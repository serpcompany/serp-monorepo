import{h as e}from"../../nitro/nitro.mjs";import{h as t,T as i,s,S as r,i as n,j as a,k as l,l as o,P as c,n as u,C as h,V as d,o as f,q as m,r as p,t as y,u as g,v as b,x as S,y as w,z as Q,A as $,B as L,W as T,D as v,E as C,F as N,G as B,H as x}from"./db/schema.mjs";class ConsoleLogWriter{static[t]="ConsoleLogWriter";write(e){console.log(e)}}class DefaultLogger{static[t]="DefaultLogger";writer;constructor(e){this.writer=e?.writer??new ConsoleLogWriter}logQuery(e,t){const i=t.map((e=>{try{return JSON.stringify(e)}catch{return String(e)}})),s=i.length?` -- params: [${i.join(", ")}]`:"";this.writer.write(`Query: ${e}${s}`)}}class NoopLogger{static[t]="NoopLogger";logQuery(){}}const R=Symbol.for("drizzle:PgInlineForeignKeys"),A=Symbol.for("drizzle:EnableRLS");class PgTable extends i{static[t]="PgTable";static Symbol=Object.assign({},i.Symbol,{InlineForeignKeys:R,EnableRLS:A});[R]=[];[A]=!1;[i.Symbol.ExtraConfigBuilder]=void 0}class PrimaryKeyBuilder{static[t]="PgPrimaryKeyBuilder";columns;name;constructor(e,t){this.columns=e,this.name=t}build(e){return new PrimaryKey(e,this.columns,this.name)}}class PrimaryKey{constructor(e,t,i){this.table=e,this.columns=t,this.name=i}static[t]="PgPrimaryKey";columns;name;getName(){return this.name??`${this.table[PgTable.Symbol.Name]}_${this.columns.map((e=>e.name)).join("_")}_pk`}}function bindIfParam(e,t){return!a(t)||l(e)||o(e,c)||o(e,u)||o(e,h)||o(e,i)||o(e,d)?e:new c(e,t)}const eq=(e,t)=>s`${e} = ${bindIfParam(t,e)}`,ne=(e,t)=>s`${e} <> ${bindIfParam(t,e)}`;function and(...e){const t=e.filter((e=>void 0!==e));if(0!==t.length)return 1===t.length?new r(t):new r([new n("("),s.join(t,new n(" and ")),new n(")")])}function or(...e){const t=e.filter((e=>void 0!==e));if(0!==t.length)return 1===t.length?new r(t):new r([new n("("),s.join(t,new n(" or ")),new n(")")])}function not(e){return s`not ${e}`}const gt=(e,t)=>s`${e} > ${bindIfParam(t,e)}`,gte=(e,t)=>s`${e} >= ${bindIfParam(t,e)}`,lt=(e,t)=>s`${e} < ${bindIfParam(t,e)}`,lte=(e,t)=>s`${e} <= ${bindIfParam(t,e)}`;function inArray(e,t){return Array.isArray(t)?0===t.length?s`false`:s`${e} in ${t.map((t=>bindIfParam(t,e)))}`:s`${e} in ${bindIfParam(t,e)}`}function notInArray(e,t){return Array.isArray(t)?0===t.length?s`true`:s`${e} not in ${t.map((t=>bindIfParam(t,e)))}`:s`${e} not in ${bindIfParam(t,e)}`}function isNull(e){return s`${e} is null`}function isNotNull(e){return s`${e} is not null`}function exists(e){return s`exists ${e}`}function notExists(e){return s`not exists ${e}`}function between(e,t,i){return s`${e} between ${bindIfParam(t,e)} and ${bindIfParam(i,e)}`}function notBetween(e,t,i){return s`${e} not between ${bindIfParam(t,e)} and ${bindIfParam(i,e)}`}function like(e,t){return s`${e} like ${t}`}function notLike(e,t){return s`${e} not like ${t}`}function ilike(e,t){return s`${e} ilike ${t}`}function notIlike(e,t){return s`${e} not ilike ${t}`}function asc(e){return s`${e} asc`}function desc(e){return s`${e} desc`}class Relation{constructor(e,t,s){this.sourceTable=e,this.referencedTable=t,this.relationName=s,this.referencedTableName=t[i.Symbol.Name]}static[t]="Relation";referencedTableName;fieldName}class Relations{constructor(e,t){this.table=e,this.config=t}static[t]="Relations"}class One extends Relation{constructor(e,t,i,s){super(e,t,i?.relationName),this.config=i,this.isNullable=s}static[t]="One";withFieldName(e){const t=new One(this.sourceTable,this.referencedTable,this.config,this.isNullable);return t.fieldName=e,t}}class Many extends Relation{constructor(e,t,i){super(e,t,i?.relationName),this.config=i}static[t]="Many";withFieldName(e){const t=new Many(this.sourceTable,this.referencedTable,this.config);return t.fieldName=e,t}}function createOne(e){return function(t,i){return new One(e,t,i,i?.fields.reduce(((e,t)=>e&&t.notNull),!0)??!1)}}function createMany(e){return function(t,i){return new Many(e,t,i)}}function normalizeRelation(e,t,s){if(o(s,One)&&s.config)return{fields:s.config.fields,references:s.config.references};const r=t[f(s.referencedTable)];if(!r)throw new Error(`Table "${s.referencedTable[i.Symbol.Name]}" not found in schema`);const n=e[r];if(!n)throw new Error(`Table "${r}" not found in schema`);const a=s.sourceTable,l=t[f(a)];if(!l)throw new Error(`Table "${a[i.Symbol.Name]}" not found in schema`);const c=[];for(const e of Object.values(n.relations))(s.relationName&&s!==e&&e.relationName===s.relationName||!s.relationName&&e.referencedTable===s.sourceTable)&&c.push(e);if(c.length>1)throw s.relationName?new Error(`There are multiple relations with name "${s.relationName}" in table "${r}"`):new Error(`There are multiple relations between "${r}" and "${s.sourceTable[i.Symbol.Name]}". Please specify relation name`);if(c[0]&&o(c[0],One)&&c[0].config)return{fields:c[0].config.references,references:c[0].config.fields};throw new Error(`There is not enough information to infer relation "${l}.${s.fieldName}"`)}function createTableRelationsHelpers(e){return{one:createOne(e),many:createMany(e)}}function mapRelationalRow(e,t,i,s,n=e=>e){const a={};for(const[l,c]of s.entries())if(c.isJson){const s=t.relations[c.tsKey],r=i[l],u="string"==typeof r?JSON.parse(r):r;a[c.tsKey]=o(s,One)?u&&mapRelationalRow(e,e[c.relationTableTsKey],u,c.selection,n):u.map((t=>mapRelationalRow(e,e[c.relationTableTsKey],t,c.selection,n)))}else{const e=n(i[l]),t=c.field;let s;s=o(t,h)?t:o(t,r)?t.decoder:t.sql.decoder,a[c.tsKey]=null===e?null:s.mapFromDriverValue(e)}return a}class ColumnAliasProxyHandler{constructor(e){this.table=e}static[t]="ColumnAliasProxyHandler";get(e,t){return"table"===t?this.table:e[t]}}class TableAliasProxyHandler{constructor(e,t){this.alias=e,this.replaceOriginalName=t}static[t]="TableAliasProxyHandler";get(e,t){if(t===i.Symbol.IsAlias)return!0;if(t===i.Symbol.Name)return this.alias;if(this.replaceOriginalName&&t===i.Symbol.OriginalName)return this.alias;if(t===m)return{...e[m],name:this.alias,isAlias:!0};if(t===i.Symbol.Columns){const t=e[i.Symbol.Columns];if(!t)return t;const s={};return Object.keys(t).map((i=>{s[i]=new Proxy(t[i],new ColumnAliasProxyHandler(new Proxy(e,this)))})),s}const s=e[t];return o(s,h)?new Proxy(s,new ColumnAliasProxyHandler(new Proxy(e,this))):s}}function aliasedTable(e,t){return new Proxy(e,new TableAliasProxyHandler(t,!1))}function aliasedTableColumn(e,t){return new Proxy(e,new ColumnAliasProxyHandler(new Proxy(e.table,new TableAliasProxyHandler(t,!1))))}function mapColumnsInAliasedSQLToAlias(e,t){return new r.Aliased(mapColumnsInSQLToAlias(e.sql,t),e.fieldAlias)}function mapColumnsInSQLToAlias(e,t){return s.join(e.queryChunks.map((e=>o(e,h)?aliasedTableColumn(e,t):o(e,r)?mapColumnsInSQLToAlias(e,t):o(e,r.Aliased)?mapColumnsInAliasedSQLToAlias(e,t):e)))}class SelectionProxyHandler{static[t]="SelectionProxyHandler";config;constructor(e){this.config={...e}}get(e,t){if("_"===t)return{...e._,selectedFields:new Proxy(e._.selectedFields,this)};if(t===m)return{...e[m],selectedFields:new Proxy(e[m].selectedFields,this)};if("symbol"==typeof t)return e[t];const i=(o(e,p)?e._.selectedFields:o(e,d)?e[m].selectedFields:e)[t];if(o(i,r.Aliased)){if("sql"===this.config.sqlAliasedBehavior&&!i.isSelectionField)return i.sql;const e=i.clone();return e.isSelectionField=!0,e}if(o(i,r)){if("sql"===this.config.sqlBehavior)return i;throw new Error(`You tried to reference "${t}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`)}return o(i,h)?this.config.alias?new Proxy(i,new ColumnAliasProxyHandler(new Proxy(i.table,new TableAliasProxyHandler(this.config.alias,this.config.replaceOriginalName??!1)))):i:"object"!=typeof i||null===i?i:new Proxy(i,new SelectionProxyHandler(this.config))}}class QueryPromise{static[t]="QueryPromise";[Symbol.toStringTag]="QueryPromise";catch(e){return this.then(void 0,e)}finally(e){return this.then((t=>(e?.(),t)),(t=>{throw e?.(),t}))}then(e,t){return this.execute().then(e,t)}}class SQLiteDeleteBase extends QueryPromise{constructor(e,t,i,s){super(),this.table=e,this.session=t,this.dialect=i,this.config={table:e,withList:s}}static[t]="SQLiteDelete";config;where(e){return this.config.where=e,this}orderBy(...e){if("function"==typeof e[0]){const t=e[0](new Proxy(this.config.table[i.Symbol.Columns],new SelectionProxyHandler({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),s=Array.isArray(t)?t:[t];this.config.orderBy=s}else{const t=e;this.config.orderBy=t}return this}limit(e){return this.config.limit=e,this}returning(e=this.table[g.Symbol.Columns]){return this.config.returning=y(e),this}getSQL(){return this.dialect.buildDeleteQuery(this.config)}toSQL(){const{typings:e,...t}=this.dialect.sqlToQuery(this.getSQL());return t}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(e){return this._prepare().execute(e)}$dynamic(){return this}}function toSnakeCase(e){return(e.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).map((e=>e.toLowerCase())).join("_")}function toCamelCase(e){return(e.replace(/['\u2019]/g,"").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g)??[]).reduce(((e,t,i)=>e+(0===i?t.toLowerCase():`${t[0].toUpperCase()}${t.slice(1)}`)),"")}function noopCase(e){return e}class CasingCache{static[t]="CasingCache";cache={};cachedTables={};convert;constructor(e){this.convert="snake_case"===e?toSnakeCase:"camelCase"===e?toCamelCase:noopCase}getColumnCasing(e){if(!e.keyAsName)return e.name;const t=`${e.table[i.Symbol.Schema]??"public"}.${e.table[i.Symbol.OriginalName]}.${e.name}`;return this.cache[t]||this.cacheTable(e.table),this.cache[t]}cacheTable(e){const t=`${e[i.Symbol.Schema]??"public"}.${e[i.Symbol.OriginalName]}`;if(!this.cachedTables[t]){for(const s of Object.values(e[i.Symbol.Columns])){const e=`${t}.${s.name}`;this.cache[e]=this.convert(s.name)}this.cachedTables[t]=!0}}clearCache(){this.cache={},this.cachedTables={}}}class DrizzleError extends Error{static[t]="DrizzleError";constructor({message:e,cause:t}){super(e),this.name="DrizzleError",this.cause=t}}class TransactionRollbackError extends DrizzleError{static[t]="TransactionRollbackError";constructor(){super({message:"Rollback"})}}class SQLiteViewBase extends d{static[t]="SQLiteViewBase"}class SQLiteDialect{static[t]="SQLiteDialect";casing;constructor(e){this.casing=new CasingCache(e?.casing)}escapeName(e){return`"${e}"`}escapeParam(e){return"?"}escapeString(e){return`'${e.replace(/'/g,"''")}'`}buildWithCTE(e){if(!e?.length)return;const t=[s`with `];for(const[i,r]of e.entries())t.push(s`${s.identifier(r._.alias)} as (${r._.sql})`),i<e.length-1&&t.push(s`, `);return t.push(s` `),s.join(t)}buildDeleteQuery({table:e,where:t,returning:i,withList:r,limit:n,orderBy:a}){const l=this.buildWithCTE(r),o=i?s` returning ${this.buildSelection(i,{isSingleTable:!0})}`:void 0,c=t?s` where ${t}`:void 0,u=this.buildOrderBy(a),h=this.buildLimit(n);return s`${l}delete from ${e}${c}${o}${u}${h}`}buildUpdateSet(e,t){const r=e[i.Symbol.Columns],n=Object.keys(r).filter((e=>void 0!==t[e]||void 0!==r[e]?.onUpdateFn)),a=n.length;return s.join(n.flatMap(((e,i)=>{const n=r[e],l=t[e]??s.param(n.onUpdateFn(),n),o=s`${s.identifier(this.casing.getColumnCasing(n))} = ${l}`;return i<a-1?[o,s.raw(", ")]:[o]})))}buildUpdateQuery({table:e,set:t,where:i,returning:r,withList:n,joins:a,from:l,limit:o,orderBy:c}){const u=this.buildWithCTE(n),h=this.buildUpdateSet(e,t),d=l&&s.join([s.raw(" from "),this.buildFromTable(l)]),f=this.buildJoins(a),m=r?s` returning ${this.buildSelection(r,{isSingleTable:!0})}`:void 0,p=i?s` where ${i}`:void 0,y=this.buildOrderBy(c),g=this.buildLimit(o);return s`${u}update ${e} set ${h}${d}${f}${p}${m}${y}${g}`}buildSelection(e,{isSingleTable:t=!1}={}){const n=e.length,a=e.flatMap((({field:e},a)=>{const l=[];if(o(e,r.Aliased)&&e.isSelectionField)l.push(s.identifier(e.fieldAlias));else if(o(e,r.Aliased)||o(e,r)){const i=o(e,r.Aliased)?e.sql:e;t?l.push(new r(i.queryChunks.map((e=>o(e,h)?s.identifier(this.casing.getColumnCasing(e)):e)))):l.push(i),o(e,r.Aliased)&&l.push(s` as ${s.identifier(e.fieldAlias)}`)}else if(o(e,h)){const r=e.table[i.Symbol.Name];t?l.push(s.identifier(this.casing.getColumnCasing(e))):l.push(s`${s.identifier(r)}.${s.identifier(this.casing.getColumnCasing(e))}`)}return a<n-1&&l.push(s`, `),l}));return s.join(a)}buildJoins(e){if(!e||0===e.length)return;const t=[];if(e)for(const[i,r]of e.entries()){0===i&&t.push(s` `);const n=r.table;if(o(n,g)){const e=n[g.Symbol.Name],i=n[g.Symbol.Schema],a=n[g.Symbol.OriginalName],l=e===a?void 0:r.alias;t.push(s`${s.raw(r.joinType)} join ${i?s`${s.identifier(i)}.`:void 0}${s.identifier(a)}${l&&s` ${s.identifier(l)}`} on ${r.on}`)}else t.push(s`${s.raw(r.joinType)} join ${n} on ${r.on}`);i<e.length-1&&t.push(s` `)}return s.join(t)}buildLimit(e){return"object"==typeof e||"number"==typeof e&&e>=0?s` limit ${e}`:void 0}buildOrderBy(e){const t=[];if(e)for(const[i,r]of e.entries())t.push(r),i<e.length-1&&t.push(s`, `);return t.length>0?s` order by ${s.join(t)}`:void 0}buildFromTable(e){return o(e,i)&&e[i.Symbol.OriginalName]!==e[i.Symbol.Name]?s`${s.identifier(e[i.Symbol.OriginalName])} ${s.identifier(e[i.Symbol.Name])}`:e}buildSelectQuery({withList:e,fields:t,fieldsFlat:n,where:a,having:l,table:c,joins:u,orderBy:d,groupBy:f,limit:g,offset:S,distinct:w,setOperators:Q}){const $=n??y(t);for(const e of $)if(o(e.field,h)&&b(e.field.table)!==(o(c,p)?c._.alias:o(c,SQLiteViewBase)?c[m].name:o(c,r)?void 0:b(c))&&!(e=>u?.some((({alias:t})=>t===(e[i.Symbol.IsAlias]?b(e):e[i.Symbol.BaseName]))))(e.field.table)){const t=b(e.field.table);throw new Error(`Your "${e.path.join("->")}" field references a column "${t}"."${e.field.name}", but the table "${t}" is not part of the query! Did you forget to join it?`)}const L=!u||0===u.length,T=this.buildWithCTE(e),v=w?s` distinct`:void 0,C=this.buildSelection($,{isSingleTable:L}),N=this.buildFromTable(c),B=this.buildJoins(u),x=a?s` where ${a}`:void 0,R=l?s` having ${l}`:void 0,A=[];if(f)for(const[e,t]of f.entries())A.push(t),e<f.length-1&&A.push(s`, `);const q=A.length>0?s` group by ${s.join(A)}`:void 0,O=this.buildOrderBy(d),P=this.buildLimit(g),j=S?s` offset ${S}`:void 0,_=s`${T}select${v} ${C} from ${N}${B}${x}${q}${R}${O}${P}${j}`;return Q.length>0?this.buildSetOperations(_,Q):_}buildSetOperations(e,t){const[i,...s]=t;if(!i)throw new Error("Cannot pass undefined values to any set operator");return 0===s.length?this.buildSetOperationQuery({leftSelect:e,setOperator:i}):this.buildSetOperations(this.buildSetOperationQuery({leftSelect:e,setOperator:i}),s)}buildSetOperationQuery({leftSelect:e,setOperator:{type:t,isAll:i,rightSelect:n,limit:a,orderBy:l,offset:c}}){const u=s`${e.getSQL()} `,h=s`${n.getSQL()}`;let d;if(l&&l.length>0){const e=[];for(const t of l)if(o(t,S))e.push(s.identifier(t.name));else if(o(t,r)){for(let e=0;e<t.queryChunks.length;e++){const i=t.queryChunks[e];o(i,S)&&(t.queryChunks[e]=s.identifier(this.casing.getColumnCasing(i)))}e.push(s`${t}`)}else e.push(s`${t}`);d=s` order by ${s.join(e,s`, `)}`}const f="object"==typeof a||"number"==typeof a&&a>=0?s` limit ${a}`:void 0,m=s.raw(`${t} ${i?"all ":""}`),p=c?s` offset ${c}`:void 0;return s`${u}${m}${h}${d}${f}${p}`}buildInsertQuery({table:e,values:t,onConflict:n,returning:a,withList:l,select:u}){const h=[],d=e[i.Symbol.Columns],f=Object.entries(d).filter((([e,t])=>!t.shouldDisableInsert())),m=f.map((([,e])=>s.identifier(this.casing.getColumnCasing(e))));if(u){const e=t;o(e,r)?h.push(e):h.push(e.getSQL())}else{const e=t;h.push(s.raw("values "));for(const[t,i]of e.entries()){const n=[];for(const[e,t]of f){const a=i[e];if(void 0===a||o(a,c)&&void 0===a.value){let e;if(null!==t.default&&void 0!==t.default)e=o(t.default,r)?t.default:s.param(t.default,t);else if(void 0!==t.defaultFn){const i=t.defaultFn();e=o(i,r)?i:s.param(i,t)}else if(t.default||void 0===t.onUpdateFn)e=s`null`;else{const i=t.onUpdateFn();e=o(i,r)?i:s.param(i,t)}n.push(e)}else n.push(a)}h.push(n),t<e.length-1&&h.push(s`, `)}}const p=this.buildWithCTE(l),y=s.join(h),g=a?s` returning ${this.buildSelection(a,{isSingleTable:!0})}`:void 0,b=n?s` on conflict ${n}`:void 0;return s`${p}insert into ${e} ${m} ${y}${b}${g}`}sqlToQuery(e,t){return e.toQuery({casing:this.casing,escapeName:this.escapeName,escapeParam:this.escapeParam,escapeString:this.escapeString,invokeSource:t})}buildRelationalQuery({fullSchema:e,schema:t,tableNamesMap:i,table:n,tableConfig:a,queryConfig:l,tableAlias:c,nestedQueryRelation:u,joinOn:d}){let m,y,b,w=[],Q=[];const $=[];if(!0===l){w=Object.entries(a.columns).map((([e,t])=>({dbKey:t.name,tsKey:e,field:aliasedTableColumn(t,c),relationTableTsKey:void 0,isJson:!1,selection:[]})))}else{const n=Object.fromEntries(Object.entries(a.columns).map((([e,t])=>[e,aliasedTableColumn(t,c)])));if(l.where){const e="function"==typeof l.where?l.where(n,{and:and,between:between,eq:eq,exists:exists,gt:gt,gte:gte,ilike:ilike,inArray:inArray,isNull:isNull,isNotNull:isNotNull,like:like,lt:lt,lte:lte,ne:ne,not:not,notBetween:notBetween,notExists:notExists,notLike:notLike,notIlike:notIlike,notInArray:notInArray,or:or,sql:s}):l.where;b=e&&mapColumnsInSQLToAlias(e,c)}const u=[];let d=[];if(l.columns){let e=!1;for(const[t,i]of Object.entries(l.columns))void 0!==i&&t in a.columns&&(e||!0!==i||(e=!0),d.push(t));d.length>0&&(d=e?d.filter((e=>!0===l.columns?.[e])):Object.keys(a.columns).filter((e=>!d.includes(e))))}else d=Object.keys(a.columns);for(const e of d){const t=a.columns[e];u.push({tsKey:e,value:t})}let p,g=[];if(l.with&&(g=Object.entries(l.with).filter((e=>!!e[1])).map((([e,t])=>({tsKey:e,queryConfig:t,relation:a.relations[e]})))),l.extras){p="function"==typeof l.extras?l.extras(n,{sql:s}):l.extras;for(const[e,t]of Object.entries(p))u.push({tsKey:e,value:mapColumnsInAliasedSQLToAlias(t,c)})}for(const{tsKey:e,value:t}of u)w.push({dbKey:o(t,r.Aliased)?t.fieldAlias:a.columns[e].name,tsKey:e,field:o(t,h)?aliasedTableColumn(t,c):t,relationTableTsKey:void 0,isJson:!1,selection:[]});let S="function"==typeof l.orderBy?l.orderBy(n,{sql:s,asc:asc,desc:desc}):l.orderBy??[];Array.isArray(S)||(S=[S]),Q=S.map((e=>o(e,h)?aliasedTableColumn(e,c):mapColumnsInSQLToAlias(e,c))),m=l.limit,y=l.offset;for(const{tsKey:r,queryConfig:n,relation:a}of g){const l=normalizeRelation(t,i,a),u=i[f(a.referencedTable)],h=`${c}_${r}`,d=and(...l.fields.map(((e,t)=>eq(aliasedTableColumn(l.references[t],h),aliasedTableColumn(e,c))))),m=this.buildRelationalQuery({fullSchema:e,schema:t,tableNamesMap:i,table:e[u],tableConfig:t[u],queryConfig:o(a,One)?!0===n?{limit:1}:{...n,limit:1}:n,tableAlias:h,joinOn:d,nestedQueryRelation:a}),p=s`(${m.sql})`.as(r);w.push({dbKey:r,tsKey:r,field:p,relationTableTsKey:u,isJson:!0,selection:m.selection})}}if(0===w.length)throw new DrizzleError({message:`No fields selected for table "${a.tsName}" ("${c}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`});let L;if(b=and(d,b),u){let e=s`json_array(${s.join(w.map((({field:e})=>o(e,S)?s.identifier(this.casing.getColumnCasing(e)):o(e,r.Aliased)?e.sql:e)),s`, `)})`;o(u,Many)&&(e=s`coalesce(json_group_array(${e}), json_array())`);const t=[{dbKey:"data",tsKey:"data",field:e.as("data"),isJson:!0,relationTableTsKey:a.tsName,selection:w}];void 0!==m||void 0!==y||Q.length>0?(L=this.buildSelectQuery({table:aliasedTable(n,c),fields:{},fieldsFlat:[{path:[],field:s.raw("*")}],where:b,limit:m,offset:y,orderBy:Q,setOperators:[]}),b=void 0,m=void 0,y=void 0,Q=void 0):L=aliasedTable(n,c),L=this.buildSelectQuery({table:o(L,g)?L:new p(L,{},c),fields:{},fieldsFlat:t.map((({field:e})=>({path:[],field:o(e,h)?aliasedTableColumn(e,c):e}))),joins:$,where:b,limit:m,offset:y,orderBy:Q,setOperators:[]})}else L=this.buildSelectQuery({table:aliasedTable(n,c),fields:{},fieldsFlat:w.map((({field:e})=>({path:[],field:o(e,h)?aliasedTableColumn(e,c):e}))),joins:$,where:b,limit:m,offset:y,orderBy:Q,setOperators:[]});return{tableTsKey:a.tsName,sql:L,selection:w}}}class SQLiteSyncDialect extends SQLiteDialect{static[t]="SQLiteSyncDialect";migrate(e,t,i){const r=void 0===i||"string"==typeof i?"__drizzle_migrations":i.migrationsTable??"__drizzle_migrations",n=s`
			CREATE TABLE IF NOT EXISTS ${s.identifier(r)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;t.run(n);const a=t.values(s`SELECT id, hash, created_at FROM ${s.identifier(r)} ORDER BY created_at DESC LIMIT 1`)[0]??void 0;t.run(s`BEGIN`);try{for(const i of e)if(!a||Number(a[2])<i.folderMillis){for(const e of i.sql)t.run(s.raw(e));t.run(s`INSERT INTO ${s.identifier(r)} ("hash", "created_at") VALUES(${i.hash}, ${i.folderMillis})`)}t.run(s`COMMIT`)}catch(e){throw t.run(s`ROLLBACK`),e}}}class SQLiteAsyncDialect extends SQLiteDialect{static[t]="SQLiteAsyncDialect";async migrate(e,t,i){const r=void 0===i||"string"==typeof i?"__drizzle_migrations":i.migrationsTable??"__drizzle_migrations",n=s`
			CREATE TABLE IF NOT EXISTS ${s.identifier(r)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;await t.run(n);const a=(await t.values(s`SELECT id, hash, created_at FROM ${s.identifier(r)} ORDER BY created_at DESC LIMIT 1`))[0]??void 0;await t.transaction((async t=>{for(const i of e)if(!a||Number(a[2])<i.folderMillis){for(const e of i.sql)await t.run(s.raw(e));await t.run(s`INSERT INTO ${s.identifier(r)} ("hash", "created_at") VALUES(${i.hash}, ${i.folderMillis})`)}}))}}class TypedQueryBuilder{static[t]="TypedQueryBuilder";getSelectedFields(){return this._.selectedFields}}class SQLiteSelectBuilder{static[t]="SQLiteSelectBuilder";fields;session;dialect;withList;distinct;constructor(e){this.fields=e.fields,this.session=e.session,this.dialect=e.dialect,this.withList=e.withList,this.distinct=e.distinct}from(e){const t=!!this.fields;let i;return i=this.fields?this.fields:o(e,p)?Object.fromEntries(Object.keys(e._.selectedFields).map((t=>[t,e[t]]))):o(e,SQLiteViewBase)?e[m].selectedFields:o(e,r)?{}:w(e),new SQLiteSelectBase({table:e,fields:i,isPartialSelect:t,session:this.session,dialect:this.dialect,withList:this.withList,distinct:this.distinct})}}class SQLiteSelectQueryBuilderBase extends TypedQueryBuilder{static[t]="SQLiteSelectQueryBuilder";_;config;joinsNotNullableMap;tableName;isPartialSelect;session;dialect;constructor({table:e,fields:t,isPartialSelect:i,session:s,dialect:r,withList:n,distinct:a}){super(),this.config={withList:n,table:e,fields:{...t},distinct:a,setOperators:[]},this.isPartialSelect=i,this.session=s,this.dialect=r,this._={selectedFields:t},this.tableName=Q(e),this.joinsNotNullableMap="string"==typeof this.tableName?{[this.tableName]:!0}:{}}createJoin(e){return(t,s)=>{const n=this.tableName,a=Q(t);if("string"==typeof a&&this.config.joins?.some((e=>e.alias===a)))throw new Error(`Alias "${a}" is already used in this query`);if(!this.isPartialSelect&&(1===Object.keys(this.joinsNotNullableMap).length&&"string"==typeof n&&(this.config.fields={[n]:this.config.fields}),"string"==typeof a&&!o(t,r))){const e=o(t,p)?t._.selectedFields:o(t,d)?t[m].selectedFields:t[i.Symbol.Columns];this.config.fields[a]=e}if("function"==typeof s&&(s=s(new Proxy(this.config.fields,new SelectionProxyHandler({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.joins||(this.config.joins=[]),this.config.joins.push({on:s,table:t,joinType:e,alias:a}),"string"==typeof a)switch(e){case"left":this.joinsNotNullableMap[a]=!1;break;case"right":this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map((([e])=>[e,!1]))),this.joinsNotNullableMap[a]=!0;break;case"inner":this.joinsNotNullableMap[a]=!0;break;case"full":this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map((([e])=>[e,!1]))),this.joinsNotNullableMap[a]=!1}return this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");createSetOperator(e,t){return i=>{const s="function"==typeof i?i(getSQLiteSetOperators()):i;if(!$(this.getSelectedFields(),s.getSelectedFields()))throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return this.config.setOperators.push({type:e,isAll:t,rightSelect:s}),this}}union=this.createSetOperator("union",!1);unionAll=this.createSetOperator("union",!0);intersect=this.createSetOperator("intersect",!1);except=this.createSetOperator("except",!1);addSetOperators(e){return this.config.setOperators.push(...e),this}where(e){return"function"==typeof e&&(e=e(new Proxy(this.config.fields,new SelectionProxyHandler({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.where=e,this}having(e){return"function"==typeof e&&(e=e(new Proxy(this.config.fields,new SelectionProxyHandler({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.having=e,this}groupBy(...e){if("function"==typeof e[0]){const t=e[0](new Proxy(this.config.fields,new SelectionProxyHandler({sqlAliasedBehavior:"alias",sqlBehavior:"sql"})));this.config.groupBy=Array.isArray(t)?t:[t]}else this.config.groupBy=e;return this}orderBy(...e){if("function"==typeof e[0]){const t=e[0](new Proxy(this.config.fields,new SelectionProxyHandler({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),i=Array.isArray(t)?t:[t];this.config.setOperators.length>0?this.config.setOperators.at(-1).orderBy=i:this.config.orderBy=i}else{const t=e;this.config.setOperators.length>0?this.config.setOperators.at(-1).orderBy=t:this.config.orderBy=t}return this}limit(e){return this.config.setOperators.length>0?this.config.setOperators.at(-1).limit=e:this.config.limit=e,this}offset(e){return this.config.setOperators.length>0?this.config.setOperators.at(-1).offset=e:this.config.offset=e,this}getSQL(){return this.dialect.buildSelectQuery(this.config)}toSQL(){const{typings:e,...t}=this.dialect.sqlToQuery(this.getSQL());return t}as(e){return new Proxy(new p(this.getSQL(),this.config.fields,e),new SelectionProxyHandler({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}getSelectedFields(){return new Proxy(this.config.fields,new SelectionProxyHandler({alias:this.tableName,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}$dynamic(){return this}}class SQLiteSelectBase extends SQLiteSelectQueryBuilderBase{static[t]="SQLiteSelect";_prepare(e=!0){if(!this.session)throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");const t=y(this.config.fields),i=this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),t,"all",!0);return i.joinsNotNullableMap=this.joinsNotNullableMap,i}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.all()}}function createSetOperator(e,t){return(i,s,...r)=>{const n=[s,...r].map((i=>({type:e,isAll:t,rightSelect:i})));for(const e of n)if(!$(i.getSelectedFields(),e.rightSelect.getSelectedFields()))throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return i.addSetOperators(n)}}L(SQLiteSelectBase,[QueryPromise]);const getSQLiteSetOperators=()=>({union:q,unionAll:O,intersect:P,except:j}),q=createSetOperator("union",!1),O=createSetOperator("union",!0),P=createSetOperator("intersect",!1),j=createSetOperator("except",!1);class QueryBuilder{static[t]="SQLiteQueryBuilder";dialect;dialectConfig;constructor(e){this.dialect=o(e,SQLiteDialect)?e:void 0,this.dialectConfig=o(e,SQLiteDialect)?void 0:e}$with(e){const t=this;return{as:i=>("function"==typeof i&&(i=i(t)),new Proxy(new T(i.getSQL(),i.getSelectedFields(),e,!0),new SelectionProxyHandler({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"})))}}with(...e){const t=this;return{select:function(i){return new SQLiteSelectBuilder({fields:i??void 0,session:void 0,dialect:t.getDialect(),withList:e})},selectDistinct:function(i){return new SQLiteSelectBuilder({fields:i??void 0,session:void 0,dialect:t.getDialect(),withList:e,distinct:!0})}}}select(e){return new SQLiteSelectBuilder({fields:e??void 0,session:void 0,dialect:this.getDialect()})}selectDistinct(e){return new SQLiteSelectBuilder({fields:e??void 0,session:void 0,dialect:this.getDialect(),distinct:!0})}getDialect(){return this.dialect||(this.dialect=new SQLiteSyncDialect(this.dialectConfig)),this.dialect}}class SQLiteInsertBuilder{constructor(e,t,i,s){this.table=e,this.session=t,this.dialect=i,this.withList=s}static[t]="SQLiteInsertBuilder";values(e){if(0===(e=Array.isArray(e)?e:[e]).length)throw new Error("values() must be called with at least one value");const t=e.map((e=>{const t={},s=this.table[i.Symbol.Columns];for(const i of Object.keys(e)){const n=e[i];t[i]=o(n,r)?n:new c(n,s[i])}return t}));return new SQLiteInsertBase(this.table,t,this.session,this.dialect,this.withList)}select(e){const t="function"==typeof e?e(new QueryBuilder):e;if(!o(t,r)&&!$(this.table[v],t._.selectedFields))throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");return new SQLiteInsertBase(this.table,t,this.session,this.dialect,this.withList,!0)}}class SQLiteInsertBase extends QueryPromise{constructor(e,t,i,s,r,n){super(),this.session=i,this.dialect=s,this.config={table:e,values:t,withList:r,select:n}}static[t]="SQLiteInsert";config;returning(e=this.config.table[g.Symbol.Columns]){return this.config.returning=y(e),this}onConflictDoNothing(e={}){if(void 0===e.target)this.config.onConflict=s`do nothing`;else{const t=Array.isArray(e.target)?s`${e.target}`:s`${[e.target]}`,i=e.where?s` where ${e.where}`:s``;this.config.onConflict=s`${t} do nothing${i}`}return this}onConflictDoUpdate(e){if(e.where&&(e.targetWhere||e.setWhere))throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');const t=e.where?s` where ${e.where}`:void 0,i=e.targetWhere?s` where ${e.targetWhere}`:void 0,r=e.setWhere?s` where ${e.setWhere}`:void 0,n=Array.isArray(e.target)?s`${e.target}`:s`${[e.target]}`,a=this.dialect.buildUpdateSet(this.config.table,C(this.config.table,e.set));return this.config.onConflict=s`${n}${i} do update set ${a}${t}${r}`,this}getSQL(){return this.dialect.buildInsertQuery(this.config)}toSQL(){const{typings:e,...t}=this.dialect.sqlToQuery(this.getSQL());return t}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class SQLiteUpdateBuilder{constructor(e,t,i,s){this.table=e,this.session=t,this.dialect=i,this.withList=s}static[t]="SQLiteUpdateBuilder";set(e){return new SQLiteUpdateBase(this.table,C(this.table,e),this.session,this.dialect,this.withList)}}class SQLiteUpdateBase extends QueryPromise{constructor(e,t,i,s,r){super(),this.session=i,this.dialect=s,this.config={set:t,table:e,withList:r,joins:[]}}static[t]="SQLiteUpdate";config;from(e){return this.config.from=e,this}createJoin(e){return(t,s)=>{const r=Q(t);if("string"==typeof r&&this.config.joins.some((e=>e.alias===r)))throw new Error(`Alias "${r}" is already used in this query`);if("function"==typeof s){const e=this.config.from?o(t,g)?t[i.Symbol.Columns]:o(t,p)?t._.selectedFields:o(t,SQLiteViewBase)?t[m].selectedFields:void 0:void 0;s=s(new Proxy(this.config.table[i.Symbol.Columns],new SelectionProxyHandler({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})),e&&new Proxy(e,new SelectionProxyHandler({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))}return this.config.joins.push({on:s,table:t,joinType:e,alias:r}),this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");where(e){return this.config.where=e,this}orderBy(...e){if("function"==typeof e[0]){const t=e[0](new Proxy(this.config.table[i.Symbol.Columns],new SelectionProxyHandler({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),s=Array.isArray(t)?t:[t];this.config.orderBy=s}else{const t=e;this.config.orderBy=t}return this}limit(e){return this.config.limit=e,this}returning(e=this.config.table[g.Symbol.Columns]){return this.config.returning=y(e),this}getSQL(){return this.dialect.buildUpdateQuery(this.config)}toSQL(){const{typings:e,...t}=this.dialect.sqlToQuery(this.getSQL());return t}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class SQLiteCountBuilder extends r{constructor(e){super(SQLiteCountBuilder.buildEmbeddedCount(e.source,e.filters).queryChunks),this.params=e,this.session=e.session,this.sql=SQLiteCountBuilder.buildCount(e.source,e.filters)}sql;static[t]="SQLiteCountBuilderAsync";[Symbol.toStringTag]="SQLiteCountBuilderAsync";session;static buildEmbeddedCount(e,t){return s`(select count(*) from ${e}${s.raw(" where ").if(t)}${t})`}static buildCount(e,t){return s`select count(*) from ${e}${s.raw(" where ").if(t)}${t}`}then(e,t){return Promise.resolve(this.session.count(this.sql)).then(e,t)}catch(e){return this.then(void 0,e)}finally(e){return this.then((t=>(e?.(),t)),(t=>{throw e?.(),t}))}}class RelationalQueryBuilder{constructor(e,t,i,s,r,n,a,l){this.mode=e,this.fullSchema=t,this.schema=i,this.tableNamesMap=s,this.table=r,this.tableConfig=n,this.dialect=a,this.session=l}static[t]="SQLiteAsyncRelationalQueryBuilder";findMany(e){return"sync"===this.mode?new SQLiteSyncRelationalQuery(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e||{},"many"):new SQLiteRelationalQuery(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e||{},"many")}findFirst(e){return"sync"===this.mode?new SQLiteSyncRelationalQuery(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e?{...e,limit:1}:{limit:1},"first"):new SQLiteRelationalQuery(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e?{...e,limit:1}:{limit:1},"first")}}class SQLiteRelationalQuery extends QueryPromise{constructor(e,t,i,s,r,n,a,l,o){super(),this.fullSchema=e,this.schema=t,this.tableNamesMap=i,this.table=s,this.tableConfig=r,this.dialect=n,this.session=a,this.config=l,this.mode=o}static[t]="SQLiteAsyncRelationalQuery";mode;getSQL(){return this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}).sql}_prepare(e=!1){const{query:t,builtQuery:i}=this._toSQL();return this.session[e?"prepareOneTimeQuery":"prepareQuery"](i,void 0,"first"===this.mode?"get":"all",!0,((e,i)=>{const s=e.map((e=>mapRelationalRow(this.schema,this.tableConfig,e,t.selection,i)));return"first"===this.mode?s[0]:s}))}prepare(){return this._prepare(!1)}_toSQL(){const e=this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName});return{query:e,builtQuery:this.dialect.sqlToQuery(e.sql)}}toSQL(){return this._toSQL().builtQuery}executeRaw(){return"first"===this.mode?this._prepare(!1).get():this._prepare(!1).all()}async execute(){return this.executeRaw()}}class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery{static[t]="SQLiteSyncRelationalQuery";sync(){return this.executeRaw()}}class SQLiteRaw extends QueryPromise{constructor(e,t,i,s,r){super(),this.execute=e,this.getSQL=t,this.dialect=s,this.mapBatchResult=r,this.config={action:i}}static[t]="SQLiteRaw";config;getQuery(){return{...this.dialect.sqlToQuery(this.getSQL()),method:this.config.action}}mapResult(e,t){return t?this.mapBatchResult(e):e}_prepare(){return this}isResponseInArrayMode(){return!1}}class BaseSQLiteDatabase{constructor(e,t,i,s){this.resultKind=e,this.dialect=t,this.session=i,this._=s?{schema:s.schema,fullSchema:s.fullSchema,tableNamesMap:s.tableNamesMap}:{schema:void 0,fullSchema:{},tableNamesMap:{}},this.query={};const r=this.query;if(this._.schema)for(const[n,a]of Object.entries(this._.schema))r[n]=new RelationalQueryBuilder(e,s.fullSchema,this._.schema,this._.tableNamesMap,s.fullSchema[n],a,t,i)}static[t]="BaseSQLiteDatabase";query;$with(e){const t=this;return{as:i=>("function"==typeof i&&(i=i(new QueryBuilder(t.dialect))),new Proxy(new T(i.getSQL(),i.getSelectedFields(),e,!0),new SelectionProxyHandler({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"})))}}$count(e,t){return new SQLiteCountBuilder({source:e,filters:t,session:this.session})}with(...e){const t=this;return{select:function(i){return new SQLiteSelectBuilder({fields:i??void 0,session:t.session,dialect:t.dialect,withList:e})},selectDistinct:function(i){return new SQLiteSelectBuilder({fields:i??void 0,session:t.session,dialect:t.dialect,withList:e,distinct:!0})},update:function(i){return new SQLiteUpdateBuilder(i,t.session,t.dialect,e)},insert:function(i){return new SQLiteInsertBuilder(i,t.session,t.dialect,e)},delete:function(i){return new SQLiteDeleteBase(i,t.session,t.dialect,e)}}}select(e){return new SQLiteSelectBuilder({fields:e??void 0,session:this.session,dialect:this.dialect})}selectDistinct(e){return new SQLiteSelectBuilder({fields:e??void 0,session:this.session,dialect:this.dialect,distinct:!0})}update(e){return new SQLiteUpdateBuilder(e,this.session,this.dialect)}insert(e){return new SQLiteInsertBuilder(e,this.session,this.dialect)}delete(e){return new SQLiteDeleteBase(e,this.session,this.dialect)}run(e){const t="string"==typeof e?s.raw(e):e.getSQL();return"async"===this.resultKind?new SQLiteRaw((async()=>this.session.run(t)),(()=>t),"run",this.dialect,this.session.extractRawRunValueFromBatchResult.bind(this.session)):this.session.run(t)}all(e){const t="string"==typeof e?s.raw(e):e.getSQL();return"async"===this.resultKind?new SQLiteRaw((async()=>this.session.all(t)),(()=>t),"all",this.dialect,this.session.extractRawAllValueFromBatchResult.bind(this.session)):this.session.all(t)}get(e){const t="string"==typeof e?s.raw(e):e.getSQL();return"async"===this.resultKind?new SQLiteRaw((async()=>this.session.get(t)),(()=>t),"get",this.dialect,this.session.extractRawGetValueFromBatchResult.bind(this.session)):this.session.get(t)}values(e){const t="string"==typeof e?s.raw(e):e.getSQL();return"async"===this.resultKind?new SQLiteRaw((async()=>this.session.values(t)),(()=>t),"values",this.dialect,this.session.extractRawValuesValueFromBatchResult.bind(this.session)):this.session.values(t)}transaction(e,t){return this.session.transaction(e,t)}}class ExecuteResultSync extends QueryPromise{constructor(e){super(),this.resultCb=e}static[t]="ExecuteResultSync";async execute(){return this.resultCb()}sync(){return this.resultCb()}}class SQLitePreparedQuery{constructor(e,t,i){this.mode=e,this.executeMethod=t,this.query=i}static[t]="PreparedQuery";joinsNotNullableMap;getQuery(){return this.query}mapRunResult(e,t){return e}mapAllResult(e,t){throw new Error("Not implemented")}mapGetResult(e,t){throw new Error("Not implemented")}execute(e){return"async"===this.mode?this[this.executeMethod](e):new ExecuteResultSync((()=>this[this.executeMethod](e)))}mapResult(e,t){switch(this.executeMethod){case"run":return this.mapRunResult(e,t);case"all":return this.mapAllResult(e,t);case"get":return this.mapGetResult(e,t)}}}class SQLiteSession{constructor(e){this.dialect=e}static[t]="SQLiteSession";prepareOneTimeQuery(e,t,i,s){return this.prepareQuery(e,t,i,s)}run(e){const t=this.dialect.sqlToQuery(e);try{return this.prepareOneTimeQuery(t,void 0,"run",!1).run()}catch(e){throw new DrizzleError({cause:e,message:`Failed to run the query '${t.sql}'`})}}extractRawRunValueFromBatchResult(e){return e}all(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).all()}extractRawAllValueFromBatchResult(e){throw new Error("Not implemented")}get(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).get()}extractRawGetValueFromBatchResult(e){throw new Error("Not implemented")}values(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).values()}async count(e){return(await this.values(e))[0][0]}extractRawValuesValueFromBatchResult(e){throw new Error("Not implemented")}}class SQLiteTransaction extends BaseSQLiteDatabase{constructor(e,t,i,s,r=0){super(e,t,i,s),this.schema=s,this.nestedIndex=r}static[t]="SQLiteTransaction";rollback(){throw new TransactionRollbackError}}class SQLiteD1Session extends SQLiteSession{constructor(e,t,i,s={}){super(t),this.client=e,this.schema=i,this.options=s,this.logger=s.logger??new NoopLogger}static[t]="SQLiteD1Session";logger;prepareQuery(e,t,i,s,r){const n=this.client.prepare(e.sql);return new D1PreparedQuery(n,e,this.logger,t,i,s,r)}async batch(e){const t=[],i=[];for(const s of e){const e=s._prepare(),r=e.getQuery();if(t.push(e),r.params.length>0)i.push(e.stmt.bind(...r.params));else{const t=e.getQuery();i.push(this.client.prepare(t.sql).bind(...t.params))}}return(await this.client.batch(i)).map(((e,i)=>t[i].mapResult(e,!0)))}extractRawAllValueFromBatchResult(e){return e.results}extractRawGetValueFromBatchResult(e){return e.results[0]}extractRawValuesValueFromBatchResult(e){return d1ToRawMapping(e.results)}async transaction(e,t){const i=new D1Transaction("async",this.dialect,this,this.schema);await this.run(s.raw("begin"+(t?.behavior?" "+t.behavior:"")));try{const t=await e(i);return await this.run(s`commit`),t}catch(e){throw await this.run(s`rollback`),e}}}class D1Transaction extends SQLiteTransaction{static[t]="D1Transaction";async transaction(e){const t=`sp${this.nestedIndex}`,i=new D1Transaction("async",this.dialect,this.session,this.schema,this.nestedIndex+1);await this.session.run(s.raw(`savepoint ${t}`));try{const r=await e(i);return await this.session.run(s.raw(`release savepoint ${t}`)),r}catch(e){throw await this.session.run(s.raw(`rollback to savepoint ${t}`)),e}}}function d1ToRawMapping(e){const t=[];for(const i of e){const e=Object.keys(i).map((e=>i[e]));t.push(e)}return t}class D1PreparedQuery extends SQLitePreparedQuery{constructor(e,t,i,s,r,n,a){super("async",r,t),this.logger=i,this._isResponseInArrayMode=n,this.customResultMapper=a,this.fields=s,this.stmt=e}static[t]="D1PreparedQuery";customResultMapper;fields;stmt;run(e){const t=N(this.query.params,e??{});return this.logger.logQuery(this.query.sql,t),this.stmt.bind(...t).run()}async all(e){const{fields:t,query:i,logger:s,stmt:r,customResultMapper:n}=this;if(!t&&!n){const t=N(i.params,e??{});return s.logQuery(i.sql,t),r.bind(...t).all().then((({results:e})=>this.mapAllResult(e)))}const a=await this.values(e);return this.mapAllResult(a)}mapAllResult(e,t){return t&&(e=d1ToRawMapping(e.results)),this.fields||this.customResultMapper?this.customResultMapper?this.customResultMapper(e):e.map((e=>B(this.fields,e,this.joinsNotNullableMap))):e}async get(e){const{fields:t,joinsNotNullableMap:i,query:s,logger:r,stmt:n,customResultMapper:a}=this;if(!t&&!a){const t=N(s.params,e??{});return r.logQuery(s.sql,t),n.bind(...t).all().then((({results:e})=>e[0]))}const l=await this.values(e);if(l[0])return a?a(l):B(t,l[0],i)}mapGetResult(e,t){return t&&(e=d1ToRawMapping(e.results)[0]),this.fields||this.customResultMapper?this.customResultMapper?this.customResultMapper([e]):B(this.fields,e,this.joinsNotNullableMap):e}values(e){const t=N(this.query.params,e??{});return this.logger.logQuery(this.query.sql,t),this.stmt.bind(...t).raw()}isResponseInArrayMode(){return this._isResponseInArrayMode}}class DrizzleD1Database extends BaseSQLiteDatabase{static[t]="D1Database";async batch(e){return this.session.batch(e)}}function drizzle(e,t={}){const s=new SQLiteAsyncDialect({casing:t.casing});let r,n;if(!0===t.logger?r=new DefaultLogger:!1!==t.logger&&(r=t.logger),t.schema){const e=function(e,t){1===Object.keys(e).length&&"default"in e&&!o(e.default,i)&&(e=e.default);const s={},r={},n={};for(const[a,l]of Object.entries(e))if(o(l,i)){const e=f(l),t=r[e];s[e]=a,n[a]={tsName:a,dbName:l[i.Symbol.Name],schema:l[i.Symbol.Schema],columns:l[i.Symbol.Columns],relations:t?.relations??{},primaryKey:t?.primaryKey??[]};for(const e of Object.values(l[i.Symbol.Columns]))e.primary&&n[a].primaryKey.push(e);const c=l[i.Symbol.ExtraConfigBuilder]?.(l[i.Symbol.ExtraConfigColumns]);if(c)for(const e of Object.values(c))o(e,PrimaryKeyBuilder)&&n[a].primaryKey.push(...e.columns)}else if(o(l,Relations)){const e=f(l.table),i=s[e],a=l.config(t(l.table));let o;for(const[t,s]of Object.entries(a))i?n[i].relations[t]=s:(e in r||(r[e]={relations:{},primaryKey:o}),r[e].relations[t]=s)}return{tables:n,tableNamesMap:s}}(t.schema,createTableRelationsHelpers);n={fullSchema:t.schema,schema:e.tables,tableNamesMap:e.tableNamesMap}}const a=new SQLiteD1Session(e,s,n,{logger:r}),l=new DrizzleD1Database("async",s,a,n);return l.$client=e,l}const _=x;function useDrizzle(){return drizzle(e(),{schema:x})}const M=Object.freeze(Object.defineProperty({__proto__:null,and:and,eq:eq,or:or,get sql(){return s},tables:_,useDrizzle:useDrizzle},Symbol.toStringTag,{value:"Module"}));export{asc as a,and as b,desc as d,eq as e,M as i,useDrizzle as u};
//# sourceMappingURL=index5.mjs.map
