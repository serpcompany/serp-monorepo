import{d as e,g as t,c as r}from"../../nitro/nitro.mjs";import{u as o,e as a}from"./index5.mjs";import{g as s}from"./db/schema.mjs";import"node:buffer";import"node:process";import"node:timers";import"node:events";import"node:net";import"node:async_hooks";import"node:assert";import"node:util";import"node:url";import"node:stream";import"node:crypto";import"node:dns";import"node:string_decoder";const formatDate=e=>{if(e)try{const t=new Date(e);return isNaN(t.getTime())?e:t.toLocaleDateString("en-US",{year:"numeric",month:"long",day:"numeric"})}catch(t){return console.error(`Error formatting date: ${t.message}`),e}},i=e((async e=>{const{page:i=1,categorySlug:n,module:m=""}=t(e),d=Number(i);if(isNaN(d)||d<1||!Number.isInteger(d))throw r({statusCode:400,message:"Page must be a positive integer."});let c="";c=m&&n?`${m}-${n}-${d}`:m?`${m}-${d}`:n?`${n}-${d}`:`all-${d}`;const p=await o().select({data:s.data}).from(s).where(a(s.key,c)).execute();if(!p.length)throw r({statusCode:404,message:"Not found"});const g=JSON.parse(p[0].data);return{posts:g.posts.map((e=>{let t=[];try{e.categories&&("string"==typeof e.categories?t=JSON.parse(e.categories):Array.isArray(e.categories)&&(t=e.categories))}catch(t){console.error(`Error parsing categories for post ${e.id}: ${t.message}`)}return{...e,categories:t,createdAt:formatDate(e.createdAt),updatedAt:formatDate(e.updatedAt)}})),pagination:g.pagination,categoryName:g.categoryName}}));export{i as default};
//# sourceMappingURL=index6.mjs.map
