[
  {
    "owner": "posthog",
    "repo": "posthog",
    "content": "TITLE: Defining a MaxTool AI Tool (Python)\nDESCRIPTION: This Python snippet demonstrates how to define a new MaxTool for PostHog's AI assistant by subclassing MaxTool, specifying metadata, argument schema with pydantic, and implementing backend logic for tool execution. Dependencies include langchain_openai for LLM interaction, ChatPromptTemplate for prompt handling, and pydantic for argument validation. Key parameters such as name, description, and root_system_prompt_template must be defined; a _run_impl method executes backend logic and may leverage LLM models for processing. The tool is only available when the corresponding UI is mounted and requires API keys for OpenAI and Anthropic.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/hogai/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ee.hogai.tool import MaxTool\\nfrom pydantic import BaseModel, Field\\nfrom langchain_openai import ChatOpenAI\\nfrom langchain_core.prompts import ChatPromptTemplate\\n\\n# Define your tool's arguments schema\\nclass YourToolArgs(BaseModel):\\n    parameter_name: str = Field(description=\\\"Description of the parameter\\\")\\n\\nclass YourTool(MaxTool):\\n    name: str = \\\"your_tool_name\\\"  # Must match a value in AssistantContextualTool enum\\n    description: str = \\\"What this tool does\\\"\\n    thinking_message: str = \\\"What to show while tool is working\\\"\\n    root_system_prompt_template: str = \\\"Context about the tool state: {context_var}\\\" \\n    args_schema: type[BaseModel] = YourToolArgs\\n\\n    def _run_impl(self, parameter_name: str) -> tuple[str, Any]:\\n        # Implement tool logic here\\n        # Access context with self.context (must have context_var from template)\\n        \\n        # Optional: Use LLM to process inputs or generate structured outputs\\n        model = (\\n            ChatOpenAI(model=\\\"gpt-4o\\\", temperature=0.2)\\n            .with_structured_output(OutputType)\\n            .with_retry()\\n        )\\n        \\n        # Process and return results as (message, structured_data)\\n        return \\\"Tool execution completed\\\", result_data\n```\n\n----------------------------------------\n\nTITLE: Configuring Scene Settings and Route Mapping - PostHog Frontend - TypeScript\nDESCRIPTION: Establishes mapping between scenes and their configuration as well as between route URLs and scene enums. Ensures that visiting '/dashboard' correctly identifies and loads the Dashboards scene with its associated settings. Must be used in files central to routing and scene management.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const sceneConfigurations: Partial<Record<Scene, SceneConfig>> = {\n    [Scene.Dashboards]: {\n        projectBased: true,\n        name: 'Dashboards',\n    },\n}\n\nexport const routes: Record<string, Scene> = {\n    [urls.dashboards()]: Scene.Dashboards,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Lazy-Loaded Scene Imports - PostHog Frontend - TypeScript\nDESCRIPTION: Creates a lookup mapping from scene enums to dynamic import functions for lazy loading components, improving code-splitting. Requires Webpack, ES modules, and routing integration. Input: scene; output: Promise resolving to the scene's code.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const appScenes: Record<Scene, () => any> = {\n    [Scene.Dashboards]: () => import('./dashboard/Dashboards'),\n}\n```\n\n----------------------------------------\n\nTITLE: Using LemonColorPicker Component in TSX\nDESCRIPTION: Example usage of the `LemonColorPicker` component in TSX. Shows how to configure the picker with either an array of hex colors (`colors` prop) or data color tokens (`colorTokens` prop). It also demonstrates handling color selection via `onSelectColor` (for hex) or `onSelectColorToken` (for tokens) callbacks and setting the initially selected color/token. The `themeId` prop is required when using `colorTokens`.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/lib/lemon-ui/LemonColor/LemonColor.stories.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Using hex colors\n<LemonColorPicker\n    colors={['#FF0000', '#00FF00', '#0000FF']}\n    selectedColor=\"#FF0000\"\n    onSelectColor={(color) => console.log(color)}\n/>\n\n// Using data color tokens\n<LemonColorPicker\n    colorTokens={['primary', 'secondary', 'danger']}\n    selectedColorToken=\"primary\"\n    onSelectColorToken={(token) => console.log(token)}\n    themeId={1}\n/>\n```\n\n----------------------------------------\n\nTITLE: Implementing Feature Flag Logic with Kea Forms\nDESCRIPTION: Demonstrates the implementation of feature flag logic using Kea framework with form handling capabilities. Includes loaders, form validation, and submission handling.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a form.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const featureFlagLogic = kea<featureFlagLogicType<FeatureFlagLogicProps>>({\\n    path: (key) => ['scenes', 'feature-flags', 'featureFlagLogic', key],\\n    props: {} as FeatureFlagLogicProps,\\n    key: ({ id }) => id ?? 'new',\\n\\n    loaders: ({ values, props }) => ({\\n        featureFlag: [\\n            { ...NEW_FLAG } as FeatureFlagModel,\\n            {\\n                loadFeatureFlag: () => api.get(`api/projects/${values.currentProjectId}/feature_flags/${props.id}`),\\n            },\\n        ],\\n    }),\\n\\n    forms: ({ actions }) => ({\\n        featureFlag: {\\n            defaults: { ...NEW_FLAG } as FeatureFlagModel,\\n            errors: (featureFlag) => ({\\n                key: !featureFlag.key ? 'Must have a key' : undefined,\\n            }),\\n            submit: async (featureFlag, breakpoint) => {\\n                const { created_at, id, ...flag } = featureFlag\\n                const newFeatureFlag = updatedFlag.id\\n                    ? await api.update(`api/projects/${values.currentProjectId}/feature_flags/${updatedFlag.id}`, flag)\\n                    : await api.create(`api/projects/${values.currentProjectId}/feature_flags`, flag)\\n                breakpoint()\\n                actions.setFeatureFlagValues(newFeatureFlag)\\n                lemonToast.success('Feature flag saved')\\n                featureFlagsLogic.findMounted()?.actions.updateFlag(featureFlag)\\n                router.actions.replace(urls.featureFlag(featureFlag.id))\\n            },\\n        },\\n    }),\\n})\n```\n\n----------------------------------------\n\nTITLE: Using LemonColorGlyph Component in TSX\nDESCRIPTION: Example usage of the `LemonColorGlyph` component in TSX. Shows how to display a color glyph using either a direct hex color string via the `color` prop or a data color token via the `colorToken` and `themeId` props. Also demonstrates setting the glyph size using the `size` prop.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/lib/lemon-ui/LemonColor/LemonColor.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Using a hex color\n<LemonColorGlyph color=\"#FF0000\" />\n\n// Using a data token\n<LemonColorGlyph colorToken=\"primary\" themeId={1} />\n\n// Small variant\n<LemonColorGlyph color=\"#FF0000\" size=\"small\" />\n```\n\n----------------------------------------\n\nTITLE: Query Component Usage\nDESCRIPTION: Basic usage example of the Query component which internally routes to the appropriate node type.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/queries/README.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n<Query query={} setQuery={} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Action Model Class in Django\nDESCRIPTION: Defines the main Action model with fields for tracking user actions. Inherits from FileSystemSyncMixin and includes metadata fields, step configuration, and bytecode for performance. Contains methods for file system representation and saving actions with compiled bytecode.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/python.txt#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Action(FileSystemSyncMixin, models.Model):\n    name = models.CharField(max_length=400, null=True, blank=True)\n    description = models.TextField(blank=True, default=\"\")\n    team = models.ForeignKey(\"Team\", on_delete=models.CASCADE)\n    project = models.ForeignKey(\"Project\", on_delete=models.CASCADE, null=True, blank=True)\n    created_at = models.DateTimeField(auto_now_add=True, blank=True)\n    created_by = models.ForeignKey(\"User\", on_delete=models.SET_NULL, null=True, blank=True)\n    deleted = models.BooleanField(default=False)\n    events = models.ManyToManyField(\"Event\", blank=True)\n    post_to_slack = models.BooleanField(default=False)\n    slack_message_format = models.CharField(default=\"\", max_length=1200, blank=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    bytecode = models.JSONField(null=True, blank=True)\n    bytecode_error = models.TextField(blank=True, null=True)\n    steps_json = models.JSONField(null=True, blank=True)\n    pinned_at = models.DateTimeField(blank=True, null=True, default=None)\n    summary = models.TextField(blank=True, null=True, help_text=\"A summary of the action, generated by AI\")\n    last_summarized_at = models.DateTimeField(\n        blank=True, null=True, help_text=\"The last time the action was summarized by AI\"\n    )\n    embedding_last_synced_at = models.DateTimeField(\n        blank=True, null=True, help_text=\"The last time the action was synced to the vector database\"\n    )\n    embedding_version = models.PositiveSmallIntegerField(\n        blank=True, null=True, help_text=\"The version of the embedding model used to embed the action\"\n    )\n\n    # DEPRECATED: these were used before ClickHouse was our database\n    is_calculating = models.BooleanField(default=False)\n    last_calculated_at = models.DateTimeField(default=timezone.now, blank=True)\n\n    class Meta:\n        indexes = [models.Index(fields=[\"team_id\", \"-updated_at\"])]\n\n    def __str__(self):\n        return self.name\n\n    def save(self, *args, **kwargs):\n        self.refresh_bytecode()\n        super().save(*args, **kwargs)\n\n    @classmethod\n    def get_file_system_unfiled(cls, team: \"Team\") -> QuerySet[\"Action\"]:\n        base_qs = cls.objects.filter(team=team, deleted=False)\n        return cls._filter_unfiled_queryset(base_qs, team, type=\"action\", ref_field=\"id\")\n\n    def get_file_system_representation(self) -> FileSystemRepresentation:\n        return FileSystemRepresentation(\n            base_folder=\"Unfiled/Actions\",\n            type=\"action\",\n            ref=str(self.id),\n            name=self.name or \"Untitled\",\n            href=f\"/data-management/actions/{self.id}\",\n            meta={\n                \"created_at\": str(self.created_at),\n                \"created_by\": self.created_by_id,\n            },\n            should_delete=self.deleted,\n        )\n\n    def get_analytics_metadata(self):\n        return {\n            \"post_to_slack\": self.post_to_slack,\n            \"name_length\": len(self.name),\n            \"custom_slack_message_format\": self.slack_message_format != \"\",\n            \"event_count_precalc\": self.events.count(),  # `precalc` because events are computed async\n            \"step_count\": len(self.steps),\n            \"match_text_count\": sum(1 if step.text else 0 for step in self.steps),\n            \"match_href_count\": sum(1 if step.href else 0 for step in self.steps),\n            \"match_selector_count\": sum(1 if step.selector else 0 for step in self.steps),\n            \"match_url_count\": sum(1 if step.url else 0 for step in self.steps),\n            \"has_properties\": any(step.properties for step in self.steps),\n            \"deleted\": self.deleted,\n            \"pinned\": bool(self.pinned_at),\n            \"pinned_at\": self.pinned_at,\n        }\n\n    @property\n    def steps(self) -> list[ActionStepJSON]:\n        return [ActionStepJSON(**step) for step in self.steps_json or []]\n\n    @steps.setter\n    def steps(self, value: list[dict]):\n        # TRICKY: This is a little tricky as DRF will deserialize this here as a dict but typing wise we would expect an ActionStepJSON\n        self.steps_json = [asdict(ActionStepJSON(**step)) for step in value]\n\n    def get_step_events(self) -> list[Union[str, None]]:\n        return [action_step.event for action_step in self.steps]\n\n    def refresh_bytecode(self):\n        from posthog.hogql.compiler.bytecode import create_bytecode\n        from posthog.hogql.property import action_to_expr\n\n        try:\n            new_bytecode = create_bytecode(action_to_expr(self)).bytecode\n            if new_bytecode != self.bytecode or self.bytecode_error is not None:\n                self.bytecode = new_bytecode\n                self.bytecode_error = None\n        except BaseHogQLError as e:\n            # There are several known cases when bytecode generation can fail. Instead of spamming\n            # Sentry with errors, ignore those cases for now.\n            if self.bytecode is not None or self.bytecode_error != str(e):\n                self.bytecode = None\n                self.bytecode_error = str(e)\n```\n\n----------------------------------------\n\nTITLE: Feature Flag Form Component Implementation\nDESCRIPTION: React component implementation of the feature flag form using Kea forms. Shows the usage of Form, Field, and Group components with various form elements and submission handling.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a form.stories.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nexport function FeatureFlag({ id }: { id?: string } = {}): JSX.Element {\\n    const logicProps: FeatureFlagLogicProps = { id: id ? parseInt(id) : 'new' }\\n    const {\\n        featureFlag,\\n        isFeatureFlagSubmitting,\\n    } = useValues(featureFlagLogic(logicProps))\\n    const {\\n        submitFeatureFlag,\\n        setFeatureFlagValue,\\n    } = useActions(featureFlagLogic(logicProps))\\n\\n    return (\\n        <Form\\n            logic={featureFlagLogic}\\n            props={logicProps}\\n            formKey=\\\"featureFlag\\\"\\n            enableFormOnSubmit\\n        >\\n            <Field name=\\\"active\\\">\\n                {({ value, onChange }) => (\\n                    <LemonSwitch\\n                        checked={value}\\n                        onChange={onChange}\\n                        label={\\n                            value ? (\\n                                <span className=\\\"text-success\\\">Enabled</span>\\n                            ) : (\\n                                <span className=\\\"text-danger\\\">Disabled</span>\\n                            )\\n                        }\\n                    />\\n                )}\\n            </Field>\\n\\n            <Field name=\\\"name\\\" label=\\\"Description\\\">\\n                <LemonTextArea\\n                    className=\\\"ph-ignore-input\\\"\\n                    data-attr=\\\"feature-flag-description\\\"\\n                    placeholder=\\\"Adding a helpful description can ensure others know what this feature is for.\\\"\\n                />\\n            </Field>\\n\\n            {featureFlag?.filters?.multivariate?.variants?.map((_, index) => (\\n                <Group key={index} name={['filters', 'multivariate', 'variants', index]}>\\n                    <Field name=\\\"name\\\">\\n                        <LemonInput\\n                            data-attr=\\\"feature-flag-variant-name\\\"\\n                            className=\\\"ph-ignore-input\\\"\\n                            placeholder=\\\"Description\\\"\\n                        />\\n                    </Form.Item>\\n                </Group>\\n            ))}\\n\\n            <LemonButton\\n                loading={isFeatureFlagSubmitting}\\n                icon={<SaveOutlined />}\\n                htmlType=\\\"submit\\\"\\n                type=\\\"primary\\\"\\n                data-attr=\\\"feature-flag-submit-bottom\\\"\\n            >\\n                Save changes\\n            </LemonButton>\\n        </Form>\\n    )\\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking PostHog Feature Flags in Cypress Tests using JavaScript\nDESCRIPTION: This JavaScript helper function, `setupFeatureFlags`, is used within Cypress tests to intercept calls made to the `/decide` endpoint (handling both relative and absolute paths like `https://app.posthog.com/decide`). It allows defining mock responses for specific feature flags by passing an object where keys are flag names and values are their desired states (e.g., `true` or `false`). This enables testing UI or behavior changes based on feature flags without needing a live PostHog instance with those flags configured.\nSOURCE: https://github.com/posthog/posthog/blob/master/cypress/README.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// sometimes the system under test calls `/decide`\n// and sometimes it calls https://app.posthog.com/decide\nsetupFeatureFlags({\n    // add feature flags here, for e.g.\n    'feature-flag-key': true,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Kea Logic for a Scene - PostHog Frontend - TypeScript\nDESCRIPTION: Implements a Kea logic instance with a simple reducer for state management, specifically a counter, and sets a unique logic path. Requires Kea imports and integration within PostHog's modular scene architecture. Input is an implicit initial state; output is an updatable counter.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { kea, reducers, path } from 'kea'\n\nexport const dashboardsLogic = kea([\n    path(['scenes', 'dashboard', 'dashboardsLogic']),\n    reducers({\n        counter: [1, {}],\n    }),\n])\n```\n\n----------------------------------------\n\nTITLE: Mounting a MaxTool in the React Frontend (TypeScript, TSX)\nDESCRIPTION: This TSX (TypeScript React) snippet shows how to mount a MaxTool-enabled AI component in the PostHog frontend using the MaxTool wrapper. The MaxTool component is imported, configured with the backend tool's name, displayName, context for LLM prompts, and an output callback. The tool expects frontend context to be passed to the backend, and the callback receives structured output from the backend for UI updates. All key options—including initial prompt and lifecycle hooks—are highlighted; the displayed code assumes the tool has been defined in the backend and registered in the schema.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/hogai/README.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MaxTool } from 'scenes/max/MaxTool'\\n\\nfunction YourComponent() {\\n    return (\\n        <MaxTool\\n            name=\\\"your_tool_name\\\"  // Must match backend tool name - enforced by the AssistantContextualTool enum\\n            displayName=\\\"Human-friendly name\\\"\\n            context={{\\n                // Context data passed to backend - can be empty if there truly is no context\\n                context_var: relevantData,\\n            }}\\n            callback={(toolOutput) => {\\n                // Handle structured output from tool\\n                updateUIWithToolResults(toolOutput);\\n            }}\\n            initialMaxPrompt=\\\"Optional initial prompt for Max\\\"\\n            onMaxOpen={() => {\\n                // Optional actions when Max panel opens\\n            }}\\n        >\\n            {/* Your UI component that will have Max assistant */}\\n            <YourUIComponent />\\n        </MaxTool>\\n    )\\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying and Applying Mocks in Storybook with MSW - TypeScript\nDESCRIPTION: This TypeScript/React code demonstrates how to apply mocked API calls in Storybook stories using a custom abstraction over MockServiceWorker (MSW). It uses both a file-level decorator (mswDecorator) and a story-level hook (useStorybookMocks) to specify which requests get mocked and how. Key dependencies include MSW and the custom '~/mocks/browser' module; the MOCK_ARGUMENTS parameter controls the mocks. The input parameters allow for flexible, testable request-response simulation, and each approach can be used alone or in combination for different scoping requirements.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to mock requests.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// SomeScene.stories.tsx\nimport { mswDecorator, useStorybookMocks } from '~/mocks/browser'\n\nexport default {\n    title: 'Scenes-App/Some Scene',\n    decorators: [\n        // applies for all stories in file\n        mswDecorator(MOCK_ARGUMENTS),\n    ],\n}\n\nexport function Dashboard(): JSX.Element {\n    // applies to just this story\n    useStorybookMocks(MOCK_ARGUMENTS)\n    return <div />\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Storybook Story with MSW Mocks for a Scene - PostHog Frontend - TSX\nDESCRIPTION: Creates a Storybook definition for the Dashboard scene, including global and per-story API mocks using MSW, and sets up URL navigation and state through Kea router and logic actions. Dependencies: Storybook, mswDecorator, PostHog's App and logic, Kea-router. Inputs: none directly; output is a live story with dashboard state and mocked requests. Useful for isolated scene testing.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_15\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useEffect } from 'react'\nimport { Meta, StoryObj } from '@storybook/react'\nimport { mswDecorator, useStorybookMocks } from '~/mocks/browser'\nimport { App } from 'scenes/App'\nimport { router } from 'kea-router'\nimport { urls } from 'scenes/urls'\n\nexport default {\n    title: 'Scenes-App/Dashboard',\n    decorators: [\n        // mocks used by all stories in this file\n        mswDecorator({\n            get: {\n                '/api/projects/1/dashboards/': require('./__mocks__/dashboards.json'),\n                '/api/projects/1/dashboards/1/': require('./__mocks__/dashboard1.json'),\n                '/api/projects/1/dashboards/1/collaborators/': [],\n            },\n        }),\n    ],\n    // NB! These `parameters` only apply for Scene stories.\n    parameters: { layout: 'fullscreen', options: { showPanel: false }, viewMode: 'story' }, // scene mode\n} as Meta\n\nexport function NewDashboard (): JSX.Element {\n    // mocks used only in this story\n    useStorybookMocks({\n        get: { '/api/projects/dashboard/2/': require('./__mocks__/dashboard2.json') },\n    })\n    useEffect(() => {\n        // change the URL\n        router.actions.push(urls.dashboard(2))\n        // call various other actions to set the initial state\n        newDashboardLogic.actions.showNewDashboardModal()\n    }, [])\n    return <App />\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Parameterized Scene Component with Logic - PostHog Frontend - TypeScript\nDESCRIPTION: Defines a scene with URL-parameterized logic (per dashboard id) and a paramsToProps function for binding URL parameters to logic props. Uses Kea's BindLogic and coordinated routing. Expects an id in the URL; outputs a Dashboard scene referencing the id and a counter.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { dashboardLogic } from './dashboardLogic'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { useValues } from 'kea'\n\nexport const scene: SceneExport = {\n    component: Dashboard,\n    logic: dashboardLogic,\n    // paramsToProps - Convert url _string_ params to logic props.\n    // This mounts the right logic with turbo mode before the component renders.\n    // This wraps the scene's logic in <BindLogic />\n    paramsToProps: ({ params: {id} }:{ params: { id?: string }}) => ({ id: id ? parseInt(id) : 'new' }),\n}\n\nexport function Dashboard ({ id }: { id?: string } = {}): JSX.Element {\n    // dashboardLogic is automatically bound to the props above with BindLogic\n    const {\n        counter\n    } = useValues(dashboardLogic)\n\n    return (\n        // TODO: consolidate on a recommended naming convention\n        <div className='dashboard-scene'>\n            Dashboard Scene {id} {counter}!\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Using LemonColorList Component in TSX\nDESCRIPTION: Example usage of the `LemonColorList` component in TSX. Demonstrates displaying a horizontal list of color options, using either an array of hex colors (`colors` prop) or data color tokens (`colorTokens` prop). It also shows how to handle color selection via `onSelectColor` (for hex) or `onSelectColorToken` (for tokens) callbacks and set the initially selected color/token. The `themeId` prop is required when using `colorTokens`.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/lib/lemon-ui/LemonColor/LemonColor.stories.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// Using hex colors\n<LemonColorList\n    colors={['#FF0000', '#00FF00', '#0000FF']}\n    selectedColor=\"#FF0000\"\n    onSelectColor={(color) => console.log(color)}\n/>\n\n// Using data color tokens\n<LemonColorList\n    colorTokens={['primary', 'secondary', 'danger']}\n    selectedColorToken=\"primary\"\n    onSelectColorToken={(token) => console.log(token)}\n    themeId={1}\n/>\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcurrencyControllerItem Class in TypeScript\nDESCRIPTION: A class that wraps user functions with concurrency control logic. It handles execution, promise resolution/rejection, and cleanup when tasks complete. It also supports priority and abort controller integration.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/ts.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass ConcurrencyControllerItem<T> {\n    _debugTag?: string\n    _runFn: () => Promise<void>\n    _priority: number = Infinity\n    _promise: Promise<T>\n    constructor(\n        concurrencyController: ConcurrencyController,\n        userFn: () => Promise<T>,\n        abortController: AbortController | undefined,\n        priority: number = Infinity,\n        debugTag: string | undefined\n    ) {\n        this._debugTag = debugTag\n        this._priority = priority\n        const { promise, resolve, reject } = promiseResolveReject<T>()\n        this._promise = promise\n        this._runFn = async () => {\n            if (abortController?.signal.aborted) {\n                reject(new FakeAbortError(abortController.signal.reason || 'AbortError'))\n                return\n            }\n            if (concurrencyController._current.length >= concurrencyController._concurrencyLimit) {\n                throw new Error('Developer Error: ConcurrencyControllerItem: _runFn called while already running')\n            }\n            try {\n                concurrencyController._current.push(this)\n                const result = await userFn()\n                resolve(result)\n            } catch (error) {\n                reject(error)\n            }\n        }\n        abortController?.signal.addEventListener('abort', () => {\n            reject(new FakeAbortError(abortController.signal.reason || 'AbortError'))\n        })\n        promise\n            .catch(() => {\n                // ignore\n            })\n            .finally(() => {\n                if (concurrencyController._current.includes(this)) {\n                    concurrencyController._current = concurrencyController._current.filter((item) => item !== this)\n                    concurrencyController._runNext()\n                }\n            })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Kea Logic with Props and Key - PostHog Frontend - TypeScript\nDESCRIPTION: Implements a Kea logic with support for a parameterized id (number or 'new'), using props, key (for instance isolation), and path. Required for scenes dependent on a URL parameter. Ensures that logic maintains separate state per dashboard.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { kea, reducers, path, props, key } from 'kea'\n\nexport interface DashboardLogicProps {\n    id: number | 'new'\n}\n\nexport const dashboardLogic = kea([\n    props({} as DashboardLogicProps),\n    key(({ id }) => id),\n    path((id) => ['scenes', 'dashboard', 'dashboardLogic', id]),\n    reducers({\n        counter: [1, {}],\n    }),\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Resolution Logic in Rust\nDESCRIPTION: Implements the internal resolution logic that looks up source map data and finds the original source location for a minified JavaScript stack frame. It handles the case where a frame might not need resolution because it's already unminified.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nasync fn resolve_impl<C>(&self, team_id: i32, catalog: &C) -> Result<Frame, Error>\nwhere\n    C: SymbolCatalog<OrChunkId<Url>, OwnedSourceMapCache>,\n{\n    let Some(location) = &self.location else {\n        return Ok(Frame::from(self)); // We're probably an unminified frame\n    };\n\n    let r = self.get_ref()?; // We need either a chunk ID or a source URL to resolve a frame\n\n    let sourcemap = catalog.lookup(team_id, r).await?;\n    let smc = sourcemap.get_smc();\n\n    // Note: javascript stack frame lines are 1-indexed, so we have to subtract 1\n    let Some(location) = smc.lookup(SourcePosition::new(location.line - 1, location.column))\n    else {\n        return Err(JsResolveErr::TokenNotFound(\n            self.fn_name.clone(),\n            location.line,\n            location.column,\n        )\n        .into());\n    };\n\n    Ok(Frame::from((self, location)))\n}\n```\n\n----------------------------------------\n\nTITLE: HogQL Built-in Functions - v1.0.0\nDESCRIPTION: Defines the built-in functions available in HogQL including string manipulation, type conversion, and pattern matching operations.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconcat(...)             # concat('test: ', 1, null, '!') == 'test: 1!'\nmatch(string, pattern)  # match('fish', '$fi.*') == true\ntoString(val)          # toString(true) == 'true'\ntoInt(val)              # toInt('123') == 123\ntoFloat(val)            # toFloat('123.2') == 123.2\ntoUUID(val)             # toUUID('string') == 'string'\n```\n\n----------------------------------------\n\nTITLE: Defining Mock Arguments for HTTP Requests with MSW - TypeScript\nDESCRIPTION: This code snippet details methods for configuring the MOCK_ARGUMENTS object used in the custom MSW abstraction for Storybook. It accepts HTTP method keys (get, post, patch, delete), each mapping to a set of endpoint mocks. Responses can be specified as static objects, functions for delayed/asynchronous responses (using msw-s ctx), status shorthands, or more complex parameterized handlers. This setup enables flexible and granular API mocking required for comprehensive testing. Dependencies include MSW, ctx utilities, and potentially external mock data objects.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to mock requests.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// you can the four HTTP methods\nuseStorybookMocks({\n    get: {},\n    post: {},\n    patch: {},\n    delete: {},\n})\n\n// and any of these styles\nuseStorybookMocks({\n    get: {\n        // return a 200 success with the object passed here\n        '/api/endpoint': { results: [], success: true }\n\n        // return a 200 success after a 100ms delay, using msw-s ctx\n        '/api/other_endpoint': (_, __, ctx) => [\n            ctx.delay(100),\n            ctx.status(200),\n            ctx.json({ results: [], success: true })\n        ]\n\n        // shorthand for status + json\n        '/api/status_shorthand': () => [500, { error: 'Error text' }]\n\n        // complicated param handling\n        '/api/environments/:team_id/insights': (req, _, ctx) => {\n            const team = req.params['team']\n            const shortId = req.url.searchParams.get('short_id')\n            if (shortId === 'my_insight') {\n                return [200, { result: [{ ...insightJson, team_id: team }] }]\n            }\n            return [500, null]\n        }\n\n    },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Creating Dashboard UI Component with Tabs\nDESCRIPTION: Implements the React component for the dashboard, rendering tabs and their content using LemonTabs component.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to add tabs to a scene.stories.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useValues } from 'kea'\nimport { router } from 'kea-router'\nimport { DashboardsTabs } from '~/types'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { PageHeader } from 'lib/components/PageHeader'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs/LemonTabs'\nimport { urls } from 'scenes/urls'\nimport { dashboardsLogic, humanFriendlyTabName } from './dashboardsLogic'\n\nconst DASHBOARDS_TAB_TO_CONTENT: Record<DashboardsTabs, JSX.Element> = {\n    [DashboardsTabs.First]: <div>First tab content</div>,\n    [DashboardsTabs.Second]: <div>Second tab content</div>,\n}\n\nexport const scene: SceneExport = {\n    component: Dashboards,\n    logic: dashboardsLogic,\n}\n\nexport function Dashboards(): JSX.Element {\n    const { currentTab } = useValues(dashboardsLogic)\n\n    return (\n        <div>\n            <PageHeader />\n            <LemonTabs\n                activeKey={currentTab}\n                onChange={(tab) => router.actions.push(urls.dashboards(tab as DashboardsTabs))}\n                tabs={Object.values(DashboardsTabs).map((tab) => ({\n                    label: DASHBOARDS_TAB_TO_NAME[tab],\n                    key: tab,\n                    content: DASHBOARDS_TAB_TO_CONTENT[tab],\n                }))}\n            />\n        </div>\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null Handling in HogQL Comparisons - SQL - Boolean Comparison Reference\nDESCRIPTION: This snippet uses SQL-like syntax to clarify how null values are handled in Hog/QL equality and inequality comparisons. It shows that null is treated as a regular value, so comparisons involving null return straightforward boolean results instead of propagating nulls. This reference is instructional for implementers ensuring compatibility with HogVM's null semantics, contrasting with other SQL implementations such as ClickHouse.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/README.md#2025-04-23_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n1 == null # false\n1 != null # true\n```\n\n----------------------------------------\n\nTITLE: Creating ActionStepJSON Dataclass in Python\nDESCRIPTION: Defines a dataclass for representing the structure of an action step with optional fields for targeting elements based on tag, text, href, selector, URL, event, and properties. Includes default values and matching type options.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/python.txt#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass ActionStepJSON:\n    tag_name: Optional[str] = None\n    text: Optional[str] = None\n    text_matching: Optional[ActionStepMatching] = None\n    href: Optional[str] = None\n    href_matching: Optional[ActionStepMatching] = None\n    selector: Optional[str] = None\n    url: Optional[str] = None\n    url_matching: Optional[ActionStepMatching] = \"contains\"\n    event: Optional[str] = None\n    properties: Optional[list[dict]] = None\n```\n\n----------------------------------------\n\nTITLE: Implementing ConcurrencyController Class in TypeScript\nDESCRIPTION: A controller class that manages concurrent operations with a priority queue. It limits the number of simultaneous operations and provides methods to run functions with priority and abort capabilities.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/ts.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class ConcurrencyController {\n    _concurrencyLimit: number\n\n    _current: ConcurrencyControllerItem<any>[] = []\n    private _queue: FastPriorityQueue<ConcurrencyControllerItem<any>> = new FastPriorityQueue(\n        (a, b) => a._priority < b._priority\n    )\n\n    constructor(concurrencyLimit: number) {\n        this._concurrencyLimit = concurrencyLimit\n    }\n\n    /**\n     * Run a function with a mutex. If the mutex is already running, the function will be queued and run when the mutex\n     * is available.\n     * @param fn The function to run\n     * @param priority The priority of the function. Lower numbers will be run first. Defaults to Infinity.\n     * @param abortController An AbortController that, if aborted,  will reject the promise and immediately start the next item in the queue.\n     * @param debugTag\n     */\n    run = <T>({\n        fn,\n        priority,\n        abortController,\n        debugTag,\n    }: {\n        fn: () => Promise<T>\n        priority?: number\n        abortController?: AbortController\n        debugTag?: string\n    }): Promise<T> => {\n        const item = new ConcurrencyControllerItem(this, fn, abortController, priority, debugTag)\n\n        this._queue.add(item)\n\n        this._tryRunNext()\n\n        return item._promise\n    }\n\n    _runNext(): void {\n        const next = this._queue.poll()\n        if (next) {\n            next._runFn()\n                .catch(() => {\n                    // ignore\n                })\n                .finally(() => {\n                    this._tryRunNext()\n                })\n        }\n    }\n\n    _tryRunNext(): void {\n        if (this._current.length < this._concurrencyLimit) {\n            this._runNext()\n        }\n    }\n\n    setConcurrencyLimit = (limit: number): void => {\n        this._concurrencyLimit = limit\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: QueryEditor Component Usage\nDESCRIPTION: Implementation example of the QueryEditor component which provides a generic JSON editor interface.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/queries/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n<QueryEditor query={} setQuery={} />\n```\n\n----------------------------------------\n\nTITLE: Defining a Kea Logic-Driven Scene Component - PostHog Frontend - TypeScript\nDESCRIPTION: Defines a React scene component with Kea logic to manage state, including a counter, and an exportable scene object reflecting component, logic, and type. Requires Kea, React, and types from the PostHog codebase. This snippet shows modular scene composition and logic binding for global (non-parameterized) scenes. Key inputs include no props; output is a rendered Dashboard scene with a counter.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { dashboardsLogic } from './dashboardsLogic'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { useValues } from 'kea'\n\nexport function Dashboards (): JSX.Element {\n    const {\n        counter\n    } = useValues(dashboardsLogic)\n\n    return (\n        // TODO: consolidate on a recommended naming convention\n        <div className='dashboard-scene'>\n            Dashboard Scene {counter}!\n        </div>\n    )\n}\n\nexport const scene: SceneExport = {\n    component: Dashboards,\n    logic: dashboardsLogic,\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering TodoMatic Application UI in React\nDESCRIPTION: This React component function 'App' renders the entire UI for a todo list application called TodoMatic. It includes a form for adding new tasks, filter buttons for viewing different task states, and a list of existing tasks with options to edit, delete, and mark as complete.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/jsx.txt#2025-04-23_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction App(props) {\n    return (\n        <div className=\"todoapp stack-large\">\n            <h1>TodoMatic</h1>\n            <form>\n                <h2 className=\"label-wrapper\">\n                    <label htmlFor=\"new-todo-input\" className=\"label__lg\">\n                        What needs to be done?\n                    </label>\n                </h2>\n                <input type=\"text\" id=\"new-todo-input\" className=\"input input__lg\" name=\"text\" autoComplete=\"off\" />\n                <button type=\"submit\" className=\"btn btn__primary btn__lg\">\n                    Add\n                </button>\n            </form>\n            <div className=\"filters btn-group stack-exception\">\n                <button type=\"button\" className=\"btn toggle-btn\" aria-pressed=\"true\">\n                    <span className=\"visually-hidden\">Show </span>\n                    <span>all</span>\n                    <span className=\"visually-hidden\"> tasks</span>\n                </button>\n                <button type=\"button\" className=\"btn toggle-btn\" aria-pressed=\"false\">\n                    <span className=\"visually-hidden\">Show </span>\n                    <span>Active</span>\n                    <span className=\"visually-hidden\"> tasks</span>\n                </button>\n                <button type=\"button\" className=\"btn toggle-btn\" aria-pressed=\"false\">\n                    <span className=\"visually-hidden\">Show </span>\n                    <span>Completed</span>\n                    <span className=\"visually-hidden\"> tasks</span>\n                </button>\n            </div>\n            <h2 id=\"list-heading\">3 tasks remaining</h2>\n            <ul role=\"list\" className=\"todo-list stack-large stack-exception\" aria-labelledby=\"list-heading\">\n                <li className=\"todo stack-small\">\n                    <div className=\"c-cb\">\n                        <input id=\"todo-0\" type=\"checkbox\" defaultChecked />\n                        <label className=\"todo-label\" htmlFor=\"todo-0\">\n                            Eat\n                        </label>\n                    </div>\n                    <div className=\"btn-group\">\n                        <button type=\"button\" className=\"btn\">\n                            Edit <span className=\"visually-hidden\">Eat</span>\n                        </button>\n                        <button type=\"button\" className=\"btn btn__danger\">\n                            Delete <span className=\"visually-hidden\">Eat</span>\n                        </button>\n                    </div>\n                </li>\n                <li className=\"todo stack-small\">\n                    <div className=\"c-cb\">\n                        <input id=\"todo-1\" type=\"checkbox\" />\n                        <label className=\"todo-label\" htmlFor=\"todo-1\">\n                            Sleep\n                        </label>\n                    </div>\n                    <div className=\"btn-group\">\n                        <button type=\"button\" className=\"btn\">\n                            Edit <span className=\"visually-hidden\">Sleep</span>\n                        </button>\n                        <button type=\"button\" className=\"btn btn__danger\">\n                            Delete <span className=\"visually-hidden\">Sleep</span>\n                        </button>\n                    </div>\n                </li>\n                <li className=\"todo stack-small\">\n                    <div className=\"c-cb\">\n                        <input id=\"todo-2\" type=\"checkbox\" />\n                        <label className=\"todo-label\" htmlFor=\"todo-2\">\n                            Repeat\n                        </label>\n                    </div>\n                    <div className=\"btn-group\">\n                        <button type=\"button\" className=\"btn\">\n                            Edit <span className=\"visually-hidden\">Repeat</span>\n                        </button>\n                        <button type=\"button\" className=\"btn btn__danger\">\n                            Delete <span className=\"visually-hidden\">Repeat</span>\n                        </button>\n                    </div>\n                </li>\n            </ul>\n        </div>\n    )\n}\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Handling Resolution Errors in Rust\nDESCRIPTION: Implements error handling for JavaScript frame resolution, ensuring that even when a frame can't be resolved to its original source, a usable frame is still returned with error information. This maintains the integrity of the stack trace.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn handle_resolution_error(&self, e: JsResolveErr) -> Frame {\n    // If we failed to resolve the frame, we mark it as \"not resolved\" and add the error message,\n    // then return a Frame anyway, because frame handling is a best-effort thing.\n    let Some(location) = &self.location else {\n        return self.into();\n    };\n    (self, e, location).into()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Component Stories in TypeScript with Storybook\nDESCRIPTION: Demonstrates setting up a component story for a LemonSwitch component, including meta configuration, argTypes setup, and component implementation with state management.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to create stories.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// frontend/src/lib/lemon-ui/LemonSwitch/LemonSwitch.stories.tsx\nimport { Meta, StoryObj } from '@storybook/react'\n\nimport { LemonSwitch, LemonSwitchProps } from './LemonSwitch'\n\ntype Story = StoryObj<typeof LemonSwitch>\nconst meta: Meta<typeof LemonSwitch> = {\n    title: 'Lemon UI/Lemon Switch',\n    component: LemonSwitch,\n    argTypes: {\n        loading: {\n            control: {\n                type: 'boolean',\n            },\n        },\n        label: {\n            name: 'label',\n            type: { name: 'string', required: false },\n            defaultValue: 'Hello',\n            description: 'demo description',\n            table: {\n                type: { summary: 'string' },\n                defaultValue: { summary: 'Hello' },\n            },\n            control: {\n                type: 'text'\n            },\n        },\n    },\n    tags: ['autodocs'],\n}\nexport default meta\n\nexport function LemonSwitch_(props: LemonSwitchProps): JSX.Element {\n    const [isChecked, setIsChecked] = useState(false)\n\n    return (\n        <LemonSwitch\n            {...props}\n            checked={props.checked !== undefined ? props.checked : isChecked}\n            onChange={setIsChecked}\n        />\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Scoped Styles for a Parameterized Scene - PostHog Frontend - TypeScript (CSS-in-SCSS Syntax)\nDESCRIPTION: Specifies that all styles for the dashboard scene should be scoped within the '.dashboard-scene' class for encapsulation. Used in the Dashboard SCSS file paired with the parameterized scene. No inputs or outputs; maintains global style hygiene.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n.dashboard-scene {\n    // put all your styles inside this scope, as everything is global\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Event Streaming Server for PostHog\nDESCRIPTION: The main function sets up and runs a PostHog event streaming server. It initializes configuration, Sentry error tracking, Kafka consumer, filtering mechanism, and an Echo HTTP server with various endpoints including metrics, stats, and SSE event streaming.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/go.txt#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/getsentry/sentry-go\"\n\t\"github.com/labstack/echo-contrib/echoprometheus\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc main() {\n\tloadConfigs()\n\n\tisProd := viper.GetBool(\"prod\")\n\n\terr := sentry.Init(sentry.ClientOptions{\n\t\tDsn:              viper.GetString(\"sentry.dsn\"),\n\t\tDebug:            !isProd,\n\t\tAttachStacktrace: true,\n\t})\n\tif err != nil {\n\t\tsentry.CaptureException(err)\n\t\tlog.Fatalf(\"sentry.Init: %s\", err)\n\t}\n\t// Flush buffered events before the program terminates.\n\t// Set the timeout to the maximum duration the program can afford to wait.\n\tdefer sentry.Flush(2 * time.Second)\n\n\tmmdb := viper.GetString(\"mmdb.path\")\n\tif mmdb == \"\" {\n\t\tsentry.CaptureException(errors.New(\"mmdb.path must be set\"))\n\t\tlog.Fatal(\"mmdb.path must be set\")\n\t}\n\tbrokers := viper.GetString(\"kafka.brokers\")\n\tif brokers == \"\" {\n\t\tsentry.CaptureException(errors.New(\"kafka.brokers must be set\"))\n\t\tlog.Fatal(\"kafka.brokers must be set\")\n\t}\n\ttopic := viper.GetString(\"kafka.topic\")\n\tif topic == \"\" {\n\t\tsentry.CaptureException(errors.New(\"kafka.topic must be set\"))\n\t\tlog.Fatal(\"kafka.topic must be set\")\n\t}\n\tgroupID := viper.GetString(\"kafka.group_id\")\n\tif groupID == \"\" {\n\t\tsentry.CaptureException(errors.New(\"kafka.group_id must be set\"))\n\t\tlog.Fatal(\"kafka.group_id must be set\")\n\t}\n\n\tgeolocator, err := NewMaxMindGeoLocator(mmdb)\n\tif err != nil {\n\t\tsentry.CaptureException(err)\n\t\tlog.Fatalf(\"Failed to open MMDB: %v\", err)\n\t}\n\n\tstats := newStatsKeeper()\n\n\tphEventChan := make(chan PostHogEvent)\n\tstatsChan := make(chan PostHogEvent)\n\tsubChan := make(chan Subscription)\n\tunSubChan := make(chan Subscription)\n\n\tgo stats.keepStats(statsChan)\n\n\tkafkaSecurityProtocol := \"SSL\"\n\tif !isProd {\n\t\tkafkaSecurityProtocol = \"PLAINTEXT\"\n\t}\n\tconsumer, err := NewPostHogKafkaConsumer(brokers, kafkaSecurityProtocol, groupID, topic, geolocator, phEventChan, statsChan)\n\tif err != nil {\n\t\tsentry.CaptureException(err)\n\t\tlog.Fatalf(\"Failed to create Kafka consumer: %v\", err)\n\t}\n\tdefer consumer.Close()\n\tgo consumer.Consume()\n\n\tfilter := NewFilter(subChan, unSubChan, phEventChan)\n\tgo filter.Run()\n\n\t// Echo instance\n\te := echo.New()\n\n\t// Middleware\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\te.Use(middleware.RequestID())\n\te.Use(middleware.GzipWithConfig(middleware.GzipConfig{\n\t\tLevel: 9, // Set compression level to maximum\n\t}))\n\te.Use(echoprometheus.NewMiddlewareWithConfig(\n\t\techoprometheus.MiddlewareConfig{DoNotUseRequestPathFor404: true, Subsystem: \"livestream\"}))\n\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOrigins: []string{\"*\"},\n\t\tAllowMethods: []string{http.MethodGet, http.MethodHead},\n\t}))\n\n\t// Routes\n\te.GET(\"/\", index)\n\n\t// For details why promhttp.Handler won't work: https://github.com/prometheus/client_golang/issues/622\n\te.GET(\"/metrics\", echo.WrapHandler(promhttp.InstrumentMetricHandler(\n\t\tprometheus.DefaultRegisterer,\n\t\tpromhttp.HandlerFor(prometheus.DefaultGatherer, promhttp.HandlerOpts{DisableCompression: true}),\n\t)))\n\n\te.GET(\"/served\", servedHandler(stats))\n\n\te.GET(\"/stats\", statsHandler(stats))\n\n\te.GET(\"/events\", streamEventsHandler(e.Logger, subChan, filter))\n\n\te.GET(\"/jwt\", func(c echo.Context) error {\n\t\tclaims, err := getAuth(c.Request().Header)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn c.JSON(http.StatusOK, claims)\n\t})\n\n\tif !isProd {\n\t\te.File(\"/debug\", \"./index.html\")\n\t\te.GET(\"/debug/sse\", func(c echo.Context) error {\n\t\t\te.Logger.Printf(\"Map client connected, ip: %v\", c.RealIP())\n\n\t\t\tw := c.Response()\n\t\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\t\t\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\t\t\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\t\t\tticker := time.NewTicker(1 * time.Second)\n\t\t\tdefer ticker.Stop()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-c.Request().Context().Done():\n\t\t\t\t\te.Logger.Printf(\"SSE client disconnected, ip: %v\", c.RealIP())\n\t\t\t\t\treturn nil\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\tevent := Event{\n\t\t\t\t\t\tData: []byte(\"ping: \" + time.Now().Format(time.RFC3339Nano)),\n\t\t\t\t\t}\n\t\t\t\t\tif err := event.WriteTo(w); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tw.Flush()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\te.Logger.Fatal(e.Start(\":8080\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Ant Design to Lemon UI Component Mapping (Markdown)\nDESCRIPTION: This Markdown code uses unordered lists and inline code for documenting component mapping between Ant Design and Lemon UI. It provides clear migration guidance by specifying which Lemon UI component to use in place of each deprecated Ant Design component. This section relies on Markdown formatting for readability and is intended for contributors migrating UI code. No functional code to execute; the output is intented for documentation only.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Lemon UI.stories.mdx#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n-   `Button` – instead go for `LemonButton`\\n-   `Select` – instead go for `LemonSelect`\\n-   `Input`, `Input.Password`, `Input.Search` – instead go for `LemonInput`\\n-   `Input.TextArea` – instead go for `LemonTextArea`\\n-   `Table` – instead go for `LemonTable`\\n-   `Checkbox` – instead go for `LemonCheckbox`\\n-   `Spin` – instead go for `Spinner`\\n-   `Alert` – instead go for `LemonBanner`\\n-   `Typography` – just use HTML elements\\n-   `Modal` – instead go for `LemonModal`\\n-   `Divider` – instead go for `LemonDivider`\\n-   `Row` – instead go for `LemonRow` (for standard rows of content) or roll your own `display: flex` as needed (for general layout)\\n-   `Col` – roll your own `display: flex` as needed\n```\n\n----------------------------------------\n\nTITLE: Implementing Django Signal Handlers for Action Model\nDESCRIPTION: Defines two signal handlers: one for when an action is saved to reload it on workers, and another for when an action is deleted to drop it from workers. Uses Django's post_save and post_delete signals.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/python.txt#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@receiver(post_save, sender=Action)\ndef action_saved(sender, instance: Action, created, **kwargs):\n    reload_action_on_workers(team_id=instance.team_id, action_id=instance.id)\n\n\n@mutable_receiver(post_delete, sender=Action)\ndef action_deleted(sender, instance: Action, **kwargs):\n    drop_action_on_workers(team_id=instance.team_id, action_id=instance.id)\n```\n\n----------------------------------------\n\nTITLE: Implementing Dashboard Logic with Kea\nDESCRIPTION: Implements the dashboard logic using Kea framework, handling tab state management and URL synchronization.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to add tabs to a scene.stories.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { kea, reducers, path, actions, selectors } from 'kea'\nimport { actionToUrl, urlToAction } from 'kea-router'\n\nimport { Breadcrumb, DashboardsTabs } from '~/types'\nimport { urls } from 'scenes/urls'\n\nexport const DASHBOARDS_TAB_TO_NAME: Record<DashboardsTabs, string> = {\n    [DashboardsTabs.First]: 'First',\n    [DashboardsTabs.Second]: 'Second',\n}\n\nexport const dashboardsLogic = kea([\n    path(['scenes', 'dashboard', 'dashboardsLogic']),\n    actions({\n        setCurrentTab: (tab: DashboardsTabs = DashboardsTabs.First) => ({ tab }),\n    }),\n    reducers({\n        currentTab: [\n            DashboardsTabs.First as DashboardsTabs,\n            {\n                setCurrentTab: (_, { tab }) => tab,\n            },\n        ],\n    }),\n    selectors(() => ({\n        breadcrumbs: [\n            (s) => [s.currentTab],\n            (tab): Breadcrumb[] => {\n                const breadcrumbs: Breadcrumb[] = [{ name: 'Dashboards' }]\n                breadcrumbs.push({\n                    name: DASHBOARDS_TAB_TO_NAME[tab],\n                })\n\n                return breadcrumbs\n            },\n        ],\n    })),\n    actionToUrl(({ values }) => {\n        return {\n            setCurrentTab: () => [urls.dashboards(values.currentTab)],\n        }\n    }),\n    urlToAction(({ actions, values }) => ({\n        '/dashboards/:tab': ({ tab }) => {\n            if (tab !== values.currentTab) {\n                actions.setCurrentTab(tab as DashboardsTabs)\n            }\n        },\n    })),\n])\n```\n\n----------------------------------------\n\nTITLE: Configuring Dashboard URL Handling\nDESCRIPTION: Updates URL configuration to handle tab parameters in the dashboard route.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to add tabs to a scene.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndashboards: (tab: DashboardsTabs = DashboardsTabs.First): string => `/dashboards/${tab}`\n```\n\n----------------------------------------\n\nTITLE: Configuring Scene Settings and Dynamic Route Mapping for Parameterized Scenes - PostHog Frontend - TypeScript\nDESCRIPTION: Maps the Dashboard scene enum to its configuration and binds a dynamic route (with ':id' placeholder) to the scene for routing. Supports dynamic parameter extraction for scenes like '/dashboard/:id'. Inputs include Scene and routes; output updates to configuration and routing table.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const sceneConfigurations: Partial<Record<Scene, SceneConfig>> = {\n    [Scene.Dashboard]: {\n        projectBased: true,\n        name: 'Dashboard',\n    },\n}\n\nexport const routes: Record<string, Scene> = {\n    // this `:id` gets used in \"params\" in \"paramsToProps\" and passed to the <Dashboard /> component\n    [urls.dashboard(':id')]: Scene.Dashboard,\n}\n```\n\n----------------------------------------\n\nTITLE: Using LemonColorButton Component in TSX\nDESCRIPTION: Example usage of the `LemonColorButton` component in TSX. Demonstrates creating a button that displays a color glyph, either using a direct hex color string via the `color` prop or a data color token via the `colorToken` and `themeId` props.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/lib/lemon-ui/LemonColor/LemonColor.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Using a hex color\n<LemonColorButton color=\"#FF0000\" />\n\n// Using a data color token\n<LemonColorButton colorToken=\"primary\" themeId={1} />\n```\n\n----------------------------------------\n\nTITLE: Documenting Required HogVM Functions - Bash - Call Reference\nDESCRIPTION: This snippet outlines function calls that must be implemented in a compliant Hog Certified Parser using a bash-styled pseudocode list. Each function is demonstrated with example inputs and expected output, clarifying expected behaviors and outputs. These are reference outlines, not actual bash scripts. Implementers must ensure these functions accept the correct argument types (string, int, float, etc.) and behave as described, returning appropriate results for type conversions, pattern matches, and null handling.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconcat(...)              # concat('test: ', 1, null, '!') == 'test: 1!'\nmatch(string, pattern)   # match('fish', '$fi.*') == true\ntoString(val)            # toString(true) == 'true'\ntoInt(val)               # toInt('123') == 123\ntoFloat(val)             # toFloat('123.2') == 123.2\ntoUUID(val)              # toUUID('string') == 'string'\nifNull(val, alternative) # ifNull('string', false) == 'string'\n```\n\n----------------------------------------\n\nTITLE: Parsing JavaScript Source URL in Rust\nDESCRIPTION: Implements URL parsing logic specific to JavaScript stack frames, handling edge cases like URLs with trailing line and column numbers. It enforces that source URLs are absolute HTTP or HTTPS URLs.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn source_url(&self) -> Result<Url, JsResolveErr> {\n    // We can't resolve a frame without a source ref, and are forced\n    // to assume this frame is not minified\n    let Some(source_url) = &self.source_url else {\n        return Err(JsResolveErr::NoSourceUrl);\n    };\n\n    // We outright reject relative URLs, or ones that are not HTTP\n    if !source_url.starts_with(\"http://\") && !source_url.starts_with(\"https://\") {\n        return Err(JsResolveErr::InvalidSourceUrl(source_url.clone()));\n    }\n\n    // TODO - we assume these are always absolute urls, and maybe should handle cases where\n    // they aren't? We control this on the client side, and I'd prefer to enforce it here.\n\n    // These urls can have a trailing line and column number, formatted like: http://example.com/path/to/file.js:1:2.\n    // We need to strip that off to get the actual source url\n    // If the last colon is after the last slash, remove it, under the assumption that it's a column number.\n    // If there is no colon, or it's before the last slash, we assume the whole thing is a url,\n    // with no trailing line and column numbers\n    let last_colon = source_url.rfind(':');\n    let last_slash = source_url.rfind('/');\n    let useful = match (last_colon, last_slash) {\n        (Some(colon), Some(slash)) if colon > slash => colon,\n        _ => source_url.len(),\n    };\n\n    // We do this check one more time, to account for possible line number\n    let source_url = &source_url[..useful];\n    let last_colon = source_url.rfind(':');\n    let last_slash = source_url.rfind('/');\n    let useful = match (last_colon, last_slash) {\n        (Some(colon), Some(slash)) if colon > slash => colon,\n        _ => source_url.len(),\n    };\n\n    Url::parse(&source_url[..useful])\n        .map_err(|_| JsResolveErr::InvalidSourceUrl(source_url.to_string()))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Markdown Stories in Storybook\nDESCRIPTION: Example of creating a basic Markdown story file in Storybook. Shows the minimal structure required for a documentation page using MDX format.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to create stories.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<!-- frontend/src/stories/New Page.stories.mdx -->\nimport { Meta } from '@storybook/addon-docs'\n\n<Meta title=\" New Page\" />\n\n# Page Title\n\nWrite your content here...\n```\n\n----------------------------------------\n\nTITLE: Implementing Frame Resolution Method in Rust\nDESCRIPTION: Implements the main resolve method for RawJSFrame that attempts to map a minified JavaScript stack frame to its original source location using source maps. The method handles various error cases gracefully to ensure the stack trace processing continues.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub async fn resolve<C>(&self, team_id: i32, catalog: &C) -> Result<Frame, UnhandledError>\nwhere\n    C: SymbolCatalog<OrChunkId<Url>, OwnedSourceMapCache>,\n{\n    match self.resolve_impl(team_id, catalog).await {\n        Ok(frame) => Ok(frame),\n        Err(Error::ResolutionError(FrameError::JavaScript(e))) => {\n            Ok(self.handle_resolution_error(e))\n        }\n        Err(Error::ResolutionError(FrameError::MissingChunkIdData(chunk_id))) => {\n            Ok(self.handle_resolution_error(JsResolveErr::NoSourcemapUploaded(chunk_id)))\n        }\n        Err(Error::UnhandledError(e)) => Err(e),\n        Err(Error::EventError(_)) => unreachable!(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Hog/QL Expressions to Hog Bytecode - Bash - Illustrative Example\nDESCRIPTION: This snippet demonstrates how Hog/QL expressions translate into Hog bytecode representations using a pseudo-bash array/list syntax. Each example maps high-level logic or comparison to its corresponding opcode structure, illustrating the stack-based nature of Hog bytecode. This serves as a reference for implementers and is not executable bash; rather, it conveys the encoding pattern required for compliance.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n1 + 2                  # [_H, op.INTEGER, 2, op.INTEGER, 1, op.PLUS]\n1 and 2                # [_H, op.INTEGER, 2, op.INTEGER, 1, op.AND, 2]\n1 or 2                 # [_H, op.INTEGER, 2, op.INTEGER, 1, op.OR, 2]\nnot true               # [_H, op.TRUE, op.NOT]\nproperties.bla         # [_H, op.STRING, \"bla\", op.STRING, \"properties\", op.GET_GLOBAL, 2]\ncall('arg', 'another') # [_H, op.STRING, \"another\", op.STRING, \"arg\", op.CALL_GLOBAL, \"call\", 2]\n1 = 2                  # [_H, op.INTEGER, 2, op.INTEGER, 1, op.EQ]\n'bla' !~ 'a'           # [_H, op.STRING, 'a', op.STRING, 'bla', op.NOT_REGEX]\n```\n\n----------------------------------------\n\nTITLE: Running the RealTime Hog 3000 Server with Go\nDESCRIPTION: This Go command compiles and runs the main application in the current directory (.), starting the RealTime Hog 3000 server. Go must be installed and configured. The server loads configurations and the geolocation database as prerequisites and exposes described endpoints for live event streaming and metrics.\nSOURCE: https://github.com/posthog/posthog/blob/master/livestream/README.md#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run .\n```\n\n----------------------------------------\n\nTITLE: Feature Flag Logic Type Interface\nDESCRIPTION: Defines the TypeScript interface for feature flag logic, including actions and values for both kea-loaders and kea-forms functionality.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a form.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface featureFlagLogicType extends Logic {\\n    actions: {\\n        loadFeatureFlag: () => void\\n        loadFeatureFlagSuccess: (featureFlag: any, payload?: any) => void\\n        loadFeatureFlagFailure: (error: string, errorObject?: any) => void\\n        setFeatureFlagValue: (key: FieldName, value: any) => void\\n        setFeatureFlagValues: (values: DeepPartial<FeatureFlagType>) => void\\n        touchFeatureFlagField: (key: string) => void\\n        resetFeatureFlag: (values?: FeatureFlagType) => void\\n        submitFeatureFlag: () => void\\n        submitFeatureFlagRequest: (featureFlag: FeatureFlagType) => void\\n        submitFeatureFlagSuccess: (featureFlag: FeatureFlagType) => void\\n        submitFeatureFlagFailure: (error: Error) => void\\n    }\\n    values: {\\n        featureFlag: FeatureFlagType\\n        featureFlagLoading: boolean\\n        isFeatureFlagSubmitting: boolean\\n        showFeatureFlagErrors: boolean\\n        featureFlagChanged: boolean\\n        featureFlagTouches: Record<string, boolean>\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dashboard Route Entries\nDESCRIPTION: Configures route entries for each available dashboard tab using Object.fromEntries.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to add tabs to a scene.stories.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n...Object.fromEntries(\n    Object.values(DashboardsTabs).map((tab) => [urls.dashboards(tab), Scene.Dashboards])\n) as Record<string, Scene>,\n```\n\n----------------------------------------\n\nTITLE: Configuring Lazy-Loaded Scene Imports for Parameterized Scene - PostHog Frontend - TypeScript\nDESCRIPTION: Registers a mapping from the Dashboard scene enum to a dynamic import for on-demand loading of the dashboard scene component, supporting code-splitting and reducing initial bundle size. Input is a scene enum; output is a lazy import function.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const appScenes: Record<Scene, () => any> = {\n    [Scene.Dashboard]: () => import('./dashboard/Dashboard'),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Properties in YAML\nDESCRIPTION: Example configuration showing how to define various property types with different constraints. Includes boolean, duration, float64, and map property configurations with namespace and taskQueue constraints.\nSOURCE: https://github.com/posthog/posthog/blob/master/docker/temporal/dynamicconfig/README.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntestGetBoolPropertyKey:\n  - value: false\n  - value: true\n    constraints:\n      namespace: \"global-samples-namespace\"\n  - value: false\n    constraints:\n      namespace: \"samples-namespace\"\ntestGetDurationPropertyKey:\n  - value: \"1m\"\n    constraints:\n      namespace: \"samples-namespace\"\n      taskQueueName: \"longIdleTimeTaskqueue\"\ntestGetFloat64PropertyKey:\n  - value: 12.0\n    constraints:\n      namespace: \"samples-namespace\"\ntestGetMapPropertyKey:\n  - value:\n      key1: 1\n      key2: \"value 2\"\n      key3:\n        - false\n        - key4: true\n          key5: 2.0\n```\n\n----------------------------------------\n\nTITLE: Cache Consistency Debugging Functions\nDESCRIPTION: Python functions for checking and fixing cache consistency issues with PostHog surveys\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/surveys/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# In Django shell (python manage.py shell_plus)\nfrom posthog.models.surveys.debug import (\n    check_team_cache_consistency,\n    fix_team_cache_consistency,\n    find_teams_with_cache_inconsistencies,\n    fix_all_teams_cache_consistency\n)\n\n# Check single team\ncheck_team_cache_consistency(\"team_id_or_token\")\n\n# Fix single team\nfix_team_cache_consistency(\"team_id_or_token\")\n\n# Find all teams with issues (only active survey teams)\nfind_teams_with_cache_inconsistencies()\n\n# Fix all teams with issues\nfix_all_teams_cache_consistency()\n```\n\n----------------------------------------\n\nTITLE: DataTable Component Usage\nDESCRIPTION: Example showing the standard interface for node components, specifically the DataTable component.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/queries/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nDataTable({ query, setQuery })\n```\n\n----------------------------------------\n\nTITLE: Initializing Storybook Meta Component in JavaScript/JSX\nDESCRIPTION: Basic Storybook Meta component import and initialization for documenting missing components.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Missing components.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Meta } from '@storybook/addon-docs';\n\n<Meta title=\" Missing components\" />\n```\n\n----------------------------------------\n\nTITLE: Implementing FakeAbortError Class in TypeScript\nDESCRIPTION: A custom error class that mimics the behavior of AbortError. It allows code to use the e.name === 'AbortError' pattern to check if an error is caused by an abort operation.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/ts.txt#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a fake AbortError that allows us to use e.name === 'AbortError' to check if an error is an AbortError\nclass FakeAbortError extends Error {\n    name = 'AbortError'\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Symbol Set Reference in Rust\nDESCRIPTION: Provides a method to get a string reference for the symbol set, using the frame's chunk ID or URL. This is used for identifying where source map data should be stored or retrieved from.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub fn symbol_set_ref(&self) -> Option<String> {\n    // If we have a chunk ID for a frame, no matter where the data we save comes from, we save it with that\n    // chunk id as the ref.\n    self.get_ref().ok().map(|r| r.to_string())\n}\n```\n\n----------------------------------------\n\nTITLE: Starting and Managing Temporal Worker in Bash\nDESCRIPTION: This Bash script starts a Temporal worker using Django's manage.py command. It sets up signal traps for graceful shutdown, monitors the worker process, and handles various exit scenarios. The script uses a cleanup function to manage process termination and provides detailed status reporting.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/bash.txt#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\nset -e\n\ncleanup() {\n    echo \"Stopping worker...\"\n    if kill -0 \"$worker_pid\" >/dev/null 2>&1; then\n        kill -SIGTERM \"$worker_pid\"\n    else\n        echo \"Worker process is not running.\"\n    fi\n\n    trap cleanup SIGINT SIGTERM EXIT\n\n    python3 manage.py start_temporal_worker \"$@\" &\n\n    worker_pid=$!\n\n    # Run wait in a loop in case we trap SIGINT or SIGTERM.\n    # In both cases, wait will terminate early, potentially not waiting for graceful shutdown.\n    while wait $worker_pid\n    do\n        status=$?\n        # If we exit with SIGTERM, status will be 128 + 15.\n        # If we exit with SIGINT, status will be 128 + 2.\n        if [ $status -eq 143 ] || [ $status -eq 130 ]; then\n            echo \"Received signal $(($status - 128)), waiting for worker to finish\"\n        elif [ $status -eq 0 ]; then\n            echo \"Worker exited normally, terminating wait\"\n            break\n        else\n            echo \"Worker exited with unexpected exit status $status, terminating wait\"\n            break\n        fi\n    done\n\n    # Run wait in a loop in case we trap SIGINT or SIGTERM.\n    # In both cases, wait will terminate early, potentially not waiting for graceful shutdown.\n    while wait $worker_pid\n    do\n        status=$?\n        # If we exit with SIGTERM, status will be 128 + 15.\n        # If we exit with SIGINT, status will be 128 + 2.\n        if [ $status -eq 143 ] || [ $status -eq 130 ]; then\n            echo \"Received signal $(($status - 128)), waiting for worker to finish\"\n        elif [ $status -eq 0 ]; then\n            echo \"Worker exited normally, terminating wait\"\n            break\n        else\n            echo \"Worker exited with unexpected exit status $status, terminating wait\"\n            break\n        fi\n    done\n}\n\n\ncleanup\n```\n\n----------------------------------------\n\nTITLE: Watching and Running a Specific Rust Test with Output Display - Shell\nDESCRIPTION: This shell command uses 'cargo watch' to monitor for changes, invoking a specific test within the 'feature-flags' package. The exact test function 'property_matching::tests::test_match_properties_math_operators' is targeted, and full output is displayed upon each run. Dependencies: cargo-watch and Rust. Requires the function to exist. Outputs detailed test logs or errors.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncargo watch -x \"test --package feature-flags --lib -- property_matching::tests::test_match_properties_math_operators --exact --show-output\"\n\n```\n\n----------------------------------------\n\nTITLE: Defining Dashboard Tab Enums in TypeScript\nDESCRIPTION: Creates an enum to define available dashboard tabs for type safety and consistency.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to add tabs to a scene.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport enum DashboardsTabs {\n    First = 'first',\n    Second = 'second',\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RawJSFrame Struct in Rust\nDESCRIPTION: Defines a structure representing a minified JavaScript stack frame with fields for location, source URL, function name, and chunk ID. This struct is used to store the minimal information needed for sourcemap lookup.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct RawJSFrame {\n    #[serde(flatten)]\n    pub location: Option<FrameLocation>, // Sometimes we get frames with no location information. We treat these as already resolved, or unminified\n    #[serde(rename = \"filename\")]\n    pub source_url: Option<String>, // The url the the script the frame was in was fetched from\n    pub in_app: bool,\n    #[serde(rename = \"function\")]\n    pub fn_name: String,\n    #[serde(alias = \"chunkId\", skip_serializing_if = \"Option::is_none\")]\n    pub chunk_id: Option<String>,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-watch for Live Test Reloads - Shell\nDESCRIPTION: This command uses Homebrew to install the 'cargo-watch' utility, enabling automatic re-running of commands (like tests) on file changes. Dependencies: Homebrew and Rust tooling must be present. No input or output parameters. Outputs installation logs via Homebrew.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nbrew install cargo-watch\n\n```\n\n----------------------------------------\n\nTITLE: Running Rust Feature-Flags Package Tests - Shell\nDESCRIPTION: This shell command executes all Rust tests for the 'feature-flags' Cargo package. Dependencies: Rust and Cargo must be installed. The '--package' flag restricts testing to the specified subcrate. Test input is driven by Rust source and test files. Outputs test results in standard Rust test runner format.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncargo test --package feature-flags\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Parameterized Route URL Function - PostHog Frontend - TypeScript\nDESCRIPTION: Defines a URL generator for dashboard scenes that may accept an id parameter, returning either '/dashboard' or '/dashboard/<id>'. Used for dynamic routing. Parameter: id (string|number), output: constructed route string.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const urls = {\n    dashboard: (id: string | number) => `/dashboard{id ? `/${id}` : ''}`,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ActionStepMatching Type and Constants in Python\nDESCRIPTION: Defines a Literal type for action step matching options (contains, regex, exact) and creates a tuple of these options using get_args() for validation purposes.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/python.txt#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nActionStepMatching = Literal[\"contains\", \"regex\", \"exact\"]\nACTION_STEP_MATCHING_OPTIONS: tuple[ActionStepMatching, ...] = get_args(ActionStepMatching)\n```\n\n----------------------------------------\n\nTITLE: Formatting Rust Code for Feature-Flags Package - Shell\nDESCRIPTION: Uses Cargo's formatting tool to automatically lint and standardize the code style for all sources in the 'feature-flags' package. Dependencies: Rust, Cargo, and cargo-fmt. Expects the package to be present. Produces no output unless errors are encountered or style changes are made.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ncargo fmt --package feature-flags\n\n```\n\n----------------------------------------\n\nTITLE: Listing Hog Bytecode Operations - Bash - Opcode Specification\nDESCRIPTION: This bash-styled snippet lists the available Hog bytecode operations, giving both their integer identifiers and the stack manipulation they perform for each operation. The format is designed to be reference material for developers writing a parser or interpreter, describing opcode purposes, associated parameters, and the corresponding Hog/QL syntax. No dependencies or input/output requirements are imposed as this is for human reference only.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nFIELD = 1          # [arg3, arg2, arg1, FIELD, 3]       # arg1.arg2.arg3\nCALL_GLOBAL = 2    # [arg2, arg1, CALL, 'concat', 2]    # concat(arg1, arg2)\nAND = 3            # [val3, val2, val1, AND, 3]         # val1 and val2 and val3\nOR = 4             # [val3, val2, val1, OR, 3]          # val1 or val2 or val3\nNOT = 5            # [val, NOT]                         # not val\nPLUS = 6           # [val2, val1, PLUS]                 # val1 + val2\nMINUS = 7          # [val2, val1, MINUS]                # val1 - val2\nMULTIPLY = 8       # [val2, val1, MULTIPLY]             # val1 * val2\nDIVIDE = 9         # [val2, val1, DIVIDE]               # val1 / val2\nMOD = 10           # [val2, val1, MOD]                  # val1 % val2\nEQ = 11            # [val2, val1, EQ]                   # val1 == val2\nNOT_EQ = 12        # [val2, val1, NOT_EQ]               # val1 != val2\nGT = 13            # [val2, val1, GT]                   # val1 > val2\nGT_EQ = 14         # [val2, val1, GT_EQ]                # val1 >= val2\nLT = 15            # [val2, val1, LT]                   # val1 < val2\nLT_EQ = 16         # [val2, val1, LT_EQ]                # val1 <= val2\nLIKE = 17          # [val2, val1, LIKE]                 # val1 like val2\nILIKE = 18         # [val2, val1, ILIKE]                # val1 ilike val2\nNOT_LIKE = 19      # [val2, val1, NOT_LIKE]             # val1 not like val2\nNOT_ILIKE = 20     # [val2, val1, NOT_ILIKE]            # val1 not ilike val2\nIN = 21            # [val2, val1, IN]                   # val1 in val2\nNOT_IN = 22        # [val2, val1, NOT_IN]               # val1 not in val2\nREGEX = 23         # [val2, val1, REGEX]                # val1 =~ val2\nNOT_REGEX = 24     # [val2, val1, NOT_REGEX]            # val1 !~ val2\nIREGEX = 25        # [val2, val1, IREGEX]               # val1 =~* val2\nNOT_IREGEX = 26    # [val2, val1, NOT_IREGEX]           # val1 !~* val2\nTRUE = 29          # [TRUE]                             # true\nFALSE = 30         # [FALSE]                            # false\nNULL = 31          # [NULL]                             # null\nSTRING = 32        # [STRING, 'text']                   # 'text'\nINTEGER = 33       # [INTEGER, 123]                     # 123\nFLOAT = 34         # [FLOAT, 123.12]                    # 123.01\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration for Mobile Testing\nDESCRIPTION: Environment variables configuration for enabling mobile testing of PostHog surveys with proper CORS and security settings\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/surveys/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: env\nCODE:\n```\n# Core URLs\nSITE_URL=https://posthog-web-test.ngrok.io\nJS_URL=https://posthog-web-test.ngrok.io\n\n# CORS and security\nCORS_ALLOW_ALL_ORIGINS=true\nCORS_ALLOW_CREDENTIALS=True\nALLOWED_HOSTS=*,localhost,localhost:8010,127.0.0.1,127.0.0.1:8010,posthog-web-test\nDISABLE_SECURE_SSL_REDIRECT=True\nSECURE_COOKIES=False\n\n# Proxy settings\nIS_BEHIND_PROXY=true\nUSE_X_FORWARDED_HOST=true\nUSE_X_FORWARDED_PORT=true\nTRUST_ALL_PROXIES=true\n\n# Debug settings\nDEBUG=true\nDJANGO_DEBUG=true\nSERVE_STATIC=true\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Route URL Function - PostHog Frontend - TypeScript\nDESCRIPTION: Defines a static URL generator for the 'dashboards' scene, returning the route '/dashboard'. To be included in a central 'urls' file for route management. No parameters; output is the dashboards route string.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const urls = {\n    dashboards: () => `/dashboard`,\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Frame ID Hash in Rust\nDESCRIPTION: Implements a method to generate a unique identifier for a JavaScript stack frame by hashing its key properties. This ID can be used for deduplication or reference purposes when tracking errors.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn frame_id(&self) -> String {\n    let mut hasher = Sha512::new();\n    hasher.update(self.fn_name.as_bytes());\n    if let Some(location) = &self.location {\n        hasher.update(location.line.to_string().as_bytes());\n        hasher.update(location.column.to_string().as_bytes());\n    }\n    hasher.update(\n        self.source_url\n            .as_ref()\n            .unwrap_or(&\"\".to_string())\n            .as_bytes(),\n    );\n    format!(\"{:x}\", hasher.finalize())\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Ngrok for Mobile Testing\nDESCRIPTION: YAML configuration for setting up ngrok tunnels to test PostHog surveys on mobile devices\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/surveys/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3'\nagent:\n    authtoken: YOUR_AUTH_TOKEN\ntunnels:\n    web:\n        proto: http\n        addr: 8010\n        host_header: rewrite\n        subdomain: posthog-web-test\n    app:\n        proto: http\n        addr: 3000\n        subdomain: posthog-app-test\n```\n\n----------------------------------------\n\nTITLE: Extending Scene Enum - PostHog Frontend - TypeScript\nDESCRIPTION: Adds a new value 'Dashboards' to the scene enumeration, supporting type-safe references throughout routing and configuration. Should be placed within the scenes type definition file. Input/output is an updated enum.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport enum Scene {\n    Dashboards = 'Dashboards',\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Query for Survey Data\nDESCRIPTION: SQL query to retrieve survey information from PostHog database\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/surveys/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nselect * from posthog_survey\n where id = '{survey_id}'\n```\n\n----------------------------------------\n\nTITLE: Extending Scene Enum for Parameterized Dashboard - PostHog Frontend - TypeScript\nDESCRIPTION: Adds the 'Dashboard' value to the scene enum to allow routing and reference to individual dashboard scenes keyed by id. Used across registration and routing files. No parameters; output is new enum value.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport enum Scene {\n    Dashboard = 'Dashboard',\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Reference for Source Maps in Rust\nDESCRIPTION: Implements logic to determine the reference (either URL or chunk ID) for looking up source maps. It handles cases where either or both might be available, providing flexibility in how source maps are identified.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn get_ref(&self) -> Result<OrChunkId<Url>, JsResolveErr> {\n    match (self.source_url().ok(), self.chunk_id.clone()) {\n        (Some(url), Some(id)) => Ok(OrChunkId::both(url, id)),\n        (Some(url), None) => Ok(OrChunkId::inner(url)),\n        (None, Some(id)) => Ok(OrChunkId::chunk_id(id)),\n        (None, None) => Err(JsResolveErr::NoUrlOrChunkId),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Redshift Batch Export Tests\nDESCRIPTION: Command to execute Redshift batch export tests with host, user, and password credentials in debug mode.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/temporal/tests/batch_exports/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=1 REDSHIFT_HOST=workgroup.111222333.region.redshift-serverless.amazonaws.com REDSHIFT_USER=test_user REDSHIFT_PASSWORD=test_password pytest posthog/temporal/tests/batch_exports/test_redshift_batch_export_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Manual Grammar Generation Commands\nDESCRIPTION: Direct ANTLR commands to generate Python3 source code from HogQL grammar files. Generates both lexer and parser with visitor pattern support.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/hogql/grammar/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd posthog/hogql/grammar\nantlr -Dlanguage=Python3 HogQLLexer.g4\nantlr -visitor -Dlanguage=Python3 HogQLParser.g4\n```\n\n----------------------------------------\n\nTITLE: Core HogQL Bytecode Operations - v1.0.0\nDESCRIPTION: Defines the core set of bytecode operations including field access, function calls, logical operations, arithmetic operations, and comparison operators.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nFIELD = 1          # [arg3, arg2, arg1, FIELD, 3]       # arg1.arg2.arg3\nCALL = 2           # [arg2, arg1, CALL, 'concat', 2]    # concat(arg1, arg2)\nAND = 3            # [val3, val2, val1, AND, 3]         # val1 and val2 and val3\nOR = 4             # [val3, val2, val1, OR, 3]          # val1 or val2 or val3\nNOT = 5            # [val, NOT]                         # not val\nPLUS = 6           # [val2, val1, PLUS]                 # val1 + val2\nMINUS = 7          # [val2, val1, MINUS]                # val1 - val2\nMULTIPLY = 8       # [val2, val1, MULTIPLY]             # val1 * val2\nDIVIDE = 9         # [val2, val1, DIVIDE]               # val1 / val2\nMOD = 10           # [val2, val1, MOD]                  # val1 % val2\nEQ = 11            # [val2, val1, EQ]                   # val1 == val2\nNOT_EQ = 12        # [val2, val1, NOT_EQ]               # val1 != val2\nGT = 13            # [val2, val1, GT]                   # val1 > val2\nGT_EQ = 14         # [val2, val1, GT_EQ]                # val1 >= val2\nLT = 15            # [val2, val1, LT]                   # val1 < val2\nLT_EQ = 16         # [val2, val1, LT_EQ]                # val1 <= val2\nLIKE = 17          # [val2, val1, LIKE]                 # val1 like val2\nILIKE = 18         # [val2, val1, ILIKE]                # val1 ilike val2\nNOT_LIKE = 19      # [val2, val1, NOT_LIKE]             # val1 not like val2\nNOT_ILIKE = 20     # [val2, val1, NOT_ILIKE]            # val1 not ilike val2\nIN = 21            # [val2, val1, IN]                   # val1 in val2\nNOT_IN = 22        # [val2, val1, NOT_IN]               # val1 not in val2\nREGEX = 23         # [val2, val1, REGEX]                # val1 =~ val2\nNOT_REGEX = 24     # [val2, val1, NOT_REGEX]            # val1 !~ val2\nIREGEX = 25        # [val2, val1, IREGEX]               # val1 =~* val2\nNOT_IREGEX = 26    # [val2, val1, NOT_IREGEX]           # val1 !~* val2\nTRUE = 29          # [TRUE]                             # true\nFALSE = 30         # [FALSE]                            # false\nNULL = 31          # [NULL]                             # null\nSTRING = 32        # [STRING, 'text']                   # 'text'\nINTEGER = 33       # [INTEGER, 123]                     # 123\nFLOAT = 34         # [FLOAT, 123.12]                    # 123.01\n```\n\n----------------------------------------\n\nTITLE: Defining FrameLocation Struct in Rust\nDESCRIPTION: Defines a structure for representing line and column positions in a JavaScript stack frame. This is used to pinpoint the exact position in minified code that corresponds to the error.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/rust.txt#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq)]\npub struct FrameLocation {\n    #[serde(rename = \"lineno\")]\n    pub line: u32,\n    #[serde(rename = \"colno\")]\n    pub column: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dagster Development Server\nDESCRIPTION: Command to start the Dagster development server locally with debug mode enabled for proper local resource usage.\nSOURCE: https://github.com/posthog/posthog/blob/master/dags/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Important: Set DEBUG=1 when running locally to use local resources\nDEBUG=1 dagster dev\n```\n\n----------------------------------------\n\nTITLE: Defining Scoped Styles for a Scene - PostHog Frontend - TypeScript (CSS-in-SCSS Syntax)\nDESCRIPTION: Specifies that all style rules for the dashboards scene should be scoped within the '.dashboards-scene' class, preventing global style pollution. Expects use within a SCSS file imported by the corresponding scene component. No inputs or outputs; constraints are stylistic encapsulation.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n.dashboards-scene {\n    // put all your styles inside this scope, as everything is global\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dagster Tests\nDESCRIPTION: Commands for running tests using pytest, including options for running all tests, specific test files, or individual tests with verbose output.\nSOURCE: https://github.com/posthog/posthog/blob/master/dags/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# From the project root\npytest dags/\n\n# To run a specific test file:\npytest dags/tests/test_exchange_rate.py\n\n# To run a specific test:\npytest dags/tests/test_exchange_rate.py::test_name\n\n# Add -v for verbose output:\npytest -v dags/tests/test_exchange_rate.py\n```\n\n----------------------------------------\n\nTITLE: Installing HogQL Parser from Local Sources\nDESCRIPTION: Command to install the hogql_parser package by building from local source files using pip.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogql_parser/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install ./common/hogql_parser\n```\n\n----------------------------------------\n\nTITLE: Setting Project-Relative Dagster Home\nDESCRIPTION: Command to set DAGSTER_HOME to a subdirectory within the current project for consistency with PostHog development environment.\nSOURCE: https://github.com/posthog/posthog/blob/master/dags/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport DAGSTER_HOME=$(pwd)/.dagster_home\n```\n\n----------------------------------------\n\nTITLE: Running Kea Type Generation and TypeScript Check - PostHog Frontend - Bash\nDESCRIPTION: Invokes project scripts to regenerate types for Kea logic and verify TypeScript types. Run in the project root where 'pnpm' and script definitions exist. Produces updated type definitions and ensures type correctness; constraints: must have 'pnpm' and proper scripts set up.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to build a scene.stories.mdx#2025-04-23_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\npnpm typegen:write && pnpm typescript:check\n```\n\n----------------------------------------\n\nTITLE: Setting Dagster Home Environment Variable\nDESCRIPTION: Commands for setting up the DAGSTER_HOME environment variable which determines where Dagster stores instance configuration, logs, and local artifacts.\nSOURCE: https://github.com/posthog/posthog/blob/master/dags/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Set DAGSTER_HOME to a directory of your choice\nexport DAGSTER_HOME=/path/to/your/dagster/home\n```\n\n----------------------------------------\n\nTITLE: Running HogQL Tests\nDESCRIPTION: Command to run pytest for the hogql module using the locally-built version of hogql_parser.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogql_parser/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npytest posthog/hogql/\n```\n\n----------------------------------------\n\nTITLE: Deploying PostHog Self-Hosted Instance with Bash\nDESCRIPTION: This Bash snippet provides a one-line installation of a self-hosted PostHog instance on Linux using Docker. It executes a remote script from the PostHog repository via curl, which handles fetching and running Docker-based resources. The command assumes that Docker and curl are pre-installed, with a recommended minimum of 4GB system memory. Input is not required during execution, and the setup is limited to hobby deployments intended for up to 100,000 events per month. For large-scale deployments or customer support, PostHog Cloud is recommended.\nSOURCE: https://github.com/posthog/posthog/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"/bin/bash -c \\\"\\$(curl -fsSL https://raw.githubusercontent.com/posthog/posthog/HEAD/bin/deploy-hobby)\\\" \"\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests with Database Configuration\nDESCRIPTION: Command to run cargo tests with note about required DATABASE_URL environment variable configuration. The environment variables are automatically loaded from the project's .env file.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/md.txt#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Python Type Checking Errors\nDESCRIPTION: Comprehensive list of type checking errors detected across various Python files in the PostHog codebase. Issues include incompatible types in assignments, undefined attributes, unreachable code, and invalid return types.\nSOURCE: https://github.com/posthog/posthog/blob/master/mypy-baseline.txt#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Sample of reported errors:\n\n# Type mismatch errors\nsetUpTestData # undefined in superclass\nassignment_error: License = None  # incompatible types\n\n# Attribute access errors\nuser.social_auth  # User has no attribute 'social_auth'\nteam.organization  # None has no attribute 'organization'\n\n# Return type errors\nreturn_error: Level = 1  # incompatible return type\n\n# Method signature errors\ndef update(self):  # incompatible with supertype BaseSerializer\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining Storybook Meta Title (JSX)\nDESCRIPTION: This JSX code uses the <Meta> component to set the story's title within Storybook. It integrates with Storybook's MDX system to provide organization, labeling, and navigation for the documentation section. The key parameter is 'title', which determines where this page appears in the Storybook hierarchy. Requires Storybook Docs and the proper bundler configuration for MDX/JSX.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Lemon UI.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Meta title=\\\"Lemon UI/Overview\\\" />\n```\n\n----------------------------------------\n\nTITLE: Example Playwright Selector Strict Mode Error Message - Plain Text\nDESCRIPTION: This plain text snippet shows a Playwright error message encountered when a test locator matches multiple elements in strict mode, demonstrating the importance of writing precise selectors in end-to-end tests. There are no direct dependencies, but the message is only relevant when using Playwright for UI testing. Inputs are HTML elements as matched by the test locator; the output is an error report showing matched elements and suggested corrections.\nSOURCE: https://github.com/posthog/posthog/blob/master/playwright/README.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nError: locator.click: Error: strict mode violation: locator('text=Set a billing limit') resolved to 2 elements:\n1) <span class=\"LemonButton__content\">Set a billing limit</span> aka getByTestId('billing-limit-input-wrapper-product_analytics').getByRole('button', { name: 'Set a billing limit' })\n2) <span class=\"LemonButton__content\">Set a billing limit</span> aka getByTestId('billing-limit-input-wrapper-session_replay').getByRole('button', { name: 'Set a billing limit' })\n```\n\n----------------------------------------\n\nTITLE: Running Cypress End-to-End Tests Using Bash\nDESCRIPTION: This shell command starts the legacy Cypress end-to-end test suite for PostHog by setting the START_CYPRESS environment variable and executing the ./bin/e2e-test-runner script. Dependencies include a local PostHog development environment with the Cypress test runner set up. The script is expected to handle test orchestration. No arguments are needed; the output is the Cypress suite results. Ensure Cypress and all test dependencies are installed before running.\nSOURCE: https://github.com/posthog/posthog/blob/master/playwright/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nSTART_CYPRESS=1 ./bin/e2e-test-runner\n```\n\n----------------------------------------\n\nTITLE: Downloading and Decompressing MaxMind Database with Bash\nDESCRIPTION: This bash snippet downloads a compressed IP geolocation database from PostHog's CDN and decompresses it using Brotli, saving the result as mmdb.db. To run, ensure curl and brotli are installed on your system. Input is fetched from a remote URL, decoded, and output to a local file, which is later used by the Hog 3000 service for IP-to-lat/lng resolution.\nSOURCE: https://github.com/posthog/posthog/blob/master/livestream/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://mmdbcdn.posthog.net/ | brotli -d > mmdb.db\n```\n\n----------------------------------------\n\nTITLE: Using PostHog CLI - Bash\nDESCRIPTION: This snippet demonstrates how to invoke the PostHog CLI with the --help flag to list available commands and options. No external dependencies are needed to run this, but PostHog CLI must be installed. Key commands include login, query, sourcemap uploads, and help. Expected output is the command line help text, which contains usage notes and environment variable options that control authentication behavior.\nSOURCE: https://github.com/posthog/posthog/blob/master/cli/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n> posthog-cli --help\\nThe command line interface for PostHog \\ud83e\\udd54\\n\\nUsage: posthog-cli [OPTIONS] <COMMAND>\\n\\nCommands:\\n  login      Interactively authenticate with PostHog, storing a personal API token locally. You can also use the environment variables `POSTHOG_CLI_TOKEN` and `POSTHOG_CLI_ENV_ID`\\n  query      Run a SQL query against any data you have in posthog. This is mostly for fun, and subject to change\\n  sourcemap  Upload a directory of bundled chunks to PostHog\\n  help       Print this message or the help of the given subcommand(s)\\n\\nOptions:\\n      --host <HOST>  The PostHog host to connect to [default: https://us.posthog.com]\\n  -h, --help         Print help\\n  -V, --version      Print version\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies in TypeScript\nDESCRIPTION: Imports the FastPriorityQueue package for priority queue implementation and a utility function promiseResolveReject for creating promises with external resolve/reject handlers.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/ts.txt#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport FastPriorityQueue from 'fastpriorityqueue'\nimport { promiseResolveReject } from 'lib/utils'\n```\n\n----------------------------------------\n\nTITLE: Live Watching and Running Rust Tests via cargo-watch - Shell\nDESCRIPTION: This command uses 'cargo watch' to continuously monitor source file changes and automatically re-run tests for the 'feature-flags' package. Dependencies: cargo-watch, Cargo and Rust must be installed. The '-x' flag specifies the command to run on change. Input is file changes; outputs are test logs each time changes are detected.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncargo watch -x test --package feature-flags\n\n```\n\n----------------------------------------\n\nTITLE: Default Pod Connection\nDESCRIPTION: Example command to connect to a pod with the default 12-hour claim duration.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython toolbox.py\n```\n\n----------------------------------------\n\nTITLE: Running Snowflake Password Auth Tests\nDESCRIPTION: Command to execute Snowflake batch export tests using password authentication with warehouse, username, password, account, and role credentials.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/temporal/tests/batch_exports/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=1 SNOWFLAKE_WAREHOUSE='your-warehouse' SNOWFLAKE_USERNAME='your-username' SNOWFLAKE_PASSWORD='your-password' SNOWFLAKE_ACCOUNT='your-account' SNOWFLAKE_ROLE='your-role' pytest posthog/temporal/tests/batch_exports/test_snowflake_batch_export_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Cutting and Publishing CLI Releases - Bash\nDESCRIPTION: This snippet illustrates the sequential Bash commands needed to create a new release branch, bump the package version (manually performed in Cargo.toml), commit changes, tag the release, push changes, and optionally publish to crates.io. The process assumes the project is a Rust application managed with Cargo, and requires git, cargo, and potentially cargo-dist as dependencies. Inputs are the desired version string and commit message; outputs are a new release tag and, if invoked, a public crate release.\nSOURCE: https://github.com/posthog/posthog/blob/master/cli/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b \"cli/release-v0.1.0-pre1\"\\n# Bump version number in Cargo.toml\\ngit add .\\ngit commit -m \"Bump version number\"\\ngit tag \"posthog-cli-v0.1.0-prerelease.1\"\\ngit push\\ngit push --tags\\n# Optional - also publish to crates.io\\ncd cli && cargo publish\n```\n\n----------------------------------------\n\nTITLE: Custom Duration Pod Connection\nDESCRIPTION: Example command to connect to a pod with a custom claim duration of 4 hours.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npython toolbox.py --claim-duration 4\n```\n\n----------------------------------------\n\nTITLE: Running Snowflake Key Pair Auth Tests\nDESCRIPTION: Command to execute Snowflake batch export tests using key pair authentication with warehouse, username, private key, passphrase, account, and role credentials.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/temporal/tests/batch_exports/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=1 SNOWFLAKE_WAREHOUSE='your-warehouse' SNOWFLAKE_USERNAME='your-username' SNOWFLAKE_PRIVATE_KEY='your-private-key' SNOWFLAKE_PRIVATE_KEY_PASSPHRASE='your-passphrase' SNOWFLAKE_ACCOUNT='your-account' SNOWFLAKE_ROLE='your-role' pytest posthog/temporal/tests/batch_exports/test_snowflake_batch_export_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Making Script Executable in Unix\nDESCRIPTION: Command to make the toolbox.py script executable on Unix-based systems.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nchmod +x toolbox.py\n```\n\n----------------------------------------\n\nTITLE: Setting Up Django Test Environment for Postgres - Shell\nDESCRIPTION: This command runs a Django management command to configure the test environment specifically for PostgreSQL. Dependencies: Python, Django, and the manage.py script must be available. The 'TEST=1' environment variable signals test-specific configuration. Expects the Django project with 'setup_test_environment' command. No direct input/output unless run interactively.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nTEST=1 python manage.py setup_test_environment --only-postgres\n\n```\n\n----------------------------------------\n\nTITLE: Starting Plugin Server for Functional Tests - Bash Configuration\nDESCRIPTION: Command to start the plugin server in development mode with specific configuration for functional testing. Sets various environment variables including metrics, database connections, and logging levels.\nSOURCE: https://github.com/posthog/posthog/blob/master/plugin-server/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nAPP_METRICS_FLUSH_FREQUENCY_MS=0 \\\n    CLICKHOUSE_DATABASE='default' \\\n    DATABASE_URL=postgres://posthog:posthog@localhost:5432/test_posthog \\\n    PLUGINS_DEFAULT_LOG_LEVEL=0 \\\n    RELOAD_PLUGIN_JITTER_MAX_MS=0 \\\n    PLUGIN_SERVER_MODE=functional-tests \\\n    pnpm start:dev\n```\n\n----------------------------------------\n\nTITLE: Running Single Benchmark Test\nDESCRIPTION: Command for running a specific benchmark test with quick iteration, using regex pattern matching for test selection.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/benchmarks/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nasv run --config ee/benchmarks/asv.conf.json --bench track_lifecycle --quick\n```\n\n----------------------------------------\n\nTITLE: Running Frontend Tests Commands\nDESCRIPTION: Commands for running frontend tests, including full test suite and single test execution using Jest.\nSOURCE: https://github.com/posthog/posthog/blob/master/CLAUDE.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd frontend && pnpm test\ncd frontend && pnpm jest <test_file>\n```\n\n----------------------------------------\n\nTITLE: Running Full Benchmark Suite\nDESCRIPTION: Commands for setting up the benchmark machine and running the complete benchmark suite with Clickhouse credentials.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/benchmarks/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Set up machine\nasv machine --machine ci-benchmarks --config ee/benchmarks/asv.conf.json\n# Replace X with appropriate credentials\nCLICKHOUSE_HOST=X CLICKHOUSE_USER=X CLICKHOUSE_PASSWORD=X CLICKHOUSE_DATABASE=posthog asv run --config ee/benchmarks/asv.conf.json\n```\n\n----------------------------------------\n\nTITLE: Running Python Tests Commands\nDESCRIPTION: Commands for running Python tests, including full test suite and single test execution.\nSOURCE: https://github.com/posthog/posthog/blob/master/CLAUDE.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npytest\npytest path/to/test.py::TestClass::test_method\n```\n\n----------------------------------------\n\nTITLE: Running Functional Tests - Bash Command\nDESCRIPTION: Command to execute functional tests with specific database configuration settings using pnpm.\nSOURCE: https://github.com/posthog/posthog/blob/master/plugin-server/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nCLICKHOUSE_DATABASE='default' \\\n    DATABASE_URL=postgres://posthog:posthog@localhost:5432/test_posthog \\\n    pnpm functional_tests --watch\n```\n\n----------------------------------------\n\nTITLE: Common Error Message for Missing MS SQL Drivers\nDESCRIPTION: The error message displayed when attempting to connect a SQL database to the data warehouse without the required MS SQL drivers installed.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/warehouse/README.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nsymbol not found in flat namespace '_bcp_batch'\n```\n\n----------------------------------------\n\nTITLE: Backfilling Benchmark Data\nDESCRIPTION: Commands for backfilling historical benchmark data using date-period parameter and publishing results.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/benchmarks/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCLICKHOUSE_HOST=X CLICKHOUSE_USER=X CLICKHOUSE_PASSWORD=X CLICKHOUSE_DATABASE=posthog asv run --config ee/benchmarks/asv.conf.json --date-period 4d master~500..\n```\n\n----------------------------------------\n\nTITLE: Build and Development Commands\nDESCRIPTION: Commands for building frontend assets and starting the development environment.\nSOURCE: https://github.com/posthog/posthog/blob/master/CLAUDE.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd frontend && pnpm build\n./bin/start\n```\n\n----------------------------------------\n\nTITLE: Running S3 Batch Export Tests\nDESCRIPTION: Command to execute S3 batch export tests with KMS key ID and bucket name in debug mode.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/temporal/tests/batch_exports/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=1 S3_TEST_KMS_KEY_ID='1111111-2222-3333-4444-55555555555' S3_TEST_BUCKET='your-test-bucket' pytest posthog/temporal/tests/batch_exports/test_s3_batch_export_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Installing Microsoft SQL Server Drivers on macOS using Homebrew\nDESCRIPTION: Commands to install MS SQL drivers via Homebrew. This installs the Microsoft ODBC Driver 18 and SQL Server tools needed for PostHog to connect to SQL data sources.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/warehouse/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew tap microsoft/mssql-release https://github.com/Microsoft/homebrew-mssql-release\nbrew update\nHOMEBREW_ACCEPT_EULA=Y brew install msodbcsql18 mssql-tools18\n```\n\n----------------------------------------\n\nTITLE: Installing ASV Dependencies\nDESCRIPTION: Commands for installing airspeed velocity (asv) and its virtualenv dependency using pip package manager.\nSOURCE: https://github.com/posthog/posthog/blob/master/ee/benchmarks/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install asv virtualenv\n```\n\n----------------------------------------\n\nTITLE: Node-rdkafka Patching Commands\nDESCRIPTION: Series of bash commands to patch node-rdkafka with cooperative rebalancing functionality. Involves cloning the repository, generating diff, and applying patches.\nSOURCE: https://github.com/posthog/posthog/blob/master/plugin-server/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# setup a local node-rdkafka clone\ngit clone git@github.com:PostHog/node-rdkafka.git\ncd node-rdkafka\ngit remote add blizzard git@github.com:Blizzard/node-rdkafka.git\ngit fetch blizzard\n\n# generate the diff\ngit diff blizzard/master > ~/node-rdkafka.diff\n\n# in the plugin-server directory, this will output a temporary working directory\npnpm patch node-rdkafka@2.17.0\n\n# enter the temporary directory from the previous command\ncd /private/var/folders/b7/bmmghlpx5qdd6gpyvmz1k1_m0000gn/T/6082767a6879b3b4e11182f944f5cca3\n\n# if asked, skip any missing files\npatch -p1 < ~/node-rdkafka.diff\n\n# in the plugin-server directory, target the temporary directory from the previous command\npnpm patch-commit /private/var/folders/b7/bmmghlpx5qdd6gpyvmz1k1_m0000gn/T/6082767a6879b3b4e11182f944f5cca3\n```\n\n----------------------------------------\n\nTITLE: Installing pymssql from Source for Persistent Connection Issues\nDESCRIPTION: Alternative installation command for installing pymssql from source without cache, which can resolve persistent connection issues with MS SQL drivers.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/warehouse/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install --pre --no-binary :all: pymssql --no-cache\n```\n\n----------------------------------------\n\nTITLE: Setting up ANTLR on Ubuntu\nDESCRIPTION: Script to install and configure ANTLR 4.13.2 on Ubuntu systems. Includes installing Java runtime, downloading ANTLR jar, and setting up environment variables.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/hogql/grammar/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport ANTLR_VERSION=4.13.2\n\nsudo apt-get install default-jre\nmkdir antlr\ncd antlr\ncurl -o antlr.jar https://www.antlr.org/download/antlr-$ANTLR_VERSION-complete.jar\nexport PWD=`pwd`\necho '#!/bin/bash' > antlr\necho \"java -jar $PWD/antlr.jar \\$*\" >> antlr\nchmod +x antlr\nexport CLASSPATH=\".:$PWD/antlr.jar:$CLASSPATH\"\nexport PATH=\"$PWD:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: Building Grammar using pnpm\nDESCRIPTION: Command to build the grammar using the project's predefined pnpm script.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/hogql/grammar/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm run grammar:build\n```\n\n----------------------------------------\n\nTITLE: Implementing Cohort Matching Instructions in HogQL - v1.0.1\nDESCRIPTION: Defines bytecode operations for cohort membership checking, including IN_COHORT and NOT_IN_COHORT operations.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogvm/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nIN_COHORT = 27     # [val2, val1, IREGEX]               # val1 in cohort val2\nNOT_IN_COHORT = 28 # [val2, val1, NOT_IREGEX]           # val1 not in cohort val2\n```\n\n----------------------------------------\n\nTITLE: Importing Storybook Meta Addon - JavaScript/MDX\nDESCRIPTION: Imports the 'Meta' component from the Storybook Docs addon to enable Storybook-specific configuration and documentation settings. Required dependency: '@storybook/addon-docs'. This sets up the ability to define component metadata and display controls in Storybook UI pages.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Hello.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Meta } from '@storybook/addon-docs'\n```\n\n----------------------------------------\n\nTITLE: Direct Execution of Toolbox Script\nDESCRIPTION: Command to directly execute the toolbox script on Unix-based systems with optional flags.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./toolbox.py [flags]\n```\n\n----------------------------------------\n\nTITLE: Configuring Storybook Meta Information - MDX\nDESCRIPTION: Uses the <Meta title=\" Hello\" /> tag to define the title and configure how this documentation page appears within the Storybook sidebar. Prerequisite: 'Meta' must be imported from '@storybook/addon-docs', and Storybook MDX syntax is required for this configuration. Key parameter: 'title', which sets the Storybook item's navigation label. No data inputs or outputs beyond display context.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Hello.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: MDX\nCODE:\n```\n<Meta title=\\\" Hello\\\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Storybook Meta Addon (JavaScript)\nDESCRIPTION: This code snippet imports the Meta component from Storybook's addon-docs package, a standard requirement for setting up documentation and stories in Storybook using MDX. The Meta component is used to annotate and configure metadata for the Storybook section. No additional dependencies are required, but the surrounding file must be processed by the Storybook MDX/JSX environment.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Lemon UI.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Meta } from '@storybook/addon-docs'\n```\n\n----------------------------------------\n\nTITLE: Extending Existing Pod Duration\nDESCRIPTION: Example command to extend the duration of an existing pod claim to 24 hours.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython toolbox.py --update-claim --claim-duration 24\n```\n\n----------------------------------------\n\nTITLE: Setting Storybook Documentation Page Title (JSX)\nDESCRIPTION: This JSX snippet utilizes the `Meta` component, typically imported from `@storybook/addon-docs` (as seen in the import statement `import { Meta } from '@storybook/addon-docs';` preceding this snippet in the file), to configure metadata for a Storybook documentation page. The `title` prop specifically sets the display title of the page in the Storybook navigation and header.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/How to use components.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Meta title=\" How to use components?\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Meta Component from Storybook in React\nDESCRIPTION: This code snippet imports the Meta component from Storybook's addon-docs package. It's used to set metadata for the Storybook documentation page.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Missing scenes.stories.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Meta } from '@storybook/addon-docs'\n```\n\n----------------------------------------\n\nTITLE: Linting Commands\nDESCRIPTION: Commands for running linting tools on both Python and frontend code, including TypeScript checking.\nSOURCE: https://github.com/posthog/posthog/blob/master/CLAUDE.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nruff .\ncd frontend && pnpm format\ncd frontend && pnpm typescript:check\n```\n\n----------------------------------------\n\nTITLE: Setting Storybook Page Title with Meta Component in React\nDESCRIPTION: This code uses the imported Meta component to set the title of the Storybook page to 'Missing scenes'. This helps in organizing and navigating the Storybook documentation.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/stories/Missing scenes.stories.mdx#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Meta title=\" Missing scenes\" />\n```\n\n----------------------------------------\n\nTITLE: Running Schema Build Command\nDESCRIPTION: Command to regenerate the schema definitions for the web analytics system, executed from the project root directory. This updates both TypeScript and Python schema definitions.\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/web-analytics/contributing.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm run schema:build\n```\n\n----------------------------------------\n\nTITLE: Starting Development Stack with Docker Compose\nDESCRIPTION: Command to start the development stack using Docker Compose with wait flag to ensure services are ready.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f docker-compose.yml up -d --wait\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR on macOS\nDESCRIPTION: Command to install ANTLR compiler using Homebrew package manager on macOS systems.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/hogql/grammar/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install antlr\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests with Database Configuration\nDESCRIPTION: Command to run Rust tests with a note about required DATABASE_URL environment variable. The tests rely on a PostgreSQL database connection defined in the project's .env file.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Installing HogQL Parser Package\nDESCRIPTION: Command for local installation of the HogQL parser package using pip package manager.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogql_parser/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install ./hogql_parser\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on MacOS\nDESCRIPTION: Commands to install required libraries (boost and antlr4-cpp-runtime) using Homebrew package manager.\nSOURCE: https://github.com/posthog/posthog/blob/master/common/hogql_parser/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install boost antlr4-cpp-runtime\n```\n\n----------------------------------------\n\nTITLE: Running Playwright End-to-End Tests Using Bash\nDESCRIPTION: This bash command initiates the Playwright test suite by setting the START_PLAYWRIGHT environment variable and invoking the same ./bin/e2e-test-runner script. It requires Playwright and any related dependencies to be available in the environment. The command launches all Playwright-based end-to-end tests for PostHog, outputting test results to the console. Before running, ensure Playwright is installed (see subsequent guidance for installing Playwright).\nSOURCE: https://github.com/posthog/posthog/blob/master/playwright/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSTART_PLAYWRIGHT=1 ./bin/e2e-test-runner\n```\n\n----------------------------------------\n\nTITLE: Configuring Local SDK Reference in package.json\nDESCRIPTION: JSON configuration to use local PostHog JS SDK for testing survey changes in the main PostHog app\nSOURCE: https://github.com/posthog/posthog/blob/master/frontend/src/scenes/surveys/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"posthog-js\": \"file:../posthog-js\"\n```\n\n----------------------------------------\n\nTITLE: Running Toolbox with Python\nDESCRIPTION: Command to execute the toolbox script using Python interpreter with optional flags.\nSOURCE: https://github.com/posthog/posthog/blob/master/infra-scripts/clitools/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython toolbox.py [flags]\n```\n\n----------------------------------------\n\nTITLE: Running Playwright Tests Against a Local PostHog Instance Using Bash\nDESCRIPTION: This shell command executes Playwright tests against an already running PostHog service using set environment variables for authentication and target URL, then runs Playwright's UI mode using pnpm. Required dependencies include a working local PostHog instance at the specified BASE_URL, Playwright installed, and pnpm configured in the environment. Inputs include LOGIN_USERNAME, LOGIN_PASSWORD, and BASE_URL for targeting the correct test environment. The output is an interactive Playwright test runner UI.\nSOURCE: https://github.com/posthog/posthog/blob/master/playwright/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nLOGIN_USERNAME='my@email.address' LOGIN_PASSWORD=\"the-password\" BASE_URL='http://localhost:8010' pnpm --filter=@posthog/playwright exec playwright test --ui\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Compose Services for Local Development - Shell\nDESCRIPTION: This shell snippet starts docker compose using a specific YAML configuration file to bring up service dependencies required for development and testing. Dependencies: Docker and docker-compose must be installed. Expects a 'docker-compose.dev.yml' present one directory up from the current working directory. Outputs containers running in detached mode. No additional parameters are accepted.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndocker compose -f ../docker-compose.dev.yml up -d\n\n```\n\n----------------------------------------\n\nTITLE: Running the Feature-Flags Service with Debug Logging - Shell\nDESCRIPTION: This snippet runs the feature-flags binary from the Rust package with debug-level logging enabled. Dependencies: Rust, Cargo, and a pre-defined binary target named 'feature-flags'. 'RUST_LOG=debug' environment variable enables verbose logging for easier debugging. Outputs service runtime logs and errors to stdout/stderr.\nSOURCE: https://github.com/posthog/posthog/blob/master/rust/feature-flags/README.md#2025-04-23_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nRUST_LOG=debug cargo run --bin feature-flags\n\n```\n\n----------------------------------------\n\nTITLE: Starting Development Stack with Docker Compose\nDESCRIPTION: Command to initialize the development environment using Docker Compose with wait flag\nSOURCE: https://github.com/posthog/posthog/blob/master/products/editor/backend/chunking/test/fixtures/md.txt#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f docker-compose.yml up -d --wait\n```\n\n----------------------------------------\n\nTITLE: Running BigQuery Batch Export Tests\nDESCRIPTION: Command to execute BigQuery batch export tests using credentials file and debug mode. Requires Google application credentials to be set.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/temporal/tests/batch_exports/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nDEBUG=1 GOOGLE_APPLICATION_CREDENTIALS=/path/to/my/project-credentials.json pytest posthog/temporal/tests/batch_exports/test_bigquery_batch_export_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Django EarlyAccessFeature Migration\nDESCRIPTION: Migration script that modifies the options and metadata for the EarlyAccessFeature model in Django. Updates the options field to include ordering and constraints.\nSOURCE: https://github.com/posthog/posthog/blob/master/products/early_access_features/migrations/max_migration.txt#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Generated by Django 3.2.16 on 2023-01-23 11:25\n\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('posthog', '0001_squashed_0474_alter_earlyaccessfeature_options'),\n    ]\n\n    operations = [\n        migrations.AlterModelOptions(\n            name='earlyaccessfeature',\n            options={'constraints': [('name_per_team', 'unique(\"team_id\", lower(\"name\"))')], 'ordering': ['created_at']},\n        ),\n    ]\n```\n\n----------------------------------------\n\nTITLE: Email Domain List - Plaintext Configuration\nDESCRIPTION: A list of email domains including mail2*.com vanity domains, country-specific domains, and generic email providers. This appears to be a configuration or reference list for email validation or system setup.\nSOURCE: https://github.com/posthog/posthog/blob/master/posthog/helpers/generic_emails.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nmail2member.com\nmail2memphis.com\nmail2methodist.com\n[...]\nmetta.lk\n```"
  }
]