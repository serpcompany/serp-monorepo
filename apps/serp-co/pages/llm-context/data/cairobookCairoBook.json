[
  {
    "owner": "cairo-book",
    "repo": "cairo-book",
    "content": "TITLE: Writing to Contract State in Cairo\nDESCRIPTION: Illustrates writing a value to the contract's storage within the `set` function. The `.write()` method is called on the storage variable (`stored_data`), taking the new value (`data`) as an argument. This operation requires mutable access to the state, indicated by `ref self` in the function signature.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_01_simple_contract/src/lib.cairo:write_state}}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Closures in Cairo\nDESCRIPTION: Demonstrates how to define and use closures in Cairo as anonymous functions with arguments specified between pipes (`|`). Shows type inference for closure parameters and return values where explicit type annotations are not required. Illustrates how closure bodies can be expressions either inline or within curly braces. This example serves as an introduction to using closures for flexible behavior without defining separate named functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_closures/src/lib.cairo:basic}}\n```\n\n----------------------------------------\n\nTITLE: Using Result to Convert Overflowing Addition to Option Type in Cairo\nDESCRIPTION: This snippet demonstrates a function that takes two u128 integers and returns an Option<u128>. It internally calls the previous overflowing add function returning a Result and uses pattern matching to convert an Ok result into Some(sum) and an Err result into None to indicate failure. This function exemplifies how to use Result to implement non-panicking error handling and represent absent values with Option.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/no_listing_09_result_example/src/lib.cairo:checked-add}}\n```\n\n----------------------------------------\n\nTITLE: Writing to a Storage Mapping in Cairo\nDESCRIPTION: This snippet demonstrates how to write a value to a storage mapping by getting the storage pointer for the key and then calling write with the new value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-01-storage-mappings.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nfn set_balance(ref self: ContractState, amount: u64) {\n    let caller = get_caller_address();\n    self.balances.write(caller, amount);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting the Base Address of a Storage Variable in Cairo\nDESCRIPTION: This snippet shows how to access the base address of a storage variable using the `__base_address__` attribute, which returns a `felt252` value representing the storage slot's base address derived by the `sn_keccak` hash of the variable's name. This base address serves as the foundation for further address calculations in nested storage structures such as maps and vectors. This is foundational for understanding storage layout and computations in Cairo contracts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:total_names_address}}\n```\n\n----------------------------------------\n\nTITLE: Defining State-Modifying External Functions in Cairo\nDESCRIPTION: Illustrates a public 'external' function within an `impl` block. It takes `self: ContractState` by reference (`ref`), granting both read and write access to the contract's storage, allowing state modifications.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:external}}\n```\n\n----------------------------------------\n\nTITLE: Defining the Generic Result Enum in Cairo\nDESCRIPTION: This snippet shows the definition of the generic Result<T, E> enum with two variants: Ok containing a value of type T, and Err containing a value of type E. This enum represents success or failure outcomes in functions. It enables returning either a valid result or an error without terminating the program. No external dependencies are required for this enum definition.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/no_listing_07_result_enum/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Extracting a Function to Find the Largest Number in an Array in Cairo\nDESCRIPTION: This snippet refactors the duplicated code by defining a function named 'largest' that accepts a parameter for an array of u8 values and returns the largest element. The previous duplicated code calls this function instead of repeating logic, improving code clarity and maintainability. The function parameter is passed by reference, enabling operations on any concrete array passed at runtime. The snippet assumes a Cairo development environment and demonstrates basic function abstraction.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-00-generic-types-and-traits.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_03/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Deploying a Starknet Contract in Cairo\nDESCRIPTION: This snippet showcases the Cairo code required to deploy a Starknet contract using Starknet Foundry. It includes declaring the contract class, serializing constructor calldata (if any), and deploying the contract to retrieve its address. Requires the `snforge_std` library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:deployment}}\n```\n\n----------------------------------------\n\nTITLE: Initializing Contract State with a Cairo Constructor\nDESCRIPTION: Demonstrates the definition of a `constructor` function in Cairo, annotated with `#[constructor]`. This special function runs only once upon deployment, takes `self: ContractState` by reference (`ref`), and optionally other arguments (e.g., `owner: Person`) to initialize the contract's storage.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:constructor}}\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultTrait for Working with Result Enum in Cairo\nDESCRIPTION: This snippet provides the ResultTrait and its implementation ResultTraitImpl containing helpful methods for handling Result values. It includes methods like expect and unwrap to extract Ok values with optional custom panic messages, expect_err and unwrap_err to extract Err values similarly, and boolean methods is_ok and is_err to check the variant without consuming the Result. It requires that the generic types T and E implement the Drop trait to enforce resource cleanup. These methods enable safe extraction and introspection of Results with informative panics when necessary.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/no_listing_08_result_trait/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Finding Largest Number in an Array without Function Extraction in Cairo\nDESCRIPTION: This snippet shows a simple imperative program in Cairo that finds the largest number in an array of u8 by iterating through all elements and tracking the maximum seen so far. It directly stores the array and iterates inline without abstraction, illustrating duplicated logic when repeated across multiple arrays. It requires Cairo language environment and defines variables to hold array values and the current largest element.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-00-generic-types-and-traits.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_01/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Basic panic Function Example in Cairo\nDESCRIPTION: Demonstrates how to use the basic panic function to terminate program execution with an error code of 2. The execution stops at the panic statement, preventing any subsequent code from running.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let mut data = array![1, 2, 3];\n    data.append(4);\n    panic(array![2]);\n    println!(\"This code is never reached: {:?}\", data);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Struct Equality with assert_eq! and assert_ne!\nDESCRIPTION: This snippet illustrates how to use `assert_eq!` and `assert_ne!` macros to compare structs in Cairo. It provides a simple example demonstrating how to define a struct, initialize instances, and then use `assert_eq!` and `assert_ne!` to test the equality of these struct instances. To use this snippet, you need to define the struct and ensure it implements the `PartialEq` and `Debug` traits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\n// in src/lib.cairo\n#[derive(Drop, Debug, PartialEq)]\nstruct Point {\n    x: felt252,\n    y: felt252,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_point_equality() {\n        let p1 = Point { x: 10, y: 20 };\n        let p2 = Point { x: 10, y: 20 };\n        let p3 = Point { x: 30, y: 40 };\n\n        assert_eq!(p1, p2);\n        assert_ne!(p1, p3);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Validating User Balance Using Assertions in Cairo\nDESCRIPTION: This snippet demonstrates the use of the `assert!` macro in Cairo to validate that a user has sufficient balance before allowing a withdrawal operation. It serves to enforce preconditions, preventing state changes if the conditions fail, thereby ensuring atomicity and security of state transitions. Dependencies include the Cairo language environment and the assert macro within smart contracts. Inputs include user balance and requested withdrawal amount; the output is either a successful withdrawal state change or transaction failure without state modification.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-01-general-recommendations.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch104-starknet-smart-contracts-security/no_listing_01_assert_balance/src/lib.cairo:withdraw}}\n```\n\n----------------------------------------\n\nTITLE: Creating a User Instance with a Function in Cairo\nDESCRIPTION: This code defines a `build_user` function that returns a `User` instance initialized with specific values, including setting default values like `true` for `active` and `1` for `sign_in_count`. It demonstrates returning structs from functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:build_user}}\n```\n\n----------------------------------------\n\nTITLE: Generic Enum `Option<T>` in Cairo\nDESCRIPTION: This example defines the `Option<T>` enum, a generic type with two variants: `Some` holding a value of type `T` and `None` representing absence of value. It provides an abstraction for optional values applicable to any type `T`, promoting flexible and type-safe code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_09_option/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Struct in Cairo\nDESCRIPTION: This snippet shows how to define a `User` struct in Cairo, including the syntax for naming and specifying fields with their types. It serves as a template for creating user-related data structures.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/src/lib.cairo:user}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Struct `Wallet<T>` in Cairo\nDESCRIPTION: This snippet demonstrates how to define a struct `Wallet<T>` with a generic type parameter `T` for its `balance` field. It also shows the use of the `derive` macro to automatically implement the `Drop` trait, and how to explicitly implement `Drop` for `Wallet<T>` with a trait bound that `T` must also be droppable.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_06_derive_generics/src/lib.cairo}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_07_drop_explicit/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using Trait Default Implementation with Author Method in Cairo\nDESCRIPTION: This demonstrates how to use the default `summarize` implementation that calls the `summarize_author` method, which is specifically implemented for the `Tweet` struct. When `summarize` is called on a `Tweet` instance, it uses the provided `summarize_author` implementation to generate the summary.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let tweet = Tweet {\n        username: '@EliBenSasson',\n        content: 'hello cairo',\n        reply: false,\n        retweet: false,\n    };\n\n    let summary = Summary::summarize(@tweet);\n    assert(summary == '(Read more from @EliBenSasson...)', 'wrong summary');\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating a Contract to a Component in Cairo\nDESCRIPTION: This snippet explains the required modifications to convert a regular contract into a component, including annotations like `#[starknet::component]`, adding generic parameters, and updating function `self` arguments to `ComponentState<TContractState>`. It facilitates component reusability and integration into multiple contracts with minimal changes.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-00-composability-and-components.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/contract.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Defining Read-Only View Functions in Cairo\nDESCRIPTION: Presents a public 'view' function within an `impl` block. It takes `self: @ContractState` as a snapshot, providing read-only access to storage via `self` at compile time. Note that state modification might still occur through direct system calls or calls to other contracts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:view}}\n```\n\n----------------------------------------\n\nTITLE: Scaling Rectangle Instances Using Mutable References - Cairo\nDESCRIPTION: This snippet showcases how to define a mutating method (scale) for Rectangle that takes a mutable reference to self, allowing the instance's dimensions to be changed in place based on an input factor. The trait and impl block define the scale method, while the main function illustrates its usage. Requirements include understanding mutable references and the snapshot operator, with expected input as a Rectangle instance and a scaling factor; the output is the modified Rectangle.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/src/lib.cairo:trait_impl}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_03_references/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Storing Data in Boxed Segment using Box<T> in Cairo\nDESCRIPTION: This code snippet demonstrates how to use a Box to store a u128 value in the boxed segment of the Cairo VM. The value '5' is allocated in the boxed segment, and a pointer 'b' of type Box<u128> references this memory location.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-02-smart-pointers.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/listing_04_basic_box/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Constraining Associated Items with Trait Bounds in Cairo\nDESCRIPTION: This code demonstrates the use of Cairo's experimental associated items constraint feature to extend collections with type-safe logic. The Extend<T, A> trait uses [Item: A] constraints in its implementation to ensure that the element type provided by an iterator matches the element type of the collection being extended. Required experimental features must be enabled in Scarb.toml ('experimental-features = [\"associated_item_constraints\"]'). The snippet depends on the Destruct trait from Cairo for iterator consumption, and enforces that only appropriate element types can be used for collection extension.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_19_associated_items_constraints/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Arrays with for Loops in Cairo (cairo)\nDESCRIPTION: This snippet uses a for loop to iterate over all elements of an array, automatically handling bounds safely and concisely, reducing the risk of missed or out-of-bounds elements. No special dependencies are required. Input is an array; output is each array element printed. This loop is safer and more maintainable than manual index-based iteration.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_46_iter_loop_for/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Testing Contract State with `load` in Cairo\nDESCRIPTION: Demonstrates how to use the `load` function from `snforge_std` to verify initial storage variable values of a deployed Starknet contract. This allows asserting the contract's initial state after deployment, even for variables not exposed by entrypoints.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_constructor}}\n```\n\n----------------------------------------\n\nTITLE: Defining Entrypoints Individually with `#[abi(per_item)]` in Cairo\nDESCRIPTION: Example illustrating the use of `#[abi(per_item)]` on an `impl` block, often combined with `#[generate_trait]`. This attribute allows specifying the entrypoint type (e.g., `external`, `constructor`, `l1_handler`) for each function individually using attributes like `#[external(v0)]`, rather than exposing the entire block.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/no_listing_01_abi_per_item_attribute/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing Array on Creation in Cairo\nDESCRIPTION: Shows two alternative syntaxes for explicitly defining the element type (`u128` in this case) of an array when creating it with `ArrayTrait::new()`: using the turbofish operator `::<T>` or a variable type annotation `: Array<T>`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse array::Array;\n\nfn create_explicit_type() {\n    // Using turbofish\n    let mut arr1 = ArrayTrait::<u128>::new();\n\n    // Using type annotation\n    let mut arr2: Array<u128> = ArrayTrait::new();\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Basic Storage Mapping in Cairo\nDESCRIPTION: This snippet demonstrates how to declare a storage mapping in a contract's storage struct and implement functions to read from and write to it. The mapping associates ContractAddress keys with u64 values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-01-storage-mappings.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::contract]\nmod SimpleStorage {\n    use starknet::{ContractAddress, get_caller_address};\n    use core::starknet::storage::Map;\n\n    #[storage]\n    struct Storage {\n        balances: Map<ContractAddress, u64>,\n    }\n\n    #[external(v0)]\n    fn get_balance(self: @ContractState) -> u64 {\n        let caller = get_caller_address();\n        let balance = self.balances.read(caller);\n        balance\n    }\n\n    #[external(v0)]\n    fn set_balance(ref self: ContractState, amount: u64) {\n        let caller = get_caller_address();\n        self.balances.write(caller, amount);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Storage Variables in Starknet Contracts with Cairo\nDESCRIPTION: This snippet demonstrates how to declare persistent storage variables by defining a Storage struct annotated with #[storage] in Cairo. The struct can contain any type that implements the Store trait and enables structured contract state management on Starknet. Only types implementing Store are allowed; complex types and mappings require special wrappers or patterns.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:storage}}\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Variables with 'mut' in Cairo\nDESCRIPTION: An example showing how to make a variable mutable in Cairo using the 'mut' keyword, which allows changing the variable's value after declaration.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let mut x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Method `balance` using Trait in Cairo\nDESCRIPTION: Defines a generic trait `WalletTrait<T>` and its implementation `WalletImpl<T>` for a `Wallet` struct. The `balance` method in the trait/implementation returns the value of the `balance` field. Generic types are required in both the trait and implementation definitions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\nuse traits::TryInto;\nuse zeroable::Zeroable;\n\n#[derive(Drop, Copy)]\nstruct Wallet<T> {\n    balance: T\n}\n\ntrait WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T;\n}\n\nimpl WalletImpl<T> of WalletTrait<T> {\n    fn balance(self: @Wallet<T>) -> T {\n        *self.balance\n    }\n}\n\nfn main() {\n    let w = Wallet { balance: 10 };\n    w.balance();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Full Event Definition Example with Structs and Enums in Cairo\nDESCRIPTION: A comprehensive event definition example featuring three events: BookAdded, FieldUpdated, and BookRemoved. BookAdded and BookRemoved use structs for event data, while FieldUpdated uses a nested enum with structs combined with the #[flat] attribute to flatten inner variants as event names. It highlights how key and data fields are handled within events for filtering and data transmission.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-03-contract-events.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:full_events}}\n```\n\n----------------------------------------\n\nTITLE: Serialized Event Representation in Transaction Receipt (Adding a Book)\nDESCRIPTION: Provides an example JSON fragment of the transaction receipt showing the serialized event data for a BookAdded event emitted when adding a book with id = 42, title = 'Misery', and author = 'S. King'. The example details how keys and data fields are encoded, emphasizing the use of selectors and key serialization for event filtering.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-03-contract-events.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"events\": [\n    {\n      \"from_address\": \"0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79\",\n      \"keys\": [\n        \"0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc\",\n        \"0x532e204b696e67\"\n      ],\n      \"data\": [\n        \"0x2a\",\n        \"0x4d6973657279\"\n      ]\n    }\n  ]\n```\n\n----------------------------------------\n\nTITLE: Defining Store-Compatible Enums for Contract Storage in Cairo\nDESCRIPTION: This example details how to define an enum for usage as a storage variable by deriving the Store trait and specifying a default variant using #[default]. The enum can only be stored if all contained types implement Store, and the default variant is required for correct deserialization from uninitialized slots, preventing runtime errors.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:enum}}\n```\n\n----------------------------------------\n\nTITLE: Implementing StorePacking Trait for Custom Struct in Cairo\nDESCRIPTION: Implements the `StorePacking<Sizes, u128>` trait for the `Sizes` struct. The `pack` function combines the `u8`, `u32`, and `u64` fields into a single `u128` using left bit shifts and addition (bitwise OR). The `unpack` function extracts the original fields from the `u128` using right bit shifts and bit masks. Constants like `TWO_POW_8`, `TWO_POW_40`, `MASK_8`, and `MASK_32` are used for clarity in bit manipulation. Requires the `Sizes` struct definition.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-01-optimizing-storage-costs.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_01_storage_packing/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Capturing Environment Variables in Cairo Closures\nDESCRIPTION: Shows a closure capturing a variable (`x`) from its surrounding environment to use within its computation. This example highlights one key closure feature: the ability to access bindings present in the enclosing scope. It notes that currently mutable variables cannot be captured by closures, a limitation expected to be addressed in later Cairo versions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_closures/src/lib.cairo:environment}}\n```\n\n----------------------------------------\n\nTITLE: Using assert_xx! Macros for Comparisons\nDESCRIPTION: This code demonstrates the use of `assert_lt!`, `assert_le!`, `assert_gt!`, and `assert_ge!` macros for performing comparisons within tests. The macros check if a given value meets the specified comparison condition and reverts the test if it does not.  The example involves a `Dice` struct and requires the `PartialOrd` and `Copy` traits to be implemented to enable the comparisons.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\n// Code for `assert_xx!` macros\n{{#include ../listings/ch10-testing-cairo-programs/listing_10_08/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Example App Using Pragma Price Feed in Cairo\nDESCRIPTION: This snippet demonstrates an example application that consumes price feed data from Pragma Oracle. It shows how to import necessary modules, interact with the Pragma Oracle contract, and use the retrieved price to perform actions such as calculating the amount of ETH needed to buy an item. The contract includes a `buy_item` function that demonstrates this functionality.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-05-01-price-feeds.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Let Struct Go Out of Scope Without Drop/Destruct (Compile Error)\nDESCRIPTION: This snippet defines a simple struct `A` but does not derive the `Drop` trait. When the variable `a` goes out of scope at the end of `main`, the compiler throws an error because the struct's value hasn't been explicitly moved or destroyed, and it doesn't have an automatic `Drop` implementation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\nstruct A {\n    x: usize,\n}\n\nfn main() {\n    let a = A { x: 1 };\n    // This will cause a compile-time error\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating the Area of a Rectangle Using Separate Variables in Cairo\nDESCRIPTION: This snippet defines an `area` function that takes two separate parameters `width` and `height` of type `u64` representing the dimensions of a rectangle, then returns the computed area as a `u64`. It uses Cairo's 64-bit unsigned integers and demonstrates procedural calculation without grouping related data. The program includes a `main` function invoking `area` with explicit width and height values to calculate and display the rectangle's area. No external dependencies beyond Cairo standard library are required.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfunc area(width: u64, height: u64) -> (area: u64) {  \n    let area = width * height;\n    return (area,);\n}\n\nfunc main() -> (res: u64) {\n    let width = 30;\n    let height = 10;\n    let (res) = area(width, height);\n    return (res,);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait with Default Method Call in Cairo\nDESCRIPTION: This shows the implementation of the `Summary` trait for `Tweet`, only defining `summarize_author`. The default `summarize` implementation from the trait will then call the provided `summarize_author` method. The `Summary` trait provides the behavior of `summarize` without requiring the implementer to write extra code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\nstruct Tweet {\n    username: felt252,\n    content: felt252,\n    reply: bool,\n    retweet: bool,\n}\n\nimpl TweetSummary of Summary<Tweet> {\n    fn summarize_author(self: @Tweet) -> felt252 {\n        self.username\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages from Starknet to Ethereum using Cairo\nDESCRIPTION: Demonstrates how to use the send_message_to_l1 syscall in Cairo to build and send a message payload to a specific L1 contract address. This is the L2 side of cross-layer communication.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/no_listing_03_L1_L2_messaging/src/lib.cairo:felt_msg_send}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Contract Upgradeability Using replace_class_syscall in Cairo\nDESCRIPTION: This snippet shows how to expose an entry point that executes the replace_class_syscall with a new class hash as an argument, allowing for contract upgrades without affecting the contract's state. The implementation includes access control to restrict upgrade capabilities.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-03-upgradeability.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::interface]\ntrait IUpgradeable<T> {\n    fn upgrade(ref self: T, new_class_hash: ClassHash);\n}\n\n#[starknet::component]\nmod Upgradeable {\n    use starknet::ClassHash;\n    use starknet::syscalls::replace_class_syscall;\n\n    #[storage]\n    struct Storage {}\n\n    #[embeddable_as(UpgradeableImpl)]\n    impl Upgradeable<\n        TContractState, +HasComponent<TContractState>\n    > of super::IUpgradeable<ComponentState<TContractState>> {\n        fn upgrade(ref self: ComponentState<TContractState>, new_class_hash: ClassHash) {\n            // Access control should be implemented by the contract embedding this component\n            replace_class_syscall(new_class_hash).expect('Class replacement failed');\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Assignment of Statement Result to Variable in Cairo\nDESCRIPTION: Demonstrates a compilation error resulting from trying to assign the result of a `let` statement (which does not return a value) to another variable. Highlights distinction that assignment statements do not return values in Cairo unlike some other languages.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let y = 6;\n    let x = (let y = 6); // Invalid: statements do not return values\n}\n```\n\n----------------------------------------\n\nTITLE: Testing the Counter Component by Deploying the Mock Contract in Cairo\nDESCRIPTION: Demonstrates tests that deploy the mock contract embedding the Counter component. The tests invoke the component's public entry points through the deployed contract, validating increment functionality and contract behavior. This approach requires a deployment but enables testing in an environment mimicking actual Starknet contracts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_deployed.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Breaking Out of a Loop with the Break Keyword in Cairo\nDESCRIPTION: This snippet adds a break statement inside a loop to demonstrate early exit. The loop executes until the break condition is satisfied, at which point execution continues after the loop. This method helps avoid infinite loops and provides a controlled exit strategy based on runtime conditions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_33_loop_break/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Updating Dictionary Entries and Overwriting Values in Cairo\nDESCRIPTION: This snippet shows how to modify the value associated with an existing key ('Alex') in a Felt252Dict<T>, effectively rewriting its value. It illustrates multiple insertions for the same key and how the last inserted value persists on retrieval, demonstrating the mutable behavior facilitated by the entry list implementation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch03-common-collections/no_listing_10_intro_rewrite/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Match Enum Variants\nDESCRIPTION: This code snippet defines an enum `Coin` with variants for different US coins and a function `value_in_cents` that uses a `match` expression to determine the value of a given coin in cents. The `match` expression compares the `coin` value against each variant of the `Coin` enum, returning the corresponding value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_05_match_example/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Using the ? Operator for Concise Error Propagation with Result in Cairo\nDESCRIPTION: This snippet defines the function do_something_with_parse_u8 which uses the ? operator to call parse_u8, implicitly unwrapping or propagating errors. If parse_u8 returns Ok, the inner value is used. If Err is returned, it propagates the error to the caller. This exemplifies idiomatic, concise error handling patterns in Cairo leveraging the ? operator to avoid verbose match statements.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/listing_09_02/src/lib.cairo:function}}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Fixed Size Array in Cairo\nDESCRIPTION: This code demonstrates how to deconstruct a fixed-size array into multiple variables using pattern matching, similar to tuples.  This allows direct access to elements by binding them to individual variables.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_11\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_42_fixed_size_arr_accessing_elements/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Type Conversion Using the TryInto Trait in Cairo\nDESCRIPTION: This snippet illustrates implementing the `TryInto` trait for a custom type in Cairo, which allows fallible conversions between types returning a `Result` to handle possible failure. This trait is useful when conversion might not always succeed, providing error handling semantics. The example includes defining the `try_into` method, specifying the target type and error type, enhancing robustness when converting complex data types. This approach requires Cairo's trait system and proper error type definitions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nimpl TryInto<u64> for Rectangle {\n    type Error = (); // or appropriate error type\n    fn try_into(self) -> Result<u64, Self::Error> {\n        if self.width > 0 && self.height > 0 {\n            Ok(self.width * self.height)\n        } else {\n            Err(())\n        }\n    }\n}\n\nfunc main() {\n    let rectangle = Rectangle { width: 30, height: 10 };\n    let area_result = rectangle.try_into();\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Reuse Array After Move (Compile Error)\nDESCRIPTION: This code attempts to pass the same array variable `arr` to the function `foo` twice. In Cairo, passing a complex type like Array moves ownership, rendering the original variable unusable. The compiler prevents this double usage.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\nfn foo(mut arr: Array::<usize>) {\n    arr.pop_front();\n}\n\nfn main() {\n    let mut arr = Array::<usize>::new();\n    arr.append(1);\n    arr.append(2);\n\n    foo(arr); // arr is moved here\n    foo(arr); // This line will cause a compile-time error as arr is no longer valid\n}\n```\n\n----------------------------------------\n\nTITLE: Low-Level Contract Call Using `call_contract_syscall`\nDESCRIPTION: This snippet demonstrates how to perform a manual low-level call to another contract's function using `call_contract_syscall`. It highlights how to serialize call arguments into a `Span<felt252>`, invoke the syscall, and handle the serialized return values, offering more control over cross-contract invocations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-02-interacting-with-another-contract.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch102-starknet-cross-contract-interactions/listing_06_syscalls/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Creating and Appending Elements to Array in Cairo\nDESCRIPTION: Demonstrates how to create a new, empty array using `ArrayTrait::new()` and add elements to its end using the `append()` method. Arrays in Cairo are restricted to appending for modification.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\n\nfn create_and_append() {\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(20);\n    arr.append(30);\n}\n```\n\n----------------------------------------\n\nTITLE: Storing complex types in dictionaries with Nullable and Box in Cairo\nDESCRIPTION: Demonstrates how to store complex types like Span<felt252> in dictionaries using Nullable<T> and Box<T>. This approach allows storing types that don't implement Felt252DictValue natively.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\nuse box::BoxTrait;\nuse nullable::{NullableTrait, match_nullable, FromNullableResult};\nuse array::{ArrayTrait, SpanTrait};\nuse dict::Felt252Dict;\nuse traits::Default;\n\nfn main() {\n    // Create a dictionary of spans\n    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();\n\n    // Create an array and fill it with values\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(11);\n    arr.append(12);\n\n    // Insert in the dictionary\n    d.insert(1, NullableTrait::new(arr.span()));\n\n    // Read the value\n    let nullable_span = d.get(1);\n    match match_nullable(nullable_span) {\n        FromNullableResult::Null(()) => {\n            assert(false, 'expected non-null value');\n            0\n        },\n        FromNullableResult::NotNull(val) => {\n            assert(*val.at(0) == 10, 'invalid arr at 0');\n            assert(*val.at(1) == 11, 'invalid arr at 1');\n            assert(*val.at(2) == 12, 'invalid arr at 2');\n            0\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Loop Iterations with Continue in Cairo\nDESCRIPTION: In this snippet, the continue keyword is used within a loop to skip the current iteration when a specified condition is met, specifically when a variable equals 5. Any statements after continue for that iteration are not executed. This helps filter unwanted values during loop execution without breaking the loop.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_34_loop_continue/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Function for Overflow-Safe Addition Returning Result Enum in Cairo\nDESCRIPTION: This code snippet defines a function that takes two u128 integers and returns a Result<u128, u128>. It returns Ok(sum) if the addition of the two input numbers does not overflow the 128-bit limit, or Err(overflow_value) if an overflow occurs. This encapsulates the success or failure of the addition in a Result type for safe handling downstream without panicking or undefined behavior.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/no_listing_09_result_example/src/lib.cairo:overflow}}\n```\n\n----------------------------------------\n\nTITLE: Complete example of using arrays in dictionaries in Cairo\nDESCRIPTION: A comprehensive example showing how to create a dictionary, insert arrays, read values, and append new values to arrays stored in dictionaries. The example demonstrates proper memory management with arrays in dictionaries.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse box::BoxTrait;\nuse dict::Felt252Dict;\nuse nullable::{NullableTrait, match_nullable, FromNullableResult};\nuse traits::Default;\n\nfn get_value(ref dict: Felt252Dict<Nullable<Array<felt252>>>, key: felt252) -> Span<felt252> {\n    let (entry, nullable_arr) = dict.entry(key);\n    match match_nullable(nullable_arr) {\n        FromNullableResult::Null(()) => {\n            dict = entry.finalize(NullableTrait::new(ArrayTrait::new()));\n            ArrayTrait::new().span()\n        },\n        FromNullableResult::NotNull(mut arr) => {\n            // Convert to span before finalizing to avoid moving the array\n            let span = arr.span();\n            dict = entry.finalize(NullableTrait::new(arr));\n            span\n        }\n    }\n}\n\nfn append_value(ref dict: Felt252Dict<Nullable<Array<felt252>>>, key: felt252, value: felt252) {\n    let (entry, nullable_arr) = dict.entry(key);\n    match match_nullable(nullable_arr) {\n        FromNullableResult::Null(()) => {\n            let mut arr = ArrayTrait::new();\n            arr.append(value);\n            dict = entry.finalize(NullableTrait::new(arr));\n        },\n        FromNullableResult::NotNull(mut arr) => {\n            arr.append(value);\n            dict = entry.finalize(NullableTrait::new(arr));\n        }\n    }\n}\n\nfn main() {\n    let mut dict: Felt252Dict<Nullable<Array<felt252>>> = Default::default();\n\n    // Insert an array\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(20);\n    arr.append(30);\n    dict.insert(1, NullableTrait::new(arr));\n\n    // Read the array\n    let span = get_value(ref dict, 1);\n    assert(*span.at(0) == 10, 'Wrong value at index 0');\n    assert(*span.at(1) == 20, 'Wrong value at index 1');\n    assert(*span.at(2) == 30, 'Wrong value at index 2');\n\n    // Append a value to the array\n    append_value(ref dict, 1, 40);\n\n    // Read the updated array\n    let updated_span = get_value(ref dict, 1);\n    assert(*updated_span.at(0) == 10, 'Wrong value at index 0');\n    assert(*updated_span.at(1) == 20, 'Wrong value at index 1');\n    assert(*updated_span.at(2) == 30, 'Wrong value at index 2');\n    assert(*updated_span.at(3) == 40, 'Wrong value at index 3');\n\n    // Add a value to a non-existent key\n    append_value(ref dict, 2, 50);\n    let new_span = get_value(ref dict, 2);\n    assert(*new_span.at(0) == 50, 'Wrong value at index 0');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display for Struct with write! Macro in Cairo\nDESCRIPTION: Demonstrates implementing the Display trait for a custom struct (e.g., Point), leveraging the write! macro for component formatting within the fmt method. This approach streamlines complex formatting logic for custom types, easing maintenance and improving clarity. Requires the struct fields to implement Display and the display logic must accommodate target presentation needs.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_10_display_trait_with_write/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Traits and Impl Blocks for Rectangle Methods - Cairo\nDESCRIPTION: This snippet demonstrates that a struct in Cairo can have methods across several independent trait and impl blocks. Rectangle methods are separated into different traits and implementations, but functionality remains equivalent to grouping all methods together. This technique provides organizational flexibility but is not required for functionality.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_06_multiple_traits/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Parsing and Validating Conversion from felt252 to u8 Returning Result in Cairo\nDESCRIPTION: This snippet shows the parse_u8 function which attempts to convert a felt252 input to a u8 integer. It returns Ok(value) if the conversion is valid, otherwise returns Err with an error message ('Invalid integer'). This usage of Result allows handling conversion failures gracefully while indicating the cause of failure.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch09-error-handling/listing_09_01/src/lib.cairo:function}}\n```\n\n----------------------------------------\n\nTITLE: Sending Message to L1 Example Starknet Cairo\nDESCRIPTION: This example demonstrates using the `send_message_to_l1_syscall` in Cairo. It constructs a payload array with values (1, 2) and sends it to a hardcoded L1 address (3423542542364363), unwrapping the syscall result.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\nlet payload = ArrayTrait::new();\npayload.append(1);\npayload.append(2);\nsend_message_to_l1_syscall(payload).unwrap_syscall();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Voting Contract in Cairo for Starknet\nDESCRIPTION: A complete implementation of a voting smart contract in Cairo for Starknet. It allows voter registration, vote casting, and result tracking with event emission for key actions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_05_vote_contract/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Adding Passing and Failing Test Functions in Cairo - Cairo\nDESCRIPTION: Demonstrates defining multiple test functions in the same module in Cairo, one passing ('exploration') and one failing ('another'), both annotated with #[test]. The failing test deliberately panics with a message. This relies on 'assert!' or the panic macro, and optionally requires 'assert_macros = \"2.8.2\"' in dev dependencies. Both take no parameters; outputs are determined by success or intentional failure, useful for verifying test framework behavior.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n// In src/lib.cairo\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Scarb.toml Configuration for Starknet Foundry\nDESCRIPTION: This code snippet shows the configuration needed in the `Scarb.toml` file to integrate Starknet Foundry for testing. It includes adding `snforge_std` as a dev dependency, setting the test script to use `snforge test`, and allowing prebuilt plugins.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n[dev-dependencies]\nsnforge_std = \"0.39.0\"\n\n[scripts]\ntest = \"snforge test\"\n\n[tool.scarb]\nallow-prebuilt-plugins = [\"snforge_std\"]\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait for Mutable Dynamic Array (MemoryVec) Interface - Cairo\nDESCRIPTION: Specifies a Cairo trait for a vector-like dynamic array, MemoryVec, which supports push, get, set, and len operations. The trait defines the expected methods for any type implementing this interface and serves as a contract for further concrete implementation. The pattern supports generics for value type T, and relies on underlying dictionary primitives for storage.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:trait}}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Constraints in Cairo Closures\nDESCRIPTION: Demonstrates the limitations of Cairo's closure type inference. A closure without explicit type annotations is inferred to a single concrete type based on its first usage; attempting to call the same closure with a differing type results in a compilation error. This snippet shows an example closure and the resulting compiler error when violating this constraint, emphasizing the importance of consistent usage or explicit annotations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:here}}\n```\n\nLANGUAGE: text\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-functional-features/listing_closure_different_types/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Using the Contract Dispatcher to Call ERC20 Functions\nDESCRIPTION: This snippet illustrates a contract that interacts with an ERC20 token by wrapping its address in an `IERC20Dispatcher` instance, allowing calls to functions like `name` and `transfer`. It provides insight into how dispatcher structs simplify inter-contract calls and state modifications.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-02-interacting-with-another-contract.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch102-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Match Pattern Binding with Enum\nDESCRIPTION: This code snippet extends the `Coin` enum to include a `Quarter` variant that holds a `UsState` value. The `match` expression demonstrates how to bind the `UsState` value to a variable `state` when matching the `Coin::Quarter(state)` pattern. This allows extracting and using the inner value of the enum variant.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/src/lib.cairo:enum_def}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_07_match_pattern_bind/src/lib.cairo:function}}\n```\n\n----------------------------------------\n\nTITLE: Deploying Contract Starknet Cairo\nDESCRIPTION: This snippet provides the syntax for the `deploy_syscall` in Cairo, used to deploy a new instance of a previously declared contract class. It requires the class hash, a salt for address computation, constructor calldata, and a flag to deploy from address zero. The syscall returns the address of the newly deployed contract and the constructor's response.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn deploy_syscall(\n    class_hash: ClassHash,\n    contract_address_salt: felt252,\n    calldata: Span<felt252>,\n    deploy_from_zero: bool,\n) -> SyscallResult<(ContractAddress, Span<felt252>)> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Moving Return Values in Cairo\nDESCRIPTION: Illustrates how returning values from a function is equivalent to moving them. The function takes ownership of a value, then returns it to transfer ownership back to the caller.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/listing_02_moving_return_values/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Span from an Array in Cairo\nDESCRIPTION: Demonstrates how to create a `Span` from an existing `Array` using the `span()` method. A `Span` provides an immutable, read-only snapshot of the array's contents, useful for safe sharing and read-only operations without modifying the original array.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse array::SpanTrait;\nuse array::Span;\nuse debug::PrintTrait;\n\nfn array_to_span() {\n    let mut arr = ArrayTrait::new();\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n\n    let arr_span: Span<u128> = arr.span();\n\n    // You can use methods like len(), is_empty(), get(), at() on the span\n    'Span length: '.print(); arr_span.len().print(); '\\n'.print();\n\n    // You cannot use append() on the span\n    // arr_span.append(4); // This would cause a compile error\n}\n```\n\n----------------------------------------\n\nTITLE: Using the UserDatabase to Add and Query Users - Cairo\nDESCRIPTION: Illustrates real usage of the implemented UserDatabase type with sample code to instantiate the database, add users, update their balances, and query values. This functional demonstration expects all predicates and trait implementations from previous code and highlights method call syntax. Inputs are user identifiers and balances, and outputs are the modified database and queried balances.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Writing Contract Storage using storage_write_syscall in Cairo\nDESCRIPTION: Defines the `storage_write_syscall` function to set the value of a specified key within the calling contract's storage. It accepts an `address_domain` (currently only 0), the target `StorageAddress`, and the `felt252` value to be written. It returns `SyscallResult<()>`. This syscall offers direct storage access, differing from `var.write()`. Requires `GasBuiltin` and `System` implicits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\npub extern fn storage_write_syscall(\n    address_domain: u32, address: StorageAddress, value: felt252,\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using the Copy Trait in Cairo\nDESCRIPTION: This example defines a `Point` struct and derives the `Copy` trait for it. Because `Point` is composed only of types that implement `Copy` (felts), it can also implement `Copy`. This allows `p1` to be passed to the `foo` function without moving ownership, meaning `p1` remains valid and can be used again.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Copy, Drop)]\nstruct Point {\n    x: usize,\n    y: usize,\n}\n\nfn foo(p: Point) {\n    // do something with p\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 2 };\n    foo(p1); // p1 is copied here, not moved\n    foo(p1); // This is valid because p1 was copied and still owned by main\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring a Tuple in Cairo\nDESCRIPTION: This example illustrates how to destructure a tuple in Cairo using pattern matching. It binds individual elements of the tuple to separate variables. The program prints the value of `y`, which is `6`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_13_tuple_destructuration/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using an impl alias to embed component\nDESCRIPTION: This code snippet shows a contract integrating a component using an impl alias. This demonstrates how the generic `OwnableImpl<TContractState>` is instantiated with a concrete `ContractState`, leveraging the `HasComponent<TContractState>` trait generated by the component macro to inject the component's logic into the contract.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/contract.cairo:embedded_impl}}\n```\n\n----------------------------------------\n\nTITLE: Creating Instances of a User Struct\nDESCRIPTION: This code demonstrates creating specific instances of the `User` struct by assigning concrete values to each field using key-value pairs. The order of fields can differ from their declaration in the struct.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/listing_01_user_struct/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Tuple in Cairo\nDESCRIPTION: This code snippet demonstrates how to create a tuple with optional type annotations in Cairo. Tuples can hold values of different types and have a fixed length.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_12_tuple_type/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Getting Class Hash At Address Starknet Cairo\nDESCRIPTION: This snippet provides the syntax for the `get_class_hash_at_syscall` in Cairo. It is used to retrieve the class hash of the contract deployed at a given contract address. The function takes the contract address as input and returns the `ClassHash` within a `SyscallResult`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_9\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn get_class_hash_at_syscall(\n    contract_address: ContractAddress,\n) -> SyscallResult<ClassHash> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Example: Using storage_read_syscall in Cairo\nDESCRIPTION: Demonstrates calling `storage_read_syscall` to read from a specific storage address. The example first calculates the `StorageAddress` using `storage_base_address_from_felt252` and then calls the syscall with domain 0, unwrapping the `SyscallResult` to get the stored `felt252` value. Requires importing `storage_base_address_from_felt252`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\nuse starknet::storage_access::storage_base_address_from_felt252;\n\n...\n\nlet storage_address = storage_base_address_from_felt252(3534535754756246375475423547453)\nstorage_read_syscall(0, storage_address).unwrap_syscall()\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to Storage Vec Using push Method - Cairo\nDESCRIPTION: This code demonstrates how to append new elements to a storage Vec within a Cairo smart contract using the push method from MutableVecTrait. The method places an element at the end of the vector and requires a mutable reference to the Vec in contract storage. Ensure core::starknet::storage and the relevant traits are imported, and that the element type matches the Vec declaration. The index increases as elements are pushed, and no return value is given.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-02-storage-vecs.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:push}}\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from Array Front in Cairo\nDESCRIPTION: Explains and demonstrates the `pop_front()` method, which is the only way to remove elements from a Cairo array. This method removes and returns the first element as an `Option<T>`, returning `None` if the array is empty.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse option::OptionTrait;\nuse debug::PrintTrait;\n\nfn remove_from_front() {\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(20);\n    arr.append(30);\n\n    let first_element = arr.pop_front();\n    match first_element {\n        Option::Some(value) => { 'The first value is '.print(); value.print(); '\\n'.print(); },\n        Option::None(_) => { 'Array is empty'.print(); '\\n'.print(); },\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Storage Vec in Cairo Smart Contract - Cairo\nDESCRIPTION: This snippet shows how to declare a storage Vec in Cairo using the Vec type, specifying the element type within angle brackets. The Vec type is imported from core::starknet::storage and should be placed in the contract's Storage struct for persistent collection storage. Dependencies include the core library, and the VecTrait and MutableVecTrait traits for read/write operations. No function parameters are required for declaration, and the Vec cannot be used as a regular variable or struct member outside storage.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-02-storage-vecs.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:contract}}\n```\n\n----------------------------------------\n\nTITLE: Interface Definition for Mock Contract in Cairo\nDESCRIPTION: Defines an interface corresponding to the mock contract embedding the Counter component. This interface is necessary for external interaction with the mock contract, specifying available methods and their signatures used for calling the component's entry points during tests.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/counter.cairo:interface}}\n```\n\n----------------------------------------\n\nTITLE: Writing to Formatter Using write! Macro in Cairo\nDESCRIPTION: Shows usage of the write! macro to generate formatted strings and write them to a Formatter instance in Cairo. Suitable for concatenating multiple string components and then printing the result, this macro is typically used within custom Display implementations or when formatting to buffers. write! and writeln! support formatting syntax and require a Writable/Formatter target. Output is not printed directly but can be consumed as a ByteArray after formatting.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_07_write_macro/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using Wrapper Instance to Access Underlying Data in Cairo\nDESCRIPTION: This snippet illustrates how an instance of Wrapper<UserProfile> can be used to directly access and print the username and age fields of the underlying UserProfile, demonstrating deref coercion in action.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_example/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Byte Array Strings in Cairo\nDESCRIPTION: This snippet provides an example of declaring byte array strings in Cairo using double quotes. It describes the ByteArray type, which handles strings and byte sequences, and it is useful for strings longer than short strings. It's implemented as an array of bytes31 words and a pending felt252 buffer. Dependencies: Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{\n    // Example code demonstrating byte array string declaration\n}\n\n```\n\n----------------------------------------\n\nTITLE: Expanded Example of IERC20Dispatcher with Trait Implementation\nDESCRIPTION: This snippet shows a simplified illustration of the automatically generated `IERC20Dispatcher` struct and its associated trait `IERC20DispatcherTrait`. It demonstrates how function calls are serialized, dispatched via `contract_call_syscall`, and deserialized, providing a type-safe way to interact with ERC20 contracts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-02-interacting-with-another-contract.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch102-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Emitting Event Example Starknet Cairo\nDESCRIPTION: This example demonstrates how to use the `emit_event_syscall` in Cairo to emit an event with specified keys and data. It constructs `ArrayTrait` instances for keys ('key', 'deposit') and values (1, 2, 3), then calls the syscall, unwrapping the result.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\nlet keys = ArrayTrait::new();\nkeys.append('key');\nkeys.append('deposit');\nlet values = ArrayTrait::new();\nvalues.append(1);\nvalues.append(2);\nvalues.append(3);\nemit_event_syscall(keys, values).unwrap_syscall();\n```\n\n----------------------------------------\n\nTITLE: Defining Events with #[event] Attribute in Cairo\nDESCRIPTION: Shows how to define a smart contract's emitted events as an enum named Event, annotated with #[event]. Each enum variant corresponds to a distinct event and can hold associated data in structs or enums implementing starknet::Event. The snippet illustrates how to annotate event data fields with #[key] to mark them as indexed keys for external filtering.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-03-contract-events.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:event}}\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom insert method for dictionaries in Cairo\nDESCRIPTION: Demonstrates implementing a custom insert method for dictionaries using entry and finalize. This function creates an entry for the specified key and finalizes it with a new value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\nfn custom_insert<T, impl TDrop: Drop<T>>(ref dict: Felt252Dict<T>, key: felt252, value: T) {\n    let (entry, _) = dict.entry(key);\n    dict = entry.finalize(value);\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Contract State in Cairo\nDESCRIPTION: Demonstrates reading a value from the contract's storage within the `get` function. The `.read()` method is called on the storage variable (`stored_data`) defined in the `Storage` struct via the `self.stored_data` access pattern.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_01_simple_contract/src/lib.cairo:read_state}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Cairo Package with Scarb CLI\nDESCRIPTION: This snippet demonstrates how to use the Scarb command-line tool to create a new Cairo package. The command generates a basic package structure with the necessary files.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-01-packages-and-crates.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscarb new my_package\n```\n\n----------------------------------------\n\nTITLE: Testing add_two Function with assert_eq! and assert_ne! Macros\nDESCRIPTION: This snippet tests the `add_two` function using `assert_eq!` and `assert_ne!` macros. It checks if the function returns the expected value for a given input. It also includes a test to assert that the function does not return a specific, incorrect value. It uses `assert_eq!` to compare values for equality and `assert_ne!` to compare for inequality. The output of the tests will either pass if the conditions are met or fail with an error message indicating the mismatched values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\n// in src/lib.cairo\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_adds_two() {\n        let result = add_two(2);\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn wrong_check() {\n        let result = add_two(2);\n        assert_ne!(result, 0);\n    }\n\n    fn add_two(x: felt252) -> felt252 {\n        x + 2\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Method `mixup` Usage in Cairo\nDESCRIPTION: Provides an example `main` function demonstrating the usage of the compiling `mixup` method. It shows the creation of two `Wallet` instances with types `Wallet<bool, u128>` and `Wallet<felt252, u8>`, and then calls `mixup` to produce a new `Wallet<bool, u8>` instance.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_12\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let w1 = Wallet { address: true, balance: 10_u128 };\n    let w2 = Wallet { address: 'address', balance: 5_u8 };\n    let w3 = w1.mixup(w2);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementation of Ownable Component Logic in Cairo\nDESCRIPTION: This snippet provides the implementation details for the Ownable component, including the functions and internal logic. It employs the `#[embeddable_as]` attribute to mark the implementation as embeddable within contracts, supporting generics over `ComponentState<TContractState>`. It typically contains functions like ownership transfer and verification, encapsulating core ownership logic.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-00-composability-and-components.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:component}}\n```\n\n----------------------------------------\n\nTITLE: Defining Standalone Public Functions with `#[external(v0)]` in Cairo\nDESCRIPTION: Shows how to define a public function outside an `impl` block using the `#[external(v0)]` attribute. This makes the function callable externally and adds it to the ABI. It must take `self` as its first parameter.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:standalone}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hash Trait in Cairo\nDESCRIPTION: This code snippet defines the `Hash` trait, along with the `HashStateTrait` and `HashStateExTrait`, used to work with hashes in Cairo. It provides the basic methods for initializing, updating, and finalizing hash computations. It is used for deriving the `Hash` trait for custom structs and types, facilitating their hashing with the chosen hash function, such as Pedersen or Poseidon. It is a dependency to the other hashing operations in the file.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_03_hash_trait/src/lib.cairo:hashtrait}}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trait on Structs in Cairo\nDESCRIPTION: This snippet demonstrates implementing the `Summary` trait for the `NewsArticle` and `Tweet` structs. It provides concrete implementations for the `summarize` method for each struct, defining how each type generates its summary string using the format! macro.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Drop, Copy)]\nstruct NewsArticle {\n    headline: ByteArray,\n    location: ByteArray,\n    author: ByteArray,\n    content: ByteArray,\n}\n\n#[derive(Drop, Copy)]\nstruct Tweet {\n    username: ByteArray,\n    content: ByteArray,\n    reply: bool,\n    retweet: bool,\n}\n\nimpl Summary of NewsArticle {\n    fn summarize(self: @NewsArticle) -> ByteArray {\n        format!('{}, by {} ({})', self.headline, self.author, self.location)\n    }\n}\n\nimpl Summary of Tweet {\n    fn summarize(self: @Tweet) -> ByteArray {\n        format!('{}: {}', self.username, self.content)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Role-Based Access Control in Cairo\nDESCRIPTION: This snippet provides a basic pattern for access control in a Starknet smart contract using Cairo. It defines roles and assigns permissions to restrict function access to authorized users only, enhancing contract security by preventing unauthorized actions. Prerequisites include understanding of role-based permissions and smart contract function modifiers or guards. The typical inputs are roles assigned to users and access-limited function calls; the output is controlled execution limited to permitted roles.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-01-general-recommendations.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch104-starknet-smart-contracts-security/no_listing_02_simple_access_control/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition for Mutable Stack Using Felt252Dict - Cairo\nDESCRIPTION: Presents the Stack<T> struct, leveraging Felt252Dict for element storage and a len field to track the current stack size. This design supports LIFO semantics and arbitrary element types, enabling efficient push/pop operations and stack state checks. Stack size is managed separately from the dictionary to allow contiguous index manipulation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_11\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:struct}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Operator Overloading with Traits in Cairo\nDESCRIPTION: This snippet implements the Add trait for a user-defined Potion type in Cairo. By providing an implementation for the add method, it enables use of the \"+\" operator on instances of Potion, resulting in a new Potion with mana and health fields summed from the operands. Dependencies include the Potion struct definition and the Add trait from Cairo's standard library. The function takes two Potion instances (lhs and rhs) and returns a new Potion; both input and output are of the Potion type. Incorrect or excessive use of operator overloading can decrease code readability.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-03-operator-overloading.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_01_potions/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements with at or Subscripting in Cairo\nDESCRIPTION: Shows how to access array elements using the `at(index)` method or the subscripting operator `[index]`. Both methods return a snapshot (`@T`) of the element directly but will cause a panic if the provided index is outside the array's bounds.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse box::BoxTrait; // box::BoxTrait is needed to unbox the result of at()\nuse debug::PrintTrait;\n\nfn at_element() {\n    let mut arr = ArrayTrait::new();\n    arr.append(0);\n    arr.append(1);\n    arr.append(2);\n\n    let first: @u128 = arr.at(0); // Gets a snapshot\n    let second: @u128 = arr.at(1);\n\n    // Accessing the value from the snapshot\n    'First element (at(0)): '.print(); (*first).print(); '\\n'.print();\n    'Second element (at(1)): '.print(); (*second).print(); '\\n'.print();\n\n    // Using subscripting\n    let third: @u128 = arr[2];\n    'Third element (arr[2]): '.print(); (*third).print(); '\\n'.print();\n\n    // Note: Accessing arr.at(5) here would cause a panic.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Contract Interface Trait in Cairo\nDESCRIPTION: Defines the interface `ISimpleStorage` for the simple storage contract using a trait annotated with `#[starknet::interface]`. It declares the public functions `set` (mutates state, takes `ref self: TContractState`) and `get` (reads state, takes `@self: TContractState`), specifying their signatures. `TContractState` is a generic parameter representing the contract's state.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_01_simple_contract/src/lib.cairo:interface}}\n```\n\n----------------------------------------\n\nTITLE: Statement Example in Cairo Function Body\nDESCRIPTION: Illustrates a simple statement inside a function body where a variable `y` is declared and assigned a value using a `let` statement. This example underscores that statements perform actions and do not return values, consistent with Cairo's syntax and semantics.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let y = 6;\n    println!(\"Value of y is {y}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Sending u256 Values from Ethereum to Starknet\nDESCRIPTION: Illustrates how to correctly serialize a u256 value when sending it from Ethereum to Starknet, accounting for the fact that a Cairo u256 requires two felt252 values (low and high components).\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nuint256[] memory payload = new uint256[](2);\n// Let's send the value 1 as a u256 in cairo: low = 1, high = 0.\npayload[0] = 1;\npayload[1] = 0;\n```\n\n----------------------------------------\n\nTITLE: Checking for Panics with should_panic\nDESCRIPTION: This code demonstrates using the `#[should_panic]` attribute to test if a function panics under expected conditions.  This attribute is applied to test functions, and it ensures that a panic occurs during the test execution. Optionally, an `expected` parameter can be added to the `should_panic` attribute to verify the message the function panics with.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of using should_panic\n{{#include ../listings/ch10-testing-cairo-programs/listing_10_05/src/lib.cairo:guess}}\n```\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of using should_panic with expected message\n{{#rustdoc_include ../listings/ch10-testing-cairo-programs/listing_10_06/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Writing a Simple Test Function with #[test] Attribute - Cairo\nDESCRIPTION: Shows how to define a simple test in Cairo using the #[test] attribute within a #[cfg(test)] module. Relies on the built-in 'assert_eq!' macro to assert correctness; if the macro is from the additional crate, 'assert_macros = \"2.8.2\"' must be declared as a dev dependency. The test function takes no parameters and asserts that 2 + 2 equals 4, passing if the condition holds and failing otherwise. Source file is src/lib.cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n// In src/lib.cairo\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving Elements from Storage Vec Using at/get Methods - Cairo\nDESCRIPTION: This snippet demonstrates reading elements from a Vec in contract storage by index using the at and get methods, followed by read. The at method panics if the index is out of bounds, while get returns None for non-existent indices. These methods provide pointers to elements in persistent storage, and require importing the VecTrait trait. Ensure index validity to prevent errors, and that element types are consistent with Vec declaration.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-02-storage-vecs.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:read}}\n```\n\n----------------------------------------\n\nTITLE: Managing External Trait Implementations in Cairo\nDESCRIPTION: This example demonstrates how to manage external trait implementations in Cairo, where a trait and its implementations are defined in separate modules.  It involves importing the necessary trait or implementation to use trait methods correctly.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\nmod circle {\n    use traits::ShapeGeometry;\n\n    struct Circle {\n        radius: felt252,\n    }\n\n    impl CircleGeometry of ShapeGeometry<Circle> {\n        fn boundary(self: @Circle) -> felt252 {\n            self.radius * 2 * 314159 / 100000 // Approximate circumference\n        }\n    }\n}\n\nmod rectangle {\n    use traits::ShapeGeometry;\n\n    struct Rectangle {\n        width: felt252,\n        height: felt252,\n    }\n\n    impl RectangleGeometry of ShapeGeometry<Rectangle> {\n        fn boundary(self: @Rectangle) -> felt252 {\n            self.width * 2 + self.height * 2\n        }\n    }\n}\n\nmod traits {\n    trait ShapeGeometry<T> {\n        fn boundary(self: @T) -> felt252;\n    }\n}\n\nuse circle::Circle;\nuse rectangle::Rectangle;\nuse traits::ShapeGeometry;\n\nfn main() {\n    let my_circle = Circle { radius: 5 };\n    let my_rectangle = Rectangle { width: 4, height: 6 };\n\n    let circle_boundary = ShapeGeometry::boundary(@my_circle);\n    let rectangle_boundary = ShapeGeometry::boundary(@my_rectangle);\n\n    assert(circle_boundary == 31, 'wrong circle boundary');\n    assert(rectangle_boundary == 20, 'wrong rectangle boundary');\n}\n```\n\n----------------------------------------\n\nTITLE: Importing traits with idiomatic full paths in Cairo\nDESCRIPTION: Demonstrates the idiomatic way to import traits in Cairo by using the full path. This example shows how to bring core library's BitSize trait into scope.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nuse core::traits::BitSize;\n\nfn main() {\n    // Get the size of u8 in bits\n    let size = u8::BITS;\n    // Print the size\n    assert(size == 8, 'size should be 8');\n}\n```\n\n----------------------------------------\n\nTITLE: Using Starknet Store Trait in Cairo for Smart Contracts\nDESCRIPTION: This snippet highlights the Starknet::Store trait's role in smart contract development on Starknet, abstracting storage read/write operations to enable persistent data in smart contracts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Implement Price Feed Function in Cairo Contract\nDESCRIPTION: This snippet presents the implementation of the `get_asset_price` function. This function calls the `get_data_median` method to retrieve the price data from the Pragma Oracle. The result is then returned as a `u128` value representing the price of the asset.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-05-01-price-feeds.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:price_feed_impl}}\n```\n\n----------------------------------------\n\nTITLE: Defining Public Functions with `#[abi(embed_v0)]` in Cairo\nDESCRIPTION: Shows a Cairo `impl` block marked with the `#[abi(embed_v0)]` attribute. Functions defined within this block are exposed in the contract's public ABI, making them callable externally. All functions in such blocks must take `self: ContractState` as their first argument.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:impl_public}}\n```\n\n----------------------------------------\n\nTITLE: Printing Data with Macros in Cairo\nDESCRIPTION: Demonstrates the usage of the print! and println! macros in Cairo for outputting data to the console. The macros support placeholder formatting either by position or by named parameters, requiring the input to be a ByteArray string format. These macros depend on the Display trait, which is implemented by default for standard types. Input strings may contain both empty and named placeholders. Output is written to the console, either inline or with a newline appended.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_08_print_macro/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Excluding Types Using TypeEqual for Trait Implementations in Cairo\nDESCRIPTION: This snippet leverages the TypeEqual trait from core::metaprogramming to provide a mechanism for controlling which types are eligible for a trait implementation. Specifically, SafeDefault is implemented for any T that supports Default, except when T is SensitiveData, using a negative bound with -TypeEqual<T, SensitiveData>. The approach depends on the core::metaprogramming module and highlights advanced trait exclusion (negative impls) not achievable through simple generic bounds.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_20_type_equal/src/safe_default.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Including Common Test Functions in Multiple Cairo Test Files\nDESCRIPTION: Demonstrates how to include shared helper functions, like 'setup', into multiple Cairo test files via include directives, enabling code reuse across different test modules. Highlights that in this setup, each test file is compiled as a separate crate, affecting test output sections.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_12_submodules/tests/common.cairo}}\n```\n\n----------------------------------------\n\nTITLE: String Formatting with format! Macro in Cairo\nDESCRIPTION: Illustrates the use of the format! macro for generating formatted ByteArray strings instead of printing directly. This macro works like println! with support for value formatting via placeholders, but returns a ByteArray for programmatic use or concatenation. It does not take ownership of parameters and internally uses snapshots for safety. Requires the Display trait to be implemented for formatted types, and takes any number of arguments matching the placeholders in the string.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_06_format_macro/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Attempting DerefMut on an Immutable Variable in Cairo\nDESCRIPTION: This snippet demonstrates that using DerefMut on an immutable variable results in a compiler error, emphasizing the limitation that DerefMut can only be used with mutable variables.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:error}}\n```\n\n----------------------------------------\n\nTITLE: Defining Methods with Multiple Parameters for Rectangle - Cairo\nDESCRIPTION: This snippet implements the can_hold method, which checks whether one Rectangle instance can fully contain another. The method is defined in a trait and impl block, receiving self and another Rectangle parameter. The sample usage in main checks can_hold for two Rectangle pairs. Dependencies include the trait system and Rectangle definition. Inputs are two Rectangle snapshots; output is a boolean indicating containment.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/src/lib.cairo:trait_impl}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_04_some_params/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Direct Testing of Counter Component Without Deployment in Cairo\nDESCRIPTION: Presents tests that instantiate a `TestingState` object and call component methods directly, bypassing contract deployment. By leveraging the concrete `ComponentState` alias and the `component_state_for_testing` function, it tests internal logic and methods, including those not exposed externally, allowing lightweight and efficient component testing.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_direct.cairo:test}}\n```\n\n----------------------------------------\n\nTITLE: Testing Recursive Functions or Loops\nDESCRIPTION: This code demonstrates setting an explicit gas limit for tests involving recursive functions or loops using the `#[available_gas(<Number>)]` attribute. This is useful for benchmarking efficiency and to prevent infinite loops or excessive gas consumption during testing.  The default amount of gas is assumed reasonably large, but it can be overriden.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_16\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of testing recursive functions or loops\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_06_test_gas/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using snapshots in Cairo for immutable variable views\nDESCRIPTION: This snippet demonstrates defining and using a `calculate_area` function that accepts a snapshot of a `Rectangle` to avoid ownership transfer and mutation, ensuring the original variable remains accessible after the function call. It highlights how snapshots provide an immutable, 'past' view into the variable's state, and how the `@` syntax creates such snapshots in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-02-references-and-snapshots.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/no_listing_09_snapshots/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Modifying Elements in Storage Vec Using write Method - Cairo\nDESCRIPTION: This code shows how to modify the value at a specific index in a persistent Vec within a Cairo smart contract. After obtaining a mutable pointer to the vector element with at/get, the write method overwrites the stored value. Dependencies include core::starknet::storage and the MutableVecTrait trait. Pass the desired index and new value, ensuring the index exists to avoid runtime panics. The operation updates storage in-place.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-02-storage-vecs.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_vecs/src/lib.cairo:modify}}\n```\n\n----------------------------------------\n\nTITLE: Definition of `unwrap_or_else` method for `OptionTrait<T>` implementing `FnOnce` trait bounds\nDESCRIPTION: This snippet defines the `unwrap_or_else` method on `OptionTrait<T>`, which takes a closure `f` that is called at most once if the option value is `None`. The method utilizes `FnOnce` trait bounds to enforce that `f` can be invoked only once, providing a flexible way to handle optional values with fallback logic.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\npub impl OptionTraitImpl<T> of OptionTrait<T> {\n    #[inline]\n    fn unwrap_or_else<F, +Drop<F>, impl func: core::ops::FnOnce<F, ()>[Output: T], +Drop<func::Output>>(\n        self: Option<T>, f: F,\n    ) -> T {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Price Feed Contract Interface in Cairo\nDESCRIPTION: This snippet defines the contract interface for interacting with the Pragma price feed.  It includes the `get_asset_price` function, which takes an `asset_id` as input and returns a `u128` representing the asset's price.  This interface is essential for interacting with the Pragma Oracle to retrieve price data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-05-01-price-feeds.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:price_interface}}\n```\n\n----------------------------------------\n\nTITLE: Test Cases Demonstrating unwrap Behavior and Panic on Invalid Conversion in Cairo\nDESCRIPTION: This code snippet includes two test functions for the parse_u8 function. The first test checks successful conversion from felt252 to u8 expecting unwrap not to panic. The second test verifies that unwrap panics with 'Invalid integer' message when the conversion input is out of u8 range. These tests verify proper error signaling and panic behavior of the Result usage in conversion.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing_09_01/src/lib.cairo:tests}}\n```\n\n----------------------------------------\n\nTITLE: Cairo Compile-Time Error for Missing Display Implementation\nDESCRIPTION: Provides an example compile-time error message encountered when attempting to print a custom type that does not implement the Display trait using print! or println!. The error message clearly indicates the lack of trait implementation for the referenced struct in the given package. To resolve, implement the Display trait for the custom type or use Debug for debugging purposes.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nerror: Trait has no implementation in context: core::fmt::Display::<package_name::struct_name>\n```\n\n----------------------------------------\n\nTITLE: Trait with Default Implementation Calling Another Method\nDESCRIPTION: This defines the `Summary` trait with `summarize` having a default implementation that calls `summarize_author`. Implementors must provide `summarize_author`, while `summarize` provides default behavior, showcasing how traits can offer useful functionality with minimal implementation effort. The `summarize` method depends on `summarize_author`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\ntrait Summary<T> {\n    fn summarize_author(self: @T) -> felt252;\n\n    fn summarize(self: @T) -> felt252 {\n        alloc().append('(Read more from ');\n        alloc().append(Summary::summarize_author(@self));\n        alloc().append('...)');\n        *alloc()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PartialEq Trait for Custom Comparison in Cairo\nDESCRIPTION: This code demonstrates how to derive or implement the PartialEq trait in Cairo to compare instances for equality. It allows defining custom comparison logic, such as comparing rectangles by their area, and supports assertions in tests.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_04_implpartialeq/src/lib.cairo}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_05_partialeq/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Proposal Storage Node in Cairo\nDESCRIPTION: This snippet defines a `ProposalNode` storage node struct using the `#[starknet::storage_node]` attribute. The storage node contains a `Map` data structure that tracks voters and other metadata fields for a voting proposal. This design illustrates how to group related storage mappings and variables into a cohesive storage layout only valid within contract storage, improving modularity and enabling advanced storage patterns. Dependencies include the Starknet storage library with support for storage nodes and map types.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:storage_node}}\n```\n\n----------------------------------------\n\nTITLE: Match Option<u8> - Some case\nDESCRIPTION: Demonstrates the `Some` case in the match expression for `Option<u8>`.  The pattern `Some(val)` binds the inner value to `val`, allowing it to be used in the arm's code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:option_some}}\n```\n\n----------------------------------------\n\nTITLE: Get Vote Status with Starkli\nDESCRIPTION: This snippet demonstrates how to use the `starkli call` command to retrieve the current vote status by calling the `get_vote_status` function on the contract. It includes the contract address and RPC endpoint as arguments. The output will show the number of 'Yes' and 'No' votes and their respective percentages.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nstarkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 get_vote_status --rpc http://0.0.0.0:5050\n```\n\n----------------------------------------\n\nTITLE: Component Signature with Dependency Specification in Cairo\nDESCRIPTION: This snippet shows how to specify a component dependency using trait bounds in Cairo. It restricts the impl block to be available only for contracts that contain an implementation of the ownable_component::HasComponent trait, indicating that the TContractState type has access to the Ownable component.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-02-component-dependencies.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:component_signature}}\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements with get in Cairo\nDESCRIPTION: Demonstrates using the `get(index)` method to access elements by index. `get` returns an `Option<Box<@T>>`, providing a safe way to check if an element exists at a given index without panicking, returning `None` for out-of-bounds access.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse option::OptionTrait;\nuse box::BoxTrait;\nuse debug::PrintTrait;\n\nfn get_element() {\n    let mut arr = ArrayTrait::new();\n    arr.append(100);\n    arr.append(200);\n\n    let element_at_0 = arr.get(0);\n    let element_at_5 = arr.get(5); // Out of bounds\n\n    match element_at_0 {\n        Option::Some(boxed_value) => { 'Element at index 0: '.print(); (*boxed_value).print(); '\\n'.print(); },\n        Option::None(_) => { 'No element at index 0'.print(); '\\n'.print(); },\n    }\n\n    match element_at_5 {\n        Option::Some(boxed_value) => { 'Element at index 5: '.print(); (*boxed_value).print(); '\\n'.print(); },\n        Option::None(_) => { 'No element at index 5'.print(); '\\n'.print(); }, // This will print\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Test Runner Output for Custom Named Test Function - Shell\nDESCRIPTION: Illustrates the 'scarb test' command output when running a test function named 'exploration'. The output mirrors the structure of previous 'scarb test' results, showing collection, running, and passing of tests, reflecting the updated function name.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 1 test(s) from adder package\nRunning 1 test(s) from src/\nadder::tests::exploration ... [PASS] (gas: ~1)\n\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Making Low-Level Library Calls with library_call_syscall in Cairo\nDESCRIPTION: Illustrates the direct use of the `library_call_syscall` system call to invoke a function (`set_value`) in another class (`ValueStore`). This approach offers granular control but requires manual serialization of call arguments into a `Span<felt252>` using `Serde` and manual deserialization of the returned `Span<felt252>`. The function takes the target class hash, function selector, and serialized arguments.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-03-executing-code-from-another-class.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch102-starknet-cross-contract-interactions/listing_07_library_syscall/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Testing can_hold Method with assert! (negated) Macro in Cairo\nDESCRIPTION: This snippet builds upon the previous example by adding a test to assert that a smaller rectangle cannot hold a larger rectangle. The `assert!` macro is used, and the result of `can_hold` is negated. This checks for the false case, ensuring the method correctly returns false when expected. Requires the `Rectangle` struct and `can_hold` method.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\n// in src/lib.cairo\n#[derive(Drop, PartialEq, Debug)]\nstruct Rectangle {\n    width: felt252,\n    height: felt252,\n}\n\nimpl Rectangle {\n    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n        self.width >= other.width && self.height >= other.height\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle { width: 8, height: 7 };\n        let smaller = Rectangle { width: 5, height: 1 };\n        assert!(larger.can_hold(@smaller));\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle { width: 8, height: 7 };\n        let smaller = Rectangle { width: 5, height: 1 };\n        assert!(!smaller.can_hold(@larger));\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Single Tests in Cairo\nDESCRIPTION: This snippet shows how to run a specific test by providing its name to the `scarb test` command. Only tests matching the name argument will be executed. This is useful for focusing on specific areas during development and reducing test execution time.  Partial test names can also be used.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_14\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of running single tests\n{{#include ../listings/ch10-testing-cairo-programs/listing_10_07/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining HasComponent Trait Interface\nDESCRIPTION: This snippet defines the `HasComponent` trait. This trait is generated per component and defines the interface to bridge between the actual `TContractState` of a generic contract, and `ComponentState<TContractState>`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n// generated per component\ntrait HasComponent<TContractState> {\n    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;\n    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;\n    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;\n    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;\n    fn emit<S, impl IntoImp: traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Updated Struct with Update Syntax in Cairo\nDESCRIPTION: This snippet demonstrates using struct update syntax (`..`) to create a new `User` instance that changes certain fields, such as `email`, while copying others from an existing instance. It efficiently updates struct data with less code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_update_syntax/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Test Runner Output for Passing and Failing Tests - Shell\nDESCRIPTION: Shows the output from the 'scarb test' command when one test passes and another fails in a Cairo project. Output details which test passed and which failed, including failure data and a summary of the pass/fail/skip/ignore/filter counts, providing immediate feedback on test status.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 2 test(s) from adder package\nRunning 2 test(s) from src/\n[FAIL] adder::tests::another\n\nFailure data:\n    \"Make this test fail\"\n\n[PASS] adder::tests::exploration (gas: ~1)\nTests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    adder::tests::another\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Tests\nDESCRIPTION: This snippet explains how to ignore specific tests using the `#[ignore]` attribute. This allows for excluding time-consuming tests from the standard test runs, which is beneficial to reduce test execution time.  Ignored tests can be run with the `--include-ignored` flag to `scarb test`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_15\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of ignoring tests\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_05_ignore_tests/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Adding Line Comments in Cairo\nDESCRIPTION: This snippet demonstrates how to add single-line comments in Cairo using `//`. The comment explains the code's purpose and is ignored by the compiler. These comments are used to provide brief explanations for the code. They are typically placed above or to the right of the code they describe.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// hello, world\n```\n\n----------------------------------------\n\nTITLE: Generic Function Finding Smallest Element with PartialOrd and Copy Traits in Cairo\nDESCRIPTION: This snippet defines `smallest_element`, a generic function that finds and returns the smallest element from an `Array<T>` where `T` implements `PartialOrd` and `Copy`. It demonstrates the need for trait bounds on `T` to perform comparisons and copying, ensuring type correctness when desanpping and dropping elements.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_03_missing_tcopy/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Deploying Vote Contract with Registered Voters\nDESCRIPTION: Command template for deploying the Vote contract with three registered voter addresses using Starkli on the local Katana node.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nstarkli deploy <class_hash_of_the_contract_to_be_deployed> <voter_0_address> <voter_1_address> <voter_2_address> --rpc http://0.0.0.0:5050 --account katana-0\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Functions Without Deployment in Cairo\nDESCRIPTION: This code demonstrates how to directly access and test internal functions and storage variables of a Starknet contract without deploying it. It utilizes the `contract_state_for_testing` function from `snforge_std` and imports necessary traits for storage access.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:import_internal}}\n```\n\n----------------------------------------\n\nTITLE: Renaming imports with the `as` keyword in Cairo\nDESCRIPTION: Shows how to use the `as` keyword to create aliases when importing items, which helps resolve naming conflicts when importing multiple items with the same name.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait as Arr;\n\nfn main() {\n    // Using the renamed trait\n    let mut arr = Arr::new();\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n    assert(arr.len() == 3, 'Array should have 3 elements');\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Array Manually (Without Macro) in Cairo\nDESCRIPTION: Illustrates the explicit, step-by-step process of creating an array by first calling `ArrayTrait::new()` and then repeatedly calling `append()` for each element. This is the underlying process abstracted by the `array!` macro.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\n\nfn create_manually() {\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(20);\n    arr.append(30);\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition for a Dictionary-backed Dynamic Array (MemoryVec) - Cairo\nDESCRIPTION: Presents the MemoryVec<T> struct, defining a mutable array using Felt252Dict for value storage and a len field for current size. Values are wrapped in Nullable to allow for flexible usage of types not natively supported in dictionaries. This foundational type enables dynamic memory management and supports a wide range of types for values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:struct}}\n```\n\n----------------------------------------\n\nTITLE: Executing Infinite Loops Using the Loop Construct in Cairo\nDESCRIPTION: This snippet illustrates an infinite loop in Cairo using the loop keyword. The loop repeatedly executes a block, continually printing a message until externally stopped or out of gas. It demonstrates the importance of gas metering for limiting execution in smart contracts on Starknet and requires proper loop termination to avoid resource exhaustion.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_32_infinite_loop/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Transfer Ownership Function in Cairo\nDESCRIPTION: This snippet implements the `transfer_ownership` function. It uses the `get_dep_component_mut!` macro to mutate the state of the Ownable component, allowing the component embedding this component to call the `transfer_ownership` function from the `Ownable` component and change the current owner.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-02-component-dependencies.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:transfer_ownership}}\n```\n\n----------------------------------------\n\nTITLE: Display Trait Definition in Cairo\nDESCRIPTION: Provides the definition of the Display trait, which allows custom types to define their own string formatting for use with print! and println! macros. The trait specifies a fmt method taking a reference to a Formatter and must return a Result type. All types used with print macros must have Display implemented, either by default or by manual implementation. The Formatter struct given as parameter accumulates the formatted string as a ByteArray.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait Display<T> {\n    fn fmt(self: @T, ref f: Formatter) -> Result<(), Error>;\n}\n```\n\n----------------------------------------\n\nTITLE: OwnableCounter Component Implementation in Cairo\nDESCRIPTION: This snippet shows the complete implementation of the OwnableCounter component, which depends on the Ownable component for ownership features. It defines a counter that can only be incremented by its owner. The snippet encompasses the full code of the `counter.cairo` file.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-02-component-dependencies.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:full}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with a Default Implementation in Cairo\nDESCRIPTION: This code defines a `Summary` trait with a default implementation for the `summarize` method. This allows types implementing the trait to use the default behavior or override it with a custom implementation. The trait defines the contract for summarizing data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\ntrait Summary<T> {\n    fn summarize(self: @T) -> felt252 {\n        'Read more...'\n    }\n}\n\nstruct NewsArticle {\n    headline: felt252,\n    location: felt252,\n    author: felt252,\n    content: felt252,\n}\n\nimpl NewsArticleSummary of Summary<NewsArticle> {}\n\nstruct Tweet {\n    username: felt252,\n    content: felt252,\n    reply: bool,\n    retweet: bool,\n}\n\nimpl TweetSummary of Summary<Tweet> {\n    fn summarize(self: @Tweet) -> felt252 {\n        alloc().append('hello');\n        alloc().append(self.username);\n        alloc().append(': ');\n        alloc().append(self.content);\n        *alloc()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Multiple Patterns with the `|` Operator in Cairo\nDESCRIPTION: This example demonstrates using the `|` (or) operator within a `match` arm to accept multiple patterns simultaneously. The modified vending machine function accepts both Dime and Quarter coins in a single arm, returning true if either is inserted, and false otherwise. Required dependencies include the definition of the `Coin` enum.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nfunc vending_machine_accept(coin: Coin) -> (accepted: bool) {\n    match coin {\n        Coin::Dime | Coin::Quarter => return (true),\n        _ => return (false),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing multiple items from the same module in Cairo\nDESCRIPTION: Demonstrates how to import multiple items from the same module using curly braces syntax, which makes the code more concise and readable.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nuse starknet::{ContractAddress, ClassHash, StorageAddress};\n\nfn process_data(contract: ContractAddress, class: ClassHash, storage: StorageAddress) {\n    // Function implementation using the imported types\n}\n```\n\n----------------------------------------\n\nTITLE: Test Case Showing Error Propagation and Console Panic with ? Operator in Cairo\nDESCRIPTION: This snippet includes a test function demonstrating usage of the ? operator in do_something_with_parse_u8. It prints an error message 'Invalid Integer' on the console when an invalid conversion input causes panic, verifying error propagation and panic messages when using ?.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-02-recoverable-errors.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch09-error-handling/listing_09_02/src/lib.cairo:tests}}\n```\n\n----------------------------------------\n\nTITLE: Item-level Documentation in Cairo\nDESCRIPTION: This snippet showcases item-level documentation comments in Cairo, using `///`. These comments provide a detailed description of functions, implementations, traits, and more. They may include descriptions of parameters, return values, and potential causes for panics. The compiler will interpret the `///` prefix for detailed item-level documentation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_37_item_doc_comments/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Generic Trait Bound with '+' Operator in Cairo\nDESCRIPTION: This snippet illustrates the use of the `+` operator to specify trait bounds without naming implementations, known as anonymous generic implementation parameters. It simplifies function signatures by constraining generic types to implement required traits like `PartialOrd` and `Copy`, improving code clarity when implementations are only used as constraints.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_05_with_anonymous_impl/src/lib.cairo:1}}\n```\n\n----------------------------------------\n\nTITLE: Using the `Into` Trait for Type Conversion in Cairo\nDESCRIPTION: This code illustrates how to use the `Into` trait for type conversion in Cairo, specifically when the conversion is guaranteed to succeed.  The new variable's type must be explicitly defined.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_13\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_11_into/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Shell Output of Function Call\nDESCRIPTION: Displays the expected output when executing the Cairo code that defines and calls the `five` function. This confirms that the function correctly returns the value `5`, which is then printed.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n# Assuming content from ../listings/ch02-common-programming-concepts/no_listing_22_function_return_values/output.txt\n$ scarb cairo-run\n   Compiling workspace v0.1.0 (/path/to/project/src)\n    Finished release target(s) in 0 seconds\n     Running cairo-run\nThe value of x is: 5\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Storage Contract in Cairo\nDESCRIPTION: The complete source code for a basic Starknet contract written in Cairo. This contract defines a module annotated with `#[starknet::contract]`, includes a `Storage` struct with a single `u128` field, defines an interface trait `ISimpleStorage`, and implements this trait with `set` and `get` functions to modify and retrieve the stored value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_01_simple_contract/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Trait in Cairo\nDESCRIPTION: This snippet defines a public trait named `Summary` that declares a single method signature `summarize`. The method is intended to be implemented by types that can provide a summary, taking an instance of `NewsArticle` by reference and returning a `ByteArray` (Cairo's string type).\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\npub trait Summary {\n    fn summarize(self: @NewsArticle) -> ByteArray;\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming and Running a Custom Named Test Function - Cairo\nDESCRIPTION: Shows how to define and run a test function with a custom name ('exploration') annotated with #[test] in Cairo. Similar to previous, it uses 'assert_eq!' to check that 2 + 2 equals 4. Required dependencies are the same as earlier (optionally 'assert_macros'). No parameters; the output will display the new function name in test results.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n// In src/lib.cairo\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Formatter Struct Definition in Cairo\nDESCRIPTION: Shows the definition of the Formatter struct that serves as the buffer for formatted output in custom Display implementations. The Formatter holds a ByteArray buffer to accumulate the result. It derives Default and Drop, supporting typical struct lifecycle and usage in formatting routines. Used primarily as the parameter to Display::fmt implementations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Default, Drop)]\npub struct Formatter {\n    /// The pending result of formatting.\n    pub buffer: ByteArray,\n}\n```\n\n----------------------------------------\n\nTITLE: Usage example of `filter` with a boolean-returning closure\nDESCRIPTION: This snippet exemplifies how to invoke the Cairo `filter` function with a closure that checks for a condition (e.g., greater than a threshold), filtering an array accordingly. It demonstrates practical application of closure with boolean output to selectively include array elements based on custom criteria.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_closures/src/lib.cairo:filter_usage}}\n```\n\n----------------------------------------\n\nTITLE: Deriving Hash Trait in Cairo\nDESCRIPTION: This example shows how to derive the Hash trait for structs and enums in Cairo, enabling easy hashing of data types using standard hash functions, which is useful for collections like hash maps.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Mappings in Cairo Smart Contracts\nDESCRIPTION: This snippet demonstrates how to access values in nested mappings by traversing through multiple keys, showing both read and write operations on a user's warehouse items.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-01-storage-mappings.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_quantity(self: @ContractState, user: ContractAddress, item_id: u64) -> u64 {\n    let user_warehouse = self.user_warehouse.read(user);\n    let quantity = user_warehouse.read(item_id);\n    quantity\n}\n\nfn set_quantity(ref self: ContractState, user: ContractAddress, item_id: u64, quantity: u64) {\n    let mut user_warehouse = self.user_warehouse.read(user);\n    user_warehouse.write(item_id, quantity);\n    self.user_warehouse.write(user, user_warehouse);\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting arrays in dictionaries in Cairo\nDESCRIPTION: Shows how to create a dictionary and insert an array into it using Nullable<T>. This demonstrates the basic setup for storing arrays in dictionaries.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse box::BoxTrait;\nuse dict::Felt252Dict;\nuse nullable::{NullableTrait, match_nullable};\nuse traits::Default;\n\nfn main() {\n    let mut dict: Felt252Dict<Nullable<Array<felt252>>> = Default::default();\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(20);\n    arr.append(30);\n    dict.insert(1, NullableTrait::new(arr));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Implemented Trait Methods in Cairo\nDESCRIPTION: This snippet shows how to use the `summarize` method after implementing the `Summary` trait on `NewsArticle` and `Tweet`. It requires bringing the `Summary` trait into scope using `use aggregator::Summary;` (assuming 'aggregator' is the crate name), then instantiating the structs and calling the trait method on the instances.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\nuse aggregator::Summary; // Assuming aggregator is the crate name\n\n// Struct definitions (assuming they are defined elsewhere or in the same file)\n#[derive(Drop, Copy)]\nstruct NewsArticle {\n    headline: ByteArray,\n    location: ByteArray,\n    author: ByteArray,\n    content: ByteArray,\n}\n\n#[derive(Drop, Copy)]\nstruct Tweet {\n    username: ByteArray,\n    content: ByteArray,\n    reply: bool,\n    retweet: bool,\n}\n\nfn main() {\n    let tweet = Tweet {\n        username: 'horse_ebooks',\n        content: 'of course, as you probably already know, people',\n        reply: false,\n        retweet: false,\n    };\n\n    let article = NewsArticle {\n        headline: 'Penguins win the Stanley Cup!',\n        location: 'Pittsburgh, PA',\n        author: 'Iceburgh',\n        content: 'The Pittsburgh Penguins once again won the Stanley Cup.',\n    };\n\n    println!('New tweet summary: {}', tweet.summarize());\n    println!('New article summary: {}', article.summarize());\n}\n```\n\nLANGUAGE: Shell\nCODE:\n```\nNew tweet summary: horse_ebooks: of course, as you probably already know, people\nNew article summary: Penguins win the Stanley Cup!, by Iceburgh (Pittsburgh, PA)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Felt252Dict<T> in Cairo for Basic Operations\nDESCRIPTION: This snippet demonstrates how to instantiate a Felt252Dict<U64> dictionary, insert key-value pairs, and retrieve values using the insert and get methods. It highlights how the dictionary allows overwriting values for existing keys and manages default zero-initialized entries. Dependencies include the core library providing Felt252Dict and their associated traits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch03-common-collections/no_listing_09_intro/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Adding Comments above Code in Cairo\nDESCRIPTION: This snippet demonstrates placing a comment on a separate line above the code it is annotating. This improves code readability by explicitly connecting comments to specific code sections. The comment explains the code immediately following it.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_26_comments/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Generic Enum `Result<T, E>` in Cairo\nDESCRIPTION: This snippet presents the `Result<T, E>` enum, which uses two generic types to represent success or failure outcomes respectively. Variants `Ok` contain a value of type `T`, and `Err` contain a value of type `E`. It facilitates error handling patterns across functions and operations that may succeed or fail.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_10_result/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Writing Storage Variables in Starknet Contracts using Cairo\nDESCRIPTION: This snippet illustrates how to update a value in contract storage by using the auto-generated write function on a storage variable declared in the #[storage] struct. Input is the new value to persist, and the function automatically writes to the correct address. Only types implementing the Store trait can be written.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:write_owner}}\n```\n\n----------------------------------------\n\nTITLE: pow Macro Usage Example\nDESCRIPTION: This is an example of how the `pow` macro is used within a Cairo project. The `pow` macro can be called directly, providing base and exponent as arguments. The result of the computation is then assigned to the variable `result`. The macro's generated code is included into the compiled Cairo code during the build process.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\nuse pow::pow;\n\n#[test]\nfn test_pow() {\n    let base = 2;\n    let exponent = 3;\n    let result = pow(base, exponent);\n    assert(result == 8, 'pow failed');\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding external dependencies with Scarb in Cairo projects\nDESCRIPTION: Examples of how to specify external package dependencies in the Scarb.toml file using Git repositories, including main branch imports and specific branch imports.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nalexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }\n```\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nalexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", branch = \"cairo-v2.3.0-rc0\" }\n```\n\n----------------------------------------\n\nTITLE: Implementation pattern of `map` function using Cairo closures\nDESCRIPTION: This snippet illustrates a Cairo implementation of the `map` function, applying a closure to each element of an array to produce a new array with transformed elements. The function leverages the `Fn` trait's associated output type, allowing the closure to output different element types, thus supporting flexible transformations with potential use of experimental features.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_closures/src/lib.cairo:array_map}}\n```\n\n----------------------------------------\n\nTITLE: Implementation Signature of Ownable Component in Cairo\nDESCRIPTION: This snippet details the function signatures within the embeddable implementation of the Ownable component, illustrating the style and structure of functions that can be embedded into contracts. It highlights the use of `ComponentState<TContractState>` for access to storage and events, supporting reusability across different contract contexts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-00-composability-and-components.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:impl_signature}}\n```\n\n----------------------------------------\n\nTITLE: Using the Default Implementation of a Trait in Cairo\nDESCRIPTION: This code demonstrates how to use the default implementation of the `summarize` method defined in the `Summary` trait for the `NewsArticle` struct. It creates an instance of `NewsArticle` and calls the `summarize` method, which will use the default implementation because no custom implementation is provided.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let article = NewsArticle {\n        headline: 'New article available!',\n        location: 'Cairo',\n        author: 'Cairo Book',\n        content: 'This is a new article about Cairo.'\n    };\n    let summary = Summary::summarize(@article);\n    assert(summary == 'Read more...', 'wrong default summary');\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Configuration for Procedural Macros\nDESCRIPTION: This `Cargo.toml` configuration is used to define the dependencies needed for a Rust project that implements a procedural macro.  It specifies the crate type as a dynamically linked library (`cdylib`) and includes the `cairo-lang-macro` crate as a dependency. This configuration is part of the macro implementation project.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n[package]\nname = \"pow\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\ncairo-lang-macro = \"2.3.0\"\ncairo-lang-parser = \"2.3.0\"\ncairo-lang-syntax = \"2.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Prime Checking Logic in Cairo\nDESCRIPTION: This Cairo code implements a function `is_prime` that checks if a given `u32` integer is prime using trial division. The `main` function is marked with `#[executable]` and serves as the entry point, taking user input and calling `is_prime` to determine primality.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nfn is_prime(n: u32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n\n    let mut i: u32 = 3;\n    loop {\n        if i * i > n {\n            break;\n        }\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    };\n\n    true\n}\n\n#[executable]\nfn main(n: u32) -> bool {\n    is_prime(n)\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating the Area of a Rectangle Using Tuples in Cairo\nDESCRIPTION: This snippet refactors the area calculation by packaging the `width` and `height` as a tuple `(u64, u64)` passed to the `area` function as a single parameter. The function extracts width and height by index (`rectangle.0` and `rectangle.1`) before calculating the area. This approach reduces parameter count and groups related data but lacks semantic clarity because tuple elements are unnamed, increasing the risk of indexing errors. The `main` function demonstrates instantiating and passing a tuple to compute the area.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nfunc area(rectangle: (u64, u64)) -> (area: u64) {\n    let width = rectangle.0;\n    let height = rectangle.1;\n    let area = width * height;\n    return (area,);\n}\n\nfunc main() -> (res: u64) {\n    let rectangle = (30, 10);\n    let (res) = area(rectangle);\n    return (res,);\n}\n```\n\n----------------------------------------\n\nTITLE: Using while Loops for Conditional Counting in Cairo (cairo)\nDESCRIPTION: This snippet demonstrates a while loop that prints a countdown from a variable, decrementing its value each iteration until a stopping condition is met. It exemplifies Cairo's built-in looping constructs for running code while a condition remains true. No additional dependencies are required. Inputs may involve initial counter value; output is printed to the terminal. The loop exits as soon as the condition is false, preventing excess iterations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_36_while_loop/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Push and Pop for Mutable Stack Using Felt252Dict - Cairo\nDESCRIPTION: Implements the push and pop functions for a mutable Stack in Cairo, with values stored in Felt252Dict at stack length as index. push inserts and increments the length, while pop decrements and retrieves the last value. The approach guarantees O(1) stack operations and shows how to combine len tracking with dictionary-based storage for stacks.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_12\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:implem}}\n```\n\n----------------------------------------\n\nTITLE: Numeric Operations in Cairo\nDESCRIPTION: This code snippet demonstrates basic mathematical operations in Cairo, specifically focusing on how to use numeric operations like addition, subtraction, multiplication, and division with integer types.  It shows how to use the operators in `let` statements to assign the results of these operations to variables. The expected output is the results of the calculations applied to integer values. Dependencies: Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{\n    // Example code demonstrating numeric operations\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct for Bit-Packing Example in Cairo\nDESCRIPTION: Defines the `Sizes` struct in Cairo, containing fields of type `u8`, `u32`, and `u64`. This struct serves as an example to illustrate how multiple fields with a total size less than a storage slot (251 bits) can be packed together. The total size here is 104 bits, fitting within a `u128`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-01-optimizing-storage-costs.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_01_storage_packing/src/lib.cairo:struct}}\n```\n\n----------------------------------------\n\nTITLE: Inline Comments in Cairo\nDESCRIPTION: This snippet shows how to add a comment at the end of a line of code. The comment is denoted by `//` and provides a brief explanation of the code. The comment is placed after the code it is annotating, describing the purpose of that particular line or segment.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_25_comments/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hello Derive Macro - Rust\nDESCRIPTION: Rust procedural macro implementation for `#[derive(Hello)]`. It receives the input struct's definition as a `TokenStream`, extracts the struct name, and generates Cairo code to implement the `Hello` trait for that specific struct, including a `hello()` method that prints a greeting.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_17_procedural_macro_derive/src/lib.rs:hello}}\n```\n\n----------------------------------------\n\nTITLE: Storing Multiple Types in Array Using Enum in Cairo\nDESCRIPTION: Explains and shows how to store elements of different data types within the same array by defining an `Enum` where each variant wraps a different type. The array is then declared to hold instances of this Enum.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse array::Array;\nuse debug::PrintTrait;\n\n#[derive(Drop, Debug)]\nenum MixedType {\n    Integer(u128),\n    Boolean(bool),\n    // Add other types as needed\n}\n\nfn array_with_enum() {\n    let mut arr: Array<MixedType> = ArrayTrait::new();\n    arr.append(MixedType::Integer(123));\n    arr.append(MixedType::Boolean(true));\n\n    // You can iterate or access elements and match on the enum variant\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Counter Component in Cairo\nDESCRIPTION: Defines a generic Counter component to be integrated within contracts, allowing them to maintain an incrementable counter. This component cannot be deployed standalone and lacks a ContractState. It establishes the component's storage structure and increment logic, serving as the foundational unit for testing approaches described later.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/counter.cairo:component}}\n```\n\n----------------------------------------\n\nTITLE: Returning Values from Loop Break Expressions in Cairo\nDESCRIPTION: This snippet demonstrates returning a value from within a loop using the break keyword with an associated value. The loop computes until a condition is satisfied and then breaks, returning the calculated value (e.g., counter * 2), which is assigned to a variable outside the loop. Useful for retrying operations and obtaining a result from repeated attempts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_35_loop_return_values/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining the Main Entry Point in Cairo - Cairo\nDESCRIPTION: This snippet demonstrates the minimal syntax required to define the entry point of a standalone Cairo program using the 'main' function. It establishes the program structure expected by the Cairo compiler, serving as the executable's starting point. This function does not take any parameters or return any values, and is required for non-contract Cairo programs. No external dependencies are necessary other than Cairo itself. Limitations: this example shows only an empty function, intended purely for illustration.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {}\n\n```\n\n----------------------------------------\n\nTITLE: Import Pragma Dependencies in Cairo Contract\nDESCRIPTION: This code snippet shows the necessary imports required to interact with the Pragma Oracle within a Cairo smart contract. These imports provide access to the functions and data structures needed to retrieve price feed data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-05-01-price-feeds.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_08_price_feed/src/lib.cairo:pragma_lib}}\n```\n\n----------------------------------------\n\nTITLE: Defining Naive Generic Trait and Implementation `WalletMix` in Cairo\nDESCRIPTION: Defines the `WalletMixTrait<T1, U1>` and its implementation. The `mixup<T2, U2>` method takes `self` (`Wallet<T1, U1>`) and `other` (`Wallet<T2, U2>`) and attempts to create a new `Wallet<T1, U2>`. This version is non-compiling because the generic types are not constrained by the `Drop` trait, which is required for consuming/dropping the input wallets.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait WalletMixTrait<T1, U1> {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;\n}\n\nimpl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {\n        Wallet { address: self.address, balance: other.balance }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Matching with the `_` Catch-All Placeholder in Cairo\nDESCRIPTION: This snippet shows how to use the underscore (`_`) as a catch-all pattern in a `match` expression to handle any value not explicitly matched. It defines a vending machine function that accepts only Dime coins, returning true for them and ignoring others. The catch-all arm ensures exhaustiveness without binding the ignored values. Dependencies include enum type definitions for coins.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\nfunc vending_machine_accept(coin: Coin) -> (accepted: bool) {\n    match coin {\n        Coin::Dime => return (true),\n        _ => return (false),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Circuit Inputs - Cairo\nDESCRIPTION: This snippet defines the circuit inputs using the CircuitInput struct, initializing the elements that will serve as the variables for the arithmetic circuit. The circuit expects a flexible number of inputs, which are essential for parameterizing the circuit instance and preparing for subsequent gate operations. Prerequisites include importing core::circuit and related types.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:inputs}}\n```\n\n----------------------------------------\n\nTITLE: Using `if let` and `else` with `Coin` - Cairo\nDESCRIPTION: This Cairo code illustrates the use of `if let` with an `else` block to handle different enum variants. It checks for the `Coin::Quarter` variant and, if found, prints the state. Otherwise, it executes the code in the `else` block. The `else` block functions similarly to the `_` arm of the match. This snippet shows how to use an `if let` statement with an `else` block to provide alternative actions when the pattern does not match.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nif let Coin::Quarter(state) = coin {\n    println!(\"Quarter from {:?}\", state);\n} else {\n    count += 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching on `Some` Value with `match` - Cairo\nDESCRIPTION: This Cairo code demonstrates a `match` expression used to handle an `Some<u8>` value. The primary function is to print the value inside `Some` while ignoring the `None` variant. The code snippet exemplifies the initial approach to pattern matching, showing how to handle only the \"Some\" variant. It is important to remember that match expressions should be exhaustive, therefore, the underscore branch is used to satisfy the compiler. This provides a baseline for comparison with `if let`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nmatch config_max {\n    Some(max) => {\n        println!(\"The maximum is: {:#?}\", max);\n    },\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Input Errors and Using u128 in Cairo\nDESCRIPTION: This modified Cairo code changes the input type to `u128` and adds a check to panic if the input exceeds 1,000,000. This demonstrates how to handle larger numbers and potential input errors in a provable Cairo program. Panicking will prevent a proof being generated and verified.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\nfn is_prime(n: u128) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n\n    let mut i: u128 = 3;\n    loop {\n        if i * i > n {\n            break;\n        }\n        if n % i == 0 {\n            return false;\n        }\n        i += 2;\n    };\n\n    true\n}\n\n#[executable]\nfn main(n: u128) -> bool {\n    if n > 1000000 {\n        panic!(('Input too large'));\n    }\n    is_prime(n)\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Library Call Starknet Cairo\nDESCRIPTION: This snippet provides the syntax for the `library_call_syscall` in Cairo, which executes a function from a specific class's code without the contract state being affected by the called function's storage operations. It requires the class hash, function selector, and calldata, returning the function's response as a span of felts within a `SyscallResult`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn library_call_syscall(\n    class_hash: ClassHash, function_selector: felt252, calldata: Span<felt252>,\n) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Setting and Updating Values in Dictionary-Backed MemoryVec Array - Cairo\nDESCRIPTION: Shows how to update the value at a specific index of the MemoryVec structure via insertion into the underlying Felt252Dict. The set method allows overwriting an existing value, providing mutable storage semantics in contrast to regular Cairo arrays. Properly handling indices and nullability is necessary to maintain correctness.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:set}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait for Mutable Stack Operations - Cairo\nDESCRIPTION: Defines a trait specifying core mutable stack operations: push, pop, and checking if the stack is empty. The interface supports generic T for element type, and lays out the behaviors required for any stack-like data structure in Cairo. Underlying implementations are expected to use dictionary-backed storage for flexibility and mutability.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_14_cust_struct_stack/src/lib.cairo:trait}}\n```\n\n----------------------------------------\n\nTITLE: Storing Large Data in a Box for Performance in Cairo\nDESCRIPTION: This snippet demonstrates how to store large data in a `Box<T>` to improve performance by passing references instead of copying entire data structures. It compares passing data by value and by pointer, illustrating the memory layout and performance benefits, especially when dealing with large structs like `Cart`. Dependencies include the Cairo standard library and relevant data structures like `Cart`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-02-smart-pointers.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/listing_05_box/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Matching Tuples with Enums in Cairo\nDESCRIPTION: This snippet introduces tuple pattern matching involving enums. It defines a `DayType` enum and uses a tuple of `(Coin, DayType)` in the match expression to implement conditional acceptance of coins depending on the day. The vending machine accepts any coin on weekdays, and only Dime and Quarter coins on weekends and holidays. The snippet also shows how the underscore (`_`) can be used for multiple tuple values to simplify patterns. It requires enum definitions for `Coin` and `DayType`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_9\n\nLANGUAGE: cairo\nCODE:\n```\nenum DayType {\n    Weekday,\n    Weekend,\n    Holiday,\n}\n\nfunc vending_machine_accept(input: (Coin, DayType)) -> (accepted: bool) {\n    match input {\n        (_, DayType::Weekday) => return (true),\n        (Coin::Dime | Coin::Quarter, DayType::Weekend) => return (true),\n        (Coin::Dime | Coin::Quarter, DayType::Holiday) => return (true),\n        _ => return (false),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: `match` Expression for `Coin` Enum - Cairo\nDESCRIPTION: This Cairo code demonstrates using a `match` expression with an enum `Coin`. It matches on the `Coin` type, specifically handling `Quarter` cases, binding a state variable. The code performs different actions depending on the variant of the enum encountered. It's used for cases requiring more complex logic or dealing with multiple enum variants and provides an alternative to `if let` for the same purpose.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nmatch coin {\n    Coin::Penny => {\n        println!(\"Lucky penny!\");\n    }\n    Coin::Nickel => println!(\"Nickel!\"),\n    Coin::Dime => println!(\"Dime!\"),\n    Coin::Quarter(state) => println!(\"Quarter from {:?}\", state),\n    _ => (),\n}\n```\n\n----------------------------------------\n\nTITLE: Using Named Parameters in Cairo Function Calls\nDESCRIPTION: Shows a function call using named parameters syntax where arguments are specified by parameter names rather than positions. Named parameters enhance readability, and when the variable name matches the parameter name, a syntax shortcut allows omitting the variable name after a colon. This requires functions with multiple parameters and variable bindings to match parameter names.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\nfn example_function(x: felt252, y: felt252) {\n    println!(\"x is {x}, y is {y}\");\n}\n\nfn main() {\n    let value_x = 10;\n    let value_y = 20;\n    example_function(x: value_x, y: value_y);\n    example_function(:x, :y); // Using shorthand for variables named x and y\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Definition for Starknet Messaging Contract in Solidity\nDESCRIPTION: This Solidity interface outlines the functions implemented by the StarknetMessaging contract on Ethereum, enabling the sending and consuming of messages between L1 and L2, as well as message cancellation mechanisms. It details the required parameters for each operation, such as target addresses, selectors, payloads, and nonces, facilitating interaction with Starknet's cross-chain messaging system.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_0\n\nLANGUAGE: Solidity\nCODE:\n```\ninterface IStarknetMessaging is IStarknetMessagingEvents {\n\n    function sendMessageToL2(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\n        external\n        returns (bytes32);\n\n    function startL1ToL2MessageCancellation(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n\n    function cancelL1ToL2Message(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating OpenZeppelin's Upgradeable Component in a Cairo Contract\nDESCRIPTION: This snippet demonstrates how to implement upgradeable contracts using OpenZeppelin's Upgradeable component. It combines the Upgradeable component with Ownable to restrict upgradeability to the contract owner, providing a secure upgradeability pattern.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-03-upgradeability.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::contract]\nmod UpgradeableContract {\n    // Imports\n    use openzeppelin::access::ownable::OwnableComponent;\n    use openzeppelin::upgrades::upgradeable::UpgradeableComponent;\n\n    // Components\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);\n\n    // Impling\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;\n    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;\n\n    #[abi(embed_v0)]\n    impl UpgradeableImpl = UpgradeableComponent::UpgradeableImpl<ContractState>;\n    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;\n\n    // Storage and Events\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        upgradeable: UpgradeableComponent::Storage\n    }\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n        #[flat]\n        UpgradeableEvent: UpgradeableComponent::Event,\n    }\n\n    // Constructor\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: starknet::ContractAddress) {\n        self.ownable.initializer(owner);\n    }\n\n    // Overriding the default upgrade method to add access control\n    #[external(v0)]\n    fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {\n        // Only the owner can upgrade the contract\n        self.ownable.assert_only_owner();\n        // Call the upgrade\n        self.upgradeable.upgrade(new_class_hash);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Arithmetic Circuit Implementation Example - Cairo\nDESCRIPTION: This comprehensive code listing demonstrates all steps: defining inputs, creating the circuit structure, specifying outputs, assigning input values, defining the modulus, evaluating the circuit, and retrieving output values. It can be used as a reference template for more advanced circuit building and emulation work in cryptographic research or zero-knowledge proof scenarios in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:full}}\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing in Cairo\nDESCRIPTION: An example demonstrating variable shadowing, where a new variable with the same name as an existing one is declared, effectively 'shadowing' the previous variable in the current scope.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x = 5;\n    let x = x + 1;\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n    }\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Incorrect Function Return\nDESCRIPTION: Displays the shell output containing the compiler error generated when trying to compile the invalid `plus_one` function (where the final expression is terminated by a semicolon). The error message `Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".` clearly indicates the type mismatch caused by the statement.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n# Assuming content from ../listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/output.txt\n$ scarb build\nerror: Unexpected return type. Expected: \"core::integer::u32\", found: \"()\".\n --> src/lib.cairo:7:5\n    x + 1;\n    ^\n\nerror: could not compile `ch03s03_functions` due to previous error\n\n```\n\n----------------------------------------\n\nTITLE: Executing Prime Prover using Scarb in Shell\nDESCRIPTION: This snippet demonstrates the command-line invocation of the prime_prover package using the Scarb build and execution tool. It compiles the project in development mode and runs the executable with a numeric argument meant to test primality. The program outputs the result for valid inputs and generates a panic error if the input exceeds 1,000,000. Dependencies include having the Scarb tool installed and the prime_prover project configured properly. The input is a single integer argument, and the output is either the primality test result or an error indicating input limits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch01-getting-started/prime_prover2/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb execute -p prime_prover --print-program-output --arguments 1000001\n   Compiling prime_prover v0.1.0 (listings/ch01-getting-started/prime_prover2/Scarb.toml)\n    Finished `dev` profile target(s) in 2 seconds\n   Executing prime_prover\nProgram output:\n1\nSaving output to: target/execute/prime_prover/execution2\nerror: Panicked with \"Input too large, must be <= 1,000,000\".\n```\n\n----------------------------------------\n\nTITLE: Attempting to modify a snapshot value (expected to fail)\nDESCRIPTION: This code illustrates an invalid operation where an attempt is made to modify a value passed as a snapshot, which Cairo's compiler disallows. The error prevents mutation of snapshot values, enforcing the rule that snapshots are immutable views, ensuring memory safety and consistent ownership semantics.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-02-references-and-snapshots.md#_snippet_2\n\nLANGUAGE: cairo,does_not_compile\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Counting with for Loops and Ranges in Cairo (cairo)\nDESCRIPTION: This code demonstrates using the Cairo Range feature in a for loop to count over a sequence of numbers, showing concise iteration from a starting value to an endpoint (exclusive). No external dependencies required except that Range support is provided by Cairo's standard library. Input is an integer range; output is sequential numeric values printed. The approach prevents boundary errors and simplifies counting code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_47_for_range/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Hashing a Struct Containing an Array using Poseidon in Cairo\nDESCRIPTION: This Cairo snippet illustrates how to hash a struct containing an `Array<felt252>` by using the `poseidon_hash_span` function on its `Span<felt252>`. It initializes a `HashState`, updates it by hashing the array using `poseidon_hash_span`, and finalizes the state to get the resulting `felt252` hash. This approach circumvents the inability to directly derive the Hash trait for structs with non-hashable fields by leveraging the `poseidon_hash_span` function on the array.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Executing Cairo Project Build and Run with Scarb\nDESCRIPTION: Uses the `scarb cairo-run` command to compile and execute a Cairo project. The subsequent output, included in the context, shows compilation errors related to item visibility.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nscarb cairo-run\n```\n\n----------------------------------------\n\nTITLE: Using mutable references in Cairo for in-place modification\nDESCRIPTION: This snippet demonstrates passing a mutable reference (`ref`) to a function, enabling mutation of a `Rectangle`'s fields (`height` and `width`). The `mut` declaration and `ref` keyword ensure that the function can modify the original data while maintaining ownership, with the entire struct copied into the function's stack for local mutation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-02-references-and-snapshots.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/listing_05_mutable_reference/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Showing Component's Impl Signature\nDESCRIPTION: This snippet includes an impl block syntax example used in components. It highlights the `HasComponent<TContractState>` trait and how the compiler generates implementations to wrap functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:impl_signature}}\n```\n\n----------------------------------------\n\nTITLE: Add Pragma as Project Dependency with Scarb.toml\nDESCRIPTION: This snippet shows how to add Pragma Oracle as a project dependency by modifying the `Scarb.toml` file. It specifies the git repository location for the `pragma_lib` dependency, allowing the project to access Pragma's functionalities.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-05-01-price-feeds.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\npragma_lib = { git = \"https://github.com/astraly-labs/pragma-lib\" }\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct to Hash\nDESCRIPTION: This Cairo snippet defines a struct that will be used for hashing, specifically designed to demonstrate the process with `Span<felt252>`. Because this struct contains a non-hashable type it showcases the need for custom hashing methods, like calling `poseidon_hash_span`. This step is essential for structuring the data that will be hashed using the `poseidon_hash_span` or custom methods.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:structure}}\n```\n\n----------------------------------------\n\nTITLE: Defining the area Method for Rectangle using Traits - Cairo\nDESCRIPTION: This snippet demonstrates how to define a method on the Rectangle struct using a trait and an impl block. The trait RectangleTrait is declared and implemented for Rectangle, with the area method receiving self as a snapshot parameter. This requires as prerequisites a Rectangle struct definition, as well as knowledge of Cairo's impl and trait system. The area method returns the area of the rectangle instance upon which it is called. It is recommended to use traits specifically for method syntax, even if the trait is only used for a single type.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_01_define_methods/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Serialized Event Representation in Transaction Receipt (Updating Book Author)\nDESCRIPTION: Shows a JSON snippet of the transaction receipt corresponding to a FieldUpdated event emitted on changing a book's author. As the FieldUpdated enum is annotated with #[flat], the event name becomes 'Author'. The snippet explains the serialized organization of keys and data fields enabling identification and filtering of the event externally.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-03-contract-events.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n\"events\": [\n    {\n      \"from_address\": \"0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79\",\n      \"keys\": [\n        \"0x1b90a4a3fc9e1658a4afcd28ad839182217a69668000c6104560d6db882b0e1\",\n        \"0x2a\"\n      ],\n      \"data\": [\n        \"0x5374657068656e204b696e67\"\n      ]\n    }\n  ]\n```\n\n----------------------------------------\n\nTITLE: Creating Integration Tests in the tests Directory in Cairo\nDESCRIPTION: This snippet shows the structure of an integration test file in the tests directory, referencing public functions from the main crate using use adder::add_two. No #[cfg(test)] annotation is needed, as Scarb automatically compiles these only for test runs. Each integration test file acts as its own crate and can use the public API of the library. The function under test should be public; any required setup must be accessible from outside the library. Assertions verify correct library behavior across modules.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_09_integration_test/tests/integration_tests.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Tests with Scarb\nDESCRIPTION: This snippet shows the execution of the `scarb test` command, which triggers the testing process for a Cairo project.  It compiles the project using the Scarb build system and then executes the tests defined within the project's source files. This command is a core component of the Cairo testing workflow. The output includes details on the compilation process, the number of tests collected, and the results of the test execution.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/output.txt#_snippet_0\n\nLANGUAGE: Scarb\nCODE:\n```\n$ scarb test \n     Running test no_listing_01_wrong_can_hold_impl (snforge test)\n   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)\n    Blocking waiting for file lock on build directory\n    Finished `release` profile [optimized] target(s) in 1.11s\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_01_wrong_can_hold_impl/Scarb.toml)\n    Finished `dev` profile target(s) in 6 seconds\n\n\nCollected 0 test(s) from no_listing_01_wrong_can_hold_impl package\nRunning 0 test(s) from src/\nTests: 0 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Initializing a Fixed Size Array in Cairo\nDESCRIPTION: This code shows how to declare a fixed-size array in Cairo, specifying the element type and the array's length.  All elements in the array must have the same type.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_40_fixed_size_arr_type/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Bringing a module into scope with `use` in Cairo\nDESCRIPTION: Shows how to simplify path references by bringing the hosting module into scope with the `use` keyword. This creates a shortcut to avoid repeating the full path.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n\n    // Using shortcut defined with `use`\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Default Values in Cairo\nDESCRIPTION: This snippet shows how to derive the Default trait, providing default values such as zero for types. It requires each element of a composite type to also implement Default, facilitating easy instantiation of default instances.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_07_default/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Deref Trait to Access Wrapped Data in Cairo\nDESCRIPTION: This snippet provides a simple implementation of the deref method for the Wrapper<T> struct, returning a reference to the contained value, enabling transparent member access of the wrapped data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_example/src/lib.cairo:deref}}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Store Trait for Custom Structs in Cairo\nDESCRIPTION: This snippet shows how to enable storage of a user-defined struct (e.g., Person) by deriving the starknet::Store trait. All member types must implement Store for the trait derivation to succeed, enabling the struct to be stored using the Storage struct. This is required for custom types not covered by the standard library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:person}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Tests with Scarb\nDESCRIPTION: This command executes the tests defined in the Cairo project using Scarb. It triggers the compilation of the project and the execution of the tests. The output displays the compilation status, test results, and gas usage. Prerequisites include a Cairo project with tests defined in the 'src/' and 'tests/' directories and Scarb installed and configured.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/output.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ scarb test \n     Running test adder (snforge test)\n   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)\n    Finished `release` profile [optimized] target(s) in 0.51s\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)\n    Finished `dev` profile target(s) in 7 seconds\n\n\nCollected 2 test(s) from adder package\nRunning 1 test(s) from tests/\n[PASS] adder_tests::integration_tests::internal (gas: ~1)\nRunning 1 test(s) from src/\n[PASS] adder::tests::add (gas: ~1)\nTests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Defining a User Database and Trait with Felt252Dict - Cairo\nDESCRIPTION: Shows how to define a generic struct UserDatabase<T> with Felt252Dict as a member for tracking user balances and a trait UserDatabaseTrait specifying the necessary functions to manipulate and retrieve user data. This snippet covers setting up generics, dictionary fields, and outlines function signatures required for a complete in-memory user management data structure. Dependencies include traits and dictionary primitives from the Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:struct}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:trait}}\n```\n\n----------------------------------------\n\nTITLE: Using Field Init Shorthand in Cairo\nDESCRIPTION: This snippet shows how to simplify struct initialization when function parameters share the same name as struct fields. Using field init shorthand reduces repetition by automatically assigning parameter values to matching fields.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:build_user2}}\n```\n\n----------------------------------------\n\nTITLE: Mock Contract Embedding Counter Component in Cairo\nDESCRIPTION: Defines a mock contract solely for testing that embeds the Counter component using the `component!` macro. The component's entry points are exposed via implementation aliases annotated with `#[abi(embed_v0)]`. This allows deploying the contract on a testnet or local environment so the Counter's methods can be called through a dispatcher, simulating real contract interaction.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/lib.cairo:mock_contract}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Mappings for Complex Data Structures in Cairo\nDESCRIPTION: This snippet shows how to declare nested mappings to represent more complex data structures, specifically a warehouse system that maps users to their items and quantities.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-01-storage-mappings.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n#[storage]\nstruct Storage {\n    user_warehouse: Map<ContractAddress, Map<u64, u64>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Cairo Program via Scarborough CLI Shell\nDESCRIPTION: This snippet demonstrates the command-line invocation of the Scarborough (scarb) tool to compile and run a Cairo project. Dependencies include a valid Scarborough configuration file (Scarb.toml) and the Cairo compiler environment. The command compiles the specified Cairo program, runs it, and returns the output, here demonstrating a calculation of an area value. Inputs are the files within the project directory and configuration, outputs include build status and program results. It assumes the user has configured the project correctly and focuses on executing and capturing the runtime output in the terminal.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb cairo-run \n   Compiling listing_04_06_no_struct v0.1.0 (listings/ch05-using-structs-to-structure-related-data/listing_03_no_struct/Scarb.toml)\n    Finished `dev` profile target(s) in 3 seconds\n     Running listing_04_06_no_struct\nArea is 300\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Including Multiple Cairo Files into a Single Test Crate\nDESCRIPTION: Shows how to combine several Cairo test files into one crate by creating a 'lib.cairo' inside the tests directory. This approach consolidates the test code, so only test functions are executed, and helper functions like 'setup' can be imported without creating separate output sections per file.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/tests/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Vote Contract in Starknet\nDESCRIPTION: Command to declare the Vote contract on a local Starknet node using Starkli, making it available for deployment.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nstarkli declare target/dev/listing_99_12_vote_contract_Vote.contract_class.json --rpc http://0.0.0.0:5050 --account katana-0\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Reuse After Move\nDESCRIPTION: This is the compiler output generated when trying to compile the code that attempts to reuse an array after it has been moved. The error explicitly states that the variable `arr` has been moved and suggests implementing the `Copy` trait, which is not possible for complex types like `Array`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nerror: Variable was moved.\n --> .../src/lib.cairo:11:9\n    foo(arr);\n    ^------\nnote: The variable was moved here.\n --> .../src/lib.cairo:10:9\n    foo(arr);\n    ^------\nnote: In order to use a variable after it was moved, the type must implement the `Copy` trait.\n   consider adding #[derive(Copy)] to the type definition.\n```\n\n----------------------------------------\n\nTITLE: Exposing Module with pub Keyword in Cairo\nDESCRIPTION: Shows how to expose a module using the pub keyword. This code still won't compile because while the hosting module is public, its contents remain private.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        fn add_to_waitlist() {\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Input Values to Circuit - Cairo\nDESCRIPTION: Here, values are assigned to the circuit's input elements, initializing a and b using Cairo's u384/u96 encoding suitable for 384-bit modulus. An accumulator and the new_inputs and next functions (returning AddInputResult enum) manage variable input initialization. The process ensures all required input values are set before evaluation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:instance}}\n```\n\n----------------------------------------\n\nTITLE: Example Command for Deploying Vote Contract\nDESCRIPTION: Example deployment command with actual address values for the contract class hash and three registered voters using the Katana test accounts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nstarkli deploy 0x06974677a079b7edfadcd70aa4d12aac0263a4cda379009fca125e0ab1a9ba52 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c 0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5 --rpc http://0.0.0.0:5050 --account katana-0\n```\n\n----------------------------------------\n\nTITLE: Reading arrays from dictionaries with entry method in Cairo\nDESCRIPTION: Demonstrates how to properly read an array from a dictionary using entry and finalize methods. This approach is necessary because arrays don't implement the Copy trait required for the get method.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_value(ref dict: Felt252Dict<Nullable<Array<felt252>>>, key: felt252) -> Span<felt252> {\n    let (entry, nullable_arr) = dict.entry(key);\n    match match_nullable(nullable_arr) {\n        FromNullableResult::Null(()) => {\n            dict = entry.finalize(NullableTrait::new(ArrayTrait::new()));\n            ArrayTrait::new().span()\n        },\n        FromNullableResult::NotNull(mut arr) => {\n            // Convert to span before finalizing to avoid moving the array\n            let span = arr.span();\n            dict = entry.finalize(NullableTrait::new(arr));\n            span\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Methods with #[generate_trait] Attribute - Cairo\nDESCRIPTION: This code provides an example of using the #[generate_trait] attribute to automate trait definition for methods belonging to Rectangle. It simplifies the syntax by letting the compiler generate the required trait, focusing only on the implementation. As with the previous approach, it requires a Rectangle struct definition and is intended to add methods to it while reducing boilerplate trait declarations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_02_gen_trait/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Copying Array Data with clone in Cairo\nDESCRIPTION: Demonstrates how to create a deep copy of an Array using the clone method. This creates a completely new copy of the array in memory rather than just copying the reference.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/no_listing_08_array_clone/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using Fixed Size Arrays for Months in Cairo\nDESCRIPTION: This demonstrates the use of fixed-size arrays for storing data that has a fixed number of elements, like month names. It is more efficient when the size does not need to change during runtime.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_9\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/src/lib.cairo:months}}\n```\n\n----------------------------------------\n\nTITLE: Defining Hosting Module in hosting.cairo\nDESCRIPTION: This code snippet defines a simple function `add_to_waitlist` within the `src/front_of_house/hosting.cairo` file. This file represents the implementation of the `hosting` submodule, which is a child module of `front_of_house`. The directory structure mirrors the module hierarchy.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\npub fn add_to_waitlist() {}\n```\n\n----------------------------------------\n\nTITLE: Getting Execution Info Starknet Cairo\nDESCRIPTION: This snippet shows the syntax for the `get_execution_info_syscall` in Cairo. This syscall consolidates access to various transaction, block, and execution context details. It returns a `SyscallResult` containing a boxed `ExecutionInfo` struct.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn get_execution_info_syscall() -> SyscallResult<\n    Box<starknet::info::ExecutionInfo>,\n> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Cast a Vote (Yes/No) with Starkli\nDESCRIPTION: This snippet shows how to cast a vote using the `starkli invoke` command, either 'Yes' (1) or 'No' (0).  It requires the contract address, the `vote` function name, the vote input (0 or 1), the RPC endpoint, and the account descriptor.  A fee is charged, and the transaction needs to be signed using the associated account's private key.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n//Voting Yes\nstarkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0\n\n//Voting No\nstarkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0\n```\n\n----------------------------------------\n\nTITLE: Match Arm with Block\nDESCRIPTION: This code snippet demonstrates using a code block within a `match` arm. It shows how to execute multiple lines of code when a specific pattern is matched. In this example, when `Coin::Penny` is matched, it prints \"Lucky penny!\" and then returns the value 1.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_06_match_arms_block/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Using panic! Macro in Cairo\nDESCRIPTION: Demonstrates the panic! macro which provides a more convenient way to panic than the panic function. The panic! macro allows for error messages longer than 31 bytes as it takes a string parameter.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let mut data = array![1, 2, 3];\n    data.append(4);\n    panic!('An error occurred');\n    println!(\"This code is never reached: {:?}\", data);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Function Comparing Lists with Drop Trait in Cairo\nDESCRIPTION: This snippet shows the definition of a generic function `largest_list` that compares two lists of a generic type `T` and returns the larger one based on element count. The function enforces that `T` must implement the `Drop` trait to handle resource cleanup properly. It highlights trait bounds in function signatures to ensure type safety and correctness.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_02_with_tdrop/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Including Modules in Cairo\nDESCRIPTION: Shows how to declare modules in Cairo using 'mod' and include their code from separate files. Demonstrates the use of 'pub mod' for public modules and how to bring items into scope with 'use'. The example revolves around a crate named 'backyard'.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-02-defining-modules-to-control-scope.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\npub mod garden;\n```\n\nLANGUAGE: Cairo\nCODE:\n```\nuse crate::garden::vegetables::Asparagus;\n```\n\n----------------------------------------\n\nTITLE: Using Negative Impls in Cairo\nDESCRIPTION: This code demonstrates the use of negative implementations (negative traits/bounds) in Cairo to express that a type does not implement a certain trait. It creates a default implementation of `Consumer` for all types that do not implement `Producer`, enforcing the constraint that a type cannot be both.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\ntrait Producer<T> {\n    fn produce(self: @T) -> felt252;\n}\n\ntrait Consumer<T> {\n    fn consume(self: @T, value: felt252);\n}\n\nstruct ProducerType {}\n\nimpl ProducerImpl of Producer<ProducerType> {\n    fn produce(self: @ProducerType) -> felt252 {\n        1234\n    }\n}\n\nstruct AnotherType {}\n\nstruct AThirdType {}\n\n// This code would fail to compile without `experimental-features = [\"negative_impls\"]` in Scarb.toml\nimpl<T, impl ProducerT of !Producer<T>> ConsumerImpl of Consumer<T> {\n    fn consume(self: @T, value: felt252) {\n        assert(value > 0, 'value must be positive');\n    }\n}\n\nfn main() {\n    let producer = ProducerType {};\n    let another_type = AnotherType {};\n    let third_type = AThirdType {};\n\n    let produced_value = Producer::produce(@producer);\n    Consumer::consume(@another_type, produced_value);\n    Consumer::consume(@third_type, produced_value);\n\n    // This line would cause a compile-time error because `ProducerType` does not implement `Consumer`.\n    // Consumer::consume(@producer, produced_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Build WASM-bindgen Toolkit without Modules\nDESCRIPTION: This command builds the WASM-Cairo toolkit without modules, using `wasm-pack`.  It sets the release profile, target to `no-modules`, output directory, and output name. The `no-modules` target creates a single JavaScript file and a wasm file without module.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack build --release --target no-modules --out-dir output/no_module/pkg --out-name wasm-cairo\n```\n\n----------------------------------------\n\nTITLE: Analyzing Cairo Function `sum_n` via Profiling Output\nDESCRIPTION: This code snippet reuses the Cairo function `sum_n` within a test context, illustrating how the profiling process captures function calls and execution steps. It demonstrates executing the `sum_n` function during test runs to generate trace and profile output necessary for performance analysis.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_17\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_06_test_gas/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Proposal by Populating a Storage Node in Cairo\nDESCRIPTION: This snippet demonstrates how to instantiate and populate a `ProposalNode` storage node in a Starknet contract. It sets individual members of the proposal, except the `voters` map which is initially empty. It illustrates that storage nodes cannot be read or written as a whole but must be accessed through their members individually. Key parameters include the proposal ID and proposal metadata. This emphasizes structured, fine-grained manipulation of contract storage via storage nodes.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:create_proposal}}\n```\n\n----------------------------------------\n\nTITLE: Verifying the Zero-Knowledge Proof\nDESCRIPTION: This command uses Scarb to verify a previously generated zero-knowledge proof.  Successful verification confirms that the computation was performed correctly, without needing to re-run the program.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n{{#include ../listings/ch01-getting-started/prime_prover/output_verify.txt}}\n```\n\n----------------------------------------\n\nTITLE: Importing traits and functions for array Hashing\nDESCRIPTION: This snippet focuses on importing necessary traits and functions for advanced hashing operations, specifically aimed at handling `Span<felt252>` and structures containing them in Cairo. The imported elements are essential for utilizing the `poseidon_hash_span` function and performing hashing on such data structures. It sets up the necessary dependencies for the following code examples, which involve hashing with poseidon.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_05_advanced_hash/src/lib.cairo:import}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Compiling Generic Trait `WalletMix` with Drop Constraints in Cairo\nDESCRIPTION: Defines the corrected `WalletMixTrait` and its implementation, adding `Drop` trait constraints to the generic type parameters (`T1`, `U1` on the implementation and `T2`, `U2` on the `mixup` method). These constraints satisfy the compiler's requirement for handling ownership and dropping the input `Wallet` instances within the `mixup` function, making the code compile.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_11\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait WalletMixTrait<T1, U1> {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> where T2: Drop, U2: Drop;\n}\n\nimpl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> where T1: Drop, U1: Drop {\n    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> where T2: Drop, U2: Drop {\n        Wallet { address: self.address, balance: other.balance }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Binary Tree Data Structure in Cairo\nDESCRIPTION: This snippet defines a recursive data structure 'BinaryTree' with 'Leaf' and 'Node' variants. It demonstrates the definition of a binary tree that contains integer values and can be recursively composed. The code indicates dependencies on Cairo's type definitions and patterns for recursive enums.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch12-advanced-features/listing_recursive_types_wrong/output.txt#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nenum BinaryTree:\n    Leaf(value: u32)\n    Node(left: BinaryTree, right: BinaryTree)\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants in Cairo\nDESCRIPTION: Examples of constant declaration in Cairo. Constants are always immutable, must have type annotations, and can only be set to constant expressions or computed values using consteval_int!.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nconst THREE_HOURS_IN_SECONDS: u64 = 60 * 60 * 3;\nconst SOME_INTEGER: u8 = 5;\nconst EMPTY_ARRAY: Array<felt252> = array![];\n\n// Using consteval_int! macro for computed constants\nconst COMPUTED_CONSTANT: u64 = consteval_int!(3 * 3 * 3);\n```\n\n----------------------------------------\n\nTITLE: Desnapping snapshots back into values in Cairo\nDESCRIPTION: This snippet shows how to convert a snapshot (`@Rectangle`) into a regular variable using the desnap operator `*`. This allows code to work with snapshots and then restore values for further use without ownership transfer. The example underscores that only `Copy` types are safely desnappable and that desnapping is a free operation when the value isn't modified.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-02-references-and-snapshots.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/no_listing_10_desnap/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining the Deref Trait in Cairo\nDESCRIPTION: This snippet shows the Cairo implementation of the Deref trait, which enables implicit conversion of a type into its target type by defining the Target associated type and the deref method that returns a reference to the inner data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_09_deref_coercion/src/lib.cairo:Deref}}\n```\n\n----------------------------------------\n\nTITLE: Using the `TryInto` Trait for Type Conversion in Cairo\nDESCRIPTION: This example demonstrates the use of the `TryInto` trait for fallible type conversions in Cairo. The conversion returns an `Option<T>`, indicating success or failure. The new variable's type must also be explicitly defined.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_14\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_39_tryinto/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Applying Hello Derive Macro - Cairo\nDESCRIPTION: Demonstrates applying the custom `#[derive(Hello)]` macro to a Cairo struct named `SomeType`. This tells the Rust compiler to invoke the `hello_derive` macro with the definition of `SomeType`, resulting in the `Hello` trait being implemented for `SomeType`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_15_procedural_macro/src/lib.cairo:some_struct}}\n```\n\n----------------------------------------\n\nTITLE: Consuming Messages from Starknet in Ethereum Solidity Contract\nDESCRIPTION: Shows how to consume a message sent from Starknet (L2) in a Solidity contract on Ethereum (L1) using the StarknetMessaging contract's consumeMessageFromL2 function. It includes validation of the payload and message source.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfunction consumeMessageFelt(\n    uint256 fromAddress,\n    uint256[] calldata payload\n)\n    external\n{\n    let messageHash = _snMessaging.consumeMessageFromL2(fromAddress, payload);\n\n    // You can use the message hash if you want here.\n\n    // We expect the payload to contain only a felt252 value (which is a uint256 in Solidity).\n    require(payload.length == 1, \"Invalid payload\");\n\n    uint256 my_felt = payload[0];\n\n    // From here, you can safely use `my_felt` as the message has been verified by StarknetMessaging.\n    require(my_felt > 0, \"Invalid value\");\n}\n```\n\n----------------------------------------\n\nTITLE: Handling If Condition with Non-Boolean Expression in Cairo\nDESCRIPTION: This snippet demonstrates what occurs when a non-bool value (specifically an integer) is used as the condition in an if statement in Cairo. The example intentionally triggers a type error by providing a numeric literal, illustrating that Cairos if statements require a boolean expression. Outputs an error at runtime or compile time, and includes no successful output.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Branching on Nonzero Numeric Values in Cairo If Expressions\nDESCRIPTION: This snippet checks if a numeric variable is not equal to zero inside an if expression. Instead of relying on implicit truthiness, a direct comparison creates a boolean condition, preventing type errors. The code prints a specific message when the number is nonzero and demonstrates best practices for conditionals in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_29_ter_if_not_equal_zero/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Front of House Module in lib.cairo\nDESCRIPTION: This code snippet declares the `front_of_house` module within the `src/lib.cairo` file. The actual implementation of the module will reside in a separate file named `src/front_of_house.cairo`. This declaration instructs the compiler to look for the module's definition in that file.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house;\n```\n\n----------------------------------------\n\nTITLE: Hashing a Struct with Poseidon in Cairo\nDESCRIPTION: This Cairo snippet demonstrates the use of the Poseidon hash function to hash a struct. It initializes a hash state with `PoseidonTrait::new()`, updates the state with the struct's fields using the `update_with` method, and finalizes the hash computation using `finalize()`, which returns the hash value as a felt252. This example provides a practical demonstration of the `Hash` trait and its associated functions with the Poseidon hash.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_04_hash_poseidon/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Sending Message to L1 Syntax Starknet Cairo\nDESCRIPTION: This snippet shows the syntax for the `send_message_to_l1_syscall` in Cairo, used to send a message from a Starknet contract (L2) to a specified Ethereum contract (L1). It takes the recipient's L1 address and the message payload as arguments. The function returns a `SyscallResult<()>`, indicating the outcome.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn send_message_to_l1_syscall(\n    to_address: felt252, payload: Span<felt252>,\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Cairo u256 Structure Definition\nDESCRIPTION: Defines the structure of a u256 type in Cairo, showing how it's composed of two u128 values (low and high) which will be serialized as two felt252 values when crossing layer boundaries.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nstruct u256 {\n    low: u128,\n    high: u128,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program Output in Shell\nDESCRIPTION: This shell snippet shows how to execute the Cairo program outputting the calculated area by running `scarb cairo-run`. The command runs the Cairo program compiled in the project and prints the result to standard output, demonstrating how to invoke and verify the functionality of Cairo code through the command line interface. No additional parameters are needed beyond this basic invocation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nscarb cairo-run\nOutput:\n40\n```\n\n----------------------------------------\n\nTITLE: Execute Cairo Program using Scarb (Shell)\nDESCRIPTION: Executes a compiled Cairo program using the Scarb build tool. The command automatically compiles the project if needed and then runs the main entry point of the specified package.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch09-error-handling/no_listing_01_panic/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb cairo-run \n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program with Scarb (Bash)\nDESCRIPTION: This snippet demonstrates the command to execute a Cairo program using the Scarb build tool. It involves compiling the program specified in the Scarb.toml file and then running the compiled executable. The output confirms the successful execution of the program, displaying \"Hello, World!\". No additional dependencies besides Scarb and Cairo are needed to run this command. The output is 'Hello, World!' and a message indicating the program's successful completion.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch01-getting-started/no_listing_01_hello_world/output_run.txt#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)\n    Finished `dev` profile target(s) in 15 seconds\n     Running hello_world\nHello, World!\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Final Sierra Steps in 'main' Function for Adding and Returning Values\nDESCRIPTION: Details the last instructions in the 'main' function that add values obtained from the inlined and non-inlined functions, store the result, and return it. The snippet explains the combination of intermediate results stored in variables and the consolidation of output, which is a key operation affected by the inlining process.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n03\tfelt252_add([1], [0]) -> ([2])\n04\tstore_temp<felt252>([2]) -> ([2])\n05\treturn([2])\n```\n\n----------------------------------------\n\nTITLE: Defining the Option Enum in Cairo\nDESCRIPTION: Documents the standard `Option` enum definition in Cairo. This enum represents an optional value, having two variants: `Some(T)` for a value of type `T`, and `None` for the absence of a value. It is crucial for representing optionality explicitly and avoiding null-related issues.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-01-enums.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nenum Option<T> {\n    Some: T,\n    None,\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Let Struct with Dict Go Out of Scope Without Destruct (Compile Error)\nDESCRIPTION: This code defines a struct `A` that contains a `Felt252Dict`. Dictionaries require a specific destruction behavior ('squashing'). Since `A` cannot derive `Drop` (as it contains a dictionary) and does not derive `Destruct`, the compiler fails when `a` goes out of scope because the required destruction logic is missing.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\nuse core::felt252_dict::Felt252Dict;\n\nstruct A {\n    dict: Felt252Dict<usize>,\n}\n\nfn main() {\n    let mut a = A { dict: Felt252Dict::<usize>::new() };\n    a.dict.insert(1, 10);\n    // This will cause a compile-time error\n}\n```\n\n----------------------------------------\n\nTITLE: Type Alias Definition for Direct ComponentState Testing in Cairo\nDESCRIPTION: Introduces a type alias `TestingState` that defines a concrete implementation of the generic `ComponentState` struct by binding it to the mock contract's `ContractState` type. This alias enables direct usage of component methods on the state object without deploying any contract, relying on the `HasComponent` trait implemented by the mock contract embedding the component.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-03-testing-components.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_04_test_component/src/tests_direct.cairo:type_alias}}\n```\n\n----------------------------------------\n\nTITLE: Mutable Variable Required for DerefMut in Cairo\nDESCRIPTION: This snippet shows that declaring the wrapped_profile as mutable enables use of DerefMut, allowing mutable access to the wrapped data, which would otherwise produce an error if it was immutable.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:example}}\n```\n\n----------------------------------------\n\nTITLE: Calling Contract Starknet Cairo\nDESCRIPTION: This snippet presents the low-level syntax for the `call_contract_syscall` in Cairo. It enables a contract to call another deployed contract by specifying its address, the selector of the entry point function, and the calldata as a span of felts. The function returns the call response also as a span of felts wrapped in a `SyscallResult`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn call_contract_syscall(\n    address: ContractAddress, entry_point_selector: felt252, calldata: Span<felt252>,\n) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Implementing UserDatabaseTrait With Generic Constraints - Cairo\nDESCRIPTION: Provides an implementation block for the UserDatabaseTrait, ensuring the type parameter T meets the requirements for proper usage with Felt252Dict (i.e., implementing Copy<T>, Drop<T>, and Felt252DictValue<T>). The implementation covers construction, updating user balances, and retrieving them. This code establishes all technical constraints for T so that the user database remains type-safe and compatible with Cairo's resource handling.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:impl}}\n```\n\n----------------------------------------\n\nTITLE: Using `while let` for Looping over `Option` - Cairo\nDESCRIPTION: This Cairo code demonstrates the use of `while let` to loop over a collection of values. It uses the pattern `Some(x)` to iterate through a series of `Option` values. The loop continues as long as the values match the `Some` variant. `while let` is a more concise and idiomatic solution when handling an Option of values when the code only needs to process a specific pattern.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nwhile let Some(x) = some_option_value {\n    println!(\"{:#?}\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Rename Attribute Macro - Cairo\nDESCRIPTION: Demonstrates applying the custom `#[rename(RenamedType)]` attribute macro to a Cairo struct named `OldType`. The macro will process this definition and generate code that introduces `RenamedType` instead of `OldType`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_11\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_15_procedural_macro/src/lib.cairo:old_trait}}\n```\n\n----------------------------------------\n\nTITLE: Using super for Relative Paths in Cairo\nDESCRIPTION: Illustrates using super to reference items in parent modules. This pattern is useful when modules are closely related but might be moved in the module tree later.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Associated Functions (Constructors) for Rectangle - Cairo\nDESCRIPTION: This code defines several associated functions that act as constructors and utility functions for Rectangle: new, square, and avg. These are declared in a trait and implemented for Rectangle, illustrating the use of associated functions that do not require self. The main function demonstrates their usage including initializing rectangles and computing their average. All functions require the Rectangle struct and trait implementation context; inputs and outputs vary according to the function.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-03-method-syntax.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/src/lib.cairo:trait_impl}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch05-using-structs-to-structure-related-data/no_listing_05_class_methods/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Sierra Statements of 'inlined' Function Demonstrating Inlined Execution\nDESCRIPTION: Shows how the Sierra code for the inlined function is incorporated directly into the caller's context, avoiding an explicit function call. This code produces a constant value and stores it like a local temporary variable, demonstrating the inlining effect on variable IDs and eliminating call overhead. The snippet is crucial for understanding how inlining reduces execution steps and improves performance.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n06\tfelt252_const<1>() -> ([0])\n07\tstore_temp<felt252>([0]) -> ([0])\n```\n\n----------------------------------------\n\nTITLE: Using a Library Dispatcher to Execute External Class Logic in Cairo\nDESCRIPTION: Demonstrates a `ValueStoreExecutor` contract utilizing a generated `IValueStoreLibraryDispatcher` to invoke functions (`set_value`, `get_value`) residing in a separate `ValueStoreLogic` class. This example highlights that library calls operate within the context of the caller (`ValueStoreExecutor`), thus modifying its own storage (`value`). It depends on importing the dispatcher trait and providing the `class_hash` of the logic class.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-03-executing-code-from-another-class.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch102-starknet-cross-contract-interactions/listing_05_library_dispatcher/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Generating a Zero-Knowledge Proof\nDESCRIPTION: This command uses Scarb to generate a zero-knowledge proof for the specified execution of the 'prime_prover' program. `--execution_id 1` points to the first execution.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n{{#include ../listings/ch01-getting-started/prime_prover/output_prove.txt}}\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure for Cairo Integration Tests\nDESCRIPTION: This shell snippet outlines the expected directory layout for a Cairo project with both unit and integration tests. The src directory holds implementation and unit test code, while the tests directory holds integration tests, each as separate files or crates. This structure is required for Scarb and Cairos test discovery and execution features to work properly. No specific inputs or outputs; the structure must exist prior to running scarb test.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nadder\n Scarb.lock\n Scarb.toml\n src\n    lib.cairo\n tests\n     integration_tests.cairo\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Variable in Cairo\nDESCRIPTION: This snippet shows a basic variable declaration in Cairo, assigning a short string literal to the variable `s`. It marks the point where the variable `s` comes into scope and becomes valid.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nlet s = 'hello';\n```\n\n----------------------------------------\n\nTITLE: Re-exporting names with `pub use` in Cairo\nDESCRIPTION: Shows how to re-export items to make them available to external code through a different path structure using the `pub use` syntax.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Variable Scope in Cairo\nDESCRIPTION: This example demonstrates the concept of variable scope in Cairo. The variable `s` is valid from its declaration within the main function's scope until the end of that function's execution block.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    // s is not valid here, it hasn't been declared yet\n    let s = 'hello'; // s is valid from this point forward\n\n    // do stuff with s\n\n} // This scope is now over, and s is no longer valid\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Bun - Bash\nDESCRIPTION: Installs project dependencies required for running the helper scripts using the Bun package manager. This command must be executed in the helper scripts directory with Bun pre-installed. No input parameters are required; it installs all necessary packages as specified in the project configuration.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/scripts/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbun install\n\n```\n\n----------------------------------------\n\nTITLE: Explanation of closure traits (`FnOnce`, `Fn`) and their Role in Cairo\nDESCRIPTION: This snippet and commentary explain how closures in Cairo implement `FnOnce` and `Fn` traits depending on how they handle captured variables. It details that closures moving captured values only implement `FnOnce`, while those not moving or mutating features can implement `Fn`, enabling multiple calls. It highlights the importance of these traits in code such as `unwrap_or_else`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Starknet Foundry Test Output\nDESCRIPTION: Shows the expected output after running Starknet Foundry tests. It demonstrates the successful completion of all tests and provides gas estimation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n{{#include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Failed Type Change with Mutable Variables in Cairo\nDESCRIPTION: An example demonstrating that mutable variables cannot change type, unlike with shadowing. This code will not compile because it attempts to change the type of a mutable variable.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n// This code will not compile\nfn main() {\n    let mut x: u64 = 5;\n    x = x.into();\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Output Values from the Circuit - Cairo\nDESCRIPTION: This code demonstrates how to extract specific output values from the evaluation result using the get_output function. It allows retrieval of final gate values and any intermediate nodes present in the output tuple, providing flexibility for result validation or downstream cryptographic protocols.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:output_values}}\n```\n\n----------------------------------------\n\nTITLE: Duplicated Largest Number Logic for Multiple Arrays in Cairo\nDESCRIPTION: This snippet duplicates the repeated logic for finding the largest number in different arrays of u8 within the same program. Although operationally correct, the direct code duplication is tedious and error-prone, leading to maintainability challenges. It highlights the need to abstract this repeated pattern into a reusable function.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-00-generic-types-and-traits.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/listing_08_01_extracting_function_02/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: pow Macro Implementation\nDESCRIPTION: This is an example implementation of a `pow` macro. It's a Rust function decorated as a procedural macro. It takes a `TokenStream` as input, parses the arguments, and returns the result of the exponentiation. The macro utilizes crates from the Cairo ecosystem like `cairo_lang_macro`, `cairo_lang_parser`, and `cairo_lang_syntax` for the macro implementation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[macro_export]\n#[inline_macro]\npub fn pow(base: felt252, exponent: felt252) -> felt252 {\n    let mut result = 1;\n    let mut b = base;\n    let mut e = exponent;\n    while e > 0 {\n        if e % 2 == 1 {\n            result = result * b;\n        }\n        b = b * b;\n        e = e / 2;\n    }\n    result\n}\n\n```\n\n----------------------------------------\n\nTITLE: Check Voter Registration with Starkli\nDESCRIPTION: This snippet demonstrates how to use the `starkli call` command to check if an address is registered as a voter by calling the `is_voter_registered` function. It takes the contract address, function name, and voter address as input. It expects a boolean response indicating registration status. The RPC endpoint must also be specified.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nstarkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 is_voter_registered 0x44444444444444444 --rpc http://0.0.0.0:5050\n```\n\n----------------------------------------\n\nTITLE: Describing Arithmetic Circuit Structure - Cairo\nDESCRIPTION: This code describes the internal composition of the circuit, combining input elements and arithmetic gates (addition and multiplication) to compute the polynomial expression a * (a + b). It uses circuit_add and circuit_mul combinators to assemble intermediate nodes, reflecting the circuit's data flow. Dependencies include defined CircuitElement types and functionality from core::circuit.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:description}}\n```\n\n----------------------------------------\n\nTITLE: Reading Contract Storage using storage_read_syscall in Cairo\nDESCRIPTION: Defines the `storage_read_syscall` function to retrieve a value from a specified key within the calling contract's storage. It takes an `address_domain` (currently only 0 for on-chain L1 data) and a `StorageAddress` as input. It returns the `felt252` value at that address wrapped in a `SyscallResult`, providing direct access to any storage key, unlike `var.read()`. Requires `GasBuiltin` and `System` implicits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\npub extern fn storage_read_syscall(\n    address_domain: u32, address: StorageAddress,\n) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Using `if let` to Match `Some` - Cairo\nDESCRIPTION: This Cairo code shows how to use `if let` to achieve the same functionality as the previous `match` example. It binds the value inside `Some` to the variable `max` and prints it. It provides a more concise way to handle the \"Some\" variant when you only care about one case. The main function of this is to check if the value is \"Some\", then print its contents, making it more readable by removing unnecessary parts of the code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-03-concise-control-flow-with-if-let-and-while-let.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nif let Some(max) = config_max {\n    println!(\"The maximum is: {:#?}\", max);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program Showing Sequential Function Calls (Shell)\nDESCRIPTION: Demonstrates running the compiled Cairo code using a shell command that executes the program and prints output to the console. Shows the order of line execution from the main function, illustrating function calls print messages sequentially.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nHello, world!\nHello from another function!\n```\n\n----------------------------------------\n\nTITLE: Implementing DerefMut for a Mutable Wrapper in Cairo\nDESCRIPTION: This snippet shows the implementation of the DerefMut trait for the Wrapper<T> struct, allowing mutable access to the inner value when the wrapper instance is mutable.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:derefMut}}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Values Using Tuples in Cairo\nDESCRIPTION: Shows how to return multiple values from a function using a tuple. This demonstrates a pattern for both returning a computed result and maintaining ownership of the original input value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch04-understanding-ownership/listing_03_returning_many_values/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Emitting Event Syntax Starknet Cairo\nDESCRIPTION: This snippet shows the syntax for the `emit_event_syscall` in Cairo, allowing a contract to emit an event. Events consist of a list of keys (used for filtering) and a list of data elements. The function returns a `SyscallResult<()>`, indicating success or failure.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn emit_event_syscall(\n    keys: Span<felt252>, data: Span<felt252>,\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Defining Front of House Module in front_of_house.cairo\nDESCRIPTION: This code snippet shows the definition of the `front_of_house` module within the `src/front_of_house.cairo` file. It contains submodule declarations or function definitions that belong to the `front_of_house` module. This file is automatically linked to the module declaration in `src/lib.cairo`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-05-separating-modules-into-different-files.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\npub mod hosting;\n\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with Scarb in Cairo Project\nDESCRIPTION: Terminal command and output for running tests in a Cairo project using Scarb and Starknet Foundry. Shows compilation process, test execution, and results including gas usage for each test.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb test \n     Running test adder (snforge test)\n   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)\n    Blocking waiting for file lock on build directory\n    Finished `release` profile [optimized] target(s) in 0.88s\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)\n    Finished `dev` profile target(s) in 9 seconds\n\n\nCollected 2 test(s) from adder package\nRunning 1 test(s) from tests/\n[PASS] adder_integrationtest::integration_tests::it_adds_two (gas: ~1)\nRunning 1 test(s) from src/\n[PASS] adder::tests::internal (gas: ~1)\nTests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Verify Voter Eligibility with Starkli\nDESCRIPTION: This snippet demonstrates how to use the `starkli call` command to check if a voter is eligible to vote by calling the `voter_can_vote` function on the smart contract.  It takes the contract address, function name, and voter address as input. It expects a boolean response indicating eligibility. The RPC endpoint must also be specified.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nstarkli call 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 voter_can_vote 0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0 --rpc http://0.0.0.0:5050\n```\n\n----------------------------------------\n\nTITLE: Executing a Cairo Program with Scarb CLI and Command Arguments\nDESCRIPTION: A shell command demonstrating how to execute a Cairo program named 'prime_prover' with the Scarb build tool, passing 17 as an argument and requesting program output to be printed to the console.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch01-getting-started/prime_prover/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb execute -p prime_prover --print-program-output --arguments 17\n```\n\n----------------------------------------\n\nTITLE: Deriving and Using the Destruct Trait in Cairo\nDESCRIPTION: This example defines a struct `A` containing a `Felt252Dict` and correctly derives the `Destruct` trait. Deriving `Destruct` ensures that when `a` goes out of scope, the dictionary it contains is automatically 'squashed', fulfilling the linear type system requirements and allowing the code to compile successfully.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\nuse core::felt252_dict::Felt252Dict;\n\n#[derive(Destruct)]\nstruct A {\n    dict: Felt252Dict<usize>,\n}\n\nfn main() {\n    let mut a = A { dict: Felt252Dict::<usize>::new() };\n    a.dict.insert(1, 10);\n    // a goes out of scope here and is automatically destructed (squashing the dictionary)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementation pattern of `filter` function to select array elements based on a predicate\nDESCRIPTION: This snippet showcases a Cairo implementation of the `filter` function, which uses a closure returning a boolean to determine whether to keep each element. The filtering process applies a predicate closure to filter out undesired elements, demonstrating how closures can be utilized for conditional array processing and making use of Cairo's trait bounds for expected closure return types.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_closures/src/lib.cairo:array_filter}}\n```\n\n----------------------------------------\n\nTITLE: Creating Array Using array! Macro in Cairo\nDESCRIPTION: Demonstrates using the convenient `array!` macro to create and initialize an array with a list of elements in a single expression. This macro expands into the manual `new()` and `append()` calls at compile time.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-01-arrays.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\nuse array::array;\n\nfn create_with_macro() {\n    let mut arr = array![10, 20, 30];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Katana Local Starknet Node\nDESCRIPTION: Command to start a local Starknet node with Katana, which provides predeployed accounts for testing and development.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nkatana\n```\n\n----------------------------------------\n\nTITLE: Match Option<u8> - None case\nDESCRIPTION: Demonstrates the `None` case in the match expression for `Option<u8>`.  This handles the scenario where there is no value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:option_none}}\n```\n\n----------------------------------------\n\nTITLE: Running a Cairo Program with Scarb CLI\nDESCRIPTION: This command uses Scarb (Cairo's package manager) to compile and run a Cairo program. The output shows the compilation process, execution time, and the program's output message indicating a condition was false with a number value of 3.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_27_if/output.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb cairo-run\n```\n\n----------------------------------------\n\nTITLE: Cast Multiple Votes with Starkli\nDESCRIPTION: This snippet demonstrates two calls to the `vote` function.  It highlights the error that occurs if a user attempts to vote twice. Requires the contract address, function name, vote input (0 or 1), RPC endpoint, and the account descriptor.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nstarkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 0 --rpc http://0.0.0.0:5050 --account katana-0\n\nstarkli invoke 0x05ea3a690be71c7fcd83945517f82e8861a97d42fca8ec9a2c46831d11f33349 vote 1 --rpc http://0.0.0.0:5050 --account katana-0\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements via Span in Cairo\nDESCRIPTION: This snippet shows how to access elements of a fixed-size array by converting it to a Span. This allows indexing into the array for element access, and the conversion to Span has no runtime cost.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_12\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_44_fixed_size_arr_accessing_elements_span/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing an ABI Embedded Interface in Starknet Contracts Using Cairo\nDESCRIPTION: This code snippet demonstrates the correct syntax for importing a component's impl block as an ABI embedded interface in a Starknet contract using Cairo. The `#[abi(embed_v0)]` attribute is applied to the `impl` declaration, which binds `IMPL_NAME` to the appropriate component's embedded interface (EMBEDDED_NAME) parameterized with `ContractState`. Dependencies include the target component located at `PATH_TO_COMPONENT` and a contract state definition. Replace `IMPL_NAME`, `PATH_TO_COMPONENT`, and `EMBEDDED_NAME` as appropriate. Input to this construct is the component state via generics; output is a compiled contract with correctly embedded component functionality. This approach is constrained to Starknet contracts following the ABI embedding standard.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-05-common-error-messages.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n#[abi(embed_v0)]\nimpl IMPL_NAME = PATH_TO_COMPONENT::EMBEDDED_NAME<ContractState>\n```\n\n----------------------------------------\n\nTITLE: Accessing and Mutating Struct Fields in Cairo\nDESCRIPTION: This snippet shows how to access a struct field using dot notation, such as `user1.email`, and how to mutate the entire instance if it is mutable. It illustrates field access and mutation syntax in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_02_mut_struct/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Corresponding Sierra Code Illustrating Inlining Mechanics in Cairo\nDESCRIPTION: Shows the Sierra intermediate representation of the Cairo inlining example, breaking down the structure into type and libfunc declarations, program statements, and function declarations. It highlights how the 'main', 'inlined', and 'not_inlined' functions correspond to line intervals, and presents the Sierra instructions executed both when calling a non-inlined function and when using inlined code. The snippet explains variable assignments, use of felt252 data types, and handling of return values in an inlining context.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_03_inlining_example/src/inlining.sierra}}\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Arithmetic Circuit - Cairo\nDESCRIPTION: This snippet evaluates the circuit with the assigned inputs and defined modulus, computing the outputs (and potentially intermediate gates) by executing the circuit's gate structure. Evaluation processes all operations modularly and returns a result object encapsulating output values. It relies on prior steps of circuit construction.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:eval}}\n```\n\n----------------------------------------\n\nTITLE: Successful starkup installation message\nDESCRIPTION: The confirmation message displayed when starkup has been successfully installed on the system.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-01-installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nstarkup: Installation complete.\n```\n\n----------------------------------------\n\nTITLE: Building Cairo Project with Scarb\nDESCRIPTION: This snippet demonstrates the use of the Scarb build command to compile a Cairo project. It shows the command used and its output including the compilation process, warnings, and errors.  The `scab build` command initiates the build process of a Cairo project managed by Scarb, identifying the project, and showing any errors or warnings that occur during compilation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_07_use_and_scope/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb build\n```\n\n----------------------------------------\n\nTITLE: Compiler Error for Struct with Dict Missing Destruct\nDESCRIPTION: This is the compiler output for the code attempting to drop a struct containing a dictionary without implementing or deriving `Destruct`. The error indicates that the type `A` was neither dropped nor moved, and explicitly mentions that `Destruct` must be implemented because `Drop` cannot be derived for types containing dictionaries.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nerror: Variable was neither dropped nor moved.\n --> .../src/lib.cairo:11:1\n}\n^\nnote: Variable needs to be destructed here.\n --> .../src/lib.cairo:11:1\n}\n^\nnote: `Drop` cannot be derived for types containing `Felt252Dict<usize>`. Implement `Destruct` instead.\n   consider adding #[derive(Destruct)] to the type definition.\n```\n\n----------------------------------------\n\nTITLE: Getting Block Hash Starknet Cairo\nDESCRIPTION: This snippet provides the syntax for the `get_block_hash_syscall` in Cairo. It is used to retrieve the hash of a specific Starknet block by providing its number. The function returns a `felt252` representing the block hash within a valid range of block numbers.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn get_block_hash_syscall(\n    block_number: u64,\n) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Implementing Deref for a Generic Wrapper in Cairo\nDESCRIPTION: This snippet demonstrates the implementation of the Deref trait for a generic Wrapper<T> struct in Cairo, facilitating direct access to the wrapped value of type T through dereference, simplifying interaction with nested data structures.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_example/src/lib.cairo:Wrapper}}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Conditions with Else If Chains in Cairo\nDESCRIPTION: This snippet uses an else if construct for multi-path conditional branching. Several mutually exclusive conditions are checked in order, with the corresponding code executed for the first true condition. If none match, the else block is executed. Useful for handling more than two possible outcomes in conditional logic.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_30_else_if/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Reading from a Storage Mapping in Cairo\nDESCRIPTION: This snippet shows how to read a value from a storage mapping by retrieving the storage pointer with the entry method and then calling read on it.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-01-storage-mappings.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn get_balance(self: @ContractState) -> u64 {\n    let caller = get_caller_address();\n    let balance = self.balances.read(caller);\n    balance\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Failure Messages to Assertions\nDESCRIPTION: This code demonstrates adding custom failure messages to assertions using the `assert!` , `assert_eq!`, and `assert_ne!` macros. It utilizes the `format!` macro for creating messages that include placeholders for variable values. The output of the test will show the actual value and the expectation for the failure.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\n// Example of tests with custom messages\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Mocking Caller Address in Cairo\nDESCRIPTION: This snippet uses `start_cheat_caller_address` from `snforge_std` to mock the caller's address for testing access control. It allows simulating calls from different addresses to test permissioned functions, like changing the owner in the `PizzaFactory` contract.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_owner}}\n```\n\n----------------------------------------\n\nTITLE: Capturing Events in Cairo\nDESCRIPTION: Shows how to capture events emitted by a Starknet contract using `spy_events` from `snforge_std`. This is useful for verifying that specific events are emitted with the expected parameters when certain actions occur, such as creating a pizza in the `PizzaFactory` contract.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/tests/foundry_test.cairo:test_make_pizza}}\n```\n\n----------------------------------------\n\nTITLE: Increment Function with Ownership Check in Cairo\nDESCRIPTION: This snippet implements the `increment` function, which increases the counter value. It uses the `get_dep_component!` macro to access the Ownable component's state and calls the `assert_only_owner` function to ensure that only the owner can call the `increment` function.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-02-component-dependencies.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_03_component_dep/src/counter.cairo:increment}}\n```\n\n----------------------------------------\n\nTITLE: Specifying Circuit Outputs - Cairo\nDESCRIPTION: This snippet defines the outputs for the arithmetic circuit by specifying which circuit elements represent the external output signals for circuit evaluation. In this example, the final multiplication gate is used as the sole output for clarity. This modular output declaration is required for the evaluation step.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:output}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program Output for Function with Parameter (Shell)\nDESCRIPTION: Shows expected console output of running the Cairo program where `another_function` is called with argument `5`. Illustrates parameter passing reflecting in printed output.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nThe value is 5\n```\n\n----------------------------------------\n\nTITLE: Serializing Data Structures with Serde in Cairo\nDESCRIPTION: This snippet explains how to use Serde in Cairo to serialize and deserialize data structures, enabling data persistence. It includes examples of transforming structures into arrays and back, with notes on ownership and the need for Drop derivation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_06_serialize/src/lib.cairo}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_07_deserialize/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Tests with Scarb and Snforge\nDESCRIPTION: This command runs the tests within a Scarb project, using the Snforge test runner. The command `scarb test` triggers the compilation and execution of tests defined within the project. It compiles the necessary dependencies and then executes the tests, producing a report indicating passed, failed, skipped, ignored, or filtered out tests. Dependencies include Scarb, Snforge and the Cairo compiler. It outputs the results of the test execution, including failure data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb test \n     Running test no_listing_02_custom_messages (snforge test)\n   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)\n    Blocking waiting for file lock on build directory\n    Finished `release` profile [optimized] target(s) in 0.39s\n   Compiling test(listings/ch10-testing-cairo-programs/no_listing_02_custom_messages/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n\n\nCollected 1 test(s) from no_listing_02_custom_messages package\nRunning 1 test(s) from src/\n[FAIL] no_listing_02_custom_messages::tests::it_adds_two\n\nFailure data:\n    \"assertion `4 == add_two(2)` failed: Expected 4, got add_two(2)=5\n    4: 4\n    add_two(2): 5\"\n\nTests: 0 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    no_listing_02_custom_messages::tests::it_adds_two\n```\n\n----------------------------------------\n\nTITLE: Appending Data to Immutable Arrays in Cairo - Cairo\nDESCRIPTION: This snippet demonstrates how to append values to a fixed array structure in Cairo, illustrating the immutability of array elements after insertion. It introduces the challenge of modifying collection elements, motivating migration to more flexible data types such as dictionaries. No external dependencies are required for this basic pattern, but mutability constraints persist.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/listing_01_array_collection/src/lib.cairo:array_append}}\n```\n\n----------------------------------------\n\nTITLE: Type Changes through Shadowing in Cairo\nDESCRIPTION: An example showing how variable shadowing allows changing a variable's type while reusing its name, which is not possible with mutable variables.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let x: u64 = 5;\n    let x: felt252 = x.into();\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Rectangle Area Using Structs in Cairo\nDESCRIPTION: This snippet introduces a `Rectangle` struct with named fields `width` and `height` of type `u64` to represent the rectangle dimensions explicitly. The `area` function takes a `Rectangle` instance, accesses its fields using dot notation, and returns the area calculation. The `main` function creates a `Rectangle` instance with specific dimensions and calls the `area` function. Using structs adds clarity and safety by naming fields, improving readability and reducing potential errors from indexing, especially as the complexity of uses grows.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nstruct Rectangle {\n    width: u64,\n    height: u64\n}\n\nfunc area(rectangle: Rectangle) -> (area: u64) {\n    let area = rectangle.width * rectangle.height;\n    return (area,);\n}\n\nfunc main() -> (res: u64) {\n    let rectangle = Rectangle { width: 30, height: 10 };\n    let (res) = area(rectangle);\n    return (res,);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Data Types Example in Cairo\nDESCRIPTION: This snippet likely includes code that declares and uses various data types available in Cairo. This may involve felts, integers, booleans, and perhaps the usage of short and byte array strings. It shows how to declare variables with different types, demonstrating the statically typed nature of the language. Dependencies include the Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{\n    // Example code demonstrating declaration of different types\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating `use` scope limitations in Cairo modules\nDESCRIPTION: This example shows that a `use` statement only applies within the scope where it's defined. The hosting module shortcut doesn't work in the customer submodule.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Function Return Due to Statement in Cairo\nDESCRIPTION: Shows an incorrect version of the `plus_one` function where a semicolon is added after `x + 1`. This turns the expression into a statement, which evaluates to the unit type `()`. This conflicts with the declared return type `u32`, causing a compilation error. This code snippet is marked as `does_not_compile`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_15\n\nLANGUAGE: cairo\nCODE:\n```\n// Assuming content from ../listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo\nfn main() {\n    let x = plus_one(5);\n    println!(\"The value of x is: {}\", x);\n}\n\nfn plus_one(x: u32) -> u32 {\n    x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program Output for Multi-Parameter Function (Shell)\nDESCRIPTION: Console output after running the `print_labeled_measurement` example, confirming that the function parameters have been correctly passed and printed with the supplied values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nValue: 5, Unit: h\n```\n\n----------------------------------------\n\nTITLE: Processing SHA-256 Blocks using sha256_process_block_syscall in Cairo\nDESCRIPTION: Defines the `sha256_process_block_syscall` for incrementally computing SHA-256 hashes. It processes a single 512-bit block (`Box<[u32; 16]>`) of input data using the current SHA-256 state (`core::sha256::Sha256StateHandle`). The function returns the updated SHA-256 state handle wrapped in `SyscallResult`. Requires `GasBuiltin` and `System` implicits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_15\n\nLANGUAGE: cairo\nCODE:\n```\npub extern fn sha256_process_block_syscall(\n    state: core::sha256::Sha256StateHandle, input: Box<[u32; 16]>\n) -> SyscallResult<core::sha256::Sha256StateHandle> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Type Conversion Using the Into Trait in Cairo\nDESCRIPTION: This snippet demonstrates how to define a custom type conversion implementing the `Into` trait for a user-defined type in Cairo. It shows how to specify the type to convert into and implement the required `into` method, facilitating implicit or explicit conversions between custom compound types, such as structs or tuples, and other types. This enhances code flexibility and reuse by automating type transformations while requiring the target type to be explicitly specified. There are no dependencies beyond the standard Cairo traits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-02-an-example-program-using-structs.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nimpl Into<u64> for Rectangle {\n    fn into(self) -> u64 {\n        self.width * self.height\n    }\n}\n\nfunc main() {\n    let rectangle = Rectangle { width: 30, height: 10 };\n    let area: u64 = rectangle.into();\n}\n```\n\n----------------------------------------\n\nTITLE: Making Module and Function Public in Cairo\nDESCRIPTION: Demonstrates proper use of the pub keyword to make both a module and its function accessible from outside. This code will compile successfully.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Cairo Code Compilation Error\nDESCRIPTION: This snippet represents the compilation error encountered while compiling a Cairo program. The error arises from the use of `dict.get(0)` and reports a missing implementation for `core::traits::Copy` which indicates a type incompatibility issue. The error occurs specifically on line 13. The output signifies a failure to compile the specified Cairo project due to issues with type handling within the Cairo code, specifically with how the program deals with nullable arrays.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/output.txt#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nerror: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>.\n --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:13:20\n    let val = dict.get(0); // This will cause a compiler error\n                   ^*^\n\nerror: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Self for Generic Implementation in Cairo\nDESCRIPTION: This snippet defines a public trait named `Summary` designed to be implemented on various types. It declares a `summarize` method that takes the implementing type itself (represented by `@Self`) and returns a `ByteArray`. This pattern allows the trait to be implemented on different concrete types like `NewsArticle` and `Tweet`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\npub trait Summary {\n    fn summarize(self: @Self) -> ByteArray;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Person Struct to Illustrate StorageBase Usage in Cairo\nDESCRIPTION: This snippet defines a `Person` struct to exemplify how a storage variable of struct type can be modeled by a `StorageBase`. Accessing fields like `name` and `address` from the base storage pointer demonstrates deriving pointers to specific fields, which then can invoke `read` and `write` operations transparently. This clarifies how structs are mapped into contract storage and how the core library abstracts storage reads/writes with pointer-based operations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:person}}\n```\n\n----------------------------------------\n\nTITLE: Executing Cairo Tests using `scarb test`\nDESCRIPTION: Demonstrates the command `scarb test` used to run tests in a Cairo project managed by Scarb. The output shows the compilation process involving `snforge` and the target test package, followed by the execution summary indicating one passing test ('greater_than_100'). The output confirms successful test execution with details on the test suite and individual test results.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/listing_10_05/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb test \n     Running test listing_09_08 (snforge test)\n   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)\n    Blocking waiting for file lock on build directory\n    Finished `release` profile [optimized] target(s) in 0.21s\n   Compiling test(listings/ch10-testing-cairo-programs/listing_10_05/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n\n\nCollected 1 test(s) from listing_09_08 package\nRunning 1 test(s) from src/\n[PASS] listing_09_08::tests::greater_than_100 (gas: ~1)\n\nSuccess data:\n    \"Guess must be >= 1 and <= 100\"\n\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Illustrating Incorrect Contract Implementation in Cairo\nDESCRIPTION: Shows an incorrect implementation (`SimpleStorageWrongImpl`) of the `ISimpleStorage` interface. The `set` function's signature (accepting `felt252`) differs from the trait's definition (expecting `u128`), which prevents successful compilation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_02_wrong_impl/src/lib.cairo:impl}}\n```\n\n----------------------------------------\n\nTITLE: Using Renamed Struct - Cairo\nDESCRIPTION: Illustrates creating an instance of the struct after it has been processed and renamed by the `#[rename]` attribute macro. The struct must now be referenced and instantiated using its new name, `RenamedType`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_12\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_15_procedural_macro/src/lib.cairo:rename_example}}\n```\n\n----------------------------------------\n\nTITLE: Using custom dictionary methods in Cairo\nDESCRIPTION: Shows an example of using custom get and insert methods with a Felt252Dict. The code demonstrates creating a dictionary, inserting values, and retrieving them with the custom functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() -> felt252 {\n    // Create a dictionary\n    let mut dict: Felt252Dict<felt252> = Default::default();\n\n    // Store a value at key 1 manually using our custom functions\n    custom_insert(ref dict, 1, 42);\n    custom_insert(ref dict, 2, 77);\n\n    let val = custom_get(ref dict, 1);\n    assert(val == 42, 'Incorrect value');\n\n    // Return arbitrary number to satisfy return type\n    val\n}\n```\n\n----------------------------------------\n\nTITLE: Importing All Public Items Using Glob Operator - Rust\nDESCRIPTION: This Rust code snippet utilizes the `use` statement along with the glob operator (`*`) to import all public items from the `core::num::traits` module into the current scope. This makes all public elements defined within the specified module directly accessible without the need to specify them individually. The primary purpose of the snippet is to enable access to all items within the module. Prerequisites include familiarity with Rust's module system and the `use` keyword. There are no parameters in this example.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n```rust\nuse core::num::traits::*;\n```\n```\n\n----------------------------------------\n\nTITLE: Match Option<u8>\nDESCRIPTION: This code snippet demonstrates using a `match` expression with `Option<u8>`. The `plus_one` function takes an `Option<u8>` and adds 1 to the value if it's `Some`. If it's `None`, the function returns `None`. The `match` expression handles both `Some` and `None` cases.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_08_match_option/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Boolean Type in Cairo\nDESCRIPTION: Demonstrates the declaration and usage of the boolean type in Cairo. It shows the use of `true` and `false` literals to assign values to boolean variables. The functionality is to represent a binary state (true or false) which is commonly used in control flow like `if` statements. Dependencies: Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{\n    // Example code demonstrating boolean type declaration\n}\n\n```\n\n----------------------------------------\n\nTITLE: Incorrect nopanic Function Example in Cairo\nDESCRIPTION: Shows an incorrect example of using the nopanic notation where the function might actually panic due to calling assert or using equality operations. This will cause compilation errors.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n#[nopanic]\nfn my_incorrect_nopanic_function(x: felt252, y: felt252) -> bool {\n    assert(x != 0, 'x cannot be 0');\n    x == y\n}\n```\n\n----------------------------------------\n\nTITLE: Module Documentation in Cairo\nDESCRIPTION: This snippet demonstrates module documentation comments in Cairo, using `//!`. These comments are placed above the module they describe and provide an overview of the module's purpose and usage, including usage examples. The `//!` prefix marks the comment as a module-level documentation providing a broader understanding of the module.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_38_mod_doc_comments/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Reading Storage Variables in Starknet Contracts using Cairo\nDESCRIPTION: This snippet shows how to read a storage variable's value in a Cairo contract by using the auto-generated read function. Requires the storage variable to be part of the #[storage] struct; the read function returns the value stored at the appropriate slot. Input parameters depend on the variable type and all necessary context is provided via the Storage struct.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:read_owner}}\n```\n\n----------------------------------------\n\nTITLE: Enabling Sierra Output in Scarb for Cairo Projects (toml)\nDESCRIPTION: This code snippet configures a Cairo project to output Sierra intermediate representation by setting sierra-text = true in the Scarb.toml file. No further dependencies are required. No direct input or output apart from enabling a different build artifact. It is necessary to analyze low-level code behavior corresponding to both loops and recursion.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\nsierra-text = true\n```\n\n----------------------------------------\n\nTITLE: Block Expressions Returning Values in Cairo\nDESCRIPTION: Shows that code blocks enclosed in curly braces can be expressions that evaluate to a value. A block expression can be assigned to a variable. The last expression in the block without a semicolon determines the block's return value. Demonstrates this behavior with a variable `y` assigned the block result `4`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\nfn main() {\n    let x = 3;\n    let y = {\n        let z = x + 1;\n        z + 1  // No semicolon here, making this block evaluate to 4\n    };\n    println!(\"Value of y is {y}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Cairo Program with Scarb\nDESCRIPTION: This snippet shows the command `scarb cairo-run` used to compile and execute a Cairo project. The output displays compilation warnings related to unused variables in the `lib.cairo` file, specifically when concatenating strings using `+` and the `format!` macro. Despite the warnings, the compilation finishes successfully, and the program runs, printing 'tic-tac-toe'.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch12-advanced-features/no_listing_06_format_macro/output.txt#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_06_format_macro v0.1.0 (listings/ch12-advanced-features/no_listing_06_format_macro/Scarb.toml)\nwarn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.\n --> listings/ch12-advanced-features/no_listing_06_format_macro/src/lib.cairo:5:9\n    let s = s1 + \"-\" + s2 + \"-\" + s3;\n        ^\n\nwarn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.\n --> listings/ch12-advanced-features/no_listing_06_format_macro/src/lib.cairo:11:9\n    let s = format!(\"{s1}-{s2}-{s3}\"); // s1, s2, s3 are not consumed by format!\n        ^\n\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_06_format_macro\ntic-tac-toe\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Reading Simple Storage Field in Cairo Sequence Diagram\nDESCRIPTION: Demonstrates the sequence of messages exchanged when a user requests to read a simple storage variable (self.owner.name) in a Cairo smart contract. It involves resolving the base address of the storage variable, creating a pointer, and retrieving the value from contract storage. No additional dependencies beyond the Cairo contract system are needed.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/mermaid-storage-model.txt#_snippet_0\n\nLANGUAGE: sequenceDiagram\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant Compiler\n    participant StorageBase\n    participant StoragePointer\n    participant ContractStorage\n\n    User->>Compiler: self.owner.name.read()\n    Compiler->>StorageBase: Get base address for 'owner'\n    StorageBase->>StoragePointer: Create pointer for 'name'\n    StoragePointer->>ContractStorage: Read value\n    ContractStorage-->>User: Return value\n```\n\n----------------------------------------\n\nTITLE: Compiling and running a Cairo project with Scarab\nDESCRIPTION: A terminal output showing the compilation process of the Cairo project `no_listing_09_snapshots` with Scarab, indicating the target profile, compilation time, and execution status. It also displays runtime output, specifically calculations related to a rectangle's area at different times, and confirms successful completion with no errors.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch04-understanding-ownership/no_listing_09_snapshots/output.txt#_snippet_1\n\nLANGUAGE: Console Output\nCODE:\n```\n   Compiling no_listing_09_snapshots v0.1.0 (listings/ch04-understanding-ownership/no_listing_09_snapshots/Scarb.toml)\n    Finished `dev` profile target(s) in 2 seconds\n     Running no_listing_09_snapshots\nThe area of the rectangle when the snapshot was taken is 30\nThe current area of the rectangle is 50\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Implementing Clone Trait in Cairo\nDESCRIPTION: This code snippet demonstrates how to derive the Clone trait in Cairo for creating deep copies of data structures. It emphasizes that all component fields must also implement Clone. The example illustrates explicit cloning functionality.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_01_clone/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cairo Function With a Single Typed Parameter\nDESCRIPTION: Defines a function named `another_function` with one parameter `x` of type `felt252`. Shows how to pass an argument to this parameter and use it inside a Cairo macro like `println!` for formatted output. Requires understanding of Cairo primitive types and macro usage.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nfn another_function(x: felt252) {\n    println!(\"The value is {x}\");\n}\n\nfn main() {\n    another_function(5);\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying arrays stored in dictionaries in Cairo\nDESCRIPTION: Shows how to append values to an array stored in a dictionary. This function uses entry and finalize to retrieve the array, modify it, and update the dictionary with the modified array.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_12\n\nLANGUAGE: cairo\nCODE:\n```\nfn append_value(ref dict: Felt252Dict<Nullable<Array<felt252>>>, key: felt252, value: felt252) {\n    let (entry, nullable_arr) = dict.entry(key);\n    match match_nullable(nullable_arr) {\n        FromNullableResult::Null(()) => {\n            let mut arr = ArrayTrait::new();\n            arr.append(value);\n            dict = entry.finalize(NullableTrait::new(arr));\n        },\n        FromNullableResult::NotNull(mut arr) => {\n            arr.append(value);\n            dict = entry.finalize(NullableTrait::new(arr));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Circuit Modulus (BN254 Field) - Cairo\nDESCRIPTION: This code defines the modulus to be used by the arithmetic circuit, specifically the BN254 prime field which supports up to 384-bit modulus arithmetic. By instantiating CircuitModulus, the circuit is configured to perform all operations within the selected finite field, which is crucial for cryptographic use-cases.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-arithmetic-circuits.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_10_arithmetic_circuits/src/lib.cairo:modulus}}\n```\n\n----------------------------------------\n\nTITLE: Using Debug Trait for Printing in Cairo\nDESCRIPTION: This code illustrates how to derive and utilize the Debug trait in Cairo to enable formatted debug output with `:?`. It allows inspecting variable states during runtime, essential for debugging and testing.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_03_debug/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Binary Tree using Boxes in Cairo\nDESCRIPTION: This code snippet demonstrates how to define a recursive BinaryTree type in Cairo using Box<T> to store child nodes. By using Box<BinaryTree>, the compiler can determine the size of the BinaryTree type at compile time, resolving the infinite recursion issue.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-02-smart-pointers.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/listing_recursive_types/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Basic Cairo Package Directory Structure\nDESCRIPTION: This snippet shows the directory structure of a newly created Cairo package. It includes the Scarb.toml configuration file and the src directory containing the lib.cairo entry point.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-01-packages-and-crates.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmy_package/\n Scarb.toml\n src\n     lib.cairo\n```\n\n----------------------------------------\n\nTITLE: Dictionary Squashing for Verification in Cairo\nDESCRIPTION: This snippet describes the process of squashing dictionary entries to verify consistency, ensuring that each keys sequential values are coherent. It details how the squash_dict function compares each entrys new_value with the previous_value of the subsequent entry, detecting any illegal modifications. This procedure is vital for proof validation in Cairos STARK system.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Dictionary entry and finalize method signatures in Cairo\nDESCRIPTION: Demonstrates the signature of the entry and finalize methods used for manual dictionary manipulation in Cairo. These methods allow direct access to dictionary entries for custom operations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nfn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic\n```\n\nLANGUAGE: cairo\nCODE:\n```\nfn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T>\n```\n\n----------------------------------------\n\nTITLE: Simulating Dictionary Operations via Entry List in Cairo\nDESCRIPTION: This example illustrates how each insertion creates a new entry with references to prior states for keys 'Alex' and 'Maria', showcasing the list of entries that forms the internal representation. The table demonstrates how multiple updates extend the list, enabling undoing or auditing of changes through the entry sequence.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo:inserts}}\n```\n\n----------------------------------------\n\nTITLE: Replacing Class Starknet Cairo\nDESCRIPTION: This snippet shows the syntax for the `replace_class_syscall` in Cairo. This system call is used to upgrade a contract's implementation by replacing its current class hash with a new one. It takes the new `ClassHash` as input and returns a `SyscallResult<()>`, indicating the success or failure of the replacement.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\npub extern fn replace_class_syscall(\n    class_hash: ClassHash,\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Match\nDESCRIPTION: This code snippet demonstrates a non-exhaustive `match` expression. The `plus_one` function attempts to match on an `Option<u8>` but only handles the `Some` case, omitting the `None` case.  This causes a compilation error because Cairo requires `match` expressions to be exhaustive, covering all possible cases.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Verifying Scarb and Snforge installations\nDESCRIPTION: Commands to check the installed versions of Scarb (Cairo's package manager) and Snforge (Starknet Foundry's testing tool) to confirm successful installation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-01-installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb --version\nscarb 2.11.4 (c0ef5ec6a 2025-04-09)\ncairo: 2.11.4 (https://crates.io/crates/cairo-lang-compiler/2.11.4)\nsierra: 1.7.0\n\n$ snforge --version\nsnforge 0.39.0\n```\n\n----------------------------------------\n\nTITLE: Compiler Error Output for Invalid Statement Assignment (Shell)\nDESCRIPTION: Console error output indicating the invalid attempt to assign a let statement's result to another variable, illustrating Cairo compiler's enforcement of no return value from statements.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nerror: cannot assign let statement to variable\n  --> src/lib.cairo:3:13\n   |\n3  |     let x = (let y = 6);\n   |             ^^^^^^^^^^\n   |\nnote: let statements do not produce a value\n```\n\n----------------------------------------\n\nTITLE: Creating a new Scarb project\nDESCRIPTION: These commands create a new Scarb project named 'prime_prover' and navigates into the project directory. Scarb is used as the build system and package manager for Cairo projects.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscarb new prime_prover\ncd prime_prover\n```\n\n----------------------------------------\n\nTITLE: Using `scarb fmt` for Cairo Code Formatting\nDESCRIPTION: Provides instructions on formatting Cairo projects with `scarb fmt`, including how to invoke it within a project directory. It emphasizes consistent code style across teams and projects.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-06-useful-development-tools.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nscarb fmt\n```\n\n----------------------------------------\n\nTITLE: Sample Output from Array Iteration Example (shell)\nDESCRIPTION: This snippet shows the terminal output produced by iterating through all elements of an array using a while loop in Cairo. It is intended to help users verify correct code behavior. No dependencies. Input is the code execution; output is text lines with array values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program with Scarb\nDESCRIPTION: This command compiles and executes a Cairo program using Scarb. Scarb is a build system for Cairo projects. The command `scarb cairo-run` compiles the project defined in the Scarb.toml file, generates the necessary artifacts, and then runs the compiled Cairo code.  The output shows the values of a variable `x` in different scopes demonstrating variable shadowing. The output includes the compilation process, execution results and the return value.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_03_shadowing/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_03_shadowing\nInner scope x value is: 12\nOuter scope x value is: 6\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Testing can_hold Method with assert! Macro in Cairo\nDESCRIPTION: This snippet demonstrates testing the `can_hold` method of a `Rectangle` struct using the `assert!` macro. The `can_hold` method's boolean return value is checked against the expected outcome. Prerequisites include defining the `Rectangle` struct and the `can_hold` method. The expected output is `true` if the assertion is successful and the test passes. It uses a simple struct definition and its method.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_7\n\nLANGUAGE: cairo\nCODE:\n```\n// in src/lib.cairo\n#[derive(Drop, PartialEq, Debug)]\nstruct Rectangle {\n    width: felt252,\n    height: felt252,\n}\n\nimpl Rectangle {\n    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {\n        self.width >= other.width && self.height >= other.height\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle { width: 8, height: 7 };\n        let smaller = Rectangle { width: 5, height: 1 };\n        assert!(larger.can_hold(@smaller));\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending a Message from Ethereum to Starknet via Solidity Contract\nDESCRIPTION: This Solidity function illustrates how to send a cross-chain message from an Ethereum smart contract to Starknet by invoking `sendMessageToL2` on the `StarknetMessaging` contract. It serializes a `felt` value into an array, sets the necessary call parameters including the target contract address and selector, and ensures the message fee (minimum 20,000 wei) is covered. The function is designed for developers implementing cross-chain communication logic and highlights the importance of proper serialization and fee handling.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-04-L1-L2-messaging.md#_snippet_1\n\nLANGUAGE: Solidity\nCODE:\n```\nfunction sendMessageFelt(\n    uint256 contractAddress,\n    uint256 selector,\n    uint256 myFelt\n)\n    external\n    payable\n{\n    // Serialize felt into payload array\n    uint256[] memory payload = new uint256[](1);\n    payload[0] = myFelt;\n\n    // Call StarknetMessaging to send message, ensuring minimum fee\n    _snMessaging.sendMessageToL2{value: msg.value}(\n        contractAddress,\n        selector,\n        payload\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Bitwise AND, XOR, OR Using Cairo Bitwise Builtin - Cairo\nDESCRIPTION: This Cairo function demonstrates usage of the Bitwise Builtin to perform bitwise AND, XOR, and OR operations on two input field elements x and y. It requires the BitwiseBuiltin imported from starkware.cairo.common.cairo_builtins, which provides a pointer to the builtin's dedicated memory segment where inputs and outputs are stored in a defined 5-cell block. The function asserts the inputs at offsets 0 and 1, reads outputs from offsets 2, 3, and 4 respectively, and increments the pointer by 5 for the next operation. Inputs are two felt values representing the operands, and the function returns a tuple with the three bitwise results. This leverages the VM's native support for efficient bitwise computation with builtins.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch204-02-04-bitwise.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfrom starkware.cairo.common.cairo_builtins import BitwiseBuiltin\n\nfunc bitwise_ops{bitwise_ptr: BitwiseBuiltin*}(x: felt, y: felt) -> (and: felt, xor: felt, or: felt) {\n    assert [bitwise_ptr] = x;        // Input x\n    assert [bitwise_ptr + 1] = y;    // Input y\n    let and = [bitwise_ptr + 2];     // x & y\n    let xor = [bitwise_ptr + 3];     // x ^ y\n    let or = [bitwise_ptr + 4];      // x | y\n    let bitwise_ptr = bitwise_ptr + 5;\n    return (and, xor, or);\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Variable with If Expression in a Let Statement in Cairo\nDESCRIPTION: This snippet leverages Cairo's ability to treat if as an expression, using it on the right side of a let statement. The result of the if-else block is assigned as the value of a variable. This enables concise conditional assignment. Outputs the resulting variable value after evaluating the condition.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_31_if_let/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Build WASM-bindgen Toolkit with Modules\nDESCRIPTION: This command uses `wasm-pack` to build the WASM-Cairo toolkit with modules.  It specifies the release profile, target as `web`, output directory, and output name. The `wasm-pack` tool builds WebAssembly packages from Rust crates.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack build --release --target web --out-dir output/module/pkg --out-name wasm-cairo\n```\n\n----------------------------------------\n\nTITLE: Using nopanic Notation in Cairo Functions\nDESCRIPTION: Demonstrates how to mark a function with nopanic notation to indicate it will never panic. Only nopanic functions can be called within a function annotated as nopanic.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n#[inline(always)]\nfn do_not_panic() -> felt252 {\n    42\n}\n\n#[inline(always)]\n#[nopanic]\nfn my_nopanic_function() -> felt252 {\n    do_not_panic()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom get method for dictionaries in Cairo\nDESCRIPTION: Shows how to implement a custom get method for dictionaries using entry and finalize. The function creates an entry, retrieves the current value, and finalizes it with the same value to preserve the dictionary state.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_6\n\nLANGUAGE: cairo\nCODE:\n```\nfn custom_get<T, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(ref dict: Felt252Dict<T>, key: felt252) -> T {\n    let (entry, value) = dict.entry(key);\n    dict = entry.finalize(value);\n    value\n}\n```\n\n----------------------------------------\n\nTITLE: Pack WASM-bindgen Toolkit with Modules\nDESCRIPTION: This command packs the output of the module build using `wasm-pack`. It prepares the module for publishing. This command should be executed after the build command for the 'with modules' target has completed.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack pack output/module\n```\n\n----------------------------------------\n\nTITLE: Extending Generic Struct `Wallet<U>` with an Address Field in Cairo\nDESCRIPTION: This snippet shows how to add another generic type parameter `U` to `Wallet<T>` to include a new `address` field of type `U`. This approach enables flexible struct definitions where each field can have a different, yet generic, data type, with trait bounds like `Drop` applying to all type parameters.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch08-generic-types-and-traits/no_listing_08_two_generics/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy Trait in Cairo\nDESCRIPTION: This snippet shows how to derive the Copy trait in Cairo, enabling simple duplication of values where all parts are also Copy. It is useful for types that can be duplicated trivially without resource concerns.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-03-derivable-traits.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/appendix/listing_02_copy/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Struct Instance without Update Syntax\nDESCRIPTION: This code demonstrates how to create a new `User` instance manually, reusing existing values from `user1` and changing only specific fields like `email`. It shows explicit field assignment without using update syntax.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch05-01-defining-and-instantiating-structs.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing_without_update_syntax/src/lib.cairo:here}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo project using Scarab with deprecation warning\nDESCRIPTION: A command-line instruction to execute a Cairo project using Scarab, with a warning about deprecation and an alternative recommended command. It indicates the start of a project run and shows a compilation message, including profile target completion time, followed by runtime output of snapshot data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch04-understanding-ownership/no_listing_09_snapshots/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb cairo-run \nwarn: `scarb cairo-run` will be deprecated soon\nhelp: use `scarb execute` instead\n```\n\n----------------------------------------\n\nTITLE: Creating a Binary Tree Node with Recursive Children in Cairo\nDESCRIPTION: This snippet constructs a 'Node' variant of the 'BinaryTree', with a tuple containing an integer and two child trees ('leaf2' and 'leaf3'). It models a recursive binary tree node with left and right subtrees, which are intended to be 'BinaryTree' instances. The code is part of a recursive tree construction but triggers errors due to the infinite size of recursive types in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch12-advanced-features/listing_recursive_types_wrong/output.txt#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nlet node = BinaryTree::Node((4, leaf2, leaf3));\n```\n\n----------------------------------------\n\nTITLE: Testing Private Functions through Child Modules in Cairo\nDESCRIPTION: This example illustrates testing a private (non-pub) function in Cairo using a child-module test. It accesses the parent modules internal_adder via use super::internal_adder inside the #[cfg(test)] module. The setup requires Cairo and Scarb, with the private function defined in the same file as its tests. Tests call private functions directly if present in an ancestor module, supporting granular verification of implementation details otherwise hidden to external consumers. Expected inputs and outputs match the functions interface; no additional permissions are required.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/no_listing_11_test_private_function/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Initializing Array with Repeated Values in Cairo\nDESCRIPTION: This example shows how to initialize a fixed-size array with a specific value repeated for each element. It provides a concise way to create an array with identical initial values.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_10\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_41_fixed_size_arr_months/src/lib.cairo:repeated_values}}\n```\n\n----------------------------------------\n\nTITLE: Adding Multi-Line Comments in Cairo\nDESCRIPTION: This snippet shows how to write multi-line comments in Cairo using `//` at the beginning of each line. This is essential for providing more detailed explanations that span multiple lines. Each line within the comment block is preceded by `//` and used to explain more complex or longer code segments.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-04-comments.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n// So we're doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what's going on.\n```\n\n----------------------------------------\n\nTITLE: Executing the Cairo Program with Scarb and u128 input\nDESCRIPTION: This command executes the 'prime_prover' package using Scarb. It passes the number 1000001 as an argument to trigger a panic. No proof can be generated from a panicked execution.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n{{#include ../listings/ch01-getting-started/prime_prover2/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Constrained Generic Method `receive` in Cairo\nDESCRIPTION: Defines a trait implementation specifically for `Wallet<u128>`. The `receive` method is implemented for this constrained type, allowing it to modify the `balance` field, which must be `u128`. The `main` function demonstrates calling this method on a mutable `Wallet<u128>` instance.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\nuse traits::TryInto;\nuse zeroable::Zeroable;\n\n#[derive(Drop, Copy)]\nstruct Wallet<T> {\n    balance: T\n}\n\ntrait WalletTrait {\n    fn receive(ref self: Wallet<u128>, amount: u128);\n}\n\nimpl WalletU128Impl of WalletTrait {\n    fn receive(ref self: Wallet<u128>, amount: u128) {\n        self.balance += amount;\n    }\n}\n\nfn main() {\n    let mut w = Wallet { balance: 10_u128 };\n    w.receive(5_u128);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Test Runner Execution Output for Successful Test - Shell\nDESCRIPTION: Displays the typical output from the 'scarb test' command when running a passing test in Cairo using Starknet Foundry as the runner. No dependencies required; output summarizes tests found, run, passed, failed, and includes gas estimation for passing tests.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 1 test(s) from adder package\nRunning 1 test(s) from src/\nadder::tests::it_works ... [PASS] (gas: ~1)\n\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Program with Scarb CLI\nDESCRIPTION: This snippet demonstrates how to run a Cairo program using the Scarb CLI. It first compiles the project using `scarb`, and then executes the compiled program. The output shows the value returned by the program. No specific dependencies are shown but Scarb toolchain is expected to be setup. The command `scarb cairo-run` initiates this process, compiling the project, and subsequently executing the compiled cairo program. The output reveals the program's result: \"The value of x is: 5\". This approach assumes a configured Scarb project structure with a `Scarb.toml` file and a Cairo source file.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_16_single_param/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_16_single_param\nThe value of x is: 5\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Writing Unit Tests with #[cfg(test)] in Cairo\nDESCRIPTION: This snippet demonstrates how to define a unit test inside a tests module using the #[cfg(test)] attribute in Cairo. Dependencies include a functioning Cairo development environment and Scarb, the Cairo package manager. The snippet places test code alongside implementation code in the src directory. Key annotations and module imports ensure only test builds compile the test code, preventing test logic from being included in production artifacts. Inputs are typically function parameters under test; outputs are assertions or test results.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-02-test-organization.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch10-testing-cairo-programs/listing_10_01/src/lib.cairo:it_works}}\n```\n\n----------------------------------------\n\nTITLE: Running a Cairo Project with Scarb (Shell)\nDESCRIPTION: This snippet shows the command 'scarb cairo-run' used to compile and execute a Cairo project named 'no_listing_15_functions'. The output displays the compilation steps, the program's standard output ('Hello, world!' and 'Another function.'), and a success confirmation. This command requires Scarb and a valid Cairo project structure.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_15_functions/output.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_15_functions\nHello, world!\nAnother function.\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Enforcing Type Equality for Associated Types in Cairo State Machines\nDESCRIPTION: This code uses TypeEqual within a trait bound to ensure that two types, both implementing the StateMachine trait with associated type State, can interact only when their states are the same type. The combine function is gated by the bound TypeEqual<A::State, B::State>. Required dependencies include a working implementation of StateMachine, State, and the TypeEqual trait from core::metaprogramming. This pattern enforces type-safe interoperability between generics with matching associated types.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_14\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch08-generic-types-and-traits/no_listing_20_type_equal/src/state_machine.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Deriving and Using the Drop Trait in Cairo\nDESCRIPTION: This example shows how to fix the previous compile error by deriving the `Drop` trait for the struct `A`. Deriving `Drop` tells the compiler that the type can be safely 'dropped' (automatically destroyed with no side effects) when it goes out of scope, satisfying the linear type system requirement.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Drop)]\nstruct A {\n    x: usize,\n}\n\nfn main() {\n    let a = A { x: 1 };\n    // a goes out of scope here and is automatically dropped\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display for Custom Types in Cairo\nDESCRIPTION: Demonstrates how to implement the Display trait for a custom struct (e.g., Point) to enable formatted printing using print! and println!. The implementation must provide a fmt method that writes to the Formatter. This allows custom data types to be presented in a user-friendly format, handling field presentation as needed. The code requires the trait definition and all fields used in formatting to implement Display.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-08-printing.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_09_display_trait_with_format/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Running Cairo Tests with Scarb\nDESCRIPTION: This snippet demonstrates the execution of tests for a Cairo project using the Scarb build tool. It triggers the test suite, showing compilation progress, test results, and gas consumption. Dependencies include Scarb and a Cairo project with defined tests.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch10-testing-cairo-programs/no_listing_07_benchmark_gas/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb test\n```\n\n----------------------------------------\n\nTITLE: Implementing an Infinite Loop Using loop and break in Cairo (cairo)\nDESCRIPTION: This snippet contains a Cairo program using the loop keyword to create an infinite loop, with a break statement to exit when a certain condition is satisfied. No additional dependencies are needed. Input is usually an initial variable; output occurs when the loop breaks and prints a value. The snippet is used to illustrate how loop control structures function before transitioning to recursion examples.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_14\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/loop_example.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Destructuring a Tuple in Cairo\nDESCRIPTION: This snippet showcases declaring a tuple with values and types and simultaneously destructuring it into individual variables. This combines tuple creation and destructuring in a single operation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_14_tuple_types/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Run Cairo Program using wasmtime_test.sh\nDESCRIPTION: This command runs a Cairo program using the `wasmtime_test.sh` script.  It takes a Cairo file (`.cairo`) as input and assumes the program has been compiled. The script likely executes the compiled Cairo program.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./wasmtime_test.sh runCairoProgram ./cairo_files/HelloStarknetAstro.cairo\n```\n\n----------------------------------------\n\nTITLE: Defining a Nested Module for Restaurant Front of House\nDESCRIPTION: Defines a nested module 'front_of_house' with inner modules 'hosting' and 'serving' within a crate 'restaurant'. Illustrates how modules are nested using curly brackets and how they represent organizational hierarchy for frontend restaurant functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-02-defining-modules-to-control-scope.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_01_basic_nested_modules/src/lib.cairo:front_of_house}}\n```\n\n----------------------------------------\n\nTITLE: Executing Cairo Program with Scarb\nDESCRIPTION: This snippet shows the command used to run a Cairo program using Scarb. It involves compiling the program and then executing it. The output of the program, including the returned value is displayed.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_22_function_return_values/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_20_function_return_values\nThe value of x is: 5\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Defining a Cairo Function with Multiple Typed Parameters\nDESCRIPTION: Defines a function `print_labeled_measurement` which takes two parameters: `value` of type `u128` and `unit_label` of type `ByteArray` (used for string literals in Cairo). Demonstrates how to print both parameters formatted as a labeled measurement string. This snippet requires Cairo's string handling capabilities.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\nfn print_labeled_measurement(value: u128, unit_label: ByteArray) {\n    println!(\"Value: {value}, Unit: {unit_label}\");\n}\n\nfn main() {\n    print_labeled_measurement(5, b\"h\");\n}\n```\n\n----------------------------------------\n\nTITLE: Run Tests using wasmtime_test.sh\nDESCRIPTION: This command executes tests defined within a Cairo file using `wasmtime_test.sh`. It accepts a Cairo file (`.cairo`) as input, presumably containing test cases.  It runs the tests and reports the results.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./wasmtime_test.sh runTests ./cairo_files/Test.cairo\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Members in Storage Variables in Cairo\nDESCRIPTION: This example demonstrates how to read or write specific members of a struct stored in contract storage by utilizing the member's read and write functions. Accessing members individually optimizes storage operations by targeting only the relevant fields in persistent storage. Requires each member type to implement Store.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_simple_storage/src/lib.cairo:read_owner_name}}\n```\n\n----------------------------------------\n\nTITLE: Instantiation of Leaf Node in Cairo\nDESCRIPTION: This snippet shows creating a 'Leaf' node of the 'BinaryTree' with a specific integer value. It requires the 'BinaryTree' enum to be defined and demonstrates basic construction of a leaf node, which should be a leaf containing the value 1. The snippet is part of the process to build a binary tree but is commented by errors due to recursive size issues.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch12-advanced-features/listing_recursive_types_wrong/output.txt#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nlet leaf1 = BinaryTree::Leaf(1);\n```\n\n----------------------------------------\n\nTITLE: Underlying Entry List Structure for Felt252Dict<T>\nDESCRIPTION: This snippet defines the Entry<T> structure used internally to implement Felt252Dict<T> as a list of entries, each containing a key, previous_value, and new_value. It highlights how each interaction with the dictionary creates a new entry, modeling immutability and enabling historical tracking of modifications.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch03-02-dictionaries.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch03-common-collections/no_listing_11_entries/src/lib.cairo:struct}}\n```\n\n----------------------------------------\n\nTITLE: Declaring Short Strings in Cairo\nDESCRIPTION: This code snippet provides examples on declaring and using short strings in Cairo. It shows how to declare short strings using the single-quote syntax and using hexadecimal representation. The short strings are represented by the `felt252` type, limited to 31 ASCII characters (31*8 = 248 bits). Dependencies: Cairo core library.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-02-data-types.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{\n    // Example code demonstrating short string declaration\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sierra Statements of 'main' Function Demonstrating Inlined and Non-Inlined Calls\nDESCRIPTION: Details the Sierra code fragments comprising the 'main' function for the inlining example. It includes the invocation of a non-inlined function via 'function_call' libfunc and local instructions for constant creation and addition. This snippet clarifies the handling of variable IDs in inline versus non-inline scenarios, stores temporary values, and performs arithmetic operations, emphasizing the overhead differences between inlined and non-inlined calls.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n00 function_call<user@main::main::not_inlined>() -> ([0])\n01 felt252_const<1>() -> ([1])\n02 store_temp<felt252>([1]) -> ([1])\n03 felt252_add([1], [0]) -> ([2])\n04 store_temp<felt252>([2]) -> ([2])\n05 return([2])\n```\n\n----------------------------------------\n\nTITLE: Cairo Code Triggering Visibility Errors\nDESCRIPTION: Cairo code lines identified by the compiler (within `lib.cairo`) as causing visibility errors. These lines attempt to access the potentially non-public `hosting` module and `add_to_waitlist` function using both absolute (`crate::`) and relative paths, leading to compilation failure as shown in the error messages.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch07-managing-cairo-projects-with-packages-crates-and-modules/listing_02_paths/output.txt#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\ncrate::front_of_house::hosting::add_to_waitlist();\n```\n\nLANGUAGE: Cairo\nCODE:\n```\nfront_of_house::hosting::add_to_waitlist();\n```\n\n----------------------------------------\n\nTITLE: Using Absolute and Relative Paths in Cairo\nDESCRIPTION: Demonstrates how to call the add_to_waitlist function using both absolute and relative paths. The code won't compile yet because the modules and functions are private by default.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Constant Expressions with `consteval_int!` in Cairo\nDESCRIPTION: Demonstrates the use of the `consteval_int!` macro in Cairo to compute an integer expression (2 * 2 * 2) at compile time and assign the result (8) to a constant `a` of type `felt252`. This macro is necessary when declaring constants whose values depend on computations.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-05-macros.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nconst a: felt252 = consteval_int!(2 * 2 * 2);\n```\n\n----------------------------------------\n\nTITLE: Compile Starknet Contract using wasmtime_test.sh\nDESCRIPTION: This command uses the `wasmtime_test.sh` script to compile a Starknet contract.  It takes a Cairo file (`.cairo`) and a JSON file (`.json`) as input, likely representing the contract definition. The compiled artifact is likely a Sierra file or a similar intermediate representation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./wasmtime_test.sh compileStarknetContract ./cairo_files/storage.cairo ./cairo_files/storage.json\n```\n\n----------------------------------------\n\nTITLE: Creating a Cairo Project Structure Using Scarb - Shell\nDESCRIPTION: Demonstrates the filesystem hierarchy created when initializing a new Cairo project with Scarb using the 'scarb new adder' command. This structure includes the manifest file (Scarb.toml) and source folder (src/lib.cairo). There are no required dependencies other than Scarb itself. No parameters required; output is the folder structure for new Cairo projects.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch10-01-how-to-write-tests.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nadder\n Scarb.toml\n src\n     lib.cairo\n```\n\n----------------------------------------\n\nTITLE: Defining a Complete NameRegistry Contract in Cairo\nDESCRIPTION: Provides the full source code for a reference `NameRegistry` contract used throughout the chapter. This contract likely includes storage definitions, events, structs, a constructor, and various types of public and private functions to illustrate different concepts.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:all}}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Immutable Variables in Cairo\nDESCRIPTION: An example showing how Cairo enforces immutability by default. This code fails to compile because it attempts to change the value of an immutable variable x.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-01-variables-and-mutability.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n// This code will not compile\nfn main() {\n    let x = 5;\n    println!(\"The value of x is: {x}\");\n    x = 6;\n    println!(\"The value of x is: {x}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Including Embeddable Implementation Example\nDESCRIPTION: This snippet includes a Cairo file showcasing an embeddable implementation. It demonstrates how an interface trait can be made embeddable, adding new entry points and modifying the contract's ABI.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/no_listing_01_embeddable/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Casting a Vote and Accessing a Map Within a Storage Node in Cairo\nDESCRIPTION: This snippet accesses a specific `ProposalNode` storage node for a given proposal ID and manipulates its internal `voters` map. It first checks if a caller address has already voted by reading from the map, and if not, writes to the map to record the vote. This showcases conditional reads and writes on map structures embedded inside storage nodes, enforcing voting constraints. Prerequisites include familiarity with storage nodes, maps, and contract caller identity.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-01-00-contract-storage.md#_snippet_8\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_storage_node/src/lib.cairo:vote}}\n```\n\n----------------------------------------\n\nTITLE: Matching `felt252` Integer Variables with Sequential Arms in Cairo\nDESCRIPTION: Demonstrates matching of `felt252` integer variables with the constraints that the first arm must start at 0 and subsequent arms cover contiguous integer segments. This example models a game where rolling a six-sided die (values 0 to 5) results in winning for rolls 0 to 2, re-rolling for 3, and losing otherwise. It requires care to ensure all arms cover the full range without gaps or overlaps, and only single `felt252` integers (no large unsigned integers) are supported.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch06-02-the-match-control-flow-construct.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\nfunc roll_result(roll: felt252) -> (result: felt252) {\n    match roll {\n        0 | 1 | 2 => return (1),  // Win\n        3 => return (2),          // Roll again\n        _ => return (0),          // Lose\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing embeddable_as generated\nDESCRIPTION: This snippet shows the result generated by the compiler because of the `embeddable_as(Ownable)` annotation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/no_listing_02_embeddable_as_output/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Full Implementation of MemoryVec Trait for Dynamic Arrays - Cairo\nDESCRIPTION: Implements all trait methods for MemoryVec, including push, get, set, and len, providing a fully functional mutable array abstraction. The methods internally manipulate the Felt252Dict and the length field, handling nullable value types as needed. The snippet assumes that prerequisite traits and struct definitions are available, and illustrates how mutable collections can be composed in Cairo using dictionaries.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_9\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:implem}}\n```\n\n----------------------------------------\n\nTITLE: Building and Running Cairo Project with Scarb\nDESCRIPTION: This snippet shows the use of the Scarb build tool to compile and execute a Cairo project named 'no_listing_17_multiple_params'. It compiles the project in development mode, runs the program, and reports the measurement and success status. Dependencies include the Scarb tool and the project files located in the specified directory. No input parameters are required for the run command, and the output indicates the execution status and measurement.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_17_multiple_params/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)\n    Finished `dev` profile target(s) in 5 seconds\n     Running no_listing_17_multiple_params\nThe measurement is: 5h\nRun completed successfully, returning []\n```\n\n----------------------------------------\n\nTITLE: Adding Optional Type Annotations to Cairo Closures\nDESCRIPTION: Illustrates how to explicitly annotate parameter and return types in closures, making closures syntactically closer to functions. Includes a comparison of a named function and several closure definitions with varying levels of type annotation and syntactic sugar. This example clarifies that annotations improve readability but that type inference by the compiler can often be relied upon to reduce verbosity.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch11-01-closures.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch11-functional-features/listing_closure_type/src/lib.cairo:here}}\n```\n\nLANGUAGE: cairo\nCODE:\n```\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n```\n\n----------------------------------------\n\nTITLE: Get Transaction Details with Starkli\nDESCRIPTION: This snippet demonstrates how to retrieve details of a Starknet transaction using the `starkli transaction` command. It takes the transaction hash as input and queries the specified RPC endpoint. The output is a JSON object containing information about the transaction, such as its hash, fee, signature, nonce, and calldata.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nstarkli transaction <TRANSACTION_HASH> --rpc http://0.0.0.0:5050\n```\n\n----------------------------------------\n\nTITLE: Manually Implementing Destruct for UserDatabase to Support Generic Types - Cairo\nDESCRIPTION: This snippet demonstrates a manual implementation of the Destruct trait for UserDatabase<T> to ensure proper cleanup, since generic types and Felt252Dict fields prevent auto-derivation. The implementation correctly frees resources during scope exit, which is essential for memory safety in types containing dictionaries. All generic parameters must fulfill Destruct and related traits for safe destruction.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/no_listing_12_dict_struct_member/src/lib.cairo:destruct}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cairo Function with Parameter and Return Value\nDESCRIPTION: Defines a Cairo function `plus_one` that accepts one argument `x` of type `u32` and returns a `u32`. The function body implicitly returns the result of the expression `x + 1`.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_14\n\nLANGUAGE: cairo\nCODE:\n```\n// Assuming content from ../listings/ch02-common-programming-concepts/no_listing_23_function_return_values_2/src/lib.cairo\nfn main() {\n    let x = plus_one(5);\n    println!(\"The value of x is: {}\", x);\n}\n\nfn plus_one(x: u32) -> u32 {\n    x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Smart Wallet Class Hash\nDESCRIPTION: Command to retrieve the class hash of a smart wallet at a given address using Starkli and the Katana RPC endpoint.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nstarkli class-hash-at <SMART_WALLET_ADDRESS> --rpc http://0.0.0.0:5050\n```\n\n----------------------------------------\n\nTITLE: Example Scarb.toml Configuration for Cairo Package\nDESCRIPTION: This snippet shows a basic Scarb.toml configuration file for a Cairo package. It includes metadata like name, version, edition, and a commented out example of how to specify dependencies.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-01-packages-and-crates.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"my_package\"\nversion = \"0.1.0\"\nedition = \"2024_07\"\n\n[dependencies]\n# foo = { path = \"vendor/foo\" }\n```\n\n----------------------------------------\n\nTITLE: Hashing with Pedersen in Cairo\nDESCRIPTION: This snippet is a short example of Pedersen hashing. It showcases how to compute a hash using the Pedersen function within a Cairo program. The code likely demonstrates initializing the hash with a base state (felt252 type), updating it with input data, and finalizing the hash to obtain the final felt252 hash value. It highlights a different approach to hashing compared to Poseidon, as Pedersen uses a base state.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-04-hash.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_04_hash_pedersen/src/lib.cairo:main}}\n```\n\n----------------------------------------\n\nTITLE: Compiling Cairo Project with Scarb\nDESCRIPTION: This snippet shows the command used to compile and run a Cairo project using Scarb, a package manager and build tool for Cairo. It attempts to compile the project 'no_listing_15_dict_of_array_attempt_get'. The command `scarb cairo-run` is used. The output indicates the compilation process, including any errors encountered. The expected output is the successful compilation of the Cairo code, or the compilation and execution of the code depending on the sub-command. However, in this case, the compilation fails.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb cairo-run \n```\n\n----------------------------------------\n\nTITLE: Implementing Destruct for MemoryVec with Nullable Dictionaries - Cairo\nDESCRIPTION: Contains a manual Destruct trait implementation for MemoryVec<T>, needed to safely destroy instances containing Felt252Dict and generic Nullable-wrapped types. By handling the custom destruction logic, this snippet ensures all heap memory and dictionary values are released, preventing memory leaks when the vector goes out of scope.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-01-custom-data-structures.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_13_cust_struct_vect/src/lib.cairo:destruct}}\n```\n\n----------------------------------------\n\nTITLE: Calling Methods via Deref Coercion in Cairo\nDESCRIPTION: This snippet illustrates how methods defined on the target type can be called directly on the source type instance by leveraging deref coercion. The example demonstrates dereferencing MySource to MyTarget and invoking the method foo directly.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-09-deref-coercion.md#_snippet_7\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_09_deref_fn_arg/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Implementing an IERC20 Library Dispatcher in Cairo\nDESCRIPTION: Defines the `IERC20LibraryDispatcher` struct and its associated trait `IERC20DispatcherTrait` for making library calls to an IERC20 class. It utilizes the `library_call_syscall` system call internally to execute the logic of the target class within the caller's context, updating the caller's state. This pattern requires the corresponding interface (e.g., `IERC20`) to be defined.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch102-03-executing-code-from-another-class.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch102-starknet-cross-contract-interactions/listing_04_expanded_ierc20_library/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Cairo Function Returning a Value\nDESCRIPTION: This snippet showcases a basic Cairo function named `five` which takes no arguments and returns a `u32` value. The return type is declared using `-> u32`. The function body consists solely of the expression `5`, which is implicitly returned.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_11\n\nLANGUAGE: cairo\nCODE:\n```\n// Assuming content from ../listings/ch02-common-programming-concepts/no_listing_22_function_return_values/src/lib.cairo\n\nfn main() {\n    let x = five();\n    println!(\"The value of x is: {}\", x);\n}\n\nfn five() -> u32 {\n    5\n}\n```\n\n----------------------------------------\n\nTITLE: Running `scarb prove` to Generate a Proof\nDESCRIPTION: Executes the Scarb command to generate a STARK proof for the 'prime_prover' package. The `--execution-id 1` flag assigns a specific ID to this execution instance. The output shows the start of the proving process, a warning regarding the prover's current soundness status, and the final location where the generated proof file is saved.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch01-getting-started/prime_prover/output_prove.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb prove --execution-id 1\n     Proving prime_prover\nwarn: soundness of proof is not yet guaranteed by Stwo, use at your own risk\nSaving proof to: target/execute/prime_prover/execution1/proof/proof.json\n```\n\n----------------------------------------\n\nTITLE: Using Impl Aliases to Instantiate Generic Impls in Cairo\nDESCRIPTION: This code demonstrates using impl aliases in Cairo to instantiate generic implementations with concrete types.  It defines a trait `Two` and a generic implementation for types that implement `One`, then uses aliases to expose the implementation only for `u8` and `u128`, keeping the generic implementation private.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-02-traits-in-cairo.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\ntrait One {\n    fn one() -> felt252;\n}\n\nimpl OneU8 of One<u8> {\n    fn one() -> u8 { 1 }\n}\n\nimpl OneU128 of One<u128> {\n    fn one() -> u128 { 1 }\n}\n\n\nmod internal {\n    use super::One;\n\n    trait Two<T> {\n        fn two() -> T;\n    }\n\n    impl<T, impl OneT of One<T>> TwoImpl of Two<T> {\n        fn two() -> T {\n            One::one() + One::one()\n        }\n    }\n\n}\n\nuse internal::Two;\n\nimpl TwoU8 of Two<u8> = internal::TwoImpl<u8>;\nimpl TwoU128 of Two<u128> = internal::TwoImpl<u128>;\n\nfn main() {\n    assert(Two::two::<u8>() == 2, 'wrong u8');\n    assert(Two::two::<u128>() == 2, 'wrong u128');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Branching with If Expressions in Cairo\nDESCRIPTION: This snippet shows how to use an if expression in Cairo to execute code depending on whether a condition is true. The code checks if the variable number is equal to 5 and prints a message based on the result, with optional else handling for the false branch. Requires defining a bool and outputs conditional text to the console.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_27_if/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Executing the Cairo Program with Scarb\nDESCRIPTION: This command executes the 'prime_prover' package using Scarb. It passes the number 17 as an argument and prints the program's output to the console.  The output indicates success and the result of the primality check.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nscarb execute -p prime_prover --print-program-output --arguments 17\n```\n\n----------------------------------------\n\nTITLE: Scarb Execution Output with Program Panic (Log)\nDESCRIPTION: Displays the console output generated by the `scarb cairo-run` command. It includes messages about project compilation status, the time taken, the running of the program, and the specific panic message with its arguments if the program terminates abnormally via a panic.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch09-error-handling/no_listing_01_panic/output.txt#_snippet_1\n\nLANGUAGE: Log\nCODE:\n```\n   Compiling no_listing_01_panic v0.1.0 (listings/ch09-error-handling/no_listing_01_panic/Scarb.toml)\n    Finished `dev` profile target(s) in 4 seconds\n     Running no_listing_01_panic\nRun panicked with [2, ].\n```\n\n----------------------------------------\n\nTITLE: Inlining Example Using Cairo Programming Language\nDESCRIPTION: Demonstrates a simple Cairo program where two functions return constant values, with one function annotated for inlining and the other not. The example illustrates how the inline attribute impacts the generated Cairo code by comparing inlined and non-inlined function behavior and shows how return values are combined.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/listing_03_inlining_example/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Emitting Events in Cairo Smart Contracts Using self.emit()\nDESCRIPTION: Illustrates how to emit the previously defined events within smart contract functions by calling self.emit() passing an event data instance. This snippet provides an example of usage, linking event definition with runtime emission, essential for recording contract state changes for external observers and tooling.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-03-contract-events.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_events_example/src/lib.cairo:emit_event}}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Variable with a Literal Value in Cairo\nDESCRIPTION: Illustrates the equivalent Cairo code for initializing a variable `x` directly with the literal value `5`. This is shown to be functionally the same as initializing `x` with the return value of the `five()` function.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_13\n\nLANGUAGE: cairo\nCODE:\n```\nlet x = 5;\n```\n\n----------------------------------------\n\nTITLE: Interface Definition of Ownable Component in Cairo\nDESCRIPTION: This snippet defines the external interface for the Ownable component, specifying the methods accessible for managing ownership within embedded contracts. It utilizes the `#[starknet::interface]` attribute to declare the interface structure, ensuring a clear contract for external interactions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-00-composability-and-components.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:interface}}\n```\n\n----------------------------------------\n\nTITLE: Using panic_with Attribute in Cairo\nDESCRIPTION: Demonstrates the panic_with attribute which creates a wrapper function that panics if the original function returns None or Err. It takes two arguments: panic data and wrapper function name.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\nuse core::option::OptionTrait;\n\n#[panic_with('Invalid division', division_unwrap)]\nfn divide(dividend: u32, divisor: u32) -> Option<u32> {\n    if divisor == 0 {\n        return Option::None;\n    }\n    Option::Some(dividend / divisor)\n}\n\nfn main() {\n    // This will return 2\n    let result1 = division_unwrap(10, 5);\n    // This will panic with the message 'Invalid division'\n    let result2 = division_unwrap(10, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Scarb and Encountering a Missing Match Arm Error\nDESCRIPTION: This snippet shows the terminal output after running `scarb cairo-run` on a Cairo project (`no_listing_08_missing_match_arm`). The compilation fails because a `match` expression within the Cairo code (specifically in `lib.cairo` at line 5) is not exhaustive; it's missing a branch to handle the `None` variant of an enum (likely `Option`). Scarb reports the error and exits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/output.txt#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ scarb cairo-run \n   Compiling no_listing_08_missing_match_arm v0.1.0 (listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/Scarb.toml)\nerror: Missing match arm: `None` not covered.\n --> listings/ch06-enums-and-pattern-matching/no_listing_09_missing_match_arm/src/lib.cairo:5:5\n    match x {\n    ^*******^\n\nerror: could not compile `no_listing_08_missing_match_arm` due to previous error\nerror: `scarb metadata` exited with error\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Arrays with while Loops in Cairo (cairo)\nDESCRIPTION: This code iterates through the elements of an array using a while loop, incrementing an index variable and printing each element. It demonstrates how manual bounds checking is required, and how errors may result from mismatched array lengths and conditions. No external dependencies are needed. Input is an array; output is each element printed in sequence. The approach is error prone and less safe compared to other methods.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_10\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Calling Derived Hello Method - Cairo\nDESCRIPTION: Shows how to create an instance of a struct (`SomeType`) that has derived the `Hello` trait using the custom macro and call the generated `hello()` method. The method will execute the code produced by the macro, printing 'Hello, SomeType!'.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_8\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_15_procedural_macro/src/lib.cairo:hello_example}}\n```\n\n----------------------------------------\n\nTITLE: Computing Keccak-256 Hash using keccak_syscall in Cairo\nDESCRIPTION: Defines the `keccak_syscall` function used for computing the Keccak-256 hash of a given input. It takes the input data as a `Span<u64>` and returns the resulting hash as a `u256` value wrapped in `SyscallResult`. Requires `GasBuiltin` and `System` implicits.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-08-system-calls.md#_snippet_14\n\nLANGUAGE: cairo\nCODE:\n```\npub extern fn keccak_syscall(\n    input: Span<u64>,\n) -> SyscallResult<u256> implicits(GasBuiltin, System) nopanic;\n```\n\n----------------------------------------\n\nTITLE: PizzaFactory Contract Definition in Cairo\nDESCRIPTION: This code snippet defines the `PizzaFactory` contract in Cairo, which serves as the primary example for demonstrating smart contract testing with Starknet Foundry. It showcases the contract's structure and functionality, including creating pizzas and managing ownership.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch104-02-testing-smart-contracts.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch104-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/src/pizza.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Using panic_with_felt252 Function in Cairo\nDESCRIPTION: Shows a more concise way to panic by using the panic_with_felt252 function, which takes a felt252 value as the error message. This approach is more idiomatic and cleaner than using the basic panic function.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch09-01-unrecoverable-errors-with-panic.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nfn main() {\n    let mut data = array![1, 2, 3];\n    data.append(4);\n    panic_with_felt252('An error occurred');\n    println!(\"This code is never reached: {:?}\", data);\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Closure with Different Numeric Types in Cairo\nDESCRIPTION: This snippet demonstrates an attempt to call a closure named 'example_closure' with both u64 and u32 parameters, resulting in type inference errors. The Cairo compiler cannot automatically infer the type for the second call.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch11-functional-features/listing_closure_different_types/output.txt#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nlet s = example_closure(5_u64);\nlet n = example_closure(5_u32);\n```\n\n----------------------------------------\n\nTITLE: Verifying a proof using Scarab CLI in Shell\nDESCRIPTION: This shell command attempts to verify a proof with a specific execution ID in the Cairo-Book project. It depends on a previously generated proof file and outputs an error if the file is missing. The command aids in automating proof verification within a development or CI/CD pipeline.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch01-getting-started/prime_prover2/output_verify.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ scarb verify --execution-id 1\n```\n\n----------------------------------------\n\nTITLE: Defining Private/Internal Contract Functions in Cairo\nDESCRIPTION: Demonstrates defining private (internal) functions within an `impl` block, potentially using the `#[generate_trait]` attribute for convenience. These functions are not exposed in the ABI and can only be invoked from within the contract.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch101-02-contract-functions.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch101-building-starknet-smart-contracts/listing_01_reference_contract/src/lib.cairo:state_internal}}\n```\n\n----------------------------------------\n\nTITLE: Declaring an Array in Cairo\nDESCRIPTION: This snippet provides a concise reminder of how to declare an array in Cairo, showing initialization with integer values. Arrays are complex types in Cairo that adhere to move semantics.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch04-01-what-is-ownership.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nlet mut arr = Array::<usize>::new();\narr.append(1);\narr.append(2);\n```\n\n----------------------------------------\n\nTITLE: Configuring Scarb.toml for an Executable Target\nDESCRIPTION: This Scarb.toml configuration defines an executable target for the Cairo project and includes the `cairo_execute` plugin.  It also disables gas tracking. This configuration is required to create a provable Cairo program.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-03-proving-a-prime-number.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"prime_prover\"\nversion = \"0.1.0\"\nedition = \"2024_07\"\n\n[dependencies]\n\n[dev-dependencies]\ncairo_test = \"2.11.4\"\n```\n\n----------------------------------------\n\nTITLE: Skipping Formatting with `#[cairofmt::skip]` in Cairo\nDESCRIPTION: Demonstrates how to prevent `scarb fmt` from formatting specific sections of Cairo code by using the `#[cairofmt::skip]` attribute. This is useful for preserving manual formatting in certain parts of the code.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/appendix-06-useful-development-tools.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n#[cairofmt::skip]\nlet table: Array<ByteArray> = array![\n    \"oxo\",\n    \"xox\",\n    \"oxo\",\n];\n```\n\n----------------------------------------\n\nTITLE: Installing starkup on Linux or MacOS\nDESCRIPTION: Command to download and install starkup, which manages Cairo, Scarb, and Starknet Foundry. This curl command downloads and executes an installation script that handles the complete setup process.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch01-01-installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.starkup.dev | sh\n```\n\n----------------------------------------\n\nTITLE: Defining Hello Trait - Cairo\nDESCRIPTION: Defines the `Hello` trait in Cairo, which includes a `hello()` function. This trait serves as the target for the `#[derive(Hello)]` procedural macro discussed later.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_15_procedural_macro/src/lib.cairo:hello_trait}}\n```\n\n----------------------------------------\n\nTITLE: Compile Cairo Program using wasmtime_test.sh\nDESCRIPTION: This command executes the `wasmtime_test.sh` script to compile a Cairo program using a specified Cairo file and Sierra file.  It requires a Cairo program file (`.cairo`) and a corresponding Sierra file (`.sierra`) as input.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./wasmtime_test.sh compileCairoProgram ./cairo_files/HelloStarknetAstro.cairo ./cairo_files/HelloStarknetAstro.sierra\n```\n\n----------------------------------------\n\nTITLE: Showing the trait def embedded\nDESCRIPTION: This snippet shows the code that will be used with `embeddable_as(<name>)`. It shows the functions receiving the generic type `ComponentState<TContractState>`\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-02-01-under-the-hood.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch103-building-advanced-starknet-smart-contracts/listing_02_ownable_component/src/component.cairo:trait_def}}\n```\n\n----------------------------------------\n\nTITLE: Publish WASM-bindgen Toolkit with Modules\nDESCRIPTION: This command publishes the packed module using `wasm-pack`. This command should be executed after the packing step to make the package available on npm.  It will publish the package to npm registry.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack publish\n```\n\n----------------------------------------\n\nTITLE: Pack WASM-bindgen Toolkit without Modules\nDESCRIPTION: This command packs the output of the no-module build using `wasm-pack`. It is used after the build command for the no-modules target.  It prepares the project for potential publication.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack pack output/no_module\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Function in Cairo\nDESCRIPTION: Shows how to define a simple function using the `fn` keyword followed by the function name and parentheses to declare the function. The function body is enclosed in curly braces. Demonstrates a function call within the main function. The snippet requires a Cairo compiler and assumes familiarity with the main function as the program entry point.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-03-functions.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn another_function() {\n    println!(\"Hello from another function!\");\n}\n\nfn main() {\n    println!(\"Hello, world!\");\n    another_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Using unidiomatic path imports for functions in Cairo\nDESCRIPTION: An example of importing a function directly with `use`, which is considered unidiomatic in Cairo. This style makes the code less clear about where the function is defined.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Binary Tree Type in Cairo (Incorrect)\nDESCRIPTION: This code snippet attempts to define a recursive BinaryTree type in Cairo without using Box<T>. This results in a compilation error because the size of the BinaryTree type cannot be determined at compile time due to the infinite recursion.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-02-smart-pointers.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Attempting to Modify a Struct Through a Snapshot in Cairo\nDESCRIPTION: This code snippet demonstrates an invalid operation where the code attempts to modify fields of a struct through a snapshot reference, which is not allowed in Cairo's ownership model.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch04-understanding-ownership/listing_04_attempt_modifying_snapshot/output.txt#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nrec.height = rec.width;\nrec.width = temp;\n```\n\n----------------------------------------\n\nTITLE: Checking Starkli Version for Deployment\nDESCRIPTION: Command to verify the installed version of Starkli CLI tool, which should be 0.3.6 for compatibility with the tutorial.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch103-06-01-deploying-and-interacting-with-a-voting-contract.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ starkli --version\n0.3.6 (8d6db8c)\n```\n\n----------------------------------------\n\nTITLE: Scarb.toml Configuration for Procedural Macros\nDESCRIPTION: This `Scarb.toml` file marks the project as a Cairo plugin.  It defines a `[cairo-plugin]` target, indicating that this project provides a macro for use in Cairo projects. This configuration is part of the macro implementation project and tells Scarb that this project contains a Cairo plugin.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_2\n\nLANGUAGE: TOML\nCODE:\n```\n[package]\nname = \"pow\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[[cairo-plugin]]\nplugin_type = \"macro\"\n\n```\n\n----------------------------------------\n\nTITLE: Implementing the Contract Interface in Cairo\nDESCRIPTION: Provides the implementation block for the `SimpleStorage` contract, implementing the `ISimpleStorage` trait. The block is annotated with `#[abi(embed_v0)]` to make the functions (`set` and `get`) callable externally. It uses the generated `ContractState` type for `self` to interact with storage variables defined in the `Storage` struct.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_01_simple_contract/src/lib.cairo:impl}}\n```\n\n----------------------------------------\n\nTITLE: Defining Procedural Macro Signatures\nDESCRIPTION: These are the signatures for the three types of procedural macros: `inline`, `attribute`, and `derive`.  Each macro type corresponds to how the macro will be invoked in Cairo code (function-like, attribute-like, or derive). The signatures take a `TokenStream` as input (Cairo tokens) and return a `ProcMacroResult` (generated code and diagnostics).\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[inline_macro]\npub fn inline(code: TokenStream) -> ProcMacroResult {}\n\n#[attribute_macro]\npub fn attribute(attr: TokenStream, code: TokenStream) -> ProcMacroResult {}\n\n#[derive_macro]\npub fn derive(code: TokenStream) -> ProcMacroResult {}\n```\n\n----------------------------------------\n\nTITLE: Using Recursion to Mimic loop Behavior in Cairo (cairo)\nDESCRIPTION: This code shows a recursive function in Cairo that produces the same result as an infinite loop, calling itself until a condition is satisfied and outputting a value. No dependencies are required. Input is the base case or recursion parameter; output is the result when recursion terminates. This demonstrates the conceptual and compilation equivalence between loops and recursion in Cairo.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch02-05-control-flow.md#_snippet_15\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../listings/ch02-common-programming-concepts/no_listing_loop_recursion/src/examples/recursion_example.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Example Compilation Error for Incorrect Interface Implementation\nDESCRIPTION: Displays the compiler error output generated when attempting to compile the incorrect implementation shown in the previous snippet. The error message highlights the mismatch between the implemented `set` function signature and the required signature from the `ISimpleStorage` trait.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch100-00-introduction-to-smart-contracts.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n{{#include ../listings/ch100-introduction-to-smart-contracts/listing_02_wrong_impl/output.txt}}\n```\n\n----------------------------------------\n\nTITLE: Sierra Statements of 'not_inlined' Function Showing Non-Inlined Behavior\nDESCRIPTION: Presents the Sierra code specifically for the 'not_inlined' function executed via a runtime call within the 'main' function. It creates a constant felt252 value and stores it temporarily. This snippet illustrates how non-inlined functions encapsulate their logic separately, leading to an extra function call overhead compared to inlined functions.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-06-inlining-in-cairo.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n09\tfelt252_const<2>() -> ([0])\n10\tstore_temp<felt252>([0]) -> ([0])\n```\n\n----------------------------------------\n\nTITLE: Writing Mapped Storage Entry in Cairo Sequence Diagram\nDESCRIPTION: Shows the message flow for writing a value into a mapped storage entry (self.user_values.entry(addr)) in a Cairo smart contract. The operation starts with finding the base address, constructing and hashing the storage path with the mapping key, converting the path into a pointer, and then writing the value to contract storage. Confirmation of the write operation is sent back to the user. This snippet highlights the writing mechanism within a nested storage mapping structure.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/mermaid-storage-model.txt#_snippet_2\n\nLANGUAGE: sequenceDiagram\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant Compiler\n    participant StorageBase\n    participant StoragePath\n    participant StoragePointer\n    participant ContractStorage\n\n    User->>Compiler: self.user_values.entry(addr).write(value)\n    Compiler->>StorageBase: Get base address for 'user_values'\n    StorageBase->>StoragePath: Create initial path\n    StoragePath->>StoragePath: Hash with 'addr'\n    StoragePath->>StoragePointer: Convert to pointer\n    StoragePointer->>ContractStorage: Write value\n    ContractStorage-->>User: Confirm write\n```\n\n----------------------------------------\n\nTITLE: Compiling Cairo Code with Type Mismatch Error\nDESCRIPTION: Terminal output showing a compilation error in a Cairo project. The error occurs on line 4 of lib.cairo where the numeric literal 3 is used in a context where a boolean value is expected.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/output.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ scarb build \n   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)\nerror: Mismatched types. The type `core::bool` cannot be created from a numeric literal.\n --> listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:4:18\n    let number = 3;\n                 ^\n\nerror: could not compile `no_listing_28_bis_if_not_bool` due to previous error\n```\n\n----------------------------------------\n\nTITLE: Implementing Rename Attribute Macro - Rust\nDESCRIPTION: Rust procedural macro implementation for a custom `#[rename(NewName)]` attribute. This macro takes the new name from the attribute arguments and the original struct definition, then generates new Cairo code to effectively rename the struct during compilation.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n{{#rustdoc_include ../listings/ch12-advanced-features/no_listing_18_procedural_macro_attribute/src/lib.rs:rename}}\n```\n\n----------------------------------------\n\nTITLE: Reading Mapped Storage Entry in Cairo Sequence Diagram\nDESCRIPTION: Illustrates the sequence of operations for reading a value from a mapped storage entry (self.user_values.entry(addr)) in a Cairo contract. It includes acquiring the base address, building a hashed storage path incorporating the provided address key, transforming the path into a storage pointer, and finally reading the value from contract storage. The diagram emphasizes path hashing for mapping keys prior to reading data.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/mermaid-storage-model.txt#_snippet_1\n\nLANGUAGE: sequenceDiagram\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant Compiler\n    participant StorageBase\n    participant StoragePath\n    participant StoragePointer\n    participant ContractStorage\n\n    User->>Compiler: self.user_values.entry(addr).read()\n    Compiler->>StorageBase: Get base address for 'user_values'\n    StorageBase->>StoragePath: Create initial path\n    StoragePath->>StoragePath: Hash with 'addr'\n    StoragePath->>StoragePointer: Convert to pointer\n    StoragePointer->>ContractStorage: Read value\n    ContractStorage-->>User: Return value\n```\n\n----------------------------------------\n\nTITLE: Displaying GitHub Project Contributors in an HTML Table\nDESCRIPTION: This HTML snippet defines table rows (`<tr>`) and cells (`<td>`) to list contributors. Each cell includes an image (`<img>`) linking to the contributor's GitHub profile, their username, and icon links (`<a>` with `` for documentation, `` for code) pointing to their commit history within the 'cairo-book/cairo-book' repository.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/README.md#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Symmaque\"><img src=\"https://avatars.githubusercontent.com/u/50242998?v=4?s=100\" width=\"100px;\" alt=\"Symmaque\"/><br /><sub><b>Symmaque</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=Symmaque\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=Symmaque\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/No-bodyq\"><img src=\"https://avatars.githubusercontent.com/u/141028690?v=4?s=100\" width=\"100px;\" alt=\"Asher\"/><br /><sub><b>Asher</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=No-bodyq\" title=\"Code\"></a></td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://misicnenad.github.io\"><img src=\"https://avatars.githubusercontent.com/u/19427053?v=4?s=100\" width=\"100px;\" alt=\"Nenad Misi\"/><br /><sub><b>Nenad Misi</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=misicnenad\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=misicnenad\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/TeddyNotBear\"><img src=\"https://avatars.githubusercontent.com/u/106410805?v=4?s=100\" width=\"100px;\" alt=\"Teddy Not Bear\"/><br /><sub><b>Teddy Not Bear</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=TeddyNotBear\" title=\"Documentation\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://audithub.app\"><img src=\"https://avatars.githubusercontent.com/u/71888134?v=4?s=100\" width=\"100px;\" alt=\"Malatrax\"/><br /><sub><b>Malatrax</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=zmalatrax\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=zmalatrax\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"http://alankang.xyz\"><img src=\"https://avatars.githubusercontent.com/u/55970530?v=4?s=100\" width=\"100px;\" alt=\"Beeyoung\"/><br /><sub><b>Beeyoung</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=FriendlyLifeguard\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=FriendlyLifeguard\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/chachaleo\"><img src=\"https://avatars.githubusercontent.com/u/49371958?v=4?s=100\" width=\"100px;\" alt=\"Charlotte\"/><br /><sub><b>Charlotte</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=chachaleo\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=chachaleo\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/obatirou\"><img src=\"https://avatars.githubusercontent.com/u/92337658?v=4?s=100\" width=\"100px;\" alt=\"Oba\"/><br /><sub><b>Oba</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=obatirou\" title=\"Documentation\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/martinvibes\"><img src=\"https://avatars.githubusercontent.com/u/127976766?v=4?s=100\" width=\"100px;\" alt=\"martin machiebe\"/><br /><sub><b>martin machiebe</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=martinvibes\" title=\"Documentation\"></a></td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Jeanmichel7\"><img src=\"https://avatars.githubusercontent.com/u/59661788?v=4?s=100\" width=\"100px;\" alt=\"Jean-Michel\"/><br /><sub><b>Jean-Michel</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=Jeanmichel7\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=Jeanmichel7\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/NueloSE\"><img src=\"https://avatars.githubusercontent.com/u/124416278?v=4?s=100\" width=\"100px;\" alt=\"Emmanuel A Akalo\"/><br /><sub><b>Emmanuel A Akalo</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=NueloSE\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=NueloSE\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/supreme2580\"><img src=\"https://avatars.githubusercontent.com/u/100731397?v=4?s=100\" width=\"100px;\" alt=\"Supreme Labs\"/><br /><sub><b>Supreme Labs</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=supreme2580\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=supreme2580\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/blocksorcerer\"><img src=\"https://avatars.githubusercontent.com/u/175638109?v=4?s=100\" width=\"100px;\" alt=\"blocksorcerer\"/><br /><sub><b>blocksorcerer</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=blocksorcerer\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=blocksorcerer\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/quentin-abei\"><img src=\"https://avatars.githubusercontent.com/u/98474907?v=4?s=100\" width=\"100px;\" alt=\"quentin-abei\"/><br /><sub><b>quentin-abei</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=quentin-abei\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=quentin-abei\" title=\"Code\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.0xjarix.com/\"><img src=\"https://avatars.githubusercontent.com/u/55955137?v=4?s=100\" width=\"100px;\" alt=\"0xjarix\"/><br /><sub><b>0xjarix</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=0xjarix\" title=\"Documentation\"></a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/kkawula\"><img src=\"https://avatars.githubusercontent.com/u/57270771?v=4?s=100\" width=\"100px;\" alt=\"kkawula\"/><br /><sub><b>kkawula</b></sub></a><br /><a href=\"https://github.com/cairo-book/cairo-book/commits?author=kkawula\" title=\"Documentation\"></a> <a href=\"https://github.com/cairo-book/cairo-book/commits?author=kkawula\" title=\"Code\"></a></td>\n    </tr>\n  </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Redefining Generic `Wallet` Struct with Two Parameters in Cairo\nDESCRIPTION: Redefines the `Wallet` struct to include two generic type parameters, `U` and `V`. This structure is intended for demonstrating generic methods within generic traits that involve multiple generic types. This definition is part of a non-compiling example.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch08-01-generic-data-types.md#_snippet_9\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Drop, Copy)]\nstruct Wallet<U, V> {\n    address: U,\n    balance: V\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing Cairo Zero Program with Output Builtin\nDESCRIPTION: This Cairo Zero program demonstrates basic memory allocation and manipulation within the execution segment using the `ap` register and the `output` builtin. It allocates three values, performs an addition, asserts the result, and uses the `output_ptr` to store the final output in a dedicated segment. The `output_ptr` is passed as an argument and the function returns an incremented pointer indicating the next available memory address.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch202-02-segments.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n%builtins output\n\nfunc main(output_ptr: felt*) -> (output_ptr: felt*) {\n\n    // We are allocating three different values to segment 1.\n    [ap] = 10, ap++;\n    [ap] = 100, ap++;\n    [ap] = [ap - 2] + [ap - 1], ap++;\n\n    // We set value of output_ptr to the address of where the output will be stored.  \n    // This is part of the output builtin requirement. \n    [ap] = output_ptr, ap++;\n\n    // Asserts that output_ptr equals to 110.\n    assert [output_ptr] = 110;\n\n    // Returns the output_ptr + 1 as the next unused memory address.\n    return (output_ptr=output_ptr + 1); \n}\n```\n\n----------------------------------------\n\nTITLE: Build WASMTIME's WASM-Cairo Toolkit\nDESCRIPTION: This command uses `cargo` to build the WASMTIME's WASM-Cairo toolkit. It specifies the target as `wasm32-wasi` and the release profile. It produces a wasm file that can be run in a WASI environment.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/theme/wasm-cairo/pkg/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo build --target wasm32-wasi --release\n```\n\n----------------------------------------\n\nTITLE: HTML Comments for Tool Integration (all-contributors, prettier)\nDESCRIPTION: These HTML comments serve as markers or directives for external tools. `<!-- markdownlint-disable/restore -->` and `<!-- prettier-ignore-start/end -->` likely control linting and code formatting tools, preventing them from modifying the enclosed contributor table section. `<!-- ALL-CONTRIBUTORS-LIST:END -->` is commonly used by the 'all-contributors' tool/bot to automatically manage and update the contributor list.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/README.md#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- markdownlint-restore -->\n<!-- prettier-ignore-end -->\n\n<!-- ALL-CONTRIBUTORS-LIST:END -->\n<!-- prettier-ignore-start -->\n<!-- markdownlint-disable -->\n\n<!-- markdownlint-restore -->\n<!-- prettier-ignore-end -->\n\n<!-- ALL-CONTRIBUTORS-LIST:END -->\n```\n\n----------------------------------------\n\nTITLE: Attribute Macro Signature - Rust\nDESCRIPTION: Provides the standard function signature for an attribute procedural macro in Rust. Attribute macros receive two `TokenStream` arguments: `attr` containing the arguments provided in the attribute itself, and `code` containing the item the attribute is attached to.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/src/ch12-10-procedural-macros.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n#[attribute_macro]\npub fn attribute(attr: TokenStream, code: TokenStream) -> ProcMacroResult {}\n```\n\n----------------------------------------\n\nTITLE: Running Helper Scripts with Bun - Bash\nDESCRIPTION: Executes the entry point for the helper scripts using Bun. This command assumes that all dependencies have already been installed via 'bun install'. Running this will start the helper script defined in the project's Bun configuration, automating listing management or diffing tasks as required.\nSOURCE: https://github.com/cairo-book/cairo-book/blob/main/scripts/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbun start\n\n```"
  }
]