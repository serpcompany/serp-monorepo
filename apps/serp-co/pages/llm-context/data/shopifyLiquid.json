[
  {
    "owner": "shopify",
    "repo": "liquid",
    "content": "TITLE: Parsing and Rendering Liquid Template\nDESCRIPTION: This Ruby code demonstrates how to parse and render a Liquid template using the `Liquid::Template` class. It showcases the basic API for using Liquid and the passing of parameters for rendering dynamic content.\nSOURCE: https://github.com/shopify/liquid/blob/main/README.md#_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n@template = Liquid::Template.parse(\"hi {{name}}\") # Parses and compiles the template\n@template.render('name' => 'tobi')                # => \"hi tobi\"\n```\n\n----------------------------------------\n\nTITLE: HTML Template Example\nDESCRIPTION: This HTML snippet shows a basic Liquid template structure, using loops and outputting data. It demonstrates how to display product information within an HTML list using Liquid syntax.\nSOURCE: https://github.com/shopify/liquid/blob/main/README.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<ul id=\"products\">\n  {% for product in products %}\n    <li>\n      <h2>{{ product.name }}</h2>\n      Only {{ product.price | price }}\n\n      {{ product.description | prettyprint | paragraph }}\n    </li>\n  {% endfor %}\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Defining and Rendering a Custom Drop with Liquid::Drop in Ruby\nDESCRIPTION: This Ruby snippet illustrates how to create a ProductDrop class inheriting from Liquid::Drop, exposing a top_sales method that returns the top 10 products ordered by sales from the current shop context. It then demonstrates usage by parsing a Liquid template containing a for-loop tag to iterate products, followed by rendering with a new ProductDrop as input. Dependencies include the Liquid templating gem and a Shop model with product associations. The template expects a 'product' variable referencing a ProductDrop instance, and outputs the product names for the top sales. Limitations: active dependencies on the structure and availability of Shop and Product models.\nSOURCE: https://github.com/shopify/liquid/blob/main/History.md#_snippet_0\n\nLANGUAGE: Ruby\nCODE:\n```\nclass ProductDrop < Liquid::Drop\n  def top_sales\n     Shop.current.products.find(:all, :order => 'sales', :limit => 10 )\n  end\nend\nt = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {% endfor %} '  )\nt.render('product' => ProductDrop.new )\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Variables\nDESCRIPTION: This Ruby code demonstrates how to use `strict_variables: true` to handle undefined variables during rendering. It displays how errors are stored in the `template.errors` array and how `render!` method can raise the error immediately instead of storing them.  It illustrates the output when variables are missing.\nSOURCE: https://github.com/shopify/liquid/blob/main/README.md#_snippet_4\n\nLANGUAGE: ruby\nCODE:\n```\ntemplate = Liquid::Template.parse(\"{{x}} {{y}} {{z.a}} {{z.b}}\")\ntemplate.render({ 'x' => 1, 'z' => { 'a' => 2 } }, { strict_variables: true })\n#=> '1  2 ' # when a variable is undefined, it's rendered as nil\ntemplate.errors\n#=> [#<Liquid::UndefinedVariable: Liquid error: undefined variable y>, #<Liquid::UndefinedVariable: Liquid error: undefined variable b>]\n```\n\nLANGUAGE: ruby\nCODE:\n```\ntemplate = Liquid::Template.parse(\"{{x | filter1 | upcase}}\")\ntemplate.render({ 'x' => 'foo' }, { strict_filters: true })\n#=> '' # when at least one filter in the filter chain is undefined, a whole expression is rendered as nil\ntemplate.errors\n#=> [#<Liquid::UndefinedFilter: Liquid error: undefined filter filter1>]\n```\n\nLANGUAGE: ruby\nCODE:\n```\ntemplate = Liquid::Template.parse(\"{{x}} {{y}}\")\ntemplate.render!({ 'x' => 1}, { strict_variables: true })\n#=> Liquid::UndefinedVariable: Liquid error: undefined variable y\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Environments\nDESCRIPTION: This Ruby code shows how to define and use Liquid Environments to encapsulate custom tags and filters. It demonstrates how to register custom tags, such as `renderobj` and `unsubscribe_footer`, within specific environments to avoid conflicts and improve modularity.\nSOURCE: https://github.com/shopify/liquid/blob/main/README.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nuser_environment = Liquid::Environment.build do |environment|\n  environment.register_tag(\"renderobj\", RenderObjTag)\nend\n\nLiquid::Template.parse(<<~LIQUID, environment: user_environment)\n  {% renderobj src: \"path/to/model.obj\" %}\nLIQUID\n```\n\nLANGUAGE: ruby\nCODE:\n```\nemail_environment = Liquid::Environment.build do |environment|\n  environment.register_tag(\"unsubscribe_footer\", UnsubscribeFooter)\nend\n\nLiquid::Template.parse(<<~LIQUID, environment: email_environment)\n  {% unsubscribe_footer %}\nLIQUID\n```\n\n----------------------------------------\n\nTITLE: Setting Error Modes\nDESCRIPTION: This Ruby snippet shows how to set the error mode for Liquid. It describes the various modes (`:strict`, `:warn`, and `:lax`) and their effects on template parsing and error handling. This is useful for debugging and enforcing stricter syntax rules.\nSOURCE: https://github.com/shopify/liquid/blob/main/README.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nLiquid::Environment.default.error_mode = :strict\nLiquid::Environment.default.error_mode = :strict # Raises a SyntaxError when invalid syntax is used\nLiquid::Environment.default.error_mode = :warn # Adds strict errors to template.errors but continues as normal\nLiquid::Environment.default.error_mode = :lax # The default mode, accepts almost anything.\n```\n\nLANGUAGE: ruby\nCODE:\n```\nLiquid::Template.parse(source, error_mode: :strict)\n```"
  }
]