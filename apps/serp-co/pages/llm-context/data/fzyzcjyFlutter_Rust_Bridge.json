[
  {
    "owner": "fzyzcjy",
    "repo": "flutter_rust_bridge",
    "content": "TITLE: Calling Rust Function from Dart Code Using Dart\nDESCRIPTION: Demonstrates calling the Rust function 'f' from Dart code by passing a String and a list of 'MyEnum'. This snippet shows seamless invocation of Rust code as if it were normal Dart code, with automatic bridge handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nprint(f(a: 'Hello', b: [MyEnum.c('Tom')]));\n```\n\n----------------------------------------\n\nTITLE: Running a Flutter Rust Bridge Application\nDESCRIPTION: Standard Flutter command to run the application after setup is complete. This works just like a normal Flutter project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nflutter run\n```\n\n----------------------------------------\n\nTITLE: Struct field rename example (Rust)\nDESCRIPTION: This example demonstrates how to rename a struct field when generating the corresponding Dart class using the `#[frb(name = \"...\")]` attribute.  The `rust_field_name` field in the Rust struct will be translated to `dartFieldName` in Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/struct.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb]\npub struct MyStruct {\n  #[frb(name = \"dartFieldName\")]\n  pub rust_field_name: Vec<u8>,\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Rust Struct Methods to Dart Classes\nDESCRIPTION: Shows how Rust struct methods are translated into Dart class methods using flutter_rust_bridge, converting synchronous Rust calls into asynchronous Dart functions. Static methods are represented as static Dart methods, while instance methods include a 'self' reference.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/methods.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass SumWith {\n  final int x;\n\n  const SumWith({\n    required this.x,\n  });\n\n  Future<int> sum({required int y, dynamic hint}) { ... }\n\n  static Future<int> sumStatic({required int x, required int y, dynamic hint}) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Word Dictionary Operations with Flutter Rust Bridge in Rust\nDESCRIPTION: Defines a Rust struct WordDict representing a word dictionary and implements methods to open the dictionary, get its size synchronously, and perform asynchronous word searches with streaming results. The implementation supports callback functions from Dart, error translation, synchronous getters, and both synchronous and asynchronous interaction patterns integrated with Flutter Rust Bridge macros.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// ↑ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↑ Support functions & methods\nimpl WordDict {\n    //          ↑ Can call Dart back                 ↑ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↑ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↑ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↑ Allow async & sync                    ↑ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Freezed and Build Runner Dependencies in Shell\nDESCRIPTION: This shell snippet shows how to install the build_runner, freezed, and freezed_annotation packages for Dart and Flutter projects. These dependencies enable code generation for Freezed annotated classes. The commands must be executed from the project's root directory before attempting to generate code. Required for compiling code using the Freezed package.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_build_runner.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nflutter pub add -d build_runner\nflutter pub add -d freezed\nflutter pub add freezed_annotation\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handler in Rust for Flutter Rust Bridge\nDESCRIPTION: This Rust code snippet demonstrates how to implement a custom ErrorHandler for error reporting within a Flutter Rust Bridge project. By wrapping the default ReportDartErrorHandler, this handler allows errors to be sent to an external backend before delegating to the standard handler, facilitating richer diagnostics and support for symbolication. Required dependencies include the definition of ErrorHandler, handler::Error, and the external reporting function send_error_to_your_backend. Inputs are the error port identifier and the error object; outputs are the error being sent and further handled. Some implementation details are omitted in the example (indicated by ...), and further customization may be necessary based on the backend's requirements.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/report-error.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyErrorHandler(ReportDartErrorHandler);\n\nimpl ErrorHandler for MyErrorHandler {\n    fn handle_error(&self, port: i64, error: handler::Error) {\n        send_error_to_your_backend(&error);\n        self.0.handle_error(port, error)\n    }\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exposing the WordDict API using flutter_rust_bridge in Rust\nDESCRIPTION: This snippet defines a Rust struct 'WordDict' and implements several methods to make it accessible in Dart applications via flutter_rust_bridge. The 'open' function asynchronously initializes the dictionary, taking a closure as a chooser and returning a Result-wrapped instance, translating errors as necessary. The 'size' method exposes a property getter with support for both synchronous and asynchronous Dart calls. The 'search' method provides asynchronous keyword-based search capability and streams results using a StreamSink. Requires flutter_rust_bridge and appropriate bridge setup; key parameters include the closure for dictionary construction and the search keyword. Expects string-based keyword input, returns a stream of string results for searches, and an integer size for dictionary size queries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// ↱ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↱ Support functions & methods\nimpl WordDict {\n    //          ↱ Can call Dart back                 ↱ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↱ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↱ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↱ Allow async & sync                    ↱ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WordDict Structure and Methods in Rust for Flutter Rust Bridge\nDESCRIPTION: Defines a Rust struct 'WordDict' with support functions including 'open' for initialization, 'size' as a property getter, and 'search' as an asynchronous stream generator. Dependencies include the 'StreamSink' trait and the 'frb' attribute macro for Flutter Rust Bridge integration. These methods facilitate interactions from Dart, allowing synchronous property access, asynchronous opener, and streaming search results.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_macros/README.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// ↱ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↱ Support functions & methods\nimpl WordDict {\n    //          ↱ Can call Dart back                 ↱ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↱ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↱ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↱ Allow async & sync                    ↱ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dart Runtime Dependencies (Bash)\nDESCRIPTION: Adds the required `flutter_rust_bridge` runtime package to a Flutter project using `flutter pub add`. Optionally, it adds development dependencies (`build_runner`, `freezed`) and `freezed_annotation` needed when using enum structs and the Dart code generator.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/deps.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nflutter pub add flutter_rust_bridge\n# if using Dart codegen\nflutter pub add -d build_runner\nflutter pub add -d freezed\nflutter pub add freezed_annotation\n```\n\n----------------------------------------\n\nTITLE: Adding Dart Dependencies\nDESCRIPTION: This snippet shows how to add the required Dart dependencies for using `flutter_rust_bridge` and related packages (e.g., `build_runner`, `freezed`). It uses `flutter pub add` to add these dependencies. It's crucial for enabling the core functionality, including the generation of the glue code and serialization/deserialization of data structures.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/02-deps.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nflutter pub add flutter_rust_bridge\n# if using Dart codegen\nflutter pub add -d build_runner\nflutter pub add -d freezed\nflutter pub add freezed_annotation\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Function from Dart using flutter_rust_bridge\nDESCRIPTION: This Dart snippet demonstrates calling the Rust function 'f' from Dart code via flutter_rust_bridge. The function invocation passes a named String argument 'a' and a list of 'MyEnum' enum instances. This example illustrates how Dart can naturally call Rust functions as if they were Dart functions without manual handling, showcasing seamless interoperability and automatic translation of complex types.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nprint(f(a: 'Hello', b: [MyEnum.c('Tom')]));\n```\n\n----------------------------------------\n\nTITLE: Integrating Flutter Rust Bridge into Existing Project\nDESCRIPTION: Command to add flutter_rust_bridge to an existing Flutter project. This should be executed in the root folder of the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen integrate\n```\n\n----------------------------------------\n\nTITLE: JSON Encoding/Decoding in Dart\nDESCRIPTION: This Dart code snippet demonstrates how to use `jsonEncode` to serialize a Dart object into a JSON string, pass it to a Rust function through flutter_rust_bridge, and then use `jsonDecode` to parse the JSON string returned by the Rust function into a Dart object. It relies on the `dart:convert` library for JSON encoding and decoding and the flutter_rust_bridge generated API (`api`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/protobuf-json.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Dart\nvar result = jsonDecode(await api.f(a: jsonEncode({\"x\": [100, 200, \"what\"], \"y\": \"hello\"})));\n```\n\n----------------------------------------\n\nTITLE: Defining a Constant in Rust\nDESCRIPTION: This Rust code defines a public constant named `CONST_INT` of type `i32` with a value of 42.  The `pub` keyword is necessary for flutter_rust_bridge to recognize and expose the constant. This constant will then be accessible from Dart code via an automatically generated getter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/constants.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub const CONST_INT: i32 = 42;\n```\n\n----------------------------------------\n\nTITLE: Flutter Dart App Listening to Rust Stream Timer\nDESCRIPTION: A Flutter application that initializes a stream by calling the Rust 'tick' function, and uses StreamBuilder to display the elapsed seconds. The app updates its UI in real-time as rust emits new tick count values, demonstrating cross-language stream integration within Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:flutter/material.dart';\nimport 'ffi.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({Key? key, required this.title}) : super(key: key);\n  final String title;\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  late Stream<int> ticks;\n\n  @override\n  void initState() {\n    super.initState();\n    ticks = api.tick();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text(\"Time since starting Rust stream\"),\n            StreamBuilder<int>(\n              stream: ticks,\n              builder: (context, snap) {\n                final style = Theme.of(context).textTheme.headlineMedium;\n                final error = snap.error;\n                if (error != null)\n                  return Tooltip(\n                      message: error.toString(),\n                      child: Text('Error', style: style));\n\n                final data = snap.data;\n                if (data != null) return Text('$data second(s)', style: style);\n\n                return const CircularProgressIndicator();\n              },\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter Rust Bridge Codegen\nDESCRIPTION: This snippet provides the command to install the `flutter_rust_bridge_codegen` tool, which is used to generate bindings between Flutter/Dart and Rust. This is a prerequisite for creating and running applications using the bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\n```\n\n----------------------------------------\n\nTITLE: Defining WordDict Rust Struct with Async and Sync Methods\nDESCRIPTION: Defines a Rust struct WordDict that represents a word dictionary with a constructor supporting callback-based error-handling open method, synchronous size getter, and asynchronous search functionality. The code employs features such as async-await, trait bounds for callbacks, error translation, and stream sinks to support communication with Dart clients. It requires the flutter_rust_bridge macros and traits to handle Dart interoperability, including specifying sync accessors and streaming for Dart consumers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n// ↑ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↑ Support functions & methods\nimpl WordDict {\n    //          ↑ Can call Dart back                 ↑ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↑ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↑ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↑ Allow async & sync                    ↑ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RustOpaque for ArbitraryData in Rust\nDESCRIPTION: This Rust snippet demonstrates how to define a struct `ArbitraryData` and functions that use the `RustOpaque` type. It shows how `RustOpaque` can be used within function signatures to handle opaque data.  Dependencies: Requires the `flutter_rust_bridge` crate.  Input: A `RustOpaque<ArbitraryData>` or a `RustOpaque<Mutex<ArbitraryData>>`. Output:  `RustOpaque<RwLock<ArbitraryData>>`. Limitations: Works in Rust projects utilizing the Flutter Rust Bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-opaque.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct ArbitraryData { ... }\npub fn use_opaque(a: RustOpaque<ArbitraryData>) { ... }\npub fn even_use_locks(b: RustOpaque<Mutex<ArbitraryData>) -> RustOpaque<RwLock<ArbitraryData>> { ... }\nenum AnEnumContainingOpaque { Hello(RustOpaque<ArbitraryData>), World(i32) }\n...\n```\n\n----------------------------------------\n\nTITLE: Dart Logging Setup Listening to Rust Stream\nDESCRIPTION: Shows an asynchronous Dart function that subscribes to the log stream from Rust and processes each LogEntry, printing log details to the console. Enables real-time viewing of logs originating from Rust within Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> setup() async {\n    createLogStream().listen((event) {\n      print('log from rust: ${event.level} ${event.tag} ${event.msg} ${event.timeMillis}');\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Trait Implementation Example\nDESCRIPTION: This example demonstrates how a Rust trait implementation is defined.  It shows a trait `MyTrait` being implemented for a struct `MyStruct` with a single method `f` that takes a String and returns an i32. This is the Rust code that flutter_rust_bridge will process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/implementations.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl MyTrait for MyStruct {\n    fn f(&self, a: String) -> i32 { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Function from Dart\nDESCRIPTION: This Dart code snippet demonstrates how to call the previously defined Rust function `my_rust_function` from Dart.  It assumes that the necessary bridge code has been generated using Flutter Rust Bridge, allowing direct invocation of the Rust function within the Dart environment. The `myRustFunction` identifier is a placeholder for the actual generated function name.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/dart-call-rust.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nprint(myRustFunction('Hello'));\n```\n\n----------------------------------------\n\nTITLE: Defining a Synchronous Rust Function with #[frb(sync)] Attribute\nDESCRIPTION: This Rust code demonstrates how to mark a function as synchronous using the #[frb(sync)] attribute. The function normal() is a regular function, while dart_counterpart_is_synchronous() is marked for synchronous binding. The attribute allows the generated Dart API to call the function without requiring 'await', reducing overhead for quick, frequently called functions, but caution is advised for slow functions to avoid blocking the UI.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/sync-dart.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn normal() {}\n\n#[frb(sync)]\nfn dart_counterpart_is_synchronous() {}\n```\n\n----------------------------------------\n\nTITLE: Running Flutter Rust Bridge for Web\nDESCRIPTION: Commands to build and run a Flutter Rust Bridge application for web platforms, including necessary headers for cross-origin isolation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen build-web\n# ... or any other standard Flutter ways\nflutter run --web-header=Cross-Origin-Opener-Policy=same-origin --web-header=Cross-Origin-Embedder-Policy=require-corp\n```\n\n----------------------------------------\n\nTITLE: Illustrating Asynchronous Transformation from Rust to Dart\nDESCRIPTION: Demonstrates how a synchronous Rust function signature is transformed into an asynchronous Dart function signature returning a Future by flutter_rust_bridge. This approach ensures that calls to potentially long-running Rust code do not block the Flutter UI thread.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/async-dart.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(..) -> String\n```\n\nLANGUAGE: Dart\nCODE:\n```\nFuture<String> f(..)\n```\n\n----------------------------------------\n\nTITLE: Calling a Rust Function from Dart\nDESCRIPTION: Example of how to call the Rust function from Dart code in the lib/main.dart file. The function is called asynchronously with await.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await hello(a: \"Hi\");\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Flutter Application\nDESCRIPTION: This shell command is a quickstart for setting up and running a Flutter application that utilizes the Flutter Rust Bridge.  It involves installing the codegen, creating a new application, navigating to the application directory, and then running the Flutter application. The codegen tool will generate necessary bindings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen create my_app && cd my_app && flutter run\n```\n\n----------------------------------------\n\nTITLE: Returning DartDynamic from Rust via flutter_rust_bridge\nDESCRIPTION: This Rust function demonstrates using the `DartDynamic` escape hatch to return heterogeneous data to Dart. It shows how to convert various Rust types (`()`, `i32`, `String`) into a format compatible with `DartDynamic` using the `into_dart()` method and returning them as a list.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-dynamic.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\npub fn return_dynamic() -> DartDynamic {\n    vec![\n        ().into_dart(),\n        0i32.into_dart(),\n        format!(\"Hello there!\").into_dart()\n    ].into_dart()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Callable Rust Struct for flutter_rust_bridge\nDESCRIPTION: This Rust code snippet defines a struct `A` and implements a `call` method. By convention, implementing a method named `call` with this signature allows instances of struct `A` to be treated as callable functions when bridged to Dart using flutter_rust_bridge. The method takes an owned reference to self (`&self`) and a `String` argument, returning a `String`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/callables.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct A { ... }\n\nimpl A {\n    pub fn call(&self, my_arg: String) -> String { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the build process. This ensures compatibility with the CMake features used in the file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Calling the WordDict Rust API from Dart using flutter_rust_bridge\nDESCRIPTION: This Dart snippet demonstrates consuming the Rust 'WordDict' API via flutter_rust_bridge. It shows how to asynchronously open the dictionary, access properties using Dart getters, and process stream results using asynchronous for-loops. The example requires that flutter_rust_bridge-generated bindings are available and properly initialized within the Flutter app. The 'open' method expects a Dart closure that returns a boolean, while 'search' expects a string keyword and returns a stream of results; outputs are printed to the standard output.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Adding Log Entry to Stream in Rust\nDESCRIPTION: This Rust code demonstrates how to send a log message to the Dart side using the established `log_stream_sink`. A `LogEntry` struct is created with relevant log data and added to the stream. It requires the `LogEntry` struct and `StreamSink` to have been properly initialized. This action effectively transmits the log message for consumption within the Dart environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlog_stream_sink.add(LogEntry { msg: \"hello I am a log from Rust\", ... })\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Properties with Getter and Setter Attributes for Flutter Rust Bridge\nDESCRIPTION: This snippet demonstrates how to use custom attributes #[frb(getter)] and #[frb(setter)] in Rust to generate corresponding Dart property accessors. Functions annotated with these attributes become available as Dart getters and setters, simplifying interlanguage property access and manipulation. Key dependencies include the Flutter Rust Bridge framework and particular attributes that facilitate code generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/properties.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct A { ... }\n\nimpl A {\n    #[frb(sync, getter)]\n    pub fn something(&self) -> String { ... }\n\n    #[frb(sync, setter)]\n    pub fn something(&mut self, value: String) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing External Library in Dart\nDESCRIPTION: This Dart code initializes the external library by loading it using the provided path. The function `initializeExternalLibrary` takes a string path as input, which represents the location of the compiled library. It then instantiates a `BridgeImpl` object with the loaded library, making the bridge available for use in tests. The `loadLibForDart` function is used for loading the library. Requires the `basis_hybrid` package and `flutter_rust_bridge` package.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/unit_tests_dart.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nBridgeImpl initializeExternalLibrary(String path) => BridgeImpl(loadLibForDart(path));\n```\n\n----------------------------------------\n\nTITLE: Using Trait Objects with RustOpaque in Rust\nDESCRIPTION: This Rust snippet demonstrates the usage of trait objects behind opaque pointers. It defines `DebugWrapper` struct which uses `RustOpaque<Box<dyn Debug>>`. Shows how to create a wrapper using `opaque_dyn` macro.  Dependencies: Requires the `flutter_rust_bridge` crate. Input: none. Output: none. It also shows an example of defining another struct which uses `RustOpaque` with more traits like `Send`, `Sync`, `UnwindSafe`, and `RefUnwindSafe`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-opaque.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct DebugWrapper(pub RustOpaque<Box<dyn Debug>>);\n\n// creating a DebugWrapper using the opaque_dyn macro\nlet wrap = DebugWrapper(opaque_dyn!(\"foobar\"));\n// it's possible to name it directly\npub struct DebugWrapper2(pub RustOpaque<Box<dyn Debug + Send + Sync + UnwindSafe + RefUnwindSafe>>);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Rust Function\nDESCRIPTION: This Rust function `my_rust_function` takes a String as input and returns a new String that is the original string repeated twice. This function demonstrates a basic operation that can be exposed to Dart through Flutter Rust Bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/dart-call-rust.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn my_rust_function(a: String) -> String { a.repeat(2) }\n```\n\n----------------------------------------\n\nTITLE: Installing Application Executable and Dependencies\nDESCRIPTION: Specifies installation rules using the `install` command. It installs the main application executable (`TARGETS ${BINARY_NAME}`), the Flutter International Components for Unicode (ICU) data file (`FILES \"${FLUTTER_ICU_DATA_FILE}\"`), the core Flutter engine library (`FILES \"${FLUTTER_LIBRARY}\"`), and conditionally installs any bundled plugin libraries (`FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"` if the variable is non-empty). All are installed to their respective configured destination directories within the `CMAKE_INSTALL_PREFIX`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Xcode Project from Rust Crate Using cargo-xcode Bash Command\nDESCRIPTION: This bash command runs 'cargo xcode' inside the Rust crate directory to generate an Xcode project file (*.xcodeproj) for the crate. The generated project facilitates integrating Rust code within Xcode workflows, enabling iOS and macOS app development that leverages Rust libraries. Running this command is a one-time setup per crate. It requires having the 'cargo-xcode' tool installed and configured. The output project can then be imported into other Xcode projects.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_proj.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo xcode\n```\n\n----------------------------------------\n\nTITLE: Configuring Linux CMake Build for Flutter Rust Plugin\nDESCRIPTION: CMakeLists.txt file for the Linux platform within a Flutter plugin. It sets the minimum CMake version, defines the project name, downloads pre-compiled Rust library binaries from a specified GitHub release URL, extracts the archive, and sets the path to the bundled shared library (`.so`) for Flutter integration. Requires placeholders like `library_name`, `YourGitHubAccount`, and `repo_name` to be replaced.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/01-windows-and-linux.md#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\n\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\n# Project-level configuration.\nset(PROJECT_NAME \"flutter_library_name\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}\")\nset(ArchivePath \"${LibRoot}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(flutter_library_name_bundled_libraries\n  \"${LibRoot}/${FLUTTER_TARGET_PLATFORM}/liblibrary_name.so\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Bridge Code with Watch Mode\nDESCRIPTION: Command to execute the code generator with watch mode, which automatically regenerates the bridge code whenever Rust code changes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen generate --watch\n```\n\n----------------------------------------\n\nTITLE: Returning Custom Error in Rust\nDESCRIPTION: This Rust function demonstrates returning the custom `CustomError`. It returns a `Result<u32, CustomError>`, returning `Err(CustomError::Error1(3))` to represent an error condition. The error will be caught as a Dart exception on the Dart side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn return_err_custom_error() -> Result<u32, CustomError> {\n    Err(CustomError::Error1(3))\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Rust (`WordDict`) Methods from Dart via `flutter_rust_bridge`\nDESCRIPTION: Demonstrates how to call the Rust `WordDict` methods (`open`, `size`, `search`) from Dart code using the bindings generated by `flutter_rust_bridge`. It shows instantiating the `WordDict` by calling the async `open` method with a callback, accessing the synchronous `size` property getter, and iterating over the results of the asynchronous `search` method using `await for`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Functions and Types for Flutter_Rust_Bridge\nDESCRIPTION: This snippet demonstrates the definition of Rust functions and associated types intended for use with Flutter/Dart through flutter_rust_bridge. It includes a sample function `draw_tree` with parameters like `TreeNode` and `DrawMode`, showcasing the handling of structured data.  This requires the flutter_rust_bridge library and the corresponding code generator to be properly set up.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/quickstart.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// A normal Rust function ...\npub fn draw_tree(root: TreeNode, mode: DrawMode) -> Result<Vec<u8>> { /* ... */ }\n\n// ... with rich types\npub struct TreeNode { pub value: String, pub children: Vec<MyTreeNode> }\npub enum DrawMode { Colorful {palette: String}, Grayscale }\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake with Project Configuration in CMake\nDESCRIPTION: Sets the minimum required CMake version to 3.14 to maintain compatibility with Flutter's Visual Studio tooling and defines the project name and language. It ensures the project is configured properly for C++ builds within the Flutter Rust bridge environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_lib_flutter_via_create\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Define struct with shared ownership using Arc in Rust\nDESCRIPTION: This code snippet demonstrates how to define a struct in Rust that uses shared ownership via `Arc` for a field. This allows multiple parts of the code to safely access and modify the field's data.  It is an alternative approach when working with borrowed types in Flutter Rust Bridge, particularly when you need to share data between Rust and Dart. The `RustAutoOpaque<Another>` is mentioned as an option to expose the field to Dart as an opaque struct.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/alternatives.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct {\n    field: Arc<Another>,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Application Installation and Asset Bundling in CMake (CMake)\nDESCRIPTION: This code automates the installation process, creating a relocatable bundle containing binaries, plugins, library dependencies, and Flutter assets. It ensures a clean deployment directory, manages copying of native and plugin assets, and conditionally installs AOT libraries in non-Debug modes. Inputs include build output paths and asset directories, and outputs are the deployed application files ready for distribution.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\")\n  \" COMPONENT Runtime)\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\" COMPONENT Runtime)\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\" COMPONENT Runtime)\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Ignoring Modules with flutter_rust_bridge Using Doc Comments in Rust\nDESCRIPTION: This Rust snippet illustrates the use of the documentation comment /// flutter_rust_bridge:ignore to exclude modules from flutter_rust_bridge processing. This syntax is necessary for modules because Rust grammar does not yet support the #[frb(ignore)] attribute on modules. The snippet shows a module declaration marked to be ignored, implying it will not be bridged to Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/ignoring.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// flutter_rust_bridge:ignore\nmod this_submodule_will_be_ignored;\n```\n\n----------------------------------------\n\nTITLE: Importing Flutter Rust Bridge Command Documentation Components in JavaScript\nDESCRIPTION: Imports various generated Markdown React components that document different flutter_rust_bridge_codegen CLI commands. Each import corresponds to a specific command module (main, generate, build-web, create, integrate) for modular documentation. This setup is used to organize and render CLI command documentation dynamically.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/codegen/full-list.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport CommandMain from '../../../generated/_frb-codegen-command-main.mdx';\nimport CommandGenerate from '../../../generated/_frb-codegen-command-generate.mdx';\nimport CommandBuildWeb from '../../../generated/_frb-codegen-command-build-web.mdx';\nimport CommandCreate from '../../../generated/_frb-codegen-command-create.mdx';\nimport CommandIntegrate from '../../../generated/_frb-codegen-command-integrate.mdx';\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Struct with Public Field in Rust\nDESCRIPTION: Shows a Rust struct intended to be marked as opaque (`#[frb(opaque)]` implied) with a public field (`pub name: String`) that flutter_rust_bridge will translate into Dart accessors. A private field (`db`) is included to show it won't be translated.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyOpaqueType {\n    pub name: String,\n    db: Database,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Application Build Targets and Dependencies in CMake\nDESCRIPTION: Adds the 'runner' subdirectory which contains the main application CMake build instructions, declares that the executable target depends on the 'flutter_assemble' target ensuring Flutter tool build steps are run before linking the app, and modifies the runtime output directory so that only the installed bundled executable launches properly — preventing accidental use of the unbundled binary.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(\"runner\")${\\n}${\\n}add_dependencies(${BINARY_NAME} flutter_assemble)${\\n}${\\n}set_target_properties(${BINARY_NAME}${\\n}  PROPERTIES${\\n}  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/intermediates_do_not_run\"${\\n})\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Functions from Dart with and without await\nDESCRIPTION: This Dart example illustrates how to invoke Rust functions annotated for synchronous behavior. The normal() function requires 'await' because it is asynchronous by default, whereas dartCounterpartIsSynchronous() can be called directly without 'await' due to the #[frb(sync)] attribute. This setup optimizes performance for quick functions in Flutter apps where minimizing delay is important.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/sync-dart.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nawait normal(); // Need await\ndartCounterpartIsSynchronous(); // No need await\n```\n\n----------------------------------------\n\nTITLE: Setting RUST_BACKTRACE Environment Variable in Rust\nDESCRIPTION: This snippet demonstrates how to set the RUST_BACKTRACE environment variable to \"1\" in a Rust application using the env module. This enables capturing stack traces for Rust errors forwarded through flutter_rust_bridge, which is necessary for debugging and diagnostics in Flutter apps. It must be invoked with env::set_var(\"RUST_BACKTRACE\", \"1\"); before initializing flutter_rust_bridge; simply using Dart's --dart-define will not work, as environment variables must be set in Rust's runtime context.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/stack-trace.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenv::set_var(\"RUST_BACKTRACE\", \"1\");\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RustOpaque in Flutter/Rust Bridge (web) - Dart\nDESCRIPTION: This Dart code demonstrates how to create and interact with a RustOpaque object exposed from Rust.  It calls `createOpaque` to get a new opaque object and then calls `rustOpaque` to perform an operation.  The comments describe how reference counting(Arc) is affected by ownership changes. It emphasizes the memory management implications of the RustOpaque type when crossing the bridge, and the fact that Dart's memory management might not always be aligned with Rust's (particularly with respect to finalizers). It relies on the Flutter/Rust bridge for the `api` and the methods: `createOpaque` and `rustOpaque`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque(); \n\n// (Arc counter = 2) increases immediately. \nString hideData = await api.rustOpaque(opaque);\n\n// (Arc counter = 1)\n//\n// Rust:\n//\n//`executes rust_call_example and counter decreases.`\n\n// memory of opaque types is not monitoring by Dart and can accumulate.\n// (Arc count can be 0 or 1) don't count on automatic clearing.\n//\n// Dart:\n//\n//`the finalizer is NOT guaranteed to be called before the program terminates.`\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Trait Objects with Flutter Rust Bridge in Rust\nDESCRIPTION: Defines a Rust trait and multiple implementations for distinct structs, then a function accepting a reference to any implementer of the trait (`&dyn MyTrait`). This function demonstrates how Rust trait objects enable flexible argument types. The code requires a Rust environment set up with the Flutter Rust Bridge integration to generate Dart bindings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/trait-objects.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub trait MyTrait {}\nimpl MyTrait for MyStructOne {}\nimpl MyTrait for MyStructTwo {}\n\npub fn f(a: &dyn MyTrait) {}\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust struct with methods for data access\nDESCRIPTION: This Rust code defines a struct `MyTempDir` that wraps a `tempdir::TempDir` and provides methods to interact with it. The methods `directory_path` and `read_text` are exposed to Dart to access the underlying temporary directory's path and read the contents of a file within it, respectively. Requires the `tempdir` crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/using-data.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyTempDir {\n    dir: tempdir::TempDir,\n}\n\nimpl MyTempDir {\n    pub fn new() -> Self { ... }\n\n    pub fn directory_path(&self) -> String {\n        self.dir.path()\n    }\n\n    pub fn read_text(&self, filename: String) -> String {\n        fs::read_to_string(self.dir.path().join(filename))\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rust API Function Example: loop_back with DartOpaque Parameter\nDESCRIPTION: Example Rust API function `loop_back` simply returning the passed `DartOpaque` argument. Demonstrates basic usage where a Dart closure or object can be passed to Rust wrapped in `DartOpaque` and returned transparently, verifying safe handle transfer without copying or invalidating the handle.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\npub fn loop_back(opaque: DartOpaque) -> DartOpaque {\n    opaque\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Build-time Dependencies\nDESCRIPTION: This snippet demonstrates how to install build-time dependencies for a Dart project using `cargo install` and `dart pub add`. This includes the core codegen, and tools like `ffigen` and `cargo-xcode` which are useful when building iOS and MacOS targets. It leverages `cargo` to install Rust dependencies and `dart pub add` to add Dart dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/02-deps.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\ndart pub add --dev ffigen && dart pub add ffi\n# if building for iOS or MacOS\ncargo install cargo-xcode\n```\n\n----------------------------------------\n\nTITLE: Using Thread Pool to Execute Code in Rust\nDESCRIPTION: This snippet shows how to execute code asynchronously using a thread pool provided by the `thread_pool()` method. It employs the `execute()` function to run a closure in a separate thread, with the `transfer!` macro handling data transfer for cross-thread and WASM compatibility.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/cross-platform/thread-pool.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nFLUTTER_RUST_BRIDGE_HANDLER.thread_pool().execute(transfer!(|| {\n    // your code executed in another thread\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Rust Function in Flutter Rust Bridge\nDESCRIPTION: Example of a basic Rust function that takes a string and repeats it twice. This is placed in the rust/src/api/simple.rs file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn hello(a: String) -> String { a.repeat(2) }\n```\n\n----------------------------------------\n\nTITLE: Calling Rust methods from Dart\nDESCRIPTION: This Dart code demonstrates how to call the Rust methods defined in the `MyTempDir` struct. It instantiates `MyTempDir` (using `newMyTempDir` generated by flutter_rust_bridge), then calls `directoryPath` and `readText` to access the temporary directory's path and read the contents of a file. It uses `await` because the calls are asynchronous.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/using-data.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nvar d = await MyTempDir.newMyTempDir();\nprint(await d.directoryPath());\nprint(await d.readText('a.txt'));\n```\n\n----------------------------------------\n\nTITLE: Initializing RustLib with Custom Parameters (Dart)\nDESCRIPTION: This Dart code snippet shows how to initialize the Rust library (`RustLib`) using the `init()` method and pass custom parameters. The `someCustomizableParameter` is a placeholder for actual configuration options. Refer to the method signature for a full list of available parameters.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/dart/constructors.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nawait RustLib.init(someCustomizableParameter: someValue);\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Metadata and Build Types in CMake (CMake)\nDESCRIPTION: This code snippet initializes the CMake build configuration for a Flutter-based desktop application. It specifies the required CMake version, the project metadata (including languages), executable names, application identifiers, and establishes modern CMake policies. Dependencies such as GTK are located, and default build types with selectable configurations ('Debug', 'Profile', 'Release') are defined. No external dependencies beyond system packages and Flutter are required.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\nproject(runner LANGUAGES CXX)\nset(BINARY_NAME \"flutter_package_example\")\nset(APPLICATION_ID \"com.example.flutter_package\")\ncmake_policy(SET CMP0063 NEW)\nset(CMAKE_INSTALL_RPATH \"$ORIGIN/lib\")\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE STRING \"Flutter build mode\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Profile\" \"Release\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Dart FFI Stub Implementation\nDESCRIPTION: This Dart code snippet creates a stub implementation for the FFI (Foreign Function Interface) layer.  It defines a `createWrapperImpl` function that throws an `UnimplementedError`, serving as a placeholder for platform-specific implementations (IO or Web). It imports the `bridge_generated.dart` file which is generated by `ffigen` and provides a common interface for calling Rust code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\n/// Represents the external library for $LIBNAME\n///\n/// Will be a DynamicLibrary for dart:io or WasmModule for dart:html\ntypedef ExternalLibrary = Object;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary lib) =>\n    throw UnimplementedError();\n```\n\n----------------------------------------\n\nTITLE: Dart Example: Passing Closure to Rust with loopBack\nDESCRIPTION: Dart snippet that defines a closure returning a string, passes it via `loopBack` Rust API call expecting a DartOpaque, then casts back to a Dart function and validate the return value. Highlights integration of Dart closures passed through FFI wrapped in `DartOpaque` objects.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nString f() => 'Test_String';\n\nvar fn = await api.loopBack(opaque: f) as String Function();\n\nexpect(fn(), 'Test_String');\n```\n\n----------------------------------------\n\nTITLE: Rust API Definition\nDESCRIPTION: Defines two simple Rust functions, `simple_add` and `simple_minus`, representing the original API structure before classification into separate files. These functions take two 32-bit integers as input and return their sum or difference, respectively.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(unused_variables)]\n\npub fn simple_add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\npub fn simple_minus(a: i32, b: i32) -> i32 {\n    a - b\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Result Return in Rust\nDESCRIPTION: This Rust code demonstrates a function that returns an i32 directly. It simply adds two i32 integers together and returns the result. This is a straightforward example of a function with no error handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn f(a: i32, b: i32) -> i32 { a + b }\n```\n\n----------------------------------------\n\nTITLE: Dart FFI Web Implementation\nDESCRIPTION: This Dart code provides an implementation of the FFI layer for web platforms.  It defines `ExternalLibrary` as `WasmModule` and imports the flutter_rust_bridge package for Wasm support. The `createWrapperImpl` function creates an instance of `${DART_CLASS_NAME}Impl.wasm` using the provided Wasm module. This facilitates calling Rust functions compiled to WebAssembly from Dart web applications.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:$LIBNAME/src/bridge_generated.dart';\nimport 'package:flutter_rust_bridge/flutter_rust_bridge.dart';\n\ntypedef ExternalLibrary = WasmModule;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary module) =>\n    ${DART_CLASS_NAME}Impl.wasm(module);\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust API function to be exposed\nDESCRIPTION: Creates a simple Rust function 'greet' that returns a greeting string, intended for exposing via bindings. Dependencies are minimal, primarily standard Rust libraries. This function serves as an example API endpoint for the generated bindings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_gen.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn greet() -> String {\n    \"Hello from Rust! 🦀\".into()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pubspec.yaml for Flutter ffiPlugin Platforms\nDESCRIPTION: This YAML snippet modifies the Flutter plugin configuration to specify support for multiple platforms using ffi plugins. It instructs Flutter to handle binaries for iOS, macOS, Android, Linux, and Windows, streamlining platform-specific binary bundling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nflutter:\n  plugin:\n    platforms:\n      ios:\n        ffiPlugin: true\n      macos:\n        ffiPlugin: true\n      android:\n        ffiPlugin: true\n      linux:\n        ffiPlugin: true\n      windows:\n        ffiPlugin: true\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Crate Type in Cargo.toml\nDESCRIPTION: Add these lines to the `[lib]` section of your Rust crate's `Cargo.toml` file. This configuration sets the crate to build as both a static library (`staticlib`) for platforms like MacOS/iOS and a dynamic library (`cdylib`) for others, which is necessary for `flutter_rust_bridge` usage. Optionally add `\"rlib\"` for development tasks like testing.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/new_crate.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n+[lib]\n+crate-type = [\"staticlib\", \"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Crate Type in Cargo.toml (Rust)\nDESCRIPTION: This code snippet shows how to configure the crate type in the `Cargo.toml` file for a Rust crate intended to be used with Flutter Rust Bridge.  It specifies that the crate should be built as a static library (`staticlib`) for MacOS and iOS, and as a dynamic library (`cdylib`) for other platforms. This ensures compatibility with different target platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/01-new-crate.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n+[lib]\n+crate-type = [\"staticlib\", \"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Transferring Full Ownership to Rust for Unwrapping in Dart\nDESCRIPTION: Shows how to transfer full ownership of an opaque type from Dart to Rust, enabling safe unwrapping on the Rust side. The move flag signals that Dart is relinquishing ownership control.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// When passed as an argument, dart will relinquish ownership.\nopaque.move = true;\n\n// (Arc counter = 1) Rust has full ownership.\n// On the Rust side, the Arc unwrap safely \n// as the Rust has full ownership of the opaque type. \n// Memory is cleared in the usual way Rust.\nawait api.unwrapRustOpaque(opaque: data);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Application Target and Linking Dependencies - CMake\nDESCRIPTION: This snippet creates the main executable target for the application using CMake's add_executable, specifying the source files required for compilation. It then applies standard settings and links the target to the Flutter and GTK libraries—dependencies necessary for the application's UI and runtime. Dependencies include the GTK development libraries, Flutter runtime, and any generated plugin registrant code. The BINARY_NAME variable determines the output executable’s name, and the configuration ensures proper runtime library paths.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n\napply_standard_settings(${BINARY_NAME})\n\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Adding Executable Target with CMake\nDESCRIPTION: This snippet adds an executable target named ${BINARY_NAME} and specifies the source files to be compiled. These source files makes up the executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring flutter_rust_bridge via .flutter_rust_bridge.yml (YAML)\nDESCRIPTION: Provides an example of configuring the `flutter_rust_bridge_codegen` tool using a dedicated YAML file (`.flutter_rust_bridge.yml`). It specifies the input Rust API file path(s) under `rust_input` and the output Dart generated file path(s) under `dart_output`. This file is automatically detected if present in the working directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/command_line.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# in .flutter_rust_bridge.yml\nrust_input:\n  - path/to/api.rs\ndart_output:\n  - path/to/bridge_generated.dart\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Settings App Wrapper\nDESCRIPTION: This snippet applies standard settings to the app wrapper target. These settings are project-wide conventions, ensuring that the project builds consistently.  This typically loads other CMake configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(flutter_wrapper_app)\n```\n\n----------------------------------------\n\nTITLE: Translating Rust Vec<TreeNode> and Vec<u8> to Dart types\nDESCRIPTION: Example showing how Rust's Vec<TreeNode> and Vec<u8> are converted to Dart's List<TreeNode> and Uint8List respectively when using flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/vec.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn draw_tree(tree: Vec<TreeNode>) -> Vec<u8> { ... }\n```\n\nLANGUAGE: dart\nCODE:\n```\nFuture<Uint8List> drawTree({required List<TreeNode> tree});\n```\n\n----------------------------------------\n\nTITLE: Set Minimum Dart SDK Version to >=2.17.0 for FFI Compatibility\nDESCRIPTION: Requires updating 'pubspec.yaml' environment to specify Dart SDK version >=2.17.0, necessary for compatibility with the 'ffigen' tool and Flutter projects using recent SDK features.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for iOS and macOS Support\nDESCRIPTION: This snippet configures the `Cargo.toml` file to specify the crate types required for iOS and macOS compatibility.  `staticlib` is needed for iOS, and `cdylib` is necessary for other platforms, along with `lib` for non-library targets like tests.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/01-proj.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[lib]\ncrate-type = [\"lib\", \"staticlib\", \"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configuration Options with CMake\nDESCRIPTION: This snippet defines the build configuration options (Debug, Profile, Release). It sets the CMAKE_BUILD_TYPE if it's not already set.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n    STRING \"Flutter build mode\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n    \"Debug\" \"Profile\" \"Release\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Updating Platform Enum in Rust\nDESCRIPTION: This snippet demonstrates modifying the Platform enum definition in Rust by replacing separate MacIntel and MacApple variants with a single MacOs(String) variant that stores the CPU architecture as a string. This allows downstream code to handle macOS-specific logic in a unified way, reducing redundancy. No external dependencies are required beyond the Rust standard library, and no additional constraints are imposed; ensure all code referencing Platform is updated accordingly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_adding_code.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n pub enum Platform {\n     ..\n-    MacIntel,\n-    MacApple,\n+    MacOs(String),\n     ..\n }\n```\n\n----------------------------------------\n\nTITLE: Defining a Method Returning a Reference Requiring Proxy in Rust\nDESCRIPTION: Defines Rust structs `BiquadFilterNode` and `AudioParam`. The `frequency` method returns a reference `&AudioParam`, highlighting a case where `#[frb(proxy)]` is needed because `flutter_rust_bridge` doesn't directly support returning references without it. The `#[frb(opaque)]` annotation suggests `BiquadFilterNode` is treated as an opaque type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/proxy.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(opaque)]\npub struct BiquadFilterNode {\n    frequency: AudioParam,\n}\n\nimpl BiquadFilterNode {\n    // Add #[frb(proxy)] here to make it work\n    pub fn frequency(&self) -> &AudioParam {\n        &self.frequency\n    }\n}\n\npub struct AudioParam { /* ... */ }\n\nimpl AudioParam {\n    pub fn my_method_one(&self, value: f32) { /* ... */ }\n    pub fn my_method_two(&self, value: f32) { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming function with frb attribute - Rust\nDESCRIPTION: This code snippet shows how to rename a Rust function to `g` on the Dart side using the `#[frb(name = \"g\")]` attribute. When the flutter_rust_bridge generator runs, it will create a Dart function named `g` that calls the Rust function `f`. This allows you to customize the Dart API without changing the Rust implementation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/renaming.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(name = \"g\")]\npub fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Platform-specific LLVM installation commands for ffigen\nDESCRIPTION: Provides commands for installing LLVM on Windows, macOS, and Linux (using apt-get and dnf). These commands are prerequisites for the ffigen package used by flutter_rust_bridge, ensuring correct setup of LLVM for code generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/ffigen-troubleshooting.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Windows\n\n1. Install Visual Studio with C++ support.\n2. Install LLVM: `winget install -e --id LLVM.LLVM`.\n\n# MacOS\n\n1. Install Xcode.\n2. Install command line tools: `xcode-select --install`.\n3. Install LLVM via Homebrew: `brew install llvm`.\n\n# Linux apt-get\n\nInstall libclang: `sudo apt-get install libclang-dev`.\n\n# Linux dnf\n\nInstall libclang: `sudo dnf install clang-devel`.\n```\n\n----------------------------------------\n\nTITLE: CI Workflow for Rust/Flutter Library\nDESCRIPTION: This YAML file defines the Continuous Integration workflow for building, testing, and analyzing the Rust and Flutter code.  It runs on Ubuntu, macOS, and Windows environments for integration tests. It includes steps to check code formatting, perform static analysis (clippy and analyze), run unit tests, and build the code for different platforms and devices. It utilizes tools like `melos` for package management and Flutter/Rust tooling. The `library_name` and `LibraryName` are placeholders.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nname: Build & Test\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  # General build, check, and test steps\n  build_and_test:\n    runs-on: ubuntu-latest\n\n    steps:\n      # Setup\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n          components: rustfmt, clippy\n\n      # Rust\n      - name: Check Rust format\n        working-directory: ./packages/library_name/native/src\n        run: rustfmt --check lib.rs\n      - name: Rust code analysis\n        run: cargo clippy -- -D warnings\n      - name: Run Rust tests\n        run: cargo test\n      - name: Build Rust code for Dart tests\n        run: cargo build -r\n\n      # Dart/Flutter\n      - name: Check Dart format\n        run: melos run check-format --no-select\n      - name: Dart code analysis\n        run: melos run analyze --no-select\n      - name: Run Dart tests\n        run: melos run test\n\n  macos_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the XCFramework\n        run: melos run build:apple\n      - name: Copy the XCFramework to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/macos/Frameworks/$CURR_VERSION.zip\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d macos integration_test\n\n  windows_integration_test:\n    runs-on: windows-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the binaries\n        run: melos run build:other\n      - name: Copy the binaries to the needed location\n        shell: bash\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/other.tar.gz packages/flutter_library_name/windows/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d windows integration_test\n\n  linux_integration_test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install dependencies for flutter integration test\n        run: sudo apt update && sudo apt-get install -y libglu1-mesa ninja-build clang cmake pkg-config libgtk-3-dev liblzma-dev\n      - uses: pyvista/setup-headless-display-action@v1\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the binaries\n        run: melos run build:other\n      - name: Copy the binaries to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/other.tar.gz packages/flutter_library_name/linux/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d linux integration_test\n\n  ios_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Start iOS Simulator\n        run: |\n          DEVICE_ID=$(xcrun xctrace list devices | grep iPhone | head -1 | awk '{print $NF}' | tr -d '()')\n          echo \"DEVICE_ID=$DEVICE_ID\" >> $GITHUB_ENV\n          xcrun simctl boot $DEVICE_ID\n\n      - name: Build the XCFramework\n        run: melos run build:apple\n      - name: Copy the XCFramework to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/ios/Frameworks/$CURR_VERSION.zip\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d ${{ env.DEVICE_ID }} integration_test\n\n  android_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n      - uses: nttld/setup-ndk@v1\n        with:\n          ndk-version: r25b\n      - uses: actions/setup-java@v3\n        with:\n          distribution: zulu\n          java-version: \"11.x\"\n\n      - name: Build the binaries\n        run: melos run build:android\n      - name: Copy the binaries to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/android.tar.gz packages/flutter_library_name/android/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        uses: Wandalen/wretry.action@master # sometimes android tests are flaky\n        with:\n          attempt_limit: 5\n          action: reactivecircus/android-emulator-runner@v2\n          with: |\n            api-level: 33\n            target: google_apis\n            arch: x86_64\n            ram-size: 1024M\n            disk-size: 2048M\n            script: cd packages/flutter_library_name/example && flutter test -d `flutter devices | grep android | tr ' ' '\\n' | grep emulator-` integration_test\n```\n\n----------------------------------------\n\nTITLE: Adding Rust targets for Android cross-compilation\nDESCRIPTION: Adds the necessary Rust targets for cross-compiling to various Android architectures. This is required to build Rust code that can run on Android devices. The targets include aarch64-linux-android, armv7-linux-androideabi, x86_64-linux-android, and i686-linux-android.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/01-setup/01-android.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add \\\n    aarch64-linux-android \\\n    armv7-linux-androideabi \\\n    x86_64-linux-android \\\n    i686-linux-android\n```\n\n----------------------------------------\n\nTITLE: Concurrent Invocation of Rust Functions Using Dart Futures\nDESCRIPTION: This Dart code snippet shows how to concurrently call the synchronous Rust `compute` function three times and wait for all to complete using `Future.wait()`. It illustrates asynchronous Dart programming that enables multiple Rust calls to run concurrently on the thread pool. Dependencies include the Flutter-Rust-Bridge integration for Dart and Dart's async/await capabilities. Variables `a`, `b`, and `c` hold Future results of the Rust calls, with the final awaited Future ensuring the program waits for all computations before proceeding.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/sync-rust.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvar a = compute();\nvar b = compute();\nvar c = compute();\nawait Future.wait([a, b, c]); // You may need to learn `Future` and `async` in Dart to understand this\n```\n\n----------------------------------------\n\nTITLE: Concurrent Function Calls with RustOpaque in Dart\nDESCRIPTION: Demonstrates using the same RustOpaque in multiple concurrent function calls and disposing it before the calls complete. This pattern shows how reference counting manages shared ownership in asynchronous contexts.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \nvar unawait_task1 = api.runOpaque(opaque); *1\n\n// (Arc counter = 3) increases immediately. \nvar unawait_task2 = api.runOpaque(opaque); *2\n\n// (Arc counter = 2) Rust has full ownership\nopaque.dispose();\n\n// (*1 is complete) (Arc counter = 1)\n//\n// Rust:\n//\n//`executes rust_call_example and counter decreases.`\n\n// (*2 is complete) (Arc counter = 0) \n// opaque type is dropped (deallocated)\n//\n// Rust:\n//\n//`executes rust_call_example and drop opaque type.`\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Windows Runner Build Using CMake - CMake\nDESCRIPTION: This snippet provides a CMake build configuration for the Windows runner in a Flutter project. It defines an executable target, specifies relevant source and resource files, applies standard settings, and adds preprocessor definitions for Flutter version information. Dependencies are managed via target_link_libraries and include directories, and the script integrates the Flutter build tool with add_dependencies. This script requires CMake version 3.14 or higher and assumes dependencies such as Flutter, flutter_wrapper_app, and dwmapi.lib are available; you should set the BINARY_NAME and FLUTTER_MANAGED_DIR variables in a parent CMake file. The input is interpreted by the CMake build system, which generates native build files for your IDE or build tool.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(runner LANGUAGES CXX)\n\n# Define the application target. To change its name, change BINARY_NAME in the\n# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer\n# work.\n#\n# Any new source files that you add to the application should be added here.\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n\n# Apply the standard set of build settings. This can be removed for applications\n# that need different build settings.\napply_standard_settings(${BINARY_NAME})\n\n# Add preprocessor definitions for the build version.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n\n# Disable Windows macros that collide with C++ standard library functions.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n\n# Add dependency libraries and include directories. Add any application-specific\n# dependencies here.\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n\n```\n\n----------------------------------------\n\nTITLE: Building Rust Libraries for Android with cargo-ndk\nDESCRIPTION: Shell script to compile Rust code for multiple Android architectures using cargo-ndk, and create a compressed archive of the resulting libraries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/android.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Create the jniLibs build directory\nJNI_DIR=jniLibs\nmkdir -p $JNI_DIR\n\n# Set up cargo-ndk\ncargo install cargo-ndk\nrustup target add \\\n        aarch64-linux-android \\\n        armv7-linux-androideabi \\\n        x86_64-linux-android \\\n        i686-linux-android\n\n# Build the android libraries in the jniLibs directory\ncargo ndk -o $JNI_DIR \\\n        --manifest-path ../Cargo.toml \\\n        -t armeabi-v7a \\\n        -t arm64-v8a \\\n        -t x86 \\\n        -t x86_64 \\\n        build --release \n\n# Archive the dynamic libs\ncd $JNI_DIR\ntar -czvf ../android.tar.gz *\ncd -\n\n# Cleanup\nrm -rf $JNI_DIR\n```\n\n----------------------------------------\n\nTITLE: Converting Rust Vec<u8> to Dart Uint8List\nDESCRIPTION: This snippet demonstrates the translation of a Rust function that returns a `Vec<u8>` to a Dart function that returns a `Uint8List`.  `flutter_rust_bridge` handles this conversion automatically, recognizing `Vec<u8>` as a byte array that should be represented as `Uint8List` for improved performance in Dart.  No specific parameters are passed to control this translation; it's based on the function signature.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_vec.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn draw_tree(tree: Vec<TreeNode>) -> Vec<u8> { ... }\n```\n\n----------------------------------------\n\nTITLE: Generate Dart bindings from Rust\nDESCRIPTION: This command uses `flutter_rust_bridge_codegen` to generate Dart bindings from the Rust API definition file.  It takes the Rust input file and the desired Dart output file as arguments and creates the `bridge_generated.dart` file which allows Dart to call Rust functions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial_pure_dart.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nflutter_rust_bridge_codegen --rust-input frb_example/pure_dart/rust/src/api.rs --dart-output frb_example/pure_dart/dart/lib/bridge_generated.dart\n```\n\n----------------------------------------\n\nTITLE: Running Flutter_Rust_Bridge Code Generator\nDESCRIPTION: This snippet demonstrates the command-line usage of the `flutter_rust_bridge_codegen` tool. It takes a Rust input file and generates a Dart output file. The `--rust-input` option specifies the path to the Rust API file, and the `--dart-output` option specifies the output path for the generated Dart bindings.  It requires the code generator to be installed correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/quickstart.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nflutter_rust_bridge_codegen --rust-input path/to/api.rs \\\n                            --dart-output path/to/bridge_generated.dart\n```\n\n----------------------------------------\n\nTITLE: Updating Justfile to Run Build Runner After Rust Codegen\nDESCRIPTION: This DIFF snippet demonstrates how to uncomment or add a line in a justfile to ensure that the Flutter build_runner command is executed after Rust code generation. It modifies the gen recipe so that Dart code generation via build_runner runs after Rust bindings are produced. This step is necessary for incorporating automatically generated code from Freezed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_build_runner.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n gen:\n     ..\n     # Uncomment this line to invoke build_runner as well\n-    # flutter pub run build_runner build\n+    flutter pub run build_runner build\n```\n\n----------------------------------------\n\nTITLE: Handling Custom Error in Dart\nDESCRIPTION: This Dart code demonstrates how to catch the `CustomError` that is returned from Rust. It uses a `try-catch` block to catch the exception and asserts that the caught exception is an instance of `CustomError`. The example assumes that the Dart api is already set up.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\ntry {\n    final r = await api.returnErrCustomError();\n    print(\"received $r\");\n} catch (e) {\n    print('dart catch e: $e');\n    expect(e, isA<CustomError>());\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Dart Package in Flutter Library\nDESCRIPTION: Dart code to re-export the underlying Dart-only package to users of the Flutter package. This allows users to access all functionality with a single dependency.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nexport 'package:library_name/library_name.dart';\n```\n\n----------------------------------------\n\nTITLE: Installing Rust targets for iOS cross-compilation\nDESCRIPTION: This command set adds the required Rust compilation targets for iOS development. It includes targets for 64-bit devices (real and simulator) and optionally 32-bit targets, with special note of the newer simulator target needed for Xcode 12 and later.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/01-setup/02-ios.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# 64 bit targets (real device & simulator):\nrustup target add aarch64-apple-ios x86_64-apple-ios\n# New simulator target for Xcode 12 and later\nrustup target add aarch64-apple-ios-sim\n# 32 bit targets (you probably don't need these):\nrustup target add armv7-apple-ios i386-apple-ios\n```\n\n----------------------------------------\n\nTITLE: Managing Installation and Asset Bundling for Flutter Application (CMake)\nDESCRIPTION: Implements install rules for building standalone application bundles. The snippet ensures a clean build for each install, copies dependencies including native libraries and Flutter assets, sets output locations to avoid accidental execution outside bundles, and conditionally includes AOT libraries for non-debug builds. Requires correct setting of build and asset directories. This robust asset/install configuration is crucial for ensuring consistent deployment and correct file structure of desktop Flutter/Rust apps.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\")\n  \" COMPONENT Runtime)\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories for Flutter\nDESCRIPTION: This snippet adds include directories for the `flutter` interface library. The interface library is used to define the project's include directories for other targets.  The `INTERFACE` keyword specifies that the target's include directories are propagated to other targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing WASM module for Flutter Rust Bridge on Web\nDESCRIPTION: Creates a wrapper to consume the bridge files by importing the WASM module generated by wasm_bindgen, initializing the wasmModule, and creating the implementation class.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/06-web.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nimport 'bridge_generated.web.dart';\nexport 'bridge_definitions.dart';\n\nimport 'dart:html';\n\n// Path to the wasm_bindgen generated files\nconst root = 'pkg/native';\nfinal api = NativeImpl.wasm(WasmModule.initialize(\n    kind: const Modules.noModules(root: root),\n));\n```\n\n----------------------------------------\n\nTITLE: Compute Function in Rust\nDESCRIPTION: This Rust code defines a function `compute` that simulates a time-consuming operation by pausing the current thread for 1000 milliseconds (1 second). It uses the `thread::sleep` function from the standard library and the `Duration` struct to specify the sleep duration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/concurrency.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn compute() {\n  thread::sleep(Duration::from_millis(1000));\n}\n```\n\n----------------------------------------\n\nTITLE: Calling WordDict Rust API from Dart Asynchronously with Stream Support\nDESCRIPTION: Shows Dart code invoking the Rust WordDict API exposed by flutter_rust_bridge. This snippet illustrates opening the dictionary asynchronously with a callback chooser, accessing the synchronous size property, and asynchronously iterating over the search results stream. The Dart code depends on the flutter_rust_bridge-generated bindings to handle async Dart-Rust communication and stream conversions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Updating Dart Code with Freezed Enum Pattern Matching\nDESCRIPTION: This diff shows how to replace a manual platform mapping with freezed's when() method for more type-safe and exhaustive pattern matching on a Platform enum.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/04-finish.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- final text = const {\n-   Platform.Android: 'Android',\n-   Platform.Ios: 'iOS',\n-   Platform.MacApple: 'MacOS with Apple Silicon',\n-   Platform.MacIntel: 'MacOS',\n-   Platform.Windows: 'Windows',\n-   Platform.Unix: 'Unix',\n-   Platform.Wasm: 'the Web',\n- }[platform] ??\n- 'Unknown OS';\n+ final text = platform.when(\n+   android: () => 'Android',\n+   ios: () => 'iOS',\n+   macOs: (arch) => 'MacOS on $arch',\n+   windows: () => 'Windows',\n+   unix: () => 'Unix',\n+   wasm: () => 'the Web',\n+ );\n```\n\n----------------------------------------\n\nTITLE: Declaring Flutter ffiPlugin Platforms in pubspec.yaml (YAML)\nDESCRIPTION: This YAML snippet configures the Flutter plugin system in the pubspec.yaml file to use the newer ffiPlugin format across supported platforms including iOS, macOS, Android, Linux, and Windows. By setting `ffiPlugin: true` under each platform, the package opts into using native FFI bindings instead of Flutter's older platform channels. This is essential for enabling direct calls to the Rust binaries bundled with the package. This snippet must be added to the Flutter wrapper package's pubspec.yaml file, typically near the bottom, to ensure correct integration and simplified native binary usage across platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nflutter:\n  plugin:\n    platforms:\n      ios:\n        ffiPlugin: true\n      macos:\n        ffiPlugin: true\n      android:\n        ffiPlugin: true\n      linux:\n        ffiPlugin: true\n      windows:\n        ffiPlugin: true\n```\n\n----------------------------------------\n\nTITLE: Generated Dart classes for opaque and non-opaque Rust types\nDESCRIPTION: This Dart snippet shows the code generated by flutter_rust_bridge for the corresponding Rust structs. class A is generated as a typical Dart class mirroring the Rust struct's fields (as it's non-opaque). class B, corresponding to the #[frb(opaque)] Rust struct, is generated as a class extending RustAutoOpaque, indicating it's a handle to an opaque Rust type that must be manipulated via Rust calls.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/override-defaults.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// A pretty standard Dart class with fields inside it\nclass A { String name; ... }\n\n// A Dart class without data fields, you should pass it to Rust to manipulate it\nclass B extends RustAutoOpaque { ... }\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Code for Imported Types\nDESCRIPTION: This Dart code snippet shows the automatically generated Dart function `useImportedThings` corresponding to the Rust function `use_imported_things`.  It expects MyStruct and MyEnum as required parameters.  The return type is a Future<void>, indicating an asynchronous operation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/external/same-crate.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Well it just behaves normally as you expect\nFuture<void> useImportedThings({required MyStruct myStruct, required MyEnum myEnum});\n```\n\n----------------------------------------\n\nTITLE: Adding dummy header for Flutter Rust Bridge on MacOS\nDESCRIPTION: Configure the Objective-C Bridging Header in Build Settings to point to the generated bridge header file, which is necessary because Flutter on MacOS doesn't inject headers by default.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/macos.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nRunner/bridge_generated.h\n```\n\n----------------------------------------\n\nTITLE: Dart usage example with DartOpaque objects\nDESCRIPTION: Shows how to use `DartOpaque` in Dart to call Rust functions, demonstrating passing a Dart object wrapped as `DartOpaque` and receiving an opaque object from Rust. The example casts the returned object to a function type and executes it, illustrating identity preservation and callable object handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_dart_opaque.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvar opaque = await api.getDartOpaque(() => '42');\nObject answer_obj = await api.returnDartOpaque();\nvar fn = answer_obj as String Function();\nprint(fn());\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization in Rust\nDESCRIPTION: This Rust code snippet defines a function `f` that receives a JSON string as input, deserializes it into a Rust object using `serde_json::from_str`, performs some operation (not shown here), and then serializes a Rust object into a JSON string using `serde_json::json!` and returns it. It utilizes the `serde_json` crate for JSON serialization and deserialization. The function returns a `Result` type, allowing for error handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/protobuf-json.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Rust\npub fn f(a: String) -> Result<String> {\n    let arg = serde_json::from_str(&a)?;\n    Ok(json!({\"some\": \"result\", \"is\": [42]}).to_string())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Executable Target\nDESCRIPTION: Defines the executable target with the name specified by BINARY_NAME and lists the source files to be compiled into the executable. The WIN32 keyword indicates that this is a Windows application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n```\n\n----------------------------------------\n\nTITLE: Calling Opaque Type Functions from Dart\nDESCRIPTION: Demonstrates how to call the Rust functions that operate on the opaque `MyNonEncodableType` from Dart code. It shows the asynchronous nature of FFI calls and how the Dart variable `object` represents the opaque Rust object, allowing it to be passed to different Rust functions corresponding to creation, borrowing, and consumption.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/overview.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nvar object = await create();\nawait borrow(object);\nawait mutable_borrow(object);\nawait consume(object);\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList Component in Markdown Documentation (JavaScript)\nDESCRIPTION: This snippet imports the DocCardList component from the @theme package and embeds it within a Markdown document using mdx-code-block syntax. The DocCardList component is a React element provided by the documentation framework, allowing dynamic listing of doc cards. Prerequisites include a documentation site built with Docusaurus or a compatible MDX/React-based documentation system with the @theme/DocCardList module available. Inputs include the Markdown/MDX document context. Outputs are interactive documentation card lists rendered in the documentation UI. The code must be used in supported documentation environments and is not suitable for plain Markdown viewers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Approach 1: Using Tokio's Main Macro for Async to Sync Conversion\nDESCRIPTION: Converting an async function to synchronous using the tokio::main macro. This approach creates a Tokio runtime automatically.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow;\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Shell Script: Copying Files for Apple Integration Tests\nDESCRIPTION: This shell script copies the XCFramework zip file to the specified location for Apple (macOS and iOS) integration tests. It determines the current version by parsing the pubspec.yaml file. It uses `awk` to get the version number and constructs the CURR_VERSION variable, then copies the zip file to the appropriate macOS or iOS Frameworks directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\ncp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/macos/Frameworks/$CURR_VERSION.zip\necho Copied file!\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Function for Log Stream\nDESCRIPTION: Defines a Dart function that returns a Stream of LogEntry objects, allowing Dart code to subscribe and listen to logs streamed from Rust. Facilitates integration of logging data into Dart application workflows.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nStream<LogEntry> createLogStream();\n```\n\n----------------------------------------\n\nTITLE: Unwrapping RustOpaque in Flutter/Rust Bridge - Dart\nDESCRIPTION: This Dart code demonstrates the usage of unwrapRustOpaque which will relinquish the ownership. It creates a RustOpaque using `createOpaque` and passes it to the `unwrapRustOpaque` function. The `opaque.move = true;` line relinquishes Dart's ownership. The Rust side then has full ownership, and the associated memory is cleared in Rust's usual way. The function relies on the Flutter/Rust bridge for the method: `unwrapRustOpaque` and its parameters.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// When passed as an argument, dart will relinquish ownership.\nopaque.move = true;\n\n// (Arc counter = 1) Rust has full ownership.\n// On the Rust side, the Arc unwrap safely \n// as the Rust has full ownership of the opaque type. \n// Memory is cleared in the usual way Rust.\nawait api.unwrapRustOpaque(opaque: data);\n```\n\n----------------------------------------\n\nTITLE: Running code generator\nDESCRIPTION: These commands execute the Flutter Rust Bridge code generator. The first command generates Dart code for the pure_dart example, and the second generates Dart and C code for the with_flutter example. Key parameters include rust-input (Rust API file), dart-output (Dart output file), c-output (C output file), and dart-format-line-length.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/appendix.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n(cd frb_codegen && cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/pure_dart/rust/src/api.rs --dart-output ../frb_example/pure_dart/dart/lib/bridge_generated.dart --dart-format-line-length 120 && cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/with_flutter/rust/src/api.rs --dart-output ../frb_example/with_flutter/lib/bridge_generated.dart --c-output ../frb_example/with_flutter/ios/Runner/bridge_generated.h --dart-format-line-length 120)\n```\n\n----------------------------------------\n\nTITLE: Dart Isolate Initialization and Disposal\nDESCRIPTION: This snippet outlines the necessary steps to use Dart Isolates with flutter_rust_bridge.  It explains that the user should call `RustLib.init()` when an isolate starts and `RustLib.dispose()` when it stops, similar to managing Flutter objects. No other dependencies are explicitly mentioned, but it is assumed the `RustLib` class is properly set up through `flutter_rust_bridge` to facilitate communication with Rust code. The primary input is the starting and stopping of the isolate. The output involves initialization and disposal of resources related to Rust code within the isolate. There is a note to not worry about using Dart isolates unless the user requires them.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/miscellaneous/isolates.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nTo use Dart Isolates, just call `RustLib.init()` and `RustLib.dispose()` when your isolate starts and stops,\njust like how you deal with many standard Flutter objects.\n```\n\n----------------------------------------\n\nTITLE: Monorepo Initialization Script (Bash)\nDESCRIPTION: This bash script automates the creation of a new Flutter Rust Bridge monorepo. It sets up the directory structure, initializes Git, creates necessary files like `Cargo.toml`, `analysis_options.yaml`, and `.gitignore`, and configures Dart and Rust components. The script uses `cat << EOF` to create files with specified content and `dart create` to generate a Dart package.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLIBNAME=library_name # snake_case\nDART_CLASS_NAME=LibraryName # probably is PascalCase version of $LIBNAME\n\n# Monorepo setup\nmkdir -p $LIBNAME/packages\ncd $LIBNAME\ngit init\n\ncat << EOF >> Cargo.toml\n[workspace]\nmembers = [\"packages/$LIBNAME/native\"]\nEOF\n\ncat << EOF >> analysis_options.yaml\n# TODO change the below options/lints as you see fit\nanalyzer:\n  exclude:\n    - '**.freezed.dart'\n    - '**.g.dart'\n  language:\n    strict-inference: true\n    strict-raw-types: true\n  errors:\n    invalid_annotation_target: ignore\n\nlinter:\n  rules:\n    # Custom lints\n    - prefer_single_quotes\n\n    # Core Dart lints\n    - avoid_empty_else\n    - avoid_relative_lib_imports\n    - avoid_shadowing_type_parameters\n    - avoid_types_as_parameter_names\n    - await_only_futures\n    - camel_case_extensions\n    - camel_case_types\n    - curly_braces_in_flow_control_structures\n    - depend_on_referenced_packages\n    - empty_catches\n    - file_names\n    - hash_and_equals\n    - iterable_contains_unrelated_type\n    - list_remove_unrelated_type\n    - no_duplicate_case_values\n    - non_constant_identifier_names\n    - null_check_on_nullable_type_parameter\n    - package_prefixed_library_names\n    - prefer_generic_function_type_aliases\n    - prefer_is_empty\n    - prefer_is_not_empty\n    - prefer_iterable_whereType\n    - prefer_typing_uninitialized_variables\n    - provide_deprecation_message\n    - unnecessary_overrides\n    - unrelated_type_equality_checks\n    - valid_regexps\n    - void_checks\n\n    # Recommended Dart lints\n    - always_require_non_null_named_parameters\n    - annotate_overrides\n    - avoid_function_literals_in_foreach_calls\n    - avoid_init_to_null\n    - avoid_null_checks_in_equality_operators\n    - avoid_renaming_method_parameters\n    - avoid_return_types_on_setters\n    - avoid_returning_null_for_void\n    - avoid_single_cascade_in_expression_statements\n    - constant_identifier_names\n    - control_flow_in_finally\n    - empty_constructor_bodies\n    - empty_statements\n    - exhaustive_cases\n    - implementation_imports\n    - library_names\n    - library_prefixes\n    - library_private_types_in_public_api\n    - no_leading_underscores_for_library_prefixes\n    - no_leading_underscores_for_local_identifiers\n    - null_closures\n    - overridden_fields\n    - package_names\n    - prefer_adjacent_string_concatenation\n    - prefer_collection_literals\n    - prefer_conditional_assignment\n    - prefer_contains\n    - prefer_equal_for_default_values\n    - prefer_final_fields\n    - prefer_for_elements_to_map_fromIterable\n    - prefer_function_declarations_over_variables\n    - prefer_if_null_operators\n    - prefer_initializing_formals\n    - prefer_inlined_adds\n    - prefer_interpolation_to_compose_strings\n    - prefer_is_not_operator\n    - prefer_null_aware_operators\n    - prefer_spread_collections\n    - prefer_void_to_null\n    - recursive_getters\n    - slash_for_doc_comments\n    - type_init_formals\n    - unnecessary_brace_in_string_interps\n    - unnecessary_const\n    - unnecessary_constructor_name\n    - unnecessary_getters_setters\n    - unnecessary_late\n    - unnecessary_new\n    - unnecessary_null_aware_assignments\n    - unnecessary_null_in_if_null_operators\n    - unnecessary_nullable_for_final_variable_declarations\n    - unnecessary_string_escapes\n    - unnecessary_string_interpolations\n    - unnecessary_this\n    - use_function_type_syntax_for_parameters\n    - use_rethrow_when_possible\n\n    # Flutter lints\n    - avoid_print\n    - avoid_unnecessary_containers\n    - avoid_web_libraries_in_flutter\n    - no_logic_in_create_state\n    - prefer_const_constructors\n    - prefer_const_constructors_in_immutables\n    - prefer_const_declarations\n    - prefer_const_literals_to_create_immutables\n    - sized_box_for_whitespace\n    - sort_child_properties_last\n    - use_build_context_synchronously\n    - use_full_hex_values_for_flutter_colors\n    - use_key_in_widget_constructors\nEOF\n\ncat << EOF >> .gitignore\n# Miscellaneous\n*.class\n*.log\n*.pyc\n*.swp\n.DS_Store\n.atom/\n.buildlog/\n.history\n.svn/\n\n# IntelliJ related\n*.iml\n*.ipr\n*.iws\n.idea/\n\n# The .vscode folder contains launch configuration and tasks you configure in\n# VS Code which you may wish to be included in version control, so this line\n# is commented out by default.\n#.vscode/\n\n# Flutter/Dart/Pub related\npubspec.lock\npubspec_overrides.yaml\n**/doc/api/\n.dart_tool/\n.packages\nbuild/\n.pub-cache/\n.pub/\n.flutter-plugins\n.flutter-plugins-dependencies\n\n# Rust related\n/target/\n/Cargo.lock\n/platform-build\nEOF\n\n# Dart setup\nDART_BASE=packages/$LIBNAME\ndart create --template=package $DART_BASE\n(cd $DART_BASE && dart pub add flutter_rust_bridge ffi && dart pub add ffigen --dev)\nrm $DART_BASE/analysis_options.yaml # we provide our own in repo root\n( # ffi setup\ncd $DART_BASE\nmkdir -p lib/src/ffi\n\ncat << EOF >> lib/src/ffi/stub.dart\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\n/// Represents the external library for $LIBNAME\n///\n/// Will be a DynamicLibrary for dart:io or WasmModule for dart:html\ntypedef ExternalLibrary = Object;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary lib) =>\n    throw UnimplementedError();\nEOF\n\ncat << EOF >> lib/src/ffi/io.dart\nimport 'dart:ffi';\n\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\ntypedef ExternalLibrary = DynamicLibrary;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary dylib) =>\n    ${DART_CLASS_NAME}Impl(dylib);\nEOF\n\ncat << EOF >> lib/src/ffi/web.dart\nimport 'package:$LIBNAME/src/bridge_generated.dart';\nimport 'package:flutter_rust_bridge/flutter_rust_bridge.dart';\n\ntypedef ExternalLibrary = WasmModule;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary module) =>\n    ${DART_CLASS_NAME}Impl.wasm(module);\nEOF\n\ncat << EOF >> lib/src/ffi.dart\nimport 'bridge_generated.dart';\nimport 'ffi/stub.dart'\n    if (dart.library.io) 'ffi/io.dart'\n    if (dart.library.js_interop) 'ffi/web.dart';\n\n$DART_CLASS_NAME? _wrapper;\n\n$DART_CLASS_NAME createWrapper(ExternalLibrary lib) {\n  _wrapper ??= createWrapperImpl(lib);\n  return _wrapper!;\n}\nEOF\n\necho \"export 'src/ffi.dart';\" >> lib/$LIBNAME.dart\n)\n\n# Rust setup\nRUST_BASE=$DART_BASE/native\nmkdir -p $RUST_BASE/src\n\ncat << EOF >> $RUST_BASE/build.rs\nuse lib_flutter_rust_bridge_codegen::{\n    config_parse, frb_codegen, get_symbols_if_no_duplicates, RawOpts,\n};\n\nconst RUST_INPUT: &str = \"src/api.rs\";\nconst DART_OUTPUT: &str = \"../lib/src/bridge_generated.dart\";\n\nconst IOS_C_OUTPUT: &str = \"../../flutter_$LIBNAME/ios/Classes/frb.h\";\nconst MACOS_C_OUTPUT_DIR: &str = \"../../flutter_$LIBNAME/macos/Classes/\";\n\nfn main() {\n    // Tell Cargo that if the input Rust code changes, rerun this build script\n    println!(\"cargo:rerun-if-changed={}\", RUST_INPUT);\n\n    // Options for frb_codegen\n    let raw_opts = RawOpts {\n        rust_input: vec![RUST_INPUT.to_string()],\n        dart_output: vec![DART_OUTPUT.to_string()],\n        c_output: Some(vec![IOS_C_OUTPUT.to_string()]),\n        extra_c_output_path: Some(vec![MACOS_C_OUTPUT_DIR.to_string()]),\n        inline_rust: true,\n        wasm: true,\n        ..Default::default()\n    };\n\n    // Generate Rust & Dart ffi bridges\n    let configs = config_parse(raw_opts);\n    let all_symbols = get_symbols_if_no_duplicates(&configs).unwrap();\n    for config in configs.iter() {\n        frb_codegen(config, &all_symbols).unwrap();\n    }\n\n    // Format the generated Dart code\n    _ = std::process::Command::new(\"flutter\")\n        .arg(\"format\")\n        .arg(\"..\")\n        .spawn();\n}\nEOF\n\ncat << EOF >> $RUST_BASE/.gitignore\n# Rust library related\nCargo.lock\ntarget\nEOF\n\ncat << EOF >> $RUST_BASE/Cargo.toml\n[package]\nname = \"$LIBNAME\"\nversion = \"0.0.0\"\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\"]\n\n[build-dependencies]\nflutter_rust_bridge_codegen = \"1.62.*\"\n\n[dependencies]\nflutter_rust_bridge = \"1.62.*\"\nEOF\n\ntouch $RUST_BASE/src/api.rs\n\ncat << EOF >> $RUST_BASE/src/lib.rs\nmod api;\nEOF\n\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter_Rust_Bridge Code Generator with Cargo\nDESCRIPTION: This bash snippet shows the installation process of the flutter_rust_bridge code generator using `cargo install`.  The code generator is required for creating the bindings that will enable communication between Rust and Dart code.  It assumes that Rust and Cargo are properly installed and configured on the user's system.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/quickstart.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\n# or with cargo-binstall\ncargo binstall flutter_rust_bridge_codegen\n# or with scoop (Windows)\nscoop bucket add frb https://github.com/Desdaemon/scoop-repo\nscoop install flutter_rust_bridge_codegen\n# or with Homebrew\nbrew install desdaemon/repo/flutter_rust_bridge_codegen\n```\n\n----------------------------------------\n\nTITLE: Install flutter_rust_bridge_codegen\nDESCRIPTION: This command installs the `flutter_rust_bridge_codegen` tool, which is used to generate the necessary Dart bindings for interacting with Rust code. It is a prerequisite for generating the bridge between Dart and Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial_pure_dart.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\n```\n\n----------------------------------------\n\nTITLE: Define Struct A with Opaque Field B (Rust)\nDESCRIPTION: This code defines a struct `A` containing a public field `b` of type `B`. It assumes that `B` is an opaque type, meaning its internal structure is not directly accessible or translatable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/opaque-in-translatable.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct A { pub b: B }\n```\n\n----------------------------------------\n\nTITLE: Overriding Methods Using frb_override Prefix in Rust\nDESCRIPTION: Demonstrates how to define a Rust method that uses the frb_override_ prefix to override an existing method with the same name by automatically ignoring the prefix. This approach helps resolve method name conflicts especially when using custom attributes like #[ext]. The dependency is on a code-generation or macro system that recognizes the frb_override_ prefix. The method shown takes an immutable reference to self and an integer parameter, returning an integer. The prefix grants the method privilege to override and remove conflicting methods with the same name.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/override-prefix.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl MyStruct {\n    pub fn frb_override_hello(&self, a: i32) -> i32 {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom-Encoded Types in Function Signatures\nDESCRIPTION: Demonstration of how a Rust function using a custom type is automatically converted to use the corresponding Dart type in the generated Dart code. The conversion uses the previously defined encoder/decoder functions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/custom.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn f(a: FancyRustType) { ... }\n```\n\nLANGUAGE: dart\nCODE:\n```\nvoid f(FancyDartType a) { ... }\n```\n\n----------------------------------------\n\nTITLE: Creating Log Stream Interface in Rust\nDESCRIPTION: Provides a function to assign a Dart StreamSink to the Rust static variable, enabling Dart to receive log entries streamed from Rust. This setup connects Rust's logging outputs to Dart's stream consumers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_log_stream(s: StreamSink<LogEntry>) {\n    stream_sink = s;\n}\n```\n\n----------------------------------------\n\nTITLE: Rust wire_uint_8_list to Vec<u8> conversion\nDESCRIPTION: This Rust code snippet implements the `Wire2Api` trait for converting a `*mut wire_uint_8_list` to a `Vec<u8>`. It reconstructs the vector from the pointer and length provided in the `wire_uint_8_list` struct, taking ownership of the underlying memory. It uses `support::box_from_leak_ptr` and `support::vec_from_leak_ptr` to handle memory management safely. The input is a raw pointer to `wire_uint_8_list` struct allocated from Dart FFI.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/cst-codec.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {\n    fn wire2api(self) -> Vec<u8> {\n        unsafe {\n            let wrap = support::box_from_leak_ptr(self);\n            support::vec_from_leak_ptr(wrap.ptr, wrap.len)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RustOpaque Type in Rust\nDESCRIPTION: Basic Rust implementation for creating and handling opaque types. The code defines functions to create a new RustOpaque instance and access its data through dereferencing. RustOpaque requires the wrapped type to implement Send and Sync traits.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Return Types in Rust for Flutter Rust Bridge\nDESCRIPTION: Shows how to define Rust functions returning either a plain type or a Result wrapped in anyhow::Result for integration with Flutter Rust Bridge. Demonstrates difference in error handling capabilities between direct return types and those enveloped in anyhow::Result. The functions take two 32-bit integers as parameters and return their sum either directly or as a Result type indicating potential error handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_return_types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn f(a: i32, b: i32) -> i32 { a + b }\n\npub fn g(a: i32, b: i32) -> anyhow::Result<i32> { Ok(a + b) }\n```\n\n----------------------------------------\n\nTITLE: Rust Word Dictionary Implementation\nDESCRIPTION: This Rust code defines a `WordDict` struct and implements methods for opening the dictionary, getting its size, and searching for keywords.  It demonstrates features like calling Dart callbacks, translating errors, supporting async/sync Dart, property getters, and stream support. The `#[frb(sync, getter)]` attribute is used for synchronous getter methods.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// ↱ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↱ Support functions & methods\nimpl WordDict {\n    //          ↱ Can call Dart back                 ↱ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↱ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↱ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↱ Allow async & sync                    ↱ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking an Asynchronous Rust Function in Dart\nDESCRIPTION: This snippet illustrates how to call an asynchronous Rust function, exposed via flutter_rust_bridge, from Dart using the `await` keyword. It assumes the Rust function `f` has been properly bound and is accessible in Dart as an async function. This approach requires Dart's async/await capabilities and an established bridge to the Rust backend. There are no explicit input parameters in this example, but the pattern works for any async Rust function exposed to Dart. Outputs are received as the completed Future value. Usage is limited to environments where FFI and asynchronous Dart code are supported.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/async-rust.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nawait f();\n```\n\n----------------------------------------\n\nTITLE: Example Dart Code Catching Custom Rust Error as Exception - Dart\nDESCRIPTION: Demonstrates how the Rust custom error converted to a Dart exception can be used on the Dart side. It uses a try-catch block to await a Rust API call that returns a Result with a custom error. If an error occurs, it asserts that the caught exception is an instance of the Dart representation of the Rust custom error type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_exceptions.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\ntry {\n    final r = await api.returnErrCustomError();\n    print(\"received $r\");\n} catch (e) {\n    print('dart catch e: $e');\n    expect(e, isA<CustomError>());\n}\n```\n\n----------------------------------------\n\nTITLE: Set minimum CMake version\nDESCRIPTION: Specifies the minimum required version of CMake for the project.  It is set to 3.10 to ensure compatibility with the Flutter tooling requirements.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Generating a Freezed Data Class with Metadata in Dart\nDESCRIPTION: This Dart code demonstrates the Dart-side result when a Rust struct uses the frb metadata annotation. It imports the meta package, applies the @freezed and @meta.immutable annotations, and defines the UserId class with a single required int value field using the Freezed package. The class is const-constructible, uses a factory, and supports code generation for equality, immutability, and copyWith, following Dart best practices for value types. Dependencies: package:meta/meta.dart and freezed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_struct.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:meta/meta.dart' as meta;\n\n@freezed\n@meta.immutable\nclass UserId with _$UserId {\n  const factory UserId({\n    required int value,\n  }) = _UserId;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-ndk CLI tool for Android NDK integration - Bash\nDESCRIPTION: Installs the cargo-ndk command-line tool, version 2.7.0 or higher, which provides support for Android NDK versions greater than 22. This tool facilitates building Rust projects targeting Android. The command uses Cargo's install functionality to add the tool globally. Prerequisites include having a working Rust toolchain and Cargo installed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/alternative_ndk.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-ndk --version ^2.7.0\n```\n\n----------------------------------------\n\nTITLE: Receiving StreamSink Data as Dart Stream from Rust (Dart)\nDESCRIPTION: Shows how a Rust function with StreamSink<T> argument gets translated into a Dart function returning Stream<T>. This Dart Stream allows receiving multiple asynchronous values emitted from Rust. Flutter's Stream abstraction enables UI to render partial results as soon as they come without waiting for the complete computation in Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/stream.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nStream<T> f(..)\n```\n\n----------------------------------------\n\nTITLE: Creating Platform-Independent FFI Factory in Flutter\nDESCRIPTION: Dart code that provides a platform-independent way to create the library wrapper. This uses conditional imports to select the appropriate implementation based on the platform.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi.dart\nimport 'package:library_name/library_name.dart';\nimport 'ffi/stub.dart'\n    if (dart.library.io) 'ffi/io.dart'\n    if (dart.library.js_interop) 'ffi/web.dart';\n\nLibraryName createLib() =>\n    createWrapper(createLibraryImpl());\n```\n\n----------------------------------------\n\nTITLE: Defining and Linking Flutter C++ Wrapper Libraries with CMake\nDESCRIPTION: This snippet defines source lists for core, plugin, and app-specific C++ wrapper components by prepending directory paths. It creates two static libraries: flutter_wrapper_plugin containing core and plugin sources, and flutter_wrapper_app containing core and app sources. Both libraries apply standard build settings, set position-independent code, and visibility presets. They link publicly against the Flutter INTERFACE library, include wrapper headers, and depend on the flutter_assemble target to ensure correct build ordering.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Modifying rust.cmake to use Corrosion (CMake)\nDESCRIPTION: This code snippet demonstrates how to modify the `rust.cmake` file to correctly find and use the Corrosion package in a CMake build process. The modifications involve replacing the commented-out lines that directly fetch Corrosion with a simple `find_package` call. This enables the build system to locate the Corrosion library necessary for bridging Flutter and Rust code.  The version of corrosion specified is v0.4.4.  It is essential to ensure CMake is correctly installed to use this script.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/setup_desktop.md#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n```diff\n-# find_package(Corrosion REQUIRED)\n+find_package(Corrosion REQUIRED)\n\n-include(FetchContent)\n-\n-FetchContent_Declare(\n-    Corrosion\n-    GIT_REPOSITORY https://github.com/AndrewGaspar/corrosion.git\n-    GIT_TAG v0.4.4 # Optionally specify a version tag or branch here\n-)\n-\n-FetchContent_MakeAvailable(Corrosion)\n```\n```\n\n----------------------------------------\n\nTITLE: Using One Mirror Definition for Multiple Structs\nDESCRIPTION: Shows how to define a single mirror for multiple structs with identical fields, simplifying code and ensuring synchronization. The macro #[frb(mirror())] accepts multiple type names.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_external.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// *no* need to do these\n#[frb(mirror(MessageId))]\npub struct MId(pub [u8; 32]);\n#[frb(mirror(BlobId))]\npub struct BId(pub [u8; 32]);\n#[frb(mirror(FeedId))]\npub struct FId(pub [u8; 32]);\n\n// simply do this is sufficient\n#[frb(mirror(MessageId, BlobId, FeedId))]\npub struct Id(pub [u8; 32]);\n```\n\n----------------------------------------\n\nTITLE: Android .gitignore Configuration\nDESCRIPTION: Gitignore settings to exclude Rust binaries and tar archives from version control in the Android project directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/03-android.md#_snippet_2\n\nLANGUAGE: gitignore\nCODE:\n```\n# Ignore Rust binaries\nsrc/main/jniLibs/\n*.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Rust Mirroring External Structs for Code Generation\nDESCRIPTION: Defines placeholder structs and enums with #[frb(mirror())] attribute to mirror external types. These mirror definitions are used at compile time to facilitate code generation without copying complex types, ensuring type fidelity and compile-time error detection.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_external.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// Mirroring example:\n// The goal of mirroring is to use external objects without needing to convert them with an intermediate type\n// In this case, the struct ApplicationSettings is defined in another crate (called external-lib)\n\n// To use an external type with mirroring, it MUST be imported publicly (aka. re-export)\npub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};\n\n// To mirror an external struct, you need to define a placeholder type with the same definition\n#[frb(mirror(ApplicationSettings))]\npub struct _ApplicationSettings {\n    pub name: String,\n    pub version: String,\n    pub mode: ApplicationMode,\n    pub env: Box<ApplicationEnv>,\n}\n\n// It works with basic enums too\n// Enums with struct variants are not yet supported\n#[frb(mirror(ApplicationMode))]\npub enum _ApplicationMode {\n    Standalone,\n    Embedded,\n}\n\n#[frb(mirror(ApplicationEnv))]\npub struct _ApplicationEnv {\n    pub vars: Vec<String>,\n}\n\n// Functions that use external types can directly return or accept the mirrored types\npub fn get_app_settings() -> ApplicationSettings {\n    external_lib::get_app_settings()\n}\n\npub fn is_app_embedded(app_settings: ApplicationSettings) -> bool {\n    match app_settings.mode {\n        ApplicationMode::Standalone => false,\n        ApplicationMode::Embedded => true,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Function Returning StreamSink to Emit Multiple Results (Rust)\nDESCRIPTION: Demonstrates a Rust function signature that uses StreamSink<T> as an argument and returns a Result type to enable emitting multiple asynchronous results back to Dart. The StreamSink allows the function to send pieces of data periodically while possibly continuing computation. It can be held and used even after the function returns, allowing long-lived streams such as for logging. Function signatures can place StreamSink at any parameter position.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/stream.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(sink: StreamSink<T>, ..) -> Result<()>\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(a: i32, b: StreamSink<String>)\nfn f(a: StreamSink<String>, b: i32)\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Struct (`WordDict`) for Flutter Integration with `flutter_rust_bridge` in Rust\nDESCRIPTION: Defines a Rust struct `WordDict` and its implementation block, showcasing methods (`open`, `size`, `search`) annotated with `#[frb]` attributes for `flutter_rust_bridge`. It demonstrates features like passing Dart callbacks to Rust (`open`), error translation (`Result<WordDict>`), synchronous property getters (`#[frb(sync, getter)]` for `size`), handling different reference types (`&self`), and asynchronous stream support (`async fn search` with `StreamSink`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// ↱ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↱ Support functions & methods\nimpl WordDict {\n    //          ↱ Can call Dart back                 ↱ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↱ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↱ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↱ Allow async & sync                    ↱ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Code for Optional Struct\nDESCRIPTION: This Dart code shows the automatically generated Dart code for the Rust struct and function defined with `Option`. The `Option` fields are translated to nullable types in Dart (String?, List<Attribute>? etc.). The `required` keyword is applied to the `mode` argument in the function, as it's non-nullable in Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/option.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nFuture<Element?> handleOptionalStruct({required String mode, String? document});\n\nclass Element {\n  final String? tag;\n  final String? text;\n  final List<Attribute>? attributes;\n  final List<Element>? children;\n  Element({this.tag, this.text, this.attributes, this.children});\n}\n```\n\n----------------------------------------\n\nTITLE: Running Code Generation Commands for Bindings\nDESCRIPTION: This Bash snippet demonstrates how to execute code generation scripts located in command.sh.txt from the project's root directory. Running these commands generates the necessary language bindings (such as C headers) based on the Rust library's exported functions and types, enabling Flutter integration. There are no code-level parameters, but the script must be available and executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/03-gen.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n{{#include command.sh.txt}}\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests in Dart\nDESCRIPTION: This Dart code uses the Flutter test framework to test the functionality of the bridge.  It imports necessary packages and then uses the `initializeExternalLibrary` function to load the bridge.  It then calls functions `saveUser` and `readUser` and asserts the results using `expect`.  Requires the `basis_hybrid`, `flutter_test` packages.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/unit_tests_dart.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:basis_hybrid/bridge_definitions.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nimport 'ffi.test.dart';\n\nFuture<void> main() async {\n  final api = initializeExternalLibrary('rust/target/debug/librustbridge.dylib');\n  await api.init(sqlPath: 'test.db', kvPath: 'test.kv');\n\n  test('User save/load', () async {\n     await api.saveUser();\n     var user = await api.readUser();\n     expect(user, isNotNull);\n   });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Rules for Flutter Windows Application with CMake\nDESCRIPTION: This snippet configures installation steps to copy the built Flutter executable, ICU data file, Flutter engine libraries, bundled plugin libraries, native assets, and Flutter assets into the appropriate runtime directories next to the executable. It ensures the build bundle directory is correctly set as the installation prefix, supports Visual Studio integration with default install on build, cleans stale Flutter asset directories before copying new ones, and installs Ahead-Of-Time (AOT) compiled libraries only for Profile and Release configurations. This setup facilitates running the Flutter Windows app directly from the build output in Visual Studio or after official install.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Methods in Rust\nDESCRIPTION: This Rust code defines a struct `SumWith` with a member variable `x` and two methods: `sum` (non-static) and `sum_static` (static). The `sum` method adds the instance's `x` value to the provided `y` value. The `sum_static` method adds two provided integer arguments. It serves as the foundation for the bridge to Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_methods.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct SumWith { pub x: u32 }\n\nimpl SumWith {\n    pub fn sum(&self, y: u32) -> u32 { self.x + y }\n    pub fn sum_static(x: u32, y: u32) -> u32 { x + y }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Dart Closure to Rust Function - Dart\nDESCRIPTION: This Dart snippet shows how to pass a Dart closure as a callback argument to the Rust function. The closure takes a parameter 'name' and returns a greeting string 'Hello, $name!'. This closure is used by Rust code to get a computed result dynamically.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/rust-call-dart.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nrustFunction(dartCallback: (name) => 'Hello, $name!');\n```\n\n----------------------------------------\n\nTITLE: Analysis Options Configuration (YAML)\nDESCRIPTION: This YAML snippet configures Dart's analyzer and linter settings. It specifies exclusions for generated files (`.freezed.dart`, `.g.dart`), enforces strict inference and raw types, and defines a set of linter rules to improve code quality.  It contains a comprehensive list of core Dart and Flutter lints.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nanalyzer:\n  exclude:\n    - '**.freezed.dart'\n    - '**.g.dart'\n  language:\n    strict-inference: true\n    strict-raw-types: true\n  errors:\n    invalid_annotation_target: ignore\n\nlinter:\n  rules:\n    # Custom lints\n    - prefer_single_quotes\n\n    # Core Dart lints\n    - avoid_empty_else\n    - avoid_relative_lib_imports\n    - avoid_shadowing_type_parameters\n    - avoid_types_as_parameter_names\n    - await_only_futures\n    - camel_case_extensions\n    - camel_case_types\n    - curly_braces_in_flow_control_structures\n    - depend_on_referenced_packages\n    - empty_catches\n    - file_names\n    - hash_and_equals\n    - iterable_contains_unrelated_type\n    - list_remove_unrelated_type\n    - no_duplicate_case_values\n    - non_constant_identifier_names\n    - null_check_on_nullable_type_parameter\n    - package_prefixed_library_names\n    - prefer_generic_function_type_aliases\n    - prefer_is_empty\n    - prefer_is_not_empty\n    - prefer_iterable_whereType\n    - prefer_typing_uninitialized_variables\n    - provide_deprecation_message\n    - unnecessary_overrides\n    - unrelated_type_equality_checks\n    - valid_regexps\n    - void_checks\n\n    # Recommended Dart lints\n    - always_require_non_null_named_parameters\n    - annotate_overrides\n    - avoid_function_literals_in_foreach_calls\n    - avoid_init_to_null\n    - avoid_null_checks_in_equality_operators\n    - avoid_renaming_method_parameters\n    - avoid_return_types_on_setters\n    - avoid_returning_null_for_void\n    - avoid_single_cascade_in_expression_statements\n    - constant_identifier_names\n    - control_flow_in_finally\n    - empty_constructor_bodies\n    - empty_statements\n    - exhaustive_cases\n    - implementation_imports\n    - library_names\n    - library_prefixes\n    - library_private_types_in_public_api\n    - no_leading_underscores_for_library_prefixes\n    - no_leading_underscores_for_local_identifiers\n    - null_closures\n    - overridden_fields\n    - package_names\n    - prefer_adjacent_string_concatenation\n    - prefer_collection_literals\n    - prefer_conditional_assignment\n    - prefer_contains\n    - prefer_equal_for_default_values\n    - prefer_final_fields\n    - prefer_for_elements_to_map_fromIterable\n    - prefer_function_declarations_over_variables\n    - prefer_if_null_operators\n    - prefer_initializing_formals\n    - prefer_inlined_adds\n    - prefer_interpolation_to_compose_strings\n    - prefer_is_not_operator\n    - prefer_null_aware_operators\n    - prefer_spread_collections\n    - prefer_void_to_null\n    - recursive_getters\n    - slash_for_doc_comments\n    - type_init_formals\n    - unnecessary_brace_in_string_interps\n    - unnecessary_const\n    - unnecessary_constructor_name\n    - unnecessary_getters_setters\n    - unnecessary_late\n    - unnecessary_new\n    - unnecessary_null_aware_assignments\n    - unnecessary_null_in_if_null_operators\n    - unnecessary_nullable_for_final_variable_declarations\n    - unnecessary_string_escapes\n    - unnecessary_string_interpolations\n    - unnecessary_this\n    - use_function_type_syntax_for_parameters\n    - use_rethrow_when_possible\n\n    # Flutter lints\n    - avoid_print\n    - avoid_unnecessary_containers\n    - avoid_web_libraries_in_flutter\n    - no_logic_in_create_state\n    - prefer_const_constructors\n    - prefer_const_constructors_in_immutables\n    - prefer_const_declarations\n    - prefer_const_literals_to_create_immutables\n    - sized_box_for_whitespace\n    - sort_child_properties_last\n    - use_build_context_synchronously\n    - use_full_hex_values_for_flutter_colors\n    - use_key_in_widget_constructors\n```\n\n----------------------------------------\n\nTITLE: Initializing Rust with #[frb(init)] Annotation in Rust\nDESCRIPTION: Using the `#[frb(init)]` annotation on a Rust function to automatically initialize the Rust side during Flutter/Dart startup. The flutter_rust_bridge_codegen tool already creates an init function called `init_app` by default.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/init.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(init)]\npub fn lets_init_app_here() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Dart Log Stream Listener\nDESCRIPTION: This Dart code snippet sets up a listener to receive and process log entries from the Rust side.  The `createLogStream()` function (provided by flutter_rust_bridge) returns a `Stream` of `LogEntry` objects. The `.listen()` method is used to process each incoming log entry, printing the log level, tag, message, and timestamp to the console. This demonstrates how the log messages originating from the Rust side are received and processed in Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> setup() async {\n    createLogStream().listen((event) {\n      print('log from rust: ${event.level} ${event.tag} ${event.msg} ${event.timeMillis}');\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Rust Targets for Android Cross-Compilation - Shell\nDESCRIPTION: Utilizes the `rustup` tool to install the required target triples (`aarch64-linux-android`, `armv7-linux-androideabi`, `x86_64-linux-android`, `i686-linux-android`) necessary for cross-compiling Rust code for various Android device architectures. This is a prerequisite for building the native library used by flutter_rust_bridge on Android.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/setup_android.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nrustup target add \\\n    aarch64-linux-android \\\n    armv7-linux-androideabi \\\n    x86_64-linux-android \\\n    i686-linux-android\n```\n\n----------------------------------------\n\nTITLE: Configuring LLVM path explicitly for flutter_rust_bridge_codegen\nDESCRIPTION: Provides instructions for setting the LLVM path explicitly if the code generator cannot locate LLVM after installation. Users can specify the path via command line (`--llvm-path <YOUR_LLVM_PATH>`) or in configuration files (`llvm_path: <YOUR_LLVM_PATH>`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/ffigen-troubleshooting.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nflutter_rust_bridge_codegen --llvm-path <YOUR_LLVM_PATH>\n```\n\n----------------------------------------\n\nTITLE: Displaying Documentation Cards in MDX\nDESCRIPTION: This snippet utilizes the `DocCardList` component to render a list of documentation cards. The `DocCardList` component likely fetches and displays a list of document cards, allowing for easy navigation and organization of documentation entries. No specific parameters are passed to the component in the provided code, so it likely relies on default settings or context to render the document cards. It is dependent on the `@theme/DocCardList` import and likely renders HTML or other presentational elements.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/index.md#_snippet_0\n\nLANGUAGE: MDX\nCODE:\n```\n```mdx-code-block\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Function\nDESCRIPTION: This Rust code snippet is an example of a function that can be called from Dart using the Flutter Rust Bridge.  It takes a String and a vector of `MyEnum` as input and returns a `MyStruct`.  This shows how the bridge can handle complex types without requiring manual intervention.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn f(a: String, b: Vec<MyEnum>) -> MyStruct { ... }\n```\n\n----------------------------------------\n\nTITLE: Gitignore Configuration for Linux/Windows Plugin Directories\nDESCRIPTION: An example .gitignore file for the `linux/` and `windows/` directories of a Flutter plugin, using an allowlist approach. It ignores all files by default (`*`) but explicitly allows `.gitignore` and `CMakeLists.txt`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/01-windows-and-linux.md#_snippet_2\n\nLANGUAGE: gitignore\nCODE:\n```\n# Set up as allowlist\n*\n\n# Allowed files\n!.gitignore\n!CMakeLists.txt\n```\n\n----------------------------------------\n\nTITLE: Disabling Windows Macros\nDESCRIPTION: Disables Windows macros that can conflict with C++ standard library functions by defining NOMINMAX as a preprocessor definition.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n```\n\n----------------------------------------\n\nTITLE: Looping Back DartOpaque Objects between Rust and Dart\nDESCRIPTION: Demonstrates passing a Dart object (`DartOpaque`) to Rust and immediately returning it back to Dart. The Rust function `loop_back` accepts and returns `DartOpaque`. The Dart code calls this function, passing a Dart function, receives the opaque object back, casts it to its original type, and executes it.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/dart_opaque_type_safety.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn loop_back(opaque: DartOpaque) -> DartOpaque {\n    opaque\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\nString f() => 'Test_String';\n\nvar fn = await api.loopBack(opaque: f) as String Function();\n\nexpect(fn(), 'Test_String');\n```\n\n----------------------------------------\n\nTITLE: Configuring flutter_rust_bridge_codegen for multiple platforms\nDESCRIPTION: This command runs the flutter_rust_bridge_codegen tool to generate bridge code for Flutter-Rust integration. It specifies the Rust source file, output Dart file, header file for iOS, and additional paths for MacOS builds. Dependencies include the flutter_rust_bridge_codegen package and correct file paths.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/command.sh.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nflutter_rust_bridge_codegen \\\n    -r $crate/src/api.rs \\\n    -d lib/bridge_generated.dart \\\n    -c ios/Runner/bridge_generated.h \\\n    -e macos/Runner/   # if building for MacOS, extra path is essential\n```\n\n----------------------------------------\n\nTITLE: Installing flutter_rust_bridge with Default Cargo Method\nDESCRIPTION: Command to install flutter_rust_bridge_codegen using the standard Cargo package manager.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\n```\n\n----------------------------------------\n\nTITLE: Defining Struct with Option in Rust\nDESCRIPTION: This Rust code defines a struct `Element` with several fields, all of which are optional strings or vectors of attributes/elements, using the `Option` type. It also defines a function `parse` that accepts a String and an optional String as input, returning an optional Element.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/option.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct Element {\n    pub tag: Option<String>,\n    pub text: Option<String>,\n    pub attributes: Option<Vec<Attribute>>,\n    pub children: Option<Vec<Element>>,\n}\n\npub fn parse(mode: String, document: Option<String>) -> Option<Element> { ... }\n```\n\n----------------------------------------\n\nTITLE: Workaround for GLIBC Version Not Found Errors with Flutter Snap\nDESCRIPTION: Installation guidance for Flutter on Linux to avoid GLIBC version mismatch errors, recommending installing Flutter via the official method rather than Snap, following known issues with Link Time Optimization (LTO) and specific GLIBC versions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Calling Rust Function from Dart\nDESCRIPTION: This Dart code snippet demonstrates how to call the Rust function defined in the previous example. It passes a String and a list of `MyEnum` values as arguments to the function and then prints the result.  The code shows how easily Rust functions can be used in Dart with the bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nprint(f(a: 'Hello', b: [MyEnum.c('Tom')]));\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Code for Rust Option Types\nDESCRIPTION: This Dart code shows the generated output from Flutter Rust Bridge corresponding to the Rust example. The `Option<T>` types in Rust are translated to nullable types `T?` in Dart. The non-optional `mode` parameter in the Rust function becomes `required String mode` in Dart, while the optional `document` parameter becomes `String? document`. The `Element` class mirrors the Rust struct with nullable fields.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_option.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nFuture<Element?> handleOptionalStruct({required String mode, String? document});\n\nclass Element {\n  final String? tag;\n  final String? text;\n  final List<Attribute>? attributes;\n  final List<Element>? children;\n  Element({this.tag, this.text, this.attributes, this.children});\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries to Target with CMake\nDESCRIPTION: This snippet links the flutter and GTK libraries to the executable target. These are PRIVATE dependencies, meaning they are only needed by the target itself.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-ndk for Android Rust compilation\nDESCRIPTION: Command to install cargo-ndk, a tool that facilitates building Rust code for Android targets using the NDK.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/03-android/01-tasks.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-ndk\n```\n\n----------------------------------------\n\nTITLE: Metadata example (Dart)\nDESCRIPTION: This is the Dart code generated from the Rust metadata example.  It imports the `meta` package as `meta`, and applies the `@freezed` and `@meta.immutable` annotations to the `UserId` class.  It also includes the `_$UserId` mixin and factory constructor required by the `freezed` package.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/struct.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:meta/meta.dart' as meta;\n\n@freezed\n@meta.immutable\nclass UserId with _$UserId {\n  const factory UserId({\n    required int value,\n  }) = _UserId;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Trait Implementation Methods Attributes in Rust\nDESCRIPTION: Illustrates overriding methods in a trait implementation for a struct by defining an external implementation block with #[frb(external)] and specifying the trait and struct names. Unlike previous cases, method parameters must be explicitly declared, though method bodies are omitted. The example uses #[frb(ignore)] to exclude the method from binding generation. This pattern facilitates modifying attribute behavior without changing third-party crate code but may evolve in future syntax versions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/override-attributes.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(external)]\nimpl MyTrait for MyStruct {\n    #[frb(ignore)]\n    fn method(a: i32, b: String) -> Vec<f64> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Native Dynamic Library (Dart)\nDESCRIPTION: This Dart function provides the platform-specific logic for loading a native dynamic library on IO platforms (Android, iOS, macOS, Linux, Windows). It uses `dart:ffi` and `dart:io` to determine the operating system and construct the correct file path or name for the native library (`.framework`, `.dll`, `.so`), then opens it using `DynamicLibrary.open()`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/io.dart\nimport 'dart:ffi';\nimport 'dart:io';\n\nDynamicLibrary createLibraryImpl() {\n  const base = 'library_name';\n\n  if (Platform.isIOS || Platform.isMacOS) {\n    return DynamicLibrary.open('$base.framework/$base');\n  } else if (Platform.isWindows) {\n    return DynamicLibrary.open('$base.dll');\n  } else {\n    return DynamicLibrary.open('lib$base.so');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using flutter_rust_bridge_codegen CLI commands\nDESCRIPTION: Command-line interface for flutter_rust_bridge showing available commands and options. The tool provides commands for generating bindings, creating new projects, integrating Rust into existing Flutter projects, building for web, and accessing help documentation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/generated/main.txt#_snippet_0\n\nLANGUAGE: CLI\nCODE:\n```\nUsage: flutter_rust_bridge_codegen [OPTIONS] <COMMAND>\n\nCommands:\n  generate   Execute the main code generator\n  create     Create a new Flutter + Rust project\n  integrate  Integrate Rust into existing Flutter project\n  build-web  Compile for the Web (WASM)\n  help       Print this message or the help of the given subcommand(s)\n\nOptions:\n  -v, --verbose  Show debug messages\n  -h, --help     Print help\n  -V, --version  Print version\n```\n\n----------------------------------------\n\nTITLE: Defining a Synchronous Rust Function Using Thread Sleep in Rust\nDESCRIPTION: This Rust snippet defines a synchronous function named `compute` that pauses execution for 1000 milliseconds using thread sleep. It demonstrates a blocking operation suitable for concurrent execution on a thread pool. No external crates beyond Rust's standard library are required. The function takes no parameters and returns no value, modeling a simple compute task with a delay.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/sync-rust.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn compute() {\n  thread::sleep(Duration::from_millis(1000));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Parameter Values in Flutter Rust Bridge Using Rust\nDESCRIPTION: Demonstrates defining default values for function parameters in Rust code interoperating with Dart using the Flutter Rust Bridge. The snippet includes an enum `Answer` and a struct `Point`, and a function `defaults` where the `answer` parameter defaults to `Answer.Yes` and the `point` parameter defaults to a constant `Point` instance with fields set to 2 and 3 respectively. The defaults use the #[frb(default = \"...\")] attribute, specifying Dart-compatible expressions to be used as default values on the Dart side. The snippet requires the Flutter Rust Bridge framework and annotations enabled. It is intended to show how to specify defaults transparently for Dart code generation, supporting primitives, classes, and enums.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_default.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub enum Answer { Yes, No }\npub struct Point(pub f64, pub f64);\n\n#[frb]\npub fn defaults(\n    #[frb(default = \"Answer.Yes\")]\n    answer: Answer,\n    #[frb(default = \"const Point(field0: 2, field1: 3)\")]\n    point: Point,\n);\n```\n\n----------------------------------------\n\nTITLE: Defining LogEntry struct in Rust\nDESCRIPTION: This Rust code defines a `LogEntry` struct which is used to transfer log messages from Rust to Dart. The struct contains fields for time, log level, tag, and the log message itself.  It's a simplified demonstration, and requires implementing the `IntoDart` trait, usually generated by `flutter_rust_bridge_codegen`. This struct will be used to send logs to the Dart side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct LogEntry {\n    pub time_millis: i64,\n    pub level: i32,\n    pub tag: String,\n    pub msg: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dart and Rust Preambles in YAML\nDESCRIPTION: This YAML configuration snippet demonstrates how to specify preambles for Dart and Rust code generation. `dart_preamble` allows injecting Dart code, useful for suppressing lint rules or importing dependencies. `rust_preamble` does the same for Rust code, allowing the injection of 'use' statements or other code at the top of the generated Rust file. Multi-line string literals are used to define the code blocks.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/preambles.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\ndart_preamble: |\n  // ignore_for_file: this_is_a_lint_rule\n  whatever_thing_here;\nrust_preamble: |\n  use some::Thing;\n  also_whatever_thing_here;\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Codegen Logging in build.rs (Rust)\nDESCRIPTION: This Rust code snippet demonstrates how to initialize logging for the `frb_codegen` tool within a project's `build.rs` file. By calling `init_logger` with a target directory (e.g., \"./logs/\"), logs generated by `frb_codegen` (including panics, `log::info!`, `log::debug!`, etc.) during the build process will be written to dated files (e.g., `2023-02-01.log`) in that directory. This is useful for debugging changes made to the code generator itself. Requires the `lib_flutter_rust_bridge_codegen` crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/misc.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse lib_flutter_rust_bridge_codegen::init_logger;\nfn main() {\n    init_logger(\"./logs/\").unwrap();\n...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Platform-Specific Logger in Rust\nDESCRIPTION: This Rust code snippet demonstrates the initialization of platform-specific loggers. It configures logging for Android using `android_logger` and for iOS using `oslog`. The `#[cfg]` attributes enable the correct logger based on the target operating system. It requires the respective dependencies (`android_logger` and `oslog`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn setup_the_logger() {\n    #[cfg(target_os = \"android\")]\n    android_logger::init_once(android_logger::Config::default().with_max_level(LevelFilter::Trace));\n\n    #[cfg(target_os = \"ios\")]\n    oslog::OsLogger::new(\"com.example.test\").level_filter(LevelFilter::Trace).init().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Rust Bridge in pubspec.yaml\nDESCRIPTION: This YAML snippet demonstrates how to configure Flutter Rust Bridge parameters directly within the `pubspec.yaml` file. It includes settings for the rust input file (`rust_input`), rust root directory (`rust_root`), and dart output location (`dart_output`). This method is suitable for project-specific configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/codegen/inputs.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# put this somewhere in your pubspec.yaml\nflutter_rust_bridge:\n  rust_input: crate::api\n  rust_root: rust/\n  dart_output: lib/src/rust\n  # ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Executor with Logging in Rust\nDESCRIPTION: This Rust code defines a custom struct `MyExecutor` that wraps a `ThreadPoolExecutor` parameterized with a custom error handler (`MyErrorHandler`). It implements the `Executor` trait, overriding the `execute` method to add custom behavior around task execution. The custom behavior includes logging the start and end times of each task using a helper method `log_around`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/handler.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyExecutor(ThreadPoolExecutor<MyErrorHandler>);\n\nimpl Executor for MyExecutor {\n    fn execute<TaskFn, TaskRet>(&self, wrap_info: WrapInfo, task: TaskFn) {\n        let debug_name_string = wrap_info.debug_name.to_string();\n        self.thread_pool_executor\n            .execute(wrap_info, move |task_callback| {\n                Self::log_around(&debug_name_string, move || task(task_callback))\n            })\n    }\n}\n\nimpl MyExecutor {\n    fn log_around<F, R>(debug_name: &str, f: F) -> R where F: FnOnce() -> R {\n        let start = Instant::now();\n        debug!(\"(Rust) execute [{}] start\", debug_name);\n        let ret = f();\n        debug!(\"(Rust) execute [{}] end delta_time={}ms\", debug_name, start.elapsed().as_millis());\n        ret\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing anyhow::Result Error in Rust for Flutter Rust Bridge - Rust\nDESCRIPTION: Defines a Rust function returning an anyhow::Result that purposely fails using the bail! macro to throw an error. When called from Dart, this error is automatically converted and thrown as a Dart exception. The snippet relies on the anyhow crate for error handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_exceptions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn f() -> anyhow::Result<i32> { bail!(\"oops I failed\") }\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform-Specific FFI for iOS, macOS, Windows and Linux\nDESCRIPTION: Dart implementation that loads the native library using platform-specific paths. This code handles different library naming conventions across platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/io.dart\nimport 'dart:ffi';\nimport 'dart:io';\n\nDynamicLibrary createLibraryImpl() {\n  const base = 'library_name';\n\n  if (Platform.isIOS || Platform.isMacOS) {\n    return DynamicLibrary.open('$base.framework/$base');\n  } else if (Platform.isWindows) {\n    return DynamicLibrary.open('$base.dll');\n  } else {\n    return DynamicLibrary.open('lib$base.so');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration\nDESCRIPTION: This snippet sets the minimum CMake version, defines the project name, and sets the executable name. It also defines the languages used in the project. This ensures the CMake build system knows the project details.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(frb_example_gallery LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"frb_example_gallery\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Package Project with Cargokit for Rust Integration\nDESCRIPTION: Sets up a Flutter package project with CMake, specifying the minimum required version, project name, and integrating Cargokit for Rust compilation. It also defines the bundled libraries that should be included with the plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The Flutter tooling requires that developers have a version of Visual Studio\n# installed that includes CMake 3.14 or later. You should not increase this\n# version, as doing so will cause the plugin to fail to compile for some\n# customers of the plugin.\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"flutter_package\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../rust flutter_package \"\")\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(flutter_package_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Getting Help for flutter_rust_bridge_codegen (Shell)\nDESCRIPTION: Demonstrates using the `--help` flag with the `flutter_rust_bridge_codegen` command in a shell environment to display its full usage documentation. The actual help text is included from an external file 'help.txt'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/command_line.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ flutter_rust_bridge_codegen --help\n{{#include help.txt}}\n```\n\n----------------------------------------\n\nTITLE: Stream Usage in Rust for Periodic Ticks\nDESCRIPTION: Implements a Rust function that generates a periodic tick count, sending incremented integers through a supplied StreamSink every second using a loop and sleep. Demonstrates stream-based timing data emission from Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow::Result;\nuse std::{thread::sleep, time::Duration};\n\nuse flutter_rust_bridge::StreamSink;\n\nconst ONE_SECOND: Duration = Duration::from_secs(1);\n\n// can't omit the return type yet, this is a bug\npub fn tick(sink: StreamSink<i32>) -> Result<()> {\n    let mut ticks = 0;\n    loop {\n        sink.add(ticks);\n        sleep(ONE_SECOND);\n        if ticks == i32::MAX {\n            break;\n        }\n        ticks += 1;\n    }\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Log Stream in Rust\nDESCRIPTION: This Rust code declares and initializes the log stream sink to send log entries.  It utilizes the `StreamSink` from `flutter_rust_bridge` to stream log entries to the Dart side. This implementation involves the use of `lazy_static` for thread safety, or other similar solutions for mutability in static contexts. `create_log_stream` function is used to set the `StreamSink` from dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlazy_static! { static ref log_stream_sink: StreamSink<LogEntry>; }\n\npub fn create_log_stream(s: StreamSink<LogEntry>) {\n    stream_sink = s;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Functions in Rust\nDESCRIPTION: This Rust code defines a simple API function, greet, that returns a greeting string. It is meant to be placed in the src/api.rs file of a Rust crate, exposing functionality to be called from other languages through generated bindings. No external dependencies are required; the function takes no parameters and outputs a String containing a message.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/03-gen.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn greet() -> String {\n    \"Hello from Rust! 🦀\".into()\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MessagePort Communication Flow in Browser Environment\nDESCRIPTION: This diagram illustrates how MessagePort is used to replace dart:ffi's SendPort for communication between Dart and Rust threads in a web environment. The sequence shows port transfer from Dart to Rust and back to Dart via workers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dco-codec.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nDart ->> Rust: port2\nRust ->> Rust Worker: port2\nRust Worker ->> Dart: port2.postMessage\n```\n\n----------------------------------------\n\nTITLE: Importing DocCardList component in Dart for Flutter\nDESCRIPTION: This snippet shows importing a theme component, 'DocCardList', from an external package in Dart for Flutter. It enables the rendering of documentation cards and encapsulates UI logic related to documentation display within the Flutter app. The snippet indicates dependencies on the '@theme/DocCardList' package or module.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/index.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Enforce Bundling Swift Dummy Method\nDESCRIPTION: This Swift code defines a dummy method to ensure that the Rust symbols are not accidentally stripped during the build process. This function is called to force the linker to include the Rust code in the final binary. It is included in both `ios/Classes/EnforceBundling.swift` and `macos/Classes/EnforceBundling.swift`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/02-ios-and-macos.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\npublic func dummyMethodToEnforceBundling() -> Int64 {\n  return dummy_method_to_enforce_bundling()\n}\nlet dummyVar = dummyMethodToEnforceBundling();\n```\n\n----------------------------------------\n\nTITLE: Linking Plugin Wrapper Dependencies\nDESCRIPTION: This snippet links the `flutter_wrapper_plugin` to the `flutter` library.  This ensures that the wrapper has access to the Flutter library functions and data. The `PUBLIC` keyword makes the dependency available to users.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\n```\n\n----------------------------------------\n\nTITLE: Implementing Web Support Placeholder for FFI\nDESCRIPTION: Placeholder implementation for web support that currently throws an UnsupportedError. This indicates that web support is planned but not yet implemented.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/web.dart\nimport 'package:library_name/library_name.dart';\n\nWasmModule createLibraryImpl() {\n  // TODO add web support. See:\n  // https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter/lib/ffi.web.dart\n  throw UnsupportedError('Web support is not provided yet.');\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Dart Log Stream Function\nDESCRIPTION: This Dart code represents the declaration of a function named `createLogStream`.  This function, generated by `flutter_rust_bridge`, is responsible for creating a stream of `LogEntry` objects coming from the Rust side. The generated code facilitates the communication of log messages from the Rust side to be consumed in Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/logging.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nStream<LogEntry> createLogStream();\n```\n\n----------------------------------------\n\nTITLE: Defining Minimum CMake Version and Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.13 and defines the project 'runner' with C++ as the language. It initializes the build environment for an executable application, specifying its name via the BINARY_NAME variable. This forms the foundation for subsequent build configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Declaring External Method Signature for flutter_rust_bridge in Rust\nDESCRIPTION: This snippet demonstrates how to declare the signature of an external method in the main crate using the #[frb(external)] attribute for compatibility with flutter_rust_bridge. The struct MyExternalStruct is referenced, and the method simple_external_method is declared with an empty body. This requires flutter_rust_bridge as a dependency, and the attribute signals that the function is defined externally. No implementation is needed in the body; only the signature is required for bridge generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/external-methods.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(external)]\nimpl MyExternalStruct {\n    pub fn simple_external_method(&self) -> String {}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding rust.cmake to CMakeLists.txt for Flutter Rust Bridge integration\nDESCRIPTION: This diff shows how to include the rust.cmake file in your CMakeLists.txt to enable Flutter Rust Bridge integration for Windows and Linux desktop applications. The modification should be added after the generated_plugins.cmake inclusion.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/05-desktop.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n # Generated plugin build rules, which manage building the plugins and adding\n # them to the application.\n include(flutter/generated_plugins.cmake)\n\n+include(./rust.cmake)\n\n # === Installation ===\n # Support files are copied into place next to the executable, so that it can\n```\n\n----------------------------------------\n\nTITLE: Using futures::executor::block_on\nDESCRIPTION: This snippet demonstrates the usage of `futures::executor::block_on` to run async code, specifically with plain futures. This can run async code without depending on a runtime like Tokio. The `hello_world` function and the main function use it.  This approach does not depend on a specific runtime, provided the futures crate is used. The output prints \"hello, world!\".\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse futures::executor::block_on;\n\nasync fn hello_world() -> String {\n    \"hello, world!\".to_string()\n}\n\nfn get() -> String {\n    block_on(async {\n        hello_world().await\n    })\n}\n\nfn main() {\n    println!(\"{}\", get()); // prints \"hello, world!\"\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Compilation Settings with CMake Function (CMake)\nDESCRIPTION: Defines a reusable CMake function called APPLY_STANDARD_SETTINGS to apply common compiler settings to targets building the Flutter desktop application. It enforces C++17 standard, enables high warning level with warnings treated as errors except for specific warning 4100, enables exception handling compatibility, disables C++ standard exceptions, and sets debug macros for debug builds. This function aids in maintaining uniform compilation options across multiple targets, such as Flutter plugins or application components.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring .gitignore for Windows/Linux Flutter-Rust Integration\nDESCRIPTION: A .gitignore configuration for the Linux and Windows directories that implements an allowlist approach, only allowing specific files to be tracked by git.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/windows_and_linux.md#_snippet_2\n\nLANGUAGE: gitignore\nCODE:\n```\n# Set up as allowlist\n*\n\n# Allowed files\n!.gitignore\n!CMakeLists.txt\n```\n\n----------------------------------------\n\nTITLE: Including Generated Plugin Build Rules in CMake\nDESCRIPTION: Includes a separate CMake file generated by Flutter tooling that defines rules for building plugins and integrating them with the application. This allows automated management of plugin dependencies without manual alteration of the main CMakeLists.txt file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Metadata example (Rust)\nDESCRIPTION: This example shows how to add Dart metadata annotations to a Rust struct using the `#[frb(dart_metadata=...)]` attribute. It uses `freezed` and `immutable` annotations. The `immutable` annotation requires importing the `meta` package with alias `meta`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/struct.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]\npub struct UserId {\n    pub value: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList Component in MDX\nDESCRIPTION: This snippet demonstrates importing the DocCardList component from the '@theme/DocCardList' package and rendering it within an MDX document. It requires the environment to support JSX/React within MDX files. The purpose is to display a list of documentation cards dynamically on the page without additional parameters or configuration inputs. The output is a rendered component showing these cards, facilitating navigation or highlighting key documents.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Consult WebAssembly Limitations for Flutter on WASM\nDESCRIPTION: Directs to the 'Limitations on WASM' documentation for details on common challenges and solutions when deploying Flutter applications with Rust via WebAssembly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Applying Standard Compiler Options and Flutter Integration (CMake)\nDESCRIPTION: Defines a reusable CMake function to set standard compiler features and options for target executables, enforces a modern C++ standard (cxx_std_14), and applies additional flags for release builds. This snippet introduces the function 'APPLY_STANDARD_SETTINGS' and demonstrates its use, particularly for plugins. The snippet also shows inclusion of the Flutter-managed build directory, enabling integration of Flutter dependencies for desktop applications. Requires CMake, C++ toolchain, and Flutter desktop tooling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Struct and Methods for Flutter Integration\nDESCRIPTION: Defines a Rust struct `WordDict` and implements methods using `flutter_rust_bridge` attributes (`frb`). Demonstrates features like callback functions (`open`), synchronous getters (`size` annotated with `#[frb(sync, getter)]`), asynchronous functions (`search`), error handling (`Result`), and streams (`StreamSink`). These elements are designed to be callable from Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// ↱ Arbitrarily fancy Rust types\npub struct WordDict { .. }\n\n// ↱ Support functions & methods\nimpl WordDict {\n    //          ↱ Can call Dart back                 ↱ Translate errors\n    pub fn open(chooser: impl Fn(String) -> bool) -> Result<WordDict> { .. }\n\n    // ↱ Support async & sync Dart; property getter\n    #[frb(sync, getter)]\n    //          ↱ Support T/&T/&mut T\n    pub fn size(&self) -> u32 { .. }\n\n    //  ↱ Allow async & sync                    ↱ Support stream (iterator)\n    pub async fn search(&self, keyword: String, sink: StreamSink<String>) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Dart 3 Switch Expressions for Platform Matching\nDESCRIPTION: Presents an alternative implementation in Dart using Dart 3's switch expressions to handle the `Platform` enum. This provides compile-time exhaustiveness checks similar to Rust's `match` and offers a different syntax compared to the `freezed` `when` method, including pattern matching to extract data like the architecture (`arch`) from the `Platform_MacOs` variant.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_finish.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal text = switch (platform) {\n  Platform_Android() => 'Android',\n  Platform_Ios() => 'iOS',\n  Platform_MacOs(:final arch) => 'MacOS on $arch',\n  Platform_Windows() => 'Windows',\n  Platform_Unix() => 'Unix',\n  Platform_Wasm() => 'the Web',\n  // we have covered all cases, so this compiles.\n};\n```\n\n----------------------------------------\n\nTITLE: Rust API Functions: Synchronous and Asynchronous Drop of DartOpaque\nDESCRIPTION: Two Rust functions demonstrating safe dropping of `DartOpaque`: `sync_accept_dart_opaque` performs a synchronous drop and returns a string wrapped in `SyncReturn`; `async_accept_dart_opaque` asynchronously drops the handle without returning anything. These showcase how Rust can safely dispose Dart opaque handles on the appropriate thread/port.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\npub fn sync_accept_dart_opaque(opaque: DartOpaque) -> SyncReturn<String> {\n    drop(opaque);\n    SyncReturn(\"test\".to_owned())\n}\n\npub fn async_accept_dart_opaque(opaque: DartOpaque) {\n    drop(opaque);\n}\n```\n\n----------------------------------------\n\nTITLE: Running Required Rust Build Commands with Bash\nDESCRIPTION: This code snippet instructs the user to execute a shell script with all necessary build commands each time Rust code is updated, prior to invoking flutter run. It likely includes commands for compiling the Rust library with required flags and moving or linking artifacts as needed for the Flutter app. This script may depend on correct Rust toolchain and environment setup, as well as integration with flutter_rust_bridge; there are no specific parameters or outputs specified, but the script must be run after Rust changes and before Flutter execution.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/finish.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n{{#include command.sh.txt}}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Flutter Interface Library\nDESCRIPTION: Creates and configures a Flutter interface library with appropriate include directories and linked libraries including GTK, GLIB, and GIO dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Flutter Include Directories and Linking in CMake\nDESCRIPTION: Defines the Flutter library location, header files, and configures the CMake interface target named flutter, specifying the include directories and libraries to link against. It ensures correct integration of generated Flutter files and necessary system libraries (GTK, GLib, GIO), and exposes selected variables to the parent scope for use across build stages. Inputs include paths to generated Flutter library and headers; outputs are CMake interface targets and published paths.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Build Scripts for Platform-Specific Binaries (example: Bash scripts)\nDESCRIPTION: These scripts automate building platform-specific binaries located in '/scripts/build-*.sh'. They output into '/platform-build' directories, creating platform-appropriate packages such as XCFrameworks or tarballs, which are then uploaded to a remote location like GitHub releases for distribution.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Example: build-ios.sh\n# Build iOS XCFramework binary\nxcodebuild -archivePath ./build/ios -scheme YourScheme\n# Package into XCFramework\nxcodebuild -create-xcframework -library ./build/ios/YourLib.a -headers ./include -output ./platform-build/LibraryName.xcframework.zip\n```\n\n----------------------------------------\n\nTITLE: Running flutter_rust_bridge Code Generation via Shell Script - Shell\nDESCRIPTION: This shell command invokes the flutter_rust_bridge_codegen tool to generate foreign function interface (FFI) bindings from a Rust API file (src/api.rs) to both Dart (lib/bridge_generated.dart) and Objective-C (ios/Runner/bridge_generated.h). It includes an additional path parameter for targeting MacOS (macos/Runner/), which is essential for building MacOS support. Run this command in the project root directory with all the specified files available. Requires the flutter_rust_bridge_codegen package installed and Rust source files set up appropriately.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/command.sh.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen \\\n    -r $crate/src/api.rs \\\n    -d lib/bridge_generated.dart \\\n    -c ios/Runner/bridge_generated.h \\\n    -e macos/Runner/   # if building for MacOS, extra path is essential\n```\n\n----------------------------------------\n\nTITLE: Publishing Releases to GitHub and Pub.dev GitHub Action (YAML)\nDESCRIPTION: This YAML snippet defines a GitHub Actions workflow that automatically runs whenever new tags are pushed to the repository. It is responsible for building necessary artifacts, creating a release on GitHub, and publishing packages to pub.dev. The pub.dev publishing requires a GitHub repository secret `PUB_CRED_JSON` containing the contents of the user's pub credentials file (`pub-credentials.json`). The workflow includes steps for checking out code, setting up Flutter, Melos, Zig, LLVM, Rust toolchain, and Android NDK before building via `melos run build`, creating the GitHub release with specific files, and finally authenticating with pub.dev and publishing using Melos.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/ci.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nname: Publish Release(s)\n\non:\n  push:\n    tags:\n      - \"*\"\n\njobs:\n  publish_github_release:\n    # macOS because we can cross-compile to all other platforms from it\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n      - uses: nttld/setup-ndk@v1\n        with:\n          ndk-version: r25b\n\n      - name: Build all library binaries\n        run: melos run build\n\n      - name: Create GitHub release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: platform-build/*\n\n  publish_pub_release:\n    needs: publish_github_release\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - name: Setup pub.dev credentials\n        run: |\n          mkdir -p $HOME/.config/dart\n          cat << EOF > $HOME/.config/dart/pub-credentials.json\n          ${{ secrets.PUB_CRED_JSON }}\n          EOF\n      - name: Dry-run publish to pub.dev\n        run: melos publish -y --dry-run\n      - name: Publish to pub.dev\n        run: melos publish -y --no-dry-run\n```\n\n----------------------------------------\n\nTITLE: Fetching Data Asynchronously with Reqwest\nDESCRIPTION: This snippet demonstrates a basic asynchronous function `get` using the Reqwest library to fetch data from a specified URL. It utilizes `reqwest::get` to initiate the request and awaits the result, then converts the response to text. It relies on the `anyhow` crate for error handling. This is the basic building block, but cannot be directly used due to the lack of Future support by the library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse anyhow;\n\nasync fn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Rust Module Injections\nDESCRIPTION: Illustrates the code that flutter_rust_bridge auto injects to `lib.rs` for each `rust-output`. Note that the author mentions this code may not be accurate and may need to be manually adjusted.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nmod api_1;\nmod api_2;\nmod generated_api_1; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */\nmod generated_api_2; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */\n```\n\n----------------------------------------\n\nTITLE: Adding Executable and Source Files\nDESCRIPTION: This snippet adds the executable target for the Flutter runner and lists the source files required for building the application. The executable name is dynamically set using `BINARY_NAME`. The source files include C++ files and resource files necessary for the application. The dependencies here relate to the Flutter build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test in Dart\nDESCRIPTION: This Dart code initializes the external library and then runs a test to save and load user data. The `initializeExternalLibrary` function is called with the path to the compiled Rust library. The test then calls the `saveUser` and `readUser` functions from the bridge, verifying that the user data can be saved and loaded successfully.  Dependencies include `basis_hybrid`, `flutter_rust_bridge` and `flutter_test` packages.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/unit_tests_dart.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'package:basis_hybrid/bridge_generated.dart';\nimport 'package:flutter_rust_bridge/flutter_rust_bridge.dart';\n\nBridgeImpl initializeExternalLibrary(String path) {\n  return BridgeImpl(\n    loadLibForFlutter(path)\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Android NDK path in Gradle properties\nDESCRIPTION: Configuration for gradle.properties file to specify the path to the Android NDK, which is required by cargo-ndk to compile Rust code for Android targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/03-android/01-tasks.md#_snippet_2\n\nLANGUAGE: properties\nCODE:\n```\nANDROID_NDK=(path to NDK)\n```\n\n----------------------------------------\n\nTITLE: Awaiting Asynchronous Dart Callback from Rust - Dart\nDESCRIPTION: This snippet demonstrates how to await the asynchronous Rust function that accepts a Dart callback. The Dart callback is provided as an anonymous function that returns a greeting string asynchronously, enabling the Rust side to invoke Dart closures that perform asynchronous operations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/rust-call-dart.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nawait rustFunction(dartCallback: (name) => 'Hello, $name!');\n```\n\n----------------------------------------\n\nTITLE: Using RustOpaque Objects in Flutter Dart and Manual Disposal\nDESCRIPTION: This Dart snippet demonstrates how to receive, work with, and properly dispose of a RustOpaque object from Rust through the api interface provided by flutter_rust_bridge. It requires the flutter_rust_bridge Dart package and an asynchronous connection to the bridge API. After fetching an opaque object, it is passed to a Rust function and explicitly disposed with opaque.dispose(). Failure to dispose manually may lead to resource leaks as disposal via garbage collection is discouraged. Parameters include the opaque object reference, and operations are asynchronous using Dart futures.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_rust_opaque.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvar opaque = await api.functionThatCreatesSomeOpaqueData();\nawait api.functionThatUsesSomeOpaqueData(opaque);\nopaque.dispose();\n```\n\n----------------------------------------\n\nTITLE: Destructuring and Calling a Tuple-Returning Function in Dart\nDESCRIPTION: This Dart code demonstrates how to define and call a function that returns a record (Dart's equivalent to a tuple) with two double values. The result is immediately destructured into 'lat' and 'long', facilitating direct access. This pattern requires Dart 3+ to support records and assumes the function is connected to the Rust backend. Inputs: none. Output: a record (double, double) corresponding to the Rust tuple.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_tuple.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n(double, double) myCoordinate();\nfinal (lat, long) = myCoordinate();\n```\n\n----------------------------------------\n\nTITLE: Annotating a Rust Struct with Dart Metadata\nDESCRIPTION: This Rust code shows a struct UserId annotated with the frb macro to apply Dart metadata, generating decorators such as @freezed and @meta.immutable on the resulting Dart class. The pub field value holds a 32-bit unsigned integer. The dart_metadata argument specifies both annotation strings and Dart package imports, supporting advanced customization when bridging Rust and Dart. No extra crates are needed beyond flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_struct.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]\npub struct UserId {\n    pub value: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Data Class in Dart\nDESCRIPTION: This Dart class, generated from a Rust struct, models a recursive node (MyTreeNode) with two fields: a Uint8List for value and a List of MyTreeNode for children. It uses required named parameters in the constructor for safety. The Dart-side mapping follows flutter_rust_bridge conventions: all fields are immutable and typed to interoperate with the Rust definition. No external dependencies are required.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_struct.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyTreeNode {\n  final Uint8List value;\n  final List<MyTreeNode> children;\n  MyTreeNode({required this.value, required this.children});\n}\n```\n\n----------------------------------------\n\nTITLE: Run Dart program with Rust library\nDESCRIPTION: This command runs the Dart program, providing the path to the compiled Rust dynamic library as an argument. This allows the Dart code to load and use the Rust functions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial_pure_dart.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ndart frb_example/pure_dart/dart/lib/main.dart frb_example/pure_dart/rust/target/debug/libflutter_rust_bridge_example_pure_dart.so\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Policy Version Range\nDESCRIPTION: Specifies the CMake policy version range from 3.14 to 3.25 using `cmake_policy`. This command ensures consistent build behavior based on the policies defined within this version range and helps avoid warnings related to outdated policies when using newer CMake versions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(VERSION 3.14...3.25)\n```\n\n----------------------------------------\n\nTITLE: Configuring FFI Plugin with Method Channels\nDESCRIPTION: This YAML snippet demonstrates configuring an FFI plugin alongside method channels. It shows how to define a `pluginClass` along with `ffiPlugin` to enable both native and dart implementations for the plugin on a given platform.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/README.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nplugin:\n  platforms:\n    some_platform:\n      pluginClass: SomeName\n      ffiPlugin: true\n```\n\n----------------------------------------\n\nTITLE: Dart code for importing and initializing WebAssembly modules in Flutter\nDESCRIPTION: This snippet demonstrates how to import generated WebAssembly bridge files, and set up the native implementation using a specified WebAssembly module. It specifies the path to WebAssembly files, imports necessary modules, and initializes the WebAssembly module within a Flutter app context using the dart:html library. Dependencies include 'bridge_generated.web.dart' and 'bridge_definitions.dart'. The code sets up a constant for the WebAssembly file path and a variable for the API implementation based on WebAssembly initialization.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/web.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nimport 'bridge_generated.web.dart';\nexport 'bridge_definitions.dart';\n\nimport 'dart:html';\n\n// Path to the wasm_bindgen generated files\nconst root = 'pkg/native';\nfinal api = NativeImpl.wasm(WasmModule.initialize(\n    kind: const Modules.noModules(root: root),\n));\n```\n\n----------------------------------------\n\nTITLE: Displaying Documentation Cards (MDX)\nDESCRIPTION: Imports the `DocCardList` React component from the documentation theme and renders it directly within the MDX content. This component is commonly used in documentation sites (like those built with Docusaurus) to automatically list documentation cards or links based on the page's structure or configuration, providing easy navigation or highlighting related content.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/index.md#_snippet_0\n\nLANGUAGE: MDX\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Dart 'RustOpaque' Abstract Class for Rust Resource Encapsulation\nDESCRIPTION: Defines an abstract class representing a Rust opaque type, holding a RustArc instance. It provides decoding from raw pointer and encoding to raw representation, facilitating safe transfer of opaque resources.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nabstract class RustOpaque {\n  final RustArc _arc;\n  RustOpaque.decode(raw) { ... }\n  int encode() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using RustOpaque Data in Dart\nDESCRIPTION: This Dart snippet shows how to use the `RustOpaque` data created in Rust code. It calls a function that creates opaque data, uses that data, and disposes of it when no longer needed. Dependencies: Requires the Flutter Rust Bridge plugin and the corresponding Rust code. Input:  None. Output:  None.  It makes calls to an API defined by the Rust code and calls `dispose()` to release the opaque data when finished using it.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-opaque.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nvar opaque = await api.functionThatCreatesSomeOpaqueData();\nawait api.functionThatUsesSomeOpaqueData(opaque);\nopaque.dispose();\n```\n\n----------------------------------------\n\nTITLE: Installing Build-Time Dependencies for Flutter Projects (Bash)\nDESCRIPTION: Installs necessary build-time dependencies for a Flutter project using flutter_rust_bridge. This includes the codegen tool, ffigen for C header bindings, the core ffi package, and optionally cargo-xcode for Apple platform builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/deps.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\nflutter pub add --dev ffigen && flutter pub add ffi\n# if building for iOS or MacOS\ncargo install cargo-xcode\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command for Flutter Assembly\nDESCRIPTION: Adds a custom command to execute a shell script (`tool_backend.sh`) from the Flutter tools to assemble the Flutter library and headers.  The command includes the flutter tool environment variables.  A phony file is included as an output to ensure the command runs every build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Command to Assemble Flutter\nDESCRIPTION: Adds a custom command that runs the Flutter tool backend to assemble the Flutter library and headers. The command runs every time because of the `_phony_` file, and utilizes the flutter tool to generate the library and header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Function Implementation in Rust and Dart with flutter_rust_bridge\nDESCRIPTION: Demonstrates how a Rust function that takes string parameters and returns a custom struct can be called directly from Dart code using flutter_rust_bridge, without requiring manual boilerplate code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/overview.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f(a: String, b: Vec<String>) -> MyStruct { ... }\n```\n\nLANGUAGE: dart\nCODE:\n```\nprint(f(a: 'Hello', b: ['Tom']));\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project and Including Rust Integration Module (CMake)\nDESCRIPTION: Defines a C++ project with a placeholder name to be replaced by the actual Rust crate name. Includes an external custom CMake script 'cargokit.cmake' that contains functions to assist with Rust crate integration in the build process. This snippet sets up core project infrastructure necessary for combining Rust and Flutter via CMake.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"REPLACE_ME_RUST_CRATE_NAME\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Path\nDESCRIPTION: Sets the `FLUTTER_LIBRARY` variable to the path of the Flutter library (`libflutter_linux_gtk.so`) and propagates these variables to the parent scope for use in later stages (e.g., installation).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Defining list_prepend Function\nDESCRIPTION: This snippet defines a function `list_prepend` to prepend an item to a list.  It replicates the functionality of `list(TRANSFORM ... PREPEND ...)` which isn't available in CMake 3.10. The function takes the list name and the prefix to prepend as input.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Generating Flutter-Rust Bridge Bindings with Shell\nDESCRIPTION: This optional shell command snippet demonstrates regenerating the bridge code bindings after modifying Rust source files, followed by running the Flutter app to see changes live. It depends on having a project created by flutter_rust_bridge_codegen and updated Rust source code. This snippet emphasizes the iterative development workflow supported by the tool.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen generate && flutter run\n```\n\n----------------------------------------\n\nTITLE: Removing Existing Bundle Directory with CMake\nDESCRIPTION: This snippet removes the existing build bundle directory to ensure a clean installation. It uses the `file(REMOVE_RECURSE)` command within an `install(CODE)` block.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\"\n  \" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Installing Build-time Dependencies - Flutter Project\nDESCRIPTION: This Bash script details the installation of build-time dependencies required for Flutter projects utilizing `flutter_rust_bridge`.  It includes the `flutter_rust_bridge_codegen`, `ffigen`, and optional `cargo-xcode` for iOS/MacOS support. These dependencies are used to generate the necessary glue code and facilitate communication between Rust and Dart/Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/02-deps.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\nflutter pub add --dev ffigen && flutter pub add ffi\n# if building for iOS or MacOS\ncargo install cargo-xcode\n```\n\n----------------------------------------\n\nTITLE: Appending and Prepending to Flutter Library Headers List\nDESCRIPTION: Appends a list of header files to `FLUTTER_LIBRARY_HEADERS` and then prepends the ephemeral directory path to each header. This ensures that the correct header files are included during compilation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\n```\n\n----------------------------------------\n\nTITLE: Embedding Rust Enum in Struct\nDESCRIPTION: This Rust snippet demonstrates how the previously defined `MyEnum` can be embedded within another struct (`MyStruct`). This pattern shows how to incorporate the type-safe `enum` approach into a structured data type for translation by `flutter_rust_bridge`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-dynamic.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct MyStruct {\n    msg:  String,\n    data: MyEnum,\n}\n```\n\n----------------------------------------\n\nTITLE: Reinstall Rust Toolchain for Cargokit on macOS\nDESCRIPTION: Provides steps to completely uninstall and reinstall Rust to fix crate resolution errors ('can't find crate for core') when building for macOS targets, including commands to uninstall, reinstall, and rebuild Flutter project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\nrustup self uninstall\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nflutter clean && flutter pub get && flutter run -d macos\n```\n\n----------------------------------------\n\nTITLE: Shell Script: Copying Files for Windows Integration Tests\nDESCRIPTION: This shell script copies the other.tar.gz (presumably containing binaries) to the windows directory in the flutter_library_name project. It also determines the current version by parsing the pubspec.yaml file and uses awk for the version number.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\ncp platform-build/other.tar.gz packages/flutter_library_name/windows/$CURR_VERSION.tar.gz\necho Copied file!\n```\n\n----------------------------------------\n\nTITLE: Using Generated Dart Property Accessors\nDESCRIPTION: Provides a simple Dart example showing how to interact with the automatically generated getter and setter for a public field of an opaque Rust struct. It demonstrates accessing and modifying the field using standard Dart property syntax.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nvar object = MyOpaqueType();\nobject.name += 'a';\nprint('Hi ${object.name}');\n```\n\n----------------------------------------\n\nTITLE: Customizing flutter_rust_bridge Worker Pool Count in Cargo.toml Using TOML\nDESCRIPTION: This snippet shows how to configure the flutter_rust_bridge dependency in Cargo.toml to customize the number of worker threads or web workers in the pool. By specifying the 'features' key, you can select predefined options such as 'worker-single' for a single thread or 'worker-max' to use all available logical cores. This affects the concurrency behavior of Rust function calls made from Dart via flutter_rust_bridge, optimizing performance and resource usage based on project needs.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/worker_pool.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n// Cargo.toml\n\n[dependencies]\nflutter_rust_bridge = { workspace = true, features = [\"worker-max\"] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Rust Struct Methods in Rust\nDESCRIPTION: Defines a Rust struct with instance and static methods, illustrating how methods are written in Rust within a crate. These methods serve as logic that will be exposed to Dart via flutter_rust_bridge, demonstrating standard Rust syntax.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/methods.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct SumWith { pub x: u32 }\n\nimpl SumWith {\n    pub fn sum(&self, y: u32) -> u32 { self.x + y }\n    pub fn sum_static(x: u32, y: u32) -> u32 { x + y }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Panic in Rust Functions Propagated to Dart Exceptions - Rust\nDESCRIPTION: Shows multiple Rust functions that panic when called, each returning different types including i32, anyhow::Result<String>, and a custom Result with CustomError. Panics within these functions are captured and converted into Dart exceptions automatically by Flutter Rust Bridge, allowing Rust panics to be safely handled on the Dart side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_exceptions.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn g1() -> i32 { panic!(\"oops I failed\") }\npub fn g2() -> anyhow::Result<String> { panic!(\"oops I failed\") }\npub fn g3() -> Result<Vec<u8>, CustomError> { panic!(\"oops I failed\") }\n```\n\n----------------------------------------\n\nTITLE: Wrap with Mutex\nDESCRIPTION: This code wraps the `Foo` struct from the third-party crate with a `Mutex`. This is done to handle potential `Sync` issues, making the type thread-safe. This allows access to the inner `Foo` struct in a synchronized manner.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/wrappers.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub struct Foo(Mutex<third_party_crate::Foo>);\n```\n\n----------------------------------------\n\nTITLE: Generating Flutter Rust Bridge Code\nDESCRIPTION: This snippet shows the command used to generate code using the flutter_rust_bridge_codegen tool.  It is likely run within the project directory after modifications to the Rust source code to reflect the changes in the Dart interface. This command must be executed to update the bridge's generated code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen generate && flutter run\n```\n\n----------------------------------------\n\nTITLE: Project Configuration CMake\nDESCRIPTION: Sets the minimum CMake version, project name, executable name, and application identifier. It also configures modern CMake behaviors and sets RPATH for runtime linking.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Project-level configuration.\ncmake_minimum_required(VERSION 3.13)\nproject(runner LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"flutter_via_integrate\")\n# The unique GTK application identifier for this application. See:\n# https://wiki.gnome.org/HowDoI/ChooseApplicationID\nset(APPLICATION_ID \"com.example.flutter_via_integrate\")\n\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(SET CMP0063 NEW)\n\n# Load bundled libraries from the lib/ directory relative to the binary.\nset(CMAKE_INSTALL_RPATH \"$ORIGIN/lib\")\n```\n\n----------------------------------------\n\nTITLE: Enforcement Function for Symbol Bundling in Swift\nDESCRIPTION: Defines a Swift function 'dummyMethodToEnforceBundling' to prevent Rust symbols from being stripped during compilation. It calls an external function 'dummy_method_to_enforce_bundling' and assigns the result to a variable, ensuring the linker retains the symbol.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/ios_and_macos.md#_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\npublic func dummyMethodToEnforceBundling() -> Int64 {\n  return dummy_method_to_enforce_bundling()\n}\nlet dummyVar = dummyMethodToEnforceBundling();\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Library Headers and Includes\nDESCRIPTION: This snippet defines a list of header files for the Flutter library and then prepends an include directory. This ensures that the necessary headers are included in the build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Disabling Default WASM Initialization in Cargo.toml\nDESCRIPTION: To prevent flutter_rust_bridge from injecting its default WASM initialization code (like console_error_panic_hook), set `default-features = false` for the crate dependency in your project's Cargo.toml. You can then explicitly enable other features if needed. This allows you to provide your own custom WASM initialization logic.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/rust/wasm-init.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\nflutter_rust_bridge = { version = \"..\", default-features = false, features = [..] }\n```\n\n----------------------------------------\n\nTITLE: Disposing Opaque Type Before Function Completion in Dart\nDESCRIPTION: Demonstrates how to safely dispose of an opaque type while an asynchronous operation is still using it. This pattern shows how ownership transfers to Rust to ensure the operation completes successfully.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \n// Dart and Rust share the opaque type.\n// Safely because opaque type has `Send` `Sync` Rust trait.\nvar unawait_task = api.runOpaqueWithDelay(opaque: opaque);\n\n// (Arc counter = 1) Rust has full ownership.\n// Dart stops owning the opaque type. \n// Trying to use an opaque type will throw StateError('Use after dispose.')\nopaque.dispose();\n\n// Successfully completed.\n//\n// Rust:\n// `executes run_opaque_with_delay.`\n// after complete (Arc counter = 0) \n// opaque type is dropped (deallocated)\nawait unawait_task;\n```\n\n----------------------------------------\n\nTITLE: Invoking a Callable Rust Struct Object in Dart\nDESCRIPTION: This Dart code demonstrates how to invoke an instance of a Rust struct (`A`) that has been bridged using flutter_rust_bridge and implements the callable pattern (via a `call` method in Rust). An instance `a` of the struct `A` is obtained, and then it is invoked directly as if it were a function, passing the required arguments (`myArg`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/callables.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// Obtain an object of type A by whatever approach\nvar a = A();\n// Though the `a` is an *object*, it acts as if it is a *function*\na(myArg: 'hello');\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Command for Flutter Tool Backend in CMake\nDESCRIPTION: Adds a custom command that executes the Flutter tool's backend script (`tool_backend.sh`) to generate necessary build artifacts like the Flutter library (`FLUTTER_LIBRARY`) and headers (`FLUTTER_LIBRARY_HEADERS`). The command runs with environment variables specified by `FLUTTER_TOOL_ENVIRONMENT` and passes platform and build type arguments. The `_phony_` output target forces the command to run on every build, as precise input/output tracking is difficult. `VERBATIM` ensures arguments are passed correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Using UUIDs with Rust and Flutter\nDESCRIPTION: This document explains how to use UUIDs in Rust and Flutter. In Rust, the `Uuid` struct from the `uuid` crate is used if the `uuid` feature is enabled. In Flutter, you will use `UuidValue` and will need to add the `uuid` package to your pubspec.yaml file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/uuid.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Formatting and linting\nDESCRIPTION: These commands format and lint the codebase across multiple modules (frb_codegen, frb_rust, frb_macros, etc.) for Rust and Dart. It uses `cargo fmt` and `cargo clippy` for Rust, and `dart format` and `dart analyze` for Dart. Each command is executed within the specific module's directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/appendix.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n(cd frb_codegen && cargo fmt --all); (cd frb_rust && cargo fmt --all); (cd frb_macros && cargo fmt --all); (cd frb_example/pure_dart/rust && cargo fmt --all); (cd frb_example/with_flutter/rust && cargo fmt --all);\n(cd frb_codegen && cargo clippy); (cd frb_rust && cargo clippy); (cd frb_macros && cargo clippy); (cd frb_example/pure_dart/rust && cargo clippy); (cd frb_example/with_flutter/rust && cargo clippy);                                                                                                                                          \n(cd frb_dart && dart format . --line-length 80); (cd frb_example/pure_dart/dart && dart format . --line-length 120); (cd frb_example/with_flutter && dart format . --line-length 120);\n(cd frb_dart && dart analyze --fatal-infos); (cd frb_example/pure_dart/dart && dart analyze --fatal-infos); (cd frb_example/with_flutter && dart analyze --fatal-infos);\n```\n\n----------------------------------------\n\nTITLE: Defining the Flutter Windows Runner Executable with CMake\nDESCRIPTION: This CMake script configures the build for a Flutter Windows application runner. It sets the minimum CMake version, defines the CXX project, creates an executable target (`${BINARY_NAME}`) with specified C++ source files and resources, applies standard build settings, defines preprocessor macros for Flutter versioning, disables the NOMINMAX macro, links against Flutter libraries (`flutter`, `flutter_wrapper_app`) and the Windows `dwmapi.lib`, sets include directories, and adds a dependency on the `flutter_assemble` target to integrate with the Flutter build process. The `BINARY_NAME` variable must be defined in the parent CMakeLists.txt.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(runner LANGUAGES CXX)\n\n# Define the application target. To change its name, change BINARY_NAME in the\n# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer\n# work.\n#\n# Any new source files that you add to the application should be added here.\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n\n# Apply the standard set of build settings. This can be removed for applications\n# that need different build settings.\napply_standard_settings(${BINARY_NAME})\n\n# Add preprocessor definitions for the build version.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n\n# Disable Windows macros that collide with C++ standard library functions.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n\n# Add dependency libraries and include directories. Add any application-specific\n# dependencies here.\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command for Flutter Build\nDESCRIPTION: This snippet defines a custom command to execute the Flutter tool backend. This command runs the Flutter build process. The command executes the Flutter tool with environment variables and the specified platform.  It defines the output files and lists dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Including Generated Plugins with CMake\nDESCRIPTION: This includes a cmake file, `generated_plugins.cmake`, that manages building the plugins and adding them to the application. This is required to have plugins integrated into the Flutter application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Wrapper Libraries for Flutter Windows in CMake\nDESCRIPTION: Configures two static libraries, `flutter_wrapper_plugin` and `flutter_wrapper_app`, using C++ source files from the `cpp_client_wrapper`. These libraries act as wrappers, linking against the core Flutter INTERFACE library (`flutter`) and providing necessary interfaces and include directories for plugins and the main application runner respectively. Standard settings, position-independent code, and hidden visibility presets are applied. Both libraries depend on the `flutter_assemble` target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# === Wrapper ===\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Custom Build Commands for Flutter Tool Backend Integration using CMake\nDESCRIPTION: This snippet configures a phony output file to force execution of a custom command on every build. The add_custom_command triggers the Flutter tool backend batch script with environment variables and target platform/context parameters. It specifies outputs including Flutter libraries, headers, wrapper sources, and the phony output path. The add_custom_target defines flutter_assemble depending on these outputs to orchestrate build order and ensure code generation or assembly steps are run before dependent targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Finding and Importing System Library Dependencies for GTK, GLib, and GIO in CMake\nDESCRIPTION: Uses CMake's find_package and pkg_check_modules to detect and import system-level dependencies required for the Flutter Linux desktop build, specifically GTK 3, GLib 2.0, and GIO 2.0. This ensures proper linkage and availability of these libraries when building the application. Dependencies include installed development packages for gtk+-3.0, glib-2.0, and gio-2.0.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Function from Dart\nDESCRIPTION: This code demonstrates a Dart example of calling a Rust function `f`.  The function takes a String (`a`) and a Vector of `MyEnum` objects as input, and is expected to return a `MyStruct`.  This illustrates how Rust code can be seamlessly called from Dart without extensive manual binding.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nprint(f(a: 'Hello', b: [MyEnum.c('Tom')]));\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies to the Application Target\nDESCRIPTION: This snippet links the application target with the Flutter library and GTK dependency via target_link_libraries. These dependencies are essential for Flutter integration and GUI components, respectively, enabling the executable to interact with Flutter and GTK functionalities.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Installing Executable Target with CMake\nDESCRIPTION: This snippet installs the executable target to the installation directory.  The `RUNTIME DESTINATION` specifies the location within the install prefix where the executable will be placed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Using Rust Enums Instead of Dynamic Types\nDESCRIPTION: Example of restructuring a Rust struct that holds either a u32 or a String into a more type-safe design using an enum with dedicated variants for each possible type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_dynamic.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct {\n    a: Optional<u32>,\n    b: Optional<String>,\n}\n\nstruct DataStruct {\n    msg:  String,\n    data: MyStruct,\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nenum MyEnum {\n    U32(u32),\n    String(String),\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyStruct {\n    msg:  String,\n    data: MyEnum,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Cross-Origin Headers in Flutter Web (flutter run)\nDESCRIPTION: This shell command sets the `Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy` headers when running a Flutter web application using `flutter run`.  This configuration is crucial for enabling shared buffers and cross-origin isolation, which is necessary for using asynchronous WASM features. This command requires the Flutter SDK to be installed and accessible.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/02-web-cross-origin.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nflutter run --web-header=Cross-Origin-Opener-Policy=same-origin --web-header=Cross-Origin-Embedder-Policy=require-corp\n```\n\n----------------------------------------\n\nTITLE: Including Flutter Libraries and Runner Subdirectories in CMake Build\nDESCRIPTION: Defines the flutter managed directory relative to current source and adds it as a subdirectory for inclusion in the build. Similarly adds the 'runner' subdirectory containing the application-specific build rules. This organizes the project structure allowing modular builds of Flutter engine bindings and application runtime.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Creating Static C++ Wrapper Libraries in CMake\nDESCRIPTION: Creates two static libraries: `flutter_wrapper_plugin` (for plugin support) and `flutter_wrapper_app` (for the main application runner). It uses the previously defined C++ source files, applies standard build settings, sets properties like Position Independent Code (PIC) and hidden C++ symbol visibility, links them publicly against the `flutter` interface library, sets include directories, and adds dependencies on the `flutter_assemble` target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Library and Related Variables\nDESCRIPTION: Defines variables to locate the Flutter library (`flutter_windows.dll`) and related data files. It sets variables, and appends to lists for headers. It also sets these variables to the parent scope for installation purposes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Finding Package Dependencies\nDESCRIPTION: Uses `pkg-config` to locate and configure system-level dependencies required for the Flutter application, specifically GTK, GLib, and GIO.  These are essential libraries for a GTK based Flutter application on Linux.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Cloning Caveat with Nested Opaque Access in Dart\nDESCRIPTION: Shows a Dart example that highlights the cloning caveat when accessing nested public fields of opaque structs. Attempting to modify `a.b.c` affects a temporary clone of `B`, so subsequent access to `a.b.c` reads a new clone of the original `B` instance, making the change appear lost.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nvar a = A(...);\na.b.c += 1;\nprint(a.b.c); // unchanged\n```\n\n----------------------------------------\n\nTITLE: Mocking RustLibApi for Dart Tests (Dart)\nDESCRIPTION: This code snippet demonstrates how to mock the `RustLibApi` class in Dart to test Dart code without relying on the actual Rust implementation. It uses a mocking framework (likely Mockito or Mocktail) to define the behavior of the mocked API.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/test.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\n// Surely, you can use Mockito or whatever other mocking packages\nclass MockRustLibApi extends Mock implements RustLibApi {}\n\nFuture<void> main() async {\n  final mockApi = MockRustLibApi();\n  await RustLib.init(api: mockApi);\n\n  test('can mock Rust calls', () async {\n    when(() => mockApi.simpleAdderTwinNormal(a: 1, b: 2))\n        .thenAnswer((_) async => 123456789);\n    final actualResult = await simpleAdderTwinNormal(a: 1, b: 2);\n    expect(actualResult, isNot(3));\n    expect(actualResult, equals(123456789));\n    verify(() => mockApi.simpleAdderTwinNormal(a: 1, b: 2)).called(1);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Plugin Wrapper Assemble Dependency\nDESCRIPTION: This snippet adds a dependency to `flutter_assemble`. This custom target builds the Flutter application and helps with dependency ordering. It guarantees that `flutter_assemble` runs before anything that uses `flutter_wrapper_plugin`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Mirroring ApplicationSettings in Rust\nDESCRIPTION: This snippet demonstrates mirroring an external struct `ApplicationSettings` from an external crate, `external_lib`.  It defines a placeholder struct `_ApplicationSettings` with the same fields and uses the `#[frb(mirror(...))]` attribute to link it to the external type.  It also includes mirroring enums and the usage in functions. The `pub use` statement is crucial for re-exporting the external type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/external-types.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};\n\n#[frb(mirror(ApplicationSettings))]\npub struct _ApplicationSettings {\n    pub name: String,\n    pub version: String,\n    pub mode: ApplicationMode,\n    pub env: Box<ApplicationEnv>,\n}\n\n#[frb(mirror(ApplicationMode))]\npub enum _ApplicationMode {\n    Standalone,\n    Embedded,\n}\n\n#[frb(mirror(ApplicationEnv))]\npub struct _ApplicationEnv {\n    pub vars: Vec<String>,\n}\n\npub fn get_app_settings() -> ApplicationSettings {\n    external_lib::get_app_settings()\n}\n\npub fn is_app_embedded(app_settings: ApplicationSettings) -> bool {\n    match app_settings.mode {\n        ApplicationMode::Standalone => false,\n        ApplicationMode::Embedded => true,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Gitignore for iOS and macOS Frameworks\nDESCRIPTION: Provides '.gitignore' files to exclude Flutter and Framework directories from version control, ensuring only necessary files are committed. '.gitkeep' files are used to keep empty directories in version control.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/ios_and_macos.md#_snippet_1\n\nLANGUAGE: None\nCODE:\n```\n# iOS Gitignore\nFlutter/\nRunner/\nFrameworks/*\n!Frameworks/.gitkeep\n\n# macOS Gitignore\nFlutter/\nFrameworks/*\n!Frameworks/.gitkeep\n```\n\n----------------------------------------\n\nTITLE: Defining and Returning Custom Error Enum Without Backtrace - Rust\nDESCRIPTION: Defines a custom Rust error type as an enum with variants holding different data types. Also includes a function that returns a Result type with the custom error, representing an error scenario. This custom error is interoperable with Dart and will be converted into a Dart class when the exception is passed across the FFI boundary.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_exceptions.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub enum CustomError {\n    Error0(String),\n    Error1(u32),\n}\n\npub fn return_err_custom_error() -> Result<u32, CustomError> {\n    Err(CustomError::Error1(3))\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Call Pattern with RustOpaque in Dart\nDESCRIPTION: Demonstrates the basic usage of RustOpaque types in Dart, showing how to create, use, and properly dispose of an opaque type. The code includes Arc reference counting comments to explain ownership transitions during the lifecycle.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) for the duration of the function \n// and after (Arc counter = 1).\n// \n// Dart and Rust share the opaque type.\nString hideData = await api.runOpaque(opaque);\n\n// (Arc counter = 0) opaque type is dropped (deallocated).\nopaque.dispose();\n```\n\n----------------------------------------\n\nTITLE: Implementing Calc Trait with Rust\nDESCRIPTION: This snippet presents an example of using a trait `Calc` (and its implementation `CalcImpl`) from an external crate within a `flutter_rust_bridge` project. It showcases two scenarios. The first creates an opaque `Box<dyn Calc>`. The second one uses a proxy/wrapper `CalcWrapper` with methods that match the trait's API to make the trait methods accessible in Dart via the generated FFI.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/external-types.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn new_calc() -> Box<dyn Calc> {\n    Box::new(CalcImpl {})\n}\n\npub struct CalcWrapper(Box<dyn Calc + Send + Sync>);\n\nimpl CalcWrapper {\n    pub fn new() -> Self {\n        Self(Box::new(CalcImpl {}))\n    }\n    \n    pub fn add(&self, a: u32, b: u32) -> u32 {\n        self.0.add(a, b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Cargokit Integration for Rust Libraries in CMake\nDESCRIPTION: Includes the Cargokit CMake scripts and applies the cargokit to the Flutter Rust project, enabling building and managing Rust dependencies. It links the Rust library located at the specified relative path with the CMake project, facilitating cross-language integration and bundling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../../../../rust rust_lib_flutter_via_create \"\")\n```\n\n----------------------------------------\n\nTITLE: Adding Build Dependencies\nDESCRIPTION: Adds a build dependency to the executable target, ensuring that the flutter_assemble target is built before the executable. This ensures that Flutter assets are assembled before the application is built.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Including Source Directory Paths\nDESCRIPTION: This snippet specifies the include directory for the target BINARY_NAME, adding the source directory of the project. It ensures that headers and other include files from the source directory are accessible during compilation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Rust Build Script Configuration\nDESCRIPTION: This Rust code configures the build process for the Rust library using the `flutter_rust_bridge_codegen` crate. It specifies input and output file paths for Rust and Dart code, enables inline Rust code and Wasm support, and uses `frb_codegen` to generate the necessary FFI bindings. It also formats the generated Dart code using `flutter format`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse lib_flutter_rust_bridge_codegen::{\n    config_parse, frb_codegen, get_symbols_if_no_duplicates, RawOpts,\n};\n\nconst RUST_INPUT: &str = \"src/api.rs\";\nconst DART_OUTPUT: &str = \"../lib/src/bridge_generated.dart\";\n\nconst IOS_C_OUTPUT: &str = \"../../flutter_$LIBNAME/ios/Classes/frb.h\";\nconst MACOS_C_OUTPUT_DIR: &str = \"../../flutter_$LIBNAME/macos/Classes/\";\n\nfn main() {\n    // Tell Cargo that if the input Rust code changes, rerun this build script\n    println!(\"cargo:rerun-if-changed={}\", RUST_INPUT);\n\n    // Options for frb_codegen\n    let raw_opts = RawOpts {\n        rust_input: vec![RUST_INPUT.to_string()],\n        dart_output: vec![DART_OUTPUT.to_string()],\n        c_output: Some(vec![IOS_C_OUTPUT.to_string()]),\n        extra_c_output_path: Some(vec![MACOS_C_OUTPUT_DIR.to_string()]),\n        inline_rust: true,\n        wasm: true,\n        ..Default::default()\n    };\n\n    // Generate Rust & Dart ffi bridges\n    let configs = config_parse(raw_opts);\n    let all_symbols = get_symbols_if_no_duplicates(&configs).unwrap();\n    for config in configs.iter() {\n        frb_codegen(config, &all_symbols).unwrap();\n    }\n\n    // Format the generated Dart code\n    _ = std::process::Command::new(\"flutter\")\n        .arg(\"format\")\n        .arg(\"..\")\n        .spawn();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust and WASM Prerequisites for Web Development (bash)\nDESCRIPTION: Details the commands needed to prepare the Rust environment for building WebAssembly code with Flutter Rust Bridge. This includes installing the `nightly` toolchain, adding the `rust-src` component and the `wasm32-unknown-unknown` target, and installing the `wasm-pack` tool via `curl` or `cargo`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/01-setup/03-web.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain install nightly\nrustup +nightly component add rust-src\nrustup +nightly target add wasm32-unknown-unknown\n# either of these\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\ncargo install wasm-pack\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimum CMake Version and Project Parameters\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.14, defines the project name, and specifies C++ as the language. These configurations ensure compatibility and establish project context needed for subsequent build steps.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_lib_frb_example_integrate_third_party\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Set bundled libraries\nDESCRIPTION: Defines the list of libraries to be bundled with the Flutter plugin.  It includes the library generated by Cargokit. The `PARENT_SCOPE` ensures that the variable is accessible in the parent scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/rust_builder/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(rust_builder_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Opaque Structs Illustrating Cloning Caveat in Rust\nDESCRIPTION: Defines two Rust structs, `A` and `B`, both marked as opaque (`#[frb(opaque)]`), where `A` contains a public field `b` of type `B`. This nested structure is used to illustrate the cloning behavior when accessing fields of opaque types from Dart, which can cause confusion.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(opaque)]\npub struct A {\n    pub b: B,\n}\n\n#[frb(opaque)]\npub struct B {\n    pub c: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: CMake Apply Standard Settings\nDESCRIPTION: This creates a function named `APPLY_STANDARD_SETTINGS` which is used to configure compiler settings for a target. It enables C++17 features, sets compile options for warnings, exceptions, and defines debug macros. This is a common settings function intended for multiple targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Compilation settings that should be applied to most targets.\n#\n# Be cautious about adding new options here, as plugins use this function by\n# default. In most cases, you should add new options to specific targets instead\n# of modifying this function.\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Setting Up System Dependencies for Flutter Linux\nDESCRIPTION: Configures the required system-level dependencies for Flutter on Linux using PkgConfig to find GTK, GLIB, and GIO packages.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Adding Plugin Wrapper Library\nDESCRIPTION: This snippet creates a static library for the plugin wrapper, using the core and plugin source files. This library contains the code specific to plugins.  `STATIC` ensures that the library is statically linked.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Android Gradle to run cargo-ndk during build\nDESCRIPTION: Gradle configuration that hooks into Android build tasks to compile Rust code for multiple architectures using cargo-ndk. This creates tasks for Debug, Profile, and Release build variants.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/03-android/01-tasks.md#_snippet_1\n\nLANGUAGE: gradle\nCODE:\n```\n[\n    new Tuple2('Debug', ''),\n    new Tuple2('Profile', '--release'),\n    new Tuple2('Release', '--release')\n].each {\n    def taskPostfix = it.first\n    def profileMode = it.second\n    tasks.whenTaskAdded { task ->\n        if (task.name == \"javaPreCompile$taskPostfix\") {\n            task.dependsOn \"cargoBuild$taskPostfix\"\n        }\n    }\n    tasks.register(\"cargoBuild$taskPostfix\", Exec) {\n        // Until https://github.com/bbqsrc/cargo-ndk/pull/13 is merged,\n        // this workaround is necessary.\n\n        def ndk_command = \"\"\"cargo ndk \\\n            -t armeabi-v7a -t arm64-v8a -t x86_64 -t x86 \\\n            -o ../android/app/src/main/jniLibs build $profileMode\"\"\"\n\n        workingDir \"../../$crate\"\n        environment \"ANDROID_NDK_HOME\", \"$ANDROID_NDK\"\n        if (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()) {\n            commandLine 'cmd', '/C', ndk_command\n        } else {\n            commandLine 'sh', '-c', ndk_command\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing JNI_OnLoad for NDK Context Initialization (Rust)\nDESCRIPTION: Defines the `JNI_OnLoad` function in Rust, which is automatically called by the Android JVM when the native library is loaded via `System.loadLibrary`. This function initializes the `ndk_context` using the `JavaVM` pointer, enabling safe interaction with the Android environment via JNI. This code should be placed in the main Rust library file (`lib.rs`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_os = \"android\")]\n#[no_mangle]\npub extern \"C\" fn JNI_OnLoad(vm: jni::JavaVM, res: *mut std::os::raw::c_void) -> jni::sys::jint {\n    use std::ffi::c_void;\n\n    let vm = vm.get_java_vm_pointer() as *mut c_void;\n    unsafe {\n        ndk_context::initialize_android_context(vm, res);\n    }\n    jni::JNIVersion::V6.into()\n}\n```\n\n----------------------------------------\n\nTITLE: Including External CMake script for Dependencies\nDESCRIPTION: This snippet includes an external CMake script located relative to the current directory, which manages dependencies through cargokit. It applies configurations necessary for integrating Rust libraries into the project, establishing build environment dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../../../../rust rust_lib_frb_example_integrate_third_party \"\")\n```\n\n----------------------------------------\n\nTITLE: Adding Android JNI Dependencies in Cargo.toml (TOML)\nDESCRIPTION: Specifies the required dependencies (`jni` and `ndk-context`) in the `Cargo.toml` file for Rust projects targeting Android. These dependencies are necessary for interacting with the JavaVM via JNI and initializing the `ndk_context` correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[target.'cfg(target_os = \"android\")'.dependencies]\njni = \"0.21\"\nndk-context = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Windows CMake Build for Flutter Rust Plugin\nDESCRIPTION: CMakeLists.txt file for the Windows platform within a Flutter plugin. It sets the minimum CMake version (3.14) and Visual Studio requirement, defines the project name, includes a workaround for Flutter Windows ARM support by setting `FLUTTER_TARGET_PLATFORM`, downloads pre-compiled Rust library binaries from a GitHub release, extracts the archive, and sets the path to the bundled dynamic library (`.dll`). Requires placeholders like `library_name`, `YourGitHubAccount`, and `repo_name` to be replaced.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/01-windows-and-linux.md#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\n\n# TODO Remove this workaround once Flutter supports Windows ARM.\n# https://github.com/flutter/flutter/issues/116196\nset(FLUTTER_TARGET_PLATFORM windows-x64)\n\n# The Flutter tooling requires that developers have a version of Visual Studio\n# installed that includes CMake 3.14 or later. You should not increase this\n# version, as doing so will cause the plugin to fail to compile for some\n# customers of the plugin.\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"flutter_library_name\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}\")\nset(ArchivePath \"${LibRoot}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(flutter_library_name_bundled_libraries\n  \"${LibRoot}/${FLUTTER_TARGET_PLATFORM}/library_name.dll\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Cross-Building Configuration CMake\nDESCRIPTION: Configures the build environment for cross-compilation by setting the system root and search paths if FLUTTER_TARGET_PLATFORM_SYSROOT is defined.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Root filesystem for cross-building.\nif(FLUTTER_TARGET_PLATFORM_SYSROOT)\n  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Project and Build Settings in CMake\nDESCRIPTION: Defines the minimal required CMake version (3.13), specifies the project name ('runner') and language (C++), and sets the executable's binary name and GTK application identifier. Establishes build configuration options with a default to 'Debug' if not specified, enables modern CMake policies, sets cross-compilation root filesystem when applicable, and defines common compilation standards with C++14, strict warnings, and optimization flags applied to all targets via a reusable function.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)${\\n}project(runner LANGUAGES CXX)${\\n}${\\n}set(BINARY_NAME \"flutter_via_create\")${\\n}set(APPLICATION_ID \"com.example.flutter_via_create\")${\\n}${\\n}cmake_policy(SET CMP0063 NEW)${\\n}${\\n}if(FLUTTER_TARGET_PLATFORM_SYSROOT)${\\n}  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})${\\n}  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})${\\n}  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)${\\n}  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)${\\n}  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)${\\n}  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)${\\n}endif()${\\n}${\\n}if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)${\\n}  set(CMAKE_BUILD_TYPE \"Debug\" CACHE${\\n}    STRING \"Flutter build mode\" FORCE)${\\n}  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS${\\n}    \"Debug\" \"Profile\" \"Release\")${\\n}endif()${\\n}${\\n}function(APPLY_STANDARD_SETTINGS TARGET)${\\n}  target_compile_features(${TARGET} PUBLIC cxx_std_14)${\\n}  target_compile_options(${TARGET} PRIVATE -Wall -Werror)${\\n}  target_compile_options(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")${\\n}  target_compile_definitions(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")${\\n}endfunction()\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Rust Error Enum with Backtrace Field - Rust\nDESCRIPTION: Defines a Rust enum for custom errors where each variant contains an error field and a backtrace field. This pattern enables passing detailed debugging information (backtrace) along with the error, which can be reflected on the Dart side by Flutter Rust Bridge. This snippet leverages the thiserror crate conventions for fill-in and usage.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_exceptions.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub enum CustomStructError {\n    Error0 { e: String, backtrace: Backtrace },\n    Error1 { e: u32, backtrace: Backtrace },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Profile Build Flags\nDESCRIPTION: Sets the compiler and linker flags specifically for the 'Profile' build configuration. It mirrors the flags used for the 'Release' configuration (`CMAKE_EXE_LINKER_FLAGS_RELEASE`, `CMAKE_SHARED_LINKER_FLAGS_RELEASE`, `CMAKE_C_FLAGS_RELEASE`, `CMAKE_CXX_FLAGS_RELEASE`), ensuring optimized builds suitable for profiling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Define settings for the Profile build mode.\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n```\n\n----------------------------------------\n\nTITLE: Rust wire_uint_8_list to String conversion\nDESCRIPTION: This Rust code snippet implements the `Wire2Api` trait for converting a `*mut wire_uint_8_list` to a `String`. It first converts the `wire_uint_8_list` to a `Vec<u8>` using the implementation defined in the previous snippet, and then converts the `Vec<u8>` to a String using `String::from_utf8_lossy`. This function handles UTF-8 encoding and returns a String, replacing any invalid UTF-8 sequences with the Unicode replacement character.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/cst-codec.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Wire2Api<String> for *mut wire_uint_8_list {\n    fn wire2api(self) -> String {\n        let vec: Vec<u8> = self.wire2api();\n        String::from_utf8_lossy(&vec).into_owned()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generated Dart Bindings\nDESCRIPTION: This snippet provides an example of how to use the generated Dart bindings. It assumes that the code generator has produced a Dart file named `bridge_generated.dart`.  The example shows how to call the `drawTree` function, which was defined in the Rust code, with appropriate parameters. This assumes the Dart code is correctly importing and using the generated bindings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/quickstart.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\napi.drawTree(TreeNode(value: \"root\", ...), Colorful(palette: \"viridis\"));\n```\n\n----------------------------------------\n\nTITLE: Adding Executable Target\nDESCRIPTION: Adds the executable target, specifying the source files to be included in the build. The BINARY_NAME variable defines the name of the executable.  It includes main.cc, my_application.cc, and the generated plugin registrant.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Rust Function Calling Dart Callback - Rust\nDESCRIPTION: An asynchronous Rust function snippet demonstrating how Rust can call an async Dart callback closure. The Rust function receives a closure returning a DartFnFuture<String>, and it calls the closure with \"Tom\" asynchronously, awaiting the result. This pattern supports asynchronous bidirectional communication and requires the dart_callback closure to be compatible with async Dart functions returning Future<String>.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/rust-call-dart.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub async fn rust_function(dart_callback: impl Fn(String) -> DartFnFuture<String>) {\n    dart_callback(\"Tom\".to_owned()).await; // Will get `Hello, Tom!`\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributors - HTML\nDESCRIPTION: This HTML snippet generates a table row displaying a contributor's information. It includes their GitHub avatar, username, and links to their code and documentation contributions. It uses GitHub avatars and links for contribution counts.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/README.md#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/erikas-taroza\"><img src=\"https://avatars.githubusercontent.com/u/68450090?v=4?s=100\" width=\"100px;\" alt=\"Erikas Taroza\"/><br /><sub><b>Erikas Taroza</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=erikas-taroza\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://lipoic.org\"><img src=\"https://avatars.githubusercontent.com/u/48402225?v=4?s=100\" width=\"100px;\" alt=\"菘菘\"/><br /><sub><b>菘菘</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SiongSng\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/JustSimplyKyle\"><img src=\"https://avatars.githubusercontent.com/u/68589851?v=4?s=100\" width=\"100px;\" alt=\"SimplyKyle!\"/><br /><sub><b>SimplyKyle!</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=JustSimplyKyle\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Zaitam\"><img src=\"https://avatars.githubusercontent.com/u/71014214?v=4?s=100\" width=\"100px;\" alt=\"Zaitam\"/><br /><sub><b>Zaitam</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Zaitam\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/coder0xff\"><img src=\"https://avatars.githubusercontent.com/u/2261949?v=4?s=100\" width=\"100px;\" alt=\"Brent Lewis\"/><br /><sub><b>Brent Lewis</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=coder0xff\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=coder0xff\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://derdilla.com\"><img src=\"https://avatars.githubusercontent.com/u/82763757?v=4?s=100\" width=\"100px;\" alt=\"derdilla\"/><br /><sub><b>derdilla</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=NobodyForNothing\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=NobodyForNothing\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/nitn3lav\"><img src=\"https://avatars.githubusercontent.com/u/77448526?v=4?s=100\" width=\"100px;\" alt=\"nitn3lav\"/><br /><sub><b>nitn3lav</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=nitn3lav\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=nitn3lav\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/mcmah309\"><img src=\"https://avatars.githubusercontent.com/u/56412856?v=4?s=100\" width=\"100px;\" alt=\"Henry\"/><br /><sub><b>Henry</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=mcmah309\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/AlienKevin\"><img src=\"https://avatars.githubusercontent.com/u/22850071?v=4?s=100\" width=\"100px;\" alt=\"Kevin Li\"/><br /><sub><b>Kevin Li</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/alexthe2\"><img src=\"https://avatars.githubusercontent.com/u/33789063?v=4?s=100\" width=\"100px;\" alt=\"Alex Procelewski\"/><br /><sub><b>Alex Procelewski</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alexthe2\" title=\"Documentation\">📖</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alexthe2\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Larpoux\"><img src=\"https://avatars.githubusercontent.com/u/45900255?v=4?s=100\" width=\"100px;\" alt=\"Larpoux\"/><br /><sub><b>Larpoux</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Larpoux\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://patrick.mukherjee.de\"><img src=\"https://avatars.githubusercontent.com/u/2045440?v=4?s=100\" width=\"100px;\" alt=\"Patrick Mukherjee\"/><br /><sub><b>Patrick Mukherjee</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=patmuk\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://dport.me\"><img src=\"https://avatars.githubusercontent.com/u/7816187?v=4?s=100\" width=\"100px;\" alt=\"Daniel Porteous (dport)\"/><br /><sub><b>Daniel Porteous (dport)</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=banool\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/AlexV525\"><img src=\"https://avatars.githubusercontent.com/u/15884415?v=4?s=100\" width=\"100px;\" alt=\"Alex Li\"/><br /><sub><b>Alex Li</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlexV525\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://blog.i7.homes\"><img src=\"https://avatars.githubusercontent.com/u/71180087?v=4?s=100\" width=\"100px;\" alt=\"Integral\"/><br /><sub><b>Integral</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Integral-Tech\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tienisto.com\"><img src=\"https://avatars.githubusercontent.com/u/38380847?v=4?s=100\" width=\"100px;\" alt=\"Tien Do Nam\"/><br /><sub><b>Tien Do Nam</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Tienisto\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://satvikpendem.com\"><img src=\"https://avatars.githubusercontent.com/u/42670561?v=4?s=100\" width=\"100px;\" alt=\"Satvik Pendem\"/><br /><sub><b>Satvik Pendem</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=satvikpendem\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://monitzer.com\"><img src=\"https://avatars.githubusercontent.com/u/644763?v=4?s=100\" width=\"100px;\" alt=\"Andreas Monitzer\"/><br /><sub><b>Andreas Monitzer</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=anlumo\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/temeddix\"><img src=\"https://avatars.githubusercontent.com/u/66480156?v=4?s=100\" width=\"100px;\" alt=\"Kim Dong-Hyun\"/><br /><sub><b>Kim Dong-Hyun</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=temeddix\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=temeddix\" title=\"Documentation\">📖</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://blog.nightfeather.dev/\"><img src=\"https://avatars.githubusercontent.com/u/77222233?v=4?s=100\" width=\"100px;\" alt=\"NightFeather\"/><br /><sub><b>NightFeather</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=NightFeather0615\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://alexballmer.dev\"><img src=\"https://avatars.githubusercontent.com/u/4921944?v=4?s=100\" width=\"100px;\" alt=\"Alex Ballmer\"/><br /><sub><b>Alex Ballmer</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=fmeef\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/alexlapa\"><img src=\"https://avatars.githubusercontent.com/u/36732824?v=4?s=100\" width=\"100px;\" alt=\"alexlapa\"/><br /><sub><b>alexlapa</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alexlapa\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/xuwaters\"><img src=\"https://avatars.githubusercontent.com/u/1222863?v=4?s=100\" width=\"100px;\" alt=\"Wei Xu\"/><br /><sub><b>Wei Xu</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=xuwaters\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/SirKrlos\"><img src=\"https://avatars.githubusercontent.com/u/64156428?v=4?s=100\" width=\"100px;\" alt=\"José Carlos\"/><br /><sub><b>José Carlos</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SirKrlos\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://woini.men\"><img src=\"https://avatars.githubusercontent.com/u/52571365?v=4?s=100\" width=\"100px;\" alt=\"九月\"/><br /><sub><b>九月</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=OfficialBoyfriend\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/jippeholwerda\"><img src=\"https://avatars.githubusercontent.com/u/117410?v=4?s=100\" width=\"100px;\" alt=\"Jippe Holwerda\"/><br /><sub><b>Jippe Holwerda</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=jippeholwerda\" title=\"Code\">💻</a></td>\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries (C++)\nDESCRIPTION: This section links the necessary libraries to the application target. It links `flutter` and `PkgConfig::GTK`, indicating dependencies on Flutter and GTK. This makes the external libraries available to the executable, resolving symbols and enabling functionality from those libraries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Class with Property Accessors for Rust Methods\nDESCRIPTION: The snippet shows the automatically generated Dart class that corresponds to the Rust struct. It includes a getter and setter for the 'something' property, which are generated based on the Rust annotations. This enables seamless property access in Dart code, leveraging the Rust definitions, with dependencies on the code generation capabilities of Flutter Rust Bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/properties.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass A {\n    String get something { ... }\n    void set something (String value) { ... }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Dart Application with Native Asset Support (Shell)\nDESCRIPTION: Runs a Dart application with the experimental native assets feature enabled, allowing integration with native libraries such as Rust modules through flutter_rust_bridge. Requires Dart SDK with the experimental '--enable-experiment=native-assets' flag and the example project code. Expected input is a properly set up Dart project in the specified folder, and the output is the execution of 'main.dart' with native assets support. The flag is a temporary prerequisite until the Dart team releases built-in native asset support.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/miscellaneous/pure-dart.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndart --enable-experiment=native-assets run lib/main.dart\n```\n\n----------------------------------------\n\nTITLE: Using flutter_rust_bridge_serve Tool for Web Development (bash)\nDESCRIPTION: Describes how to incorporate and utilize the `flutter_rust_bridge_serve` tool. This tool simplifies the process of building the WASM binary and serving the web application, replacing the standard `flutter web` command. It can be used via `dart run` within a project or installed globally with `dart pub global activate`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/01-setup/03-web.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# in your Flutter/Dart package\nflutter pub add flutter_rust_bridge\n# then run this instead of \"flutter web -d chrome\"\ndart run flutter_rust_bridge:serve\n# or install globally\ndart pub global activate flutter_rust_bridge\nflutter_rust_bridge_serve\n```\n\n----------------------------------------\n\nTITLE: Using Struct Methods in Dart (without Bridge)\nDESCRIPTION: This Dart code demonstrates how the methods are called when using the `--no-use-bridge-in-method` flag, meaning the bridge is not explicitly used within the method calls. The methods are accessed through the API.  It specifies the expected input parameters for each method call.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_methods.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass SumWith {\n  final int x;\n\n  const SumWith({\n    required this.x,\n  });\n\n  Future<int> sum({required int y, dynamic hint}) => api.sumMethodSumWith(\n        that: this,\n        y: y,\n      );\n\n  static Future<int> sumStatic({required int x, required int y, dynamic hint}) =>\n      api.sumStaticStaticMethodSumWith(x: x, y: y, hint: hint);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Struct Methods Attributes in Rust\nDESCRIPTION: Demonstrates how to add attributes to a struct method defined in a third-party crate by writing an external `impl` block with the #[frb(external)] attribute and marking the method with #[frb(sync)] for synchronous Dart code generation. Requires no modification to the original third-party code and omits argument and return type specifications.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/override-attributes.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// src/third_party/some_crate/hello/world/mod.rs\n#[frb(external)]\nimpl SomeStruct {\n    #[frb(sync)] // <-- This attribute will be auto merged to third-party code\n    pub fn method() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Tuple Coordinates in Rust\nDESCRIPTION: Defines a Rust function named `my_coordinate` that returns a tuple of two 64-bit floating-point numbers representing coordinates. This function is designed to provide coordinate data that can be consumed by other languages such as Dart via FFI. The tuple contains latitude and longitude as (f64, f64).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/tuple.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn my_coordinate() -> (f64, f64);\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings in CMake\nDESCRIPTION: Applies a standard set of CMake build settings (like compiler flags, optimization levels for different build types) to the defined executable target `${BINARY_NAME}`. This function (`apply_standard_settings`) is typically provided by Flutter's CMake tooling to ensure consistent and appropriate build configurations across projects.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Apply the standard set of build settings. This can be removed for applications\n# that need different build settings.\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Defining and Using RustOpaque Types with Locks in Rust\nDESCRIPTION: This Rust code snippet illustrates how to define an arbitrary struct, make functions that accept and return RustOpaque-wrapped types (including synchronization primitives like Mutex and RwLock), and an enum containing a RustOpaque. Dependencies required include flutter_rust_bridge and standard Rust library types such as std::sync::Mutex and std::sync::RwLock. The key parameters are the wrapped Rust types, and interaction occurs via opaque pointers on the Dart side. Inputs and outputs maintain object identity without copying or reconstructing the underlying Rust data. Manual memory management is crucial to avoid leaks.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_rust_opaque.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct ArbitraryData { ... }\npub fn use_opaque(a: RustOpaque<ArbitraryData>) { ... }\npub fn even_use_locks(b: RustOpaque<Mutex<ArbitraryData>>) -> RustOpaque<RwLock<ArbitraryData>> { ... }\nenum AnEnumContainingOpaque { Hello(RustOpaque<ArbitraryData>), World(i32) }\n...\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Compilation Settings in CMake\nDESCRIPTION: Defines standard compilation settings including Unicode support and a function `APPLY_STANDARD_SETTINGS` to apply common options to targets. This function enables C++17 features, sets Windows-specific warning levels (/W4, /WX, disabling warning 4100), enables structured exception handling (/EHsc), disables C++ exceptions for performance (_HAS_EXCEPTIONS=0), and defines _DEBUG for Debug builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Use Unicode for all projects.\nadd_definitions(-DUNICODE -D_UNICODE)\n\n# Compilation settings that should be applied to most targets.\n#\n# Be cautious about adding new options here, as plugins use this function by\n# default. In most cases, you should add new options to specific targets instead\n# of modifying this function.\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Dart String to wire_uint_8_list conversion\nDESCRIPTION: This Dart code snippet converts a Dart String into a `wire_uint_8_list` by first encoding the string to a Uint8List, then creating a new `wire_uint_8_list` and setting its pointer to the encoded data. This function is part of the Dart to Rust data transfer process in Flutter Rust Bridge when using the CST codec. The memory is allocated using `inner.new_uint_8_list_0`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/cst-codec.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nffi.Pointer<wire_uint_8_list> _api2wire_String(String raw) {\n  return _api2wire_uint_8_list(utf8.encoder.convert(raw));\n}\n\nffi.Pointer<wire_uint_8_list> _api2wire_uint_8_list(Uint8List raw) {\n  final ans = inner.new_uint_8_list_0(raw.length);\n  ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping DartOpaque Objects in Rust\nDESCRIPTION: Illustrates how Rust can take ownership and manage the lifecycle (dropping) of a Dart object passed as `DartOpaque`. The Rust code provides synchronous (`sync_accept_dart_opaque`) and asynchronous (`async_accept_dart_opaque`) functions that accept `DartOpaque` and explicitly call `drop()` on it. The Dart code shows passing closures to these Rust functions, demonstrating safe cleanup on the Rust side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/dart_opaque_type_safety.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub fn sync_accept_dart_opaque(opaque: DartOpaque) -> SyncReturn<String> {\n    drop(opaque);\n    SyncReturn(\"test\".to_owned())\n}\n\npub fn async_accept_dart_opaque(opaque: DartOpaque) {\n    drop(opaque);\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n// the closure is safely removed on the Rust side (on another thread)\nawait api.asyncAcceptDartOpaque(opaque: () => 'Test_String');\n// the closure is safely removed on the Rust side (on current thread)\napi.syncAcceptDartOpaque(opaque: () => 'Test_String');\n```\n\n----------------------------------------\n\nTITLE: Setting Cross-Origin Headers in Flutter Web (flutter drive)\nDESCRIPTION: This shell command configures cross-origin headers when running Flutter web tests using `flutter drive`. It sets the same headers as `flutter run` to enable shared buffers for features like asynchronous WASM in a testing environment. The command needs the Flutter SDK to be properly configured in the environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/02-web-cross-origin.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nflutter drive --web-header=Cross-Origin-Opener-Policy=same-origin --web-header=Cross-Origin-Embedder-Policy=require-corp\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Library Build with CMake for Flutter Plugin - CMake\nDESCRIPTION: This snippet enforces a minimum CMake version of 3.14 to ensure compatibility with Visual Studio tooling required by Flutter. It sets project-level configurations including project name and programming language (C++). The snippet incorporates an external CMake module (cargokit.cmake) to apply cargo-based Rust build logic, linking the Rust build system with CMake. It sets the list of bundled Rust libraries that the Flutter plugin will embed, facilitating the packaging of libraries for distribution. Dependencies include having Visual Studio with CMake >= 3.14 and the cargokit CMake module. Inputs include project path parameters for cargokit, and outputs include bundled library paths for the plugin build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nset(PROJECT_NAME \"rust_lib_frb_example_rust_ui_counter\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../../../../../ rust_lib_frb_example_rust_ui_counter \"\")\n\nset(rust_lib_frb_example_rust_ui_counter_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Setting minimum CMake version to 3.10 in CMakeLists.txt\nDESCRIPTION: Specifies the minimum required version of CMake as 3.10, which is needed for compatibility with Flutter tooling. The comment notes that increasing this version higher than 3.10 may cause the plugin to fail for some users, imposing a constraint on upgrade. This ensures consistent build behavior across different environments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Ensure Build Runner is Executed for Freezed Files\nDESCRIPTION: Advises running build_runner to regenerate '.freezed.dart' or '.g.dart' files to avoid outdated code, thus maintaining synchronization between source annotations and generated code during development.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Listing Core Wrapper Sources\nDESCRIPTION: This snippet lists the core C++ source files used in the wrapper. These files provide the bridge between the Flutter engine and the native code.  `CPP_WRAPPER_SOURCES_CORE` stores the list of core C++ source file names.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using Dart Opaque Types in Flutter\nDESCRIPTION: This Dart code demonstrates interacting with the Rust functions defined previously. It calls `putDartOpaque` to pass a Dart closure (`() => '42'`) to Rust. Then, it calls `getDartOpaque` to retrieve the opaque type from Rust, casts it to a function, and finally executes the retrieved function.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-opaque.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nawait putDartOpaque(() => '42');\nvar answer = (await getDartOpaque()) as String Function(); // it is the `() => '42'` closure\nprint(answer()); // print '42'\n```\n\n----------------------------------------\n\nTITLE: Using RustAutoOpaque for Opaque Field B (Rust)\nDESCRIPTION: This code snippet shows the diff of modifying the field `b` of Struct `A` to use `RustAutoOpaque<B>`. This allows shared ownership of B, allowing it to be used multiple times.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/opaque-in-translatable.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n-    pub b: B,\n+    pub b: RustAutoOpaque<B>,\n```\n\n----------------------------------------\n\nTITLE: Defining DartOpaqueNonClone for Safe Non-Cloneable Dart Handles in Rust\nDESCRIPTION: Defines `DartOpaqueNonClone` struct that contains a `ThreadBox` wrapping a `GeneralizedAutoDropDartPersistentHandle`, along with a sendable Dart message port handle (`drop_port`). This struct encapsulates safe usage semantics of Dart opaque handles across threads with proper drop delegation, avoiding cloning but maintaining thread-safe handling via encapsulated send/sync.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct DartOpaqueNonClone {\n    persistent_handle: ThreadBox<GeneralizedAutoDropDartPersistentHandle>,\n    drop_port: SendableMessagePortHandle,\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring an Asynchronous Function in Rust\nDESCRIPTION: This snippet demonstrates the syntax for declaring an asynchronous function in Rust using the `async fn` construct. It is intended to be recognized by the flutter_rust_bridge code generator, which provides proper bindings for use in Dart. The function body is incomplete in this example (using ellipsis), primarily serving as a template. Required dependencies include Rust 2018+ with `async fn` support. Inputs and outputs depend on the actual function implementation, but functions declared this way may perform I/O or network requests asynchronously. The main constraint is that the function must be compatible with the chosen async runtime.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/async-rust.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn f() { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding Executable Target (C++)\nDESCRIPTION: This code block defines the executable target for the Flutter application. It uses the `BINARY_NAME` variable to name the executable, making sure the flutter run command works. It then lists all the source files required. This step is critical for specifying the files to be compiled and linked to create the application executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Build Variables in CMake\nDESCRIPTION: Defines several CMake variables related to the Flutter build outputs and paths. `FLUTTER_LIBRARY` points to the main Flutter engine library, `FLUTTER_ICU_DATA_FILE` to the ICU data file, `PROJECT_BUILD_DIR` to the project's build output directory, and `AOT_LIBRARY` to the compiled application library. These variables are set with `PARENT_SCOPE` to be accessible outside the current directory scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapper Sources Core and Plugin\nDESCRIPTION: This snippet defines sources used to create the wrapper libraries, splitting them into core and plugin components and prepending the WRAPPER_ROOT directory to them.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# === Wrapper ===\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Encodable Struct in Rust\nDESCRIPTION: Defines a Rust struct `MyNonEncodableType` which contains a field that is not trivially encodable for FFI, such as a temporary directory or native resource. This struct is used as an example for the `RustAutoOpaque` feature, allowing it to be passed between Rust and Dart without explicit encoding/decoding logic.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/overview.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyNonEncodableType {\n    // e.g., a temporary directory, a file descriptor, a native resource, a lock, a channel, ...\n    sample_non_encodable_field: tempdir::TempDir,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing AOT Library (Non-Debug)\nDESCRIPTION: Installs the AOT (Ahead-Of-Time) library to the library directory within the build bundle if the build type is not Debug. This library provides pre-compiled code for better performance. The installation occurs as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Using Generated Dart Signatures for Rust Trait Objects in Flutter Rust Bridge\nDESCRIPTION: Shows how the Rust function accepting a trait object reference translates to Dart with the trait type as the argument. Demonstrates calling the function with instances of two different structs implementing the trait. This snippet depends on the Flutter Rust Bridge code generation that converts Rust trait references to Dart types for seamless interoperability.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/trait-objects.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nvoid f(MyTrait a) => ...;\n\nMyStructOne one = ...;\nMyStructTwo two = ...;\n\nf(one); // allowed\nf(two); // also allowed\n```\n\n----------------------------------------\n\nTITLE: Set minimum CMake version\nDESCRIPTION: Specifies the minimum required CMake version for the project. This ensures compatibility with older systems and prevents the use of unsupported features. The version is set to 3.10 to align with Flutter's requirements.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Adding Plugin Wrapper Library\nDESCRIPTION: Creates the `flutter_wrapper_plugin` library. It links to flutter, includes the necessary headers, and adds dependencies for the build process. Uses `STATIC` and `INTERFACE` to define how the library is built and consumed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Dependabot Configuration for Pub Packages\nDESCRIPTION: This YAML configuration sets up dependabot to automatically create pull requests for updating dependencies in the pub ecosystem.  It specifies the package-ecosystem as 'pub' and targets specific directories within the project structure. It also defines the update interval as 'weekly'.  The `library_name` needs to be replaced with the actual name of the library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: 2\nenable-beta-ecosystems: true\nupdates:\n  - package-ecosystem: pub\n    directory: \"/packages/library_name\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/library_name/example\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/flutter_library_name\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/flutter_library_name/example\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: cargo\n    directory: \"/packages/library_name/native\"\n    schedule:\n      interval: weekly\n```\n\n----------------------------------------\n\nTITLE: Clearing Flutter Cache (Shell)\nDESCRIPTION: This shell command removes the Flutter cache to ensure the modified source code is correctly recognized after the changes in `devfs_web.dart`. It is a necessary step to update Flutter after making the modifications. Requires access to the file system of the flutter installation and the shell environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/02-web-cross-origin.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nrm /whatever-path/bin/cache/flutter_tools.stamp\n```\n\n----------------------------------------\n\nTITLE: Initializing Dart/Rust Monorepo Structure (Bash Script)\nDESCRIPTION: A Bash script to automate the creation of a monorepo for a Flutter/Rust project. It initializes Git, creates root configurations (Cargo.toml, analysis_options.yaml, .gitignore), sets up a Dart package with FFI boilerplate, adds dependencies, and initializes a Rust native sub-project including build scripts and Cargo configuration. Requires user-defined variables `$LIBNAME` and `$DART_CLASS_NAME` at the beginning.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/dart_only.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nLIBNAME=library_name # snake_case\nDART_CLASS_NAME=LibraryName # probably is PascalCase version of $LIBNAME\n\n# Monorepo setup\nmkdir -p $LIBNAME/packages\ncd $LIBNAME\ngit init\n\ncat << EOF >> Cargo.toml\n[workspace]\nmembers = [\"packages/$LIBNAME/native\"]\nEOF\n\ncat << EOF >> analysis_options.yaml\n# TODO change the below options/lints as you see fit\nanalyzer:\n  exclude:\n    - '**.freezed.dart'\n    - '**.g.dart'\n  language:\n    strict-inference: true\n    strict-raw-types: true\n  errors:\n    invalid_annotation_target: ignore\n\nlinter:\n  rules:\n    # Custom lints\n    - prefer_single_quotes\n\n    # Core Dart lints\n    - avoid_empty_else\n    - avoid_relative_lib_imports\n    - avoid_shadowing_type_parameters\n    - avoid_types_as_parameter_names\n    - await_only_futures\n    - camel_case_extensions\n    - camel_case_types\n    - curly_braces_in_flow_control_structures\n    - depend_on_referenced_packages\n    - empty_catches\n    - file_names\n    - hash_and_equals\n    - iterable_contains_unrelated_type\n    - list_remove_unrelated_type\n    - no_duplicate_case_values\n    - non_constant_identifier_names\n    - null_check_on_nullable_type_parameter\n    - package_prefixed_library_names\n    - prefer_generic_function_type_aliases\n    - prefer_is_empty\n    - prefer_is_not_empty\n    - prefer_iterable_whereType\n    - prefer_typing_uninitialized_variables\n    - provide_deprecation_message\n    - unnecessary_overrides\n    - unrelated_type_equality_checks\n    - valid_regexps\n    - void_checks\n\n    # Recommended Dart lints\n    - always_require_non_null_named_parameters\n    - annotate_overrides\n    - avoid_function_literals_in_foreach_calls\n    - avoid_init_to_null\n    - avoid_null_checks_in_equality_operators\n    - avoid_renaming_method_parameters\n    - avoid_return_types_on_setters\n    - avoid_returning_null_for_void\n    - avoid_single_cascade_in_expression_statements\n    - constant_identifier_names\n    - control_flow_in_finally\n    - empty_constructor_bodies\n    - empty_statements\n    - exhaustive_cases\n    - implementation_imports\n    - library_names\n    - library_prefixes\n    - library_private_types_in_public_api\n    - no_leading_underscores_for_library_prefixes\n    - no_leading_underscores_for_local_identifiers\n    - null_closures\n    - overridden_fields\n    - package_names\n    - prefer_adjacent_string_concatenation\n    - prefer_collection_literals\n    - prefer_conditional_assignment\n    - prefer_contains\n    - prefer_equal_for_default_values\n    - prefer_final_fields\n    - prefer_for_elements_to_map_fromIterable\n    - prefer_function_declarations_over_variables\n    - prefer_if_null_operators\n    - prefer_initializing_formals\n    - prefer_inlined_adds\n    - prefer_interpolation_to_compose_strings\n    - prefer_is_not_operator\n    - prefer_null_aware_operators\n    - prefer_spread_collections\n    - prefer_void_to_null\n    - recursive_getters\n    - slash_for_doc_comments\n    - type_init_formals\n    - unnecessary_brace_in_string_interps\n    - unnecessary_const\n    - unnecessary_constructor_name\n    - unnecessary_getters_setters\n    - unnecessary_late\n    - unnecessary_new\n    - unnecessary_null_aware_assignments\n    - unnecessary_null_in_if_null_operators\n    - unnecessary_nullable_for_final_variable_declarations\n    - unnecessary_string_escapes\n    - unnecessary_string_interpolations\n    - unnecessary_this\n    - use_function_type_syntax_for_parameters\n    - use_rethrow_when_possible\n\n    # Flutter lints\n    - avoid_print\n    - avoid_unnecessary_containers\n    - avoid_web_libraries_in_flutter\n    - no_logic_in_create_state\n    - prefer_const_constructors\n    - prefer_const_constructors_in_immutables\n    - prefer_const_declarations\n    - prefer_const_literals_to_create_immutables\n    - sized_box_for_whitespace\n    - sort_child_properties_last\n    - use_build_context_synchronously\n    - use_full_hex_values_for_flutter_colors\n    - use_key_in_widget_constructors\nEOF\n\ncat << EOF >> .gitignore\n# Miscellaneous\n*.class\n*.log\n*.pyc\n*.swp\n.DS_Store\n.atom/\n.buildlog/\n.history\n.svn/\n\n# IntelliJ related\n*.iml\n*.ipr\n*.iws\n.idea/\n\n# The .vscode folder contains launch configuration and tasks you configure in\n# VS Code which you may wish to be included in version control, so this line\n# is commented out by default.\n#.vscode/\n\n# Flutter/Dart/Pub related\npubspec.lock\npubspec_overrides.yaml\n**/doc/api/\n.dart_tool/\n.packages\nbuild/\n.pub-cache/\n.pub/\n.flutter-plugins\n.flutter-plugins-dependencies\n\n# Rust related\n/target/\n/Cargo.lock\n/platform-build\nEOF\n\n# Dart setup\nDART_BASE=packages/$LIBNAME\ndart create --template=package $DART_BASE\n(cd $DART_BASE && dart pub add flutter_rust_bridge ffi && dart pub add ffigen --dev)\nrm $DART_BASE/analysis_options.yaml # we provide our own in repo root\n( # ffi setup\ncd $DART_BASE\nmkdir -p lib/src/ffi\n\ncat << EOF >> lib/src/ffi/stub.dart\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\n/// Represents the external library for $LIBNAME\n///\n/// Will be a DynamicLibrary for dart:io or WasmModule for dart:html\ntypedef ExternalLibrary = Object;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary lib) =>\n    throw UnimplementedError();\nEOF\n\ncat << EOF >> lib/src/ffi/io.dart\nimport 'dart:ffi';\n\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\ntypedef ExternalLibrary = DynamicLibrary;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary dylib) =>\n    ${DART_CLASS_NAME}Impl(dylib);\nEOF\n\ncat << EOF >> lib/src/ffi/web.dart\nimport 'package:$LIBNAME/src/bridge_generated.dart';\nimport 'package:flutter_rust_bridge/flutter_rust_bridge.dart';\n\ntypedef ExternalLibrary = WasmModule;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary module) =>\n    ${DART_CLASS_NAME}Impl.wasm(module);\nEOF\n\ncat << EOF >> lib/src/ffi.dart\nimport 'bridge_generated.dart';\nimport 'ffi/stub.dart'\n    if (dart.library.io) 'ffi/io.dart'\n    if (dart.library.js_interop) 'ffi/web.dart';\n\n$DART_CLASS_NAME? _wrapper;\n\n$DART_CLASS_NAME createWrapper(ExternalLibrary lib) {\n  _wrapper ??= createWrapperImpl(lib);\n  return _wrapper!;\n}\nEOF\n\necho \"export 'src/ffi.dart';\" >> lib/$LIBNAME.dart\n)\n\n# Rust setup\nRUST_BASE=$DART_BASE/native\nmkdir -p $RUST_BASE/src\n\ncat << EOF >> $RUST_BASE/build.rs\nuse lib_flutter_rust_bridge_codegen::{\n    config_parse, frb_codegen, get_symbols_if_no_duplicates, RawOpts,\n};\n\nconst RUST_INPUT: &str = \"src/api.rs\";\nconst DART_OUTPUT: &str = \"../lib/src/bridge_generated.dart\";\n\nconst IOS_C_OUTPUT: &str = \"../../flutter_$LIBNAME/ios/Classes/frb.h\";\nconst MACOS_C_OUTPUT_DIR: &str = \"../../flutter_$LIBNAME/macos/Classes/\";\n\nfn main() {\n    // Tell Cargo that if the input Rust code changes, rerun this build script\n    println!(\"cargo:rerun-if-changed={}\", RUST_INPUT);\n\n    // Options for frb_codegen\n    let raw_opts = RawOpts {\n        rust_input: vec![RUST_INPUT.to_string()],\n        dart_output: vec![DART_OUTPUT.to_string()],\n        c_output: Some(vec![IOS_C_OUTPUT.to_string()]),\n        extra_c_output_path: Some(vec![MACOS_C_OUTPUT_DIR.to_string()]),\n        inline_rust: true,\n        wasm: true,\n        ..Default::default()\n    };\n\n    // Generate Rust & Dart ffi bridges\n    let configs = config_parse(raw_opts);\n    let all_symbols = get_symbols_if_no_duplicates(&configs).unwrap();\n    for config in configs.iter() {\n        frb_codegen(config, &all_symbols).unwrap();\n    }\n\n    // Format the generated Dart code\n    _ = std::process::Command::new(\"flutter\")\n        .arg(\"format\")\n        .arg(\"..\")\n        .spawn();\n}\nEOF\n\ncat << EOF >> $RUST_BASE/.gitignore\n# Rust library related\nCargo.lock\ntarget\nEOF\n\ncat << EOF >> $RUST_BASE/Cargo.toml\n[package]\nname = \"$LIBNAME\"\nversion = \"0.0.0\"\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\"]\n\n[build-dependencies]\nflutter_rust_bridge_codegen = \"1.62.*\"\n\n[dependencies]\nflutter_rust_bridge = \"1.62.*\"\nEOF\n\ntouch $RUST_BASE/src/api.rs\n\ncat << EOF >> $RUST_BASE/src/lib.rs\nmod api;\nEOF\n\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Initializing RustLib with Custom Handler - Dart\nDESCRIPTION: This code snippet demonstrates how to initialize the `RustLib` with a custom handler. The `YourCustomHandler` class, which should be a subclass of `BaseHandler`, allows for adding custom logic before and after Rust functions are called from Dart. This enables features such as logging or timing.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/inspect.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nawait RustLib.init(handler: YourCustomHandler());\n```\n\n----------------------------------------\n\nTITLE: Setting Fallback Configurations for Target Platform\nDESCRIPTION: This snippet sets a fallback value for the `FLUTTER_TARGET_PLATFORM` variable if it's not already defined, which is intended for older Flutter tool versions. The default target platform is windows-x64.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Converting Native Pointers to Rust Vec<u8> and String Types - Rust\nDESCRIPTION: These Rust implementations define how pointers from FFI (specifically *mut wire_uint_8_list) are transformed into Vec<u8> and String Rust types. It relies on auxiliary support functions for safe heap management (box_from_leak_ptr, vec_from_leak_ptr). The wire2api function for Vec<u8> unsafely reclaims ownership of the buffer and length, while the String implementation decodes the byte vector using UTF-8 lossless conversion. Dependencies include correct memory management on both Dart and Rust sides. Inputs are leaked pointers from FFI code, and outputs are owned Rust types. Malformed UTF-8 is gracefully handled through lossy conversion but double-frees or leaks must be prevented by careful pointer management.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/design.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nimpl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {\n    fn wire2api(self) -> Vec<u8> {\n        unsafe {\n            let wrap = support::box_from_leak_ptr(self);\n            support::vec_from_leak_ptr(wrap.ptr, wrap.len)\n        }\n    }\n}\n\nimpl Wire2Api<String> for *mut wire_uint_8_list {\n    fn wire2api(self) -> String {\n        let vec: Vec<u8> = self.wire2api();\n        String::from_utf8_lossy(&vec).into_owned()\n    }\n}\n\npub struct wire_uint_8_list {\n    ptr: *mut u8,\n    len: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Library Headers List\nDESCRIPTION: Creates a list of Flutter library header files required for interacting with the Flutter engine API. The list items are transformed to include the `EPHEMERAL_DIR` path.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\n```\n\n----------------------------------------\n\nTITLE: Setting Sysroot for Cross-Building\nDESCRIPTION: Configures the sysroot for cross-building, if FLUTTER_TARGET_PLATFORM_SYSROOT is defined.  It sets the CMAKE_SYSROOT and CMAKE_FIND_ROOT_PATH variables and configures the search modes for programs, packages, libraries, and includes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLUTTER_TARGET_PLATFORM_SYSROOT)\n  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Failed Attempt to Convert Async to Sync with Futures Executor\nDESCRIPTION: An attempt to make the async function synchronous by using futures::executor::block_on. This will fail with Reqwest because it uses Tokio runtime instead of futures runtime.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow;\nuse futures::executor::block_on;\n\nfn get() -> anyhow::Result<String> {\n    block_on(async {\n        let url = \"https://link/to/file/download\";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Rust Bridge Dependency in pubspec.yaml\nDESCRIPTION: Specifies version 1.62.1 for the `flutter_rust_bridge` dependency within the Dart package's `pubspec.yaml` file. This version is recommended for compatibility with the guide.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/dart_only.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n  flutter_rust_bridge: \"1.62.1\"\n```\n\n----------------------------------------\n\nTITLE: Prepending App Wrapper Sources Directory\nDESCRIPTION: This snippet prepends the `WRAPPER_ROOT` directory to the app wrapper source file names.  This constructs the full path. The `TRANSFORM` command performs the prepending operation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Unwrapping RustOpaque in Rust\nDESCRIPTION: Demonstrates how to safely unwrap a RustOpaque type in Rust when full ownership is transferred from Dart. This pattern is useful when you need to extract the inner value from the opaque wrapper.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn unwrap_rust_opaque(opaque: Opaque<HideData>) -> Result<String> {\n    let res: Result<HideData, Opaque<HideData>> = opaque.try_unwrap();\n    let data: HideData = res.map_err(|_| anyhow::anyhow!(\"opaque type is shared\"))?;\n    Ok(data.hide_data())\n}\n```\n\n----------------------------------------\n\nTITLE: Approach 2: Explicitly Creating Tokio Runtime\nDESCRIPTION: A more explicit approach that manually creates a Tokio runtime and uses its block_on method to execute the async code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow;\nuse tokio::runtime::Runtime;\n\nfn get() -> anyhow::Result<String> {\n    let rt = Runtime::new().unwrap();\n    rt.block_on(async {\n        let url = \"https://link/to/file/download\";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: Initializes the CMake project, setting the minimum required CMake version and project name, and specifies the CXX language. It sets up the basic environment for the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Linking App Wrapper Dependencies\nDESCRIPTION: This snippet links the `flutter_wrapper_app` to the `flutter` library.  This grants access to the Flutter functions. The `PUBLIC` keyword signifies that the dependency is also available to projects that use this wrapper.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project and Language (CMake)\nDESCRIPTION: Defines the main CMake project with the name \"rust_lib_flutter_via_create\". It specifies that the project primarily uses the CXX (C++) language, which is common when bridging between Rust and native platforms consumed by Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"rust_lib_flutter_via_create\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Flutter-Rust Integration\nDESCRIPTION: Required modifications to the Cargo.toml file to configure the Rust library for use with Flutter. This sets up the crate-type as cdylib for Android support and staticlib for iOS support.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/set_up_from_scratch.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n[lib]\nname = \"flutter_rust_bridge_example\" # whatever you like\n# notice this type. `cdylib` for android, and `staticlib` for iOS. I write down a script to change it before build.\n+ crate-type = [\"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Command for Flutter Tool\nDESCRIPTION: This snippet defines a custom command to execute the Flutter tool backend.  It creates a phony file to ensure it runs every time. It uses the flutter tool environment and the tool_backend.sh script and specifies the platform and build type. It depends on the Flutter library and headers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Getter for a Constant\nDESCRIPTION: This Dart code shows the getter that is automatically generated by flutter_rust_bridge for the `CONST_INT` constant defined in Rust. This getter allows accessing the value of the Rust constant from Dart code. The `TwinNormal` suffix is likely related to the configuration or naming conventions used by the tool.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/constants.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nint get constIntTwinNormal => ...;\n```\n\n----------------------------------------\n\nTITLE: Missing Dispose Call on Web Platforms in Dart\nDESCRIPTION: Explains the behavior when dispose() is not called on web platforms. Unlike on native platforms, the finalizer is not guaranteed to run before program termination, making proper disposal critical.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque(); \n\n// (Arc counter = 2) increases immediately. \nString hideData = await api.rustOpaque(opaque);\n\n// (Arc counter = 1)\n//\n// Rust:\n//\n//`executes rust_call_example and counter decreases.`\n\n// memory of opaque types is not monitoring by Dart and can accumulate.\n// (Arc count can be 0 or 1) don't count on automatic clearing.\n//\n// Dart:\n//\n//`the finalizer is NOT guaranteed to be called before the program terminates.`\n```\n\n----------------------------------------\n\nTITLE: Calling Rust from Dart Concurrently\nDESCRIPTION: This Dart code calls the `compute` function (defined in Rust) three times and uses `Future.wait` to ensure that all three calls complete before proceeding. This allows the `compute` functions to run concurrently, reducing the overall execution time.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/concurrency.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nvar a = compute();\nvar b = compute();\nvar c = compute();\nawait Future.wait([a, b, c]); // You may need to learn `Future` and `async` in Dart to understand this\n```\n\n----------------------------------------\n\nTITLE: Appending Flutter Library Headers\nDESCRIPTION: Appends a list of Flutter library header files to the `FLUTTER_LIBRARY_HEADERS` variable. These headers provide the necessary interfaces for interacting with the Flutter engine.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring build.gradle for Android Integration\nDESCRIPTION: Modifies the build.gradle file to set the Android SDK versions and trigger the binary download process through the CMake configuration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/android.md#_snippet_1\n\nLANGUAGE: gradle\nCODE:\n```\nandroid {\n    compileSdkVersion 31\n\n    defaultConfig {\n        minSdkVersion 16\n    }\n\n    // Trigger the binary download/update over in CMakeLists.txt\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Assembly Dependency\nDESCRIPTION: Adds a dependency on flutter_assemble, ensuring that the Flutter assets are built as part of the build process.  This makes the Flutter assets available to the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Melos Configuration - YAML\nDESCRIPTION: This YAML configuration file defines the settings for a Melos monorepo. It specifies the project name, repository, package locations, and scripts for various tasks like analyzing, formatting, versioning, building, and testing the project. The `scripts` section contains commands to be executed for each task.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/01-overview/02-melos.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: library_name\n\nrepository: https://github.com/YourGitHubAccount/library_name\n\npackages:\n  - packages/**\n\nscripts:\n  analyze:\n    exec: flutter analyze .\n    description: Analyze a specific package in this project.\n\n  check-format:\n    exec: dart format --set-exit-if-changed .\n    description: Check the format of a specific package in this project.\n\n  format:\n    exec: dart format .\n    description: Format a specific package in this project.\n\n  version:\n    description: Updates version numbers in all build files\n    run: bash scripts/version.sh\n\n  build:\n    run: melos run build:apple && melos run build:android && melos run build:other\n    description: Build all native libraries for the project.\n\n  build:apple:\n    run: bash scripts/build-apple.sh\n    description: Build the XCFramework for iOS and macOS.\n\n  build:android:\n    run: bash scripts/build-android.sh\n    description: Build the .tar.gz for Android.\n\n  build:other:\n    run: bash scripts/build-other.sh\n    description: Build the .tar.gz for all other platforms.\n\n  test:\n    run: melos run test:dart --no-select && melos run test:flutter --no-select\n    description: Run all Dart & Flutter tests in this project.\n\n  test:dart:\n    run: melos exec -c 1 --fail-fast -- \"dart test test\"\n    description: Run Dart tests for a specific package in this project.\n    select-package:\n      flutter: false\n      dir-exists: test\n\n  test:flutter:\n    run: melos exec -c 1 --fail-fast -- \"flutter test test\"\n    description: Run Flutter tests for a specific package in this project.\n    select-package:\n      flutter: true\n      dir-exists: test\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project and Build Types for Flutter Rust Bridge in CMake\nDESCRIPTION: Sets the minimum required CMake version to 3.14 and names the project 'frb_example_rust_ui_counter' with C++ language support. Configures multi-configuration generators and default build types (Debug, Profile, Release). Defines Profile mode to inherit flags from Release. Ensures Unicode definitions are added globally.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(frb_example_rust_ui_counter LANGUAGES CXX)\n\nset(BINARY_NAME \"frb_example_rust_ui_counter\")\n\ncmake_policy(VERSION 3.14...3.25)\n\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Dependencies for Tokio Main Macro Approach\nDESCRIPTION: Required dependencies for using the tokio::main macro approach with reqwest.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nfutures = \"0.3\"\nreqwest = \"0.11.6\"\ntokio = { version = \"1.14.0\", features = [\"rt\", \"macros\"] }\nanyhow = { version = \"1.0.49\" }\n```\n\n----------------------------------------\n\nTITLE: Using Lifetime-Bound Types in Dart via flutter_rust_bridge\nDESCRIPTION: Shows how to interact with generated Dart bindings for Rust types involving lifetimes. It demonstrates creating an instance of `Foo`, calling a method (`computeBar`) that returns a lifetime-bound `Bar` instance (referencing `Foo`), and then calling a method (`greet`) on the `Bar` instance. This assumes `flutter_rust_bridge` code generation has been successfully run on the corresponding Rust code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/type-with-lifetimes.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nvar foo = Foo(..);\nvar bar = foo.computeBar();\nbar.greet();\n```\n\n----------------------------------------\n\nTITLE: Including and Applying Cargokit (CMake)\nDESCRIPTION: Includes the external `cargokit.cmake` script, which provides functions to integrate a Rust Cargo project into the CMake build. The `apply_cargokit` function is then called, linking the CMake project name, the relative path to the Rust source directory, and the name of the Rust library target to be built and integrated.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../rust rust_lib_flutter_via_create \"\")\n```\n\n----------------------------------------\n\nTITLE: Converting a Rust Trait to a Dart Abstract Class - Dart\nDESCRIPTION: This Dart code snippet shows how the Rust `MyTrait` is converted into an abstract class called `MyTrait`. The method `f` from the Rust trait is included in the Dart abstract class as a method that takes a string and returns an integer. There are no dependencies. This demonstrates the auto-generation of Dart code from Rust traits.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/definitions.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n```dart\nabstract class MyTrait {\n  int f(String a);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: Defines the CMake project using the name set in the `PROJECT_NAME` variable. It specifies that the project uses the C++ language (`CXX`). This is the main command that declares the project to CMake.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Setting ANDROID_NDK Gradle Property\nDESCRIPTION: This snippet demonstrates how to set the `ANDROID_NDK` property in the Gradle configuration to specify the path to the Android NDK. It involves appending a line to the `~/.gradle/gradle.properties` file, making the NDK visible to Gradle and enabling the project to find and utilize the native libraries. The path should be replaced with the actual NDK installation path.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/setup_android.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\necho \"ANDROID_NDK=(path to NDK)\" >> ~/.gradle/gradle.properties\n```\n\n----------------------------------------\n\nTITLE: Profile Build Mode Settings\nDESCRIPTION: Configures the Profile build mode by copying the settings from the Release build mode. This simplifies the configuration and ensures consistency across different build types by using the Release settings as a baseline.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Rust Integration in Flutter Plugin (CMake)\nDESCRIPTION: This CMake snippet sets the minimum required CMake version to 3.10, defines the project and its supported language (C++), and integrates the external CargoKit module to build and link a Rust library with a Flutter plugin. It relies on the cargokit.cmake helper and applies the 'apply_cargokit' function, passing the project name and Rust sources path. The generated library paths are then specified for bundling, exposing them as a configurable variable to the parent CMake scope. The project's main dependency is the CargoKit CMake module and a compatible CMake installation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_lib_frb_example_rust_ui_todo_list\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../ rust_lib_frb_example_rust_ui_todo_list \"\")\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(rust_lib_frb_example_rust_ui_todo_list_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Delegation Using delegate-attr\nDESCRIPTION: This code uses the `delegate` attribute from the `delegate-attr` crate to automatically generate wrapper methods for the `Foo` struct. It indicates that method calls should be delegated to `self.0.lock().unwrap()`.  The method bodies are left empty as they are generated by the attribute macro.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/wrappers.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[delegate(self.0.lock().unwrap())] // <-- just add this, and leave the method body empty\nimpl Foo {\n    pub fn method_one(..) -> .. {}\n    pub fn method_two(..) -> .. {}\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Rust Struct with Extra Dart Code Using flutter_rust_bridge - Rust\nDESCRIPTION: This Rust code snippet demonstrates how to annotate a struct with the #[frb(dart_code = ...)] attribute, embedding additional Dart methods into the corresponding generated Dart class. Dependencies include flutter_rust_bridge and a correct build pipeline for Rust-to-Dart FFI binding. Parameters include the struct definition and the dart_code string; the Rust struct itself may contain fields and methods, but only those used in pub functions will trigger Dart code generation. The primary input is the Rust source, and the output is enhanced Dart code; constraints include writing valid Dart code suitable for a class body.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/dart-code.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(dart_code = \"\n    int extraMethod() => a * 2;\n\"\n)]\npub struct MyStruct {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tokio Runtime for Asynchronous Execution\nDESCRIPTION: This code snippet shows how to explicitly create a Tokio runtime and use `rt.block_on` to run the asynchronous `get` function. The function downloads a file from a given URL. This gives more control over the Tokio runtime than the `tokio::main` macro approach. It needs `anyhow`, `reqwest` and `tokio` crates.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse anyhow;\nuse tokio::runtime::Runtime;\n\nfn get() -> anyhow::Result<String> {\n    let rt = Runtime::new().unwrap();\n    rt.block_on(async {\n        let url = \"https://link/to/file/download\";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using the flutter_rust_bridge_codegen CLI Tool\nDESCRIPTION: Shows the basic command-line syntax for invoking the `flutter_rust_bridge_codegen` tool. It lists the main commands for code generation (`generate`), project creation (`create`), integration (`integrate`), web compilation (`build-web`), and help (`help`), along with options for verbosity (`-v`), help (`-h`), and version display (`-V`). The tool requires a command to be specified after the options.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/generated/_frb-codegen-command-main.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nFlutter/Dart <-> Rust binding generator, feature-rich, but seamless and simple\n\nUsage: flutter_rust_bridge_codegen [OPTIONS] <COMMAND>\n\nCommands:\n  generate   Execute the main code generator\n  create     Create a new Flutter + Rust project\n  integrate  Integrate Rust into existing Flutter project\n  build-web  Compile for the Web (WASM)\n  help       Print this message or the help of the given subcommand(s)\n\nOptions:\n  -v, --verbose  Show debug messages\n  -h, --help     Print help\n  -V, --version  Print version\n```\n\n----------------------------------------\n\nTITLE: Configuring crate-type in Cargo.toml\nDESCRIPTION: This snippet configures the `crate-type` in `Cargo.toml`.  It sets up the build for various platforms like iOS and MacOS. The `crate-type` directives inform the Rust compiler on how to build the crate (library, dynamic library, and static library).  The configuration ensures compatibility with iOS using `staticlib` and other platforms using `cdylib` along with `lib` for tests and benchmarks. No specific dependencies are required, but it assumes a working Cargo and a project that will be built for iOS and other platforms. The expected output is a Rust library that can be linked against the iOS or other native code. It is assumed the user has cargo installed and that this Cargo.toml file is present.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/02-tour/03-native-proj.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\ncrate-type = [\"lib\", \"cdylib\", \"staticlib\"]\n```\n\n----------------------------------------\n\nTITLE: Enabling Default Zero-Copy via Cargo Feature (TOML)\nDESCRIPTION: Configures the `flutter_rust_bridge` dependency in `Cargo.toml` to enable the `zero-copy` feature. This makes types like `Vec<u8>` use zero-copy transfer by default, eliminating the need to wrap them explicitly with `ZeroCopyBuffer`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/zero_copy.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n# Cargo.toml\n[dependencies]\nflutter_rust_bridge = { version = \"...\", features = [\"zero-copy\"] }\n```\n\n----------------------------------------\n\nTITLE: Syntactically Valid but Semantically Confusing flutter_rust_bridge_codegen Command\nDESCRIPTION: An example of a command that will compile and work but has inconsistent naming patterns between inputs and outputs, demonstrating that flutter_rust_bridge does not enforce semantic correctness across flag parameters.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_orange.rs\" \"$REPO_DIR/native/src/api_apple.rs\" \\\n        --dart-output \"$REPO_DIR/lib/gen_api_apple.dart\" \"$REPO_DIR/lib/gen_api_orange.dart\" \\\n        --class-name ApiClassOrange ApiClassApple \\\n        --rust-output generated_api_apple generated_api_orange\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings\nDESCRIPTION: Applies a standard set of build settings to the executable target.  The specific settings are defined elsewhere (presumably in a CMake module named apply_standard_settings).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Configuring Melos Monorepo Tool with YAML\nDESCRIPTION: Defines the Melos workspace configuration specifying repository details, package discovery patterns, and various reusable scripts for analyzing, formatting, building, versioning, and testing Dart and Flutter packages in the monorepo. Each script entry includes the command to execute and a brief description. This configuration enables streamlined development workflows for Flutter/Dart packages by standardizing command behaviors across the workspace.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/melos.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: library_name\n\nrepository: https://github.com/YourGitHubAccount/library_name\n\npackages:\n  - packages/**\n\nscripts:\n  analyze:\n    exec: flutter analyze .\n    description: Analyze a specific package in this project.\n\n  check-format:\n    exec: dart format --set-exit-if-changed .\n    description: Check the format of a specific package in this project.\n\n  format:\n    exec: dart format .\n    description: Format a specific package in this project.\n\n  version:\n    description: Updates version numbers in all build files\n    run: bash scripts/version.sh\n\n  build:\n    run: melos run build:apple && melos run build:android && melos run build:other\n    description: Build all native libraries for the project.\n\n  build:apple:\n    run: bash scripts/build-apple.sh\n    description: Build the XCFramework for iOS and macOS.\n\n  build:android:\n    run: bash scripts/build-android.sh\n    description: Build the .tar.gz for Android.\n\n  build:other:\n    run: bash scripts/build-other.sh\n    description: Build the .tar.gz for all other platforms.\n\n  test:\n    run: melos run test:dart --no-select && melos run test:flutter --no-select\n    description: Run all Dart & Flutter tests in this project.\n\n  test:dart:\n    run: melos exec -c 1 --fail-fast -- \"dart test test\"\n    description: Run Dart tests for a specific package in this project.\n    select-package:\n      flutter: false\n      dir-exists: test\n\n  test:flutter:\n    run: melos exec -c 1 --fail-fast -- \"flutter test test\"\n    description: Run Flutter tests for a specific package in this project.\n    select-package:\n      flutter: true\n      dir-exists: test\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for Flutter Plugin Build (CMake)\nDESCRIPTION: Specifies the minimum required CMake version as 3.14 to satisfy the Flutter tooling requirement for Visual Studio builds. This prevents issues arising from using newer CMake versions that could cause plugin compilation failures for users.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Cocoapods Podspec for iOS/macOS Flutter Binding\nDESCRIPTION: This Ruby-based podspec script defines the specifications for creating a CocoaPods library for Flutter bindings of a Rust library. It fetches the precompiled XCFramework from a GitHub release, sets deployment targets, and specifies source files and frameworks for integration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/ios_and_macos.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nrelease_tag_name = 'library_name-v0.0.0' # generated; do not edit\n\n# Fetch XCFramework from GitHub Release\nframework_name = 'LibraryName.xcframework'\nremote_zip_name = \"#{framework_name}.zip\"\nurl = \"https://github.com/YourGitHubAccount/repo_name/releases/download/#{release_tag_name}/#{remote_zip_name}\"\nlocal_zip_name = \"#{release_tag_name}.zip\"\n`cd Frameworks\nrm -rf #{framework_name}\n\nif [ ! -f #{local_zip_name} ]\nthen\n  curl -L #{url} -o #{local_zip_name}\nfi\n\nunzip #{local_zip_name}\ncd -`\n\nPod::Spec.new do |spec|\n  spec.name          = 'library_name'\n  spec.version       = '0.0.1'\n  spec.license       = { :file => '../LICENSE' }\n  spec.homepage      = 'https://github.com/YourGitHubAccount/repo_name'\n  spec.authors       = { 'Your Name' => 'your-email@example.com' }\n  spec.summary       = 'iOS/macOS Flutter bindings for library_name'\n\n  spec.source              = { :path => '.' }\n  spec.source_files        = 'Classes/**/*'\n  spec.public_header_files = 'Classes/**/*.h'\n  spec.vendored_frameworks = \"Frameworks/#{framework_name}\"\n\n  spec.ios.deployment_target = '11.0'\n  spec.osx.deployment_target = '10.11'\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust function returning a reference\nDESCRIPTION: Demonstrates a Rust function `f` that takes a reference to a `Foo` struct and returns a reference to a `Bar` struct with the same lifetime. This pattern is currently unsupported by flutter_rust_bridge for direct return types. It expects inputs `foo` as a borrowed reference and outputs a borrowed reference `Bar` tied to the input's lifetime.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/return-references.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn f<'a>(foo: &'a Foo) -> &'a Bar { .. }\n```\n\n----------------------------------------\n\nTITLE: Dart Class Generated from Rust Trait\nDESCRIPTION: This Dart code shows the generated class `MyStruct` that implements the interface `MyTrait`. The `f` method is generated from the Rust trait implementation, taking a String as input and returning an int. This demonstrates how traits act as interfaces in Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/implementations.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass MyStruct implements MyTrait {\n    ...\n    int f(String a) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Cargokit Configuration\nDESCRIPTION: Calls the `apply_cargokit` macro/function provided by the included Cargokit script. This step integrates the Rust build process (handled by Cargokit) into the CMake build. It takes the project name, Rust crate directory, crate name, and other parameters.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\napply_cargokit(${PROJECT_NAME} ../../REPLACE_ME_RUST_CRATE_DIR REPLACE_ME_RUST_CRATE_NAME \"\")\n```\n\n----------------------------------------\n\nTITLE: Creating New Releases with Melos via GitHub Actions (YAML)\nDESCRIPTION: Defines a manually triggered GitHub Actions workflow (`create-release.yml`) to version packages using `melos version`. It allows selecting versioning strategies (standard, prerelease, graduate) via inputs. Requires a `BOT_ACCESS_TOKEN` secret for pushing generated tags and commit back to the repository.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nname: Create Release(s)\n\non:\n  workflow_dispatch:\n    inputs:\n      version_parameters:\n        description: 'Parameters to pass to \"melos version\"'\n        required: true\n        default: \" \"\n        type: choice\n        options:\n          - \"--\"\n          - \"--prerelease\"\n          - \"--graduate\"\n\njobs:\n  create_release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          token: ${{ secrets.BOT_ACCESS_TOKEN }}\n          fetch-depth: 0\n      - name: Setup git\n        run: |\n          git config user.name \"YourName\"\n          git config user.email \"your-email@example.com\"\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n\n      - name: Create the new version(s)\n        run: melos version --yes ${{ inputs.version_parameters }}\n\n      - name: Push created version commit\n        run: git push\n      - name: Push modified tags\n        run: git push --tags\n```\n\n----------------------------------------\n\nTITLE: Specifying Default Parameters in Flutter Rust Bridge Using Rust\nDESCRIPTION: This Rust snippet demonstrates setting default values for function parameters exposed to Dart via Flutter Rust Bridge using the #[frb(default)] attribute. It shows how to assign default enum values and default struct instances initialized in Dart constant context, enabling Dart-side default parameter handling. The example defines an enum 'Answer' and a struct 'Point' with default values for a function parameter 'answer' and 'point'. Required dependencies include Flutter Rust Bridge and Rust's attribute macros. Parameters 'answer' and 'point' default to 'Answer.Yes' and a constant 'Point' respectively, facilitating seamless cross-language defaults.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/default-params.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub enum Answer { Yes, No }\npub struct Point(pub f64, pub f64);\n\n#[frb]\npub fn defaults(\n    #[frb(default = \"Answer.Yes\")]\n    answer: Answer,\n    #[frb(default = \"const Point(field0: 2, field1: 3)\")]\n    point: Point,\n);\n```\n\n----------------------------------------\n\nTITLE: Integrating flutter_rust_bridge into Existing Project in Workspace (Shell)\nDESCRIPTION: This sequence of commands navigates into an existing Flutter project directory (`my_flutter_project`) and then runs `flutter_rust_bridge_codegen integrate`. The `--rust-crate-dir` option is used to specify the relative location and name of the associated Rust crate within the Cargo workspace, enabling the codegen process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/cargo-workspaces.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd my_flutter_project\nflutter_rust_bridge_codegen integrate --rust-crate-dir ../my_flutter_bridge\ncd ..\n```\n\n----------------------------------------\n\nTITLE: Third-Party Crate Structure Example in Rust\nDESCRIPTION: Example of a structure in a third-party crate that has a method which might need to be overridden.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/override-methods.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct S { ... }\nimpl S {\n    pub fn greet(&self, name: &str) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding flutter_rust_bridge and Building/Serving on Web - Bash\nDESCRIPTION: This bash snippet details how to add the flutter_rust_bridge package to a Flutter/Dart project using flutter pub, then run a local dev server with flutter_rust_bridge:serve or globally install and invoke flutter_rust_bridge_serve. It requires the Dart and Flutter SDKs along with the flutter_rust_bridge package. The commands manage dependencies and start a development server to expedite WASM asset building and proper HTTP header configuration. Inputs are shell commands executed in a Flutter project context, producing a ready-to-serve WASM-enabled web app.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/setup_web.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# in your Flutter/Dart package\nflutter pub add flutter_rust_bridge\n# then run this instead of \"flutter web -d chrome\"\ndart run flutter_rust_bridge:serve\n# or install globally\ndart pub global activate flutter_rust_bridge\nflutter_rust_bridge_serve\n```\n\n----------------------------------------\n\nTITLE: Installing flutter_rust_bridge with Cargo-Binstall\nDESCRIPTION: Command to install flutter_rust_bridge_codegen using the faster cargo-binstall tool which downloads pre-built binaries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo binstall flutter_rust_bridge_codegen\n```\n\n----------------------------------------\n\nTITLE: Installing Data Files with CMake\nDESCRIPTION: This snippet installs the Flutter ICU data file to the installation directory.  This provides internationalization support.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Build and serve Flutter web app for Safari debugging - shell\nDESCRIPTION: These commands build the Flutter web application for profiling and then serve the generated web content using a Dart-based web server utility, allowing debugging in browsers like Safari which do not support 'flutter run -d chrome' style commands. The commands require having the flutter_rust_bridge_utils package and justfile tooling installed, and must be executed within the appropriate project subdirectories to correctly build and serve the web artifacts.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/tip.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n(cd frb_example/flutter_via_create && just codegen build-web && flutter build web --profile)\n(cd frb_utils && dart run flutter_rust_bridge_utils serve-web --web-root ../frb_example/flutter_via_create/build/web)\n```\n\n----------------------------------------\n\nTITLE: Rendering flutter_rust_bridge_codegen CLI Command Documentation Snippets in Markdown/JSX\nDESCRIPTION: Renders React components corresponding to documentation of various flutter_rust_bridge_codegen CLI commands within a markdown context. Each component call (<CommandMain/>, <CommandGenerate/>, etc.) displays detailed help and parameter information for its respective command, allowing the documentation page to dynamically include modularized command info.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/codegen/full-list.md#_snippet_1\n\nLANGUAGE: Markdown/JSX\nCODE:\n```\n## `flutter_rust_bridge_codegen`\n\n<CommandMain/>\n\n## `flutter_rust_bridge_codegen generate`\n\n<CommandGenerate/>\n\n## `flutter_rust_bridge_codegen build-web`\n\n<CommandBuildWeb/>\n\n## `flutter_rust_bridge_codegen create`\n\n<CommandCreate/>\n\n## `flutter_rust_bridge_codegen integrate`\n\n<CommandIntegrate/>\n```\n\n----------------------------------------\n\nTITLE: Refactoring Platform Handling using Freezed `when` in Dart\nDESCRIPTION: Modifies `lib/main.dart` to replace a map-based platform string lookup with the `when` method provided by the `freezed` package for the `Platform` enum. This ensures exhaustive checking and provides a type-safe way to handle different platform variants, including passing architecture data for macOS.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_finish.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n- final text = const {\n-   Platform.Android: 'Android',\n-   Platform.Ios: 'iOS',\n-   Platform.MacApple: 'MacOS with Apple Silicon',\n-   Platform.MacIntel: 'MacOS',\n-   Platform.Windows: 'Windows',\n-   Platform.Unix: 'Unix',\n-   Platform.Wasm: 'the Web',\n- }[platform] ??\n- 'Unknown OS';\n+ final text = platform.when(\n+   android: () => 'Android',\n+   ios: () => 'iOS',\n+   macOs: (arch) => 'MacOS on $arch',\n+   windows: () => 'Windows',\n+   unix: () => 'Unix',\n+   wasm: () => 'the Web',\n+ );\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Bridge Code with flutter_rust_bridge_codegen (Shell)\nDESCRIPTION: This shell snippet runs flutter_rust_bridge_codegen with custom parameters, including the --rust-output flag to specify a non-default output file for the generated Rust FFI bindings. Developers must ensure that flutter_rust_bridge_codegen is installed and available in their environment. The key argument is --rust-output, which expects a path for the output Rust bridge file, such as $crate/src/my_bridge.rs; the expected output is a new or updated Rust FFI module.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/finish.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen \\\n    ..\n    --rust-output $crate/src/my_bridge.rs\n```\n\n----------------------------------------\n\nTITLE: Setting Up Flutter and GTK Dependencies in CMake\nDESCRIPTION: Adds the Flutter managed directory as a subdirectory to integrate Flutter libraries and build rules, finds the required GTK 3.0 package via pkg-config (marking it as an imported target), which is necessary for building the GTK-based Flutter desktop application. This ensures the build system correctly links GTK system libraries and Flutter-managed components.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")${\\n}add_subdirectory(${FLUTTER_MANAGED_DIR})${\\n}${\\n}find_package(PkgConfig REQUIRED)${\\n}pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n```\n\n----------------------------------------\n\nTITLE: Adding Integration Test Dependencies (YAML)\nDESCRIPTION: This YAML snippet is added to the `dev_dependencies` section of a Flutter package's `pubspec.yaml` file. It includes the standard `flutter_test` SDK and the `integration_test` SDK, which are necessary for writing and running integration tests, often used in CI pipelines.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  integration_test:\n    sdk: flutter\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter Library with CMake\nDESCRIPTION: This snippet installs the Flutter library to the installation directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Compilation Settings and Build Types - CMake\nDESCRIPTION: This snippet defines reusable build options and standard compilation settings for all project targets through the APPLY_STANDARD_SETTINGS function. It sets the C++ standard, enables warning and error flags, configures optimization or debug defines based on the build type, and ensures consistent compile-time behavior. Requires a valid build target and assumes a modern CMake toolchain is installed. Key parameters include the build type and targeted C++ standard; outputs affect target properties and compiler flags.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Setting Up StreamSink for Log Streaming in Rust\nDESCRIPTION: Initializes a static StreamSink for LogEntry, used to send log messages from Rust to Dart. Requires synchronization primitives like OnceCell, Mutex, or RwLock for thread safety. This pattern enables Rust logs to be streamed to Dart in real-time.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlazy_static! { static ref log_stream_sink: StreamSink<LogEntry>; }\n```\n\n----------------------------------------\n\nTITLE: Specifying LLVM Path in justfile for ffigen (justfile DSL)\nDESCRIPTION: This snippet provides a conditional assignment within a justfile to set the llvm_path variable according to the operating system. Specifically for MacOS, it assigns the LLVM installation path required by ffigen, addressing common issues where the tool cannot reliably detect LLVM on different architectures. The value is an argument string to be passed to build or binding-generation tools; requires just to be installed, and paths may need adjustment based on actual system configuration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_adding_code.md#_snippet_1\n\nLANGUAGE: justfile\nCODE:\n```\nllvm_path := if os() == \"macos\" {\n    \"--llvm-path /opt/homebrew/opt/llvm\"\n} else {\n    \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Definition in Rust\nDESCRIPTION: This Rust code defines a custom error type, `CustomError`, as an enum.  It has two variants: `Error0` which contains a String, and `Error1` which contains a u32.  This custom error type can be returned from Rust functions and automatically converted to a Dart exception.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub enum CustomError {\n    Error0(String),\n    Error1(u32),\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Service Workers Using Browser JavaScript Console - JavaScript\nDESCRIPTION: This JavaScript snippet is intended to be executed in a browser's developer console (F12) to unregister all registered service workers. It iterates through each registration returned by navigator.serviceWorker.getRegistrations(), invoking the unregister() method. This prepares a 'cold-start' environment by removing cached service worker behaviors prior to manual testing. Requires a modern browser supporting the Service Worker API; expected input is none, and there is no output except for the removal of service workers, which may affect cached offline behavior.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/manual-test.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nnavigator.serviceWorker.getRegistrations().then(function(registrations) { for(let registration of registrations) { registration.unregister(); }});\n```\n\n----------------------------------------\n\nTITLE: Setting Executable Name and Application ID with CMake\nDESCRIPTION: This snippet sets the name of the executable and the unique GTK application identifier.  The BINARY_NAME affects the on-disk name of the application and APPLICATION_ID is used for GTK.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(BINARY_NAME \"frb_example_gallery\")\nset(APPLICATION_ID \"com.example.frb_example_gallery\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Crate Types in Cargo.toml for Cross-Platform Build\nDESCRIPTION: This snippet specifies the crate types in Cargo.toml necessary for building Rust libraries for multiple platforms, including iOS and macOS. The configuration includes 'lib' for general library targets, 'staticlib' specifically required for iOS static linking, and 'cdylib' for dynamic linking on other platforms. Proper crate-type declaration ensures the Rust compiler produces compatible binaries for integration with external tools like Xcode. This configuration must be placed under the [lib] section of Cargo.toml within the Rust crate's root directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_proj.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\ncrate-type = [\"lib\", \"staticlib\", \"cdylib\"]\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Library Paths and Parent Scope Variables\nDESCRIPTION: Sets variables pointing to essential Flutter build outputs like the engine library (`flutter_windows.dll`), ICU data file, project build directory, and AOT library. These variables are also exported to the parent scope for use in other CMake files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Defining LogEntry Structure in Rust\nDESCRIPTION: Defines a LogEntry struct in Rust to encapsulate log details such as timestamp, level, tag, and message. Serves as the data model for log transmission from Rust to Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/logging.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct LogEntry {\n    pub time_millis: i64,\n    pub level: i32,\n    pub tag: String,\n    pub msg: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Existing Methods in Third-Party Crates in Rust\nDESCRIPTION: Demonstrates how to override an existing method in a third-party crate using the extension trait pattern and the frb_override_ prefix. This example changes the signature of the greet method.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/override-methods.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse extend::ext; // or, for example, easy_ext's\nuse the_external_crate::path::to::S;\n\n#[ext]\npub impl S {\n    pub fn frb_override_greet(&self, age: i32, first_name: String, last_name: Vec<u8>) {\n        // We can have arbitrary implementation.\n        // Here, we demonstrate how to call the original implementation with modified arguments.\n        self.greet(format!(\"{age}-{first_name}-{last_name:?}\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning a Cloned Struct as an Alternative to Proxy in Rust\nDESCRIPTION: Illustrates an alternative to `#[frb(proxy)]` by modifying the method (`get_my_sub_struct`) to return a clone of the inner struct (`MySubStruct`, analogous to `AudioParam` in the main example). This avoids reference lifetimes but requires the type to implement the `Clone` trait.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/proxy.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn get_my_sub_struct(&self) -> MySubStruct {\n    self.frequency.clone()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Plugin with FFI Template\nDESCRIPTION: Command to create a new Flutter plugin with FFI support for multiple platforms. This template serves as a starting point for the Flutter wrapper.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nflutter create --template=plugin_ffi --platforms=android,ios,macos,linux,windows --org=com.example flutter_library_name\n```\n\n----------------------------------------\n\nTITLE: Configuring crate-type in Cargo.toml for iOS and macOS\nDESCRIPTION: This code snippet shows the necessary `crate-type` configurations in `Cargo.toml` to build a Rust library that can be linked with iOS and macOS projects. `staticlib` is essential for iOS, while `cdylib` is required for other platforms. `lib` is necessary for non-library targets like tests.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/tour_native_proj.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\ncrate-type = [\"lib\", \"cdylib\", \"staticlib\"]\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Structs for Heterogeneous Data in Rust\nDESCRIPTION: This Rust snippet shows a less ideal design pattern using structs with optional fields (`Optional<T>`) to represent data that could hold values of different types. It is presented as a problematic approach that could lead to complexity compared to using `enum`s.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-dynamic.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct MyStruct {\n    a: Optional<u32>,\n    b: Optional<String>,\n}\n\nstruct DataStruct {\n    msg:  String,\n    data: MyStruct,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList Component in MDX - JavaScript/JSX\nDESCRIPTION: This snippet shows how to import the DocCardList React component from the Docusaurus theme and render it directly within an MDX documentation file. Dependencies include Docusaurus with MDX support and the '@theme/DocCardList' component. No parameters are required; the component is rendered as-is to display a list of documentation cards. Outputs a set of documentation cards as defined by DocCardList.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Defining list_prepend Function\nDESCRIPTION: Defines a CMake function `list_prepend` that prepends a given prefix to each element of a list. This function is used because `list(TRANSFORM ... PREPEND ...)` is not available in CMake 3.10.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Adding Rust iOS Cross-Compilation Targets using rustup\nDESCRIPTION: These commands utilize the `rustup` tool to install the required Rust cross-compilation targets for building applications for various iOS architectures. This includes targets for 64-bit real devices (`aarch64-apple-ios`), older 64-bit simulators (`x86_64-apple-ios`), newer ARM64 simulators (`aarch64-apple-ios-sim`), and optional 32-bit architectures. These targets are essential for cross-compiling Rust code to run on iOS.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/setup_ios.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# 64 bit targets (real device & simulator):\nrustup target add aarch64-apple-ios x86_64-apple-ios\n# New simulator target for Xcode 12 and later\nrustup target add aarch64-apple-ios-sim\n# 32 bit targets (you probably don't need these):\nrustup target add armv7-apple-ios i386-apple-ios\n```\n\n----------------------------------------\n\nTITLE: Build Rust code to a dynamic library\nDESCRIPTION: This command builds the Rust code into a dynamic library (`.so` on Linux, `.dylib` on MacOS, `.dll` on Windows). This library contains the compiled Rust functions that will be called from Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial_pure_dart.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Project in Cargo Workspace (Shell)\nDESCRIPTION: This command uses the `flutter_rust_bridge_codegen` tool to create a new Flutter project (`my_flutter_project`) alongside a new Rust crate (`../my_flutter_bridge`) specifically configured for a Cargo workspace environment. The `--rust-crate-dir` option specifies the relative path and name for the generated Rust project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/cargo-workspaces.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflutter_rust_bridge_codegen create my_flutter_project --rust-crate-dir ../my_flutter_bridge\n```\n\n----------------------------------------\n\nTITLE: Ignoring Structs and Functions with flutter_rust_bridge in Rust\nDESCRIPTION: This Rust snippet demonstrates how to mark structs and functions to be ignored by flutter_rust_bridge using the #[frb(ignore)] attribute. It requires the flutter_rust_bridge crate to process these annotations and skip the annotated elements during code generation. The snippet includes a struct and a function both annotated to be excluded. Inputs are standard Rust item declarations; outputs are that these items will not be exported to the Flutter side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/ignoring.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(ignore)]\npub struct ThisStructWillBeIgnore;\n\n#[frb(ignore)]\npub fn this_function_will_be_ignored() {}\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Rust reference return value in a new struct for flutter_rust_bridge compatibility\nDESCRIPTION: Shows an alternative approach where a new struct `BarReference` holding a reference to `Bar` is created. The function `f` is redefined to return this wrapper struct with the appropriate lifetime. This pattern enables flutter_rust_bridge to handle functions returning references by encapsulating the reference in a simple struct wrapper, preserving lifetime semantics.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/return-references.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct BarReference<'a>(&'a Bar);\n\nfn f<'a>(foo: &'a Foo) -> BarReference<'a> { .. }\n```\n\n----------------------------------------\n\nTITLE: Call After Dispose Error Handling in Dart\nDESCRIPTION: Shows how Dart handles errors when attempting to use an opaque type after calling dispose(). This pattern is important for understanding the safety mechanisms that prevent use-after-free errors.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 0) opaque type dropped (deallocated)\nopaque.dispose();\n\n// (Arc counter = 0) Dart throws StateError('Use after dispose.')\ntry {\n    await api.runOpaque(opaque: opaque);\n} on StateError catch (e) {\n    expect(e.toString(), 'Bad state: Use after dispose.');\n}\n```\n\n----------------------------------------\n\nTITLE: Usage Pattern for flutter_rust_bridge_codegen create Command\nDESCRIPTION: Shows the command syntax and available options for creating a new Flutter project with Rust integration. The command requires a project name as an argument and offers various optional parameters to customize the project structure and organization.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/generated/_frb-codegen-command-create.mdx#_snippet_0\n\nLANGUAGE: cli\nCODE:\n```\nflutter_rust_bridge_codegen create [OPTIONS] <NAME>\n```\n\n----------------------------------------\n\nTITLE: Running binding generation commands for Flutter Rust Bridge\nDESCRIPTION: Executes a shell script from the project root to generate C bindings from the Rust library, which are essential for Dart/Flutter interoperation. The commands produce headers to prevent symbol stripping, facilitating safe FFI calls. This process should be rerun after any modifications to the Rust code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_gen.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n{{#include command.sh.txt}}\n```\n\n----------------------------------------\n\nTITLE: Setting Up GitHub Actions CI Pipeline for Flutter Rust Bridge - YAML\nDESCRIPTION: This YAML snippet defines the main GitHub Actions workflow for continuous integration of a Dart/Flutter and Rust library. It includes scheduled, push, and pull_request triggers, jobs for building and testing across Ubuntu, macOS, and Windows, and configuration for Melos, Flutter, and Rust toolchains. Dependencies required are Melos, Flutter, Rust (with rustfmt, clippy), and relevant OS packages (e.g., libgtk-3-dev for Linux). Each job runs formatting checks, analyses, builds, and integration tests, with file path placeholders ('library_name', 'LibraryName') to be replaced for your project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/ci.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nname: Build & Test\n\non:\n  pull_request:\n  push:\n    branches:\n      - main\n  schedule:\n    # runs the CI everyday at 10AM\n    - cron: \"0 10 * * *\"\n\njobs:\n  # General build, check, and test steps\n  build_and_test:\n    runs-on: ubuntu-latest\n\n    steps:\n      # Setup\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n          components: rustfmt, clippy\n\n      # Rust\n      - name: Check Rust format\n        working-directory: ./packages/library_name/native/src\n        run: rustfmt --check lib.rs\n      - name: Rust code analysis\n        run: cargo clippy -- -D warnings\n      - name: Run Rust tests\n        run: cargo test\n      - name: Build Rust code for Dart tests\n        run: cargo build -r\n\n      # Dart/Flutter\n      - name: Check Dart format\n        run: melos run check-format --no-select\n      - name: Dart code analysis\n        run: melos run analyze --no-select\n      - name: Run Dart tests\n        run: melos run test\n\n  macos_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the XCFramework\n        run: melos run build:apple\n      - name: Copy the XCFramework to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/macos/Frameworks/$CURR_VERSION.zip\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d macos integration_test\n\n  windows_integration_test:\n    runs-on: windows-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the binaries\n        run: melos run build:other\n      - name: Copy the binaries to the needed location\n        shell: bash\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/other.tar.gz packages/flutter_library_name/windows/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d windows integration_test\n\n  linux_integration_test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install dependencies for flutter integration test\n        run: sudo apt update && sudo apt-get install -y libglu1-mesa ninja-build clang cmake pkg-config libgtk-3-dev liblzma-dev\n      - uses: pyvista/setup-headless-display-action@v1\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Build the binaries\n        run: melos run build:other\n      - name: Copy the binaries to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/other.tar.gz packages/flutter_library_name/linux/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d linux integration_test\n\n  ios_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n\n      - name: Start iOS Simulator\n        run: |\n          DEVICE_ID=$(xcrun xctrace list devices | grep iPhone | head -1 | awk '{print $NF}' | tr -d '()')\n          echo \"DEVICE_ID=$DEVICE_ID\" >> $GITHUB_ENV\n          xcrun simctl boot $DEVICE_ID\n\n      - name: Build the XCFramework\n        run: melos run build:apple\n      - name: Copy the XCFramework to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/ios/Frameworks/$CURR_VERSION.zip\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        working-directory: packages/flutter_library_name/example\n        run: flutter test -d ${{ env.DEVICE_ID }} integration_test\n\n  android_integration_test:\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n      - uses: nttld/setup-ndk@v1\n        with:\n          ndk-version: r25b\n      - uses: actions/setup-java@v3\n        with:\n          distribution: zulu\n          java-version: \"11.x\"\n\n      - name: Build the binaries\n        run: melos run build:android\n      - name: Copy the binaries to the needed location\n        run: |\n          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n          cp platform-build/android.tar.gz packages/flutter_library_name/android/$CURR_VERSION.tar.gz\n          echo Copied file!\n\n      - name: Run Flutter integration tests\n        uses: Wandalen/wretry.action@master # sometimes android tests are flaky\n        with:\n          attempt_limit: 5\n          action: reactivecircus/android-emulator-runner@v2\n          with: |\n            api-level: 33\n            target: google_apis\n            arch: x86_64\n            ram-size: 1024M\n            disk-size: 2048M\n            script: cd packages/flutter_library_name/example && flutter test -d `flutter devices | grep android | tr ' ' '\\n' | grep emulator-` integration_test\n\n```\n\n----------------------------------------\n\nTITLE: Annotating Rust Functions for flutter_rust_bridge Integration (Rust)\nDESCRIPTION: This Rust snippet demonstrates using a doc comment annotation (/// flutter_rust_bridge:ignore) above a function to inform flutter_rust_bridge tools to ignore the function during code generation. No external dependencies beyond the flutter_rust_bridge toolchain are required. The function f takes no inputs or outputs and illustrates the application of special comments for FFI export customization.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/attributes/comments.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// flutter_rust_bridge:ignore\npub fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Interface Library\nDESCRIPTION: Defines an interface library named `flutter`. Interface libraries are used to group include directories and link libraries without generating any actual object code.  Dependencies on GTK, GLib and GIO are also added.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version for Flutter Plugin Build in CMake\nDESCRIPTION: Specifies the minimum required CMake version as 3.10 to ensure compatibility with Flutter tooling, and warns against increasing this version to avoid compilation issues for plugin users. This directive is critical for maintaining build stability across environments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Modifying ffi.dart for Cross-Platform Dynamic Library Loading in Dart\nDESCRIPTION: This code snippet demonstrates how to configure the ffi.dart file in a Flutter project to correctly reference the platform-specific compiled Rust dynamic library. It exports the bridge, dynamically sets the base name, and constructs the appropriate library filename for Windows and other platforms. Dependencies include the 'dart:io' library for platform detection. The key parameters are the '_base' name and the '_dylib' filename, which adapt based on the operating system.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/usage.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// Re-export the bridge so it is only necessary to import this file.\nexport 'bridge_generated.dart';\nimport 'dart:io' as io;\n\n-const _base = 'native';\n+const _base = '$crate';\n\n// On MacOS, the dynamic library is not bundled with the binary,\n// but rather directly **linked** against the binary.\nfinal _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';\n```\n\n----------------------------------------\n\nTITLE: Including Generated Plugins CMake\nDESCRIPTION: Includes the generated_plugins.cmake file, which manages the building of plugins and adding them to the application. This integrates the plugin build process into the overall CMake build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Rust Module Declaration\nDESCRIPTION: Declares two modules, `api_1` and `api_2`, in `lib.rs`.  These lines inform the Rust compiler about the existence of these modules, allowing the code within them to be used in the main library. They are essential for organizing the project structure when splitting APIs into multiple files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod api_1;\nmod api_2;\n```\n\n----------------------------------------\n\nTITLE: Using RustAutoOpaque Field as an Alternative to Proxy in Rust\nDESCRIPTION: Demonstrates using `RustAutoOpaque<AudioParam>` for the `frequency` field as an alternative to `#[frb(proxy)]`. This approach leverages reference counting (`Arc`) for shared ownership, enabling access across the FFI boundary without direct reference returns.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/proxy.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfrequency: RustAutoOpaque<AudioParam>,\n```\n\n----------------------------------------\n\nTITLE: Investigate Flutter Rust Bridge Code Generation Deadlock with Debug Logs\nDESCRIPTION: Advises setting 'RUST_LOG=debug' environment variable to obtain detailed logs when 'flutter_rust_bridge_codegen' hangs, enabling identification of stuck steps such as executing 'flutter pub get'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\nRUST_LOG=debug flutter_rust_bridge_codegen your_args\n```\n\n----------------------------------------\n\nTITLE: Annotating an Unused Rust Struct with Static Dart Function - Rust\nDESCRIPTION: This Rust code snippet shows how to use the #[frb(dart_code = ...)] attribute to add a static Dart function (dartSay) to a struct called DartCodeStruct. The snippet emphasizes that such structs must be actively used in public Rust functions or methods to ensure that flutter_rust_bridge generates the associated Dart class and includes the Dart code. Inputs are the struct declaration and relevant attribute string; outputs result only if the struct is referenced. Constraints include ensuring callability from Dart for the code to take effect.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/dart-code.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(dart_code = \"static void dartSay() => print('Dart_code at struct');\")]\npub struct DartCodeStruct {}\n\nimpl DartCodeStruct {\n    pub fn noop() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Libraries to Bundle with the Flutter Plugin\nDESCRIPTION: This snippet defines a list of absolute paths to libraries that should be bundled with the Flutter plugin, including prebuilt or externally built libraries. It uses a variable derived from an external script to specify the libraries to include.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(rust_lib_frb_example_integrate_third_party_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n```\n\n----------------------------------------\n\nTITLE: Adding Preprocessor Definitions for Versioning\nDESCRIPTION: This snippet adds preprocessor definitions that embed the build version information into the application. These definitions are used to define the version number, major, minor, patch and build numbers. These definitions are used to get the version number in the code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"\\${FLUTTER_VERSION}\\\"\"\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=\\${FLUTTER_VERSION_MAJOR}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=\\${FLUTTER_VERSION_MINOR}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=\\${FLUTTER_VERSION_PATCH}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=\\${FLUTTER_VERSION_BUILD}\")\n```\n\n----------------------------------------\n\nTITLE: Upgrading flutter_rust_bridge_codegen using cargo\nDESCRIPTION: This shell script upgrades the `flutter_rust_bridge_codegen` tool using the `cargo install` command. The upgrade is followed by the `generate` command to ensure the project's dependencies and code are updated correctly. Requires cargo to be installed and configured. The output is the updated dependencies and generated code files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/miscellaneous/upgrade/regular.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen generate\n```\n\n----------------------------------------\n\nTITLE: Applying Cargokit for Rust Integration in CMake\nDESCRIPTION: This includes the cargokit cmake file and then applies it to the project. The `apply_cargokit` function integrates the Rust library with the Flutter project.  It takes the project name, the path to the rust directory, and the name of the Rust library as arguments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../rust rust_lib_frb_example_integrate_third_party \"\")\n```\n\n----------------------------------------\n\nTITLE: Initializing RustLib with a custom external library in Dart\nDESCRIPTION: This code snippet shows how to initialize the RustLib in Dart by providing a custom function for loading the Rust library. It replaces the default loading logic, allowing developers to specify their own method for loading the library, which is useful when not using the default Flutter-Rust integration template.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/load-library.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nawait RustLib.init(externalLibrary: loadMyRustLibraryUsingWhateverMethod());\n```\n\n----------------------------------------\n\nTITLE: Cocoapods Podspec Configuration\nDESCRIPTION: This Ruby code defines a Podspec for integrating the Rust library with Cocoapods.  It fetches the compiled XCFramework from a remote GitHub release, extracts it, and configures the pod to use the framework.  Replace 'library_name', 'LibraryName', 'YourGitHubAccount', and 'repo_name' with the correct values for your project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/02-ios-and-macos.md#_snippet_2\n\nLANGUAGE: Ruby\nCODE:\n```\nrelease_tag_name = 'library_name-v0.0.0' # generated; do not edit\n\n# We cannot distribute the XCFramework alongside the library directly,\n# so we have to fetch the correct version here.\nframework_name = 'LibraryName.xcframework'\nremote_zip_name = \"#{framework_name}.zip\"\nurl = \"https://github.com/YourGitHubAccount/repo_name/releases/download/#{release_tag_name}/#{remote_zip_name}\"\nlocal_zip_name = \"#{release_tag_name}.zip\"\n`\ncd Frameworks\nrm -rf #{framework_name}\n\nif [ ! -f #{local_zip_name} ]\nthen\n  curl -L #{url} -o #{local_zip_name}\nfi\n\nunzip #{local_zip_name}\ncd -\n`\n\nPod::Spec.new do |spec|\n  spec.name          = 'library_name'\n  spec.version       = '0.0.1'\n  spec.license       = { :file => '../LICENSE' }\n  spec.homepage      = 'https://github.com/YourGitHubAccount/repo_name'\n  spec.authors       = { 'Your Name' => 'your-email@example.com' }\n  spec.summary       = 'iOS/macOS Flutter bindings for library_name'\n\n  spec.source              = { :path => '.' }\n  spec.source_files        = 'Classes/**/*'\n  spec.public_header_files = 'Classes/**/*.h'\n  spec.vendored_frameworks = \"Frameworks/#{framework_name}\"\n\n  spec.ios.deployment_target = '11.0'\n  spec.osx.deployment_target = '10.11'\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Error with Backtrace in Rust\nDESCRIPTION: This Rust code defines a custom error type, `CustomStructError`, which includes a `Backtrace` field. This enables capturing stack traces when an error occurs. `thiserror` crate can be useful for automatically filling the backtrace field.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub enum CustomStructError {\n    Error0 { e: String, backtrace: Backtrace },\n    Error1 { e: u32, backtrace: Backtrace },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Server for WASM in Flutter\nDESCRIPTION: Example Dart code for setting up a web server that adds the required Cross-Origin headers needed for WASM modules to function correctly. These headers are essential for the security model when using SharedArrayBuffer in WebAssembly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/build_wasm.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:shelf/shelf.dart';\nimport 'package:shelf/shelf_io.dart';\nimport 'package:shelf_static/shelf_static.dart';\n\nvoid main() async {\n    final root = \"/* directory containing index.html */\";\n    final staticFilesHandler = createStaticHandler(root, defaultDocument: 'index.html');\n    final handler = const Pipeline().addMiddleware((handler) {\n        return (req) async {\n            final res = await handler(req);\n            return res.change(headers: const {\n                'Cross-Origin-Opener-Policy': 'same-origin',\n                'Cross-Origin-Embedder-Policy': 'require-corp',\n            });\n        };\n    }).addHandler(staticFilesHandler);\n    await serve(handler, 'localhost', 8080);\n}\n```\n\n----------------------------------------\n\nTITLE: Address Unexpected CFG Condition Warnings in Cargo.toml\nDESCRIPTION: Suggests adding a configuration to 'Cargo.toml' to control warnings about unexpected 'cfg' condition names like 'frb_expand', preventing build issues or warnings during compilation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_15\n\nLANGUAGE: Toml\nCODE:\n```\n[lints.rust]\nunexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(frb_expand)'] }\n```\n\n----------------------------------------\n\nTITLE: Installing Assets Directory\nDESCRIPTION: Installs the flutter_assets directory to the data directory within the build bundle. This includes all the Flutter assets needed for the application to run. They are installed as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Including API Module in Rust Library\nDESCRIPTION: This code shows how to include the newly created api module in the main library file (lib.rs) of the Rust project. By adding mod api;, functions defined in src/api.rs become accessible for export and use in bindings. This is a one-line module declaration modification and does not require dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/03-gen.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod api;\n```\n\n----------------------------------------\n\nTITLE: Installing Build-Time Dependencies for Dart Projects (Bash)\nDESCRIPTION: Installs necessary build-time dependencies for a Dart project using flutter_rust_bridge. This includes the codegen tool, ffigen for C header bindings, the core ffi package, and optionally cargo-xcode for Apple platform builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/deps.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install flutter_rust_bridge_codegen\ndart pub add --dev ffigen && dart pub add ffi\n# if building for iOS or MacOS\ncargo install cargo-xcode\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Melos Workspace (Bash)\nDESCRIPTION: This command is used in projects managed by Melos, a monorepo management tool. Running `melos bootstrap` analyzes the workspace, links local packages, fetches external dependencies using `pub get` (or equivalent), and performs other necessary setup steps. It ensures the monorepo is ready for development after changes like adding packages or dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmelos bs\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Compilation Settings Function\nDESCRIPTION: Defines a CMake function `APPLY_STANDARD_SETTINGS` that takes a target name as input. This function applies a set of common C++ compilation settings: enables C++17 features, sets warning levels (/W4, /WX), disables specific warning 4100, enables standard C++ exception handling semantics (/EHsc), disables compiler support for C++ exceptions (`_HAS_EXCEPTIONS=0`), and defines the `_DEBUG` macro for Debug builds using generator expressions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Compilation settings that should be applied to most targets.\n#\n# Be cautious about adding new options here, as plugins use this function by\n# default. In most cases, you should add new options to specific targets instead\n# of modifying this function.\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Build Environment for Flutter Windows\nDESCRIPTION: Sets the minimum required CMake version, defines the ephemeral directory path containing generated files, includes the main configuration file generated by the Flutter tool (`generated_config.cmake`), and sets a fallback target platform if not defined.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n\n# Set fallback configurations for older versions of the flutter tool.\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building WASM Binary with Rust Nightly Toolchain\nDESCRIPTION: Commands for building a WASM binary using wasm-pack with specific flags for atomics, bulk-memory, and mutable-globals features. This setup is required for flutter_rust_bridge to work properly with WebAssembly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/build_wasm.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport RUSTUP_TOOLCHAIN=nightly\nexport RUSTFLAGS=\"-C target-feature=+atomics,+bulk-memory,+mutable-globals\"\nwasm-pack build \\\n    -t no-modules \\\n    -d <WASM_OUTPUT_PATH> \\\n    --no-typescript -- \\\n    -Z build-std=std,panic_abort\n```\n\n----------------------------------------\n\nTITLE: Installing Native Assets\nDESCRIPTION: Installs the native assets from the specified directory to the library directory within the build bundle. This includes assets provided by the build.dart script from all packages and are installed as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Type Aliases in Rust\nDESCRIPTION: This Rust code snippet demonstrates how to declare type aliases for primitive and custom enum/struct types and shows their usage in struct definitions and function signatures. Dependencies include the enum and struct types defined earlier in the code (MyEnum and MyStruct). The example highlights type aliasing as a way to simplify type references, improve code readability, and enforce type consistency. Inputs include an Id (aliased to u64) passed to function `f`, which returns a TestModel struct composed of aliased types. Limitations include current lack of support for nested item types inside generics such as `SyncReturn<Id>`. The snippet serves to illustrate type alias usage in Rust for better type management within the Flutter Rust Bridge framework.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/alias.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum MyEnum {...}\nstruct MyStruct {...}\n\n// type aliases\npub type Id = u64;\npub type EnumAlias = MyEnum;\npub type StructAlias = MyStruct;\n\n// can also use them in fields, etc\npub struct TestModel { pub id: Id, pub e: EnumAlias, pub s: StructAlias}\n\npub fn f(input: Id) -> TestModel {...}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Type Aliases for Bridging\nDESCRIPTION: This Rust snippet demonstrates defining type aliases for basic types, enums, and structs, intended for use with flutter_rust_bridge. It shows how these aliases (`Id`, `EnumAlias`, `StructAlias`) can be used as field types in a struct (`TestModel`) and in a function signature (`f`). The function `f` takes an `Id` (aliasing `u64`) and returns a `TestModel`, illustrating their typical usage.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_type_alias.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nenum MyEnum {...}\nstruct MyStruct {...}\n\n// type aliases\npub type Id = u64;\npub type EnumAlias = MyEnum;\npub type StructAlias = MyStruct;\n\n// can also use them in fields, etc\npub struct TestModel { pub id: Id, pub e: EnumAlias, pub s: StructAlias}\n\npub fn f(input: Id) -> TestModel {...}\n```\n\n----------------------------------------\n\nTITLE: Git Ignore Configuration\nDESCRIPTION: This snippet defines a `.gitignore` file, excluding common files and directories from version control. This includes temporary files, build artifacts, IDE-specific settings, and Flutter/Dart/Rust related files like `pubspec.lock`, `target/`, and `.dart_tool/`.  It improves the cleanliness and efficiency of the Git repository.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_3\n\nLANGUAGE: gitignore\nCODE:\n```\n# Miscellaneous\n*.class\n*.log\n*.pyc\n*.swp\n.DS_Store\n.atom/\n.buildlog/\n.history\n.svn/\n\n# IntelliJ related\n*.iml\n*.ipr\n*.iws\n.idea/\n\n# The .vscode folder contains launch configuration and tasks you configure in\n# VS Code which you may wish to be included in version control, so this line\n# is commented out by default.\n#.vscode/\n\n# Flutter/Dart/Pub related\npubspec.lock\npubspec_overrides.yaml\n**/doc/api/\n.dart_tool/\n.packages\nbuild/\n.pub-cache/\n.pub/\n.flutter-plugins\n.flutter-plugins-dependencies\n\n# Rust related\n/target/\n/Cargo.lock\n/platform-build\n```\n\n----------------------------------------\n\nTITLE: Using reqwest::blocking for Synchronous Requests\nDESCRIPTION: This snippet shows how to avoid async code altogether by using the synchronous blocking version of functions in `reqwest::blocking`.  It downloads a file synchronously. This eliminates the complexities of async/await and runtime management, provided the blocking versions are sufficient for the use case.  Requires the `reqwest` crate with the `blocking` feature enabled and the `anyhow` crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse anyhow;\nuse reqwest;\n\nfn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::blocking::get(url)?.text()?;\n    Ok(data)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Plugin Wrapper Sources\nDESCRIPTION: This snippet lists the C++ source files required for the plugin wrapper, which handles plugin-specific logic. These files bridge Flutter plugin APIs to native code. The `CPP_WRAPPER_SOURCES_PLUGIN` list stores the file names.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Running Flutter Project in Workspace (Shell)\nDESCRIPTION: These commands navigate into the Flutter project directory (`my_flutter_project`) and then execute `flutter run`. This starts the Flutter application, which is now configured to build and utilize the associated Rust code managed within the Cargo workspace via flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/cargo-workspaces.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncd my_flutter_project/\nflutter run\n```\n\n----------------------------------------\n\nTITLE: Installing ICU Data File\nDESCRIPTION: Installs the ICU data file to the data directory within the build bundle. This file is essential for internationalization support.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Setting Bundled Libraries (CMake)\nDESCRIPTION: Defines a CMake variable `rust_lib_flutter_via_create_bundled_libraries` and sets its value to the path of the Rust library built by Cargokit (`${${PROJECT_NAME}_cargokit_lib}`). The `PARENT_SCOPE` keyword ensures that this variable is visible to the parent scope that included this CMake file, making the built Rust library available for bundling with the Flutter plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(rust_lib_flutter_via_create_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Rust function accepting DartOpaque parameter\nDESCRIPTION: Defines a Rust function `get_dart_opaque` that accepts a `DartOpaque` object as an argument, allowing the Rust side to receive a Dart object without copying. Also includes a function `return_dart_opaque` to return a `DartOpaque` object back to Dart. It demonstrates the Rust side handling of opaque Dart objects for interoperability.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_dart_opaque.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn get_dart_opaque(a: DartOpaque) { ... }\npub fn return_dart_opaque() -> DartOpaque { ... }\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration for Multiple Rust Input Folders\nDESCRIPTION: This YAML snippet demonstrates how to configure the `rust_input` key in the Flutter Rust Bridge configuration file to include multiple Rust modules/directories. The `rust_input` key specifies comma-separated paths to Rust modules, which are then scanned for relevant code to generate the bridge. The configuration instructs the tool to scan modules in `src/api/**/*.rs` and `src/hello/world/**/*.rs`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/multi-input.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrust_input: crate::api,crate::hello::world\n```\n\n----------------------------------------\n\nTITLE: Dart Example: Calling Rust Unwrap Functions and Handling FFI Exceptions\nDESCRIPTION: Dart code demonstrating calling the Rust unwrap function which safely unwraps a Dart closure, and calling the panic-causing unwrap on the wrong thread, expecting an FFI exception. Showcases error handling crossing FFI boundaries and enforcing thread restrictions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\n// Rust gets (drop safely) wrap Dart_PersistentHandler (or JsValue).\napi.unwrapDartOpaque(opaque: () => 'Test_String');\n\n// We get an error because DartOpaque was passed to another thread.\nawait expectLater(() => api.panicUnwrapDartOpaque(opaque: () => 'Test_String'), throwsA(isA<FfiException>()));\n```\n\n----------------------------------------\n\nTITLE: Creating a New Flutter Rust Bridge Project\nDESCRIPTION: Command to create a new Flutter project with Rust integration named 'my_app'. Additional options are available via the '--help' flag.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen create my_app\n```\n\n----------------------------------------\n\nTITLE: Build Script for Creating XCFrameworks using Rust and Xcode\nDESCRIPTION: A Bash script automates the process of building Rust targets for various Apple architectures, creating fat binaries via 'lipo', assembling an XCFramework with 'xcodebuild', and packaging it into a zip file. It ensures multiple architectures are correctly combined for Flutter integration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/ios_and_macos.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Build static libs for each target architecture\nfor TARGET in \\\n        aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim \\\n        x86_64-apple-darwin aarch64-apple-darwin\n do\n    rustup target add $TARGET\n    cargo build -r --target=$TARGET\n done\n\n# Prepare directories for fat binaries\nFRAMEWORK=\"LibraryName.xcframework\"\nLIBNAME=liblibrary_name.a\nmkdir mac-lipo ios-sim-lipo\nIOS_SIM_LIPO=ios-sim-lipo/$LIBNAME\nMAC_LIPO=mac-lipo/$LIBNAME\n\n# Create fat libraries\nlipo -create -output $IOS_SIM_LIPO \\\n        ../target/aarch64-apple-ios-sim/release/$LIBNAME \\\n        ../target/x86_64-apple-ios/release/$LIBNAME\nlipo -create -output $MAC_LIPO \\\n        ../target/aarch64-apple-darwin/release/$LIBNAME \\\n        ../target/x86_64-apple-darwin/release/$LIBNAME\n\n# Generate XCFramework using xcodebuild\nxcodebuild -create-xcframework \\\n        -library $IOS_SIM_LIPO \\\n        -library $MAC_LIPO \\\n        -library ../target/aarch64-apple-ios/release/$LIBNAME \\\n        -output $FRAMEWORK\n\n# Package the XCFramework into a zip archive\nzip -r $FRAMEWORK.zip $FRAMEWORK\n\n# Cleanup temporary files\nrm -rf ios-sim-lipo mac-lipo $FRAMEWORK\n```\n\n----------------------------------------\n\nTITLE: Listing App Wrapper Sources\nDESCRIPTION: This snippet lists the C++ source files for the app wrapper, which provides a bridge between the Flutter engine and the application code. These source files provide functionality for the Flutter application. The file paths are stored in `CPP_WRAPPER_SOURCES_APP`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Package Dependencies (GTK)\nDESCRIPTION: Uses PkgConfig to find the GTK library as a required dependency.  It imports the GTK target for linking later.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n```\n\n----------------------------------------\n\nTITLE: Workaround for code signature errors and missing headers in Linux\nDESCRIPTION: Suggests setting the `CPATH` environment variable to include the clang include directory, fixing issues like `'stdarg.h' file not found` or signature mismatches in generated code. This is especially relevant on Linux systems when facing header or signature problems with the generated `store_dart_post_cobject()` function.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/ffigen-troubleshooting.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport CPATH=\"$(clang -v 2>&1 | grep \"Selected GCC installation\" | rev | cut -d' ' -f1 | rev)/include\"\n```\n\n----------------------------------------\n\nTITLE: Setting Default Build Type\nDESCRIPTION: Sets the default build type to \"Debug\" if CMAKE_BUILD_TYPE is not already set and defines the available build types (Debug, Profile, Release). This provides a default configuration for the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n    STRING \"Flutter build mode\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n    \"Debug\" \"Profile\" \"Release\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building Rust Libraries for Windows and Linux Platforms\nDESCRIPTION: A shell script that builds Rust libraries for multiple platforms (Linux x64/ARM64 and Windows x64/ARM64) using cargo-zigbuild for Linux and cargo-xwin for Windows, then packages them for distribution.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/windows_and_linux.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Install build dependencies\ncargo install cargo-zigbuild\ncargo install cargo-xwin\n\nzig_build () {\n    local TARGET=\"$1\"\n    local PLATFORM_NAME=\"$2\"\n    local LIBNAME=\"$3\"\n    rustup target add \"$TARGET\"\n    cargo zigbuild --target \"$TARGET\" -r\n    mkdir \"$PLATFORM_NAME\"\n    cp \"../target/$TARGET/release/$LIBNAME\" \"$PLATFORM_NAME/\"\n}\n\nwin_build () {\n    local TARGET=\"$1\"\n    local PLATFORM_NAME=\"$2\"\n    local LIBNAME=\"$3\"\n    rustup target add \"$TARGET\"\n    cargo xwin build --target \"$TARGET\" -r\n    mkdir \"$PLATFORM_NAME\"\n    cp \"../target/$TARGET/release/$LIBNAME\" \"$PLATFORM_NAME/\"\n}\n\n# Build all the dynamic libraries\nLINUX_LIBNAME=liblibrary_name.so\nzig_build aarch64-unknown-linux-gnu linux-arm64 $LINUX_LIBNAME\nzig_build x86_64-unknown-linux-gnu linux-x64 $LINUX_LIBNAME\nWINDOWS_LIBNAME=library_name.dll\nwin_build aarch64-pc-windows-msvc windows-arm64 $WINDOWS_LIBNAME\nwin_build x86_64-pc-windows-msvc windows-x64 $WINDOWS_LIBNAME\n\n# Archive the dynamic libs\ntar -czvf other.tar.gz linux-* windows-*\n\n# Cleanup\nrm -rf linux-* windows-*\n```\n\n----------------------------------------\n\nTITLE: Installing and Creating Flutter-Rust Bridge Project with Shell\nDESCRIPTION: This shell snippet shows how to install the Flutter Rust Bridge code generator via Cargo, create a new Flutter-Rust bridge project named 'my_app', move into its directory, and run the Flutter app. It demonstrates the rapid setup capability of the package requiring only a single one-liner command to bootstrap a working app integrating Flutter and Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen create my_app && cd my_app && flutter run\n```\n\n----------------------------------------\n\nTITLE: Including Subdirectories and Plugins in CMake\nDESCRIPTION: Includes necessary subdirectories for the Flutter project. It sets the path for the Flutter managed directory, adds the Flutter library and tool build rules, includes the application runner code (usually in 'runner' subdirectory), and incorporates the build rules for generated plugins.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n\n\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Prepending Plugin Wrapper Sources Directory\nDESCRIPTION: This snippet prepends the `WRAPPER_ROOT` directory to the plugin wrapper source file names to generate full file paths. The `TRANSFORM` command does this.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Rebuild Rust for store_dart_post_cobject Symbol Resolution\nDESCRIPTION: Rebuilds the Rust project to ensure the symbol 'store_dart_post_cobject' is correctly included in the shared library, resolving runtime linkage errors encountered when calling Rust functions from Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Consuming Rust Tuple Coordinates in Dart Using Records\nDESCRIPTION: Defines a Dart function `myCoordinate` that corresponds to the Rust function returning a tuple of two doubles representing latitude and longitude. It demonstrates calling the Rust function through Flutter Rust Bridge and destructuring the returned Dart record into `lat` and `long` variables for further use. This enables seamless use of Rust tuples within Dart 3 using records.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/tuple.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n(double, double) myCoordinate();\nfinal (lat, long) = myCoordinate();\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Flutter Assemble\nDESCRIPTION: This snippet adds a custom target named `flutter_assemble`, which depends on the build outputs. This target bundles the build process together.  This command ensures that the custom command defined above (the flutter build) runs before the targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_32\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings with CMake\nDESCRIPTION: This function applies a standard set of build settings to a target, including C++ standard, compiler options (warnings, errors, optimization), and preprocessor definitions. It takes TARGET name as input.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Adding Application ID Definition\nDESCRIPTION: Adds a preprocessor definition for the application ID, making it available in the C++ code. This allows the application to access its unique identifier.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Linux Flutter-Rust Integration\nDESCRIPTION: CMakeLists.txt file for Linux that downloads and extracts prebuilt Rust libraries, setting up the necessary configurations for integrating Rust libraries with Flutter on Linux platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/windows_and_linux.md#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\n\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\n# Project-level configuration.\nset(PROJECT_NAME \"flutter_library_name\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}\")\nset(ArchivePath \"${LibRoot}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(flutter_library_name_bundled_libraries\n  \"${LibRoot}/${FLUTTER_TARGET_PLATFORM}/liblibrary_name.so\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Dart Example: Awaiting Asynchronous and Synchronous Drop Calls\nDESCRIPTION: Dart calls to Rust APIs asynchronously and synchronously dropping closures passed as `DartOpaque`. Demonstrates safe callback cleanup by Rust and usage on main and background threads with proper memory safety.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\n// the closure is safely removed on the Rust side (on another thread)\nawait api.asyncAcceptDartOpaque(opaque: () => 'Test_String');\n// the closure is safely removed on the Rust side (on current thread)\napi.syncAcceptDartOpaque(opaque: () => 'Test_String');\n```\n\n----------------------------------------\n\nTITLE: Panic Example in Rust\nDESCRIPTION: These Rust functions demonstrate how a panic in Rust translates to a Dart exception. Each function uses the panic! macro to cause a panic, regardless of the return type.  When called from Dart, each of these will throw a `PanicException`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub fn g1() -> i32 { panic!(\"oops I failed\") }\npub fn g2() -> anyhow::Result<String> { panic!(\"oops I failed\") }\npub fn g3() -> Result<Vec<u8>, CustomError> { panic!(\"oops I failed\") }\n```\n\n----------------------------------------\n\nTITLE: Manual Initialization with Dart and Rust\nDESCRIPTION: An alternative approach to initialization where you explicitly call Rust initialization functions from Dart code. This method gives you more control over when and how initialization occurs.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/init.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> main() async {\n  await RustLib.init();\n  await myRustInitLogic(); // or `sync` if you like\n  // ...\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn my_rust_init_logic() {\n    // initialize whatever things here\n}\n```\n\n----------------------------------------\n\nTITLE: Installing flutter_rust_bridge Code Generator Using Shell\nDESCRIPTION: Installs the flutter_rust_bridge_codegen tool and creates a new Flutter + Rust project named 'my_app'. It then navigates into the project folder and runs the Flutter app. Requires Rust's cargo tool and Flutter SDK installed on the system.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen create my_app && cd my_app && flutter run\n```\n\n----------------------------------------\n\nTITLE: Calling dummy_method_to_enforce_bundling in iOS AppDelegate.swift using Diff\nDESCRIPTION: This diff snippet demonstrates how to modify the AppDelegate.swift file in an iOS Flutter project by calling the generated dummy method `dummy_method_to_enforce_bundling()` inside the application launch lifecycle function. Using the returned value prevents the linker and Xcode from stripping the exported Rust symbols during build time. The example also prints the dummy value to avoid dead code elimination.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/04-headers.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n override func application(\n     _ application: UIApplication,\n     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n ) -> Bool {\n+    let dummy = dummy_method_to_enforce_bundling()\n+    print(dummy)\n     ..\n }\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Flutter Assemble Target in CMake\nDESCRIPTION: Defines a custom command and target named `flutter_assemble`. The command executes the Flutter tool backend script (`tool_backend.bat`) with appropriate environment variables and arguments (platform, configuration) to generate necessary build artifacts like the Flutter library, headers, and C++ wrapper sources. It uses a symbolic phony output file (`_phony_`) to ensure the command runs on every build. The `flutter_assemble` target depends on the successful generation of these artifacts.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Rust API Definition (String Parameter)\nDESCRIPTION: Defines a Rust function that takes a String parameter. This is relevant for demonstrating implicit API conflicts due to automatically generated FFI code for common types like String.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub fn test_string_1(s1: String) {\n    println!(\"test implicit parameter conflicts {}\", s1);\n}\n```\n\n----------------------------------------\n\nTITLE: Configure CMake Minimum Version and Directories\nDESCRIPTION: This snippet sets the minimum required CMake version and defines key directory variables like `EPHEMERAL_DIR`. `EPHEMERAL_DIR` is used to locate files generated by the Flutter tool during the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Initialize Android NDK Context via Explicit Plugin Call (Method 2)\nDESCRIPTION: This alternative method uses a Flutter Plugin to explicitly initialize the NDK context. The plugin loads the native library using `System.loadLibrary` and calls a dedicated Rust function (`init_android`) via JNI from the `onAttachedToEngine` lifecycle method, passing the application context. This provides more direct control over the timing and context used for initialization. It requires the `jni` crate in Rust and uses `ndk-context` internally for the actual initialization.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/ndk-init.md#_snippet_1\n\nLANGUAGE: Kotlin\nCODE:\n```\npackage com.example.frontend\n\nimport android.content.Context\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.embedding.engine.plugins.FlutterPlugin\nimport io.flutter.plugin.common.MethodCall\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler\nimport io.flutter.plugin.common.MethodChannel.Result\n\nclass MainActivity : FlutterActivity() {\n    override fun configureFlutterEngine(\n        @NonNull flutterEngine: FlutterEngine,\n    ) {\n        flutterEngine.plugins.add(MyPlugin())\n        super.configureFlutterEngine(flutterEngine)\n    }\n}\n\nclass MyPlugin : FlutterPlugin, MethodCallHandler {\n    companion object {\n        init {\n            System.loadLibrary(\"rust_lib_frontend\")\n        }\n    }\n\n    external fun init_android(ctx: Context)\n\n    override fun onAttachedToEngine(\n        @NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding,\n    ) {\n        init_android(flutterPluginBinding.applicationContext)\n    }\n\n    override fun onMethodCall(\n        @NonNull call: MethodCall,\n        @NonNull result: Result,\n    ) {\n        result.notImplemented()\n    }\n\n    override fun onDetachedFromEngine(\n        @NonNull binding: FlutterPlugin.FlutterPluginBinding,\n    ) {\n    }\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n[target.'cfg(target_os = \"android\")'.dependencies]\njni = \"0.21\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(target_os = \"android\")]\nmod init_android_context {\n    use jni::{objects::JClass, objects::JObject, objects::GlobalRef, JNIEnv};\n    use std::sync::OnceLock;\n    use std::ffi::c_void;\n\n    static CTX: OnceLock<GlobalRef> = OnceLock::new();\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_com_example_local_1auth_MyPlugin_init_1android(\n        env: JNIEnv,\n        _class: JClass,\n        ctx: JObject,\n    ) {\n        let global_ref = env.new_global_ref(&ctx).expect(\"to make global reference\");\n        let vm = env.get_java_vm().unwrap();\n        let vm = vm.get_java_vm_pointer() as *mut c_void;\n        unsafe {\n            ndk_context::initialize_android_context(vm, global_ref.as_obj().as_raw() as _);\n        }\n        CTX.get_or_init(|| global_ref);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Preprocessor Definitions (C++)\nDESCRIPTION: This code adds a preprocessor definition for the application ID using `add_definitions`. The `-DAPPLICATION_ID` flag is used to define `APPLICATION_ID` with the value provided by `APPLICATION_ID`. This enables the application to reference its own identifier during compilation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Rust API Definition (String Parameter 2)\nDESCRIPTION: Another Rust function that also takes a String parameter. It exhibits the issue of symbol conflicts when generating APIs across multiple blocks because the same FFI functions may be generated for both API definitions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn test_string_2(s2: String) {\n    println!(\"test implicit parameter conflicts {}\", s2);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Tuple-Returning Function in Rust\nDESCRIPTION: This Rust function definition declares 'my_coordinate', which returns a tuple composed of two f64 values, typically representing a pair such as geographic coordinates. To integrate with Dart via Flutter Rust Bridge, this function must be exported, and Rust's type system will map the tuple to Dart's record type when bridged. Inputs: none. Output: a tuple (f64, f64). Requires Rust 1.0+ and is supported for tuples of up to 10 elements unless further nested.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_tuple.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn my_coordinate() -> (f64, f64);\n```\n\n----------------------------------------\n\nTITLE: Configuring Installer and Runtime File Deployment in CMake for Flutter Rust Bridge\nDESCRIPTION: Sets the runtime installation target directory and configures Visual Studio to include an install step by default for easier run workflows. Defines install paths for runtime executable, ICU data, Flutter library, plugin bundled libraries, native assets from build scripts, and Flutter assets that are fully copied on each build to prevent stale data. Additionally, installs the Ahead-Of-Time (AOT) compiled library on Profile and Release modes only, ensuring correct runtime environments per build configuration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: CMake Flutter Library Inclusion\nDESCRIPTION: This section includes Flutter build rules. It defines the Flutter managed directory and adds the flutter subdirectory to the build. This sets up the Flutter library build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Configuring FFI Plugin in pubspec.yaml\nDESCRIPTION: This YAML snippet demonstrates how to configure an FFI plugin within the `pubspec.yaml` file. It specifies that the `some_platform` platform uses an FFI plugin. This configuration triggers the native build process and bundles the binaries within Flutter applications targeting this platform.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/README.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nplugin:\n  platforms:\n    some_platform:\n      ffiPlugin: true\n```\n\n----------------------------------------\n\nTITLE: Using Struct Methods in Dart (with Bridge)\nDESCRIPTION: This Dart code represents the generated code for using the `SumWith` struct's methods. It shows how non-static and static methods are accessed and wrapped within a FlutterRustBridge setup.  It showcases the direct integration of the Rust struct and its associated methods in Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_methods.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass SumWith {\n  final FlutterRustBridgeExampleSingleBlockTest bridge;\n  final int x;\n\n  SumWith({\n    required this.bridge,\n    required this.x,\n  });\n\n  Future<int> sum({required int y, dynamic hint}) => ..\n  static Future<int> sum({required int x, required int y, dynamic hint}) => ..\n}\n```\n\n----------------------------------------\n\nTITLE: Ensure Dart SDK >=2.17.0 for Compatibility with flutter_rust_bridge\nDESCRIPTION: Highlights the requirement of Dart SDK version 2.17.0 or higher due to 'ffigen' needs, urging to specify the SDK constraint in 'pubspec.yaml' for proper environment setup.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Defining Build Configurations (Debug, Profile, Release)\nDESCRIPTION: Configures the available build types (configurations) based on whether the CMake generator supports multiple configurations simultaneously (e.g., Visual Studio). If multi-config is supported, it explicitly sets 'Debug;Profile;Release'. Otherwise (e.g., Makefiles), it defaults to 'Debug' if no build type is specified and makes 'Debug', 'Profile', and 'Release' available options.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Define build configuration option.\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enabling build_runner in justfile - Diff\nDESCRIPTION: This diff shows the change required in the `justfile` to uncomment the line that invokes `build_runner`. By uncommenting `flutter pub run build_runner build`, the Dart code will be generated automatically after the Rust bindings are created. This simplifies the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/03-build-runner.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n gen:\n     ..\n     # Uncomment this line to invoke build_runner as well\n-    # flutter pub run build_runner build\n+    flutter pub run build_runner build\n```\n\n----------------------------------------\n\nTITLE: Setting Install Prefix and Bundle Directory\nDESCRIPTION: Sets the installation prefix and defines the build bundle directory. If the CMAKE_INSTALL_PREFIX is set to default, it sets it to a custom bundle directory, ensuring that the installation targets a specific location.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Cross-platform Async Functions in Flutter Rust Bridge\nDESCRIPTION: List of provided async functions that work on both web and non-web platforms. These functions replicate Tokio functionality with cross-platform compatibility.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/cross-platform/async.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n* `spawn`\n* `spawn_local`\n* `spawn_blocking_with` (just like Tokio's `spawn_blocking`)\n```\n\n----------------------------------------\n\nTITLE: Define C++ Wrapper Source File Lists\nDESCRIPTION: Defines lists of C++ source files for the core, plugin-specific, and app-specific parts of the C++ client wrapper. The list items are transformed to include the `WRAPPER_ROOT` path.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# === Wrapper ===\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies to Target with CMake\nDESCRIPTION: This snippet adds a dependency on the flutter_assemble target to the executable target. This ensures that the Flutter assets are built before the executable is linked.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories (C++)\nDESCRIPTION: This snippet adds the source directory to the include paths for the executable target. It ensures that the compiler can find the header files located in the source directory.  This is essential for resolving dependencies on header files within the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Re-exporting Dart Library (Dart)\nDESCRIPTION: This Dart `export` statement is typically placed at the top of the main library file (e.g., `lib/flutter_library_name.dart`) of the Flutter wrapper package. Its purpose is to re-export the entire contents of the underlying Dart-only package, allowing users of the Flutter package to access all the core library functionality directly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nexport 'package:library_name/library_name.dart';\n```\n\n----------------------------------------\n\nTITLE: Including rust.cmake Script in CMake Project - CMake - diff\nDESCRIPTION: This snippet shows how to modify your CMakeLists.txt file by including the rust.cmake script, enabling Rust integration within the build process for your Flutter desktop project. The changes should be made in both windows and linux CMake configurations. Requires both rust.cmake and flutter/generated_plugins.cmake to be present in the working directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/desktop.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n # Generated plugin build rules, which manage building the plugins and adding\n # them to the application.\n include(flutter/generated_plugins.cmake)\n\n+include(./rust.cmake)\n\n # === Installation ===\n # Support files are copied into place next to the executable, so that it can\n\n```\n\n----------------------------------------\n\nTITLE: Including and applying cargokit in CMake\nDESCRIPTION: This includes the cargokit CMake module and applies its functionalities. Cargokit is used to integrate Rust code into the Flutter plugin build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../REPLACE_ME_RUST_CRATE_DIR REPLACE_ME_DART_PACKAGE_NAME \"\")\n```\n\n----------------------------------------\n\nTITLE: CMake Policy and Configuration\nDESCRIPTION: This configures CMake policies to maintain compatibility and uses the generator to determine multi-configuration or single configuration and sets the build configuration types for multi-config generators (Debug, Profile, Release). For single-config generators, it sets the build type to Debug if not already set and sets the build type cache property.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(VERSION 3.14...3.25)\n\n# Define build configuration option.\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Integrating Flutter Tool Backend via Custom CMake Command\nDESCRIPTION: Defines a custom command and a custom target (`flutter_assemble`) to execute the Flutter tool's backend script (`tool_backend.bat`). This command is responsible for generating essential build artifacts like the Flutter library, headers, and C++ wrapper source files based on the target platform and build configuration. It uses a phony output (`_phony_`) to ensure the command runs on every build, as precise input/output tracking is not fully available.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Building Android Native Libraries with cargo-ndk\nDESCRIPTION: This command uses the `cargo ndk` plugin to build the Rust code and places the resulting native libraries into the `../android/app/src/main/jniLibs` directory. This command is executed after installing cargo-ndk and preparing the Android environment. It compiles Rust code for the Android platform, making it available to be integrated into the Flutter application through JNI.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/setup_android.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo ndk -o ../android/app/src/main/jniLibs build\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet sets the minimum required version of CMake to 3.10. This is essential for the Flutter tooling to function correctly and ensures compatibility with the plugin. Increasing this version can cause compilation failures for some users.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Creating Project Versions with Melos GitHub Action (YAML)\nDESCRIPTION: This YAML snippet defines a GitHub Actions workflow triggered manually via `workflow_dispatch`. Its purpose is to automate the creation of new version tags and commits for a monorepo using the Melos tool. It requires a GitHub repository secret `BOT_ACCESS_TOKEN` with sufficient permissions to push changes and tags. The workflow checks out the code, sets up Git user identity, installs Flutter and Melos, runs the `melos version` command with user-specified parameters (`--`, `--prerelease`, or `--graduate`), and finally pushes the resulting commits and tags.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/ci.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nname: Create Release(s)\n\non:\n  workflow_dispatch:\n    inputs:\n      version_parameters:\n        description: 'Parameters to pass to \"melos version\"'\n        required: true\n        default: \" \"\n        type: choice\n        options:\n          - \"--\"\n          - \"--prerelease\"\n          - \"--graduate\"\n\njobs:\n  create_release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          token: ${{ secrets.BOT_ACCESS_TOKEN }}\n          fetch-depth: 0\n      - name: Setup git\n        run: |\n          git config user.name \"YourName\"\n          git config user.email \"your-email@example.com\"\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n\n      - name: Create the new version(s)\n        run: melos version --yes ${{ inputs.version_parameters }}\n\n      - name: Push created version commit\n        run: git push\n      - name: Push modified tags\n        run: git push --tags\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Compilation Settings\nDESCRIPTION: Defines a function to apply standard compilation settings to a target. It sets C++ standard to 17, sets compiler options for warnings and exceptions, and defines preprocessor definitions. This function is used to standardize the compilation process for various targets within the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Setting RPATH for Bundled Libraries\nDESCRIPTION: Sets the RPATH to load bundled libraries from the lib/ directory relative to the binary. This allows the application to find its dependencies at runtime without requiring them to be installed in a standard system location.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_INSTALL_RPATH \"$ORIGIN/lib\")\n```\n\n----------------------------------------\n\nTITLE: Configuring flutter_rust_bridge via pubspec.yaml (YAML)\nDESCRIPTION: Illustrates how to embed the `flutter_rust_bridge` configuration directly within the Dart project's `pubspec.yaml` file. The configuration is placed under the top-level `flutter_rust_bridge` key, specifying `rust_input` and `dart_output` paths similarly to the dedicated YAML file method.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/command_line.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# put this somewhere in your pubspec.yaml\nflutter_rust_bridge:\n  rust_input:\n    - path/to/api.rs\n  dart_output:\n    - lib/src/bridge_generated.dart\n```\n\n----------------------------------------\n\nTITLE: Setting up Directories and Including Configuration\nDESCRIPTION: Defines the ephemeral directory where generated configurations from the Flutter tool reside. It then includes the configuration file generated by the Flutter tool, providing the build-time settings.  This allows the build system to adapt to different Flutter configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Dart FFI Facade\nDESCRIPTION: This Dart code defines a facade for the FFI layer, providing a single entry point for creating the Rust wrapper.  It uses conditional imports to select the appropriate platform-specific implementation (`ffi/io.dart` or `ffi/web.dart`). The `createWrapper` function lazily initializes the wrapper and returns it, ensuring that only one instance is created. It depends on `bridge_generated.dart` and the platform specific FFI files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nimport 'bridge_generated.dart';\nimport 'ffi/stub.dart'\n    if (dart.library.io) 'ffi/io.dart'\n    if (dart.library.js_interop) 'ffi/web.dart';\n\n$DART_CLASS_NAME? _wrapper;\n\n$DART_CLASS_NAME createWrapper(ExternalLibrary lib) {\n  _wrapper ??= createWrapperImpl(lib);\n  return _wrapper!;\n}\n```\n\n----------------------------------------\n\nTITLE: Plugin and Install Rules CMake\nDESCRIPTION: Includes generated plugin build rules and configures installation steps, including setting the install prefix, and defining install locations for the executable, ICU data, Flutter library, bundled libraries, native assets, and assets directory. Conditional installation of the AOT library is based on build type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n\n\n# === Installation ===\n# By default, \"installing\" just makes a relocatable bundle in the build\n# directory.\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\n# Start with a clean build bundle directory every time.\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\")\n  \" COMPONENT Runtime)\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n\n# Copy the native assets provided by the build.dart from all packages.\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\n# Install the AOT library on non-Debug builds only.\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Runner Target\nDESCRIPTION: This code defines the project and the executable target for the Flutter runner application. It specifies the project name and the languages used. The runner is defined as the main executable, and the dependencies and source files are specified in the following blocks. It sets the stage for the application build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Setting up .gitignore for Android Integration\nDESCRIPTION: Adds rules to .gitignore to prevent Rust binaries and archives from being committed to the repository.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/android.md#_snippet_2\n\nLANGUAGE: gitignore\nCODE:\n```\n# Ignore Rust binaries\nsrc/main/jniLibs/\n*.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Initializing Project with CMake\nDESCRIPTION: This snippet initializes the CMake project, sets the minimum required CMake version, specifies the project name and supported languages (CXX).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Getting Help for flutter_rust_bridge_serve (Shell)\nDESCRIPTION: Shows how to invoke the `flutter_rust_bridge_serve` tool using `dart run` and display its help documentation by passing the `--help` argument. The output is included from 'help.serve.txt'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/command_line.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ dart run flutter_rust_bridge_serve --help\n{{#include help.serve.txt}}\n```\n\n----------------------------------------\n\nTITLE: Cargo.toml Workspace Configuration\nDESCRIPTION: This YAML snippet configures the Rust workspace by specifying the members.  It indicates that the `native` crate within the `packages/$LIBNAME` directory is part of the workspace. This allows Cargo to manage dependencies and build processes across multiple crates in the monorepo.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n[workspace]\nmembers = [\"packages/$LIBNAME/native\"]\n```\n\n----------------------------------------\n\nTITLE: Bumping CMake Version for Corrosion Support - CMake - diff\nDESCRIPTION: This snippet instructs you to raise the CMake minimum required version from 3.10 to 3.12 in your linux/CMakeLists.txt file in order to use the Corrosion CMake extension, essential for Rust integration on Linux. Ensure that your system has the appropriate CMake version and that Corrosion is properly installed if further integration steps are needed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/desktop.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-cmake_minimum_required(VERSION 3.10)\n+cmake_minimum_required(VERSION 3.12)\n\n```\n\n----------------------------------------\n\nTITLE: Recursive struct example (Rust)\nDESCRIPTION: This example demonstrates a simple Rust struct `MyTreeNode` with recursive fields. It contains a `value` (a vector of u8) and a `children` field (a vector of `MyTreeNode` instances). This structure showcases how recursive data structures are handled by flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/struct.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyTreeNode {\n    pub value: Vec<u8>,\n    pub children: Vec<MyTreeNode>,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust API Functions: Unwrapping DartOpaque and Panicking on Wrong Thread\nDESCRIPTION: Provides two Rust functions showing safe and unsafe unwrapping of `DartOpaque`. Function `unwrap_dart_opaque` safely retrieves the wrapped Dart object on its originating thread, returning a string. `panic_unwrap_dart_opaque` forces an unwrap on a non-creation thread, causing a panic as enforced by `ThreadBox` rules. Illustrates thread-based safety considerations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n/// [DartWrapObject] can be safely retrieved on a dart thread.\npub fn unwrap_dart_opaque(opaque: DartOpaque) -> SyncReturn<String> {\n    let handle = opaque.try_unwrap().unwrap();\n    SyncReturn(\"Test\".to_owned())\n}\n\n/// [DartWrapObject] cannot be obtained \n/// on a thread other than the thread it was created on.\npub fn panic_unwrap_dart_opaque(opaque: DartOpaque) {\n    let handle = opaque.try_unwrap().unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Nightly, wasm32 Target, and wasm-pack Tools - Bash\nDESCRIPTION: This snippet showcases a sequence of bash commands to install the nightly Rust toolchain, add the rust-src component and the wasm32-unknown-unknown target, and install the wasm-pack utility either via a shell script or Cargo. Dependencies include the rustup toolchain manager, curl, and, optionally, Cargo. Key commands configure Rust for WASM compilation and install the necessary packaging tools. The expected input is execution within a Unix shell, producing a WASM-ready Rust toolchain.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/setup_web.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup toolchain install nightly\nrustup +nightly component add rust-src\nrustup +nightly target add wasm32-unknown-unknown\n# either of these\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\ncargo install wasm-pack\n```\n\n----------------------------------------\n\nTITLE: Defining Sealed Platform Enum Class with Freezed in Dart\nDESCRIPTION: This Dart snippet declares a sealed class Platform with multiple factory constructors for various operating systems using the Freezed code generation package. The class requires the freezed_annotation library and build_runner for code generation. Each constructor defines a platform-specific variant; the macOs constructor includes a String parameter. Inputs include variant names and a string field for macOs, and output is a type-safe union with matching generated code. The code does not compile as-is without running build_runner to generate the corresponding part files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_build_runner.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nsealed class Platform with _$Platform {\n    const factory Platform.unknown() = Platform_Unknown;\n    const factory Platform.android() = Platform_Android;\n    const factory Platforn.ios() = Platform_Ios;\n    const factory Platform.windows() = Platform_Windows;\n    const factory Platform.unix() = Platform_Unix;\n    const factory Platform.macOs(\n        String field0,\n    ) = Platform_MacOs;\n    const factory Platform.wasm() = Platform_Wasm;\n}\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: This snippet includes a configuration file generated by the flutter tool, which contains settings relevant to the specific build environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Version Script - Bash\nDESCRIPTION: This Bash script updates version numbers in specific files within a Flutter project. It extracts the current version from the `pubspec.yaml` file, then updates the `podspec` files for iOS and macOS, and `CMakeLists.txt` files for Android, Linux, and Windows.  It's used by `melos version` to automate version updates during releases.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/01-overview/02-melos.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n\n# iOS & macOS\nAPPLE_HEADER=\"release_tag_name = '$CURR_VERSION' # generated; do not edit\"\nsed -i.bak \"1 s/.*/$APPLE_HEADER/\" packages/flutter_library_name/ios/flutter_library_name.podspec\nsed -i.bak \"1 s/.*/$APPLE_HEADER/\" packages/flutter_library_name/macos/flutter_library_name.podspec\nrm packages/flutter_library_name/macos/*.bak packages/flutter_library_name/ios/*.bak\n\n# CMake platforms (Linux, Windows, and Android)\nCMAKE_HEADER=\"set(LibraryVersion \\\"$CURR_VERSION\\\") # generated; do not edit\"\nfor CMAKE_PLATFORM in android linux windows\ndo\n    sed -i.bak \"1 s/.*/$CMAKE_HEADER/\" packages/flutter_library_name/$CMAKE_PLATFORM/CMakeLists.txt\n    rm packages/flutter_library_name/$CMAKE_PLATFORM/*.bak\ndone\n\ngit add packages/flutter_library_name/\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Windows Runner Executable in CMake\nDESCRIPTION: Sets the minimum required CMake version (3.14), defines the project named 'runner' using C++ (CXX), and creates the main executable target named `${BINARY_NAME}`. It lists the C++ source files (.cpp), the generated plugin registrant, the resource file (`Runner.rc`), and the manifest file (`runner.exe.manifest`) required for the Flutter Windows runner application. The `WIN32` argument indicates a Windows GUI application, suppressing the console window upon launch.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(runner LANGUAGES CXX)\n\n# Define the application target. To change its name, change BINARY_NAME in the\n# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer\n# work.\n#\n# Any new source files that you add to the application should be added here.\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies for Flutter Build\nDESCRIPTION: This line adds dependencies for the Flutter tool portions of the build process. The  `flutter_assemble` target ensures the Flutter build steps are executed. It is crucial for making sure the Flutter build process runs correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Installing AOT Library with CMake\nDESCRIPTION: This snippet installs the AOT library to the installation directory, but only if the build type is not Debug.  AOT (Ahead-Of-Time) compilation is typically done in Release mode.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating Bindings and Running Flutter\nDESCRIPTION: This shell command demonstrates how to regenerate the bindings after modifying the Rust code and running the flutter application. This assumes changes have been made to `rust/src/api/simple.rs`. The `flutter_rust_bridge_codegen generate` command generates the bridge code, which then needs to be rebuilt by `flutter run` to reflect changes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen generate && flutter run\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet sets the minimum required version of CMake.  It's a standard practice to ensure compatibility with the features used in the build script.  The `VERSION` parameter specifies the required version. The `cmake_minimum_required` command is essential for the correct operation of the CMake build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: CMake Runner Subdirectory\nDESCRIPTION: This adds the 'runner' subdirectory to the build process, which typically handles the application's entry point and platform-specific configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Dart Function Conversion from Rust Vec<u8> return\nDESCRIPTION: This snippet shows the Dart equivalent of the Rust function that returns a `Vec<u8>`.  The `Vec<u8>` in Rust is converted to `Uint8List` in Dart using `flutter_rust_bridge`. The `Future` wrapper indicates that the function is asynchronous. The `required List<TreeNode> tree` is the input. The conversion is handled automatically.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_vec.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nFuture<Uint8List> drawTree({required List<TreeNode> tree});\n```\n\n----------------------------------------\n\nTITLE: Adding App Wrapper Library\nDESCRIPTION: This snippet adds a static library for the app wrapper, using the core and app source files. This library provides the integration with the app logic and functionality. The `STATIC` keyword defines a static library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Rust Source Module Reference after Codegen Output Change (Diff)\nDESCRIPTION: This diff snippet illustrates how to adjust the main Rust library module to reference a newly named or relocated bridge module after applying the --rust-output flag. The change swaps mod bridge_generated; for mod my_bridge;, ensuring the main library (lib.rs) includes the generated FFI code from the correct location. There are no inputs or outputs except for the requirement to manually update the source reference to match the actual path and filename set in code generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/finish.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- mod bridge_generated;\n+ mod my_bridge;\n```\n\n----------------------------------------\n\nTITLE: Implementing FFI Stub for Flutter Library\nDESCRIPTION: Stub implementation for the FFI interface that throws an UnimplementedError. This serves as a fallback when platform-specific implementations are not available.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/stub.dart\nObject createLibraryImpl() => throw UnimplementedError();\n```\n\n----------------------------------------\n\nTITLE: Configuring SimpleHandler Globally in Rust\nDESCRIPTION: This Rust snippet demonstrates how to define a global static variable `FLUTTER_RUST_BRIDGE_HANDLER` in `api.rs` using `lazy_static`. This variable is an instance of `SimpleHandler` parameterized with a `ThreadPoolExecutor` and `ReportDartErrorHandler`. This configuration tells Flutter Rust Bridge to use this specific handler instance for all function calls, allowing customization of the executor and error handler components.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/handler.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// api.rs\n\nuse flutter_rust_bridge::handler::ReportDartErrorHandler;\nuse flutter_rust_bridge::handler::SimpleHandler;\nuse flutter_rust_bridge::handler::ThreadPoolExecutor;\nuse lazy_static::lazy_static;\n\nlazy_static! {\n    static ref FLUTTER_RUST_BRIDGE_HANDLER:\n    SimpleHandler<ThreadPoolExecutor<ReportDartErrorHandler>, ReportDartErrorHandler> =\n        SimpleHandler::new(\n            ThreadPoolExecutor::new(ReportDartErrorHandler),\n            ReportDartErrorHandler {}\n        );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargokit for Nightly Rust Toolchain\nDESCRIPTION: This YAML configuration specifies that Cargokit should use the nightly Rust toolchain for release builds instead of the default stable version. The configuration is placed in a cargokit.yaml file at the root of the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/rust-compilation.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# cargokit.yaml\ncargo:\n  release:\n    toolchain: nightly\n```\n\n----------------------------------------\n\nTITLE: Configuring FFI Plugin with Dart Plugin Class\nDESCRIPTION: This YAML snippet demonstrates how to configure an FFI plugin and specify a Dart plugin class within the `pubspec.yaml` file. It indicates that `some_platform` uses an FFI plugin and a `SomeClass` dart plugin class. This combination might be used when FFI implements a platform in a federated plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/README.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nplugin:\n  implements: some_other_plugin\n  platforms:\n    some_platform:\n      dartPluginClass: SomeClass\n      ffiPlugin: true\n```\n\n----------------------------------------\n\nTITLE: Installing Executable\nDESCRIPTION: Installs the executable to the specified destination directory within the build bundle.  It is installed as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command and Target for Flutter Tool Backend Integration in CMake\nDESCRIPTION: This snippet configures a custom command and target to invoke the Flutter tool backend batch script during the build. It forcibly reruns the command by using a symbolic phantom file and sets up dependencies to regenerate Flutter libraries and headers each build. This ensures that Flutter build artifacts are up to date by running the Flutter tool with the correct target platform and build configuration environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Makefile Generation Command (Single File)\nDESCRIPTION: Illustrates the original method of generating code with flutter_rust_bridge_codegen when all APIs were defined in a single file. It highlights the use of `rust-input` and `dart-output` flags to specify the input Rust file and the output Dart file, respectively. `llvm_path` is assumed to be a defined variable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_2\n\nLANGUAGE: makefile\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated.dart\" \\\n...\n```\n\n----------------------------------------\n\nTITLE: Generating Xcode Project with Cargo Xcode\nDESCRIPTION: This snippet demonstrates the command to generate an Xcode project from a Rust crate using `cargo xcode`. This command creates a `.xcodeproj` file in the crate's directory, which can then be imported into Xcode.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/01-proj.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ncargo xcode\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Windows Library Linkage in CMake\nDESCRIPTION: Defines variables for the Flutter Windows library (`flutter_windows.dll`), ICU data file (`icudtl.dat`), project build directory, and AOT library path, exporting them to the parent scope. It creates an INTERFACE library target `flutter` to manage include directories and link dependencies for the Flutter engine, ensuring dependent targets link against the correct library and headers. It also adds a dependency on the `flutter_assemble` target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Defining Ephemeral Directory\nDESCRIPTION: This snippet defines a variable `EPHEMERAL_DIR` pointing to a directory containing generated configuration files from the flutter tool. This directory is crucial for the flutter build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Maybe Enum in Dart\nDESCRIPTION: This code demonstrates pattern matching in Dart using the generated `Maybe` enum.  It shows how to use the `switch` statement and `if case` statement to handle the different variants of the enum.  The code relies on sealed classes introduced in Dart 3.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/enum.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nMaybe maybe;\nfinal value = switch (maybe) {\n  Maybe_None() => 'got nothing',\n  Maybe_Some(:final value) => 'got value: $value',\n};\n// single case à la if-let\nif (maybe case Maybe_Some(:final value)) {\n  ..\n}\n```\n\n----------------------------------------\n\nTITLE: Building Rust Library for Windows/Linux Targets using Bash\nDESCRIPTION: A Bash script (`build-other.sh`) that automates the process of building a Rust library for multiple Windows and Linux architectures (ARM64, x64). It installs `cargo-zigbuild` and `cargo-xwin`, defines helper functions (`zig_build`, `win_build`) to compile for specific targets using these tools, builds the dynamic libraries (`.so` for Linux, `.dll` for Windows), copies them into platform-specific directories, archives the results into `other.tar.gz`, and cleans up intermediate build directories. Requires `library_name` to be replaced.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/01-windows-and-linux.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Install build dependencies\ncargo install cargo-zigbuild\ncargo install cargo-xwin\n\nzig_build () {\n    local TARGET=\"$1\"\n    local PLATFORM_NAME=\"$2\"\n    local LIBNAME=\"$3\"\n    rustup target add \"$TARGET\"\n    cargo zigbuild --target \"$TARGET\" -r\n    mkdir \"$PLATFORM_NAME\"\n    cp \"../target/$TARGET/release/$LIBNAME\" \"$PLATFORM_NAME/\"\n}\n\nwin_build () {\n    local TARGET=\"$1\"\n    local PLATFORM_NAME=\"$2\"\n    local LIBNAME=\"$3\"\n    rustup target add \"$TARGET\"\n    cargo xwin build --target \"$TARGET\" -r\n    mkdir \"$PLATFORM_NAME\"\n    cp \"../target/$TARGET/release/$LIBNAME\" \"$PLATFORM_NAME/\"\n}\n\n# Build all the dynamic libraries\nLINUX_LIBNAME=liblibrary_name.so\nzig_build aarch64-unknown-linux-gnu linux-arm64 $LINUX_LIBNAME\nzig_build x86_64-unknown-linux-gnu linux-x64 $LINUX_LIBNAME\nWINDOWS_LIBNAME=library_name.dll\nwin_build aarch64-pc-windows-msvc windows-arm64 $WINDOWS_LIBNAME\nwin_build x86_64-pc-windows-msvc windows-x64 $WINDOWS_LIBNAME\n\n# Archive the dynamic libs\ntar -czvf other.tar.gz linux-* windows-*\n\n# Cleanup\nrm -rf linux-* windows-*\n```\n\n----------------------------------------\n\nTITLE: Adding App Wrapper Library\nDESCRIPTION: Creates the `flutter_wrapper_app` library, linking to flutter and specifying dependencies and include directories. Uses `STATIC` and `INTERFACE` to define how the library is built and consumed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Flutter Rust Bridge Plugin Build\nDESCRIPTION: This CMake script sets the minimum required CMake version to 3.14, defines a C++ project named 'rust_builder', includes the 'cargokit.cmake' module from a relative path, and applies cargokit to build a Rust library located at '../../../../../../rust/rust_lib'. Finally, it sets the 'rust_builder_bundled_libraries' variable in the parent scope to contain the path of the built Rust library provided by cargokit, making it available for bundling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\n# The Flutter tooling requires that developers have a version of Visual Studio\n# installed that includes CMake 3.14 or later. You should not increase this\n# version, as doing so will cause the plugin to fail to compile for some\n# customers of the plugin.\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_builder\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../../../../rust rust_lib \"\")\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(rust_builder_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-ndk (Rust >= 1.68)\nDESCRIPTION: This command installs the `cargo-ndk` plugin using the cargo package manager. This installation is for Rust versions 1.68 and above. cargo-ndk is a Cargo plugin designed to simplify the process of compiling Rust code to be integrated into an Android project, without additional configuration. It allows easy integration of Rust libraries with Java Native Interface (JNI).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/setup_android.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-ndk\n```\n\n----------------------------------------\n\nTITLE: Importing flutter_rust_bridge Generated Header in iOS Bridging Header using Diff\nDESCRIPTION: This snippet shows the necessary modification to the iOS bridging header file by adding an import statement for the generated dummy header file \"bridge_generated.h\". This import ensures Swift code can see the C symbols exported from the Rust library. The diff format illustrates an added line to the existing bridging header file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/04-headers.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n+#import \"bridge_generated.h\"\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Wrapper Plugin Static Library\nDESCRIPTION: Defines a static library target for the C++ wrapper components needed by plugins. It includes core and plugin-specific sources, applies standard settings, sets target properties, and links against the `flutter` interface library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Importing DocCardList Component in MDX\nDESCRIPTION: This snippet demonstrates importing the 'DocCardList' component from '@theme/DocCardList' and rendering it within an MDX document. It serves as an example of including theme-specific React components in documentation pages for Flutter Rust Bridge projects.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Defining Rust structs with and without opaque attribute\nDESCRIPTION: This snippet defines two Rust structs, A and B. struct A is a standard struct, and flutter_rust_bridge will likely infer it as non-opaque due to its encodable field. struct B is explicitly marked with #[frb(opaque)], forcing it to be treated as an opaque type even though its fields are encodable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/override-defaults.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct A {\n    name: String,\n}\n\n#[frb(opaque)]\nstruct B {\n    name: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Windows Build Steps using CMake\nDESCRIPTION: This CMake snippet initializes Flutter build environment variables, sets up interface libraries for the Flutter Windows DLL and related headers, and prepares lists of source files for wrapper components. It includes configuration to fallback on defaults, link libraries, set include directories, and define dependencies with the flutter_assemble target. Key parameters include the ephemeral directory for generated files, the flutter target platform, and the lists of source files for core, plugin, and app wrappers.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n\n# TODO: Move the rest of this into files in ephemeral. See\n# https://github.com/flutter/flutter/issues/57146.\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n\n# Set fallback configurations for older versions of the flutter tool.\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n\n# === Wrapper ===\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Downgrade Android NDK to Version 22 to Fix cargo-ndk Linking Errors\nDESCRIPTION: Guidance on downgrading the Android NDK to version 22, as compatibility issues cause 'unable to find library -lgcc' errors with cargo-ndk when using Android NDK version 23. This ensures successful cross-compilation for Android targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Returning Dynamic Values from Rust to Dart\nDESCRIPTION: Example showing how to return dynamic values from Rust to Dart using DartAbi type and the into_dart method to convert Rust values into Dart-compatible format.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_dynamic.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn return_dynamic() -> DartAbi {\n    vec![\n        ().into_dart(),\n        0i32.into_dart(),\n        format!(\"Hello there!\").into_dart()\n    ].into_dart()\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nfinal dynamic values = await api.returnDynamic();\nassert(values is List<dynamic>);\nassert(values[0] == null);\nassert(values[1] == 0);\nassert(values[2] == \"Hello there!\");\n```\n\n----------------------------------------\n\nTITLE: Corresponding Dart Function for External Types\nDESCRIPTION: Shows how Rust functions using imported types are represented in Dart as asynchronous functions with required parameters, maintaining type consistency across languages.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_external.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Well it just behaves normally as you expect\nFuture<void> useImportedThings({required MyStruct myStruct, required MyEnum myEnum});\n```\n\n----------------------------------------\n\nTITLE: Implementing ThreadBox for Thread-bound Access Control in Rust\nDESCRIPTION: Introduces `ThreadBox`, a generic struct encapsulating an inner value along with the thread ID of the thread where it was created. Methods checking thread affinity panic if accessed off the creation thread, enforcing thread confinement. The struct implements `Send` and `Sync`, but usage of the inner value is restricted to the original thread, ensuring thread safety while allowing passability between threads as opaque black boxes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct ThreadBox<T> { inner: T, thread_id: ThreadId }\nimpl<T> ThreadBox<T> {\n    fn any_method_that_uses_inner_value(&self) {\n        if !self.is_on_creation_thread() { panic!(); }\n        ...\n    }\n}\nunsafe impl<T> Send for ThreadBox<T> {} // and Sync\n```\n\n----------------------------------------\n\nTITLE: Defining Static Flutter Wrapper Libraries and Linking Dependencies in CMake\nDESCRIPTION: This CMake snippet creates static libraries for Flutter wrapper plugins and apps by grouping core and specific wrapper source files, setting position independent code and visibility properties, including directories, linking against the Flutter INTERFACE library, and specifying dependencies on flutter_assemble target. It enables modular compilation of Flutter wrapper components required for plugin and runner integration on Windows.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Wrapper sources needed for a plugin.\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Card List in MDX for Performance Pages\nDESCRIPTION: This code snippet imports and renders a DocCardList component, which automatically generates a list of navigation cards for child documents in the current section, making it easy to browse performance-related documentation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/performance/index.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Installing Application Bundles and Assets in CMake\nDESCRIPTION: Defines installation directories and rules to produce a relocatable application bundle. Ensures a clean bundle directory on each install by removing previous contents. Installs the main executable, Flutter ICU data files, Flutter libraries, bundled plugin libraries, native assets, and Flutter assets into their proper locations within the bundle structure. The Ahead-Of-Time (AOT) compiled Flutter library is installed only in non-Debug build configurations to optimize runtime performance in Release or Profile modes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")${\\n}if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)${\\n}  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)${\\n}endif()${\\n}${\\n}install(CODE \"${\\n}  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\")${\\n}  \" COMPONENT Runtime)${\\n}${\\n}set(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")${\\n}set(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")${\\n}${\\n}install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"${\\n}  COMPONENT Runtime)${\\n}${\\n}install(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"${\\n}  COMPONENT Runtime)${\\n}${\\n}install(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"${\\n}  COMPONENT Runtime)${\\n}${\\n}foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})${\\n}  install(FILES \"${bundled_library}\"${\\n}    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"${\\n}    COMPONENT Runtime)${\\n}endforeach(bundled_library)${\\n}${\\n}set(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")${\\n}install(DIRECTORY \"${NATIVE_ASSETS_DIR}\"${\\n}   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"${\\n}   COMPONENT Runtime)${\\n}${\\n}set(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")${\\n}install(CODE \"${\\n}  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")${\\n}  \" COMPONENT Runtime)${\\n}install(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"${\\n}  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)${\\n}${\\n}if(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")${\\n}  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"${\\n}    COMPONENT Runtime)${\\n}endif()\n```\n\n----------------------------------------\n\nTITLE: Setting CPATH Environment Variable for Non-Debian Linux (Bash)\nDESCRIPTION: Sets the `CPATH` environment variable in a shell profile (like `.bashrc` or `.zshrc`) for non-Debian Linux systems. This helps Clang find necessary C header files, which might be needed for the build process involving ffigen.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/deps.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport CPATH=\"$(clang -v 2>&1 | grep \"Selected GCC installation\" | rev | cut -d' ' -f1 | rev)/include\"\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command for Flutter Assembly\nDESCRIPTION: Adds a custom command that invokes the Flutter tool backend script to generate the Flutter library and headers. This command runs every time because of the `_phony_` file. It uses the `FLUTTER_TOOL_ENVIRONMENT` variable and specifies the target platform and build type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributors in an HTML Table\nDESCRIPTION: This HTML snippet structures a table row to display information about multiple project contributors. Each table cell (`<td>`) contains an anchor tag (`<a>`) linking to the contributor's profile, an image tag (`<img>`) for their avatar, their name, and further links indicating their contribution types (e.g., code `💻`, documentation `📖`). Attributes like `align`, `valign`, and `width` are used for basic layout.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_macros/README.md#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://gutenfries.deno.dev\"><img src=\"https://avatars.githubusercontent.com/u/79616833?v=4?s=100\" width=\"100px;\" alt=\"Marc Gutenberger\"/><br /><sub><b>Marc Gutenberger</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=gutenfries\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/anstadnik\"><img src=\"https://avatars.githubusercontent.com/u/40110937?v=4?s=100\" width=\"100px;\" alt=\"Andrii Stadnik\"/><br /><sub><b>Andrii Stadnik</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=anstadnik\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Syndim\"><img src=\"https://avatars.githubusercontent.com/u/835035?v=4?s=100\" width=\"100px;\" alt=\"syndim\"/><br /><sub><b>syndim</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=syndim\" title=\"Code\">💻</a></td>\n    </tr>\n```\n\nLANGUAGE: html\nCODE:\n```\n<tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/vhdirk\"><img src=\"https://avatars.githubusercontent.com/u/1424486?v=4?s=100\" width=\"100px;\" alt=\"Dirk Van Haerenborgh\"/><br /><sub><b>Dirk Van Haerenborgh</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=vhdirk\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/akkumar\"><img src=\"https://avatars.githubusercontent.com/u/38454?v=4?s=100\" width=\"100px;\" alt=\"Karthik K\"/><br /><sub><b>Karthik K</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=akkumar\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://rhian-cs.dev\"><img src=\"https://avatars.githubusercontent.com/u/72531802?v=4?s=100\" width=\"100px;\" alt=\"Rhian Moraes\"/><br /><sub><b>Rhian Moraes</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=rhian-cs\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://ares.zone (国内)\"><img src=\"https://avatars.githubusercontent.com/u/40336192?v=4?s=100\" width=\"100px;\" alt=\"Ares Andrew\"/><br /><sub><b>Ares Andrew</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TENX-S\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/CJBuchel\"><img src=\"https://avatars.githubusercontent.com/u/35585061?v=4?s=100\" width=\"100px;\" alt=\"Connor J Buchel\"/><br /><sub><b>Connor J Buchel</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CJBuchel\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CJBuchel\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/polypixeldev\"><img src=\"https://avatars.githubusercontent.com/u/79737178?v=4?s=100\" width=\"100px;\" alt=\"polypixeldev\"/><br /><sub><b>polypixeldev</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=polypixeldev\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/CicadaCinema\"><img src=\"https://avatars.githubusercontent.com/u/52425971?v=4?s=100\" width=\"100px;\" alt=\"CicadaCinema\"/><br /><sub><b>CicadaCinema</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CicadaCinema\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CicadaCinema\" title=\"Documentation\">📖</a></td>\n    </tr>\n```\n\nLANGUAGE: html\nCODE:\n```\n<tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://cosmichorror.dev\"><img src=\"https://avatars.githubusercontent.com/u/30302768?v=4?s=100\" width=\"100px;\" alt=\"CosmicHorror\"/><br /><sub><b>CosmicHorror</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CosmicHorrorDev\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/akashgurava\"><img src=\"https://avatars.githubusercontent.com/u/13036662?v=4?s=100\" width=\"100px;\" alt=\"Akash Gurava\"/><br /><sub><b>Akash Gurava</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=akashgurava\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.floeschner.de/\"><img src=\"https://avatars.githubusercontent.com/u/12967904?v=4?s=100\" width=\"100px;\" alt=\"Fabian Löschner\"/><br /><sub><b>Fabian Löschner</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=w1th0utnam3\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://matrix.to/#/@vincentherl:matrix.org\"><img src=\"https://avatars.githubusercontent.com/u/5569193?v=4?s=100\" width=\"100px;\" alt=\"Vincent Herlemont\"/><br /><sub><b>Vincent Herlemont</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=vincent-herlemont\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://canxin121.github.io/docs/\"><img src=\"https://avatars.githubusercontent.com/u/69547456?v=4?s=100\" width=\"100px;\" alt=\"canxin\"/><br /><sub><b>canxin</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=canxin121\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/pixelshot91\"><img src=\"https://avatars.githubusercontent.com/u/19229808?v=4?s=100\" width=\"100px;\" alt=\"pixelshot91\"/><br /><sub><b>pixelshot91</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=pixelshot91\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://steinbrecher-bayern.de\"><img src=\"https://avatars.githubusercontent.com/u/6358523?v=4?s=100\" width=\"100px;\" alt=\"TrackerSB\"/><br /><sub><b>TrackerSB</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TrackerSB\" title=\"Code\">💻</a></td>\n    </tr>\n```\n\nLANGUAGE: html\nCODE:\n```\n<tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/bubnov\"><img src=\"https://avatars.githubusercontent.com/u/818612?v=4?s=100\" width=\"100px;\" alt=\"Slavik Bubnov\"/><br /><sub><b>Slavik Bubnov</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=bubnov\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Dampfwalze\"><img src=\"https://avatars.githubusercontent.com/u/46897578?v=4?s=100\" width=\"100px;\" alt=\"Dampfwalze\"/><br /><sub><b>Dampfwalze</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Dampfwalze\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://samuel-cavalcanti.github.io\"><img src=\"https://avatars.githubusercontent.com/u/24573157?v=4?s=100\" width=\"100px;\" alt=\"Samuel Cavalcanti\"/><br /><sub><b>Samuel Cavalcanti</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=samuel-cavalcanti\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.zaynetro.com/\"><img src=\"https://avatars.githubusercontent.com/u/627197?v=4?s=100\" width=\"100px;\" alt=\"Roman Zaynetdinov\"/><br /><sub><b>Roman Zaynetdinov</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=zaynetro\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/raphaelrobert\"><img src=\"https://avatars.githubusercontent.com/u/9882746?v=4?s=100\" width=\"100px;\" alt=\"raphaelrobert\"/><br /><sub><b>raphaelrobert</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=raphaelrobert\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/DMouayad\"><img src=\"https://avatars.githubusercontent.com/u/82384138?v=4?s=100\" width=\"100px;\" alt=\"Mouayad Alhamwi\"/><br /><sub><b>Mouayad Alhamwi</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=DMouayad\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/elliotsayes\"><img src=\"https://avatars.githubusercontent.com/u/7699058?v=4?s=100\" width=\"100px;\" alt=\"elliotsayes\"/><br /><sub><b>elliotsayes</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=elliotsayes\" title=\"Documentation\">📖</a></td>\n    </tr>\n```\n\nLANGUAGE: html\nCODE:\n```\n<tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tmpfs.org\"><img src=\"https://avatars.githubusercontent.com/u/238069?v=4?s=100\" width=\"100px;\" alt=\"muji\"/><br /><sub><b>muji</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=tmpfs\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/thomas725\"><img src=\"https://avatars.githubusercontent.com/u/68635351?v=4?s=100\" width=\"100px;\" alt=\"thomas725\"/><br /><sub><b>thomas725</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=thomas725\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://soeur.dev\"><img src=\"https://avatars.githubusercontent.com/u/26034975?v=4?s=100\" width=\"100px;\" alt=\"orange soeur\"/><br /><sub><b>orange soeur</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=juzi5201314\" title=\"Documentation\">📖</a></td>\n```\n\n----------------------------------------\n\nTITLE: Calling Rust function from Dart code using generated bridge\nDESCRIPTION: Calls the Rust function 'f' from Dart, passing a string and a list of enums, illustrating seamless cross-language invocation. Relies on the generated binding code to bridge Dart to Rust, without manual glue code, showcasing the core capability of the flutter_rust_bridge project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_macros/README.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nprint(f(a: 'Hello', b: [MyEnum.c('Tom')]))\n```\n\n----------------------------------------\n\nTITLE: Defining and Configuring the Flutter Library in CMake\nDESCRIPTION: Sets paths for the Flutter library (`flutter_windows.dll`) and ICU data file (`icudtl.dat`), making them available to the parent scope. It defines a list of required Flutter headers, creates an INTERFACE library named `flutter`, specifies its include directories, links it to the actual Flutter library's import library (`.lib`), and adds a dependency on the `flutter_assemble` custom target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Upgrading dependencies\nDESCRIPTION: These commands upgrade the `flutter_rust_bridge` dependency in dependent projects. The first command uses `flutter pub upgrade` for the Dart/Flutter side, and the second command uses `cargo update` for the Rust side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/appendix.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nflutter pub upgrade flutter_rust_bridge\ncargo update -p flutter_rust_bridge\n```\n\n----------------------------------------\n\nTITLE: Adding Integration Test Dependencies in Flutter Package\nDESCRIPTION: YAML configuration to add Flutter test and integration test dependencies to the pubspec.yaml file. This enables integration testing for the Flutter package.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/flutter_wrapper.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  integration_test:\n    sdk: flutter\n```\n\n----------------------------------------\n\nTITLE: Configuring CMakeLists.txt for Android Binary Integration\nDESCRIPTION: This CMake script downloads and extracts Android binaries into the jniLibs directory without building anything. It handles binary fetching in a cross-platform friendly way.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/03-android.md#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\nset(PROJECT_NAME \"project_name\")\n\n# Unlike the Windows & Linux CMakeLists.txt, this Android equivalent is just here\n# to download the Android binaries into src/main/jniLibs/ and does not build anything.\n# The binary download/extraction is difficult to do concisely in Groovy/Gradle,\n# at least across host platforms, so we are just reusing our Linux/Windows logic.\n\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\nproject(PROJECT_NAME)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/src/main/jniLibs\")\nset(ArchivePath \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/android.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Public Function with frb Attribute - Rust\nDESCRIPTION: Demonstrates how to use the `#[frb(ignore)]` attribute to explicitly exclude a public standalone Rust function from being processed by flutter_rust_bridge. Applying this attribute ensures that no corresponding Dart binding is generated for the function, even though it is publicly visible within the Rust code. This requires the `frb` attribute macro to be in scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/ignoring.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(ignore)]\npub fn ignored_in_frb() {\n    println!(\"you should not see ignoredInFrb in dart side.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Enum for Heterogeneous Data\nDESCRIPTION: This Rust snippet defines an `enum` to represent data that can be either a `u32` or a `String`. This is shown as a preferred, type-safe alternative to using structs with optional fields for handling varied data types translatable by `flutter_rust_bridge`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-dynamic.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nenum MyEnum {\n    U32(u32),\n    String(String),\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter and Runner Subdirectories\nDESCRIPTION: Includes build logic from subdirectories. It first sets the `FLUTTER_MANAGED_DIR` variable to the path of the `flutter` subdirectory relative to the current source directory and then uses `add_subdirectory` to process the `CMakeLists.txt` within that directory (containing Flutter-specific build rules). It subsequently adds the `runner` subdirectory, which contains the main application build logic.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Fix '_cxa_pure_virtual' and libc++ Shared Library Linking on Android\nDESCRIPTION: Adds a Rust build script 'build.rs' to link with 'c++_shared' library on Android, resolving symbol resolution errors related to virtual functions ('__cxa_pure_virtual') and dynamic linking issues involving 'libc++_shared.so'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nfn main() {\n    #[cfg(target_os = \"android\")]\n    println!(\"cargo:rustc-link-lib=c++_shared\");\n}\n```\n\n----------------------------------------\n\nTITLE: RustAutoOpaque Struct Implementation and Usage Example in Rust\nDESCRIPTION: This snippet illustrates the creation and manipulation of a RustAutoOpaque instance, showcasing methods for read/write access such as try_read, try_write, read, and write. It emphasizes thread safety through lock mechanisms similar to tokio's RwLock, allowing concurrent access management. The example demonstrates initializing the object, writing to it, and reading its value, useful for multi-threaded environments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/struct.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn example() {\n    let opaque = RustAutoOpaqueNom::new(42);\n    *opaque.try_write().unwrap() = 100;\n    println!(\"{}\", opaque.try_read().unwrap());\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Function Signature for Zero-Copy\nDESCRIPTION: Shows the generated Dart function signature `drawTree` corresponding to the Rust function using `ZeroCopyBuffer` or the `zero-copy` feature. Although the signature returns a standard `Future<Uint8List>`, the internal implementation is modified by `flutter_rust_bridge` to perform zero-copy transfer from Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/zero_copy.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nFuture<Uint8List> drawTree({required List<TreeNode> tree});\n```\n\n----------------------------------------\n\nTITLE: Multiple Function Calls with Same RustOpaque in Dart\nDESCRIPTION: Shows how reference counting works when the same opaque type is used in multiple sequential function calls. This pattern demonstrates how Arc properly manages ownership between Dart and Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately.\n// (Arc counter = 1) after complete\nString hideData1 = await api.runOpaque(opaque: opaque);\n\n// (Arc counter = 2) increases immediately.\n// (Arc counter = 1) after complete\nString hideData2 = await api.runOpaque(opaque: opaque);\n\n// (Arc counter = 0) opaque type is dropped (deallocated)\nopaque.dispose();\n```\n\n----------------------------------------\n\nTITLE: Freezed Sealed Class Definition - Dart\nDESCRIPTION: This Dart code snippet defines a sealed class `Platform` using the `freezed` library. It includes several factory constructors representing different platform types, such as unknown, android, ios, windows, unix, macOS, and wasm. The `freezed` library requires `build_runner` to generate the necessary implementation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/03-build-runner.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@freezed\nsealed class Platform with _$Platform {\n    const factory Platform.unknown() = Platform_Unknown;\n    const factory Platform.android() = Platform_Android;\n    const factory Platforn.ios() = Platform_Ios;\n    const factory Platform.windows() = Platform_Windows;\n    const factory Platform.unix() = Platform_Unix;\n    const factory Platform.macOs(\n        String field0,\n    ) = Platform_MacOs;\n    const factory Platform.wasm() = Platform_Wasm;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating libgcc.a redirection files to libunwind - plaintext\nDESCRIPTION: A manual workaround for resolving linking errors related to 'libgcc' when using high Android NDK versions with older Rust versions. It entails creating four text files named 'libgcc.a' in specific directories where 'libunwind.a' resides. Each file contains a single line that instructs the linker to input 'libunwind' instead of 'libgcc'. The snippet demonstrates example directory paths for Windows and macOS where these files should be created.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/alternative_ndk.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nINPUT(-lunwind)\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nC:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\ndk\\24.0.8215888\\toolchains\\llvm\\prebuilt\\windows-x86_64\\lib64\\clang\\14.0.1\\lib\\linux\\x86_64\\\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n~/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/14.0.1/lib/linux/x86_64/\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Card List with Docusaurus in JavaScript\nDESCRIPTION: This snippet demonstrates how to render a list of documentation cards in a Docusaurus-based documentation site by importing and using the DocCardList component. It assumes that Docusaurus and relevant plugins are installed. The only required parameter is the default configuration for DocCardList, and it produces a rendered list of documentation topics for the user interface. This is intended for static site documentation and does not handle dynamic inputs or outputs.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Structuring the Rust Crate within Flutter Project\nDESCRIPTION: This snippet illustrates the recommended directory structure for placing a Rust crate ($crate) within a Flutter project. Positioning it as a sibling to the native build folders facilitates easier configuration and integration with `flutter_rust_bridge`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/new_crate.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n├── android\n├── ios\n├── lib\n├── linux\n├── macos\n├── $crate\n│   ├── Cargo.toml\n│   ┛── src\n├── test\n├── web\n┛── windows\n```\n\n----------------------------------------\n\nTITLE: Ensuring Dart Code Generation by Using Struct in Function Parameters - Rust\nDESCRIPTION: This Rust snippet highlights how referencing an annotated struct (DartCodeStruct) as a function parameter can trigger flutter_rust_bridge to generate the corresponding Dart class and embed the specified Dart static function. The pattern ensures code is generated even if the struct contains no business logic. Inputs are the struct definition and the function declaration; output is the generated Dart class if the function is public. A key constraint is that unused structs are ignored during code generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/dart-code.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(dart_code = \"static void dartSay() => print('Dart_code at struct');\")]\npub struct DartCodeStruct {}\n\npub fn noop(dcs: DartCodeStruct) {}\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Function Returning DartDynamic in Dart\nDESCRIPTION: This Dart snippet shows how to call the `return_dynamic` function exposed by `flutter_rust_bridge`. It receives the result as a `dynamic` type and includes assertions to verify that the returned value is a list and contains the expected types and values from the Rust side.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-dynamic.md#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\nfinal dynamic values = await api.returnDynamic();\nassert(values is List<dynamic>);\nassert(values[0] == null);\nassert(values[1] == 0);\nassert(values[2] == \"Hello there!\");\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Trait - Rust\nDESCRIPTION: This Rust code snippet defines a trait named `MyTrait`. It declares a single method `f` which takes a string `a` as input and returns an integer. This trait serves as the foundation for creating an abstract class in Dart. It requires no specific dependencies. The method `f` takes a string and returns an i32.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/traits/definitions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\npub trait MyTrait {\n    fn f(&self, a: String) -> i32;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: Includes a CMake configuration file generated by the Flutter tool. This file likely contains platform-specific settings and definitions required for the build process.  It is essential for integrating Flutter's build system with CMake.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Unwrapping RustOpaque in Flutter/Rust Bridge - Rust\nDESCRIPTION: This Rust code snippet demonstrates how to unwrap a RustOpaque instance safely. The `unwrap_rust_opaque` function takes an `Opaque<HideData>` as input and attempts to unwrap it. It uses `try_unwrap()` to get the underlying data. If unwrapping fails (the opaque type is shared), an error is returned. Successful unwrapping allows the code to access the data from inside the opaque type. It requires `HideData`, `Opaque` and `Result` from flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn unwrap_rust_opaque(opaque: Opaque<HideData>) -> Result<String> {\n    let res: Result<HideData, Opaque<HideData>> = opaque.try_unwrap();\n    let data: HideData = res.map_err(|_| anyhow::anyhow!(\"opaque type is shared\"))?;\n    Ok(data.hide_data())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Interface Library in CMake\nDESCRIPTION: Defines an `INTERFACE` library named `flutter`. This type of library doesn't compile sources itself but specifies usage requirements for targets that link against it. It sets the include directory to `${EPHEMERAL_DIR}` and specifies linking against the main Flutter library (`FLUTTER_LIBRARY`) and the system libraries found earlier (GTK, GLib, GIO). It also adds a dependency on the `flutter_assemble` target, ensuring Flutter artifacts are built before this library is used.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Unwrapping DartOpaque Objects in Rust\nDESCRIPTION: Shows how to retrieve the underlying Dart object handle from `DartOpaque` in Rust using `try_unwrap()`. The `unwrap_dart_opaque` function demonstrates successful unwrapping when called on the same thread the object was created on. The `panic_unwrap_dart_opaque` function illustrates that attempting `try_unwrap()` on a different thread will fail. The Dart code calls both functions, handling the expected exception for the cross-thread unwrap attempt.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/dart_opaque_type_safety.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n/// [DartWrapObject] can be safely retrieved on a dart thread.\npub fn unwrap_dart_opaque(opaque: DartOpaque) -> SyncReturn<String> {\n    let handle = opaque.try_unwrap().unwrap();\n    SyncReturn(\"Test\".to_owned())\n}\n\n/// [DartWrapObject] cannot be obtained \n/// on a thread other than the thread it was created on.\npub fn panic_unwrap_dart_opaque(opaque: DartOpaque) {\n    let handle = opaque.try_unwrap().unwrap();\n}\n```\n\nLANGUAGE: Dart\nCODE:\n```\n// Rust gets (drop safely) wrap Dart_PersistentHandler (or JsValue).\napi.unwrapDartOpaque(opaque: () => 'Test_String');\n\n// We get an error because DartOpaque was passed to another thread.\nawait expectLater(() => api.panicUnwrapDartOpaque(opaque: () => 'Test_String'), throwsA(isA<FfiException>()));\n```\n\n----------------------------------------\n\nTITLE: Setting CPATH Environment Variable in Bash\nDESCRIPTION: Exports the `CPATH` environment variable in Bash to help the code generator locate standard C header files like `stdarg.h` or `stdbool.h`. This command dynamically finds the GCC include path using `clang -v` and is often needed to resolve header file not found errors during code generation on Linux.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport CPATH=\"$(clang -v 2>&1 | grep \"Selected GCC installation\" | rev | cut -d' ' -f1 | rev)/include\"\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Command to Build Flutter Tool Backend\nDESCRIPTION: Defines a custom command to execute the Flutter tool's backend, which generates build artifacts. Uses a phony output file to ensure it runs every time and includes dependencies such as Flutter headers and wrapper sources.  This command runs a batch file to perform the backend build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Cloneable DartOpaque Wrapper with Arc in Rust\nDESCRIPTION: Defines `DartOpaque` struct that holds an `Arc` (atomic reference counted pointer) of the `DartOpaqueNonClone` type. This addition makes the opaque handle cloneable, allowing multiple ownership with safe atomic reference counting while maintaining the thread-safety guarantees established by the inner types.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nstruct DartOpaque {\n    arc: Arc<DartOpaqueNonClone>,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Library API Module Declaration\nDESCRIPTION: This Rust code declares a module named `api` within the Rust library.  This allows the code in `src/api.rs` to be used by other parts of the crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nmod api;\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings\nDESCRIPTION: This snippet applies a predefined set of standard build settings to the target specified by BINARY_NAME. It simplifies configuration management by standardizing compiler options, compiler flags, and other build parameters, which can be customized as needed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Creating and Using RustOpaque in Flutter/Rust Bridge (web) - Rust\nDESCRIPTION: This Rust code snippet demonstrates creating and using a RustOpaque type, specifically HideData, which is a private struct. The `create_opaque` function creates a new RustOpaque instance. The `run_opaque` function dereferences the RustOpaque to access the underlying data. This example highlights the usage of RustOpaque and how to manage the data within the Rust code.  It requires the `HideData` struct and the `RustOpaque` type from the flutter_rust_bridge crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n```\n\n----------------------------------------\n\nTITLE: Initialize Android NDK Context via JNI_OnLoad (Method 1)\nDESCRIPTION: This method ensures the native library is loaded by the Java VM via `System.loadLibrary` in the main Activity's `init` block. This triggers the standard JNI `JNI_OnLoad` function in the Rust code, where `ndk_context::initialize_android_context` is called with the JavaVM pointer, providing the necessary context. This method is suitable for cases where JNI_OnLoad is the desired initialization entry point. It requires the `jni` and `ndk-context` crates in Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/ndk-init.md#_snippet_0\n\nLANGUAGE: Kotlin\nCODE:\n```\npackage com.example.frontend\n\nimport io.flutter.embedding.android.FlutterActivity\n\n// https://github.com/dart-lang/sdk/issues/46027\nclass MainActivity : FlutterActivity() {\n    // this `init` block, where \"foo\" is the name of your library\n    // ex: if it's libfoo.so, then use \"foo\"\n    init {\n        System.loadLibrary(\"foo\")\n    }\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n[target.'cfg(target_os = \"android\")'.dependencies]\njni = \"0.21\"\nndk-context = \"0.1\"\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[cfg(target_os = \"android\")]\n#[no_mangle]\npub extern \"C\" fn JNI_OnLoad(vm: jni::JavaVM, res: *mut std::os::raw::c_void) -> jni::sys::jint {\n    use std::ffi::c_void;\n\n    let vm = vm.get_java_vm_pointer() as *mut c_void;\n    unsafe {\n        ndk_context::initialize_android_context(vm, res);\n    }\n    jni::JNIVersion::V6.into()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Compilation Settings\nDESCRIPTION: Defines a function APPLY_STANDARD_SETTINGS to apply standard compilation settings to a target. This function sets C++ standard, compiler options (warnings and errors), and optimization levels based on the build configuration (Debug vs. non-Debug).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Settings to Target\nDESCRIPTION: Applies the standard build settings defined in the APPLY_STANDARD_SETTINGS function to the executable target. This ensures consistent build settings across the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Configure XCode to Prevent Stripping Symbols in iOS TestFlight\nDESCRIPTION: Guides changing build settings in XCode to disable symbol stripping ('Strip Linked Product') and ensure the symbol 'store_dart_post_cobject' is available in distribution builds like TestFlight, preventing runtime linkage errors.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Configuring Flutter Build Steps with CMake\nDESCRIPTION: This snippet initializes CMake with minimum required version and sets up directory variables to organize build artifacts and ephemeral files. It includes auto-generated Flutter configurations and defines fallback target platform if not set. It configures variables for Flutter libraries (DLL, ICU data) and project build outputs, and lists Flutter library headers with paths transformed for use in compilation. It creates an INTERFACE Flutter library target referencing these configurations and ensures dependencies on the flutter_assemble target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n\n# TODO: Move the rest of this into files in ephemeral. See\n# https://github.com/flutter/flutter/issues/57146.\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n\n# Set fallback configurations for older versions of the flutter tool.\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n\n# === Flutter Library ===\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Struct in Rust\nDESCRIPTION: This Rust code defines a struct named MyTreeNode with two fields: value, a vector of u8 bytes, and children, a vector of child MyTreeNode instances. This demonstrates how to define recursive data structures in Rust for use with flutter_rust_bridge. No external dependencies are required and all fields are public to enable Dart code generation. The Vec<u8> and Vec<MyTreeNode> fields represent arbitrary binary data and recursive relationships respectively.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_struct.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyTreeNode {\n    pub value: Vec<u8>,\n    pub children: Vec<MyTreeNode>,\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Releases to GitHub and pub.dev via GitHub Actions (YAML)\nDESCRIPTION: Defines a GitHub Actions workflow (`publish-release.yml`) triggered by tag pushes. It consists of two jobs: one builds library binaries across platforms (using Zig, LLVM, Rust, NDK) and creates a GitHub release, the second publishes the packages to pub.dev using Melos. Requires a `PUB_CRED_JSON` secret containing pub.dev credentials.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nname: Publish Release(s)\n\non:\n  push:\n    tags:\n      - \"*\"\n\njobs:\n  publish_github_release:\n    # macOS because we can cross-compile to all other platforms from it\n    runs-on: macos-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - uses: goto-bus-stop/setup-zig@v2\n      - uses: KyleMayes/install-llvm-action@v1\n        with:\n          version: \"15\"\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          toolchain: stable\n      - uses: nttld/setup-ndk@v1\n        with:\n          ndk-version: r25b\n\n      - name: Build all library binaries\n        run: melos run build\n\n      - name: Create GitHub release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: platform-build/*\n\n  publish_pub_release:\n    needs: publish_github_release\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: subosito/flutter-action@v2\n      - uses: bluefireteam/melos-action@v2\n      - name: Setup pub.dev credentials\n        run: |\n          mkdir -p $HOME/.config/dart\n          cat << EOF > $HOME/.config/dart/pub-credentials.json\n          ${{ secrets.PUB_CRED_JSON }}\n          EOF\n      - name: Dry-run publish to pub.dev\n        run: melos publish -y --dry-run\n      - name: Publish to pub.dev\n        run: melos publish -y --no-dry-run\n```\n\n----------------------------------------\n\nTITLE: Initializing Project and Setting Executable Target in CMake (CMake)\nDESCRIPTION: This snippet specifies the CMake minimum version, project name, and the languages used (CXX), then sets up key application variables like the binary and application ID. Required before configuring targets and dependencies, the variables serve as unique identifiers for the application and enable platform integration. No parameters are required, but CMake 3.10+ and a valid toolchain are prerequisites.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\nproject(runner LANGUAGES CXX)\nset(BINARY_NAME \"frb_example_rust_ui_todo_list\")\nset(APPLICATION_ID \"com.example.frb_example_rust_ui_todo_list\")\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-ndk (Rust < 1.68)\nDESCRIPTION: This command installs the `cargo-ndk` plugin with version 2.6.0 using the cargo package manager. This version is necessary for compatibility with NDK version 22 when using Rust versions below 1.68. cargo-ndk is a plugin that simplifies the process of compiling Rust code for the Android platform. The version specified here ensures compatibility with older Rust versions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/setup_android.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo install cargo-ndk --version 2.6.0\n```\n\n----------------------------------------\n\nTITLE: Installing Executable, Data & Libraries\nDESCRIPTION: Specifies the installation targets and files. Installs the executable, Flutter ICU data file, Flutter library, bundled libraries and native assets to specified destinations. The installation process prepares the application for deployment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Using Imported Types in Rust and Dart\nDESCRIPTION: Demonstrates importing external types (structs and enums) from the same crate and their usage in Rust functions and Dart code. Assumes dependencies on crate data and Flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_external.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse crate::data::{MyEnum, MyStruct};\n\npub fn use_imported_things(my_struct: MyStruct, my_enum: MyEnum) { ... }\n```\n\n----------------------------------------\n\nTITLE: FFI Function Example\nDESCRIPTION: Illustrates the FFI function `new_uint_8_list` automatically generated by flutter_rust_bridge for String parameters. The conflict of this function's signature across blocks causes compilation issues.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub extern \"C\" fn new_uint_8_list(len: i32) -> *mut wire_uint_8_list\n```\n\n----------------------------------------\n\nTITLE: Listing Flutter Library Headers\nDESCRIPTION: This snippet defines the list of header files required by the Flutter library. These header files are used to expose the Flutter API. The `APPEND` command adds new header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using Rust WordDict from Dart with Async and Stream Support\nDESCRIPTION: Shows Dart code that interacts with the Rust WordDict. The code asynchronously opens the dictionary, retrieves its size synchronously, and performs a search that streams multiple results back to Dart. The example demonstrates Flutter app integration with async/await and for-await-in syntax to process streamed data from Rust functions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_macros/README.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Paths\nDESCRIPTION: This snippet sets variables for the Flutter library, ICU data file, project build directory and AOT library paths. The `PARENT_SCOPE` argument ensures that these variables are accessible in the parent scope, typically for use in the installation step.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Updating Platform Enum Construction in Rust for macOS\nDESCRIPTION: Updates the Rust code in `native/src/api.rs` to adapt to the modified `Platform` enum definition. It replaces distinct `MacApple` and `MacIntel` variants with a single `MacOs` variant that accepts the architecture ('Apple Silicon' or 'Intel') as a string argument, using conditional compilation (`cfg!`) to determine the correct architecture at compile time.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/template/generate_finish.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n     } else if cfg!(target_os = \"ios\") {\n         Platform::Ios\n     } else if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n-        Platform::MacApple\n+        Platform::MacOs(\"Apple Silicon\".into())\n     } else if cfg!(target_os = \"macos\") {\n-        Platform::MacIntel\n+        Platform::MacOs(\"Intel\".into())\n     } else if cfg!(target_family = \"wasm\") {\n         Platform::Wasm\n     } else if cfg!(unix) {\n```\n\n----------------------------------------\n\nTITLE: Publishing Flutter Library Path\nDESCRIPTION: This snippet publishes the Flutter library, ICU data, build directory, and AOT library paths to the parent scope for the install step. The install step depends on these variables. The `PARENT_SCOPE` argument ensures that the variables are available in the parent scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Shell Script: Copying Files for Android Integration Tests\nDESCRIPTION: This shell script copies the android.tar.gz file to the relevant android folder. It determines the current version by parsing the pubspec.yaml file. It uses `awk` to get the version number and construct the CURR_VERSION variable, and then copies the .tar.gz file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\ncp platform-build/android.tar.gz packages/flutter_library_name/android/$CURR_VERSION.tar.gz\necho Copied file!\n```\n\n----------------------------------------\n\nTITLE: Running Flutter Rust Bridge Codegen\nDESCRIPTION: This bash command executes the flutter_rust_bridge_codegen tool.  The specific flags and arguments depend on the project configuration. It is assumed that `command.sh.txt` contains the full command. This command needs to be run whenever the Rust code changes and before running `flutter run`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/08-finish.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n{{#include command.sh.txt}}\n```\n\n----------------------------------------\n\nTITLE: Defining a List Prepend Utility Function in CMake\nDESCRIPTION: Implements a custom CMake function named list_prepend to add a specified prefix to every element in a given list, replicating native list(TRANSFORM ... PREPEND ...) functionality unavailable in CMake 3.10. No external dependencies are required besides CMake. The LIST_NAME argument specifies the target list, and PREFIX is the string to prepend. The modified list is set in the parent scope for further use.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Adding App Wrapper Assemble Dependency\nDESCRIPTION: This snippet adds a dependency on `flutter_assemble`. This dependency guarantees that the `flutter_assemble` target runs before building the app wrapper target, helping to establish the correct build order.  This ensures correct building.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Rendering DocCardList React Component in MDX\nDESCRIPTION: Imports the DocCardList component from the '@theme/DocCardList' package and renders it inside an MDX code block. This snippet is used within a React/MDX environment to display a list of documentation cards automatically, enhancing navigation or content discovery. It requires the React environment and the '@theme/DocCardList' package to be available in the project dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/miscellaneous/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Mapping Rust HashMap to Dart Map in Flutter-Rust Bridge\nDESCRIPTION: This Rust function accepts a HashMap with String keys and Vec<u8> values. In Dart, this corresponds to a Map<String, Uint8List>. The snippet demonstrates how Rust's HashMap is supported and how it will be represented in Dart code for interoperability.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/map_set.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn f(a: HashMap<String, Vec<u8>>) {}\n```\n\n----------------------------------------\n\nTITLE: Linking Dependency Libraries (C++)\nDESCRIPTION: This section links the necessary libraries that the executable depends on using the `target_link_libraries` command.  It links against 'flutter' and 'PkgConfig::GTK' libraries privately. This makes the Flutter framework and GTK libraries available during compilation, enabling the application to function and utilize Flutter's features.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Naive Method Implementation\nDESCRIPTION: This code demonstrates a naive, manual way to implement wrapper methods for the `Foo` struct. Each method locks the `Mutex`, unwraps the result, and calls the corresponding method on the inner `Foo` struct. The code includes a comment suggesting this is NOT the preferred approach due to its tedium.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/wrappers.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n// Naive approach, do NOT use\nimpl Foo {\n    pub fn method_one(..) -> .. {\n        self.0.lock().unwrap().method_one(..)\n    }\n    pub fn method_two(..) -> .. {\n        self.0.lock().unwrap().method_two(..)\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Rust Platform Detection Code for Freezed Enum\nDESCRIPTION: This diff shows how to modify the Rust implementation to match the new freezed enum structure, particularly handling the MacOS case with architecture information as a nested value.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/04-finish.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n     } else if cfg!(target_os = \"ios\") {\n         Platform::Ios\n     } else if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n-        Platform::MacApple\n+        Platform::MacOs(\"Apple Silicon\".into())\n     } else if cfg!(target_os = \"macos\") {\n-        Platform::MacIntel\n+        Platform::MacOs(\"Intel\".into())\n     } else if cfg!(target_family = \"wasm\") {\n         Platform::Wasm\n     } else if cfg!(unix) {\n```\n\n----------------------------------------\n\nTITLE: Configuring Windows Flutter Application Build with CMake\nDESCRIPTION: This CMake snippet sets up a complete build configuration for a Flutter application on Windows. It defines the executable target with all necessary source files, applies standard settings, adds version definitions, configures dependencies, and establishes the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(runner LANGUAGES CXX)\n\n# Define the application target. To change its name, change BINARY_NAME in the\n# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer\n# work.\n#\n# Any new source files that you add to the application should be added here.\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n\n# Apply the standard set of build settings. This can be removed for applications\n# that need different build settings.\napply_standard_settings(${BINARY_NAME})\n\n# Add preprocessor definitions for the build version.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n\n# Disable Windows macros that collide with C++ standard library functions.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n\n# Add dependency libraries and include directories. Add any application-specific\n# dependencies here.\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Wrapper App Static Library\nDESCRIPTION: Defines a static library target for the C++ wrapper components needed by the main application runner. It includes core and app-specific sources, applies standard settings, and links against the `flutter` interface library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# Wrapper sources needed for the runner.\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: This snippet includes a CMake configuration file generated by the Flutter tool. This file likely contains project-specific settings and build configurations provided via the flutter tool, and makes them available to the current CMake file. The `include()` command incorporates the configuration file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Avoiding Async with Blocking Alternatives\nDESCRIPTION: Using blocking alternatives when available, such as reqwest::blocking module, to avoid asynchronous code entirely.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow;\nuse reqwest;\n\nfn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::blocking::get(url)?.text()?;\n    Ok(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Rust HashSet to Dart Set in Flutter-Rust Bridge\nDESCRIPTION: This Rust function accepts a HashSet of Strings. Correspondingly, in Dart, it will be represented as a Set<String> after binding through the Flutter-Rust Bridge. The snippet shows the supported Rust collection type and its Dart equivalent for data interchange.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/map_set.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub fn g(a: HashSet<String>) {}\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: Includes a CMake configuration file generated by the Flutter tool. This file likely contains project-specific settings and dependencies that are required for the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including API module in Rust library\nDESCRIPTION: Modifies the Rust lib.rs file to include the api module with the '+mod api;' directive, enabling the functions defined in 'api.rs' to be part of the library. This setup is necessary for the functions to be accessible for binding generation. No external dependencies are required for this snippet.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_gen.md#_snippet_1\n\nLANGUAGE: Diff\nCODE:\n```\n+mod api;\n```\n\n----------------------------------------\n\nTITLE: Setting Plugin Wrapper Properties\nDESCRIPTION: This snippet sets properties for the plugin wrapper library.  `POSITION_INDEPENDENT_CODE` is set to ON and `CXX_VISIBILITY_PRESET` is set to `hidden`. This helps optimize the code and prevent name collisions in the executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\n```\n\n----------------------------------------\n\nTITLE: Releasing a new version\nDESCRIPTION: This command initiates the release process for a new version of the Flutter Rust Bridge. It's typically executed by the owner to bump versions, update changelog, and check example dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/appendix.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\njust release\n```\n\n----------------------------------------\n\nTITLE: Defining a KitchenSink Enum in Rust\nDESCRIPTION: This code snippet defines a Rust enum called `KitchenSink` with various variants, including `Empty`, `Primitives`, `Nested`, `Optional`, `Buffer`, and `Enums`.  It uses various types like i32, f64, bool, Option, and ZeroCopyBuffer.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/enum.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub enum KitchenSink {\n    Empty,\n    Primitives {\n        /// Dart field comment\n        int32: i32,\n        float64: f64,\n        boolean: bool,\n    },\n    Nested(Box<KitchenSink>),\n    Optional(\n        /// Comment on anonymous field\n        Option<i32>,\n        Option<i32>,\n    ),\n    Buffer(ZeroCopyBuffer<Vec<u8>>),\n    Enums(Weekdays),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining `list_prepend` Helper Function in CMake\nDESCRIPTION: Defines a custom CMake function named `list_prepend`. This function takes a list variable name and a prefix string as arguments, then creates a new list with the prefix added to each element of the original list. It updates the original list variable in the parent scope. This serves as a workaround for `list(TRANSFORM ... PREPEND)` which is unavailable in CMake 3.10.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Serves the same purpose as list(TRANSFORM ... PREPEND ...),\n# which isn't available in 3.10.\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Ignoring Public Struct Method with frb Attribute - Rust\nDESCRIPTION: Illustrates the application of the `#[frb(ignore)]` attribute to a public method defined within an `impl` block for a Rust struct. This technique allows specific methods of a struct to be ignored by flutter_rust_bridge, preventing their exposure to the Dart side, while other methods or the struct itself might still be processed. This requires the method to be part of a struct implementation and the `frb` attribute macro.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/functions/ignoring.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct RandomStruct;\n\nimpl RandomStruct {\n    #[frb(ignore)]\n    pub fn ignored_in_frb() {\n        println!(\"you should not see ignoredInFrb within RandomStruct in dart side.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Android Build Script for Rust Libraries\nDESCRIPTION: A bash script that builds Rust libraries for different Android architectures using cargo-ndk, packages them into a tar archive, and handles setup and cleanup. Supports multiple target architectures including armeabi-v7a, arm64-v8a, x86, and x86_64.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/03-android.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Create the jniLibs build directory\nJNI_DIR=jniLibs\nmkdir -p $JNI_DIR\n\n# Set up cargo-ndk\ncargo install cargo-ndk\nrustup target add \\\n        aarch64-linux-android \\\n        armv7-linux-androideabi \\\n        x86_64-linux-android \\\n        i686-linux-android\n\n# Build the android libraries in the jniLibs directory\ncargo ndk -o $JNI_DIR \\\n        --manifest-path ../Cargo.toml \\\n        -t armeabi-v7a \\\n        -t arm64-v8a \\\n        -t x86 \\\n        -t x86_64 \\\n        build --release \n\n# Archive the dynamic libs\ncd $JNI_DIR\ntar -czvf ../android.tar.gz *\ncd -\n\n# Cleanup\nrm -rf $JNI_DIR\n```\n\n----------------------------------------\n\nTITLE: Illustrative Function Call Across Layers (Dart/Rust)\nDESCRIPTION: This example demonstrates the simplified flow of a function call `f` from Dart to Rust within the Flutter Rust Bridge architecture. It shows the code involved at each layer: the initial user call in Dart, the generated Dart API wrapper, the Dart Wire layer using FFI, the Rust Wire layer handling the C call, and the final user-provided Rust API implementation. Note that the code is adapted for clarity and may not reflect exact implementation details.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/overview.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nprint(f('Hello'));\n```\n\nLANGUAGE: Dart\nCODE:\n```\nvoid f(String arg) => wire_f(codec.encode(arg))\n```\n\nLANGUAGE: Dart\nCODE:\n```\nvoid wire_f(char* ptr, int len); /* extern function */\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn wire_f(ptr: *mut u8, len: i32) { f(codec.decode(ptr, len)) }\n```\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(arg: String) { user_code }\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Functions for Opaque Type Interaction\nDESCRIPTION: Provides examples of Rust functions that operate on the `MyNonEncodableType` struct, showcasing different parameter types (`MyNonEncodableType`, `&MyNonEncodableType`, `&mut MyNonEncodableType`) and return types (`MyNonEncodableType`). These functions are designed to be automatically exposed to Dart using `flutter_rust_bridge`'s `RustAutoOpaque` feature, allowing Dart to interact with the opaque Rust object.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/overview.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub fn create() -> MyNonEncodableType { ... }\n\npub fn consume(obj: MyNonEncodableType) { ... }\n\npub fn borrow(obj: &MyNonEncodableType) { ... }\n\npub fn mutable_borrow(obj: &mut MyNonEncodableType) { ... }\n\nimpl MyNonEncodableType {\n    // Or `self`, `&mut self`\n    pub fn methods_on_it(&self) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories App Wrapper\nDESCRIPTION: This snippet adds the include directories to the `flutter_wrapper_app` to resolve header file paths. These directories are needed for the app wrapper to compile correctly and it ensures the correct include paths. The `PUBLIC` keyword means that users of this library will also get the include directories. It makes available the include directory under wrapper root.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Maybe Enum in Rust\nDESCRIPTION: This code defines a simple Rust enum `Maybe` with two variants: `None` and `Some`.  The `Some` variant contains an i32 value.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/enum.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\npub enum Maybe {\n    None,\n    Some { value: i32 },\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Code for KitchenSink Enum using Freezed\nDESCRIPTION: This code snippet shows the Dart code generated for the `KitchenSink` enum, using the `freezed` library. It demonstrates how the Rust enum variants are translated into Dart factory constructors within a `freezed` class.  The dart code represents the rust data as immutable types.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/enum.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n@freezed\nclass KitchenSink with _$KitchenSink {\n  /// Comment on variant\n  const factory KitchenSink.empty() = Empty;\n  const factory KitchenSink.primitives({\n    /// Dart field comment\n    required int int32,\n    required double float64,\n    required bool boolean,\n  }) = Primitives;\n  const factory KitchenSink.nested(\n    KitchenSink field0,\n  ) = Nested;\n  const factory KitchenSink.optional([\n    /// Comment on anonymous field\n    int? field0,\n    int? field1,\n  ]) = Optional;\n  const factory KitchenSink.buffer(\n    Uint8List field0,\n  ) = Buffer;\n  const factory KitchenSink.enums(\n    Weekdays field0,\n  ) = Enums;\n}\n```\n\n----------------------------------------\n\nTITLE: Makefile Generation Command (Multiple Files, with Class Names)\nDESCRIPTION: Illustrates an improved approach, which specifies a `class-name` for each API file. This is essential to decouple APIs thoroughly from different blocks. However, it's still not perfect and needs `rust-output` to function correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_4\n\nLANGUAGE: makefile\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_1.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_1.dart\" \\\n        --class-name ApiClass1\n\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_2.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_2.dart\" \\\n        --class-name ApiClass2\n...\n```\n\n----------------------------------------\n\nTITLE: Rendering DocCardList React Component in JSX\nDESCRIPTION: This snippet imports the DocCardList component from '@theme/DocCardList' and renders it as a JSX element. It is commonly used within MDX or React documentation pages to display a list of documentation cards dynamically. The only dependency is the '@theme/DocCardList' module, and it requires a React environment with JSX support. There are no input parameters as it is a static render, and the output is the visual list of documentation cards. It assumes the theme component manages internal state or async data fetching as needed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/concurrency/index.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Function for Flutter-Rust Bridge in Rust\nDESCRIPTION: This Rust snippet shows a sample function signature that can be directly called from Dart via the flutter_rust_bridge. The function 'f' accepts a String and a vector of an enum type 'MyEnum' and returns a struct 'MyStruct'. The bridge generates the necessary glue code for seamless calling without manual glue code. The function demonstrates support for arbitrary complex Rust types enabled by the binding generator.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn f(a: String, b: Vec<MyEnum>) -> MyStruct { ... }\n```\n\n----------------------------------------\n\nTITLE: Calling Word Dictionary Methods from Dart using Flutter Rust Bridge\nDESCRIPTION: Demonstrates Dart code that interacts seamlessly with the Rust WordDict methods exposed via Flutter Rust Bridge. It shows asynchronously opening the dictionary with a callback, synchronous property access to the dictionary size, and asynchronously streaming search results with an await-for loop. This example illustrates the integration of asynchronous Rust methods and streams with Dart's async/await and iterable features.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/README.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Installing Plugin Libraries with CMake\nDESCRIPTION: This snippet installs the bundled libraries for each plugin to the installation directory.  The `foreach` loop iterates over all the plugins.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n```\n\n----------------------------------------\n\nTITLE: Makefile Generation Command (Multiple Files, Complete)\nDESCRIPTION: Shows the complete and correct way to generate code for multiple API files with flutter_rust_bridge_codegen. Includes `class-name` to decouple API blocks and `rust-output` to specify the names of the generated Rust files for FFI translation. `llvm_path` is assumed to be a defined variable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_5\n\nLANGUAGE: makefile\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_1.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_1.dart\" \\\n        --class-name ApiClass1 \\\n        --rust-output generated_api_1\n\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_2.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_2.dart\" \\\n        --class-name ApiClass2 \\\n        --rust-output generated_api_2\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Dart Type Names in flutter_rust_bridge.yaml\nDESCRIPTION: A YAML configuration example that demonstrates how to rename Dart types in flutter_rust_bridge. It shows how to map a complex Rust type 'Box<dyn Any + Send + Sync + 'static>' to a custom Dart type name 'MyFancyName' instead of the default 'BoxAny'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/dart-type-rename.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ndart_type_rename:\n    Box<dyn Any + Send + Sync + 'static>: MyFancyName\n```\n\n----------------------------------------\n\nTITLE: Anyhow Result Return in Rust\nDESCRIPTION: This Rust function returns an anyhow::Result<i32>.  When called from Dart, the bail! macro will cause the function to return an error, which is automatically converted into a Dart exception. The anyhow crate provides convenient error handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/return.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub fn f() -> anyhow::Result<i32> { bail!(\"oops I failed\") }\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Settings in CMake\nDESCRIPTION: This configures the project, setting the project name and specifying CXX as a language.  This snippet initializes project-level configurations and sets the project name for the build. The project name is set to \"rust_lib_frb_example_integrate_third_party\".\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"rust_lib_frb_example_integrate_third_party\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Struct with RustAutoOpaque Field for Solution\nDESCRIPTION: Presents a modified Rust struct `A` using `RustAutoOpaque<B>` for its public field `b`. Wrapping the nested opaque type in `RustAutoOpaque` (which is `Arc`-based) is a solution to the cloning caveat, ensuring that accesses refer to the same underlying object.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\npub struct A {\n    pub b: RustAutoOpaque<B>,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Flutter Rust Bridge Codegen with Custom Output\nDESCRIPTION: This command demonstrates how to run flutter_rust_bridge_codegen with a custom output file for the Rust code.  The `--rust-output` flag specifies the desired output path (e.g., `$crate/src/my_bridge.rs`). This is useful for projects that require a specific file naming convention.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/08-finish.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nflutter_rust_bridge_codegen \\\n    ..\n    --rust-output $crate/src/my_bridge.rs\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Structs with Lifetimes for flutter_rust_bridge\nDESCRIPTION: Demonstrates defining opaque Rust structs (`Foo`, `Bar<'a>`) where `Bar` holds a reference with a lifetime ('a) bound to an instance of `Foo`. Includes example method implementations (`compute_bar`, `greet`) that work with these lifetime-bound types. This setup is intended for use with `flutter_rust_bridge`, requiring the `#[frb(opaque)]` attribute.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/type-with-lifetimes.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(opaque)]\npub struct Foo(String);\n\n// For simplicity and demonstration, we use a field pointing to Foo here; but this struct indeed can be anything\n#[frb(opaque)]\npub struct Bar<'a> { foo: &'a Foo }\n\nimpl Foo {\n    pub fn compute_bar<'a>(&'a self) -> Bar<'a> { .. }\n}\n\nimpl Bar<'_> {\n    pub fn greet(&self) { .. }\n}\n```\n\n----------------------------------------\n\nTITLE: Modify Dynamic Library Base Constant in Dart\nDESCRIPTION: This snippet shows the modified Dart code in `lib/ffi.dart`. It updates the `_base` constant from a hardcoded value to a placeholder `$crate`. This placeholder is intended to be replaced with your actual Rust crate name during setup, enabling the Dart code to locate the dynamic library file (`.dll`, `.so`) correctly on Windows, Linux, and other platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/07-usage.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nconst _base = '$crate';\n\n// On MacOS, the dynamic library is not bundled with the binary,\n// but rather directly **linked** against the binary.\nfinal _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';\n```\n\n----------------------------------------\n\nTITLE: Converting Dart String to Native Pointer using FFI - Dart\nDESCRIPTION: This code shows how to convert a Dart String into a native unsigned 8-bit integer list (byte array) pointer to be passed across the FFI boundary, and how to construct a pointer for any Uint8List. It requires the dart:ffi and dart:typed_data packages, as well as an allocator provided by the 'inner' variable. The _api2wire_String function takes a String, encodes it to UTF-8 bytes, and delegates to _api2wire_uint_8_list, which performs memory allocation and copies data to a native memory region, returning an FFI pointer (ffi.Pointer<wire_uint_8_list>). Inputs are Strings or Uint8List, and the output is an FFI pointer suitable for native interop.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/design.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nffi.Pointer<wire_uint_8_list> _api2wire_String(String raw) {\n  return _api2wire_uint_8_list(utf8.encoder.convert(raw));\n}\n\nffi.Pointer<wire_uint_8_list> _api2wire_uint_8_list(Uint8List raw) {\n  final ans = inner.new_uint_8_list_0(raw.length);\n  ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Rust Bridge Plugin with CMake\nDESCRIPTION: This CMake script sets up a Flutter plugin that integrates Rust code using flutter_rust_bridge. It establishes minimum CMake requirements, configures the project, applies Cargokit to build the Rust library, and sets up bundled libraries for the plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_lib_frb_example_rust_ui_counter\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../ rust_lib_frb_example_rust_ui_counter \"\")\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(rust_lib_frb_example_rust_ui_counter_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Finding System Dependencies using PkgConfig in CMake\nDESCRIPTION: Uses CMake's `find_package` command to locate the PkgConfig tool and then employs `pkg_check_modules` to find required system libraries: GTK+ 3.0, GLib 2.0, and GIO 2.0. These libraries are marked as required, and imported targets (`PkgConfig::GTK`, `PkgConfig::GLIB`, `PkgConfig::GIO`) are created for linking.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# System-level dependencies.\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Disabling Default WASM Initialization in Cargo.toml (TOML)\nDESCRIPTION: This Cargo.toml configuration disables the default features for the `flutter_rust_bridge` dependency, specifically the `wasm-start` feature which injects initialization code for panic hook setup. Setting `default-features = false` allows developers to provide their own WASM initialization logic, for example, to configure custom logging libraries. Other necessary features should still be included in the `features` array.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/misc.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nflutter_rust_bridge = { version = \"..\", default-features = false, features = [..] }\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library and Data File Variables\nDESCRIPTION: Sets variables for the Flutter library file, ICU data file, project build directory, and AOT library. These variables are published to the parent scope for use in other parts of the build process, like the install step.  These variables provide easy access to key file paths needed during compilation and deployment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Including Cargokit CMake Script\nDESCRIPTION: Includes the Cargokit CMake script file (`cargokit.cmake`). Cargokit is a tool used to integrate Rust projects into other build systems like CMake, simplifying the process of building and linking Rust code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\n```\n\n----------------------------------------\n\nTITLE: Using tokio::main Macro for Asynchronous Execution\nDESCRIPTION: This snippet utilizes the `tokio::main` macro to turn an async function into a synchronous one, specifically focusing on the `current_thread` flavor. It downloads a file from a given URL. This is a common way to use Tokio, allowing developers to write async code and have Tokio manage the runtime. It depends on `anyhow`, `reqwest`, and `tokio` crates.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse anyhow;\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Bridge Code for Multiple Files (Shell)\nDESCRIPTION: This shell command demonstrates configuring `flutter_rust_bridge_codegen` for multiple Rust API files. It specifies two input Rust files (`--rust-input`), two corresponding Dart output files (`--dart-output`), custom Dart class names (`--class-name`), and custom Rust output module names (`--rust-output`). The command requires the `flutter_rust_bridge_codegen` tool to be installed and accessible.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/multiple_files.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen \\\n  --rust-input \"$REPO_DIR/native/src/api_1.rs\" \"$REPO_DIR/native/src/api_2.rs\" \\\n  --dart-output \"$REPO_DIR/lib/bridge_generated_api_1.dart\" \"$REPO_DIR/lib/bridge_generated_api_2.dart\" \\\n  --class-name ApiClass1 ApiClass2 \\\n  --rust-output generated_api_1 generated_api_2\n```\n\n----------------------------------------\n\nTITLE: Displaying Documentation Card List Using MDX in JavaScript\nDESCRIPTION: This snippet imports a DocCardList component from a theme package and uses it within an MDX file to render a list of documentation cards. The approach relies on a static site generator or documentation platform that supports MDX and the '@theme/DocCardList' component, such as Docusaurus. There are no parameters or dynamic inputs; it simply displays all cards as defined by the documentation structure.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Including Flutter Subprojects and Plugins in CMake Build\nDESCRIPTION: This snippet adds the Flutter-managed directory and runner subdirectory to the CMake build to integrate Flutter engine libraries and application runner source code. Additionally, it includes a generated_plugins.cmake file that manages building and linking Flutter plugins, thereby automating plugin setup within the overall build process. These commands modularize Flutter engine and application components within the project build system.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\nadd_subdirectory(\"runner\")\n\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Modifying Flutter Source for Cross-Origin Headers (Dart)\nDESCRIPTION: This code snippet modifies the Flutter framework to add the necessary cross-origin headers. It involves changing the `devfs_web.dart` file within the Flutter installation. The modification adds `cross-origin-opener-policy` and `cross-origin-embedder-policy` headers to the HTTP server's default response headers. Requires Dart, the Flutter SDK, and access to the Flutter installation directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/02-web-cross-origin.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n    httpServer!.defaultResponseHeaders.remove('x-frame-options', 'SAMEORIGIN');\n \n+    print('Temporary hack Flutter framework to add headers');\n+    httpServer!.defaultResponseHeaders.add('cross-origin-opener-policy', 'same-origin');\n+    httpServer!.defaultResponseHeaders.add('cross-origin-embedder-policy', 'require-corp');\n+\n     final PackageConfig packageConfig = buildInfo.packageConfig;\n```\n\n----------------------------------------\n\nTITLE: Configuring Linker Flags in iOS/macos Podspec for Undefined Symbols\nDESCRIPTION: Adjusts the linker flags in the podspec file to resolve undefined symbols errors by adding necessary libraries like libc++ and frameworks such as SystemConfiguration and AudioToolbox. This ensures proper linkage when building iOS/macOS apps with Rust dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n'OTHER_LDFLAGS' => '-force_load ${BUILT_PRODUCTS_DIR}/librust_lib.a -lc++',\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings (C++)\nDESCRIPTION: This line applies a predefined set of build settings to the executable target. These settings are designed to streamline the build process for common scenarios. This function likely handles compiler flags, include paths, and other configurations to ensure consistent builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Setting Bundled Rust Libraries for Flutter Plugin in CMake\nDESCRIPTION: Defines a list of absolute paths to Rust libraries to be bundled with the Flutter plugin, including the library provided by the cargokit build. This list supports bundling processed or prebuilt binaries and exports the variable to the parent scope for use during plugin packaging.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(rust_lib_flutter_via_create_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Dependencies for Explicit Tokio Runtime Approach\nDESCRIPTION: Required dependencies for using the explicit Tokio runtime creation approach with reqwest.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nfutures = \"0.3\"\nreqwest = \"0.11.6\"\ntokio = { version = \"1.14.0\", features = [\"rt-multi-thread\"] }\nanyhow = { version = \"1.0.49\" }\n```\n\n----------------------------------------\n\nTITLE: Initializing Android NDK Context in MainActivity (Kotlin)\nDESCRIPTION: Modifies the Android `MainActivity.kt` to explicitly load the native Rust library using `System.loadLibrary()` within an `init` block. This ensures the necessary JNI initialization (`JNI_OnLoad`) runs before Dart accesses the library, resolving potential `ndk_context` initialization issues. Replace \"foo\" with the actual name of your native library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_3\n\nLANGUAGE: kotlin\nCODE:\n```\npackage com.example.frontend\n\nimport io.flutter.embedding.android.FlutterActivity\n\n// https://github.com/dart-lang/sdk/issues/46027\nclass MainActivity : FlutterActivity() {\n    // this `init` block, where \"foo\" is the name of your library\n    // ex: if it's libfoo.so, then use \"foo\"\n    init {\n        System.loadLibrary(\"foo\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project and Applying Cargokit Integration for Flutter Rust Bridge in CMake\nDESCRIPTION: Declares a CMake project with C++ language specified, using placeholders for the Dart package name. Includes and applies the Cargokit CMake script to integrate Rust crate building within the Flutter plugin build system. This approach automates Rust library inclusion, requiring the caller to specify correct package and crate names.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(PROJECT_NAME \"REPLACE_ME_DART_PACKAGE_NAME\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../REPLACE_ME_RUST_CRATE_DIR REPLACE_ME_DART_PACKAGE_NAME \"\")\n```\n\n----------------------------------------\n\nTITLE: Finding System Dependencies (GTK, GLIB, GIO)\nDESCRIPTION: This snippet uses `find_package` and `pkg_check_modules` to locate and import system-level dependencies, specifically GTK, GLIB, and GIO.  The `REQUIRED` flag ensures the build fails if the dependencies are not found.  `IMPORTED_TARGET` creates imported targets for each package which can be used later.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Assemble Build Dependency in CMake\nDESCRIPTION: Establishes a build dependency using `add_dependencies`. This command ensures that the `flutter_assemble` target (which is responsible for Flutter-specific build steps like compiling Dart code and bundling assets) must be built successfully before CMake attempts to build the native executable target `${BINARY_NAME}`. This synchronization is essential for a correct Flutter application build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Rust Git Ignore Configuration\nDESCRIPTION: This Rust-specific `.gitignore` file excludes the `Cargo.lock` file and the `target` directory, which contain dependency information and build artifacts, respectively. This helps keep the repository clean and avoids unnecessary commits of generated files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_9\n\nLANGUAGE: gitignore\nCODE:\n```\n# Rust library related\nCargo.lock\ntarget\n```\n\n----------------------------------------\n\nTITLE: Linking Dependencies to Target\nDESCRIPTION: Links the Flutter library and GTK to the executable target as private dependencies. This makes the necessary libraries available during linking.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Executable Target Definition (C++)\nDESCRIPTION: This section defines the executable target for the Flutter application. It adds the executable using `add_executable` and specifies the source files required for building the application. It uses the `BINARY_NAME` variable for the executable's name and includes files such as 'main.cc', 'my_application.cc' and generated plugin registrants. This snippet ties together the application's source code to create an executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Makefile Generation Command (Multiple Files, Initial Attempt)\nDESCRIPTION: Demonstrates the initial, naive approach to generating code for multiple API files.  It creates separate commands for each API file (`api_1.rs`, `api_2.rs`), outputting to distinct Dart files (`bridge_generated_api_1.dart`, `bridge_generated_api_2.dart`).  This method lacks a crucial element: the `class-name` flag.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_3\n\nLANGUAGE: makefile\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_1.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_1.dart\" \\\n\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_2.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_2.dart\" \\\n...\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Wrapper Source Files in CMake\nDESCRIPTION: Defines lists of C++ source files (`CPP_WRAPPER_SOURCES_CORE`, `CPP_WRAPPER_SOURCES_PLUGIN`, `CPP_WRAPPER_SOURCES_APP`) located in the `${WRAPPER_ROOT}` directory. These files constitute the core, plugin-specific, and application-specific parts of the C++ wrapper used to interact with the Flutter engine.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# === Wrapper ===\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Setting ANDROID_NDK in Gradle Properties\nDESCRIPTION: This snippet describes another method to make the Android NDK accessible to Gradle. It suggests creating or modifying the `gradle.properties` file in the `~/.gradle` folder, or within the `android` folder of the project. The user needs to insert the path to the NDK to the property `ANDROID_NDK`. This configuration allows Gradle to locate and use the NDK for building native Android code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial/setup_android.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nANDROID_NDK=(path to NDK)\n```\n\n----------------------------------------\n\nTITLE: Executing the Flutter Rust Bridge Code Generator\nDESCRIPTION: Basic command structure for running the flutter_rust_bridge code generator. Users replace `[OPTIONS]` with specific flags and arguments to configure the code generation process, such as specifying input Rust files, output Dart/C directories, crate directory, and other behavior modifications detailed in the subsequent options list.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/generated/generate.txt#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nflutter_rust_bridge_codegen generate [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Including and applying cargokit for Rust integration in CMakeLists.txt\nDESCRIPTION: Includes the external CMake script located at \"../cargokit/cmake/cargokit.cmake\" and calls the apply_cargokit function to integrate Rust components with the Flutter package. The parameters specify the project name, path to Rust source, and an empty string as additional arguments. This snippet is essential for bundling Rust with the Flutter plugin using custom tooling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../rust flutter_package \"\")\n```\n\n----------------------------------------\n\nTITLE: Mirroring Multiple Structs with Rust\nDESCRIPTION: This snippet illustrates mirroring multiple structs (MessageId, BlobId, and FeedId) with a single mirrored type `Id`.  It shows that by using `#[frb(mirror(MessageId, BlobId, FeedId))]`, it efficiently mirrors those external types.  This simplifies the mirroring process when dealing with related external types.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/external-types.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// *no* need to do these\n#[frb(mirror(MessageId))]\npub struct MId(pub [u8; 32]);\n\n#[frb(mirror(BlobId))]\npub struct BId(pub [u8; 32]);\n\n#[frb(mirror(FeedId))]\npub struct FId(pub [u8; 32]);\n\n// simply do this is sufficient\n#[frb(mirror(MessageId, BlobId, FeedId))]\npub struct Id(pub [u8; 32]);\n```\n\n----------------------------------------\n\nTITLE: Installing AOT Library for Profile/Release Builds\nDESCRIPTION: Installs the Ahead-Of-Time (AOT) compiled Flutter application library (`AOT_LIBRARY`). This installation rule is configured using `CONFIGURATIONS Profile;Release` to only execute for Profile and Release builds, not for Debug builds (which typically use JIT). The AOT library file is copied to the data installation directory (`INSTALL_BUNDLE_DATA_DIR`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\n# Install the AOT library on non-Debug builds only.\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Separating Dart Definitions using flutter_rust_bridge_codegen (Shell)\nDESCRIPTION: This command runs the flutter_rust_bridge code generator, specifying the `--dart-decl-output` flag to generate Dart API definitions into a separate file specified by `<DECL>`. This separates the definitions (e.g., `bridge_definitions.dart`) from the implementation file (e.g., `bridge_generated.dart`), removing `dart:ffi` dependencies from the definitions file. Replace `<DECL>` with the desired path for the declarations file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/misc.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen .. --dart-decl-output <DECL>\n```\n\n----------------------------------------\n\nTITLE: Project-level configuration in CMake\nDESCRIPTION: This snippet sets the project name and specifies that the project uses C++ (CXX) as a language. PROJECT_NAME variable is defined, followed by a call to `project` function.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(PROJECT_NAME \"REPLACE_ME_DART_PACKAGE_NAME\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Build Apple Platforms Bash Script\nDESCRIPTION: This Bash script compiles the Rust library for multiple Apple platforms (iOS, iOS Simulator, and macOS) and creates an XCFramework.  It iterates through target architectures, builds the Rust code, and then uses `lipo` and `xcodebuild` to create a universal framework. It requires `rustup` to be installed and configured with the necessary targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/02-ios-and-macos.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\n#!/bin/bash\n\n# Setup\nBUILD_DIR=platform-build\nmkdir $BUILD_DIR\ncd $BUILD_DIR\n\n# Build static libs\nfor TARGET in \\\n        aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim \\\n        x86_64-apple-darwin aarch64-apple-darwin\ndo\n    rustup target add $TARGET\n    cargo build -r --target=$TARGET\ndone\n\n# Create XCFramework zip\nFRAMEWORK=\"LibraryName.xcframework\"\nLIBNAME=liblibrary_name.a\nmkdir mac-lipo ios-sim-lipo\nIOS_SIM_LIPO=ios-sim-lipo/$LIBNAME\nMAC_LIPO=mac-lipo/$LIBNAME\nlipo -create -output $IOS_SIM_LIPO \\\n        ../target/aarch64-apple-ios-sim/release/$LIBNAME \\\n        ../target/x86_64-apple-ios/release/$LIBNAME\nlipo -create -output $MAC_LIPO \\\n        ../target/aarch64-apple-darwin/release/$LIBNAME \\\n        ../target/x86_64-apple-darwin/release/$LIBNAME\nxcodebuild -create-xcframework \\\n        -library $IOS_SIM_LIPO \\\n        -library $MAC_LIPO \\\n        -library ../target/aarch64-apple-ios/release/$LIBNAME \\\n        -output $FRAMEWORK\nzip -r $FRAMEWORK.zip $FRAMEWORK\n\n# Cleanup\nrm -rf ios-sim-lipo mac-lipo $FRAMEWORK\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Tool Backend Command\nDESCRIPTION: Sets up a custom command to run the Flutter tool backend script which generates necessary files for the Flutter application, ensuring it runs on each build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Native Assets with CMake\nDESCRIPTION: This snippet installs the native assets provided by the Flutter build process from packages to the installation directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Using Futures Executor for Plain Futures\nDESCRIPTION: Simple example showing how to use futures::executor::block_on for running a future that doesn't depend on a specific runtime like Tokio.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::executor::block_on;\n\nasync fn hello_world() -> String {\n    \"hello, world!\".to_string()\n}\n\nfn get() -> String {\n    block_on(async {\n        hello_world().await\n    })\n}\n\nfn main() {\n    println!(\"{}\", get()); // prints \"hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Code with Multiple Blocks using flutter_rust_bridge_codegen\nDESCRIPTION: Command for generating Dart bindings from multiple Rust files using flutter_rust_bridge_codegen. Uses four compulsory flags: rust-input, dart-output, class-name, and rust-output, with consistent field counts for each flag.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/generate_multiple_files.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ngen:\n    export REPO_DIR=\"$PWD\"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \\\n        --rust-input \"$REPO_DIR/native/src/api_1.rs\" \"$REPO_DIR/native/src/api_2.rs\" \\\n        --dart-output \"$REPO_DIR/lib/bridge_generated_api_1.dart\" \"$REPO_DIR/lib/bridge_generated_api_2.dart\" \\\n        --class-name ApiClass1 ApiClass2 \\\n        --rust-output generated_api_1 generated_api_2\n...\n```\n\n----------------------------------------\n\nTITLE: Linking libc++_shared on Android via build.rs (Rust)\nDESCRIPTION: A `build.rs` script that ensures the Rust crate links against the shared C++ standard library (`libc++_shared`) when compiling for Android. This resolves runtime symbol resolution errors (e.g., `__cxa_pure_virtual`) related to C++ standard library functions often encountered when loading the library in a Flutter app.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    #[cfg(target_os = \"android\")]\n    println!(\"cargo:rustc-link-lib=c++_shared\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Flutter Desktop Application Build with CMake\nDESCRIPTION: This snippet sets the basic project-level configurations in CMake to prepare for building a Flutter Windows desktop application. It specifies the minimum required CMake version, project name with C++ language, binary executable name, and adopts modern CMake policies to avoid warnings. It defines build type configurations and sets corresponding compiler and linker flags for Debug, Profile, and Release modes. Unicode support is enabled by defining Unicode macros globally.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(flutter_package_example LANGUAGES CXX)\n\nset(BINARY_NAME \"flutter_package_example\")\n\ncmake_policy(VERSION 3.14...3.25)\n\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Target for Flutter Assembly in CMake\nDESCRIPTION: Adds a custom target named `flutter_assemble`. This target doesn't build anything directly but serves as a dependency hub. It depends on the output files (`FLUTTER_LIBRARY` and `FLUTTER_LIBRARY_HEADERS`) generated by the custom command defined previously. Building the `flutter_assemble` target will trigger the execution of the custom command, thus running the Flutter tool backend.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Structs and Functions with Option Types\nDESCRIPTION: This Rust code defines an `Element` struct with several optional fields (`Option<String>`, `Option<Vec<Attribute>>`, `Option<Vec<Element>>`) and a `parse` function that takes an optional `String` argument and returns an `Option<Element>`. This demonstrates how to represent potentially missing data in Rust using the `Option` enum.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/lang_option.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct Element {\n    pub tag: Option<String>,\n    pub text: Option<String>,\n    pub attributes: Option<Vec<Attribute>>,\n    pub children: Option<Vec<Element>>,\n}\n\npub fn parse(mode: String, document: Option<String>) -> Option<Element> { ... }\n```\n\n----------------------------------------\n\nTITLE: Configuring `rust_input` for Multiple Crate Scanning (YAML)\nDESCRIPTION: This YAML configuration snippet demonstrates how to specify multiple Rust input paths within the `flutter_rust_bridge.yaml` file. It includes the local crate's `api` module (`crate::api`) and an external third-party crate (`interesting_third_party_crate_name`), separated by a comma. This configuration directs the `flutter_rust_bridge` generator to scan both the local API definitions and the specified third-party crate.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/scanning.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrust_input: crate::api,interesting_third_party_crate_name\n```\n\n----------------------------------------\n\nTITLE: Setting bundled libraries for Flutter plugin in CMake\nDESCRIPTION: This snippet defines a list of libraries to be bundled with the Flutter plugin. It uses `set` with `PARENT_SCOPE` to make the variable available in the parent scope, which is crucial for the overall build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(REPLACE_ME_DART_PACKAGE_NAME_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Handler in Rust\nDESCRIPTION: This Rust snippet defines a custom struct `MyErrorHandler` that wraps the default `ReportDartErrorHandler`. It implements the `ErrorHandler` trait, specifically overriding the `handle_error` method. This allows the custom handler to perform additional actions, such as sending errors to a backend, before forwarding the error handling to the default Dart reporter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/handler.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct MyErrorHandler(ReportDartErrorHandler);\n\nimpl ErrorHandler for MyErrorHandler {\n    fn handle_error(&self, port: i64, error: handler::Error) {\n        send_error_to_your_backend(&error);\n        self.0.handle_error(port, error)\n    }\n\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Rust Function for Flutter Integration Using Rust\nDESCRIPTION: Defines a Rust function named 'f' that takes a String parameter 'a' and a vector of 'MyEnum' called 'b', returning an instance of 'MyStruct'. This function is intended to be called from Dart through the bridge without requiring manual bridging code. The exact implementation is elided.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn f(a: String, b: Vec<MyEnum>) -> MyStruct { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding Dependency on Flutter Assembly\nDESCRIPTION: Adds a dependency on the `flutter_assemble` custom target. This ensures that the Flutter library and headers are built before any target that depends on the `flutter` interface library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Loading WebAssembly Module Stub (Dart)\nDESCRIPTION: This Dart function is intended to provide the implementation for loading the FFI library in a web environment, typically involving WebAssembly. As shown, it is currently a placeholder implementation that throws an `UnsupportedError`, indicating that web support is not yet implemented in this specific example configuration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/web.dart\nimport 'package:library_name/library_name.dart';\n\nWasmModule createLibraryImpl() {\n  // TODO add web support. See:\n  // https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter/lib/ffi.web.dart\n  throw UnsupportedError('Web support is not provided yet.');\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings (C++)\nDESCRIPTION: This command applies the standard build settings defined elsewhere in the project. The `apply_standard_settings` command is used to set up the build process. This simplifies build configuration by using a predefined standard configuration for the target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Git Ignore Configuration\nDESCRIPTION: This `.gitignore` file excludes certain directories and files from being tracked by Git. Specifically, it ignores the `Flutter/`, `Runner/`, and `Frameworks/*` directories, but explicitly includes the `.gitkeep` file within the `Frameworks/` directory.  This ensures the directory structure is preserved even if empty.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/02-ios-and-macos.md#_snippet_1\n\nLANGUAGE: gitignore\nCODE:\n```\nFlutter/\nRunner/\nFrameworks/*\n!Frameworks/.gitkeep\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries and Include Directories in CMake\nDESCRIPTION: Links necessary libraries privately to the `${BINARY_NAME}` target. This includes the core Flutter embedding library (`flutter`), the application wrapper library (`flutter_wrapper_app`), and the Windows Desktop Window Manager API library (`dwmapi.lib`) for potential window customization. It also adds the project's source directory (`${CMAKE_SOURCE_DIR}`) to the include paths, allowing the C++ compiler to find header files located there.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Add dependency libraries and include directories. Add any application-specific\n# dependencies here.\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Including Flutter and Plugin Build Rules in CMake (CMake)\nDESCRIPTION: This code includes the Flutter-managed build directory and auto-generated plugin build rules into the project. It adds subdirectories for the Flutter tool and application runner, ensuring integration of Flutter-specific commands and plugin management. This setup keeps Flutter and third-party plugin dependencies seamlessly managed within the build process. Prerequisites include valid Flutter and plugin configuration files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\ninclude(flutter/generated_plugins.cmake)\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Dart Call to Rust Word Dictionary\nDESCRIPTION: This Dart code demonstrates how to call the Rust `WordDict` methods using flutter_rust_bridge. It shows how to open the dictionary, access the `size` property, and iterate through the results of a `search` method, using async/await for asynchronous operations. The `WordDict` class is generated by flutter_rust_bridge.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/README.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Implementing Delayed Processing with RustOpaque in Rust\nDESCRIPTION: Extends the basic RustOpaque example with a function that introduces a delay, useful for demonstrating asynchronous behavior and ownership transitions when functions don't complete immediately.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub use crate::data::HideData; // `pub` for bridge_generated.rs\n\npub fn create_opaque() -> RustOpaque<HideData> {\n    // [`HideData`] has private fields.\n    RustOpaque::new(HideData::new())\n}\n\npub fn run_opaque(opaque: RustOpaque<HideData>) -> String {\n    // RustOpaque impl Deref trait.\n    opaque.hide_data()\n}\n\npub fn run_opaque_with_delay(opaque: RustOpaque<HideData>) -> String {\n    sleep(Duration::from_millis(1000));\n    opaque.hide_data()\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Rust Methods from Dart via flutter_rust_bridge\nDESCRIPTION: Shows how to interact with the Rust `WordDict` API from Dart code generated by `flutter_rust_bridge`. It demonstrates calling the asynchronous `open` method with a callback, accessing the synchronous `size` getter as a property, and iterating over the asynchronous stream returned by the `search` method using `await for`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_utils/README.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nfinal dict = await WordDict.open((situation) => true);\nprint(dict.size);\nawait for (final value in dict.search('something')) { print(value); }\n```\n\n----------------------------------------\n\nTITLE: Defining an External Struct with Methods in Rust\nDESCRIPTION: This snippet defines a Rust struct and implements a method in an external crate. Dependencies include the standard Rust toolchain; no flutter_rust_bridge integration is shown here. The MyExternalStruct struct is created, and a method simple_external_method is attached that returns a String. This code is typically placed in a crate separate from the flutter_rust_bridge integration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/external-methods.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct MyExternalStruct {\n    ...\n}\n\nimpl MyExternalStruct {\n    pub fn simple_external_method(&self) -> String {\n        // ... some long implementations ...\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing and Using DocCardList Component in MDX\nDESCRIPTION: This MDX snippet imports the `DocCardList` component from the Docusaurus theme directory (`@theme/DocCardList`) and then renders it. The `DocCardList` component is typically used to automatically generate a list of cards linking to sub-pages or related documents within the current documentation section.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/lifetimes/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Explicit Zero-Copy Return Type in Rust Function\nDESCRIPTION: Defines a Rust function `draw_tree` that explicitly returns `ZeroCopyBuffer<Vec<u8>>`. This signals `flutter_rust_bridge` to transfer the underlying `Vec<u8>` data to Dart without copying the memory buffer. Note: Zero-copy is not currently supported on Web and falls back to copying.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/zero_copy.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\npub fn draw_tree(tree: Vec<TreeNode>) -> ZeroCopyBuffer<Vec<u8>> { ... }\n```\n\n----------------------------------------\n\nTITLE: Installing flutter_rust_bridge with One Command\nDESCRIPTION: A single command to install flutter_rust_bridge_codegen, create a new project called 'my_app', navigate to the project directory, and run the Flutter application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen create my_app && cd my_app && flutter run\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries and Setting Include Directories\nDESCRIPTION: Links required libraries (flutter, flutter_wrapper_app, and dwmapi.lib) to the executable target and sets the include directories, which specifies where the compiler should search for header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Flutter Plugin Integration (CMake)\nDESCRIPTION: This snippet initializes a CMake project for integrating a Rust library into a Flutter plugin. It requires CMake 3.14 or higher and sets up the project to use C++ as the language. The script includes custom tooling via the cargokit.cmake module and invokes apply_cargokit with project and Rust source paths. Dependencies include an installed Visual Studio with the correct CMake version and the cargokit extension available at a specified path. The script configures bundled libraries for inclusion in the final plugin build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/rust_builder/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# The Flutter tooling requires that developers have a version of Visual Studio\n# installed that includes CMake 3.14 or later. You should not increase this\n# version, as doing so will cause the plugin to fail to compile for some\n# customers of the plugin.\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"rust_lib_flutter_via_integrate\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../../../../../rust rust_lib_flutter_via_integrate \"\")\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(rust_lib_flutter_via_integrate_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Removing Existing Assets Directory\nDESCRIPTION: Removes the existing flutter_assets directory to ensure a clean install of the assets.  It prevents stale asset files during application updates and is performed as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\"\n  \" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Flutter Subdirectory and Dependencies CMake\nDESCRIPTION: Adds the flutter subdirectory, finds system-level dependencies using PkgConfig for GTK, and adds a subdirectory for the runner application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\n# System-level dependencies.\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Installing Native Assets & Flutter Assets\nDESCRIPTION: Installs the native assets provided by the build and the Flutter assets. Native assets are copied to a specific destination. The Flutter assets directory is removed and then copied to ensure it's fresh.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n# Copy the native assets provided by the build.dart from all packages.\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Definition of wire_uint_8_list Struct\nDESCRIPTION: This Rust code snippet defines the `wire_uint_8_list` struct, which is used for passing byte arrays (such as strings) between Dart and Rust using FFI. It contains a pointer `ptr` to the start of the byte array and an integer `len` indicating the length of the array.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/cst-codec.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\npub struct wire_uint_8_list {\n    ptr: *mut u8,\n    len: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Example Rust function calling from Dart without manual intervention\nDESCRIPTION: A simple Rust function with parameters 'a' (String) and 'b' (vector of MyEnum), returning a MyStruct. Demonstrates how to call Rust code directly from Dart using flutter_rust_bridge's generated bindings, enabling seamless interoperation without manual gap-filling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_macros/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(a: String, b: Vec<MyEnum>) -> MyStruct { ... }\n```\n\n----------------------------------------\n\nTITLE: Example Error: `store_dart_post_cobject` Undefined Symbol\nDESCRIPTION: Displays a typical Flutter error message indicating that the `store_dart_post_cobject` symbol could not be found in the compiled Rust library. This usually happens if the generated Rust code was not compiled or linked correctly, often resolved by rerunning `cargo build`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n[ERROR:flutter/lib/ui/ui_dart_state.cc(209)] Unhandled Exception: Invalid argument(s): Failed to lookup symbol 'store_dart_post_cobject': target/debug/libadder.so: undefined symbol: store_dart_post_cobject\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Information in HTML Table\nDESCRIPTION: This HTML snippet displays contributor information within a table. It includes the contributor's avatar, name, and links to their code or documentation contributions on GitHub.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_dart/README.md#_snippet_6\n\nLANGUAGE: HTML\nCODE:\n```\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://gutenfries.deno.dev\"><img src=\"https://avatars.githubusercontent.com/u/79616833?v=4?s=100\" width=\"100px;\" alt=\"Marc Gutenberger\"/><br /><sub><b>Marc Gutenberger</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=gutenfries\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/anstadnik\"><img src=\"https://avatars.githubusercontent.com/u/40110937?v=4?s=100\" width=\"100px;\" alt=\"Andrii Stadnik\"/><br /><sub><b>Andrii Stadnik</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=anstadnik\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Syndim\"><img src=\"https://avatars.githubusercontent.com/u/835035?v=4?s=100\" width=\"100px;\" alt=\"syndim\"/><br /><sub><b>syndim</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=syndim\" title=\"Code\">💻</a></td>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/vhdirk\"><img src=\"https://avatars.githubusercontent.com/u/1424486?v=4?s=100\" width=\"100px;\" alt=\"Dirk Van Haerenborgh\"/><br /><sub><b>Dirk Van Haerenborgh</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=vhdirk\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/akkumar\"><img src=\"https://avatars.githubusercontent.com/u/38454?v=4?s=100\" width=\"100px;\" alt=\"Karthik K\"/><br /><sub><b>Karthik K</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=akkumar\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://rhian-cs.dev\"><img src=\"https://avatars.githubusercontent.com/u/72531802?v=4?s=100\" width=\"100px;\" alt=\"Rhian Moraes\"/><br /><sub><b>Rhian Moraes</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=rhian-cs\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://ares.zone (国内)\"><img src=\"https://avatars.githubusercontent.com/u/40336192?v=4?s=100\" width=\"100px;\" alt=\"Ares Andrew\"/><br /><sub><b>Ares Andrew</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TENX-S\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/CJBuchel\"><img src=\"https://avatars.githubusercontent.com/u/35585061?v=4?s=100\" width=\"100px;\" alt=\"Connor J Buchel\"/><br /><sub><b>Connor J Buchel</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CJBuchel\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CJBuchel\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/polypixeldev\"><img src=\"https://avatars.githubusercontent.com/u/79737178?v=4?s=100\" width=\"100px;\" alt=\"polypixeldev\"/><br /><sub><b>polypixeldev</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=polypixeldev\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/CicadaCinema\"><img src=\"https://avatars.githubusercontent.com/u/52425971?v=4?s=100\" width=\"100px;\" alt=\"CicadaCinema\"/><br /><sub><b>CicadaCinema</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CicadaCinema\" title=\"Code\">💻</a> <a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CicadaCinema\" title=\"Documentation\">📖</a></td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://cosmichorror.dev\"><img src=\"https://avatars.githubusercontent.com/u/30302768?v=4?s=100\" width=\"100px;\" alt=\"CosmicHorror\"/><br /><sub><b>CosmicHorror</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=CosmicHorrorDev\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/akashgurava\"><img src=\"https://avatars.githubusercontent.com/u/13036662?v=4?s=100\" width=\"100px;\" alt=\"Akash Gurava\"/><br /><sub><b>Akash Gurava</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=akashgurava\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.floeschner.de/\"><img src=\"https://avatars.githubusercontent.com/u/12967904?v=4?s=100\" width=\"100px;\" alt=\"Fabian Löschner\"/><br /><sub><b>Fabian Löschner</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=w1th0utnam3\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://matrix.to/#/@vincentherl:matrix.org\"><img src=\"https://avatars.githubusercontent.com/u/5569193?v=4?s=100\" width=\"100px;\" alt=\"Vincent Herlemont\"/><br /><sub><b>Vincent Herlemont</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=vincent-herlemont\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://canxin121.github.io/docs/\"><img src=\"https://avatars.githubusercontent.com/u/69547456?v=4?s=100\" width=\"100px;\" alt=\"canxin\"/><br /><sub><b>canxin</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=canxin121\" title=\"Code\">💻</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/pixelshot91\"><img src=\"https://avatars.githubusercontent.com/u/19229808?v=4?s=100\" width=\"100px;\" alt=\"pixelshot91\"/><br /><sub><b>pixelshot91</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=pixelshot91\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://steinbrecher-bayern.de\"><img src=\"https://avatars.githubusercontent.com/u/6358523?v=4?s=100\" width=\"100px;\" alt=\"TrackerSB\"/><br /><sub><b>TrackerSB</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TrackerSB\" title=\"Code\">💻</a></td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/bubnov\"><img src=\"https://avatars.githubusercontent.com/u/818612?v=4?s=100\" width=\"100px;\" alt=\"Slavik Bubnov\"/><br /><sub><b>Slavik Bubnov</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=bubnov\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/Dampfwalze\"><img src=\"https://avatars.githubusercontent.com/u/46897578?v=4?s=100\" width=\"100px;\" alt=\"Dampfwalze\"/><br /><sub><b>Dampfwalze</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Dampfwalze\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://samuel-cavalcanti.github.io\"><img src=\"https://avatars.githubusercontent.com/u/24573157?v=4?s=100\" width=\"100px;\" alt=\"Samuel Cavalcanti\"/><br /><sub><b>Samuel Cavalcanti</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=samuel-cavalcanti\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://www.zaynetro.com/\"><img src=\"https://avatars.githubusercontent.com/u/627197?v=4?s=100\" width=\"100px;\" alt=\"Roman Zaynetdinov\"/><br /><sub><b>Roman Zaynetdinov</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=zaynetro\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/raphaelrobert\"><img src=\"https://avatars.githubusercontent.com/u/9882746?v=4?s=100\" width=\"100px;\" alt=\"raphaelrobert\"/><br /><sub><b>raphaelrobert</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=raphaelrobert\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/DMouayad\"><img src=\"https://avatars.githubusercontent.com/u/82384138?v=4?s=100\" width=\"100px;\" alt=\"Mouayad Alhamwi\"/><br /><sub><b>Mouayad Alhamwi</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=DMouayad\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/elliotsayes\"><img src=\"https://avatars.githubusercontent.com/u/7699058?v=4?s=100\" width=\"100px;\" alt=\"elliotsayes\"/><br /><sub><b>elliotsayes</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=elliotsayes\" title=\"Documentation\">📖</a></td>\n    </tr>\n    <tr>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://tmpfs.org\"><img src=\"https://avatars.githubusercontent.com/u/238069?v=4?s=100\" width=\"100px;\" alt=\"muji\"/><br /><sub><b>muji</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=tmpfs\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://github.com/thomas725\"><img src=\"https://avatars.githubusercontent.com/u/68635351?v=4?s=100\" width=\"100px;\" alt=\"thomas725\"/><br /><sub><b>thomas725</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=thomas725\" title=\"Documentation\">📖</a></td>\n      <td align=\"center\" valign=\"top\" width=\"14.28%\"><a href=\"https://soeur.dev\"><img src=\"https://avatars.githubusercontent.com/u/26034975?v=4?s=100\" width=\"100px;\" alt=\"orange soeur\"/><br /><sub><b>orange soeur</b></sub></a><br /><a href=\"https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=juzi5201314\" title=\"Documentation\">📖</a></td>\n\n```\n\n----------------------------------------\n\nTITLE: Running Codegen with Explicit LLVM Path on macOS (Shell)\nDESCRIPTION: Shows how to execute the `flutter_rust_bridge_codegen` command on macOS, specifying the LLVM installation path using the `--llvm-path` argument. This is required when the codegen tool fails to locate LLVM automatically, often after installing LLVM via Homebrew.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/troubleshooting.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen --rust-input path/to/your/api.rs --dart-output path/to/file/being/bridge_generated.dart --llvm-path /usr/local/homebrew/opt/llvm/\n```\n\n----------------------------------------\n\nTITLE: Modifying lib.rs for Renamed Rust Bridge Module\nDESCRIPTION: This diff snippet shows the necessary modification to `$crate/src/lib.rs` when the Rust bridge module is renamed. Specifically, the `mod bridge_generated;` line needs to be changed to `mod my_bridge;` to reflect the new module name. The filename should match the filename provided to `--rust-output` in flutter_rust_bridge_codegen.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/08-finish.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n- mod bridge_generated;\n+ mod my_bridge;\n```\n\n----------------------------------------\n\nTITLE: Enabling Unicode Support\nDESCRIPTION: Adds the preprocessor definitions `-DUNICODE` and `-D_UNICODE` globally using `add_definitions`. This is standard practice for Windows development to ensure proper handling of Unicode characters, especially when interacting with the Windows API.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Use Unicode for all projects.\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Defining Platform-Specific FFI Stub (Dart)\nDESCRIPTION: This code defines a stub implementation for the `createLibraryImpl` function. It is used as a fallback or default when no specific platform implementation (like IO or Web) is applicable due to conditional imports. The stub simply throws an `UnimplementedError`, indicating that FFI loading is not available in this context.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi/stub.dart\nObject createLibraryImpl() => throw UnimplementedError();\n```\n\n----------------------------------------\n\nTITLE: Creating a Flutter Interface Library\nDESCRIPTION: Creates an interface library named `flutter` and specifies include directories and link libraries.  This provides a convenient way to group together the necessary dependencies and headers for other targets that depend on Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\n```\n\n----------------------------------------\n\nTITLE: Dart 'Droppable' Class for Safe Resource Release\nDESCRIPTION: Encapsulates resource cleanup logic in Dart, ensuring the internal resource is released exactly once through explicit dispose or garbage collection finalization. This class serves as a base for managing native resources safely.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nclass Droppable {\n  PlatformPointer? _ptr;\n  void dispose() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Assemble Custom Target\nDESCRIPTION: Defines a custom target `flutter_assemble` that depends on the outputs of the custom command executing the Flutter tool backend. This target ensures that the Flutter tool runs and generates required files before other targets (like the wrapper libraries) that depend on it.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: DateTime Type Mappings between Rust and Dart\nDESCRIPTION: Shows the correspondence between Rust's chrono types and Dart's DateTime types. This includes UTC, local timezone, and naive datetime variants, along with Duration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/chrono.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| :crab: Rust       | :dart: Dart                   |\n| -----------       | -----------                   |\n| `DateTime<Utc>`   | `DateTime` *utc*              |\n| `DateTime<Local>` | `DateTime` *local timezone*   |\n| `NaiveDateTime`   | `DateTime` *utc assumed*      |\n| `Duration`        | `Duration`                    |\n```\n\n----------------------------------------\n\nTITLE: Generating Flutter-Rust Bridge Bindings via Shell\nDESCRIPTION: Generates the bridge code after modifying Rust source files to reflect changes. It then runs the Flutter app to see updates. This step assumes prior setup of flutter_rust_bridge_codegen.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_rust/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen generate && flutter run\n```\n\n----------------------------------------\n\nTITLE: Set Fallback Flutter Target Platform\nDESCRIPTION: Provides a fallback value for the `FLUTTER_TARGET_PLATFORM` variable if it hasn't been defined by the included configuration. This ensures a default platform is set, typically for Windows builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Set fallback configurations for older versions of the flutter tool.\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Illustrating Proxy Mechanism via Method Forwarding in Rust\nDESCRIPTION: Conceptually shows how `#[frb(proxy)]` might work under the hood. Instead of returning a reference, methods like `my_method_one` from the proxied type (`AudioParam`) are effectively generated directly on the parent struct (`BiquadFilterNode`) (e.g., as `frequency_my_method_one`), forwarding the call to the inner field.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/proxy.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl BiquadFilterNode {\n    pub fn frequency_my_method_one(&self, value: f32) {\n        self.frequency.my_method_one(value)\n    }\n\n    pub fn frequency_my_method_two(&self, value: f32) {\n        self.frequency.my_method_two(value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Rust Runtime Dependency (TOML/Diff)\nDESCRIPTION: Specifies the required `flutter_rust_bridge` runtime crate dependency within the `[dependencies]` section of the Rust project's `Cargo.toml` file. Version \"1\" is specified in this example.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/deps.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n+[dependencies]\n+flutter_rust_bridge = \"1\"\n```\n\n----------------------------------------\n\nTITLE: Blocking Async Code with futures::executor\nDESCRIPTION: This code attempts to run the asynchronous `get` function within a synchronous context using `futures::executor::block_on`. The purpose is to demonstrate the usage of `block_on` to convert async code to sync. It attempts to download a file from a given URL. This will result in an error since Reqwest is designed to work with Tokio runtime. This code also needs `anyhow`, `futures`, and `reqwest` crate to work.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rust,ignore\nuse anyhow;\nuse futures::executor::block_on;\n\nfn get() -> anyhow::Result<String> {\n    block_on(async {\n        let url = \"https://link/to/file/download\";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Application and Dependencies in CMake\nDESCRIPTION: Defines rules to install the application executable and its runtime dependencies into the configured installation directories. This includes the main executable, ICU data file, Flutter library, bundled plugin libraries (if any), native assets generated by build.dart scripts, Flutter assets (ensuring stale assets are removed first), and the AOT (Ahead-Of-Time) compiled library for Profile and Release builds.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n\n# Copy the native assets provided by the build.dart from all packages.\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\n# Install the AOT library on non-Debug builds only.\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Defining Bundled Libraries in CMake\nDESCRIPTION: This defines a list of libraries to bundle with the Flutter plugin.  The `rust_lib_frb_example_integrate_third_party_bundled_libraries` variable stores the absolute paths of libraries to be included in the plugin. It utilizes the output of cargokit. The PARENT_SCOPE ensures that the variable is accessible outside the current scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/rust_builder/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(rust_lib_frb_example_integrate_third_party_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Flutter Library Headers\nDESCRIPTION: Defines the list of Flutter library headers and prepends the path to each header using the previously defined list_prepend function.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\n```\n\n----------------------------------------\n\nTITLE: Recursive struct example (Dart)\nDESCRIPTION: This is the Dart representation of the `MyTreeNode` struct from the previous Rust example. The `value` is translated to `Uint8List`, and the `children` field remains a list of `MyTreeNode` instances. The Dart class is generated with a constructor that requires both `value` and `children`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/detailed/struct.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nclass MyTreeNode {\n  final Uint8List value;\n  final List<MyTreeNode> children;\n  MyTreeNode({required this.value, required this.children});\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Application Source Files\nDESCRIPTION: This snippet adds source files to the executable target defined by BINARY_NAME, including main.cpp, my_application.cpp, and a generated plugin registrant file. It ensures all necessary source files are compiled to produce the application binary.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Function Accepting Dart Closure - Rust\nDESCRIPTION: This Rust snippet defines a function that accepts a Dart callback closure taking a String argument and returning a String. The function calls the callback with the string \"Tom\", demonstrating a simple synchronous call from Rust to Dart. This requires the Dart callback to be compatible with Rust's Fn trait with a String parameter and String return type.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/rust-call-dart.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn rust_function(dart_callback: Fn(String) -> String) {\n    dart_callback(\"Tom\"); // Will get `Hello, Tom!`\n}\n```\n\n----------------------------------------\n\nTITLE: Dart 'RustArc' Class for Managing Rust's Arc Pointer\nDESCRIPTION: Implements a Dart class that mirrors Rust's std::sync::Arc, providing clone and raw pointer transfer capabilities. It ensures proper reference counting and resource deallocation, extending Droppable for safety.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/rust-opaque.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass RustArc extends Droppable {\n  RustArc clone() { ... }\n  RustArc.fromRaw({int ptr}) { ... }\n  PlatformPointer intoRaw() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining bundled libraries for Flutter plugin in CMakeLists.txt\nDESCRIPTION: Sets a list variable named flutter_package_bundled_libraries containing paths to libraries that should be bundled with the Flutter plugin. It includes the cargokit-generated library variable, and marks this variable with PARENT_SCOPE so it is accessible in the parent CMake context. This snippet manages linking external or prebuilt libraries required by the plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(flutter_package_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Overriding Trait Definition Methods Attributes in Rust\nDESCRIPTION: Shows how to apply attributes on trait methods from a third-party trait by defining an external implementation block behind the #[frb(external)] attribute and marking individual methods with #[frb(sync)]. This enables synchronous Dart interoperability while keeping the original method signatures implicit (without arguments or return types) and does not require modifying the third-party source.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/automatic/override-attributes.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[frb(external)]\nimpl SomeTrait {\n    #[frb(sync)]\n    pub fn method() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Project and Binary Name in CMake\nDESCRIPTION: Sets the minimum required CMake version, declares the project name ('flutter_via_create') and language (CXX), defines the output executable name, and opts into modern CMake policies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\n# Project-level configuration.\ncMAKE_MINIMUM_REQUIRED(VERSION 3.14)\nproject(flutter_via_create LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"flutter_via_create\")\n\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(VERSION 3.14...3.25)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Cross-Building\nDESCRIPTION: This snippet configures CMake for cross-building. It sets the CMAKE_SYSROOT and CMAKE_FIND_ROOT_PATH based on the FLUTTER_TARGET_PLATFORM_SYSROOT. It also sets the search modes for programs, packages, libraries, and includes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(FLUTTER_TARGET_PLATFORM_SYSROOT)\n  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup (C++)\nDESCRIPTION: This snippet sets up the minimum required CMake version and defines the project name. It initializes the project using the `project` command, specifying the project name 'runner' and declaring CXX as the language. This sets the foundation for defining the application's build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Encoder/Decoder Functions in Rust\nDESCRIPTION: Example of how to define custom encoder and decoder functions using frb attribute macros. These functions specify how to convert between Rust types and Dart types through an intermediate representation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/custom.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[frb(rust2dart(dart_type = \"FancyDartType\", dart_code = \"FancyDartType.letsParseIt({})\"))]\npub fn encode_fancy_type(raw: FancyRustType) -> String { ... }\n\n#[frb(dart2rust(dart_type = \"FancyDartType\", dart_code = \"{}.letsEncodeIt()\"))]\npub fn decode_fancy_type(raw: String) -> FancyRustType { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories Plugin Wrapper\nDESCRIPTION: This snippet adds include directories to the `flutter_wrapper_plugin` to make header files available for the plugin wrapper code.  The `PUBLIC` keyword means that users of this library will also get the include directories. It makes available the include directory under wrapper root.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Class with Inserted Custom Method - Dart\nDESCRIPTION: This Dart code snippet illustrates the automatically generated Dart class that contains both standard auto-generated fields and an extra method (extraMethod) injected via the flutter_rust_bridge #[frb(dart_code)] annotation in the original Rust. This code requires the flutter_rust_bridge build output and assumes a corresponding Rust struct with identical naming. Inputs are defined by the Rust code and the dart_code string, resulting in a Dart class with enhanced functionality; constraints dictate that only valid class-member code can be inserted.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/dart-code.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nclass MyStruct {\n  ... // other auto-generated code\n  \n  int extraMethod() => a * 2; // The extra code\n}\n```\n\n----------------------------------------\n\nTITLE: Define Flutter Interface Library Target\nDESCRIPTION: Defines a CMake interface library target named `flutter`. Interface libraries don't build sources but specify include directories and linked libraries. This target represents the dependencies needed to build against the Flutter engine library.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Managing System Dependencies and Linking Packages in CMake (CMake)\nDESCRIPTION: This snippet locates and configures system-level dependencies using pkg-config, specifically ensuring GTK+ 3.0 is imported and available to the build system. The sequence verifies the existence of dependencies and sets them up for linking, which is required for building graphical interfaces with Flutter on Linux. Required packages include pkg-config and GTK development libraries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n```\n\n----------------------------------------\n\nTITLE: Adding Preprocessor Definitions (C++)\nDESCRIPTION: This adds a preprocessor definition for the application ID. The -D flag defines a preprocessor macro.  The ${APPLICATION_ID} variable likely holds the application identifier, which is then used in the source code. This is often used for conditional compilation or to pass configuration parameters to the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Including Flutter Generated Plugin Rules\nDESCRIPTION: Includes the `flutter/generated_plugins.cmake` file using the `include` command. This file is automatically generated by the Flutter build tooling and contains necessary CMake commands to find, build, and link any native plugins used by the Flutter application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Configuring Bundled Libraries for Flutter Rust Bridge Plugin in CMake\nDESCRIPTION: Defines a variable holding absolute paths to libraries bundled with the Flutter Rust Bridge plugin. It includes the Rust library generated by Cargokit and exports this variable to the parent scope, facilitating linkage in higher-level build scripts or packaging processes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(REPLACE_ME_DART_PACKAGE_NAME_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories (C++)\nDESCRIPTION: This part adds the necessary include directories.  The `target_include_directories` command adds the current source directory (`CMAKE_SOURCE_DIR`) to the include search path for the target `BINARY_NAME`. This enables the application to include headers from the specified directory during compilation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Generating WASM code with flutter_rust_bridge_codegen (Shell)\nDESCRIPTION: This command instructs flutter_rust_bridge_codegen to generate WASM-specific code. The `--wasm` flag is crucial for creating the necessary files for web browser compatibility.  This will create separate .io and .web files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/wasm.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nflutter_rust_bridge_codegen .. --wasm\n```\n\n----------------------------------------\n\nTITLE: Include and apply Cargokit\nDESCRIPTION: Includes the Cargokit CMake module, which provides tools and functions for integrating Rust code into the build process.  It then applies Cargokit with the project name, Rust source directory, and Rust library name specified.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/rust_builder/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../rust rust_lib \"\")\n```\n\n----------------------------------------\n\nTITLE: Define Opaque Struct B (Rust)\nDESCRIPTION: This code defines a struct `B` which is considered opaque. The `...` indicates that its internal structure is not relevant for this context, implying it may contain fields or data that are not directly translatable or accessible from Flutter.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/opaque-in-translatable.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct B { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining List Prepend Function\nDESCRIPTION: Defines a CMake function `list_prepend` to prepend a given prefix to each element of a list. It iterates through the list, adds the prefix to each element, and updates the original list in the parent scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Set bundled libraries\nDESCRIPTION: Defines a list of libraries to bundle with the plugin. This list includes the output from the cargokit build process. The libraries are added to the `rust_lib_flutter_via_integrate_bundled_libraries` variable with PARENT_SCOPE so that they're accessible to parent CMake projects.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/rust_builder/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(rust_lib_flutter_via_integrate_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Executing Flutter Rust Bridge Command\nDESCRIPTION: This snippet shows a shell command that installs the `flutter_rust_bridge_codegen` tool, creates a new project named `my_app`, navigates into the project directory and then runs the Flutter application. The command efficiently sets up a working Flutter and Rust application ready for use.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install flutter_rust_bridge_codegen && flutter_rust_bridge_codegen create my_app && cd my_app && flutter run\n```\n\n----------------------------------------\n\nTITLE: Setting Runtime Output Directory\nDESCRIPTION: Sets the runtime output directory for the executable, placing it in a subdirectory to prevent accidental execution of the unbundled copy. This ensures that only the installed bundle is run.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${BINARY_NAME}\n  PROPERTIES\n  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/intermediates_do_not_run\"\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Properties with CMake\nDESCRIPTION: This snippet sets the RUNTIME_OUTPUT_DIRECTORY property of the executable target. It places the executable in a subdirectory to avoid confusion with the bundled copy.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${BINARY_NAME}\n  PROPERTIES\n  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/intermediates_do_not_run\"\n)\n```\n\n----------------------------------------\n\nTITLE: Missing Dispose Call on Native Platforms in Dart\nDESCRIPTION: Explains the behavior when dispose() is not called on native platforms. The finalizer helps prevent memory leaks, but it's important to understand the guarantees and limitations of automatic cleanup.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/rust_opaque_type_safety.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n// (Arc counter = 1) Dart has full ownership.\nvar opaque = await api.createOpaque();\n\n// (Arc counter = 2) increases immediately. \nString hideData = await api.runOpaque(opaque);\n\n// (Arc counter = 1)\n//\n// Rust:\n//\n// `executes rust_call_example and counter decreases.`\n\n// memory of opaque types is not monitoring by dart and can accumulate.\n// (Arc counter = 0) \n// opaque type is dropped (deallocated)\n// \n// Dart:\n//\n// `the finalizer is guaranteed to be called before the program terminates.`\n```\n\n----------------------------------------\n\nTITLE: Defining Bundled Libraries\nDESCRIPTION: Sets a CMake variable (`REPLACE_ME_RUST_CRATE_NAME_bundled_libraries`) to a list of libraries that should be bundled with the plugin. It includes the library built by Cargokit (`${PROJECT_NAME}_cargokit_lib`). `PARENT_SCOPE` makes the variable available in the calling scope.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(REPLACE_ME_RUST_CRATE_NAME_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter Assets Directory\nDESCRIPTION: Installs the application's Flutter assets (images, fonts, etc.). It first uses `install(CODE ...)` to execute a CMake `file(REMOVE_RECURSE ...)` command, ensuring any previously installed assets directory at the destination (`INSTALL_BUNDLE_DATA_DIR/flutter_assets`) is removed to prevent stale files. Then, it uses `install(DIRECTORY ...)` to copy the `flutter_assets` directory from the project build directory to the data installation directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Rust Cargo.toml Configuration\nDESCRIPTION: This snippet configures the Rust package. It sets the package name, version, and edition. It defines the crate type as a static library and a dynamically linked C library.  It also specifies dependencies on `flutter_rust_bridge` and `flutter_rust_bridge_codegen`, pinning them to version 1.62.*\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"$LIBNAME\"\nversion = \"0.0.0\"\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"staticlib\", \"cdylib\"]\n\n[build-dependencies]\nflutter_rust_bridge_codegen = \"1.62.*\"\n\n[dependencies]\nflutter_rust_bridge = \"1.62.*\"\n```\n\n----------------------------------------\n\nTITLE: Generated Dart Accessors for Opaque Rust Struct Field\nDESCRIPTION: Demonstrates the Dart code automatically generated by flutter_rust_bridge for the public field (`name`) of an opaque Rust struct like `MyOpaqueType`. This code creates a getter and setter, making the Rust field accessible as a Dart property.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/rust-auto-opaque/properties.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\n// Auto-generated class\nclass MyOpaqueType {\n    String get name => ...;\n    set name(String value) => ...;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing C++ Flutter plugin project in CMakeLists.txt\nDESCRIPTION: Defines the project name as \"flutter_package\" and sets the language for the project to C++ (CXX). This establishes the context for the ensuing build steps and ensures that the project is treated as a C++ project within CMake.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"flutter_package\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Configuring build.gradle for Android Integration\nDESCRIPTION: This Gradle configuration sets up the Android build parameters and triggers the binary download process via CMakeLists.txt. It specifies SDK requirements and external native build settings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/03-platform-setup/03-android.md#_snippet_1\n\nLANGUAGE: gradle\nCODE:\n```\nandroid {\n    compileSdkVersion 31\n\n    defaultConfig {\n        minSdkVersion 16\n    }\n\n    // Trigger the binary download/update over in CMakeLists.txt\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Flutter Library Dependencies\nDESCRIPTION: This snippet links the Flutter library to the `flutter` interface library, ensuring that dependencies are linked. It uses the `.lib` file for the Windows platform. The `INTERFACE` keyword indicates the dependencies are propagated to other targets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\n```\n\n----------------------------------------\n\nTITLE: Cloning the Example Repository (Shell)\nDESCRIPTION: This shell command clones the flutter_rust_bridge repository from GitHub and changes the current directory to the example project folder `frb_example/with_flutter`. This is the first step to get the necessary code for the tutorial. Requires git to be installed.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/tutorial_with_flutter.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/fzyzcjy/flutter_rust_bridge && cd flutter_rust_bridge/frb_example/with_flutter\n```\n\n----------------------------------------\n\nTITLE: Address Firefox Cross-Origin Request Restrictions\nDESCRIPTION: Notes that 'flutter_rust_bridge_serve' may not work on Firefox due to strict cross-origin policies, recommending using Chromium for testing and providing a link to enable crossOriginIsolated in production environments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Displaying How-to Guide List using DocCardList in MDX\nDESCRIPTION: Imports the DocCardList component from the Docusaurus theme and renders it to display a list of available how-to guides. This is a common pattern in Docusaurus documentation sites for creating navigation pages.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Interface Library\nDESCRIPTION: Creates an interface library named `flutter` and sets its include directories and link libraries. The interface library allows other targets to link against the Flutter library and its dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries and Including Directories\nDESCRIPTION: This section links the necessary libraries and includes directories for the Flutter runner application.  It includes Flutter-specific libraries, Windows dependencies (e.g., `dwmapi.lib`), and the source directory. This establishes the dependencies of the executable.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Target for Flutter Assemble\nDESCRIPTION: Adds a custom target named `flutter_assemble` that depends on the Flutter library and headers. This target ensures that the Flutter library and headers are built before any other target that depends on them.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Flutter Assembly\nDESCRIPTION: Adds a custom target `flutter_assemble` that depends on the Flutter library and headers. This target ensures that the custom command for assembling the Flutter components is executed before any target that depends on `flutter_assemble`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a List Prepend Function\nDESCRIPTION: Defines a CMake function to prepend a prefix to each element in a list. This function emulates the `list(TRANSFORM ... PREPEND ...)` command which is unavailable in CMake 3.10, and prepends a prefix to each element of the specified list.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Passing and Retrieving Dart Opaque Types in Rust\nDESCRIPTION: This Rust code defines two functions: `put_dart_opaque` takes a `DartOpaque` as input, presumably for storing it. `get_dart_opaque` retrieves a `DartOpaque`. This facilitates passing Dart objects, such as closures, to the Rust world for processing or storage and retrieving them back.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/arbitrary/dart-opaque.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn put_dart_opaque(a: DartOpaque) { ... }\npub fn get_dart_opaque() -> DartOpaque { ... }\n```\n\n----------------------------------------\n\nTITLE: Adding Definitions with CMake\nDESCRIPTION: This snippet adds a definition to the compiler to define the APPLICATION_ID. This allows the application to access the application ID at compile time.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Defining AutoDrop Dart Persistent Handle in Rust\nDESCRIPTION: Defines a Rust struct `AutoDropDartPersistentHandle` that wraps a `Dart_PersistentHandle`. The `Drop` trait is implemented to ensure the persistent handle is properly released when the struct is dropped, preventing resource leaks. This is fundamental for managing the lifecycle of Dart handles safely from Rust.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dart-opaque.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct AutoDropDartPersistentHandle(Dart_PersistentHandle);\nimpl Drop for AutoDropDartPersistentHandle { ... }\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset and Bundle Installation - CMake\nDESCRIPTION: This snippet specifies how the application bundle, dependencies, and assets are installed using CMake’s install commands. It handles setting output directories, removing stale asset directories before installation, copying runtime libraries, Flutter library files, plugin libraries, and assets to the correct locations. It also handles AOT library installation for non-debug builds. It requires all relevant file and directory variables to be defined and ensures the installed bundle contains everything needed for execution.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\")\n  \" COMPONENT Runtime)\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/linux/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Subdirectory with CMake\nDESCRIPTION: This snippet adds the Flutter managed directory as a subdirectory, allowing CMake to process the Flutter-related build files. It assumes that the Flutter files are located in a directory named \"flutter\".\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Installing AOT library\nDESCRIPTION: Installs the AOT library, but only for non-Debug builds (Profile and Release).  This ensures that the AOT library is included in the appropriate build configurations for optimized deployments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings\nDESCRIPTION: This function call applies a predefined set of build settings to the executable target.  It provides a standard configuration for the build process. If specific build settings are required, the call can be removed and customized.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Adding a Dependency on Flutter Assemble\nDESCRIPTION: Adds a dependency from the `flutter` interface library to the `flutter_assemble` custom target. This ensures that the Flutter library and headers are assembled before any target that depends on the `flutter` library is built.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Environment and Variables\nDESCRIPTION: Sets the minimum required CMake version to 3.10 and defines the `EPHEMERAL_DIR` variable pointing to a directory containing generated build files within the current source directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet specifies the minimum required CMake version for the project. It sets the foundation for the build process by ensuring that the installed CMake version is compatible with the project's requirements.  This is essential for building the flutter application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: CMake Generated Plugin Inclusion\nDESCRIPTION: This includes the `generated_plugins.cmake` file, which manages the building and integration of Flutter plugins into the application. This step is essential for integrating external Flutter plugins.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Combining Platform FFI Implementations (Dart)\nDESCRIPTION: This central Dart file (e.g., `lib/src/ffi.dart`) orchestrates the loading of the platform-specific FFI implementation. It uses Dart's conditional imports (`if (dart.library.io)`, `if (dart.library.js_interop)`) to select the appropriate `createLibraryImpl` function based on the build target. It then calls this selected function and passes the result to the FRB-generated `createWrapper` function to get the final bridge instance.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n// lib/src/ffi.dart\nimport 'package:library_name/library_name.dart';\nimport 'ffi/stub.dart'\n    if (dart.library.io) 'ffi/io.dart'\n    if (dart.library.js_interop) 'ffi/web.dart';\n\nLibraryName createLib() =>\n    createWrapper(createLibraryImpl());\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter Assets with CMake\nDESCRIPTION: This snippet installs the flutter assets. It first removes stale assets, and then copies the new assets from the build directory. A `CODE` install type is used to remove the assets.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Avoid Conflicts with Types Named 'Kind' in Rust and Dart\nDESCRIPTION: Advises avoiding the use of 'Kind' as a suffix in Rust type names to prevent conflicts with generated Dart types when importing from 'bridge_definitions.dart' and 'bridge_generated.io.dart'.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Prepending Ephemeral Directory to Headers\nDESCRIPTION: Prepends the `EPHEMERAL_DIR`/flutter_linux/ path to the `FLUTTER_LIBRARY_HEADERS` variable using the `list_prepend` function. This ensures that the compiler can find the header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Assemble Dependency\nDESCRIPTION: This snippet adds a dependency to `flutter_assemble`, a custom target that builds the Flutter application. This ensures that `flutter_assemble` runs before any target that uses the `flutter` library. It provides the ordering.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Finding System Dependencies\nDESCRIPTION: Uses `pkg_check_modules` to find system-level dependencies like GTK, GLib, and GIO. These dependencies are essential for the Flutter Linux environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Directories and Behavior\nDESCRIPTION: Sets up parameters for the installation process. It defines the `BUILD_BUNDLE_DIR` based on the output directory of the main executable, forces the `CMAKE_INSTALL_PREFIX` to this directory for in-place running, enables automatic installation after builds in Visual Studio via `CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD`, and defines variables for subdirectories (`data`, `lib`) within the install prefix.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# === Installation ===\n# Support files are copied into place next to the executable, so that it can\n# run in place. This is done instead of making a separate bundle (as on Linux)\n# so that building and running from within Visual Studio will work.\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\n# Make the \"install\" step default, as it's required to run.\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n```\n\n----------------------------------------\n\nTITLE: Flutter Tool and Output Directory CMake\nDESCRIPTION: Adds a dependency on flutter_assemble and sets the runtime output directory to an intermediate directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n\n# Only the install-generated bundle's copy of the executable will launch\n# correctly, since the resources must in the right relative locations. To avoid\n# people trying to run the unbundled copy, put it in a subdirectory instead of\n# the default top-level location.\nset_target_properties(${BINARY_NAME}\n  PROPERTIES\n  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/intermediates_do_not_run\"\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Installation Configuration\nDESCRIPTION: This configures the installation process, specifying where to copy build artifacts. It sets the install location, defines installation directories, and sets up installation for the executable and other necessary components. The install step is made default to run, allowing for quick runs.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# === Installation ===\n# Support files are copied into place next to the executable, so that it can\n# run in place. This is done instead of making a separate bundle (as on Linux)\n# so that building and running from within Visual Studio will work.\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\n# Make the \"install\" step default, as it's required to run.\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n\n# Copy the native assets provided by the build.dart from all packages.\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\n# Install the AOT library on non-Debug builds only.\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Code Generator Pipeline Flowchart in Mermaid\nDESCRIPTION: A Mermaid flowchart illustrating the pipeline of the code generator, showing how the user-provided Rust code is parsed into an internal representation and then generated into Rust and Dart output code.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/contributing/design.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\napi.rs -- src/parser --> src/ir\nsrc/ir -- src/generator --> rd[Rust & Dart]\n```\n\n----------------------------------------\n\nTITLE: Prepending Headers Directory\nDESCRIPTION: This snippet prepends the `EPHEMERAL_DIR` path to the header file names. This ensures that the compiler can find the header files. The `TRANSFORM` command prepends the directory path.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\n```\n\n----------------------------------------\n\nTITLE: Print uncaught exceptions with stack traces in Flutter web - Dart\nDESCRIPTION: This Dart code snippet sets up global error handlers that capture and print all uncaught asynchronous and synchronous errors along with their stack traces in Flutter web applications, addressing missing stack trace issues especially in Safari. It overrides FlutterError.onError and PlatformDispatcher.instance.onError, and uses runZonedGuarded to wrap the main application code. Replace YOUR_ORIGINAL_CODE_HERE with the actual main execution logic. This snippet depends on Flutter's error handling APIs and requires running within a Flutter environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/tip.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nFuture<void> main() async {\n  FlutterError.onError = (details) {\n    FlutterError.presentError(details);\n    print('FlutterError.onError $details');\n  };\n  PlatformDispatcher.instance.onError = (error, stack) {\n    print('PlatformDispatcher.instance.onError $error $stack');\n    return true;\n  };\n  await runZonedGuarded(\n    () async {\n      YOUR_ORIGINAL_CODE_HERE;\n    },\n    (error, stackTrace) => print('runZonedGuarded error $error $stackTrace'),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Installation Paths\nDESCRIPTION: Sets up installation paths and rules for deploying the built application. It sets the build bundle directory and the install prefix. The installation process includes the executable, necessary data, and other dependencies. The CMAKE_INSTALL_PREFIX is also set.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\n# Make the \"install\" step default, as it's required to run.\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n```\n\n----------------------------------------\n\nTITLE: Standard Settings for Compilation CMake\nDESCRIPTION: Defines a function APPLY_STANDARD_SETTINGS to set compilation features, options and definitions for a target, using the cxx_std_14 standard, and setting warnings and optimization/debugging flags.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Compilation settings that should be applied to most targets.\n#\n# Be cautious about adding new options here, as plugins use this function by\n# default. In most cases, you should add new options to specific targets instead\n# of modifying this function.\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Setting Application ID Definition\nDESCRIPTION: This snippet adds a preprocessor definition for the application ID using add_definitions, injecting the value of APPLICATION_ID. This allows conditional compilation or configuration based on the specified application identifier.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Prepending Core Wrapper Sources Directory\nDESCRIPTION: This snippet prepends the `WRAPPER_ROOT` directory to the core wrapper source file names.  It constructs the full path to the source files. The `TRANSFORM` command prepends the directory path.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Listing Flutter Library Headers and Includes\nDESCRIPTION: This section defines and configures the necessary header files and include directories for the Flutter library.  The `FLUTTER_LIBRARY_HEADERS` list is populated with the necessary header files and the `TRANSFORM` command prepends the ephemeral directory to the header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Installing Native Assets\nDESCRIPTION: Installs native assets generated by Dart's build process (e.g., `build.dart` scripts in dependencies). It sets the `NATIVE_ASSETS_DIR` variable pointing to the expected location within the build directory (`PROJECT_BUILD_DIR`) and then uses `install(DIRECTORY ...)` to copy the contents of this directory to the library installation directory (`INSTALL_BUNDLE_LIB_DIR`).\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\n# Copy the native assets provided by the build.dart from all packages.\nset(NATIVE_ASSETS_DIR \"${PROJECT_BUILD_DIR}native_assets/windows/\")\ninstall(DIRECTORY \"${NATIVE_ASSETS_DIR}\"\n   DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n   COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project Name\nDESCRIPTION: Sets the `PROJECT_NAME` variable to a placeholder (`\"REPLACE_ME_RUST_CRATE_NAME\"`). This variable is then used by the `project()` command and other parts of the build script.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"REPLACE_ME_RUST_CRATE_NAME\")\n```\n\n----------------------------------------\n\nTITLE: Project setup and language definition\nDESCRIPTION: Defines the project name and specifies that the project uses C++ as a language. This is necessary for CMake to properly configure the build environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/rust_builder/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"rust_builder\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Adding Rust Dependencies\nDESCRIPTION: This snippet demonstrates how to add the `flutter_rust_bridge` dependency to the `Cargo.toml` file of a Rust project. The core dependency is `flutter_rust_bridge`, allowing the integration of Rust code within the Flutter environment. The version is specified as \"1\".\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/02-deps.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n+[dependencies]\n+flutter_rust_bridge = \"1\"\n```\n\n----------------------------------------\n\nTITLE: CMake Unicode Definition\nDESCRIPTION: This defines Unicode preprocessor definitions for the project. It ensures that all projects use Unicode, allowing for proper character handling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Use Unicode for all projects.\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Using Dart 3 Switch Expressions with Freezed Enums\nDESCRIPTION: This example demonstrates how to use Dart 3's switch expressions as an alternative to the when() method, providing pattern matching with exhaustive checks similar to Rust's match expressions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/04-finish.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nfinal text = switch (platform) {\n  Platform_Android() => 'Android',\n  Platform_Ios() => 'iOS',\n  Platform_MacOs(:final arch) => 'MacOS on $arch',\n  Platform_Windows() => 'Windows',\n  Platform_Unix() => 'Unix',\n  Platform_Wasm() => 'the Web',\n  // we have covered all cases, so this compiles.\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Executable Name\nDESCRIPTION: Defines the name of the executable file created for the application. This sets the final executable's name on the disk. Changing this variable will modify the executable file name.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(BINARY_NAME \"frb_example_rust_ui_todo_list\")\n```\n\n----------------------------------------\n\nTITLE: Automating Version Updates with Bash for Flutter Rust Bridge\nDESCRIPTION: A Bash script to automate injection of the current library version into multiple platform-specific build files for a Flutter Rust bridge project. It extracts the version from the Flutter package pubspec.yaml using awk, then updates iOS/macOS podspec files and CMake build files for Android, Linux, and Windows. The script uses sed to replace the first line with a generated version header comment. Finally, it stages the changes with git add. Dependencies include standard Unix utilities (awk, sed), and the script assumes specific package directory structures.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/melos.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\n\n# iOS & macOS\nAPPLE_HEADER=\"release_tag_name = '$CURR_VERSION' # generated; do not edit\"\nsed -i.bak \"1 s/.*/$APPLE_HEADER/\" packages/flutter_library_name/ios/flutter_library_name.podspec\nsed -i.bak \"1 s/.*/$APPLE_HEADER/\" packages/flutter_library_name/macos/flutter_library_name.podspec\nrm packages/flutter_library_name/macos/*.bak packages/flutter_library_name/ios/*.bak\n\n# CMake platforms (Linux, Windows, and Android)\nCMAKE_HEADER=\"set(LibraryVersion \\\"$CURR_VERSION\\\") # generated; do not edit\"\nfor CMAKE_PLATFORM in android linux windows\ndo\n    sed -i.bak \"1 s/.*/$CMAKE_HEADER/\" packages/flutter_library_name/$CMAKE_PLATFORM/CMakeLists.txt\n    rm packages/flutter_library_name/$CMAKE_PLATFORM/*.bak\ndone\n\ngit add packages/flutter_library_name/\n```\n\n----------------------------------------\n\nTITLE: Run flutter_rust_bridge_codegen for Web Release (Shell)\nDESCRIPTION: Executes the `flutter_rust_bridge_codegen` tool to generate bindings or code specifically for the web platform in release mode. This command is an extra step required when building a Flutter app using `flutter_rust_bridge` for the web release target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/build-release.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nflutter_rust_bridge_codegen build-web --release\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Compiler Settings for C++ Targets (CMake)\nDESCRIPTION: This snippet defines a CMake function that applies standard compilation settings to any target, enforcing C++14 features, enabling warnings, treating warnings as errors, and optimizing non-Debug builds. It should be used per target to maintain consistent and robust compile-time settings across plugins and main application. Inputs include a CMake target name, and the effect is modification of compiler flags and definitions for that target.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Generated file structure for WASM (File listing)\nDESCRIPTION: This file listing shows the default structure generated when using the `--wasm` flag.  The `.io` files are for native platforms and the `.web` files are for web platforms. The split is required by Dart's module system.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/feature/wasm.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n├── lib\n│   ├── ...\n│   ├── bridge_generated.io.dart\n│   └── bridge_generated.web.dart\n└── native/src\n    ├── bridge_generated.io.rs\n    └── bridge_generated.web.rs\n```\n\n----------------------------------------\n\nTITLE: Build Type Configuration CMake\nDESCRIPTION: Defines the build type (Debug, Profile, Release) if it's not already set, using the CMAKE_BUILD_TYPE variable and sets cache properties. This is used to determine optimization and debugging settings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Define build configuration options.\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n    STRING \"Flutter build mode\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n    \"Debug\" \"Profile\" \"Release\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: This snippet sets the minimum required version of CMake. This is a standard practice to ensure compatibility and access to the necessary features for the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Setting Installation Directories\nDESCRIPTION: Sets the installation directories for data and libraries within the build bundle. This organizes the installed files into appropriate directories.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n```\n\n----------------------------------------\n\nTITLE: Rendering DocCardList component in MDX\nDESCRIPTION: Uses MDX code block to import and render a DocCardList component that automatically displays documentation cards for child pages in this section.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/miscellaneous.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Importing Generated Header in iOS Bridging Header (Diff)\nDESCRIPTION: Shows how to import the `bridge_generated.h` file into the `Runner-Bridging-Header.h` for an iOS Flutter project. This import makes the Rust-generated C function symbols accessible within the Swift code of the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_headers.md#_snippet_0\n\nLANGUAGE: objective-c\nCODE:\n```\n+#import \"bridge_generated.h\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Windows Flutter-Rust Integration\nDESCRIPTION: CMakeLists.txt file for Windows that downloads and extracts prebuilt Rust libraries, setting up the necessary configurations for integrating Rust libraries with Flutter on Windows platforms.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/windows_and_linux.md#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\n\n# TODO Remove this workaround once Flutter supports Windows ARM.\n# https://github.com/flutter/flutter/issues/116196\nset(FLUTTER_TARGET_PLATFORM windows-x64)\n\n# The Flutter tooling requires that developers have a version of Visual Studio\n# installed that includes CMake 3.14 or later. You should not increase this\n# version, as doing so will cause the plugin to fail to compile for some\n# customers of the plugin.\ncmake_minimum_required(VERSION 3.14)\n\n# Project-level configuration.\nset(PROJECT_NAME \"flutter_library_name\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}\")\nset(ArchivePath \"${LibRoot}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n\n# List of absolute paths to libraries that should be bundled with the plugin.\n# This list could contain prebuilt libraries, or libraries created by an\n# external build triggered from this build file.\nset(flutter_library_name_bundled_libraries\n  \"${LibRoot}/${FLUTTER_TARGET_PLATFORM}/library_name.dll\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Set Project Name\nDESCRIPTION: Configures the project name and languages. This defines the top-level project name and the programming languages used in the project (in this case, CXX). The project name is set to \"rust_lib_flutter_via_integrate\".\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/rust_builder/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(PROJECT_NAME \"rust_lib_flutter_via_integrate\")\nproject(${PROJECT_NAME} LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Calling Dummy Function in iOS AppDelegate (Swift Diff)\nDESCRIPTION: Demonstrates adding a call to `dummy_method_to_enforce_bundling()` within the `AppDelegate.swift` file's `application(_:didFinishLaunchingWithOptions:)` method for an iOS Flutter project. This call is essential to prevent the linker (Xcode) from stripping the necessary Rust symbols during the build process, ensuring the bridge functions correctly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/integrate/ios_headers.md#_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n override func application(\n     _ application: UIApplication,\n     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n ) -> Bool {\n+    let dummy = dummy_method_to_enforce_bundling()\n+    print(dummy)\n     ..\n }\n```\n\n----------------------------------------\n\nTITLE: Disabling Windows Macros for C++ Compatibility\nDESCRIPTION: This line disables Windows macros that can cause conflicts with C++ standard library functions. Specifically, it defines `NOMINMAX` to prevent clashes. This is important for building a compatible program on Windows.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/windows/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n```\n\n----------------------------------------\n\nTITLE: Using Imported Types in Rust\nDESCRIPTION: This Rust code snippet demonstrates the usage of imported types (MyEnum and MyStruct) from the same crate. It defines a function `use_imported_things` that takes instances of these types as input.  Dependencies include `crate::data::MyEnum` and `crate::data::MyStruct`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/types/translatable/external/same-crate.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse crate::data::{MyEnum, MyStruct};\n\npub fn use_imported_things(my_struct: MyStruct, my_enum: MyEnum) { ... }\n```\n\n----------------------------------------\n\nTITLE: Finding Package Dependencies with CMake\nDESCRIPTION: This snippet uses `find_package` and `pkg_check_modules` to locate the GTK library. It is a system-level dependency.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Directory with CMake\nDESCRIPTION: This snippet configures the installation directory for the build bundle. It initializes `BUILD_BUNDLE_DIR` and `CMAKE_INSTALL_PREFIX`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring System Dependencies and Linking Libraries in CMake (CMake)\nDESCRIPTION: Finds and links system-level packages such as GTK using pkg-config, adds compilation definitions for the application ID, and sets up execution targets for application source files. This snippet includes the pattern of linking against both Flutter and system GUI toolkits to enable cross-platform graphical interfaces. Ensure GTK 3.0 development libraries, PkgConfig, and Flutter build dependencies are available. Outputs are properly linked executables ready for further asset inclusion and installation steps.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n\napply_standard_settings(${BINARY_NAME})\n\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required CMake version for the project. This ensures compatibility with the CMake features used in the build configuration.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Dart FFI IO Implementation\nDESCRIPTION: This Dart code provides an implementation of the FFI layer for native platforms (IO). It imports `dart:ffi` for native interop and defines `ExternalLibrary` as `DynamicLibrary`. The `createWrapperImpl` function creates an instance of `${DART_CLASS_NAME}Impl` using the provided dynamic library.  This allows calling Rust functions from Dart on platforms like Android and iOS.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/01-dart-only.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nimport 'dart:ffi';\n\nimport 'package:$LIBNAME/src/bridge_generated.dart';\n\ntypedef ExternalLibrary = DynamicLibrary;\n\n$DART_CLASS_NAME createWrapperImpl(ExternalLibrary dylib) =>\n    ${DART_CLASS_NAME}Impl(dylib);\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList in MDX - JavaScript/MDX\nDESCRIPTION: This snippet imports the DocCardList React component from the Docusaurus theme and renders it within a markdown file using MDX syntax. The code requires the Docusaurus framework and its core theme components as dependencies. The imported DocCardList can accept props if needed, but in this example is rendered with default settings. Inputs are implicit via MDX context, and the component outputs a styled card list in the generated documentation. It is constrained to Docusaurus environments with MDX support.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/attributes/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList React Component in MDX\nDESCRIPTION: This snippet imports the DocCardList component from the '@theme/DocCardList' package and renders it within an MDX code block. It requires an MDX environment capable of handling React components and the '@theme/DocCardList' dependency available in the project context. The snippet's purpose is to display a list of documentation cards dynamically, typically in a documentation site. There are no input parameters, and the output is the rendered DocCardList UI component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/misc-features/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: This snippet initializes the CMake project, specifying the minimum required version and the project name. The project utilizes CXX language for compilation. This sets the base for the project build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(frb_example_rust_ui_todo_list LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Modifying CMake Build System to Use Corrosion - Diff\nDESCRIPTION: This diff snippet demonstrates how to modify the rust.cmake file to require the Corrosion package directly, rather than fetching it at build time. By simply uncommenting find_package(Corrosion REQUIRED) and removing FetchContent, the build setup becomes simpler and more reliable when Corrosion is installed globally. This approach assumes Corrosion is already installed on the developer's system and omits the FetchContent logic for additional dependency management.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/01-setup/04-desktop.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-# find_package(Corrosion REQUIRED)\n+find_package(Corrosion REQUIRED)\n\n-include(FetchContent)\n-\n-FetchContent_Declare(\n-    Corrosion\n-    GIT_REPOSITORY https://github.com/AndrewGaspar/corrosion.git\n-    GIT_TAG v0.4.4 # Optionally specify a version tag or branch here\n-)\n-\n-FetchContent_MakeAvailable(Corrosion)\n```\n\n----------------------------------------\n\nTITLE: Adding Rust Crate to Cargo Workspace Members (Diff)\nDESCRIPTION: This diff snippet illustrates how to modify the `members` array in the workspace root's `Cargo.toml` file. It shows the addition of the `my_flutter_bridge` directory (representing the new Rust crate) to the list of workspace members, allowing Cargo to manage it as part of the workspace.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/cargo-workspaces.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n-members = [\"workspace_member_1\", \"workspace_member_2\"]\n+members = [\"workspace_member_1\", \"workspace_member_2\", \"my_flutter_bridge\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Types (Debug, Profile, Release) in CMake\nDESCRIPTION: Defines the available build configurations (Debug, Profile, Release). It checks if the generator supports multi-config builds and sets CMAKE_CONFIGURATION_TYPES accordingly. Otherwise, it defaults to the Debug build type using CMAKE_BUILD_TYPE. It also configures the linker and compiler flags for the Profile configuration to match the Release settings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Define build configuration option.\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n# Define settings for the Profile build mode.\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n```\n\n----------------------------------------\n\nTITLE: Installing Bundled Libraries\nDESCRIPTION: Installs all bundled libraries specified in PLUGIN_BUNDLED_LIBRARIES to the library directory within the build bundle.  Each library is installed as a Runtime component.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n```\n\n----------------------------------------\n\nTITLE: Installing Flutter Library\nDESCRIPTION: Installs the Flutter library to the library directory within the build bundle. This library is crucial for running the Flutter application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Creating a Flutter Package with Rust Integration\nDESCRIPTION: Command to create a shareable Flutter package with Rust integration that can be used across multiple Flutter applications.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/quickstart.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nflutter_rust_bridge_codegen create my_package --template plugin\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Plugin Package (Bash)\nDESCRIPTION: This command initiates the creation of a new Flutter plugin package. It uses the `plugin_ffi` template, specifies support for multiple platforms (android, ios, macos, linux, windows), sets an organization name, and defines the package name.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/02-creating-libraries/02-flutter-wrapper.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nflutter create --template=plugin_ffi --platforms=android,ios,macos,linux,windows --org=com.example flutter_library_name\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Flutter Assembly\nDESCRIPTION: Adds a custom target named `flutter_assemble` that depends on the Flutter library and headers. This target is used to trigger the custom command that generates these files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Wrapper Root Directory\nDESCRIPTION: This snippet defines the `WRAPPER_ROOT` variable. This variable specifies the location of the C++ wrapper files generated to bridge Flutter code to native C++ code, helping with platform specific code. This is crucial for the source code. The path is relative to the `EPHEMERAL_DIR`.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n```\n\n----------------------------------------\n\nTITLE: Define Custom Command for Flutter Tool Backend\nDESCRIPTION: Defines a custom command that executes the Flutter tool backend script (`tool_backend.bat`). This script is responsible for generating the necessary build files (like the Flutter engine library and wrapper sources) which are listed as `OUTPUT` dependencies. A `_phony_` output is used to ensure the command runs every time.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n# === Flutter tool backend ===\n# _phony_ is a non-existent file to force this command to run every time,\n# since currently there's no way to get a full input/output list from the\n# flutter tool.\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Settings to Target with CMake\nDESCRIPTION: This snippet applies the standard build settings to the executable target, using the APPLY_STANDARD_SETTINGS function defined earlier.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: Include and apply cargokit\nDESCRIPTION: Includes and applies the cargokit build script.  This script is responsible for building the Rust library and making it available to the CMake project. It defines the path to the Rust project, the crate name, and any additional arguments.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/rust_builder/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(\"../cargokit/cmake/cargokit.cmake\")\napply_cargokit(${PROJECT_NAME} ../../rust rust_lib_flutter_via_integrate \"\")\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Compilation Settings Using a CMake Function in C++\nDESCRIPTION: Defines the function APPLY_STANDARD_SETTINGS, which applies common compile features, warning levels, exception handling, and preprocessor definitions for targets. It enforces C++17 standard, warning level 4 with warnings as errors except unused parameter, disables exception handling macros, and enables debug macros in Debug configurations. This function is intended to be reused by multiple targets to ensure consistent compiler settings.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Build and Including Flutter Configuration\nDESCRIPTION: Sets the minimum required CMake version to 3.14. Defines the path to the 'ephemeral' directory containing generated files. Includes the Flutter-generated configuration file (`generated_config.cmake`) and sets a fallback target platform ('windows-x64') if not defined by the Flutter tool.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# This file controls Flutter-level build steps. It should not be edited.\ncMAKE_minimum_required(VERSION 3.14)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n\n# TODO: Move the rest of this into files in ephemeral. See\n# https://github.com/flutter/flutter/issues/57146.\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n\n# Set fallback configurations for older versions of the flutter tool.\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding build_runner and freezed dependencies - Shell\nDESCRIPTION: These shell commands add `build_runner`, `freezed`, and `freezed_annotation` as development dependencies to the Flutter project.  These packages are required for code generation when using the `freezed` library, which is used for immutable classes and unions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/03-build-runner.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nflutter pub add -d build_runner\nflutter pub add -d freezed\nflutter pub add freezed_annotation\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project and Setting Binary Name\nDESCRIPTION: Sets the minimum required CMake version to 3.14, defines the project name 'frb_example_integrate_third_party' with C++ language support (CXX), and assigns the desired executable output name to the variable BINARY_NAME.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Project-level configuration.\ncmake_minimum_required(VERSION 3.14)\nproject(frb_example_integrate_third_party LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"frb_example_integrate_third_party\")\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Subdirectories and Plugins\nDESCRIPTION: Adds Flutter-related components to the build process. Includes the Flutter managed directory, and build rules for the Flutter library and tools. It also includes the generated plugin build rules that manage the plugins for the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n\n\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Setting Ephemeral Directory\nDESCRIPTION: Defines the `EPHEMERAL_DIR` variable, which points to the directory containing generated configuration files and libraries. This directory is essential for accessing Flutter's internal build outputs.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Setting Ephemeral Directory Path\nDESCRIPTION: This snippet defines the `EPHEMERAL_DIR` variable, which points to a directory containing configuration files generated by the Flutter tool. This directory is vital for setting up configurations. The path is relative to the current source directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Applying Rust Crate Build Helper and Bundling Libraries (CMake)\nDESCRIPTION: Calls 'apply_cargokit' function from the included 'cargokit' module to process a Rust crate directory and crate name, configuring it for integration into the build. Then, creates a scoped variable listing libraries produced or gathered by the build process to be bundled with the Flutter plugin, supporting both prebuilt and externally built libraries.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\napply_cargokit(${PROJECT_NAME} ../../../../../../REPLACE_ME_RUST_CRATE_DIR REPLACE_ME_RUST_CRATE_NAME \"\")\n\nset(REPLACE_ME_RUST_CRATE_NAME_bundled_libraries\n  \"${${PROJECT_NAME}_cargokit_lib}\"\n  PARENT_SCOPE\n)\n```\n\n----------------------------------------\n\nTITLE: Include Generated Configuration and Set Wrapper Root\nDESCRIPTION: Includes a CMake configuration file generated by the Flutter tool, which provides build-specific variables. It also defines the root directory for the C++ client wrapper source files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n\n# TODO: Move the rest of this into files in ephemeral. See\n# https://github.com/flutter/flutter/issues/57146.\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Interface Library\nDESCRIPTION: This snippet creates an interface library named `flutter`. This is used to group and manage the Flutter-related dependencies.  `INTERFACE` means that this library provides include directories and dependencies to other targets, but isn't linked directly.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(flutter INTERFACE)\n```\n\n----------------------------------------\n\nTITLE: Specify LLVM Path for flutter_rust_bridge_codegen on MacOS\nDESCRIPTION: Provides the command to run 'flutter_rust_bridge_codegen' by explicitly setting the path to LLVM installed via Homebrew. This avoids errors related to missing LLVM paths on macOS systems.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nflutter_rust_bridge_codegen --rust-input path/to/your/api.rs --dart-output path/to/file/being/bridge_generated.dart --llvm-path /usr/local/homebrew/opt/llvm/\n```\n\n----------------------------------------\n\nTITLE: Automating Flutter Tool Backend and Build Output Regeneration in CMake\nDESCRIPTION: Defines a CMake custom command and associated target to automate the invocation of the Flutter tool's backend shell script, regenerating output files and headers required for the build. The _phony_ output enforces command execution on each build. Dependencies include environment variables set by the Flutter tool, and required paths to the Flutter tool shell script and ephemeral/generated files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_package/example/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Package Dependencies with PkgConfig\nDESCRIPTION: Uses `pkg-config` to find system-level dependencies required by Flutter, such as GTK, GLib, and GIO. It then imports them as imported targets for linking.  This ensures that the necessary system libraries are available and properly linked during the build process.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Android Binary Extraction\nDESCRIPTION: Creates a CMakeLists.txt file that downloads and extracts Android binaries from a GitHub release. This approach does not build anything but handles binary distribution in a cross-platform way.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/platform_setup/android.md#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(LibraryVersion \"library_name-v0.0.0\") # generated; do not edit\nset(PROJECT_NAME \"project_name\")\n\n# Unlike the Windows & Linux CMakeLists.txt, this Android equivalent is just here\n# to download the Android binaries into src/main/jniLibs/ and does not build anything.\n# The binary download/extraction is difficult to do concisely in Groovy/Gradle,\n# at least across host platforms, so we are just reusing our Linux/Windows logic.\n\n# The Flutter tooling requires that developers have CMake 3.10 or later\n# installed. You should not increase this version, as doing so will cause\n# the plugin to fail to compile for some customers of the plugin.\ncmake_minimum_required(VERSION 3.10)\n\nproject(PROJECT_NAME)\n\n# Download the binaries if they are not already present.\nset(LibRoot \"${CMAKE_CURRENT_SOURCE_DIR}/src/main/jniLibs\")\nset(ArchivePath \"${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}.tar.gz\")\nif(NOT EXISTS ${ArchivePath})\n  file(DOWNLOAD\n    \"https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/android.tar.gz\"\n    ${ArchivePath}\n    TLS_VERIFY ON\n  )\nendif()\n\n# Extract the binaries, overriding any already present.\nfile(REMOVE_RECURSE ${LibRoot})\nfile(MAKE_DIRECTORY ${LibRoot})\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}\n  WORKING_DIRECTORY ${LibRoot}\n)\n```\n\n----------------------------------------\n\nTITLE: Using dummy method in MacOS AppDelegate\nDESCRIPTION: Include the 'dummy_method_to_enfore_binding' function in the AppDelegate.swift file to ensure the Rust bridge is properly linked. This is needed because the MacOS AppDelegate structure differs from iOS.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/04-ios/macos.md#_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\ndummy_method_to_enfore_binding\n```\n\n----------------------------------------\n\nTITLE: Configuring LLVM Path Manually for ffigen in Makefile or Build Script\nDESCRIPTION: This shell snippet provides a conditional setting of the `llvm_path` variable based on the operating system, specifically setting the path for LLVM when on macOS. This manual configuration addresses issues with `ffigen`'s automatic LLVM detection, especially for architectures like x86-64 and arm64, facilitating proper binding generation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/02-adding-code.md#_snippet_1\n\nLANGUAGE: Shell Script\nCODE:\n```\nllvm_path := if os() == \"macos\" {\n    \"--llvm-path /opt/homebrew/opt/llvm\"\n} else {\n    \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Function\nDESCRIPTION: This snippet showcases a Rust function signature. The function named `f` accepts a String `a` and a vector of `MyEnum` objects as input and returns a `MyStruct` object.  It uses Rust's strong typing features for parameters and return values.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/index.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(a: String, b: Vec<MyEnum>) -> MyStruct { ... }\n```\n\n----------------------------------------\n\nTITLE: Async HTTP Request Function in Rust\nDESCRIPTION: An example of an asynchronous function that fetches content from a URL using Reqwest. This approach won't work with flutter_rust_bridge as it doesn't support returning Future types.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse anyhow;\n\nasync fn get() -> anyhow::Result<String> {\n    let url = \"https://link/to/file/download\";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependabot for Multi-Package Flutter Rust Bridge Project - YAML\nDESCRIPTION: This YAML snippet configures Dependabot to automate dependency update pull requests for Dart/Flutter (pub) and Rust (cargo) packages in a monorepo structure. Replace 'library_name' with your specific package names. Dependabot will check and propose updates weekly for each package, ensuring dependencies remain up-to-date. Prerequisites: an existing GitHub repository with valid subpackage paths.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/library/ci.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nversion: 2\nenable-beta-ecosystems: true\nupdates:\n  - package-ecosystem: pub\n    directory: \"/packages/library_name\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/library_name/example\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/flutter_library_name\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: pub\n    directory: \"/packages/flutter_library_name/example\"\n    schedule:\n      interval: weekly\n  - package-ecosystem: cargo\n    directory: \"/packages/library_name/native\"\n    schedule:\n      interval: weekly\n\n```\n\n----------------------------------------\n\nTITLE: Setting Fallback Target Platform\nDESCRIPTION: This snippet sets a fallback configuration for the `FLUTTER_TARGET_PLATFORM` variable. It defines the target platform to \"windows-x64\" if it's not already defined by the Flutter tool. This provides compatibility with older versions of the Flutter tool.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Paths and Behavior in CMake\nDESCRIPTION: Sets up variables and options for the installation process. It defines the build bundle directory relative to the executable, ensures the 'install' step runs by default in Visual Studio, sets the default installation prefix if not already set, and defines paths for data and library directories within the installed bundle.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# === Installation ===\n# Support files are copied into place next to the executable, so that it can\n# run in place. This is done instead of making a separate bundle (as on Linux)\n# so that building and running from within Visual Studio will work.\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\n# Make the \"install\" step default, as it's required to run.\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n```\n\n----------------------------------------\n\nTITLE: Including Generated Plugin Build Rules in CMake\nDESCRIPTION: Includes generated CMake scripts that handle the build and integration of Flutter plugins into the final executable. This allows automatic management of plugin dependencies and simplifies plugin-specific build configurations without manual edits.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Running flamegraph profiling scripts for performance analysis - shell\nDESCRIPTION: These shell commands execute custom benchmarking scripts designed to generate flamegraphs on MacOS for performance analysis of the flutter_rust_bridge-generated code. The first command compiles with benchmarking instrumentation, while the second runs the benchmark with specific filtering and iteration counts, helping developers identify hotspots. Dependencies include the frb_internal scripts configured for flamegraph generation and a MacOS environment.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/tip.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./frb_internal bench-flamegraph-compile\n./frb_internal bench-flamegraph-run --filter 'VoidFunction.*FrbCstSse.*false' --loop-count 10000000\n```\n\n----------------------------------------\n\nTITLE: Modern CMake Behavior & Build Configuration\nDESCRIPTION: Enables modern CMake behaviors and sets up build configurations (Debug, Profile, Release). It checks if multi-configuration generators are used and sets build type accordingly. If no configuration is specified it defaults to Debug.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_policy(VERSION 3.14...3.25)\n\n# Define build configuration option.\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Preprocessor Definitions\nDESCRIPTION: Adds preprocessor definitions to the executable target for the Flutter version information. These definitions are used during compilation to embed the version details into the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n```\n\n----------------------------------------\n\nTITLE: Prepending Elements to Lists in CMake\nDESCRIPTION: A custom CMake function that prepends a prefix to each element in a list, serving as a replacement for list(TRANSFORM ... PREPEND ...) which isn't available in CMake 3.10.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Loading Bundled Libraries from Relative Directory\nDESCRIPTION: This snippet sets the CMAKE_INSTALL_RPATH to load bundled libraries from the lib/ directory relative to the binary. This ensures that the application can find its dependencies at runtime.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_INSTALL_RPATH \"$ORIGIN/lib\")\n```\n\n----------------------------------------\n\nTITLE: Defining Phony Output File\nDESCRIPTION: This snippet defines a \"phony\" output file, which is used to force a build every time. This is a workaround because the Flutter tool doesn't reliably provide input/output information. The file is marked as symbolic so it doesn't actually exist.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Path\nDESCRIPTION: This snippet sets the path to the Flutter library file (`.dll` on Windows). This library is crucial for the application's core functionality. The path is relative to the `EPHEMERAL_DIR`. This value is then published to the parent scope for the install step.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Path\nDESCRIPTION: Sets the path to the Flutter library (`libflutter_linux_gtk.so`) and other related files like the ICU data file. These paths are then published to the parent scope for use in the install step.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Updating minimum CMake version for Linux Corrosion support\nDESCRIPTION: This diff shows how to update the minimum CMake version from 3.10 to 3.12 in the Linux CMakeLists.txt file. This change is necessary to support Corrosion, which is used by rust.cmake to integrate Rust with CMake.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/05-desktop.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-cmake_minimum_required(VERSION 3.10)\n+cmake_minimum_required(VERSION 3.12)\n```\n\n----------------------------------------\n\nTITLE: Shell Script: Copying Files for Linux Integration Tests\nDESCRIPTION: This shell script copies the binaries for Linux integration tests. It uses `awk` command to read version information from pubspec.yaml and places the binary files in the correct location for integration tests.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/07-library/04-ci.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nCURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`\ncp platform-build/other.tar.gz packages/flutter_library_name/linux/$CURR_VERSION.tar.gz\necho Copied file!\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Policy\nDESCRIPTION: Explicitly opts into modern CMake behaviors to avoid warnings with recent CMake versions. This ensures compatibility and utilizes newer CMake features.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_policy(SET CMP0063 NEW)\n```\n\n----------------------------------------\n\nTITLE: CMake Build Mode Settings\nDESCRIPTION: This code sets up settings for the 'Profile' build mode by copying the Release flags. This helps to ensure consistent build behavior across build configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Define settings for the Profile build mode.\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Subdirectory\nDESCRIPTION: Adds the Flutter managed directory as a subdirectory, allowing CMake to process the Flutter build rules. This integrates the Flutter build process into the overall CMake build.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Setting Binary Name and Application ID\nDESCRIPTION: Sets the binary name for the executable and the application ID. The binary name determines the on-disk name of the application, and the application ID is a unique identifier for the GTK application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(BINARY_NAME \"frb_example_integrate_third_party\")\nset(APPLICATION_ID \"com.example.frb_example_integrate_third_party\")\n```\n\n----------------------------------------\n\nTITLE: Defining and Prepending Flutter Header List in CMake\nDESCRIPTION: Creates a list `FLUTTER_LIBRARY_HEADERS` containing the names of Flutter C header files required for interacting with the Flutter engine on Linux. It then uses the previously defined `list_prepend` function to prepend the path `${EPHEMERAL_DIR}/flutter_linux/` to each header file name in the list.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\n```\n\n----------------------------------------\n\nTITLE: Updating Platform Enum to Merge MacIntel and MacApple into MacOs(String)\nDESCRIPTION: This snippet modifies the `Platform` enum in Rust to combine `MacIntel` and `MacApple` variants into a single `MacOs(String)` variant, which stores CPU architecture information as a string. This allows downstream code to distinguish between architectures at runtime while simplifying the enum structure.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/05-template/03-generate/02-adding-code.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub enum Platform {\n    ..\n-    MacIntel,\n-    MacApple,\n+    MacOs(String),\n    ..\n}\n```\n\n----------------------------------------\n\nTITLE: Unicode Definitions\nDESCRIPTION: Enables Unicode support for the project. This defines the UNICODE and _UNICODE preprocessor definitions. This ensures consistent string handling throughout the project, enabling support for Unicode characters.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Version Preprocessor Definitions in CMake\nDESCRIPTION: Adds several preprocessor definitions privately to the target `${BINARY_NAME}`. These definitions make the application's Flutter version information (full string, major, minor, patch, build numbers) available within the C++ source code at compile time. It also defines `NOMINMAX` to prevent common conflicts between Windows API macros (like `min` and `max`) and C++ standard library functions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/windows/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Add preprocessor definitions for the build version.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n\n# Disable Windows macros that collide with C++ standard library functions.\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project.  This ensures that the CMake version used is compatible with the features used in the script. It also sets the ephemeral directory which contains generated config files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_integrate/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Policies for Modern Behaviors\nDESCRIPTION: This snippet explicitly opts in to modern CMake behaviors to avoid warnings with recent CMake versions. It sets CMP0063 to NEW.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_policy(SET CMP0063 NEW)\n```\n\n----------------------------------------\n\nTITLE: Setting Installation Directories with CMake\nDESCRIPTION: This snippet defines the installation directories for data and libraries within the build bundle. These directories will contain the assets and shared libraries needed by the application.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Project (C++)\nDESCRIPTION: This snippet defines the minimum CMake version required and the project name. It initializes the project for the runner application and specifies CXX as the language. This sets up the foundation for the build process, ensuring compatibility with the CMake version and identifying the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/linux/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ncmake_minimum_required(VERSION 3.13)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Understanding Long Generated Code in rust_codegen\nDESCRIPTION: Explains that generated code length is typical and necessary, comparable to code generated by other serialization tools like Google protobuf, and is not inherently problematic.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/troubleshooting.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Specifying Minimum CMake Version (CMake)\nDESCRIPTION: Sets the minimum required version for CMake to 3.10. This is a requirement enforced by the Flutter tooling to ensure compatibility. The accompanying comment warns against increasing this version as it might break compilation for users of the plugin.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake (3.10) needed to build the project. This is a standard practice in CMake projects to ensure compatibility with required features. The comment warns against increasing this version due to potential compatibility issues for plugin users.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/app/rust_builder/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Library Headers\nDESCRIPTION: Defines a list of Flutter library headers and prepends the ephemeral directory path to each header. This ensures that the compiler can find the necessary header files.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_counter/ui/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\n```\n\n----------------------------------------\n\nTITLE: Including Generated Flutter Configuration in CMake\nDESCRIPTION: Includes a CMake file (`generated_config.cmake`) located in the `EPHEMERAL_DIR`. This file is generated by the Flutter tool and contains project-specific build configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Configuration provided via flutter tool.\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: Includes a CMake configuration file generated by the Flutter tool. This file likely contains platform-specific settings and dependencies.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Removing Build Bundle Directory\nDESCRIPTION: Removes the build bundle directory at the start of the installation process to ensure a clean build. This prevents stale files from interfering with the installation.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/linux/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\"\n  \" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Setting Ephemeral Directory\nDESCRIPTION: Sets the `EPHEMERAL_DIR` variable to the path of the `ephemeral` directory within the source directory. This directory likely contains generated files and configurations.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/gallery/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Removing Generated Cargo.lock File (Shell)\nDESCRIPTION: This command removes the `Cargo.lock` file located inside the newly generated Rust crate directory (`my_flutter_bridge`). Removing this file is necessary before adding the crate to a Cargo workspace, as the workspace root's `Cargo.lock` file should manage dependencies for all members.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/how-to/cargo-workspaces.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nrm my_flutter_bridge/Cargo.lock\n```\n\n----------------------------------------\n\nTITLE: Dependencies for Blocking Reqwest Approach\nDESCRIPTION: Required dependencies for using the blocking version of reqwest instead of async.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/v1_mdbook/src/article/async_in_rust.md#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nfutures = \"0.3\"\nreqwest = { version = \"0.11.6\", features = [\"blocking\"] }\nanyhow = { version = \"1.0.49\" }\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: Initializes the CMake project, specifying the minimum required CMake version and setting the project name with CXX as the language.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/rust_ui_todo_list/ui/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(runner LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Settings Plugin Wrapper\nDESCRIPTION: This snippet applies standard settings to the plugin wrapper target. This ensures that the build adheres to project-wide conventions. This is usually defined in another CMake file.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/integrate_third_party/windows/flutter/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(flutter_wrapper_plugin)\n```\n\n----------------------------------------\n\nTITLE: Setting minimum CMake version\nDESCRIPTION: This sets the minimum required CMake version for the project to 3.14.  This ensures compatibility with older versions of Visual Studio as required by Flutter tooling.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_codegen/assets/integration_template/plugin/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Required Version\nDESCRIPTION: This snippet sets the minimum required version of CMake to 3.14. This ensures that the build environment meets the necessary requirements for the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/flutter_via_create/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Define a struct\nDESCRIPTION: This code defines a struct named `Foo` within a hypothetical third-party crate. The exact fields are represented by `..`. The struct has methods `method_one` and `method_two`, the specifics of which are omitted.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/third-party/manual/wrappers.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub struct Foo { .. }\n\nimpl Foo {\n    pub fn method_one(..) -> .. { .. }\n    pub fn method_two(..) -> .. { .. }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CPATH environment variable\nDESCRIPTION: This command sets the `CPATH` environment variable which provides the include path for the `clang` compiler. The `clang -v` command is piped through `grep` and `cut` to extract the correct path, ensuring that the necessary headers are found during compilation. This command is specific to non-Debian Linux distributions.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/manual/integrate/06-existing/02-deps.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nexport CPATH=\"$(clang -v 2>&1 | grep \\\"Selected GCC installation\\\" | rev | cut -d' ' -f1 | rev)/include\"\n```\n\n----------------------------------------\n\nTITLE: Importing and Using DocCardList Component in MDX\nDESCRIPTION: This snippet demonstrates how to import the DocCardList component from the '@theme' namespace and use it within an MDX document. It assumes the existence of the DocCardList component and a supporting MDX environment that interprets JSX-like syntax in markdown. This setup is typically used to render a list of documentation cards dynamically within documentation pages. There are no input parameters for this snippet; it mainly serves UI rendering purposes.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/rust/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Rendering DocCardList component in MDX for Flutter Rust Bridge submodules\nDESCRIPTION: A code snippet that imports and renders the DocCardList component from the Docusaurus theme to automatically list all available submodule documentation pages in the current directory.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/index.md#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Index with Docusaurus DocCardList (MDX)\nDESCRIPTION: Imports the DocCardList component from the Docusaurus theme and renders it. This component automatically generates a list of cards linking to the child pages of the current documentation page, typically used for creating index pages in Docusaurus.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/codegen/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering DocCardList Component in React (JavaScript/JSX)\nDESCRIPTION: This snippet imports the DocCardList component from a specified documentation theme and renders it within the page. It requires an environment supporting MDX or React, such as Docusaurus. There are no inputs or outputs aside from the visual rendering of the documentation cards. The main dependency is '@theme/DocCardList', and the code assumes the presence of this theme component in the project.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/custom/dart/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Card List in MDX (Docusaurus)\nDESCRIPTION: This MDX snippet imports the 'DocCardList' component, typically provided by a Docusaurus theme located at '@theme/DocCardList'. It then renders this component, which dynamically generates a list of cards linking to other documentation pages within the same directory or section, facilitating navigation for the 'Two-way Road' topic.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/direction/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Importing DocCardList component in MDX\nDESCRIPTION: This snippet imports the 'DocCardList' React component from the '@theme/DocCardList' module, facilitating its usage within MDX documentation pages. It does not contain functionality by itself but sets up the environment for rendering documentation cards.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/index.md#_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Cards using DocCardList in MDX\nDESCRIPTION: This snippet demonstrates how to import and use the Docusaurus `DocCardList` component within an MDX file to display a list of documentation cards. It requires the component to be available in the Docusaurus theme.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/miscellaneous/upgrade/index.md#_snippet_0\n\nLANGUAGE: MDX\nCODE:\n```\n```mdx-code-block\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n```\n\n----------------------------------------\n\nTITLE: Visualizing BroadcastChannel Communication Flow in Browser Environment\nDESCRIPTION: This diagram shows how BroadcastChannel replaces SendPort for StreamSink communication across thread boundaries. It demonstrates the channel name being shared between threads to maintain communication paths between multiple workers and Dart.\nSOURCE: https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/website/docs/guides/contributing/submodules/dco-codec.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\nDart ->> Rust: channel\nRust ->> Rust Worker 1: channel.name\nRust Worker 1 ->> Dart: channel.postMessage\nRust ->> Rust Worker 2: channel.name\nRust Worker 2 ->> Dart: channel.postMessage\n```"
  }
]