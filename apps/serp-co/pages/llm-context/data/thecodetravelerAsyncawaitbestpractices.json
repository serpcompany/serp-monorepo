[
  {
    "owner": "thecodetraveler",
    "repo": "asyncawaitbestpractices",
    "content": "TITLE: SafeFireAndForget Extension Method for Task in C#\nDESCRIPTION: Extension method that allows a Task to safely run on a different thread while the calling thread continues execution without waiting for completion. It can optionally handle exceptions through an action delegate and control whether to continue on the captured context.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async void SafeFireAndForget(this System.Threading.Tasks.Task task, System.Action<System.Exception>? onException = null, bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: Advanced Usage of SafeFireAndForget in C#\nDESCRIPTION: Demonstrates advanced usage of SafeFireAndForget, including initialization, setting default exception handling, and using type-specific exception handling. It shows how to handle specific exception types and set global exception handling behavior.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvoid InitializeSafeFireAndForget()\n{\n    // Initialize SafeFireAndForget\n    // Only use `shouldAlwaysRethrowException: true` when you want `.SafeFireAndForget()` to always rethrow every exception. This is not recommended, because there is no way to catch an Exception rethrown by `SafeFireAndForget()`; `shouldAlwaysRethrowException: true` should **not** be used in Production/Release builds.\n    SafeFireAndForgetExtensions.Initialize(shouldAlwaysRethrowException: false);\n\n    // SafeFireAndForget will print every exception to the Console\n    SafeFireAndForgetExtensions.SetDefaultExceptionHandling(ex => Console.WriteLine(ex));\n}\n\nvoid UninitializeSafeFireAndForget()\n{\n    // Remove default exception handling\n    SafeFireAndForgetExtensions.RemoveDefaultExceptionHandling();\n}\n\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    // Allows the async Task method to safely run on a different thread while not awaiting its completion\n    // onException: If a WebException is thrown, print its StatusCode to the Console. **Note**: If a non-WebException is thrown, it will not be handled by `onException`\n    // Because we set `SetDefaultExceptionHandling` in `void InitializeSafeFireAndForget()`, the entire exception will also be printed to the Console\n    ExampleAsyncMethod().SafeFireAndForget<WebException>(onException: ex =>\n    {\n        if(ex.Response is HttpWebResponse webResponse)\n            Console.WriteLine($\"Task Exception\\n Status Code: {webResponse.StatusCode}\");\n    });\n    \n    ExampleValueTaskMethod().SafeFireAndForget<WebException>(onException: ex =>\n    {\n        if(ex.Response is HttpWebResponse webResponse)\n            Console.WriteLine($\"ValueTask Error\\n Status Code: {webResponse.StatusCode}\");\n    });\n\n    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` and `ExampleValueTaskMethod()` run in the background\n}\n\nasync Task ExampleAsyncMethod()\n{\n    await Task.Delay(1000);\n    throw new WebException();\n}\n\nasync ValueTask ExampleValueTaskMethod()\n{\n    var random = new Random();\n    if (random.Next(10) > 9)\n        await Task.Delay(1000);\n        \n    throw new WebException();\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncCommand Implementation Example\nDESCRIPTION: Complete example class showing various AsyncCommand implementations including parameter handling, exception handling, and execution control. Demonstrates practical usage patterns and command execution scenarios.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleClass\n{\n    bool _isBusy;\n\n    public ExampleClass()\n    {\n        ExampleAsyncCommand = new AsyncCommand(ExampleAsyncMethod);\n        ExampleAsyncIntCommand = new AsyncCommand<int>(ExampleAsyncMethodWithIntParameter);\n        ExampleAsyncIntCommandWithCanExecute = new AsyncCommand<int, int>(ExampleAsyncMethodWithIntParameter, CanExecuteInt);\n        ExampleAsyncExceptionCommand = new AsyncCommand(ExampleAsyncMethodWithException, onException: ex => Console.WriteLine(ex.ToString()));\n        ExampleAsyncCommandWithCanExecuteChanged = new AsyncCommand(ExampleAsyncMethod, _ => !IsBusy);\n        ExampleAsyncCommandReturningToTheCallingThread = new AsyncCommand(ExampleAsyncMethod, continueOnCapturedContext: true);\n    }\n\n    public IAsyncCommand ExampleAsyncCommand { get; }\n    public IAsyncCommand<int> ExampleAsyncIntCommand { get; }\n    public IAsyncCommand<int, int> ExampleAsyncIntCommandWithCanExecute { get; }\n    public IAsyncCommand ExampleAsyncExceptionCommand { get; }\n    public IAsyncCommand ExampleAsyncCommandWithCanExecuteChanged { get; }\n    public IAsyncCommand ExampleAsyncCommandReturningToTheCallingThread { get; }\n    \n    public bool IsBusy\n    {\n        get => _isBusy;\n        set\n        {\n            if (_isBusy != value)\n            {\n                _isBusy = value;\n                ExampleAsyncCommandWithCanExecuteChanged.RaiseCanExecuteChanged();\n            }\n        }\n    }\n\n    async Task ExampleAsyncMethod()\n    {\n        await Task.Delay(1000);\n    }\n  \n    async Task ExampleAsyncMethodWithIntParameter(int parameter)\n    {\n        await Task.Delay(parameter);\n    }\n\n    async Task ExampleAsyncMethodWithException()\n    {\n        await Task.Delay(1000);\n        throw new Exception();\n    }\n\n    bool CanExecuteInt(int count)\n    {\n        if(count > 2)\n            return true;\n        \n        return false;\n    }\n\n    void ExecuteCommands()\n    {\n        _isBusy = true;\n    \n        try\n        {\n            ExampleAsyncCommand.Execute(null);\n            ExampleAsyncIntCommand.Execute(1000);\n            ExampleAsyncExceptionCommand.Execute(null);\n            ExampleAsyncCommandReturningToTheCallingThread.Execute(null);\n            \n            if(ExampleAsyncCommandWithCanExecuteChanged.CanExecute(null))\n                ExampleAsyncCommandWithCanExecuteChanged.Execute(null);\n            \n            if(ExampleAsyncIntCommandWithCanExecute.CanExecute(1))\n                ExampleAsyncIntCommandWithCanExecute.Execute(1);\n        }\n        finally\n        {\n            _isBusy = false;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncCommand Implementation Example in C#\nDESCRIPTION: A complete example class demonstrating how to implement and use AsyncCommand with various configurations including parameterized commands, can-execute conditions, exception handling, and thread context control.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices.MVVM/README.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleClass\n{\n    bool _isBusy;\n\n    public ExampleClass()\n    {\n        ExampleAsyncCommand = new AsyncCommand(ExampleAsyncMethod);\n        ExampleAsyncIntCommand = new AsyncCommand<int>(ExampleAsyncMethodWithIntParameter);\n        ExampleAsyncIntCommandWithCanExecute = new AsyncCommand<int, int>(ExampleAsyncMethodWithIntParameter, CanExecuteInt);\n        ExampleAsyncExceptionCommand = new AsyncCommand(ExampleAsyncMethodWithException, onException: ex => Console.WriteLine(ex.ToString()));\n        ExampleAsyncCommandWithCanExecuteChanged = new AsyncCommand(ExampleAsyncMethod, _ => !IsBusy);\n        ExampleAsyncCommandReturningToTheCallingThread = new AsyncCommand(ExampleAsyncMethod, continueOnCapturedContext: true);\n    }\n\n    public IAsyncCommand ExampleAsyncCommand { get; }\n    public IAsyncCommand<int> ExampleAsyncIntCommand { get; }\n    public IAsyncCommand<int, int> ExampleAsyncIntCommandWithCanExecute { get; }\n    public IAsyncCommand ExampleAsyncExceptionCommand { get; }\n    public IAsyncCommand ExampleAsyncCommandWithCanExecuteChanged { get; }\n    public IAsyncCommand ExampleAsyncCommandReturningToTheCallingThread { get; }\n    \n    public bool IsBusy\n    {\n        get => _isBusy;\n        set\n        {\n            if (_isBusy != value)\n            {\n                _isBusy = value;\n                ExampleAsyncCommandWithCanExecuteChanged.RaiseCanExecuteChanged();\n            }\n        }\n    }\n\n    async Task ExampleAsyncMethod()\n    {\n        await Task.Delay(1000);\n    }\n  \n    async Task ExampleAsyncMethodWithIntParameter(int parameter)\n    {\n        await Task.Delay(parameter);\n    }\n\n    async Task ExampleAsyncMethodWithException()\n    {\n        await Task.Delay(1000);\n        throw new Exception();\n    }\n\n    bool CanExecuteInt(int count)\n    {\n        if(count > 2)\n            return true;\n        \n        return false;\n    }\n\n    void ExecuteCommands()\n    {\n        _isBusy = true;\n    \n        try\n        {\n            ExampleAsyncCommand.Execute(null);\n            ExampleAsyncIntCommand.Execute(1000);\n            ExampleAsyncExceptionCommand.Execute(null);\n            ExampleAsyncCommandReturningToTheCallingThread.Execute(null);\n            \n            if(ExampleAsyncCommandWithCanExecuteChanged.CanExecute(null))\n                ExampleAsyncCommandWithCanExecuteChanged.Execute(null);\n            \n            if(ExampleAsyncIntCommandWithCanExecute.CanExecute(1))\n                ExampleAsyncIntCommandWithCanExecute.Execute(1);\n        }\n        finally\n        {\n            _isBusy = false;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncValueCommand Implementation Example\nDESCRIPTION: Complete example class showing various AsyncValueCommand implementations including parameter handling, exception handling, and execution control. Demonstrates practical usage patterns with ValueTask operations.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleClass\n{\n    bool _isBusy;\n\n    public ExampleClass()\n    {\n        ExampleValueTaskCommand = new AsyncValueCommand(ExampleValueTaskMethod);\n        ExampleValueTaskIntCommand = new AsyncValueCommand<int>(ExampleValueTaskMethodWithIntParameter);\n        ExampleValueTaskIntCommandWithCanExecute = new AsyncValueCommand<int, int>(ExampleValueTaskMethodWithIntParameter, CanExecuteInt);\n        ExampleValueTaskExceptionCommand = new AsyncValueCommand(ExampleValueTaskMethodWithException, onException: ex => Debug.WriteLine(ex.ToString()));\n        ExampleValueTaskCommandWithCanExecuteChanged = new AsyncValueCommand(ExampleValueTaskMethod, _ => !IsBusy);\n        ExampleValueTaskCommandReturningToTheCallingThread = new AsyncValueCommand(ExampleValueTaskMethod, continueOnCapturedContext: true);\n    }\n\n    public IAsyncValueCommand ExampleValueTaskCommand { get; }\n    public IAsyncValueCommand<int> ExampleValueTaskIntCommand { get; }\n    public IAsyncCommand<int, int> ExampleValueTaskIntCommandWithCanExecute { get; }\n    public IAsyncValueCommand ExampleValueTaskExceptionCommand { get; }\n    public IAsyncValueCommand ExampleValueTaskCommandWithCanExecuteChanged { get; }\n    public IAsyncValueCommand ExampleValueTaskCommandReturningToTheCallingThread { get; }\n\n    public bool IsBusy\n    {\n        get => _isBusy;\n        set\n        {\n            if (_isBusy != value)\n            {\n                _isBusy = value;\n                ExampleValueTaskCommandWithCanExecuteChanged.RaiseCanExecuteChanged();\n            }\n        }\n    }\n\n    async ValueTask ExampleValueTaskMethod()\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(1000);\n    }\n\n    async ValueTask ExampleValueTaskMethodWithIntParameter(int parameter)\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(parameter);\n    }\n\n    async ValueTask ExampleValueTaskMethodWithException()\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(1000);\n\n        throw new Exception();\n    }\n\n    bool CanExecuteInt(int count)\n    {\n        if(count > 2)\n            return true;\n        \n        return false;\n    }\n\n    void ExecuteCommands()\n    {\n        _isBusy = true;\n\n        try\n        {\n            ExampleValueTaskCommand.Execute(null);\n            ExampleValueTaskIntCommand.Execute(1000);\n            ExampleValueTaskExceptionCommand.Execute(null);\n            ExampleValueTaskCommandReturningToTheCallingThread.Execute(null);\n\n            if (ExampleValueTaskCommandWithCanExecuteChanged.CanExecute(null))\n                ExampleValueTaskCommandWithCanExecuteChanged.Execute(null);\n\n            if(ExampleValueTaskIntCommandWithCanExecute.CanExecute(2))\n                ExampleValueTaskIntCommandWithCanExecute.Execute(2);\n        }\n        finally\n        {\n            _isBusy = false;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncValueCommand Implementation Example in C#\nDESCRIPTION: A comprehensive example class showing how to implement and use AsyncValueCommand with different configurations including parameterized commands, conditional execution, exception handling, and thread context control.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices.MVVM/README.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExampleClass\n{\n    bool _isBusy;\n\n    public ExampleClass()\n    {\n        ExampleValueTaskCommand = new AsyncValueCommand(ExampleValueTaskMethod);\n        ExampleValueTaskIntCommand = new AsyncValueCommand<int>(ExampleValueTaskMethodWithIntParameter);\n        ExampleValueTaskIntCommandWithCanExecute = new AsyncValueCommand<int, int>(ExampleValueTaskMethodWithIntParameter, CanExecuteInt);\n        ExampleValueTaskExceptionCommand = new AsyncValueCommand(ExampleValueTaskMethodWithException, onException: ex => Debug.WriteLine(ex.ToString()));\n        ExampleValueTaskCommandWithCanExecuteChanged = new AsyncValueCommand(ExampleValueTaskMethod, _ => !IsBusy);\n        ExampleValueTaskCommandReturningToTheCallingThread = new AsyncValueCommand(ExampleValueTaskMethod, continueOnCapturedContext: true);\n    }\n\n    public IAsyncValueCommand ExampleValueTaskCommand { get; }\n    public IAsyncValueCommand<int> ExampleValueTaskIntCommand { get; }\n    public IAsyncCommand<int, int> ExampleValueTaskIntCommandWithCanExecute { get; }\n    public IAsyncValueCommand ExampleValueTaskExceptionCommand { get; }\n    public IAsyncValueCommand ExampleValueTaskCommandWithCanExecuteChanged { get; }\n    public IAsyncValueCommand ExampleValueTaskCommandReturningToTheCallingThread { get; }\n\n    public bool IsBusy\n    {\n        get => _isBusy;\n        set\n        {\n            if (_isBusy != value)\n            {\n                _isBusy = value;\n                ExampleValueTaskCommandWithCanExecuteChanged.RaiseCanExecuteChanged();\n            }\n        }\n    }\n\n    async ValueTask ExampleValueTaskMethod()\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(1000);\n    }\n\n    async ValueTask ExampleValueTaskMethodWithIntParameter(int parameter)\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(parameter);\n    }\n\n    async ValueTask ExampleValueTaskMethodWithException()\n    {\n        var random = new Random();\n        if (random.Next(10) > 9)\n            await Task.Delay(1000);\n\n        throw new Exception();\n    }\n\n    bool CanExecuteInt(int count)\n    {\n        if(count > 2)\n            return true;\n        \n        return false;\n    }\n\n    void ExecuteCommands()\n    {\n        _isBusy = true;\n\n        try\n        {\n            ExampleValueTaskCommand.Execute(null);\n            ExampleValueTaskIntCommand.Execute(1000);\n            ExampleValueTaskExceptionCommand.Execute(null);\n            ExampleValueTaskCommandReturningToTheCallingThread.Execute(null);\n\n            if (ExampleValueTaskCommandWithCanExecuteChanged.CanExecute(null))\n                ExampleValueTaskCommandWithCanExecuteChanged.Execute(null);\n\n            if(ExampleValueTaskIntCommandWithCanExecute.CanExecute(2))\n                ExampleValueTaskIntCommandWithCanExecute.Execute(2);\n        }\n        finally\n        {\n            _isBusy = false;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of SafeFireAndForget with Task in C#\nDESCRIPTION: Demonstrates how to use SafeFireAndForget extension method with a Task to run an asynchronous method on a different thread without awaiting its completion. It includes exception handling through an onException callback.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    // Allows the async Task method to safely run on a different thread while the calling thread continues, not awaiting its completion\n    // onException: If an Exception is thrown, print it to the Console\n    ExampleAsyncMethod().SafeFireAndForget(onException: ex => Console.WriteLine(ex));\n\n    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` is running on a different thread\n    // ...\n}\n\nasync Task ExampleAsyncMethod()\n{\n    await Task.Delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: SafeFireAndForget Extension Method for ValueTask in C#\nDESCRIPTION: Extension method that allows a ValueTask to safely run on a different thread while the calling thread continues execution without waiting for completion. It can optionally handle exceptions through an action delegate and control whether to continue on the captured context.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async void SafeFireAndForget(this System.Threading.Tasks.ValueTask task, System.Action<System.Exception>? onException = null, bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: Advanced SafeFireAndForget Usage\nDESCRIPTION: Advanced implementation showing initialization, exception handling, and type-specific exception handling for both Task and ValueTask.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid InitializeSafeFireAndForget()\n{\n    SafeFireAndForgetExtensions.Initialize(shouldAlwaysRethrowException: false);\n    SafeFireAndForgetExtensions.SetDefaultExceptionHandling(ex => Console.WriteLine(ex));\n}\n\nvoid UninitializeSafeFireAndForget()\n{\n    SafeFireAndForgetExtensions.RemoveDefaultExceptionHandling()\n}\n\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    ExampleAsyncMethod().SafeFireAndForget<WebException>(onException: ex =>\n    {\n        if(ex.Response is HttpWebResponse webResponse)\n            Console.WriteLine($\"Task Exception\\n Status Code: {webResponse.StatusCode}\");\n    });\n    \n    ExampleValueTaskMethod().SafeFireAndForget<WebException>(onException: ex =>\n    {\n        if(ex.Response is HttpWebResponse webResponse)\n            Console.WriteLine($\"ValueTask Error\\n Status Code: {webResponse.StatusCode}\");\n    });\n}\n\nasync Task ExampleAsyncMethod()\n{\n    await Task.Delay(1000);\n    throw new WebException();\n}\n\nasync ValueTask ExampleValueTaskMethod()\n{\n    var random = new Random();\n    if (random.Next(10) > 9)\n        await Task.Delay(1000);\n        \n    throw new WebException();\n}\n```\n\n----------------------------------------\n\nTITLE: SafeFireAndForget with ConfigureAwaitOptions for .NET 8.0+ in C#\nDESCRIPTION: Extension method for Task that leverages .NET 8.0's ConfigureAwaitOptions to customize awaiting behavior. This allows more granular control over exception handling, continuation context, and yielding behavior when firing and forgetting a task.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void SafeFireAndForget(this System.Threading.Tasks.Task task, ConfigureAwaitOptions configureAwaitOptions, Action<Exception>? onException = null)\n```\n\n----------------------------------------\n\nTITLE: SafeFireAndForget Extension Method Declarations\nDESCRIPTION: Extension methods for safely executing Task and ValueTask without awaiting completion. Includes exception handling capability.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async void SafeFireAndForget(this System.Threading.Tasks.Task task, System.Action<System.Exception>? onException = null, bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async void SafeFireAndForget(this System.Threading.Tasks.ValueTask task, System.Action<System.Exception>? onException = null, bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of SafeFireAndForget with ValueTask in C#\nDESCRIPTION: Shows how to use SafeFireAndForget extension method with a ValueTask. This is useful for scenarios where ValueTask can provide performance benefits over Task. It includes exception handling similar to the Task example.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    // Allows the async ValueTask method to safely run on a different thread while the calling thread continues, not awaiting its completion\n    // onException: If an Exception is thrown, print it to the Console\n    ExampleValueTaskMethod().SafeFireAndForget(onException: ex => Console.WriteLine(ex));\n\n    // HandleButtonTapped continues execution here while `ExampleAsyncMethod()` is running on a different thread\n    // ...\n}\n\nasync ValueTask ExampleValueTaskMethod()\n{\n    var random = new Random();\n    if (random.Next(10) > 9)\n        await Task.Delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Task Usage with SafeFireAndForget\nDESCRIPTION: Demonstrates basic usage of SafeFireAndForget with Task, including exception handling and async execution.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    ExampleAsyncMethod().SafeFireAndForget(onException: ex => Console.WriteLine(ex));\n}\n\nasync Task ExampleAsyncMethod()\n{\n    await Task.Delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncCommand Constructor Overloads in C#\nDESCRIPTION: Three constructor overloads for AsyncCommand allowing execution with or without parameters, optional canExecute conditions, exception handling, and control over synchronization context.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices.MVVM/README.md#2025-04-17_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<TExecute, Task> execute,\n                     Func<TCanExecute, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<T, Task> execute,\n                     Func<object?, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<Task> execute,\n                     Func<object?, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: AsyncCommand Constructor Overloads\nDESCRIPTION: Constructor definitions for AsyncCommand class supporting different parameter combinations for Task-based operations. Includes options for execute function, canExecute predicate, exception handling, and context control.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<TExecute, Task> execute,\n                     Func<TCanExecute, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<T, Task> execute,\n                     Func<object?, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncCommand(Func<Task> execute,\n                     Func<object?, bool>? canExecute = null,\n                     Action<Exception>? onException = null,\n                     bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: AsyncValueCommand Constructor Overloads in C#\nDESCRIPTION: Three constructor overloads for AsyncValueCommand providing ValueTask-based command execution with options for parameter types, execution conditions, exception handling, and synchronization context control.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices.MVVM/README.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<TExecute, ValueTask> execute,\n                            Func<TCanExecute, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<T, ValueTask> execute,\n                            Func<object?, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<ValueTask> execute,\n                            Func<object?, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: AsyncValueCommand Constructor Overloads\nDESCRIPTION: Constructor definitions for AsyncValueCommand class supporting different parameter combinations for ValueTask-based operations. Includes options for execute function, canExecute predicate, exception handling, and context control.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<TExecute, ValueTask> execute,\n                            Func<TCanExecute, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<T, ValueTask> execute,\n                            Func<object?, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic AsyncValueCommand(Func<ValueTask> execute,\n                            Func<object?, bool>? canExecute = null,\n                            Action<Exception>? onException = null,\n                            bool continueOnCapturedContext = false)\n```\n\n----------------------------------------\n\nTITLE: Basic ValueTask Usage with SafeFireAndForget\nDESCRIPTION: Shows how to use SafeFireAndForget with ValueTask for efficient async operations.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid HandleButtonTapped(object sender, EventArgs e)\n{\n    ExampleValueTaskMethod().SafeFireAndForget(onException: ex => Console.WriteLine(ex));\n}\n\nasync ValueTask ExampleValueTaskMethod()\n{\n    var random = new Random();\n    if (random.Next(10) > 9)\n        await Task.Delay(1000);\n}\n```\n\n----------------------------------------\n\nTITLE: Using WeakEventManager with EventHandler in C#\nDESCRIPTION: Demonstrates the use of WeakEventManager for implementing events that allow garbage collection of subscribers. This example shows how to use WeakEventManager with EventHandler type events.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _canExecuteChangedEventManager = new WeakEventManager();\n\npublic event EventHandler CanExecuteChanged\n{\n    add => _canExecuteChangedEventManager.AddEventHandler(value);\n    remove => _canExecuteChangedEventManager.RemoveEventHandler(value);\n}\n\nvoid OnCanExecuteChanged() => _canExecuteChangedEventManager.RaiseEvent(this, EventArgs.Empty, nameof(CanExecuteChanged));\n```\n\n----------------------------------------\n\nTITLE: Using WeakEventManager with Delegate in C#\nDESCRIPTION: Shows how to use WeakEventManager with a Delegate type event, specifically PropertyChangedEventHandler. This approach allows for weak references to event subscribers, facilitating garbage collection.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _propertyChangedEventManager = new WeakEventManager();\n\npublic event PropertyChangedEventHandler PropertyChanged\n{\n    add => _propertyChangedEventManager.AddEventHandler(value);\n    remove => _propertyChangedEventManager.RemoveEventHandler(value);\n}\n\nvoid OnPropertyChanged([CallerMemberName]string propertyName = \"\") => _propertyChangedEventManager.RaiseEvent(this, new PropertyChangedEventArgs(propertyName), nameof(PropertyChanged));\n```\n\n----------------------------------------\n\nTITLE: Using WeakEventManager<T> with EventHandler<T> in C#\nDESCRIPTION: Shows how to use the generic WeakEventManager<T> with EventHandler<T> for type-safe events. This example demonstrates handling a string-based error event with weak references to subscribers.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager<string> _errorOcurredEventManager = new WeakEventManager<string>();\n\npublic event EventHandler<string> ErrorOcurred\n{\n    add => _errorOcurredEventManager.AddEventHandler(value);\n    remove => _errorOcurredEventManager.RemoveEventHandler(value);\n}\n\nvoid OnErrorOcurred(string message) => _errorOcurredEventManager.RaiseEvent(this, message, nameof(ErrorOcurred));\n```\n\n----------------------------------------\n\nTITLE: Using WeakEventManager with Action in C#\nDESCRIPTION: Demonstrates the use of WeakEventManager with an Action type event. This approach allows for simple event handling without parameters while maintaining weak references to subscribers.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _weakActionEventManager = new WeakEventManager();\n\npublic event Action ActionEvent\n{\n    add => _weakActionEventManager.AddEventHandler(value);\n    remove => _weakActionEventManager.RemoveEventHandler(value);\n}\n\nvoid OnActionEvent(string message) => _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));\n```\n\n----------------------------------------\n\nTITLE: Using WeakEventManager<T> with Action<T> in C#\nDESCRIPTION: Demonstrates the use of WeakEventManager<T> with Action<T> for simple, type-safe event handling. This approach allows for weak references to subscribers while providing a straightforward way to pass typed data to event handlers.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/README.md#2025-04-17_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager<string> _weakActionEventManager = new WeakEventManager<string>();\n\npublic event Action<string> ActionEvent\n{\n    add => _weakActionEventManager.AddEventHandler(value);\n    remove => _weakActionEventManager.RemoveEventHandler(value);\n}\n\nvoid OnActionEvent(string message) => _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));\n```\n\n----------------------------------------\n\nTITLE: WeakEventManager EventHandler Implementation\nDESCRIPTION: Implementation of WeakEventManager using EventHandler to prevent memory leaks in event handling.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _canExecuteChangedEventManager = new WeakEventManager();\n\npublic event EventHandler CanExecuteChanged\n{\n    add => _canExecuteChangedEventManager.AddEventHandler(value);\n    remove => _canExecuteChangedEventManager.RemoveEventHandler(value);\n}\n\nvoid OnCanExecuteChanged() => _canExecuteChangedEventManager.RaiseEvent(this, EventArgs.Empty, nameof(CanExecuteChanged));\n```\n\n----------------------------------------\n\nTITLE: Generic WeakEventManager EventHandler Implementation\nDESCRIPTION: Implementation of generic WeakEventManager using EventHandler<T> for typed event handling.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager<string> _errorOcurredEventManager = new WeakEventManager<string>();\n\npublic event EventHandler<string> ErrorOcurred\n{\n    add => _errorOcurredEventManager.AddEventHandler(value);\n    remove => _errorOcurredEventManager.RemoveEventHandler(value);\n}\n\nvoid OnErrorOcurred(string message) => _errorOcurredEventManager.RaiseEvent(this, message, nameof(ErrorOcurred));\n```\n\n----------------------------------------\n\nTITLE: WeakEventManager Delegate Implementation\nDESCRIPTION: Implementation of WeakEventManager using PropertyChangedEventHandler delegate.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _propertyChangedEventManager = new WeakEventManager();\n\npublic event PropertyChangedEventHandler PropertyChanged\n{\n    add => _propertyChangedEventManager.AddEventHandler(value);\n    remove => _propertyChangedEventManager.RemoveEventHandler(value);\n}\n\nvoid OnPropertyChanged([CallerMemberName]string propertyName = \"\") => _propertyChangedEventManager.RaiseEvent(this, new PropertyChangedEventArgs(propertyName), nameof(PropertyChanged));\n```\n\n----------------------------------------\n\nTITLE: Generic WeakEventManager Action Implementation\nDESCRIPTION: Implementation of generic WeakEventManager using Action<T> for typed event handling.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager<string> _weakActionEventManager = new WeakEventManager<string>();\n\npublic event Action<string> ActionEvent\n{\n    add => _weakActionEventManager.AddEventHandler(value);\n    remove => _weakActionEventManager.RemoveEventHandler(value);\n}\n\nvoid OnActionEvent(string message) => _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));\n```\n\n----------------------------------------\n\nTITLE: WeakEventManager Action Implementation\nDESCRIPTION: Implementation of WeakEventManager using Action delegate for simple event handling.\nSOURCE: https://github.com/TheCodeTraveler/AsyncAwaitBestPractices/blob/main/src/AsyncAwaitBestPractices/README.md#2025-04-17_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly WeakEventManager _weakActionEventManager = new WeakEventManager();\n\npublic event Action ActionEvent\n{\n    add => _weakActionEventManager.AddEventHandler(value);\n    remove => _weakActionEventManager.RemoveEventHandler(value);\n}\n\nvoid OnActionEvent(string message) => _weakActionEventManager.RaiseEvent(message, nameof(ActionEvent));\n```"
  }
]