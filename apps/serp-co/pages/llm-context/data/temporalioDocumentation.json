[
  {
    "owner": "temporalio",
    "repo": "documentation",
    "content": "TITLE: Implementing Asynchronous Temporal Activity with aiohttp in Python\nDESCRIPTION: Defines a Temporal Activity class `TranslateActivities` using `asyncio`. It utilizes `aiohttp` for non-blocking HTTP requests to an external microservice, managing the client session within the class instance for efficiency. The `greet_in_spanish` activity calls a helper method `call_service` to fetch data and handles potential HTTP errors by raising `ApplicationError`, differentiating between retryable (5xx) and non-retryable (4xx) errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sync-vs-async.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport aiohttp\nimport urllib.parse\nfrom temporalio import activity\n\nclass TranslateActivities:\n    def __init__(self, session: aiohttp.ClientSession):\n        self.session = session\n\n    @activity.defn\n    async def greet_in_spanish(self, name: str) -> str:\n        greeting = await self.call_service(\"get-spanish-greeting\", name)\n        return greeting\n\n    # Utility method for making calls to the microservices\n    async def call_service(self, stem: str, name: str) -> str:\n        base = f\"http://localhost:9999/{stem}\"\n        url = f\"{base}?name={urllib.parse.quote(name)}\"\n\n        async with self.session.get(url) as response:\n            translation = await response.text()\n\n            if response.status >= 400:\n                raise ApplicationError(\n                    f\"HTTP Error {response.status}: {translation}\",\n                    # We want to have Temporal automatically retry 5xx but not 4xx\n                    non_retryable=response.status < 500,\n                )\n\n            return translation\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Temporal Activity Class with requests in Python\nDESCRIPTION: Implements the `TranslateActivities` as a class containing a synchronous Temporal Activity `greet_in_spanish`. This version uses the standard `requests` library for making blocking HTTP calls via the `call_service` helper method, which is safe within a synchronous Activity execution environment managed by `ThreadPoolExecutor` or `ProcessPoolExecutor`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sync-vs-async.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport urllib.parse\nimport requests\nfrom temporalio import activity\n\nclass TranslateActivities:\n\n    @activity.defn\n    def greet_in_spanish(self, name: str) -> str:\n        greeting = self.call_service(\"get-spanish-greeting\", name)\n        return greeting\n\n    # Utility method for making calls to the microservices\n    def call_service(self, stem: str, name: str) -> str:\n        base = f\"http://localhost:9999/{stem}\"\n        url = f\"{base}?name={urllib.parse.quote(name)}\"\n\n        response = requests.get(url)\n        return response.text\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Custom Workflow ID in TypeScript\nDESCRIPTION: This code demonstrates how to start a Workflow using a custom Workflow ID that maps to a business process identifier. It shows setting the Workflow ID, Task Queue, and passing arguments to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  workflowId: 'yourWorkflowId',\n  taskQueue: 'yourTaskQueue',\n  args: ['your', 'arg', 'uments'],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing and Proxying Temporal Activities in a Workflow (TypeScript)\nDESCRIPTION: Shows the standard practice for preparing to execute Temporal Activities within a Workflow definition using TypeScript. It involves importing only the *types* of the activities (`import type * as activities from './activities'`) for type safety and then using `proxyActivities<typeof activities>()` to create a typed proxy (`greet`) for invoking the specific Activity. Activity options like `startToCloseTimeout` are passed during proxy creation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { proxyActivities } from '@temporalio/workflow';\n// Only import the activity types\nimport type * as activities from './activities';\n\nconst { greet } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\n// A workflow that calls an activity\nexport async function example(name: string): Promise<string> {\n  return await greet(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client with Encrypted Data Converter\nDESCRIPTION: Code snippet showing how to configure a Temporal Client with a custom data converter that uses encryption. The example demonstrates initializing the client and starting a workflow with encrypted arguments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  dataConverter: await getDataConverter(),\n});\n\nconst handle = await client.workflow.start(example, {\n  args: ['Alice: Private message for Bob.'],\n  taskQueue: 'encryption',\n  workflowId: `my-business-id-${uuid()}`,\n});\n\nconsole.log(`Started workflow ${handle.workflowId}`);\nconsole.log(await handle.result());\n```\n\n----------------------------------------\n\nTITLE: Invoking Activities Synchronously in Temporal Java SDK Workflows - Java\nDESCRIPTION: This code defines a Workflow implementation that creates a type-safe Activity stub using the Java Temporal SDK. It demonstrates the setup of ActivityOptions such as setStartToCloseTimeout, and the orchestration of a file-processing pipeline within the processFile method. Dependencies include the Temporal Java SDK, FileProcessingActivities interface, and a registered Worker. Arguments must provide necessary file details. The code ensures cleanup of temporary files, handling nulls, and is intended to run inside a Workflow worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_15\n\nLANGUAGE: java\nCODE:\n```\npublic class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) {\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity Interface in Java\nDESCRIPTION: Example of implementing an Activity interface in Java. This class provides the actual implementation of the composeGreeting method defined in the GreetingActivities interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nstatic class GreetingActivitiesImpl implements GreetingActivities {\n    @Override\n    public String composeGreeting(String greeting, String name) {\n      return greeting + \" \" + name + \"!\";\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring a Temporal Worker in Go\nDESCRIPTION: Complete example of creating and configuring a Temporal Worker, including Client initialization, Worker creation, Workflow and Activity registration, and Worker execution with proper error handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_27\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"log\"\n\n    \"go.temporal.io/sdk/activity\"\n    \"go.temporal.io/sdk/client\"\n    \"go.temporal.io/sdk/worker\"\n    \"go.temporal.io/sdk/workflow\"\n\n    \"documentation-samples-go/yourapp\"\n)\n\nfunc main() {\n    // Create a Temporal Client\n    // A Temporal Client is a heavyweight object that should be created just once per process.\n    temporalClient, err := client.Dial(client.Options{})\n    if err != nil {\n        log.Fatalln(\"Unable to create client\", err)\n    }\n    defer temporalClient.Close()\n    // Create a new Worker.\n    yourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n    // Register your Workflow Definitions with the Worker.\n    // Use the RegisterWorkflow or RegisterWorkflowWithOptions method for each Workflow registration.\n    yourWorker.RegisterWorkflow(yourapp.YourWorkflowDefinition)\n// ...\n    // Register your Activity Definitons with the Worker.\n    // Use this technique for registering all Activities that are part of a struct and set the shared variable values.\n    message := \"This could be a connection string or endpoint details\"\n    number := 100\n    activities := &yourapp.YourActivityObject{\n        Message: &message,\n        Number:  &number,\n    }\n    // Use the RegisterActivity or RegisterActivityWithOptions method for each Activity.\n    yourWorker.RegisterActivity(activities)\n// ...\n    // Run the Worker\n    err = yourWorker.Run(worker.InterruptCh())\n    if err != nil {\n        log.Fatalln(\"Unable to start Worker\", err)\n    }\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Replaying a Single Temporal Workflow History Fetched via SDK Client (TypeScript)\nDESCRIPTION: Shows how to programmatically fetch a Workflow Event History using the Temporal Client (`client.workflow.getHandle` and `handle.fetchHistory`) and then replay it using `Worker.runReplayHistory`. This approach integrates history fetching directly into the testing or analysis script. Requires connection details, namespace, workflow ID, and the path to the workflow definitions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nconst connection = await Connection.connect({ address });\nconst client = new Client({ connection, namespace: 'your-namespace' });\nconst handle = client.workflow.getHandle('your-workflow-id');\nconst history = await handle.fetchHistory();\nawait Worker.runReplayHistory(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  history,\n);\n```\n\n----------------------------------------\n\nTITLE: Defining a RetryPolicy Struct for ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Provides an example of constructing a `RetryPolicy` struct, setting essential retry parameters such as intervals, backoff coefficient, and non-retryable errors for Temporal Activities in Go. This struct is used as a dependency when setting the `RetryPolicy` field in ActivityOptions. Explicit values are set for intervals and maximum attempts, showing customizable retry behavior. Assumes reliance on `go.temporal.io/sdk/temporal`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nretryPolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100, // 100 * InitialInterval\n  MaximumAttempts:    0, // Unlimited\n  NonRetryableErrorTypes: []string, // empty\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Retry Policy with Temporal TypeScript SDK - TypeScript\nDESCRIPTION: This snippet demonstrates the configuration of a custom Retry Policy for an Activity in the Temporal TypeScript SDK. The retry property allows specifying initialInterval and maximumAttempts as part of the ActivityOptions passed to proxyActivities. Requires the SDK and defined activities. The initialInterval indicates the starting wait time between retries, and maximumAttempts limits the total attempts. If not provided, a default retry policy applies.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst { myActivity } = proxyActivities<typeof activities>({\n  // ...\n  retry: {\n    initialInterval: '10s',\n    maximumAttempts: 5,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Workflow in Go\nDESCRIPTION: Example of a simple Workflow Definition in Go, which is an exportable function that takes a workflow context parameter and returns an error. This is the fundamental unit of a Temporal Application.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage yourapp\n\nimport (\n    \"time\"\n\n    \"go.temporal.io/sdk/workflow\"\n)\n// ...\n\n// YourSimpleWorkflowDefinition is the most basic Workflow Definition.\nfunc YourSimpleWorkflowDefinition(ctx workflow.Context) error {\n    // ...\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Retry Interval with NextRetryDelay in Go SDK\nDESCRIPTION: This snippet demonstrates how to override the retry interval by returning an Application Failure with a custom NextRetryDelay. This technique allows dynamic control of retry timing based on runtime conditions like the current attempt number.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nattempt := activity.GetInfo(ctx).Attempt;\n\nreturn temporal.NewApplicationErrorWithOptions(fmt.Sprintf(\"Something bad happened on attempt %d\", attempt), \"NextDelay\", temporal.ApplicationErrorOptions{\n  NextRetryDelay: 3 * time.Second * delay,\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Activities from a Temporal Workflow in Python with Type-safe Arguments\nDESCRIPTION: This snippet showcases starting an Activity from within a Temporal Workflow definition using the `execute_activity()` helper, passing in a parameter object and specifying required timeout options. The Workflow class is registered with the Temporal SDK, and the run method asynchronously invokes the Activity, handling arguments and the result using type-safe constructs. Dependencies are `temporalio.workflow`, the Activity definition, and a parameter-dataclass. Required keyword arguments such as `start_to_close_timeout` are shown. Inputs to the Activity are constructed as an instance of `YourParams`, while the Workflow method itself expects the name as input and returns a string based on Activity execution. Exception handling for deadline and payload size constraints should be considered.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import workflow\\n# ...\\n# ...\\n@workflow.defn(name=\"YourWorkflow\")\\nclass YourWorkflow:\\n    @workflow.run\\n    async def run(self, name: str) -> str:\\n        return await workflow.execute_activity(\\n            your_activity,\\n            YourParams(\"Hello\", name),\\n            start_to_close_timeout=timedelta(seconds=10),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Testing a Time-Based Workflow Using Time-Skipping Server in xUnit\nDESCRIPTION: This test shows how to use a time-skipping server to efficiently test Workflows with time-based logic. It creates a worker with WaitADayWorkflow and verifies the result without actually waiting for a day.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Testing;\nusing Temporalio.Worker;\n\n[Fact]\npublic async Task WaitADayWorkflow_SimpleRun_Succeeds()\n{\n    // Start time-skipping test server\n    await using var env = await WorkflowEnvironment.StartTimeSkippingAsync();\n\n    // Create a worker\n    using var worker = new TemporalWorker(\n      env.Client,\n      new TemporalWorkerOptions($\"task-queue-{Guid.NewGuid()}\").\n          AddWorkflow<WaitADayWorkflow>());\n\n    // Run the worker only for the life of the code within\n    await worker.ExecuteAsync(async () =>\n    {\n        // Execute the workflow and confirm the result\n        var result = await env.Client.ExecuteWorkflowAsync(\n            (WaitADayWorkflow wf) => wf.RunAsync(),\n            new(id: $\"wf-{Guid.NewGuid()}\", taskQueue: worker.Options.TaskQueue!));\n        Assert.Equal(\"all done\", result);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Activity Results Dynamically in Temporal TypeScript Workflow\nDESCRIPTION: This TypeScript code snippet demonstrates how to dynamically invoke a Temporal Activity within a Workflow using its string name and retrieve its result. It uses `proxyActivities` to create an Activity client and then calls the activity by its name stored in the `activityName` variable using bracket notation (`acts[activityName](...args)`). The `await` keyword ensures the Workflow waits for the Activity Execution to complete and returns its result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  let result = await acts[activityName](...args);\n  return result;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Desired Final Workflow Code (vFinal) After Patching\nDESCRIPTION: This TypeScript snippet illustrates the target final version (`vFinal`) of the `myWorkflow` function after the patching process is complete, sourced from `patching-api/src/workflows-vFinal.ts`. In this version, `activityA` and `activityThatMustRunAfterA` are replaced by `activityB` followed by a sleep. This code cannot be deployed directly while v1 workflows are running without causing non-determinism.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// vFinal\nexport async function myWorkflow(): Promise<void> {\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring EnableLoggingInReplay for Temporal Worker in Go\nDESCRIPTION: Enables logging via `workflow.GetLogger(ctx)` during Workflow Execution replays. By default (`false`), logging is skipped during replays to avoid duplicates. Setting this to `true` is useful primarily for debugging purposes. The type is `bool`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_36\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    EnableLoggingInReplay: false,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution with Temporal TypeScript SDK\nDESCRIPTION: This code demonstrates starting a new Workflow Execution using the Temporal Client from the TypeScript SDK. It calls 'client.workflow.start' with the workflow function, workflowId, taskQueue, and arguments, then retrieves a Workflow handle to access the result. Inputs include the Workflow function reference and its arguments, and outputs a handle and Workflow result. Prerequisites: Initialized Temporal Client and deployed worker to the specified Task Queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  workflowId: 'your-workflow-id',\n  taskQueue: 'your-task-queue',\n  args: ['argument01', 'argument02', 'argument03'], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Temporal Activities with Decorators in Python\nDESCRIPTION: This snippet demonstrates how to define a Temporal Activity in Python using the `@activity.defn` decorator with a custom name. The Activity accepts a single parameter, recommended as a type-annotated dataclass for flexibility and future extension. Dependencies include the `temporalio` SDK along with proper import of parameter type definitions. Inputs include an instance of a parameter object holding the data fields (such as greeting and name), and the function returns a string greeting, which must be serializable. Ensure that parameter and return sizes adhere to gRPC's payload size limits.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import activity\\nfrom your_dataobject_dacx import YourParams\\n\\n# ...\\n# ...\\n@activity.defn(name=\"your_activity\")\\nasync def your_activity(input: YourParams) -> str:\\n    return f\"{input.greeting}, {input.name}!\"\n```\n\n----------------------------------------\n\nTITLE: Initializing a Temporal Worker Process in Python\nDESCRIPTION: This snippet demonstrates how to connect a Temporal client and initialize a Worker in Python using the Temporal SDK. It requires the 'temporalio' dependency, with a running Temporal service accessible at the specified address. Key parameters include 'client' for connection, 'task_queue' for specifying the source of tasks, and lists of registered Workflow and Activity types. The Worker is started asynchronously and will continuously poll and execute the assigned Workflows and Activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n# ...\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    await worker.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Development Server in Bash\nDESCRIPTION: This command starts the Temporal development server, which automatically starts the Web UI, creates the default Namespace, and uses an in-memory database.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev\n```\n\n----------------------------------------\n\nTITLE: Connecting a Temporal Client to a Local Development Service - TypeScript\nDESCRIPTION: Demonstrates the initialization and connection of a Temporal Client to a local Temporal Service using the TypeScript SDK. This example imports the 'Client' class, establishes a connection to the default 'localhost:7233' endpoint, and demonstrates closing the connection in an async function. Requires the '@temporalio/client' package and Node.js environment. The input is implicit (no external parameters); output is a connected Temporal Client instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from '@temporalio/client';\n\nasync function run() {\n  const client = new Client();\n\n  // . . .\n\n  await client.connection.close();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud with Credentials - Temporal Python SDK - Python\nDESCRIPTION: This code shows how to securely connect a Temporal Client to a Temporal Cloud instance using the Python SDK with mTLS authentication. It loads the required client certificate and private key from PEM files, constructs a `TLSConfig`, and uses the asynchronous `Client.connect()` method with the cloud endpoint and namespace. Required dependencies include `temporalio.client.Client`, `temporalio.client.TLSConfig`, and valid certificate files. The code must be run in an environment with access to the PEM files, and TLS setup details (like specifying custom domains or CA roots) may be needed for advanced scenarios.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/temporal-clients.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import Client, TLSConfig\\n# ...\\n# ...\\nasync def main():\\n    with open(\"client-cert.pem\", \"rb\") as f:\\n        client_cert = f.read()\\n    with open(\"client-private-key.pem\", \"rb\") as f:\\n        client_private_key = f.read()\\n    client = await Client.connect(\\n        \"your-custom-namespace.tmprl.cloud:7233\",\\n        namespace=\"<your-custom-namespace>.<account-id>\",\\n        tls=TLSConfig(\\n            client_cert=client_cert,\\n            client_private_key=client_private_key,\\n            # domain=domain, # TLS domain\\n            # server_root_ca_cert=server_root_ca_cert, # ROOT CA to validate the server cert\\n        ),\\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker in Temporal TypeScript SDK\nDESCRIPTION: This code demonstrates how to create a Worker that registers Workflows and Activities with the Temporal server. The Worker polls a specified Task Queue for tasks, bundles Workflow code with Webpack, and connects to the Temporal server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Temporal Search Attributes at Workflow Start in TypeScript\nDESCRIPTION: This snippet shows how to set various types of custom Search Attributes (Integer, Keyword, Boolean, Datetime, String) when initiating a Temporal Workflow Execution using the `client.workflow.start` method in TypeScript. The `searchAttributes` property within the workflow options is used. It also demonstrates retrieving the set attributes using `handle.describe()` after the workflow has started. Requires pre-registered custom search attributes on the Temporal service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  taskQueue: 'search-attributes',\n  workflowId: 'search-attributes-example-0',\n  searchAttributes: {\n    CustomIntField: [2],\n    CustomKeywordField: ['keywordA', 'keywordB'],\n    CustomBoolField: [true],\n    CustomDatetimeField: [new Date()],\n    CustomStringField: [\n      'String field is for text. When queried, it will be tokenized for partial match. StringTypeField cannot be used in Order By',\n    ],\n  },\n});\n\nconst { searchAttributes } = await handle.describe();\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentActivityExecutionSize for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of concurrent Activity Executions the Worker can handle. This option is configured within `worker.Options`. The type is `int`, and the default value is `1000`. Setting it to `0` uses the default value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_28\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n  MaxConcurrentActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Executing a Workflow in Go using Temporal SDK\nDESCRIPTION: This snippet demonstrates how to start a Workflow Execution using the ExecuteWorkflow() method from the Temporal Go SDK. It includes setting up the Temporal Client, defining Workflow options, and handling the returned Future.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n  // ...\n\n  \"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n  temporalClient, err := client.Dial(client.Options{})\n  if err != nil {\n    // ...\n  }\n  defer temporalClient.Close()\n  // ...\n  workflowOptions := client.StartWorkflowOptions{\n    // ...\n  }\n  workflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n  if err != nil {\n    // ...\n  }\n  // ...\n}\n\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Update Handler with Activity Execution in Temporal TypeScript\nDESCRIPTION: Shows an async Update handler that executes an Activity to make a network call. It demonstrates the use of a Mutex for safe concurrent access and error handling for unsupported languages.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport const setLanguageUsingActivity = wf.defineUpdate<Language, [Language]>('setLanguageUsingActivity');\n\nexport async function greetingWorkflow(): Promise<string> {\n  const greetings: Partial<Record<Language, string>> = {\n    [Language.CHINESE]: '你好，世界',\n    [Language.ENGLISH]: 'Hello, world',\n  };\n\n  let language = Language.ENGLISH;\n\n  const lock = new Mutex();\n  wf.setHandler(setLanguageUsingActivity, async (newLanguage) => {\n    if (!(newLanguage in greetings)) {\n      await lock.runExclusive(async () => {\n        if (!(newLanguage in greetings)) {\n          const greeting = await callGreetingService(newLanguage);\n          if (!greeting) {\n            throw new wf.ApplicationFailure(`${newLanguage} is not supported by the greeting service`);\n          }\n          greetings[newLanguage] = greeting;\n        }\n      });\n    }\n    const previousLanguage = language;\n    language = newLanguage;\n    return previousLanguage;\n  });\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Workflow and Activity Types in Go\nDESCRIPTION: Shows how to register multiple Workflow and Activity types with a Temporal Worker. Each type must have a unique name, and all Workers listening to the same Task Queue must register the same types.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_48\n\nLANGUAGE: go\nCODE:\n```\nw.RegisterActivity(ActivityA)\nw.RegisterActivity(ActivityB)\nw.RegisterActivity(ActivityC)\nw.RegisterWorkflow(WorkflowA)\nw.RegisterWorkflow(WorkflowB)\nw.RegisterWorkflow(WorkflowC)\n```\n\n----------------------------------------\n\nTITLE: Replaying Workflow Event History - Temporal WorkflowReplayer - Go\nDESCRIPTION: This Go code example shows how to replay a previously fetched Workflow Event History using the Temporal Go SDK's worker.WorkflowReplayer. The function retrieves history using the provided client, registers the Workflow implementation, and invokes ReplayWorkflowHistory. Dependencies are go.temporal.io/sdk/client and go.temporal.io/sdk/worker. Input parameters are context, client, workflow id, and run id; returns an error if the actual execution diverges from the recorded history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {\n\thist, err := GetWorkflowHistory(ctx, client, id, runID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplayer := worker.NewWorkflowReplayer()\n\treplayer.RegisterWorkflow(YourWorkflow)\n\treturn replayer.ReplayWorkflowHistory(nil, hist)\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Prefix to Temporal Activity Types in Java\nDESCRIPTION: Illustrates using the `namePrefix` parameter within the `@ActivityInterface` annotation to prepend a specified string to all Activity Types derived from methods in that interface. In this example, the prefix \"Messaging_\" is added, resulting in Activity Types `Messaging_SendMessage` and `Messaging_ComposeGreeting`. The method name part is still capitalized. Requires the Temporal Java SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_13\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface(namePrefix = \"Messaging_\")\npublic interface GreetingActivities {\n    String sendMessage(String input);\n\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Interface with Custom Object in Java\nDESCRIPTION: Example of defining an Activity interface that uses a custom object as a parameter. This allows for more complex data structures to be passed to Activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_10\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface\npublic interface YourActivities {\n    String getCustomObject(CustomObj customobj);\n    void sendCustomObject(CustomObj customobj, String abc);\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from one Workflow to another in Temporal TypeScript\nDESCRIPTION: Example of sending an External Signal from one Workflow to another using getExternalWorkflowHandle. This approach maintains determinism in Workflow code by avoiding direct network calls while enabling inter-workflow communication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getExternalWorkflowHandle } from '@temporalio/workflow';\nimport { joinSignal } from './other-workflow';\n\nexport async function yourWorkflowThatSignals() {\n  const handle = getExternalWorkflowHandle('workflow-id-123');\n  await handle.signal(joinSignal, { userId: 'user-1', groupId: 'group-1' });\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud with mTLS in TypeScript\nDESCRIPTION: Demonstrates how to establish a secure connection to a Temporal Cloud namespace using mTLS. It reads the certificate and private key from files using `fs-extra`, configures `connectionOptions` including the Temporal Cloud address and TLS credentials (client certificate and key), connects using `Connection.connect`, and then initializes a `Client` instance associated with the specific namespace. The connection logic is conditionally executed based on the `NODE_ENV` environment variable, targeting 'production' or 'staging' deployments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Client, Connection } from '@temporalio/client';\nimport fs from 'fs-extra';\n\nconst { NODE_ENV = 'development' } = process.env;\nconst isDeployed = ['production', 'staging'].includes(NODE_ENV);\n\nasync function run() {\n  const cert = await fs.readFile('./path-to/your.pem');\n  const key = await fs.readFile('./path-to/your.key');\n\n  let connectionOptions = {};\n  if (isDeployed) {\n    connectionOptions = {\n      address: 'your-namespace.tmprl.cloud:7233',\n      tls: {\n        clientCertPair: {\n          crt: cert,\n          key,\n        },\n      },\n    };\n\n    const connection = await Connection.connect(connectionOptions);\n\n    const client = new Client({\n      connection,\n      namespace: 'your-namespace',\n    });\n\n    // . . .\n\n    await client.connection.close();\n  }\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Developing an Activity in C#\nDESCRIPTION: Shows how to define an Activity using the [Activity] attribute. The example includes a synchronous Activity method that takes custom parameters and returns a string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Activities;\n\npublic class MyActivities\n{\n    [Activity]\n    public string MyActivity(MyActivityParams input) =>\n        $\"{input.Greeting}, {input.Name}!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkflowClient with a Custom Payload Converter in Temporal Java SDK\nDESCRIPTION: This snippet shows how to set up a custom DataConverter with a custom PayloadConverter, and register it in WorkflowClientOptions for use by a Temporal Java SDK Worker or Workflow client. The configuration ensures all Payload conversions use the provided logic, essential for workflows requiring special serialization. Dependencies include the Temporal Java SDK, a custom PayloadConverter, and correct client option setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/converters-and-encryption.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n//...\\nDefaultDataConverter ddc =\\n        DefaultDataConverter.newDefaultInstance()\\n            .withPayloadConverterOverrides(new YourCustomPayloadConverter());\\n\\n    WorkflowClientOptions workflowClientOptions =\\n        WorkflowClientOptions.newBuilder().setDataConverter(ddc).build();\\n//...\\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to Local Development Temporal Service in Go SDK\nDESCRIPTION: Initializes a Temporal Client that connects to a local development Temporal Service. This example creates a client with default connection options that target 127.0.0.1:7233, the standard port for local Temporal development instances. The client can be used to communicate with the Temporal Service for operations like starting workflows and sending signals.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"documentation-samples-go/yourapp\"\n\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n\t// Create a Temporal Client to communicate with the Temporal Service.\n\t// A Temporal Client is a heavyweight object that should be created just once per process.\n\ttemporalClient, err := client.Dial(client.Options{\n\t\tHostPort: client.DefaultHostPort,\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create Temporal Client\", err)\n\t}\n\tdefer temporalClient.Close()\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Activities for Workflow Integration Testing in Python\nDESCRIPTION: Illustrates integration testing of a Temporal Workflow by mocking its Activity dependencies. A mock Activity implementation (`compose_greeting_mocked`) with the same name and signature as the real one is defined using `@activity.defn` and provided to the `Worker`. When the `GreetingWorkflow` is executed via the client, the Worker invokes the mocked Activity, allowing the Workflow logic to be tested in isolation from the real Activity's implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/testing-suite.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport uuid\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n\n# Import your Activity Definition and real implementation\nfrom hello.hello_activity import (\n    ComposeGreetingInput,\n    GreetingWorkflow,\n    compose_greeting,\n)\n\n# Define your mocked Activity implementation\n@activity.defn(name=\"compose_greeting\")\nasync def compose_greeting_mocked(input: ComposeGreetingInput) -> str:\n    return f\"{input.greeting}, {input.name} from mocked activity!\"\n\nasync def test_mock_activity(client: Client):\n    task_queue_name = str(uuid.uuid4())\n    # Provide the mocked Activity implementation to the Worker\n    async with Worker(\n        client,\n        task_queue=task_queue_name,\n        workflows=[GreetingWorkflow],\n        activities=[compose_greeting_mocked],\n    ):\n        # Execute your Workflow as usual\n        assert \"Hello, World from mocked activity!\" == await client.execute_workflow(\n            GreetingWorkflow.run,\n            \"World\",\n            id=str(uuid.uuid4()),\n            task_queue=task_queue_name,\n        )\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Method with Annotation in Java\nDESCRIPTION: Example of defining an Activity interface with an optional @ActivityMethod annotation on the method. This annotation is not required but can be used for clarity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface\npublic interface GreetingActivities {\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\n----------------------------------------\n\nTITLE: Pseudocode Example of a Basic Temporal Workflow Structure\nDESCRIPTION: A simple pseudocode example showing the structure of a loan application workflow with sequential Activity execution. This demonstrates how business logic can be written in a straightforward manner using Temporal SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nfunc LoanApplicationWorkflow {\n\n    sdk.ExecuteActivity(CreditCheck)\n\n    sdk.ExecuteActivity(AutomatedApproval)\n\n    sdk.ExecuteActivity(NotifyApplicant)\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Activity Implementations for Worker Integration Tests in TypeScript\nDESCRIPTION: This code demonstrates how to mock Activity implementations when integration testing Workflows with a real Worker. A partial object (`mockActivities`) is created, providing mock functions only for the Activities relevant to the test (e.g., `makeHTTPRequest`). This mock object is then passed to the `Worker.create` configuration under the `activities` key, ensuring the Worker uses the mocks instead of the real implementations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type * as activities from './activities';\n\n// Creating a mock object of the activities.\nconst mockActivities: Partial<typeof activities> = {\n  makeHTTPRequest: async () => '99',\n};\n\n// Creating a worker with the mocked activities.\nconst worker = await Worker.create({\n  activities: mockActivities,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring a Production Worker with Environment-Based Setup\nDESCRIPTION: Demonstrates how to create a Worker that uses different Workflow loading strategies based on the environment. In production, it loads a pre-bundled file, while in development it uses dynamic path resolution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nconst workflowOption = () =>\n  process.env.NODE_ENV === 'production'\n    ? {\n      workflowBundle: {\n        codePath: require.resolve('../workflow-bundle.js'),\n      },\n    }\n    : { workflowsPath: require.resolve('./workflows') };\n\nasync function run() {\n  const worker = await Worker.create({\n    ...workflowOption(),\n    activities,\n    taskQueue: 'production-sample',\n  });\n\n  await worker.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Automatic Time Skipping in Temporal\nDESCRIPTION: Test implementation showing how to use automatic time skipping with a Worker to execute a sleep Workflow without actual time delay.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sleeperWorkflow } from './workflows';\n\ntest('sleep completes almost immediately', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n  });\n  // Does not wait an entire day\n  await worker.runUntil(\n    testEnv.client.workflow.execute(sleeperWorkflow, {\n      workflowId: uuid(),\n      taskQueue: 'test',\n    }),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Typed Activity Stubs with Custom ActivityOptions - Temporal Java SDK - Java\nDESCRIPTION: This snippet shows how to configure and instantiate multiple typed Activity stubs within a Workflow implementation, each with its own ActivityOptions such as task queue and timeout. It demonstrates customizing parallel task execution settings for Activities, enabling more granular control in Workflow orchestration. Requires Temporal Java SDK and FileProcessingActivities interface. Each stub operates on different task queues and with different timeouts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_16\n\nLANGUAGE: java\nCODE:\n```\npublic FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue1\")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskQueue(\"taskQueue2\")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrative Modified Workflow (v2) Causing Non-Determinism\nDESCRIPTION: This TypeScript code snippet demonstrates a modified version (v2) of a Workflow where a `sleep('1 day')` is added before the original `runActivity()` call. Deploying this directly while v1 Workflows are running would lead to non-determinism errors (as the replay would expect `runActivity` first, not `sleep`), highlighting the need for the Patching API.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// to v2\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 day');\n\n  await runActivity();\n  return 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RetryOptions via WorkflowImplementationOptions in Java\nDESCRIPTION: This snippet shows how to set Retry Options per Activity type (`EmailCustomerGreeting`) using `WorkflowImplementationOptions`. It configures the Activity to not retry on `NullPointerException` and sets a required `StartToCloseTimeout`. Dependencies include `io.temporal.worker.WorkflowImplementationOptions`, `com.google.common.collect.ImmutableMap`, `io.temporal.activity.ActivityOptions`, `io.temporal.common.RetryOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_33\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n        WorkflowImplementationOptions.newBuilder()\n               .setActivityOptions(\n                    ImmutableMap.of(\n                        \"EmailCustomerGreeting\",\n                        ActivityOptions.newBuilder()\n                              // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                              // required when setting Activity options.\n                              .setStartToCloseTimeout(Duration.ofSeconds(5))\n                              .setRetryOptions(\n                                    RetryOptions.newBuilder()\n                                        .setDoNotRetry(NullPointerException.class.getName())\n                                        .build())\n                              .build()))\n              .build();\n```\n\n----------------------------------------\n\nTITLE: Registering Workflow and Activity Implementations with Worker - Java\nDESCRIPTION: This snippet shows how to register a Workflow and an Activity implementation with a Worker created via a WorkerFactory in Temporal's Java SDK. The method registerWorkflowImplementationTypes associates the worker with a Workflow implementation, while registerActivitiesImplementations provides a stateless, thread-safe Activity instance. All Workers polling the same task queue must register the same types. Prerequisites are a properly configured WorkerFactory, worker, and implementation classes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_40\n\nLANGUAGE: Java\nCODE:\n```\nWorker worker = workerFactory.newWorker(\"your_task_queue\");\n...\n// Register Workflow\nworker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n// Register Activity\nworker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to Local Temporal Service with Temporal TypeScript SDK\nDESCRIPTION: This snippet demonstrates how to instantiate a Temporal Client aimed at a local development Temporal Service using the TypeScript SDK. No explicit connection or client options are required as it defaults to 127.0.0.1:7233. The code performs basic error handling and closes the connection after use. Dependencies: '@temporalio/client' module and a local running Temporal Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Client } from '@temporalio/client';\n\nasync function run() {\n  const client = new Client();\n\n  // . . .\n\n  await client.connection.close();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Replaying a Single Workflow Event History from JSON with Temporal Python SDK\nDESCRIPTION: This snippet illustrates how to instantiate a Replayer for specific Workflow definitions and replay a single workflow from a JSON-formatted Event History using the Temporal Python SDK in Python. It requires the Temporal Python SDK and a WorkflowHistory in JSON string format (history_json_str). The snippet covers converting a JSON string into a history object and performing the replay, raising errors if the replay fails due to non-determinism. This method can accept a JSON object loaded via Python's json.load() if reading from a file, making it suitable for replaying exported histories (e.g., from Temporal Web UI or CLI).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/testing-suite.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nreplayer = Replayer(workflows=[YourWorkflow])\nawait replayer.replay_workflow(WorkflowHistory.from_json(history_json_str))\n```\n\n----------------------------------------\n\nTITLE: Registering a Nexus Service and Handler Workflow in a Java Worker\nDESCRIPTION: Demonstrates setting up a Temporal Worker in Java using `WorkerFactory` to host a Nexus service. The code initializes a `WorkflowClient`, creates a `WorkerFactory`, and then a `Worker` listening on a specific task queue (`my-handler-task-queue`). It registers the `HelloHandlerWorkflowImpl` Workflow implementation and the `NexusServiceImpl` service implementation using `worker.registerNexusServiceImplementation`. Finally, it starts the factory to begin polling for tasks. Requires the Temporal Java SDK, `ClientOptions` for client setup, `NexusServiceImpl` class, and `HelloHandlerWorkflowImpl` class.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\npackage io.temporal.samples.nexus.handler;\n\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.samples.nexus.options.ClientOptions;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class HandlerWorker {\n  public static final String DEFAULT_TASK_QUEUE_NAME = \"my-handler-task-queue\";\n\n  public static void main(String[] args) {\n    WorkflowClient client = ClientOptions.getWorkflowClient(args);\n\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n\n    Worker worker = factory.newWorker(DEFAULT_TASK_QUEUE_NAME);\n    worker.registerWorkflowImplementationTypes(HelloHandlerWorkflowImpl.class);\n    worker.registerNexusServiceImplementation(new NexusServiceImpl());\n\n    factory.start();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Synchronous Nexus Operation in Go\nDESCRIPTION: This snippet demonstrates how to mock a synchronous Nexus operation in a Temporal Workflow test. It uses the OnNexusOperation method to set up the mock and executes a test Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_NexusSyncOperation() {\n        s.env.OnNexusOperation(\n                \"sample-service\",\n                nexus.NewOperationReference[SampleInput, SampleOutput](\"sample-operation\"),\n                SampleInput{},\n                workflow.NexusOperationOptions{},\n        ).Return(\n                &nexus.HandlerStartOperationResultSync[SampleOutput]{\n                        Value: SampleOutput{},\n                },\n                nil, // error if you want to simulate an error in the ExecuteOperation call\n        )\n        // You can also add a delay to return the mock values by calling After().\n        // Eg: s.env.OnNexusOperation(...).Return(...).After(1*time.Second)\n\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_nexus_operation\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Client for Local Development Service in Java\nDESCRIPTION: This code snippet demonstrates how to create a Temporal Client instance that connects to a locally hosted Temporal Service using default settings (localhost:7233) in Java.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nWorkflowServiceStubs serviceStub = WorkflowServiceStubs.newLocalServiceStubs();\n\n// Initialize the Temporal Client\n// This application uses the Client to communicate with the local Temporal Service\nWorkflowClient client = WorkflowClient.newInstance(serviceStub);\n```\n\n----------------------------------------\n\nTITLE: Sending an External Signal from a Temporal Go Workflow\nDESCRIPTION: Provides an example of sending a signal from one Workflow Execution to another (an External Signal) using `workflow.SignalExternalWorkflow` from within a Workflow Definition. This function requires a `workflow.Context`, the target Workflow ID (`\"some-workflow-id\"`), an optional target Run ID (empty string `\"\"` targets the current run), the signal name (`\"your-signal-name\"`), and the signal data (`signal`). The `.Get(ctx, nil)` call blocks until the signal operation is acknowledged by the Temporal service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// ...\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n  ...\n  signal := MySignal {\n    Message: \"Some important data\",\n  }\n  err :=  workflow.SignalExternalWorkflow(ctx, \"some-workflow-id\", \"\", \"your-signal-name\", signal).Get(ctx, nil)\n  if err != nil {\n    // ...\n  }\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Executing and Awaiting Completion of Child Workflows with Temporal TypeScript SDK\nDESCRIPTION: This code sample illustrates using the executeChild function from the Temporal TypeScript SDK to run multiple Child Workflows in parallel and wait for all of them to complete. Dependencies include '@temporalio/workflow' and the relevant Workflow definitions. The code demonstrates passing custom options for each Child Workflow and aggregating their results into a concatenated string. Input is a variable argument list of names, and outputs a newline-separated string of each child's result. Notably, advanced Child Workflow options can be used for cancellation and parent-close behaviors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { executeChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(...names: string[]): Promise<string> {\n  const responseArray = await Promise.all(\n    names.map((name) =>\n      executeChild(childWorkflow, {\n        args: [name],\n        // workflowId, // add business-meaningful workflow id here\n        // // regular workflow options apply here, with two additions (defaults shown):\n        // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n        // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n      })\n    ),\n  );\n  return responseArray.join('\\n');\n}\n```\n\n----------------------------------------\n\nTITLE: Mocked Activity Unit Test Implementation\nDESCRIPTION: Implementation of unit tests for HelloActivity sample using TestWorkflowEnvironment with mocked activities using Mockito.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testMockedActivity() {\n        // Mock our workflow activity\n        GreetingActivities activities = mock(GreetingActivities.class);\n        when(activities.composeGreeting(\"Hello\", \"World\")).thenReturn(\"Hello Mocked World!\");\n        worker.registerActivitiesImplementations(activities);\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello Mocked World!\", greeting);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Workflow and Activity Types for a Temporal Worker in Python\nDESCRIPTION: This snippet outlines the registration of Workflow and Activity types when creating a Worker using the Temporal Python SDK. The Worker constructor is called with explicit lists supplied to 'workflows' and 'activities', ensuring consistency for all Workers polling the same Task Queue. It depends on the same prerequisites as Temporal Worker setup, and requires defining suitable Workflow and Activity classes or functions to register. Inputs are the Task Queue name and handlers; output is a Worker process that runs indefinitely until shutdown.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    worker = Worker(\n        client,\n        task_queue=\"your-task-queue\",\n        workflows=[YourWorkflow],\n        activities=[your_activity],\n    )\n    await worker.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Functions in Go with Temporal SDK\nDESCRIPTION: Demonstrates two approaches to Activity Definition in the Temporal Go SDK: as a standalone function and as a struct method. Struct methods allow sharing resources across Activity invocations in the same Worker process.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage yourapp\n\nimport (\n    \"context\"\n\n    \"go.temporal.io/sdk/activity\"\n)\n// ...\n\n// YourSimpleActivityDefinition is a basic Activity Definition.\nfunc YourSimpleActivityDefinition(ctx context.Context) error {\n    return nil\n}\n\n// YourActivityObject is the struct that maintains shared state across Activities.\n// If the Worker crashes this Activity object loses its state.\ntype YourActivityObject struct {\n    Message *string\n    Number  *int\n}\n\n// YourActivityDefinition is your custom Activity Definition.\n// An Activity Definition is an exportable function.\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from one Workflow to another in C#\nDESCRIPTION: This code shows how to send a Signal from one Workflow to another, known as an External Signal. It uses Workflow.GetExternalWorkflowHandle to obtain a handle to the target Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class WorkflowB\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        var handle = Workflow.GetExternalWorkflowHandle<WorkflowA>(\"workflow-a\");\n        await handle.SignalAsync(wf => wf.YourSignalAsync(\"signal argument\"));\n    }\n\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Connecting a Worker to Temporal Cloud in Go\nDESCRIPTION: Demonstrates how to configure a Worker to connect to Temporal Cloud using mTLS authentication. Requires a certificate/key pair, namespace information, and proper TLS configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_47\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"crypto/tls\"\n    \"log\"\n\n    \"go.temporal.io/sdk/client\"\n    \"go.temporal.io/sdk/worker\"\n\n    \"documentation-samples-go/cloud\"\n)\n\nfunc main() {\n    // Get the key and cert from your env or local machine\n    clientKeyPath := \"./secrets/yourkey.key\"\n    clientCertPath := \"./secrets/yourcert.pem\"\n    // Specify the host and port of your Temporal Cloud Namespace\n    // Host and port format: namespace.unique_id.tmprl.cloud:port\n    hostPort := \"<yournamespace>.<id>.tmprl.cloud:7233\"\n    namespace := \"<yournamespace>.<id>\"\n    // Use the crypto/tls package to create a cert object\n    cert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n    if err != nil {\n        log.Fatalln(\"Unable to load cert and key pair.\", err)\n    }\n    // Add the cert to the tls certificates in the ConnectionOptions of the Client\n    temporalClient, err := client.Dial(client.Options{\n        HostPort:  hostPort,\n        Namespace: namespace,\n        ConnectionOptions: client.ConnectionOptions{\n            TLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n        },\n    })\n    if err != nil {\n        log.Fatalln(\"Unable to connect to Temporal Cloud.\", err)\n    }\n    defer temporalClient.Close()\n    // Create a new Worker.\n    yourWorker := worker.New(temporalClient, \"cloud-connection-example-go-task-queue\", worker.Options{})\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Continue-As-New in a Temporal Python Workflow\nDESCRIPTION: This Python snippet defines a Temporal Workflow class `LoopingWorkflow`. The asynchronous `run` method takes an `iteration` integer. If the iteration reaches 5, the workflow completes. Otherwise, it pauses for 10 seconds using `asyncio.sleep(10)` and then invokes `workflow.continue_as_new(iteration + 1)`. This call stops the current Workflow Execution and starts a new one with the same Workflow Id but an incremented iteration count and a fresh Event History. This demonstrates a pattern for looping or long-running processes without accumulating an overly large event history. It relies on the `temporalio.workflow` and `asyncio` libraries.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\n@workflow.defn\nclass LoopingWorkflow:\n    @workflow.run\n    async def run(self, iteration: int) -> None:\n        if iteration == 5:\n            return\n        await asyncio.sleep(10)\n        workflow.continue_as_new(iteration + 1)\n```\n\n----------------------------------------\n\nTITLE: Setting Search Attributes for a Workflow in Go\nDESCRIPTION: This snippet explains how to set indexed Search Attributes for a Workflow Execution in Go, allowing for later filtering and querying. It involves creating a `map[string]interface{}` with attribute keys and correctly typed values (e.g., string, int64, float64, bool, time.Time) and assigning it to the `SearchAttributes` field in `client.StartWorkflowOptions`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_15\n\nLANGUAGE: go\nCODE:\n```\n```go\nsearchAttributes := map[string]interface{}{\n  \"CustomIntField\": 1,\n  \"MiscData\": \"yellow\",\n}\nworkflowOptions := client.StartWorkflowOptions{\n  SearchAttributes: searchAttributes,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Signals in Go Workflow\nDESCRIPTION: Shows how to implement Signal handling using workflow.GetSignalChannel for receiving asynchronous messages in a Workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nconst ApproveSignal = \"approve\"\n\ntype ApproveInput struct {\n\tName string\n}\n\nfunc GreetingWorkflow(ctx workflow.Context) error {\n    logger := workflow.GetLogger(ctx)\n\tapproverName := \"\"\n\t...\n\tvar approveInput ApproveInput\n\tworkflow.GetSignalChannel(ctx, ApproveSignal).Receive(ctx, &approveInput)\n\tapproverName = approveInput.Name\n\tlogger.Info(\"Received approval\", \"Approver\", approverName)\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Handling Temporal Updates with Validators in TypeScript\nDESCRIPTION: Shows how to define a Temporal Update using `wf.defineUpdate` and set its handler and optional validator using `wf.setHandler`. The handler mutates Workflow state (`language`) and returns a value (`previousLanguage`). The optional validator runs first to accept or reject the Update based on input validity (checking if `newLanguage` exists in `greetings`), preventing invalid state changes before the handler runs. Update handlers can be async, while validators must be synchronous.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// 👉 Use the object returned by defineUpdate to set the Update handler in\n// Workflow code, and to send Updates from Client code.\nexport const setLanguage = wf.defineUpdate<Language, [Language]>('setLanguage');\n\nexport async function greetingWorkflow(): Promise<string> {\n  const greetings: Partial<Record<Language, string>> = {\n    [Language.CHINESE]: '你好，世界',\n    [Language.ENGLISH]: 'Hello, world',\n  };\n\n  let language = Language.ENGLISH;\n\nwf.setHandler(\n    setLanguage,\n    (newLanguage: Language) => {\n      // 👉 An Update handler can mutate the Workflow state and return a value.\n      const previousLanguage = language;\n      language = newLanguage;\n      return previousLanguage;\n    },\n    {\n      validator: (newLanguage: Language) => {\n        // 👉 Update validators are optional\n        if (!(newLanguage in greetings)) {\n          throw new Error(`${newLanguage} is not supported`);\n        }\n      },\n    }\n  );\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker with Task Queue Configuration in TypeScript\nDESCRIPTION: This code demonstrates how to create a Worker in Temporal's TypeScript SDK, specifying a Task Queue and registering Workflows and Activities. The Worker connects to the Temporal server and begins accepting tasks on the specified queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  // Step 1: Register Workflows and Activities with the Worker and connect to\n  // the Temporal server.\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    activities,\n    taskQueue: 'hello-world',\n  });\n  // Worker connects to localhost by default and uses console.error for logging.\n  // Customize the Worker by passing more options to create():\n  // https://typescript.temporal.io/api/classes/worker.Worker\n  // If you need to configure server connection parameters, see docs:\n  // /typescript/security#encryption-in-transit-with-mtls\n\n  // Step 2: Start accepting tasks on the `tutorial` queue\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Return Values in Go with Temporal SDK\nDESCRIPTION: Shows how to structure return values from a Temporal Workflow using a combination of custom result objects and errors. Demonstrates how to handle errors and construct result objects.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage yourapp\n\nimport (\n    \"time\"\n\n    \"go.temporal.io/sdk/workflow\"\n)\n// ...\n\n// YourWorkflowResultObject is the object returned by the Workflow.\ntype YourWorkflowResultObject struct {\n    WFResultFieldX string\n    WFResultFieldY int\n}\n// ...\n// YourWorkflowDefinition is your custom Workflow Definition.\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\n// ...\n    if err != nil {\n        return nil, err\n    }\n    // Make the results of the Workflow Execution available.\n    workflowResult := &YourWorkflowResultObject{\n        WFResultFieldX: activityResult.ResultFieldX,\n        WFResultFieldY: activityResult.ResultFieldY,\n    }\n    return workflowResult, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Workflow Test using Time-Skipping Environment in TypeScript\nDESCRIPTION: This example demonstrates executing a Workflow test using the `TestWorkflowEnvironment` set up previously (`testEnv`). A Worker is created using the test environment's connection (`testEnv.nativeConnection`). The Workflow (`workflowFoo`) is started using the test client (`testEnv.client.workflow.execute`). Finally, `worker.runUntil()` runs the Worker process until the specific Workflow execution completes, allowing assertions on its result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Worker } from '@temporalio/worker';\nimport { v4 as uuid4 } from 'uuid';\nimport { workflowFoo } from './workflows';\n\ntest('workflowFoo', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    ...\n  });\n  const result = await worker.runUntil(\n    testEnv.client.workflow.execute(workflowFoo, {\n      workflowId: uuid4(),\n      taskQueue: 'test',\n    })\n  );\n  expect(result).toEqual('foo');\n});\n```\n\n----------------------------------------\n\nTITLE: Spawning a Synchronous Child Workflow from Parent Workflow in Java\nDESCRIPTION: Implementation of spawning a Child Workflow from a Parent Workflow using a synchronous call. This example shows both the Child Workflow interface definition and the Parent Workflow implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n@WorkflowMethod\nString composeGreeting(String greeting, String name);\n}\n// Child Workflow implementation not shown\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n@Override\npublic String getGreeting(String name) {\n    GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n    // This is a blocking call that returns only after child has completed.\n    return child.composeGreeting(\"Hello\", name );\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud with mTLS in Go SDK\nDESCRIPTION: Establishes a secure connection to Temporal Cloud using mTLS authentication. This code loads a certificate and private key from local files, configures TLS, and creates a client that connects to a specific Temporal Cloud Namespace. It demonstrates how to properly set up connection options for cloud environments with security requirements.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"log\"\n\n\t\"documentation-samples-go/cloud\"\n\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n\t// Get the key and cert from your env or local machine\n\tclientKeyPath := \"./secrets/yourkey.key\"\n\tclientCertPath := \"./secrets/yourcert.pem\"\n\t// Specify the host and port of your Temporal Cloud Namespace\n\t// Host and port format: namespace.unique_id.tmprl.cloud:port\n\thostPort := \"<yournamespace>.<id>.tmprl.cloud:7233\"\n\tnamespace := \"<yournamespace>.<id>\"\n\t// Use the crypto/tls package to create a cert object\n\tcert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to load cert and key pair.\", err)\n\t}\n\t// Add the cert to the tls certificates in the ConnectionOptions of the Client\n\ttemporalClient, err := client.Dial(client.Options{\n\t\tHostPort:  hostPort,\n\t\tNamespace: namespace,\n\t\tConnectionOptions: client.ConnectionOptions{\n\t\t\tTLS: &tls.Config{Certificates: []tls.Certificate{cert}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to connect to Temporal Cloud.\", err)\n\t}\n\tdefer temporalClient.Close()\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Time-Skipping Test Environment with Jest in TypeScript\nDESCRIPTION: This snippet shows the setup for a time-skipping test environment using `TestWorkflowEnvironment` from `@temporalio/testing`, suitable for frameworks like Jest or Mocha. `TestWorkflowEnvironment.createTimeSkipping()` initializes the in-memory test server. The environment is typically created once in a setup hook (`beforeAll`) and torn down in a cleanup hook (`afterAll`) to be reused across multiple tests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TestWorkflowEnvironment } from '@temporalio/testing';\n\nlet testEnv: TestWorkflowEnvironment;\n\n// beforeAll and afterAll are injected by Jest\nbeforeAll(async () => {\n  testEnv = await TestWorkflowEnvironment.createTimeSkipping();\n});\n\nafterAll(async () => {\n  await testEnv?.teardown();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Running a Workflow - Temporal Python SDK - Python\nDESCRIPTION: This snippet outlines how to define a Workflow using the Temporal Python SDK by decorating a class with @workflow.defn and an async run() method with @workflow.run. The run method accepts a string parameter and returns the result of executing an Activity with a specified timeout. Dependencies include the 'temporalio' library, and it assumes the existence of a compatible Activity implementation such as 'your_activity' and a parameters data class 'YourParams'. The method must be async and all parameters/return values must be serializable for Temporal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import workflow\n# ...\n# ...\n@workflow.defn(name=\\\"YourWorkflow\\\")\nclass YourWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            your_activity,\n            YourParams(\\\"Hello\\\", name),\n            start_to_close_timeout=timedelta(seconds=10),\n        )\n```\n\n----------------------------------------\n\nTITLE: Mocking Activity Context for Unit Testing in TypeScript\nDESCRIPTION: This snippet demonstrates how to unit test a Temporal Activity function (`activityFoo`) that accesses its context (`activityInfo`). It uses `MockActivityEnvironment` from `@temporalio/testing` to create a mock context, setting the `attempt` property. The `env.run()` method executes the Activity function within this mocked environment, allowing isolated testing without a running Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { activityInfo } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\n// A function that takes two numbers and returns a promise that resolves to the sum of the two numbers\n// and the current attempt.\nasync function activityFoo(a: number, b: number): Promise<number> {\n  return a + b + activityInfo().attempt;\n}\n\n// Create a MockActivityEnvironment with attempt set to 2. Run the activityFoo\n// function with parameters 5 and 35. Assert that the result is 42.\nconst env = new MockActivityEnvironment({ attempt: 2 });\nconst result = await env.run(activityFoo, 5, 35);\nassert.equal(result, 42);\n```\n\n----------------------------------------\n\nTITLE: Handling Different Types of Errors in Temporal Go SDK\nDESCRIPTION: This code demonstrates how to handle various error types returned from Activities in Temporal Workflows. It shows how to check for ApplicationError, CanceledError, TimeoutError, and PanicError using the errors.As() method, extract error details, and implement specific handling for different error conditions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/error-handling.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nerr := workflow.ExecuteActivity(ctx, YourActivity, ...).Get(ctx, nil)\nif err != nil {\n\tvar applicationErr *ApplicationError\n\tif errors.As(err, &applicationErr) {\n\t\t// retrieve error message\n\t\tfmt.Println(applicationError.Error())\n\n\t\t// handle Activity errors (created via NewApplicationError() API)\n\t\tvar detailMsg string // assuming Activity return error by NewApplicationError(\"message\", true, \"string details\")\n\t\tapplicationErr.Details(&detailMsg) // extract strong typed details\n\n\t\t// handle Activity errors (errors created other than using NewApplicationError() API)\n\t\tswitch applicationErr.Type() {\n\t\tcase \"CustomErrTypeA\":\n\t\t\t// handle CustomErrTypeA\n\t\tcase CustomErrTypeB:\n\t\t\t// handle CustomErrTypeB\n\t\tdefault:\n\t\t\t// newer version of Activity could return new errors that Workflow was not aware of.\n\t\t}\n\t}\n\n\tvar canceledErr *CanceledError\n\tif errors.As(err, &canceledErr) {\n\t\t// handle cancellation\n\t}\n\n\tvar timeoutErr *TimeoutError\n\tif errors.As(err, &timeoutErr) {\n\t\t// handle timeout, could check timeout type by timeoutErr.TimeoutType()\n        switch err.TimeoutType() {\n        case commonpb.ScheduleToStart:\n                // Handle ScheduleToStart timeout.\n        case commonpb.StartToClose:\n                // Handle StartToClose timeout.\n        case commonpb.Heartbeat:\n                // Handle heartbeat timeout.\n        default:\n        }\n\t}\n\n\tvar panicErr *PanicError\n\tif errors.As(err, &panicErr) {\n\t\t// handle panic, message and call stack are available by panicErr.Error() and panicErr.StackTrace()\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Activity Parameters in Go Workflow Test\nDESCRIPTION: This test shows how to replace an Activity implementation with a custom function to verify that the correct parameters are being passed to the Activity from the Workflow. It asserts that the input parameter matches the expected value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Temporal Development Server\nDESCRIPTION: Command to start the Temporal Development Server in development mode, which automatically starts the Web UI, creates the default Namespace, and uses an in-memory database.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Activity Completion in Java\nDESCRIPTION: This snippet shows an Activity implementation (`download`) that initiates an asynchronous operation (`asyncDownloadFileFromS3`). It retrieves the Activity's `taskToken` for later correlation and calls `ctx.doNotCompleteOnReturn()` to prevent the Activity from completing when the method returns. This allows completion to happen later, potentially in another process. Dependencies include `io.temporal.activity.Activity` and `io.temporal.activity.ActivityExecutionContext`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_36\n\nLANGUAGE: java\nCODE:\n```\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n\n    // Used to correlate reply\n    byte[] taskToken = ctx.getInfo().getTaskToken();\n\n    asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);\n    ctx.doNotCompleteOnReturn();\n\n    // Return value is ignored when doNotCompleteOnReturn was called.\n    return \"ignored\";\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Executing an Activity within a Workflow in Go\nDESCRIPTION: Shows how to start an Activity Execution from within a Temporal Workflow Definition using the Go SDK. It involves setting `workflow.ActivityOptions` (like `StartToCloseTimeout`), applying them to the context using `workflow.WithActivityOptions`, preparing the activity parameters (`YourActivityParam`), and then calling `workflow.ExecuteActivity`. The Activity function (`a.YourActivityDefinition`) is passed along with the context and parameters. The `.Get()` method is used to synchronously wait for the Activity result (`YourActivityResultObject`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\n    // Set the options for the Activity Execution.\n    // Either StartToClose Timeout OR ScheduleToClose is required.\n    // Not specifying a Task Queue will default to the parent Workflow Task Queue.\n    activityOptions := workflow.ActivityOptions{\n        StartToCloseTimeout: 10 * time.Second,\n    }\n    ctx = workflow.WithActivityOptions(ctx, activityOptions)\n    activityParam := YourActivityParam{\n        ActivityParamX: param.WorkflowParamX,\n        ActivityParamY: param.WorkflowParamY,\n    }\n    // Use a nil struct pointer to call Activities that are part of a struct.\n    var a *YourActivityObject\n    // Execute the Activity and wait for the result.\n    var activityResult YourActivityResultObject\n    err := workflow.ExecuteActivity(ctx, a.YourActivityDefinition, activityParam).Get(ctx, &activityResult)\n    if err != nil {\n        return nil, err\n    }\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronously Retrieving Workflow Results in Go\nDESCRIPTION: This snippet demonstrates how to wait for and retrieve the result of a Workflow Execution synchronously within the same process that started it. After calling `c.ExecuteWorkflow` and obtaining the `workflowRun` instance, the `Get()` method is called on `workflowRun`, passing a context and a pointer to a variable (`&result`) where the Workflow's return value will be stored. This call blocks until the Workflow completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_17\n\nLANGUAGE: go\nCODE:\n```\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrative Workflow Adding a Signal Handler (No Patch Needed)\nDESCRIPTION: This TypeScript code snippet contrasts with the previous example, showing a change (adding a new signal handler) that does *not* require patching, provided the signal ('updateValue') has never been sent to existing Workflow executions. The core execution path remains deterministic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await sleep('1 days');\n  return value;\n}\n\n// to v2\nconst updateValueSignal = defineSignal<[number]>('updateValue');\n\nexport async function yourWorkflow(value: number): Promise<number> {\n  setHandler(updateValueSignal, (newValue) => (value = newValue));\n\n  await sleep('1 days');\n  return value;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Workflow Parameters Data Class - Temporal Python SDK - Python\nDESCRIPTION: This snippet illustrates how to define a serializable data class for use as a parameter to a Workflow or Activity in the Temporal Python SDK. The @dataclass decorator is applied to facilitate easy serialization, and the class should include all fields needed by the Workflow or Activity. In this example, 'greeting' and 'name' fields are modeled as strings. Dependencies: Python 'dataclasses' standard library.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n# ...\n# ...\n@dataclass\nclass YourParams:\n    greeting: str\n    name: str\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow Interface in Java\nDESCRIPTION: Shows how to create a Workflow interface using the @WorkflowInterface annotation and define a Workflow method using the @WorkflowMethod annotation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface YourWorkflow {\n\n    @WorkflowMethod\n    String yourWFMethod(Arguments args);\n}\n```\n\n----------------------------------------\n\nTITLE: Completing an Asynchronous Activity Externally in Java\nDESCRIPTION: This snippet demonstrates how to complete an asynchronous Activity from outside the original Activity worker process. It uses the `ActivityCompletionClient`'s `complete` method, passing the `taskToken` obtained during the Activity execution and the final result. This is used when the asynchronous operation initiated by the Activity succeeds. Requires an instance of `ActivityCompletionClient`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_37\n\nLANGUAGE: java\nCODE:\n```\n  public <R> void completeActivity(byte[] taskToken, R result) {\n    completionClient.complete(taskToken, result);\n  }\n```\n\n----------------------------------------\n\nTITLE: Connecting and Executing Workflows with Temporal Python SDK - Python\nDESCRIPTION: This code demonstrates how to initialize a Temporal Client using the Python SDK and start a Workflow Execution on a local development Temporal Service. It uses the asynchronous `Client.connect()` method to connect to the default local Temporal server endpoint and executes a workflow with specified ID and task queue. Required dependencies include the `temporalio.client.Client` class and `asyncio` for asynchronous execution; customize 'YourWorkflow.run' to match your Workflow definition. Outputs the workflow execution result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/temporal-clients.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n\\n    result = await client.execute_workflow(\\n        YourWorkflow.run,\\n        \"your name\",\\n        id=\"your-workflow-id\",\\n        task_queue=\"your-task-queue\",\\n    )\\n\\n    print(f\"Result: {result}\")\\n\\n\\nif __name__ == \"__main__\":\\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Executing a Temporal Workflow in Go\nDESCRIPTION: This snippet shows the basic structure for initiating a Workflow Execution using the Temporal Go SDK. It calls the `ExecuteWorkflow` method on the client (`c`), passing the context, workflow options (`workflowOptions`), the Workflow definition function (`app.YourWorkflowDefinition`), and any required parameters (`param`). The call returns a `WorkflowRun` instance representing the started execution and an error object.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_16\n\nLANGUAGE: go\nCODE:\n```\n```go\n workflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, app.YourWorkflowDefinition, param)\n if err != nil {\n   // ...\n }\n // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity Heartbeat with Checkpointing in Temporal TypeScript SDK\nDESCRIPTION: This snippet shows how to use heartbeat details for checkpointing in an Activity. If the Activity times out and gets retried, it can resume from the last checkpoint rather than starting from the beginning, which is more efficient for long-running activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function myActivity(): Promise<void> {\n  // Resume work from latest heartbeat, if there's one, or start from 1 otherwise\n  const startingPoint = activityInfo().heartbeatDetails?.progress ?? 1;\n\n  for (let progress = startingPoint; progress <= 1000; ++progress) {\n    // Do something that takes time\n    await sleep('1s');\n\n    heartbeat({ progress });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Update Handlers and Validators in Temporal Python Workflows - Python\nDESCRIPTION: This snippet details how to implement an Update handler and its validator in a Temporal Python Workflow. The Update handler mutates state and returns the previous value, while its validator method can reject the Update based on business logic by raising exceptions. Both use the appropriate decorators. Dependencies include the Temporal Python SDK, enums, and correct method signatures. The validator enhances Workflow safety by pre-validating state-changing updates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Language(IntEnum):\n    Chinese = 1\n    English = 2\n    French = 3\n\n@workflow.defn\nclass GreetingWorkflow:\n    ...\n    @workflow.update\n    def set_language(self, language: Language) -> Language:\n        # \\ud83d\\udc49 An Update handler can mutate the Workflow state and return a value.\n        previous_language, self.language = self.language, language\n        return previous_language\n\n    @set_language.validator\n    def validate_language(self, language: Language) -> None:\n        if language not in self.greetings:\n            # \\ud83d\\udc49 In an Update validator you raise any exception to reject the Update.\n            raise ValueError(f\"{language.name} is not supported\")\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous Nexus Operation Handler in Go\nDESCRIPTION: Go code that implements an asynchronous Nexus Operation handler using temporalnexus.NewWorkflowRunOperation. This example starts a Workflow as part of the Operation, using the request ID as the Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// ...\nvar HelloOperation = temporalnexus.NewWorkflowRunOperation(service.HelloOperationName, HelloHandlerWorkflow, func(ctx context.Context, input service.HelloInput, options nexus.StartOperationOptions) (client.StartWorkflowOptions, error) {\n\treturn client.StartWorkflowOptions{\n\t\t// Workflow IDs should typically be business meaningful IDs and are used to dedupe workflow starts.\n\t\t// For this example, we're using the request ID allocated by Temporal when the caller workflow schedules\n\t\t// the operation, this ID is guaranteed to be stable across retries of this operation.\n\t\tID: options.RequestID,\n\t\t// Task queue defaults to the task queue this operation is handled on.\n\t}, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Retry Policy using Temporal Python SDK\nDESCRIPTION: Illustrates how to define a custom Retry Policy for an Activity Execution using the `retry_policy` parameter within `workflow.execute_activity`. This example configures a `RetryPolicy` with parameters like `backoff_coefficient`, `maximum_attempts`, `initial_interval`, and `maximum_interval`. If no custom policy is provided, Activities use a default Retry Policy. Dependencies include `temporalio.common.RetryPolicy` and `datetime.timedelta`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.common import RetryPolicy\n# ...\n        activity_result = await workflow.execute_activity(\n            your_activity,\n            YourParams(greeting, \"Retry Policy options\"),\n            start_to_close_timeout=timedelta(seconds=10),\n            # Retry Policy\n            retry_policy=RetryPolicy(\n                backoff_coefficient=2.0,\n                maximum_attempts=5,\n                initial_interval=timedelta(seconds=1),\n                maximum_interval=timedelta(seconds=2),\n                # non_retryable_error_types=[\"ValueError\"],\n            ),\n        )\n```\n\n----------------------------------------\n\nTITLE: Setting Parent Close Policy for Child Workflows in Java\nDESCRIPTION: Example of setting a Parent Close Policy for a Child Workflow using ChildWorkflowOptions. This demonstrates how to configure the ABANDON policy and ensure the Child Workflow starts before the parent completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n public void parentWorkflow() {\n     ChildWorkflowOptions options =\n        ChildWorkflowOptions.newBuilder()\n            .setParentClosePolicy(ParentClosePolicy.PARENT_CLOSE_POLICY_ABANDON)\n            .build();\n     MyChildWorkflow child = Workflow.newChildWorkflowStub(MyChildWorkflow.class, options);\n     Async.procedure(child::<workflowMethod>, <args>...);\n     Promise<WorkflowExecution> childExecution = Workflow.getWorkflowExecution(child);\n     // Wait for child to start\n     childExecution.get()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Selectors in Temporal Go SDK Workflow\nDESCRIPTION: Complete example of using Selector API in a Temporal Workflow, showing how to create a selector, add Futures from Activities, receive information from Channels, and block execution until a Future is ready.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/selectors.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc SampleWorkflow(ctx workflow.Context) error {\n\t// standard Workflow setup code omitted...\n\n\t// API Example: declare a new selector\n\tselector := workflow.NewSelector(ctx)\n\n\t// API Example: defer code execution until the Future that represents Activity result is ready\n\twork := workflow.ExecuteActivity(ctx, ExampleActivity)\n\tselector.AddFuture(work, func(f workflow.Future) {\n\t\t// deferred code omitted...\n\t})\n\n\t// more parallel timers and activities initiated...\n\n\t// API Example: receive information from a Channel\n\tvar signalVal string\n\tchannel := workflow.GetSignalChannel(ctx, channelName)\n\tselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\t\t// matching on the channel doesn't consume the message.\n\t \t// So it has to be explicitly consumed here\n\t\tc.Receive(ctx, &signalVal)\n\t\t// do something with received information\n\t})\n\n\t// API Example: block until the next Future is ready to run\n\t// important! none of the deferred code runs until you call selector.Select\n\tselector.Select(ctx)\n\n\t// Todo: document selector.HasPending\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Parameters in Go with Temporal SDK\nDESCRIPTION: Demonstrates how to define Workflow parameters using a struct type for better backward compatibility. Shows the required workflow.Context parameter and custom parameter structs that must be serializable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage yourapp\n\nimport (\n    \"time\"\n\n    \"go.temporal.io/sdk/workflow\"\n)\n\n// YourWorkflowParam is the object passed to the Workflow.\ntype YourWorkflowParam struct {\n    WorkflowParamX string\n    WorkflowParamY int\n}\n// ...\n// YourWorkflowDefinition is your custom Workflow Definition.\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (*YourWorkflowResultObject, error) {\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Executing a Temporal Workflow and Activity in Go\nDESCRIPTION: This snippet defines a Go Workflow function (LoanApplication) and a related Activity (NotifyApplicantActivity) designed for execution by a Temporal Worker. The Workflow configures Activity execution options (notably a 1-minute StartToCloseTimeout), then executes the Activity asynchronously and waits for its result with f.Get. The Activity function encapsulates a third-party API call and returns a structured result, with the Workflow handling both success and error paths. To function, this code requires the Temporal Go SDK, proper Activity and Workflow registration, and the definitions of context, input/output structures, and error-handling logic. It illustrates usage relevant to running reliable, replayable workflows in distributed systems.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc LoanApplication(ctx workflow.Context, input *LoanApplicationWorkflowInput) (*LoanApplicationWorkflowResult, error) {\n\n\tctx = workflow.WithActivityOptions(ctx, workflow.ActivityOptions{\n\t\tStartToCloseTimeout: time.Minute,\n\t})\n\n\tvar result activities.NotifyApplicantActivityResult\n\tf := workflow.ExecuteActivity(ctx, a.NotifyApplicantActivity, NotifyApplicantActivityInput(*input))\n\n\terr := f.Get(ctx, &result)\n\n\t// Return the results\n\treturn &l.LoanApplicationState, nil\n}\n\ntype Activities struct {}\n\nfunc (a *Activities) NotifyApplicantActivity(ctx context.Context, input *NotifyApplicantActivityInput) (*NotifyApplicantActivityResult, error) {\n\tvar result NotifyApplicantActivityResult\n\n\t// Call the thirdparty API and handle the result\n\n\treturn &result, err\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring EnableSessionWorker for Temporal Worker in Go\nDESCRIPTION: Enables the Session feature for the Activity Worker. When `true`, the Worker sequentially processes Activity Tasks belonging to the same Session on the specified Task Queue. The type is `bool`, and the default is `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_42\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    EnableSessionWorker: true,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud in PHP\nDESCRIPTION: This code shows how to configure a client connection to Temporal Cloud using SSL and custom namespace settings in the PHP SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Client\\ClientOptions;\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$serviceClient = \\Temporal\\Client\\GRPC\\ServiceClient::createSSL(\n    address: '<your-custom-namespace>.tmprl.cloud:7233',\n    // crt: 'certs/server-root-ca-cert.pem', # ROOT CA to validate the server cert\n    clientKey: 'certs/client-private-key.pem',\n    clientPem: 'certs/client-cert.pem',\n    // overrideServerName: 'tls-sample',\n);\n\n$workflowClient = WorkflowClient::create(\n    serviceClient: $serviceClient,\n    options: (new ClientOptions())\n        ->withNamespace('<your-custom-namespace>.<id>'),\n);\n```\n\n----------------------------------------\n\nTITLE: Proper Proxying of Activities in Workflows Using proxyActivities - Temporal TypeScript SDK\nDESCRIPTION: Presents the correct approach to use Activities within Workflow code in the Temporal TypeScript SDK: importing only the type definitions and instantiating proxies using proxyActivities. Ensures determinism by delegating side-effect-prone operations outside the Workflow isolate. Requires the '@temporalio/workflow' package and Activity type imports. Input is a URL string, output is the awaited result from the proxied Activity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { proxyActivities } from '@temporalio/workflow';\\n\\nimport type * as activities from './activities';\\nconst { makeHTTPRequest } = proxyActivities<typeof activities>();\\n\\nexport async function yourWorkflow(): Promise<string> {\\n  return await makeHTTPRequest('https://temporal.io');\\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Temporal Workflow with Parameters in TypeScript\nDESCRIPTION: Shows how to start a Workflow execution using the Temporal Client in a `client.ts` file. It calls `client.workflow.start` with the Workflow function reference (`example`), an `args` array containing an object with `name` and `born` properties, the target `taskQueue`, and a unique `workflowId`. This initiates the Workflow execution with the specified inputs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nimport { example } from './workflows';\n\n...\nawait client.workflow.start(example, {\n  args: [{ name: 'Temporal', born: 2019 }],\n  taskQueue: 'your-queue',\n  workflowId: 'business-meaningful-id',\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Requesting Workflow Cancellation in .NET\nDESCRIPTION: Demonstrates how to cancel a Workflow Execution using the WorkflowHandle's CancelAsync method. Shows how to get a workflow handle and initiate cancellation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/cancellation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar handle = myClient.GetWorkflowHandle(\"my-workflow-id\");\nawait handle.CancelAsync();\n```\n\n----------------------------------------\n\nTITLE: Listening to Activity Heartbeats in TypeScript Tests\nDESCRIPTION: This example shows how to verify Activity heartbeats during tests using `MockActivityEnvironment`. The environment emits a `heartbeat` event whenever the tested Activity (`activityFoo`) calls `heartbeat()`. An event listener is attached using `env.on('heartbeat', ...)` to assert the details sent with the heartbeat. Note that `MockActivityEnvironment` does not throttle heartbeats.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { heartbeat } from '@temporalio/activity';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  heartbeat(6);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait env.run(activityFoo);\n```\n\n----------------------------------------\n\nTITLE: Defining and Handling Temporal Queries in TypeScript\nDESCRIPTION: Demonstrates defining a Temporal Query using `wf.defineQuery` and setting its handler within a Workflow using `wf.setHandler`. The handler synchronously retrieves Workflow state (available languages based on an input parameter) and returns it. It highlights that Query handlers must not mutate state or perform async operations. Defines necessary types like `Language` enum and `GetLanguagesInput` interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport enum Language {\n  ARABIC = 'ARABIC',\n  CHINESE = 'CHINESE',\n  ENGLISH = 'ENGLISH',\n  FRENCH = 'FRENCH',\n  HINDI = 'HINDI',\n  PORTUGUESE = 'PORTUGUESE',\n  SPANISH = 'SPANISH',\n}\n\ninterface GetLanguagesInput {\n  includeUnsupported: boolean;\n}\n\n// 👉 Use the object returned by defineQuery to set the query handler in\n// Workflow code, and when sending the Query in Client code.\nexport const getLanguages = wf.defineQuery<Language[], [GetLanguagesInput]>('getLanguages');\n\nexport async function greetingWorkflow(): Promise<string> {\n  const greetings: Partial<Record<Language, string>> = {\n    [Language.CHINESE]: '你好，世界',\n    [Language.ENGLISH]: 'Hello, world',\n  };\n\n  wf.setHandler(getLanguages, (input: GetLanguagesInput): Language[] => {\n    // 👉 A Query handler returns a value: it must not mutate the Workflow state\n    // and can't perform async operations.\n    if (input.includeUnsupported) {\n      return Object.values(Language);\n    } else {\n      return Object.keys(greetings) as Language[];\n    }\n  });\n\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting TaskQueue using Temporal Java SDK\nDESCRIPTION: This Java snippet shows how to specify the TaskQueue in WorkflowOptions when setting up a workflow stub. By using the WorkflowOptions.Builder.setTaskQueue method, the workflow execution can be directed to a specific worker group. The snippet relies on the Temporal Java SDK and definitions for the workflow interface and task queue constants. The TaskQueue string determines which worker processes tasks for this workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_12\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\\nYourWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"YourWF\\\")\\n                // Set the Task Queue\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from a Client to a Workflow in Temporal TypeScript\nDESCRIPTION: Example showing how to send a Signal to a Workflow from a Temporal Client using WorkflowHandle.signal. The signal is sent asynchronously and returns when the server accepts it, not when it's delivered to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nawait handle.signal(greetingWorkflow.approve, { name: 'me' });\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Handler in Go Workflow\nDESCRIPTION: Demonstrates how to set up a Query handler that returns supported languages based on input parameters. Shows proper usage of workflow.SetQueryHandler for synchronous state retrieval.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Language string\n\nconst Chinese Language = \"chinese\"\nconst English Language = \"english\"\nconst French Language = \"french\"\nconst Spanish Language = \"spanish\"\nconst Portuguese Language = \"portuguese\"\n\nconst GetLanguagesQuery = \"GetLanguages\"\n\ntype GetLanguagesInput struct {\n\tIncludeUnsupported bool\n}\n\nfunc GreetingWorkflow(ctx workflow.Context) (string, error) {\n    ...\n    greeting := map[Language]string{English: \"Hello\", Chinese: \"你好，世界\"}\n    err := workflow.SetQueryHandler(ctx, GetLanguagesQuery, func(input GetLanguagesInput) ([]Language, error) {\n        if input.IncludeUnsupported {\n            return []Language{Chinese, English, French, Spanish, Portuguese}, nil\n        } else {\n            return maps.Keys(greeting), nil\n        }\n    })\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Skipping Time in Workflow Tests using WorkflowEnvironment in Python\nDESCRIPTION: Shows how to set up a Temporal test environment for manual time skipping using `WorkflowEnvironment.start_time_skipping()`. Within the async context manager provided by this method, test code can manually advance the Workflow's perception of time using `env.sleep(seconds)`. This is useful for testing logic dependent on sleeps or timers without waiting for the actual duration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/testing-suite.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.testing import WorkflowEnvironment\n\nasync def test_manual_time_skipping():\n    async with await WorkflowEnvironment.start_time_skipping() as env:\n        # Your code here\n        # You can use the env.sleep(seconds) method to manually advance time\n        await env.sleep(3) # This will advance time by 3 seconds\n        # Your code here\n```\n\n----------------------------------------\n\nTITLE: Mocking Activity Failure in Go Workflow Test\nDESCRIPTION: This test demonstrates how to mock an Activity to simulate a failure scenario. It sets up the Activity mock to return an error and then verifies that the Workflow properly handles and propagates the error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Return Values with Promises in TypeScript\nDESCRIPTION: Illustrates how to define the return value of a TypeScript Workflow function using a `Promise`. The `example` function is defined with a return type of `Promise<string>`, indicating it will asynchronously return a string result upon completion. Workflow return values must be serializable, and Promises are used to handle the asynchronous nature of Workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Looping Workflow with continueAsNew in TypeScript\nDESCRIPTION: This TypeScript Workflow function, `loopingWorkflow`, demonstrates the Continue-As-New pattern. It runs iteratively, logging the current iteration number and pausing for 1 second. If the iteration count reaches 10, it completes normally. Otherwise, it calls `continueAsNew` with the incremented iteration count, effectively restarting the Workflow with the same Workflow Id but a new Run Id and a fresh event history. This requires the `continueAsNew`, `log`, and `sleep` functions from the `@temporalio/workflow` package. Note that code after `continueAsNew` is unreachable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { continueAsNew, log, sleep } from '@temporalio/workflow';\n\nexport async function loopingWorkflow(iteration = 0): Promise<void> {\n  if (iteration === 10) {\n    return;\n  }\n  log.info('Running Workflow iteration', { iteration });\n  await sleep(1000);\n  // Must match the arguments expected by `loopingWorkflow`\n  await continueAsNew<typeof loopingWorkflow>(iteration + 1);\n  // Unreachable code, continueAsNew is like `process.exit` and will stop execution once called.\n}\n```\n\n----------------------------------------\n\nTITLE: Racing Timers for Dynamic Delays in TypeScript Workflows\nDESCRIPTION: Demonstrates using `Promise.race` with a Temporal `sleep` timer and another promise (e.g., order processing). If the timer completes before the other promise, a specific action (like sending a notification email) is taken. This allows dynamically adjusting behavior based on processing time.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nexport async function processOrderWorkflow({\n  orderProcessingMS,\n  sendDelayedEmailTimeoutMS,\n}: ProcessOrderOptions): Promise<void> {\n  let processing = true;\n  const processOrderPromise = processOrder(orderProcessingMS).then(() => {\n    processing = false;\n  });\n\n  await Promise.race([processOrderPromise, sleep(sendDelayedEmailTimeoutMS)]);\n\n  if (processing) {\n    await sendNotificationEmail();\n    await processOrderPromise;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring an Activity Retry Policy in PHP\nDESCRIPTION: This snippet demonstrates setting a custom Retry Policy for an Activity using `ActivityOptions` and `RetryOptions` in the Temporal PHP SDK. It configures the Schedule-To-Close timeout, initial retry interval, maximum attempts, and specifies non-retryable exceptions. Dependencies include the Temporal PHP SDK (`Workflow`, `ActivityOptions`, `RetryOptions`), Carbon (`CarbonInterval`), and the specified exception class (`InvalidArgumentException`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(10))\n        ->withRetryOptions(\n            RetryOptions::new()\n                ->withInitialInterval(CarbonInterval::seconds(1))\n                ->withMaximumAttempts(5)\n                ->withNonRetryableExceptions([\\InvalidArgumentException::class])\n        )\n);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Queryable Progress Workflow in Temporal Go\nDESCRIPTION: Defines a Workflow function that tracks progress as a percentage, incrementing it once per second using Temporal's workflow.Sleep for time simulation. The Workflow registers a query handler ('getProgress') that allows querying the current percentage via Temporal's query mechanism. Dependencies include the Temporal Go SDK (workflow package), with key parameters being the workflow context and initial percent value. The handler returns the percentage completed, and expected outputs are progress values or errors; use only within the Temporal workflow context and test environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc ProgressWorkflow(ctx workflow.Context, percent int) error {\n\tlogger := workflow.GetLogger(ctx)\n\n\terr := workflow.SetQueryHandler(ctx, \"getProgress\", func(input []byte) (int, error) {\n\t\treturn percent, nil\n\t})\n\tif err != nil {\n\t\tlogger.Info(\"SetQueryHandler failed.\", \"Error\", err)\n\t\treturn err\n\t}\n\n\tfor percent = 0; percent<100; percent++ {\n                // Important! Use `workflow.Sleep()`, not `time.Sleep()`, because Temporal's\n                // test environment doesn't stub out `time.Sleep()`.\n\t\tworkflow.Sleep(ctx, time.Second*1)\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Simple Workflow Using a Standard Server in xUnit\nDESCRIPTION: This test demonstrates how to test a Workflow using a standard local server environment. It creates a worker with the SayHelloWorkflow, executes the workflow, and verifies the result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Testing;\nusing Temporalio.Worker;\n\n[Fact]\npublic async Task SayHelloWorkflow_SimpleRun_Succeeds()\n{\n    // Start local dev server\n    await using var env = await WorkflowEnvironment.StartLocalAsync();\n\n    // Create a worker\n    using var worker = new TemporalWorker(\n      env.Client,\n      new TemporalWorkerOptions($\"task-queue-{Guid.NewGuid()}\").\n          AddWorkflow<SayHelloWorkflow>());\n\n    // Run the worker only for the life of the code within\n    await worker.ExecuteAsync(async () =>\n    {\n        // Execute the workflow and confirm the result\n        var result = await env.Client.ExecuteWorkflowAsync(\n            (SayHelloWorkflow wf) => wf.RunAsync(\"Temporal\"),\n            new(id: $\"wf-{Guid.NewGuid()}\", taskQueue: worker.Options.TaskQueue!));\n        Assert.Equal(\"Hello, Temporal!\", result);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Completion Result in a Cron Workflow (Go)\nDESCRIPTION: This snippet demonstrates how a Temporal Cron Workflow in Go can access the result of its previous successful run. Inside the Workflow definition, it uses `workflow.HasLastCompletionResult(ctx)` to check if a previous result exists and `workflow.GetLastCompletionResult(ctx, &lastResult)` to retrieve it into the `lastResult` variable. This allows subsequent runs to build upon the state or output of prior runs, even if intermittent failures occurred.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_19\n\nLANGUAGE: go\nCODE:\n```\n```go\ntype CronResult struct {\n Count int\n}\n\nfunc YourCronWorkflowDefinition(ctx workflow.Context) (CronResult, error) {\n count := 1\n\n if workflow.HasLastCompletionResult(ctx) {\n   var lastResult CronResult\n   if err := workflow.GetLastCompletionResult(ctx, &lastResult); err == nil {\n     count = count + lastResult.Count\n   }\n }\n\n newResult := CronResult {\n   Count: count,\n }\n return newResult, nil\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Continue-As-New in a Temporal Go Workflow\nDESCRIPTION: Example showing how to implement Continue-As-New in a Temporal Workflow function. The function returns a ContinueAsNewError to close the current execution and start a new one with the same parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc SimpleWorkflow(ctx workflow.Context, value string) error {\n    ...\n    return workflow.NewContinueAsNewError(ctx, SimpleWorkflow, value)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Activity Cancellation Handling in TypeScript\nDESCRIPTION: This snippet illustrates testing an Activity's response to cancellation requests. It uses `MockActivityEnvironment` and its `.cancel()` method to trigger cancellation during the Activity's execution. The example tests an Activity (`activityFoo`) that uses the cancellation-aware `sleep()` function. The test asserts that a `CancelledFailure` is thrown when `env.cancel()` is implicitly called by `env.run`'s rejection handling, confirming the Activity reacted correctly.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { CancelledFailure, heatbeat, sleep } from '@temporalio/activity';\nimport { MockActivityEnvironment } from '@temporalio/testing';\nimport assert from 'assert';\n\nasync function activityFoo(): Promise<void> {\n  heartbeat(6);\n  // @temporalio/activity's sleep() is Cancellation-aware, which means that on Cancellation,\n  // CancelledFailure will be thrown from it.\n  await sleep(100);\n}\n\nconst env = new MockActivityEnvironment();\n\nenv.on('heartbeat', (d: unknown) => {\n  assert(d === 6);\n});\n\nawait assert.rejects(env.run(activityFoo), (err) => {\n  assert.ok(err instanceof CancelledFailure);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Interface in Java\nDESCRIPTION: Example of defining an Activity interface using the @ActivityInterface annotation in Java. This interface declares a method for composing a greeting.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface\npublic interface GreetingActivities {\n    String composeGreeting(String greeting, String language);\n}\n```\n\n----------------------------------------\n\nTITLE: Starting an Asynchronous Update from a Temporal Client in Python\nDESCRIPTION: This snippet demonstrates sending an Update asynchronously using `WorkflowHandle.start_update`. It initiates the Update and waits only until the Worker accepts it (specified by `wait_for_stage=client.WorkflowUpdateStage.ACCEPTED`), returning an `UpdateHandle`. The result can be retrieved later by calling `await update_handle.result()`. This is suitable when the Update handler performs long-running operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n```python\n# Wait until the update is accepted\nupdate_handle = await workflow_handle.start_update(\n    HelloWorldWorkflow.set_greeting,\n    HelloWorldInput(\"World\"),\n    wait_for_stage=client.WorkflowUpdateStage.ACCEPTED,\n)\n# Wait until the update is completed\nupdate_result = await update_handle.result()\n```\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Retrieving Workflow Results in Go\nDESCRIPTION: This snippet shows how to retrieve the result of a potentially completed Workflow Execution from a different process or at a later time. It uses the `GetWorkflow` method on the Temporal client (`c`), providing the context and the `workflowID` of the target execution. This returns a `WorkflowRun` instance, on which `Get()` can then be called with a pointer (`&result`) to fetch the result. This method requires knowing the Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_18\n\nLANGUAGE: go\nCODE:\n```\n```go\n // ...\n workflowID := \"Your-Custom-Workflow-Id\"\n workflowRun := c.GetWorkflow(context.Background, workflowID)\n\n var result YourWorkflowResponse\n err = workflowRun.Get(context.Background(), &result)\n if err != nil {\n     // ...\n }\n // ...\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow Interface Using Temporal PHP SDK (PHP)\nDESCRIPTION: This snippet defines a Workflow interface in PHP using the Temporal SDK's attribute-based model. The interface, annotated with #[WorkflowInterface], includes a single method processFile, which is annotated with #[WorkflowMethod] to indicate it is the Workflow entrypoint. The method accepts an Argument object as input, a recommended pattern for extensibility and backward compatibility. This code requires the Temporal\\Workflow\\WorkflowMethod and Temporal\\Workflow\\YourWorkflowInterface classes, and all parameters must be serializable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\\\Workflow\\\\YourWorkflowInterface;\nuse Temporal\\\\Workflow\\\\WorkflowMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Synchronous Nexus Operation Handler in Go\nDESCRIPTION: Go code that implements a synchronous Nexus Operation handler using nexus.NewSyncOperation. This example creates a simple echo RPC handler that returns the input as output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// ...\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/nexus-rpc/sdk-go/nexus\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/temporalnexus\"\n\t\"go.temporal.io/sdk/workflow\"\n\n\t\"github.com/temporalio/samples-go/nexus/service\"\n)\n\n// NewSyncOperation is a meant for exposing simple RPC handlers.\nvar EchoOperation = nexus.NewSyncOperation(service.EchoOperationName, func(ctx context.Context, input service.EchoInput, options nexus.StartOperationOptions) (service.EchoOutput, error) {\n\t// Use temporalnexus.GetClient to get the client that the worker was initialized with to perform client calls\n\t// such as signaling, querying, and listing workflows. Implementations are free to make arbitrary calls to other\n\t// services or databases, or perform simple computations such as this one.\n\treturn service.EchoOutput(input), nil\n})\n```\n\n----------------------------------------\n\nTITLE: Recording Activity Heartbeat in Go\nDESCRIPTION: This snippet demonstrates how to record a heartbeat within an Activity definition using the Temporal Go SDK. It imports the necessary package and uses the RecordHeartbeat function to send a heartbeat with optional details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    // ...\n    \"go.temporal.io/sdk/workflow\"\n    // ...\n)\n\nfunc YourActivityDefinition(ctx, YourActivityDefinitionParam) (YourActivityDefinitionResult, error) {\n    // ...\n    activity.RecordHeartbeat(ctx, details)\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution with TypeScript Client\nDESCRIPTION: Shows how to start a Workflow Execution using the Temporal TypeScript Client. The example demonstrates specifying workflowId, taskQueue, and arguments, then retrieving the result once the Workflow completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  workflowId: 'your-workflow-id',\n  taskQueue: 'your-task-queue',\n  args: ['argument01', 'argument02', 'argument03'], // this is typechecked against workflowFn's args\n});\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud with TLS using Temporal TypeScript SDK\nDESCRIPTION: This snippet shows how to connect to Temporal Cloud securely using the TypeScript SDK. It demonstrates reading client certificates from file for mTLS, conditionally assembling connection options, and then creating a secure connection before initializing the Temporal Client. Replace file paths and namespace details as needed. Required dependencies: '@temporalio/client', 'fs-extra', valid mTLS certificates, and access to a Temporal Cloud namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Client, Connection } from '@temporalio/client';\nimport fs from 'fs-extra';\n\nconst { NODE_ENV = 'development' } = process.env;\nconst isDeployed = ['production', 'staging'].includes(NODE_ENV);\n\nasync function run() {\n  const cert = await fs.readFile('./path-to/your.pem');\n  const key = await fs.readFile('./path-to/your.key');\n\n  let connectionOptions = {};\n  if (isDeployed) {\n    connectionOptions = {\n      address: 'your-namespace.tmprl.cloud:7233',\n      tls: {\n        clientCertPair: {\n          crt: cert,\n          key,\n        },\n      },\n    };\n\n    const connection = await Connection.connect(connectionOptions);\n\n    const client = new Client({\n      connection,\n      namespace: 'your-namespace',\n    });\n\n    // . . .\n\n    await client.connection.close();\n  }\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a Temporal Worker in Go\nDESCRIPTION: An example of how to initialize a Temporal Worker using the Go SDK. This code creates a client, sets up a Worker, registers a Workflow and an Activity, and starts the Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    // Create the client object just once per process\n    c, err := client.NewClient(client.Options{})\n    if err != nil {\n        log.Fatalln(\"Unable to create Temporal client\", err)\n    }\n    defer c.Close()\n\n    // Create the Worker instance\n    w := worker.New(c, \"loan-application-task-queue\", worker.Options{})\n\n    // Register the workflow and activity with the worker\n    w.RegisterWorkflow(LoanApplicationWorkflow)\n    w.RegisterActivity(LoanCreditCheck)\n\n    // Start listening to the Task Queue\n    err = w.Run(worker.InterruptCh())\n    if err != nil {\n        log.Fatalln(\"Unable to start Worker\", err)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Type via Function Name in TypeScript\nDESCRIPTION: Demonstrates that in the Temporal TypeScript SDK, the Workflow Type is implicitly set to the name of the exported async function. The example shows a simple Workflow function `helloWorld` defined in `snippets/src/workflows.ts`, whose Workflow Type will automatically be registered as \"helloWorld\". The function returns a simple greeting string wrapped in a Promise.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport async function helloWorld(): Promise<string> {\n  return '👋 Hello World!';\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Activity Heartbeats with ActivityEnvironment in Python\nDESCRIPTION: Demonstrates how to test an Activity that sends heartbeats using `temporalio.testing.ActivityEnvironment`. It captures heartbeats emitted via `activity.heartbeat()` by setting a callback function on the `env.on_heartbeat` property. This allows isolated testing and verification of the Activity's heartbeat logic without needing a full Worker setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/testing-suite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@activity.defn\nasync def activity_with_heartbeats(param: str):\n    activity.heartbeat(f\"param: {param}\")\n    activity.heartbeat(\"second heartbeat\")\n\nenv = ActivityEnvironment()\nheartbeats = []\n# Set the `on_heartbeat` property to a callback function that will be called for each Heartbeat sent by the Activity.\nenv.on_heartbeat = lambda *args: heartbeats.append(args[0])\n# Use the run method to start the Activity, passing in the function that contains the Heartbeats and any necessary parameters.\nawait env.run(activity_with_heartbeats, \"test\")\n# Verify that the expected Heartbeats are received by the callback function.\nassert heartbeats == [\"param: test\", \"second heartbeat\"]\n```\n\n----------------------------------------\n\nTITLE: Spawning a Child Workflow Execution - Temporal Python SDK\nDESCRIPTION: This Python snippet demonstrates declaring two workflow classes and running a child workflow from the parent using Temporal's execute_child_workflow function. Dependencies include the temporalio Python SDK, appropriate workflow type definitions, and ComposeGreetingInput. The ComposeGreetingWorkflow class defines a basic greeting task, and the GreetingWorkflow class calls it as a child, supplying custom arguments. Input parameters for child workflow construction and execution are supplied, and the function will return the result string of the child workflow's successful completion. This pattern ensures the parent waits for the child workflow to start and complete before proceeding.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\n@workflow.defn\nclass ComposeGreetingWorkflow:\n    @workflow.run\n    async def run(self, input: ComposeGreetingInput) -> str:\n        return f\"{input.greeting}, {input.name}!\"\n\n\n@workflow.defn\nclass GreetingWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_child_workflow(\n            ComposeGreetingWorkflow.run,\n            ComposeGreetingInput(\"Hello\", name),\n            id=\"hello-child-workflow-workflow-child-id\",\n# ...\n        )\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker with Task Queue in Temporal TypeScript\nDESCRIPTION: This snippet demonstrates the minimal code needed to create a Worker with a specified Task Queue. The Worker will poll this Task Queue for tasks to execute, and must be provided with the activities it should run.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining an Activity Function - Temporal Python SDK - Python\nDESCRIPTION: This snippet demonstrates defining an asynchronous Activity for use within a Temporal Workflow. The function is decorated with @activity.defn using a custom name, accepts input parameters encapsulated in a data class (YourParams), and returns a formatted greeting string. This approach supports parameter serialization and seamless Activity execution from within Workflows. The 'temporalio' library is required, and Activities should avoid blocking the event loop.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import activity\n# ...\n# ...\n@activity.defn(name=\\\"your_activity\\\")\nasync def your_activity(input: YourParams) -> str:\n    return f\\\"{input.greeting}, {input.name}!\\\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Activity Results with Blocking Get()\nDESCRIPTION: Example showing how to get Activity Execution results using the blocking Get() method on workflow.Future. The code demonstrates proper error handling and type matching for the result parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n var yourActivityResult YourActivityResult\n if err := future.Get(ctx, &yourActivityResult); err != nil {\n   // ...\n }\n // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Update Handler with Activity Execution\nDESCRIPTION: Example of an async Update handler that executes an Activity to fetch greetings in different languages. Includes lock implementation for handling concurrent updates and error handling for unsupported languages.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@activity.defn\nasync def call_greeting_service(to_language: Language) -> Optional[str]:\n    await asyncio.sleep(0.2)  # Pretend that we are calling a remote service.\n    greetings = {\n        Language.Arabic: \"مرحبا بالعالم\",\n        Language.Chinese: \"你好，世界\",\n        Language.English: \"Hello, world\",\n        Language.French: \"Bonjour, monde\",\n        Language.Hindi: \"नमस्ते दुनिया\",\n        Language.Spanish: \"Hola mundo\",\n    }\n    return greetings.get(to_language)\n\n\n@workflow.defn\nclass GreetingWorkflow:\n    def __init__(self) -> None:\n        self.lock = asyncio.Lock()\n        ...\n    ...\n    @workflow.update\n    async def set_language(self, language: Language) -> Language:\n        if language not in self.greetings:\n            async with self.lock:\n                greeting = await workflow.execute_activity(\n                    call_greeting_service,\n                    language,\n                    start_to_close_timeout=timedelta(seconds=10),\n                )\n                if greeting is None:\n                    raise ApplicationError(\n                        f\"Greeting service does not support {language.name}\"\n                    )\n                self.greetings[language] = greeting\n        previous_language, self.language = self.language, language\n        return previous_language\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkerActivitiesPerSecond for Temporal Worker in Go\nDESCRIPTION: Rate limits the number of Activity Task Executions started per second for this specific Worker. This is useful for limiting resource usage or protecting downstream services. The type is `float64` (allowing rates less than 1, e.g., 0.1 for one execution every 10 seconds), and the default is `100000`. Setting it to `0` uses the default.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_29\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    WorkerActivitiesPerSecond: 100000,\n  // ..\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Activity Execution Timeout Options in Temporal Python Workflows\nDESCRIPTION: This code snippet provides an example for setting required Activity Execution timeout options, such as `start_to_close_timeout`, at invocation time. It demonstrates passing additional keyword arguments (activity options) when calling `execute_activity()` in a Workflow. At least one of `schedule_to_close_timeout` or `start_to_close_timeout` must be defined. The Activity is called with constructed parameter objects and timeout values as `timedelta` objects. Inputs include the Activity input dataclass, options for timeout, and the result is asynchronously retrieved. This pattern ensures Activities do not run indefinitely and conform to Temporal's scheduling constraints.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n        activity_timeout_result = await workflow.execute_activity(\\n            your_activity,\\n            YourParams(greeting, \"Activity Timeout option\"),\\n            # Activity Execution Timeout\\n            start_to_close_timeout=timedelta(seconds=10),\\n            # schedule_to_start_timeout=timedelta(seconds=10),\\n            # schedule_to_close_timeout=timedelta(seconds=10),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Configuring StickyScheduleToStartTimeout for Temporal Worker in Go\nDESCRIPTION: Sets the timeout for a Workflow Task that is scheduled on a specific (sticky) Worker. If the task doesn't start within this duration, the stickiness is cleared, and the task is rescheduled non-stickily. The type is `time.Duration`, the default is 5 seconds, and resolution is in seconds.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_38\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    StickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Querying a Workflow from a Temporal PHP Client\nDESCRIPTION: Illustrates how to send a Query to a running or completed Workflow Execution from a Temporal Client in PHP. It involves creating a typed Workflow Stub using `newWorkflowStub`, starting the Workflow via the client's `start` method, and then calling the Query method (e.g., `getCurrentState()`) directly on the stub object. The example demonstrates querying the state immediately after start and after a delay. Requires the Temporal Client (`$workflowClient`) and Workflow Stub objects.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: php\nCODE:\n```\n$workflow = $workflowClient->newWorkflowStub(\n    YourWorkflow::class,\n    WorkflowOptions::new()\n);\n\n$workflowClient->start($workflow);\n\nvar_dump($workflow->getCurrentState());\nsleep(60);\nvar_dump($workflow->getCurrentState());\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Activity in Java\nDESCRIPTION: Example of implementing a Dynamic Activity in Java. This implementation can handle different Activity types at runtime based on the input parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_11\n\nLANGUAGE: java\nCODE:\n```\npublic static class DynamicActivityImpl implements DynamicActivity {\n   @Override\n   public Object execute(EncodedValues args) {\n     String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n     return activityType\n         + \": \"\n         + args.get(0, String.class)\n         + \" \"\n         + args.get(1, String.class)\n         + \" from: \"\n         + args.get(2, String.class);\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToCloseTimeout in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Shows how to configure the `ScheduleToCloseTimeout` for an Activity in a Temporal Workflow using the Go SDK. This field determines the time limit from scheduling to Activity completion. Set via the `ActivityOptions` struct, applied to the workflow context, and used during Activity execution. The snippet expects dependencies on the workflow package and correctly set context, and includes result and error management.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  ScheduleToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Workflow Function in TypeScript\nDESCRIPTION: Defines a simple asynchronous Workflow function named `example` using TypeScript. It accepts an object argument `args` typed with `ExampleArgs` (containing a `name` property) and is intended to orchestrate an Activity function (`greet`) to generate a greeting. It returns a Promise resolving to an object containing the resulting greeting string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ntype ExampleArgs = {\n  name: string;\n};\n\nexport async function example(\n  args: ExampleArgs,\n): Promise<{ greeting: string }> {\n  const greeting = await greet(args.name);\n  return { greeting };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Go Workflow Implementations with TestWorkflowEnvironment\nDESCRIPTION: This code demonstrates how to implement unit tests for a SimpleWorkflow sample using the Temporal Go SDK test framework. It shows setup of the test suite, mocking Activities, and different test scenarios including success paths and error handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage sample\n\nimport (\n        \"context\"\n        \"errors\"\n        \"testing\"\n\n        \"github.com/stretchr/testify/mock\"\n        \"github.com/stretchr/testify/suite\"\n\n        \"go.temporal.io/sdk/activity\"\n        \"go.temporal.io/sdk/testsuite\"\n)\n\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n\n----------------------------------------\n\nTITLE: JUnit5 Test Implementation with TestWorkflowExtension\nDESCRIPTION: Implementation of unit tests using JUnit5's TestWorkflowExtension for simplified test environment setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npublic class HelloActivityJUnit5Test {\n    @RegisterExtension\n    public static final TestWorkflowExtension testWorkflowExtension =\n            TestWorkflowExtension.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl(\n            TestWorkflowEnvironment testEnv, Worker worker, GreetingWorkflow workflow) {\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Standard Side Effects in Temporal Go SDK\nDESCRIPTION: This example demonstrates the correct implementation of the SideEffect function to generate a random number. The function returns a Future that can be accessed with the Get method to retrieve the result. This approach maintains Workflow determinism by storing the result in the Event History.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/side-effects.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nencodedRandom := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {\n return rand.Intn(100)\n})\n\nvar random int\nencodedRandom.Get(&random)\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Workflow Inbound Interceptor for Authorization in TypeScript\nDESCRIPTION: This snippet demonstrates a basic (and insecure) `DumbWorkflowAuthInterceptor` implementing `WorkflowInboundCallsInterceptor`. It intercepts the Workflow `execute` call, attempts to extract and decode credentials from the `auth` header using the `defaultDataConverter`, and throws an error if the hardcoded credentials don't match. A warning emphasizes this is not suitable for production authorization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/interceptors.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  defaultDataConverter,\n  Next,\n  WorkflowInboundCallsInterceptor,\n  WorkflowInput,\n} from '@temporalio/workflow';\n\n/**\n * WARNING: This demo is meant as a simple auth example.\n * Do not use this for actual authorization logic.\n * Auth headers should be encrypted and credentials\n * stored outside of the codebase.\n */\nexport class DumbWorkflowAuthInterceptor\n  implements WorkflowInboundCallsInterceptor\n{\n  public async execute(\n    input: WorkflowInput,\n    next: Next<WorkflowInboundCallsInterceptor, 'execute'>,\n  ): Promise<unknown> {\n    const authHeader = input.headers.auth;\n    const { user, password } = authHeader\n      ? await defaultDataConverter.fromPayload(authHeader)\n      : undefined;\n\n    if (!(user === 'admin' && password === 'admin')) {\n      throw new Error('Unauthorized');\n    }\n    return await next(input);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule in Java\nDESCRIPTION: This snippet demonstrates how to create a new Schedule using the createSchedule() method on the ScheduleClient. It initializes a Schedule with a unique ID, specifies the Workflow type, arguments, and options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nSchedule schedule =\n    Schedule.newBuilder()\n        .setAction(\n            ScheduleActionStartWorkflow.newBuilder()\n                .setWorkflowType(HelloSchedules.GreetingWorkflow.class)\n                .setArguments(\"World\")\n                .setOptions(\n                    WorkflowOptions.newBuilder()\n                        .setWorkflowId(\"WorkflowId\")\n                        .setTaskQueue(\"TaskQueue\")\n                        .build())\n                .build())\n        .setSpec(ScheduleSpec.newBuilder().build())\n        .build();\n\n// Create a schedule on the server\nScheduleHandle handle =\n    scheduleClient.createSchedule(\"ScheduleId\", schedule, ScheduleOptions.newBuilder().build());\n```\n\n----------------------------------------\n\nTITLE: Initializing Worker Process with Temporal Java SDK - Java\nDESCRIPTION: This snippet demonstrates how to set up a Worker process using Temporal's Java SDK by initializing core Temporal services, creating a WorkerFactory, and creating a Worker attached to a specific task queue. Required dependencies include io.temporal:temporal-sdk and related classes. Expected inputs include a task queue name, and key methods are responsible for establishing service and client connections, registering Workflows/Activities (to be completed in user code), and starting all registered workers. All activities and workflows to be executed must be registered before factory.start(); is called.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_39\n\nLANGUAGE: Java\nCODE:\n```\n// ...\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\n\npublic class YourWorker {\n\n  public static void main(String[] args) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker yourWorker = factory.newWorker(\"your_task_queue\");\n\n    // Register Workflow\n    // and/or register Activities\n\n    factory.start();\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Activity Function in TypeScript\nDESCRIPTION: Defines a simple asynchronous Activity function `greet` in TypeScript, located in `snippets/src/activities.ts`. It accepts a `name` string as input and returns a Promise resolving to a greeting string. Activities execute in a standard Node.js environment, outside the Workflow's deterministic sandbox, allowing them to perform I/O operations or interact with external services.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution Synchronously in Java\nDESCRIPTION: This snippet demonstrates how to start a Workflow Execution synchronously using a typed WorkflowStub. It sets the Workflow ID and Task Queue, then invokes the Workflow method and waits for the result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nNotifyUserAccounts workflow = client.newWorkflowStub(\n      NotifyUserAccounts.class,\n      WorkflowOptions.newBuilder()\n              .setWorkflowId(\"notifyAccounts\")\n              .setTaskQueue(taskQueue)\n              .build()\n      );\n\n// start the Workflow and wait for a result.\nworkflow.notify(new String[] { \"Account1\", \"Account2\", \"Account3\", \"Account4\", \"Account5\",\n              \"Account6\", \"Account7\", \"Account8\", \"Account9\", \"Account10\"});\n  }\n// notify(String[] accountIds) is a Workflow method defined in the Workflow Definition.\n```\n\n----------------------------------------\n\nTITLE: Patching Workflow Code (v2) Using `patched`\nDESCRIPTION: This TypeScript snippet (`v2`), sourced from `patching-api/src/workflows-v2.ts`, demonstrates the first step in patching the Workflow. It uses the `patched('my-change-id')` function from `@temporalio/workflow` to conditionally execute either the new logic (`activityB` and sleep) or the old logic (`activityA`, sleep, `activityThatMustRunAfterA`). This allows deploying v2 while v1 Workflows are still running, ensuring compatibility and determinism during the transition. Requires the `@temporalio/workflow` package.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// v2\nimport { patched } from '@temporalio/workflow';\nexport async function myWorkflow(): Promise<void> {\n  if (patched('my-change-id')) {\n    await activityB();\n    await sleep('1 days');\n  } else {\n    await activityA();\n    await sleep('1 days');\n    await activityThatMustRunAfterA();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Side Effects Implementation - Java\nDESCRIPTION: Demonstrates using multiple Side Effects in a Workflow method to generate random numbers and retrieve environment variables. Shows how to implement Side Effects within a WorkflowMethod.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/side-effects.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.sideEffect( int.class, () -> {\n        Random random = new SecureRandom();\n        return random.nextInt();\n    });\n\n    String userHome = Workflow.sideEffect(String.class, () -> System.getenv(\"USER_HOME\"));\n\n    if(randomInt % 2 == 0) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Statically Defining and Handling Signals and Queries in Temporal Workflow - TypeScript\nDESCRIPTION: Demonstrates the static definition of Signal and Query handlers outside the Workflow function for improved type safety and reusability. Relies on the Temporal TypeScript SDK ('@temporalio/workflow') with 'defineSignal', 'defineQuery', and 'setHandler' APIs. 'unblockSignal' and 'isBlockedQuery' are defined up front; the handler for 'unblockSignal' toggles a flag, 'isBlockedQuery' returns current state. The workflow waits (with wf.condition) until unblocked, logging status and properly handling cancellation. Inputs are signal/query calls; outputs are side effects and log messages. Constraint: works best when signal/query names are known ahead.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport * as wf from '@temporalio/workflow';\n\nexport const unblockSignal = wf.defineSignal('unblock');\nexport const isBlockedQuery = wf.defineQuery<boolean>('isBlocked');\n\nexport async function unblockOrCancel(): Promise<void> {\n  let isBlocked = true;\n  wf.setHandler(unblockSignal, () => void (isBlocked = false));\n  wf.setHandler(isBlockedQuery, () => isBlocked);\n  wf.log.info('Blocked');\n  try {\n    await wf.condition(() => !isBlocked);\n    wf.log.info('Unblocked');\n  } catch (err) {\n    if (err instanceof wf.CancelledFailure) {\n      wf.log.info('Cancelled');\n    }\n    throw err;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Workflow Execution Test in Go\nDESCRIPTION: This snippet shows a basic test case for executing a Workflow and asserting its completion without errors. It demonstrates the use of ExecuteWorkflow, IsWorkflowCompleted, and GetWorkflowError methods.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Activities Interface for Temporal PHP SDK (PHP)\nDESCRIPTION: This code shows an example of a PHP interface for defining several Activities using the Temporal SDK. The interface is annotated with #[ActivityInterface], and each Activity corresponds to a method, with ActivityMethod attributes specifying the Activity type name if different from the method name. Activity methods must be serializable, and the number/type of arguments should be chosen to optimize forward compatibility and stay within gRPC message size limits.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: php\nCODE:\n```\n#[ActivityInterface]\n// Defining an interface for the activities.\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName): void;\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName): void;\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow in Java\nDESCRIPTION: This snippet shows the implementation of a Workflow interface in Java. It defines a class that implements the previously defined interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class YourBasicWorkflowImpl implements YourBasicWorkflow {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Workflow in Java\nDESCRIPTION: Demonstrates how to create a Workflow implementation class that implements the Workflow interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static class GreetingWorkflowImpl implements GreetingWorkflow {\n    ...\n  }\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Workflow Completion with Untyped WorkflowStub in Java\nDESCRIPTION: Demonstrates how to connect to an existing Workflow and wait for its completion using an untyped WorkflowStub. The getResult method blocks until the Workflow completes and returns the result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_25\n\nLANGUAGE: java\nCODE:\n```\nWorkflowStub workflowStub = client.newUntypedWorkflowStub(workflowType, workflowOptions);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = untyped.getResult(String.class);\n```\n\n----------------------------------------\n\nTITLE: Basic File Processing Workflow Implementation\nDESCRIPTION: Initial implementation of a file processing Workflow that downloads, processes, and uploads a file with proper cleanup handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using an Updatable Timer in Temporal TypeScript Workflows\nDESCRIPTION: Demonstrates the usage of a custom `UpdatableTimer` class within a Temporal Workflow. The timer's deadline can be modified externally using a Signal (`setDeadlineSignal`), and its remaining time can be queried (`timeLeftQuery`). The workflow waits (`await timer`) for the timer to expire, respecting any updates to its deadline.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/timers.mdx#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport * as wf from '@temporalio/workflow';\n\n// usage\nexport async function countdownWorkflow(): Promise<void> {\n  const target = Date.now() + 24 * 60 * 60 * 1000; // 1 day!!!\n  const timer = new UpdatableTimer(target);\n  console.log('timer set for: ' + new Date(target).toString());\n  wf.setHandler(setDeadlineSignal, (deadline) => {\n    // send in new deadlines via Signal\n    timer.deadline = deadline;\n    console.log('timer now set for: ' + new Date(deadline).toString());\n  });\n  wf.setHandler(timeLeftQuery, () => timer.deadline - Date.now());\n  await timer; // if you send in a signal with a new time, this timer will resolve earlier!\n  console.log('countdown done!');\n}\n```\n\n----------------------------------------\n\nTITLE: Using WorkflowInit to Process Input Before Handlers in Temporal PHP\nDESCRIPTION: Demonstrates how to use the WorkflowInit attribute on a constructor to process Workflow input before any handlers execute, making that processed input available to all handlers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_20\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass GreetingExample\n{\n    private readonly string $nameWithTitle;\n    private bool $titleHasBeenChecked;\n\n    // Note the attribute is on a public constructor\n    #[Workflow\\WorkflowInit]\n    public function __construct(string $input)\n    {\n        $this->nameWithTitle = 'Sir ' . $input;\n        $this->titleHasBeenChecked = false;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function getGreeting(string $input)\n    {\n        yield Workflow::await(fn() => $this->titleHasBeenChecked);\n        return \"Hello \" . $this->nameWithTitle;\n    }\n\n    #[Workflow\\UpdateMethod]\n    public function checkTitleValidity()\n    {\n        // 👉 The handler is now guaranteed to see the workflow input\n        // after it has been processed by the constructor.\n        $isValid = yield Workflow::executeActivity('activity.checkTitleValidity', [$this->nameWithTitle]);\n        $this->titleHasBeenChecked = true;\n        return $isValid;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Concurrent Update Handler Implementation with workflow.Mutex in Go\nDESCRIPTION: Corrected version of the Update handler using workflow.Mutex to ensure thread-safe execution. The implementation prevents concurrent access to shared resources by acquiring a lock before executing critical sections.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n    ...\n    err := workflow.SetUpdateHandler(ctx, \"SafeUpdateHandler\", func(ctx workflow.Context) error {\n        err := mutex.Lock(ctx)\n        if err != nil {\n            return err\n        }\n        defer mutex.Unlock()\n        ao := workflow.ActivityOptions{\n            StartToCloseTimeout: 10 * time.Second,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n\n        var result Data\n        err := workflow.ExecuteActivity(ctx, FetchData, name).Get(ctx, &result)\n        x = data.x\n        // ✅ OK: the scheduler may switch now to a different handler execution, or to the main workflow\n        // method, but no other execution of this handler can run until this execution finishes.\n        err = workflow.Sleep(ctx, time.Second)\n        if err != nil {\n            return err\n        }\n        self.y = data.y\n    })\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts using Temporal Python SDK\nDESCRIPTION: Shows how to configure Activity timeouts such as `start_to_close_timeout`, `schedule_to_start_timeout`, and `schedule_to_close_timeout` within a Workflow definition using `workflow.execute_activity`. These timeouts control the maximum duration for an Activity Task Execution, the time waiting in the queue, and the overall Activity Execution, respectively. They are passed as keyword arguments and specified using `timedelta`. Either `start_to_close_timeout` or `schedule_to_close_timeout` must be set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ...\n        activity_timeout_result = await workflow.execute_activity(\n            your_activity,\n            YourParams(greeting, \"Activity Timeout option\"),\n            # Activity Execution Timeout\n            start_to_close_timeout=timedelta(seconds=10),\n            # schedule_to_start_timeout=timedelta(seconds=10),\n            # schedule_to_close_timeout=timedelta(seconds=10),\n        )\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Activity Retry Policy in Go SDK\nDESCRIPTION: This code demonstrates how to set a custom Activity Retry Policy that overrides the default behavior. The policy is configured with parameters like InitialInterval, BackoffCoefficient, and MaximumInterval to control retry behavior when an Activity fails.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityoptions := workflow.ActivityOptions{\n  RetryPolicy: retrypolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Client and WorkflowStub in Java\nDESCRIPTION: Demonstrates setting up the Temporal Java SDK client by creating `WorkflowServiceStubs`, `WorkflowClient`, and `WorkflowOptions`. It then obtains a typed `WorkflowStub` using `client.newWorkflowStub` and starts a workflow execution asynchronously by calling a method reference (`workflow::getGreetings`) via `WorkflowClient.start`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n\nWorkflowClient client = WorkflowClient.newInstance(service);\n\nWorkflowOptions workflowOptions =\n    WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n\n// Create the workflow client stub. It is used to start the workflow execution.\nGreetingWorkflow workflow = client.newWorkflowStub(GreetingWorkflow.class, workflowOptions);\n\n// Start workflow asynchronously and call its getGreeting workflow method\nWorkflowClient.start(workflow::getGreetings);\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Interface in Java\nDESCRIPTION: This snippet demonstrates how to define a Workflow interface in Java using Temporal annotations. It includes a method annotated with @WorkflowMethod.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface YourBasicWorkflow {\n\n    @WorkflowMethod\n    String workflowMethod(Arguments args);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting HeartbeatTimeout via WorkflowImplementationOptions in Java\nDESCRIPTION: This snippet shows how to set the Heartbeat Timeout per Activity type (`EmailCustomerGreeting`) using `WorkflowImplementationOptions`. This approach applies the specified `ActivityOptions`, including the Heartbeat Timeout and a required `StartToCloseTimeout`, to all Activities of that type executed by Workers configured with these options. Dependencies include `io.temporal.worker.WorkflowImplementationOptions`, `com.google.common.collect.ImmutableMap`, `io.temporal.activity.ActivityOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_29\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                              \"EmailCustomerGreeting\",\n                                    ActivityOptions.newBuilder()\n                                        // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                        // required when setting Activity options.\n                                          .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                          .setHeartbeatTimeout(Duration.ofSeconds(2))\n                                          .build()))\n                    .build();\n```\n\n----------------------------------------\n\nTITLE: Handling Cancellation in Temporal Activity - Go\nDESCRIPTION: This snippet demonstrates how to handle a Cancellation request within an Activity using Go. It uses a for-select loop to listen for cancellation while performing heartbeats.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/cancellation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (a *Activities) ActivityToBeCanceled(ctx context.Context) (string, error) {\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tlogger.Info(\"Heartbeating...\")\n\t\t\tactivity.RecordHeartbeat(ctx, \"\")\n\t\tcase <-ctx.Done():\n\t\t\tlogger.Info(\"This Activity is canceled!\")\n\t\t\treturn \"I am canceled by Done\", nil\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Workflow Results using Temporal Python SDK\nDESCRIPTION: This example illustrates how to retrieve the results of a completed Workflow Execution asynchronously. It uses `client.get_workflow_handle` to obtain a handle for an existing Workflow by its ID, and then calls `handle.result()` to wait for and fetch the final result. This requires the `temporalio.client` and `asyncio` library.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/temporal-clients.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    handle = client.get_workflow_handle(\n        workflow_id=\"your-workflow-id\",\n    )\n    results = await handle.result()\n    print(f\"Result: {results}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Defining and Canceling a Heartbeating Activity within a Temporal Workflow in Python\nDESCRIPTION: This snippet shows how to define a cancellable Activity (`cancellable_activity`) that sends heartbeats and handles cancellation using `asyncio.CancelledError`. It also includes a simple Activity (`run_activity`) and a Workflow (`GreetingWorkflow`) that starts the cancellable Activity and subsequently cancels it after a delay using the Activity handle's `cancel()` method. Note that Activity cancellation requires heartbeating and a `heartbeat_timeout` for non-local Activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/cancellation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@activity.defn\nasync def cancellable_activity(input: ComposeArgsInput) -> NoReturn:\n    try:\n        while True:\n            print(\"Heartbeating cancel activity\")\n            await asyncio.sleep(0.5)\n            activity.heartbeat(\"some details\")\n    except asyncio.CancelledError:\n        print(\"Activity cancelled\")\n        raise\n\n\n@activity.defn\nasync def run_activity(input: ComposeArgsInput):\n    print(\"Executing activity\")\n    return input.arg1 + input.arg2\n\n@workflow.defn\n class GreetingWorkflow:\n     @workflow.run\n     async def run(self, input: ComposeArgsInput) -> None:\n        activity_handle = workflow.start_activity(\n            cancellable_activity,\n            ComposeArgsInput(input.arg1, input.arg2),\n            start_to_close_timeout=timedelta(minutes=5),\n            heartbeat_timeout=timedelta(seconds=30),\n        )\n\n        await asyncio.sleep(3)\n        activity_handle.cancel()\n```\n\n----------------------------------------\n\nTITLE: Logging from a Workflow in Go\nDESCRIPTION: This snippet shows how to log from a Workflow using the GetLogger function in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/activity\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\n// Workflow is a standard workflow definition.\n// Note that the Workflow and Activity don't need to care that\n// their inputs/results are being compressed.\nfunc Workflow(ctx workflow.Context, name string) (string, error) {\n// ...\n\nworkflow.WithActivityOptions(ctx, ao)\n\n// Getting the logger from the context.\n\tlogger := workflow.GetLogger(ctx)\n// Logging a message with the key value pair `name` and `name`\n\tlogger.Info(\"Compressed Payloads workflow started\", \"name\", name)\n\n\tinfo := map[string]string{\n\t\t\"name\": name,\n\t}\n\n\tlogger.Info(\"Compressed Payloads workflow completed.\", \"result\", result)\n\n\treturn result, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Handlers and Validators in .NET Workflow\nDESCRIPTION: Illustrates the implementation of Update handlers and validators in a Temporal .NET Workflow. Updates are trackable synchronous requests that can change Workflow state, control flow, and return results. The example shows both a validator and an Update handler.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowUpdateValidator(nameof(SetCurrentLanguageAsync))]\npublic void ValidateLanguage(Language language)\n{\n    if (!Greetings.ContainsKey(language))\n    {\n        throw new ApplicationFailureException($\"{language} is not supported\");\n    }\n}\n\n[WorkflowUpdate]\npublic async Task<Language> SetCurrentLanguageAsync(Language language)\n{\n    var previousLanguage = CurrentLanguage;\n    CurrentLanguage = language;\n    return previousLanguage;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Timeout to Multiple Concurrent Activities using withTimeout in TypeScript\nDESCRIPTION: This Workflow demonstrates using `CancellationScope.withTimeout` to enforce a deadline on multiple concurrent Activities. It takes an array of URLs and a timeout duration (`timeoutMs`). It attempts to fetch JSON from all URLs concurrently using `Promise.all` within the `withTimeout` scope. If all Activities complete before `timeoutMs`, their results are returned. If the timeout is reached first, the scope is cancelled, which cancels any still-running `httpGetJSON` Activities and causes the Workflow to fail with a cancellation error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nexport function multipleActivitiesSingleTimeout(\n  urls: string[],\n  timeoutMs: number,\n): Promise<any> {\n  const { httpGetJSON } = proxyActivities<typeof activities>({\n    startToCloseTimeout: timeoutMs,\n  });\n\n  // If timeout triggers before all activities complete\n  // the Workflow will fail with a CancelledError.\n  return CancellationScope.withTimeout(\n    timeoutMs,\n    () => Promise.all(urls.map((url) => httpGetJSON(url))),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution Asynchronously with Typed WorkflowStub in Java\nDESCRIPTION: This example shows how to start a Workflow Execution asynchronously using a typed WorkflowStub. It creates the stub with Workflow options and uses WorkflowClient.start to initiate the Workflow without waiting for completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n// create typed Workflow stub\nFileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n      WorkflowOptions.newBuilder()\n              .setTaskQueue(taskQueue)\n              .setWorkflowId(workflowId)\n              .build());\n// use WorkflowClient.execute to return future that contains Workflow result or failure, or\n// use WorkflowClient.start to return WorkflowId and RunId of the started Workflow).\nWorkflowClient.start(workflow::greetCustomer);\n```\n\n----------------------------------------\n\nTITLE: Using Deterministic Date and Sleep in TypeScript Workflows\nDESCRIPTION: Compares the behavior of `Date.now()` and `workflow.sleep()` within a Temporal Workflow's deterministic environment. It shows that multiple calls to `Date.now()` within the same Workflow execution turn return the identical timestamp because the Workflow time doesn't advance without an await point. Conversely, inserting `await sleep('1 second')` allows the logical Workflow time to advance, resulting in increasing timestamps in subsequent calls to `Date.now()`. This highlights the deterministic nature of time APIs within Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nimport { sleep } from '@temporalio/workflow';\n\n// this prints the *exact* same timestamp repeatedly\nfor (let x = 0; x < 10; ++x) {\n  console.log(Date.now());\n}\n\n// this prints timestamps increasing roughly 1s each iteration\nfor (let x = 0; x < 10; ++x) {\n  await sleep('1 second');\n  console.log(Date.now());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Assertions in Workflow Context\nDESCRIPTION: Implementation showing how to use assertions within Workflow context and handle assertion failures.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport assert from 'assert';\n\nexport async function functionToTest() {\n  assert.ok(false);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Dynamic Signals in Temporal Workflows (TypeScript)\nDESCRIPTION: Demonstrates two patterns for handling dynamic Signals in Temporal TypeScript Workflows: the 'fat handler' approach consolidating logic into one handler based on payload, and the 'inline definition' approach using `wf.defineSignal` to create signal definitions dynamically per handler. Includes a helper function for the inline pattern. Depends on the '@temporalio/workflow' package.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport * as wf from '@temporalio/workflow';\n\n// \"fat handler\" solution\nwf.setHandler(`genericSignal`, (payload) => {\n  switch (payload.taskId) {\n    case taskAId:\n      // do task A things\n      break;\n    case taskBId:\n      // do task B things\n      break;\n    default:\n      throw new Error('Unexpected task.');\n  }\n});\n\n// \"inline definition\" solution\nwf.setHandler(wf.defineSignal(`task-${taskAId}`), (payload) => {\n  /* do task A things */\n});\nwf.setHandler(wf.defineSignal(`task-${taskBId}`), (payload) => {\n  /* do task B things */\n});\n\n// utility \"inline definition\" helper\nconst inlineSignal = (signalName, handler) =>\n  wf.setHandler(wf.defineSignal(signalName), handler);\ninlineSignal(`task-${taskBId}`, (payload) => {\n  /* do task B things */\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Replaying Multiple Workflow Event Histories with Temporal Python SDK\nDESCRIPTION: This snippet demonstrates how to list Workflow Executions matching certain criteria, extract their Event Histories, and use the Replayer class to replay multiple Workflow definitions in Python with the Temporal SDK. Dependencies include the Temporal Python SDK and defined Workflow classes (MyWorkflowA, MyWorkflowB, MyWorkflowC). The input consists of Histories fetched programmatically and the snippet raises an exception on any replay error. Advanced Visibility must be enabled on the Temporal server as of v1.18. The pattern is intended for integration in CI pipelines to ensure Workflow determinism and compatibility.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/testing-suite.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nworkflows = client.list_workflows(f\"TaskQueue=foo and StartTime > '2022-01-01T12:00:00'\")\nhistories = workflows.map_histories()\nreplayer = Replayer(\n    workflows=[MyWorkflowA, MyWorkflowB, MyWorkflowC]\n)\nawait replayer.replay_workflows(histories)\n```\n\n----------------------------------------\n\nTITLE: Sharing Promises Between Workflow Cancellation Scopes in Temporal TypeScript\nDESCRIPTION: This snippet demonstrates how activities started in the root scope can be awaited in a cancellable scope without being affected by cancellation. When activities are started in the root scope but used in a child cancellation scope, cancelling the child scope does not cancel the activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function sharedScopes(): Promise<any> {\n  // Start activities in the root scope\n  const p1 = httpGetJSON('http://url1.ninja');\n  const p2 = httpGetJSON('http://url2.ninja');\n\n  const scopePromise = CancellationScope.cancellable(async () => {\n    const first = await Promise.race([p1, p2]);\n    // Does not cancel activity1 or activity2 as they're linked to the root scope\n    CancellationScope.current().cancel();\n    return first;\n  });\n  return await scopePromise;\n  // The Activity that did not complete will effectively be cancelled when\n  // Workflow completes unless the Activity is awaited:\n  // await Promise.all([p1, p2]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Workflow.await in Update Handlers\nDESCRIPTION: Example of using Workflow.await in an Update handler to pause execution until a specific condition is met. This pattern allows handlers to wait for certain states before proceeding with their logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: java\nCODE:\n```\n@Override\npublic String setLanguage(UpdateInput input) {\n    Workflow.await(() -> this.updateReadyToExecute(input));\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal Testing Package via npm\nDESCRIPTION: This command installs the necessary Temporal testing package for TypeScript projects using npm. The `@temporalio/testing` package provides the test server and utilities like `TestWorkflowEnvironment` required for integration testing and time skipping.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @temporalio/testing\n```\n\n----------------------------------------\n\nTITLE: Updating GetVersion for Second Activity Change in Go\nDESCRIPTION: Extended implementation showing a second code update (replacing ActivityC with ActivityD) by updating the maxSupported version parameter and adding another conditional branch.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 2)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else if v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Child Workflow with Typed Interface in Java\nDESCRIPTION: Example of how to execute a Child Workflow asynchronously using a typed interface and the Async.function method. The child workflow is spawned and its result is retrieved using Promise.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nGreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\nPromise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n// ...\ngreeting.get()\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Task Queue in Go\nDESCRIPTION: This code example shows how to set the Task Queue for a Workflow Execution using the StartWorkflowOptions struct. The Task Queue is a required field that must be set by the developer.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  TaskQueue: \"your-task-queue\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Identity for Temporal Worker in Go\nDESCRIPTION: Sets a custom identity string for this Worker, overriding the identity inherited from the Temporal Client. This identity appears in logs and Temporal UI. The type is `string`, and it defaults to the client's identity if not specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_45\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    Identity: \"your_custom_identity\",\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Non-blocking Activity Result Check with IsReady()\nDESCRIPTION: Example demonstrating how to check if Activity results are ready without blocking using the IsReady() method before calling Get(). This pattern allows for more flexible workflow execution flow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) (YourWorkflowResponse, error) {\n // ...\n future := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam)\n // ...\n if(future.IsReady()) {\n   var yourActivityResult YourActivityResult\n   if err := future.Get(ctx, &yourActivityResult); err != nil {\n     // ...\n   }\n }\n // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Activities and Getting Results in a Temporal Workflow (PHP)\nDESCRIPTION: This code shows how to instantiate an Activity client-side stub inside a PHP Workflow, specifying ActivityOptions like start-to-close timeout. The stub is used to call an Activity method, with execution awaiting completion via yield. This approach allows workflow code to treat long-running Activities as synchronous calls. Dependencies include Temporal SDK Workflow class, the Activity interface, and PHP generators/coroutines.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_9\n\nLANGUAGE: php\nCODE:\n```\nclass GreetingWorkflow implements GreetingWorkflowInterface\n{\n    private $greetingActivity;\n\n    public function __construct()\n    {\n        $this->greetingActivity = Workflow::newActivityStub(\n            GreetingActivityInterface::class,\n            ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n        );\n    }\n\n    public function greet(string $name): \\Generator\n    {\n        // This is a blocking call that returns only after the activity has completed.\n        return yield $this->greetingActivity->composeGreeting('Hello', $name);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Activity Execution Context with ActivityExecutionContext - Temporal Java SDK - Java\nDESCRIPTION: This snippet illustrates how to access ActivityExecutionContext information from within an Activity implementation, enabling the Activity to retrieve details about its execution (such as workflow ID, run ID, timeouts). Activity.getExecutionContext() provides runtime and workflow metadata to support logging and context-aware logic. This requires the Activity to run on a Worker thread, and should be used only within the Activity call stack due to thread-local context storage. Output includes logging execution meta-properties.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_19\n\nLANGUAGE: java\nCODE:\n```\npublic class FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n  @Override\n  public String download(String bucketName, String remoteName, String localName) {\n\n    ActivityExecutionContext ctx = Activity.getExecutionContext();\n    ActivityInfo info = ctx.getInfo();\n\n    log.info(\"namespace=\" +  info.getActivityNamespace());\n    log.info(\"workflowId=\" + info.getWorkflowId());\n    log.info(\"runId=\" + info.getRunId());\n    log.info(\"activityId=\" + info.getActivityId());\n    log.info(\"activityTimeout=\" + info.getStartToCloseTimeout();\n\n    return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);\n  }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow Progress in Go\nDESCRIPTION: This example demonstrates how to write a test case that queries a Workflow's progress. It uses RegisterDelayedCallback to check the progress at a specific time and QueryWorkflow to get the final progress after completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an Update to a Workflow Using the Temporal Go Client\nDESCRIPTION: Explains how to send a synchronous Update to a Workflow Execution using `temporalClient.UpdateWorkflow`. It requires a `context` (typically with a timeout), and `client.UpdateWorkflowOptions` specifying the Workflow ID (`we.GetID()`), optional Run ID (`we.GetRunID()`), Update name (`message.SetLanguageUpdate`), arguments (`[]interface{}{message.Chinese}`), and the `WaitForStage` parameter. This example uses `client.WorkflowUpdateStageAccepted`, meaning the call returns a handle after the Update passes validation on the Worker. The handle's `.Get()` method is then used (with context) to block until the Update completes and retrieve its result (`previousLang`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nctxWithTimeout, cancel := context.WithTimeout(context.Background(), 15*time.Second)\ndefer cancel()\n\nupdateHandle, err := temporalClient.UpdateWorkflow(ctxWithTimeout, client.UpdateWorkflowOptions{\n    WorkflowID:   we.GetID(),\n    RunID:        we.GetRunID(),\n    UpdateName:   message.SetLanguageUpdate,\n    WaitForStage: client.WorkflowUpdateStageAccepted,\n    Args:         []interface{}{message.Chinese},\n})\nif err != nil {\n    log.Fatalf(\"Unable to update workflow: %v\", err)\n}\n\nvar previousLang message.Language\nerr = updateHandle.Get(ctxWithTimeout, &previousLang)\nif err != nil {\n    log.Fatalf(\"Unable to get update result: %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Temporal Workflow with a Cron Schedule - TypeScript Temporal SDK\nDESCRIPTION: This snippet shows how to schedule Workflow executions at regular intervals using Temporal's cronSchedule option in the TypeScript SDK. The cronSchedule parameter accepts a standard cron string to trigger Workflow starts, allowing for fine-grained execution timing and automation. Requires a configured Temporal client and a Workflow function reference; outputs a Workflow handle for subsequent operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(scheduledWorkflow, {\n  // ...\n  cronSchedule: '* * * * *', // start every minute\n});\n```\n\n----------------------------------------\n\nTITLE: Proxying Multiple Temporal Activities with Shared Options in TypeScript\nDESCRIPTION: Demonstrates how to efficiently proxy multiple Temporal Activities (`act1`, `act2`, `act3`) that share the same options (like timeouts and retries) using a single `proxyActivities<typeof activities>()` call and destructuring assignment within a Workflow definition. Requires `@temporalio/workflow` and the corresponding activity definitions grouped (e.g., in an `activities` object or module).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nexport async function Workflow(name: string): Promise<string> {\n  // destructuring multiple activities with the same options\n  const { act1, act2, act3 } = proxyActivities<typeof activities>();\n  /* activityOptions */\n  await act1();\n  await Promise.all([act2, act3]);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Handlers in .NET Workflow\nDESCRIPTION: Demonstrates how to create Query handlers in a Temporal .NET Workflow. Shows examples of both method-based and property-based Query handlers. Queries are used to retrieve Workflow state synchronously without modifying it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowQuery]\npublic IList<Language> GetLanguages(GetLanguagesInput input) =>\n    Enum.GetValues<Language>().\n        Where(language => input.IncludeUnsupported || Greetings.ContainsKey(language)).\n        ToList();\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowQuery]\npublic Language CurrentLanguage { get; private set; } = Language.English;\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from a Temporal Client in PHP\nDESCRIPTION: This code demonstrates how to send a signal to a Workflow execution from a Temporal Client. It shows creating a Workflow stub, starting the Workflow, and then sending a signal to set a value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: PHP\nCODE:\n```\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->start($workflow);\n\n// do something\n\n$workflow->setValue(true);\n\nassert($run->getValue() === true);\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Timeouts with Temporal TypeScript SDK - TypeScript\nDESCRIPTION: This snippet demonstrates how to configure execution, run, and task timeouts when starting a Workflow using the Temporal TypeScript SDK. It utilizes the WorkflowOptions properties (workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout) passed to client.workflow.start. Required dependencies include the Temporal SDK Client and the workflow function to execute. Inputs include workflow start options; output is the asynchronous initiation of the workflow. Timeouts are specified as strings indicating durations (e.g., '1 day').\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  // Set Workflow Timeout duration\n  workflowExecutionTimeout: '1 day',\n  // workflowRunTimeout: '1 minute',\n  // workflowTaskTimeout: '30 seconds',\n});\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Input in Temporal CLI\nDESCRIPTION: Example of using the --input command option to pass a phone number as a parameter when starting a Temporal Workflow. The example shows how to format a simple string input as JSON.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/cmd-options.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow start --input '\"+1 555-555-5555\"'\n```\n\n----------------------------------------\n\nTITLE: Basic Temporal Workflow Definition in Go\nDESCRIPTION: A simple Temporal Workflow implementation in Go that executes two activities in sequence. This represents the initial version of a Workflow before any versioning is applied.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflow(ctx workflow.Context, data string) (string, error) {\n        ao := workflow.ActivityOptions{\n                ScheduleToStartTimeout: time.Minute,\n                StartToCloseTimeout:    time.Minute,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n        var result1 string\n        err := workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n        if err != nil {\n                return \"\", err\n        }\n        var result2 string\n        err = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\n        return result2, err\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CancellationType via ActivityStub in Java\nDESCRIPTION: This snippet demonstrates setting the Activity cancellation behavior using `ActivityOptions.newBuilder().setCancellationType()` when creating an `ActivityStub`. It sets the type to `WAIT_CANCELLATION_COMPLETED`, meaning the Workflow will wait for the Activity to confirm cancellation before proceeding. Dependencies include `io.temporal.workflow.Workflow`, `io.temporal.activity.ActivityOptions`, and `io.temporal.activity.ActivityCancellationType`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_34\n\nLANGUAGE: java\nCODE:\n```\nprivate final GreetingActivities activities =\n  Workflow.newActivityStub(\n      GreetingActivities.class,\n      ActivityOptions.newBuilder()\n          .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n          .build());\n```\n\n----------------------------------------\n\nTITLE: Using Selectors with Channels in Temporal Go SDK\nDESCRIPTION: Example showing how to receive information from a Channel using AddReceive, including explicit message consumption with c.Receive().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/selectors.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// API Example: receive information from a Channel\nvar signalVal string\nchannel := workflow.GetSignalChannel(ctx, channelName)\nselector.AddReceive(channel, func(c workflow.ReceiveChannel, more bool) {\n\tc.Receive(ctx, &signalVal)\n\t// do something with received information\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Handling Temporal Signals in TypeScript\nDESCRIPTION: Illustrates defining a Temporal Signal using `wf.defineSignal` and implementing its handler with `wf.setHandler` within a Workflow. The handler asynchronously receives data (`input`) and mutates the Workflow's internal state (`approvedForRelease`, `approverName`). Signal handlers do not return values and can perform async operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// 👉 Use the object returned by defineSignal to set the Signal handler in\n// Workflow code, and to send the Signal from Client code.\nexport const approve = wf.defineSignal<[ApproveInput]>('approve');\n\nexport async function greetingWorkflow(): Promise<string> {\n  let approvedForRelease = false;\n  let approverName: string | undefined;\n\n  wf.setHandler(approve, (input) => {\n    // 👉 A Signal handler mutates the Workflow state but cannot return a value.\n    approvedForRelease = true;\n    approverName = input.name;\n  });\n\n  ...\n}\n...\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Names for Individual Temporal Activities in Java\nDESCRIPTION: Shows how to override default naming and interface prefixes by using the `name` parameter in the `@ActivityMethod` annotation for a specific activity method. The `composeFarewell` method is given the explicit Activity Type \"farewell\", overriding the `Messaging_` prefix and default capitalization. The other methods retain the prefix. Requires the Temporal Java SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_14\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface(namePrefix = \"Messaging_\")\npublic interface GreetingActivities {\n    String sendMessage(String input);\n\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n    @ActivityMethod(name = \"farewell\")\n    String composeFarewell(String farewell, String language);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Query Handler Methods in Temporal Python Workflows - Python\nDESCRIPTION: This snippet demonstrates how to define Query handler methods on a Workflow class with the Temporal Python SDK. It uses Python enums and dataclasses to clearly type inputs and illustrates best practices such as avoiding mutation of the Workflow state inside a Query handler. Dependencies include the Temporal Python SDK, Python built-in types (IntEnum, dataclass), as well as appropriate decorators. The handler returns language options based on the boolean input parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Language(IntEnum):\n    Chinese = 1\n    English = 2\n    French = 3\n\n@dataclass\nclass GetLanguagesInput:\n    include_unsupported: bool\n\n@workflow.defn\nclass GreetingWorkflow:\n    def __init__(self) -> None:\n        self.greetings = {\n            Language.CHINESE: \"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\",\n            Language.ENGLISH: \"Hello, world\",\n        }\n\n    @workflow.query\n    def get_languages(self, input: GetLanguagesInput) -> list[Language]:\n        # \\ud83d\\udc49 A Query handler returns a value: it can inspect but must not mutate the Workflow state.\n        if input.include_unsupported:\n            return list(Language)\n        else:\n            return list(self.greetings)\n```\n\n----------------------------------------\n\nTITLE: Nesting Cancellation Scopes in Temporal Workflows\nDESCRIPTION: Demonstrates complex flow control using nested cancellation scopes, including using nonCancellable scopes for setup/cleanup operations and timeout-based cancellation for main operations. This allows for fine-grained control over what gets cancelled and when.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\n\nimport type * as activities from '../activities';\n\nconst { setup, httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nestedCancellation(url: string): Promise<void> {\n  await CancellationScope.cancellable(async () => {\n    await CancellationScope.nonCancellable(() => setup());\n    try {\n      await CancellationScope.withTimeout(\n        1000,\n        () => httpPostJSON(url, { some: 'data' }),\n      );\n    } catch (err) {\n      if (isCancellation(err)) {\n        await CancellationScope.nonCancellable(() => cleanup(url));\n      }\n      throw err;\n    }\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Client in Temporal TypeScript\nDESCRIPTION: This code shows how to start a Workflow using the Temporal Client. It creates a connection to the Temporal server, instantiates a Client, and executes a Workflow with required parameters including taskQueue and workflowId.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, Connection } from '@temporalio/client';\n// This is the code that is used to start a Workflow.\nconst connection = await Connection.create();\nconst client = new Client({ connection });\nconst result = await client.workflow.execute(yourWorkflow, {\n  // required\n  taskQueue: 'your-task-queue',\n  // required\n  workflowId: 'your-workflow-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts with Temporal TypeScript SDK - TypeScript\nDESCRIPTION: This example shows how to configure various Activity timeout options (scheduleToCloseTimeout, startToCloseTimeout, scheduleToStartTimeout) when creating proxies to Activities via proxyActivities. At least one of startToCloseTimeout or scheduleToCloseTimeout is required. The snippet requires the Temporal TypeScript SDK and relevant activity definitions. Timeout values are strings (e.g., '5m' for 5 minutes). These settings determine how long an Activity is allowed to run or wait before timing out.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst { myActivity } = proxyActivities<typeof activities>({\n  scheduleToCloseTimeout: '5m',\n  // startToCloseTimeout: \"30s\", // recommended\n  // scheduleToStartTimeout: \"60s\",\n});\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Activity Invocation Using Async.function and Async.procedure - Temporal Java SDK - Java\nDESCRIPTION: This snippet showcases the use of the Async class to invoke Activities asynchronously in the Temporal Java SDK, utilizing Promise objects for concurrent execution. It downloads multiple files in parallel, processes them, then uploads results in parallel, handling resource cleanup appropriately. Dependencies include the Async class, Promise, and correctly configured Activity stubs. Parameters include lists of filenames and target locations, and each Promise is resolved when its Activity completes, ensuring efficient parallel processing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_18\n\nLANGUAGE: java\nCODE:\n```\n  public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n      // Download all files in parallel.\n      for (String sourceFilename : args.getSourceFilenames()) {\n        Promise<String> localName =\n            Async.function(activities::download, args.getSourceBucketName(), sourceFilename);\n        localNamePromises.add(localName);\n      }\n      List<String> localNames = new ArrayList<>();\n      for (Promise<String> localName : localNamePromises) {\n        localNames.add(localName.get());\n      }\n      processedNames = activities.processFiles(localNames);\n\n      // Upload all results in parallel.\n      List<Promise<Void>> uploadedList = new ArrayList<>();\n      for (String processedName : processedNames) {\n        Promise<Void> uploaded =\n            Async.procedure(\n                activities::upload,\n                args.getTargetBucketName(),\n                args.getTargetFilename(),\n                processedName);\n        uploadedList.add(uploaded);\n      }\n      // Wait for all uploads to complete.\n      Promise.allOf(uploadedList).get();\n    } finally {\n      for (Promise<String> localNamePromise : localNamePromises) {\n        // Skip files that haven't completed downloading.\n        if (localNamePromise.isCompleted()) {\n          activities.deleteLocalFile(localNamePromise.get());\n        }\n      }\n      if (processedNames != null) {\n        for (String processedName : processedNames) {\n          activities.deleteLocalFile(processedName);\n        }\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Payload Codec for Encryption in Java SDK\nDESCRIPTION: This code shows a custom PayloadCodec implementation that handles encryption and decryption of Workflow payloads. It defines encode and decode methods with metadata verification and uses AES/GCM encryption.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/converters-and-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nclass YourCustomPayloadCodec implements PayloadCodec {\n\n  static final ByteString METADATA_ENCODING =\n      ByteString.copyFrom(\"binary/encrypted\", StandardCharsets.UTF_8);\n\n  private static final String CIPHER = \"AES/GCM/NoPadding\";\n\n  // Define constants that you can add to your encoded Payload to create a new Payload.\n  static final String METADATA_ENCRYPTION_CIPHER_KEY = \"encryption-cipher\";\n\n  static final ByteString METADATA_ENCRYPTION_CIPHER =\n      ByteString.copyFrom(CIPHER, StandardCharsets.UTF_8);\n\n  static final String METADATA_ENCRYPTION_KEY_ID_KEY = \"encryption-key-id\";\n\n  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n\n  // See the linked sample for details on the methods called here.\n  @NotNull\n  @Override\n  public List<Payload> encode(@NotNull List<Payload> payloads) {\n    return payloads.stream().map(this::encodePayload).collect(Collectors.toList());\n  }\n\n  @NotNull\n  @Override\n  public List<Payload> decode(@NotNull List<Payload> payloads) {\n    return payloads.stream().map(this::decodePayload).collect(Collectors.toList());\n  }\n\n  private Payload encodePayload(Payload payload) {\n    String keyId = getKeyId();\n    SecretKey key = getKey(keyId);\n\n    byte[] encryptedData;\n    try {\n      encryptedData = encrypt(payload.toByteArray(), key); // The encrypt method contains your custom encryption logic.\n    } catch (Throwable e) {\n      throw new DataConverterException(e);\n    }\n    // Apply metadata to the encoded Payload that you can verify in your decode method before decoding.\n    // See the sample for details on the metadata values set.\n    return Payload.newBuilder()\n        .putMetadata(EncodingKeys.METADATA_ENCODING_KEY, METADATA_ENCODING)\n        .putMetadata(METADATA_ENCRYPTION_CIPHER_KEY, METADATA_ENCRYPTION_CIPHER)\n        .putMetadata(METADATA_ENCRYPTION_KEY_ID_KEY, ByteString.copyFromUtf8(keyId))\n        .setData(ByteString.copyFrom(encryptedData))\n        .build();\n  }\n\n  private Payload decodePayload(Payload payload) {\n    // Verify the incoming encoded Payload metadata before applying decryption.\n    if (METADATA_ENCODING.equals(\n        payload.getMetadataOrDefault(EncodingKeys.METADATA_ENCODING_KEY, null))) {\n      String keyId;\n      try {\n        keyId = payload.getMetadataOrThrow(METADATA_ENCRYPTION_KEY_ID_KEY).toString(UTF_8);\n      } catch (Exception e) {\n        throw new PayloadCodecException(e);\n      }\n      SecretKey key = getKey(keyId);\n      byte[] plainData;\n      Payload decryptedPayload;\n\n      try {\n        plainData = decrypt(payload.getData().toByteArray(), key); // The decrypt method contains your custom decryption logic.\n        decryptedPayload = Payload.parseFrom(plainData);\n        return decryptedPayload;\n      } catch (Throwable e) {\n        throw new PayloadCodecException(e);\n      }\n    } else {\n      return payload;\n    }\n  }\n\n  private String getKeyId() {\n    // Currently there is no context available to vary which key is used.\n    // Use a fixed key for all payloads.\n    // This still supports key rotation as the key ID is recorded on payloads allowing\n    // decryption to use a previous key.\n\n    return \"test-key-test-key-test-key-test!\";\n  }\n\n  private SecretKey getKey(String keyId) {\n    // Key must be fetched from KMS or other secure storage.\n    // Hard coded here only for example purposes.\n    return new SecretKeySpec(keyId.getBytes(UTF_8), \"AES\");\n  }\n\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions with Advanced Query Filter using tctl (Bash)\nDESCRIPTION: Demonstrates advanced filtering of Workflow Executions using the `--query` modifier with `tctl workflow list`. This requires Advanced Visibility configured on the Temporal Cluster. The query uses an SQL-like syntax against Search Attributes. Examples show filtering by Workflow ID, combining multiple conditions (AND/OR), using custom attributes, date ranges, and ordering results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --query \"WorkflowId=<your-workflow-id>\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list \\\n  --query \"WorkflowType='main.SampleParentWorkflow' AND ExecutionStatus='Running'\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list \\\n  --query '(CustomKeywordField = \"keyword1\" and CustomIntField >= 5) or CustomKeywordField = \"keyword2\"' \\\n  --print_search_attr\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list \\\n  --query 'CustomKeywordField in (\"keyword2\", \"keyword1\") and CustomIntField >= 5 and CloseTime between \"2018-06-07T16:16:36-08:00\" and \"2019-06-07T16:46:34-08:00\" order by CustomDatetimeField desc' \\\n  --print_search_attr\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" and (WorkflowId = \"1645a588-4772-4dab-b276-5f9db108b3a8\" or RunId = \"be66519b-5f09-40cd-b2e8-20e4106244dc\")'\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list \\\n  --query 'WorkflowType = \"main.Workflow\" StartTime > \"2019-06-07T16:46:34-08:00\" and ExecutionStatus = \"Running\"'\n```\n\n----------------------------------------\n\nTITLE: Using Workflow Condition for Signal Handling in Temporal TypeScript\nDESCRIPTION: Demonstrates the use of workflow.condition to wait for a Signal in a Temporal Workflow. The Workflow pauses execution until the approval Signal is received.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function greetingWorkflow(): Promise<string> {\n  let approvedForRelease = false;\n  let approverName: string | undefined;\n\n  wf.setHandler(approve, (input) => {\n    approvedForRelease = true;\n    approverName = input.name;\n  });\n  ...\n\n  await wf.condition(() => approvedForRelease);\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow Test Suite Structure in Go\nDESCRIPTION: Creates a test suite struct that combines functionality from testify and Temporal's test framework, setting up the foundation for Workflow unit tests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype UnitTestSuite struct {\n        suite.Suite\n        testsuite.WorkflowTestSuite\n\n        env *testsuite.TestWorkflowEnvironment\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple Child Workflows in Parallel in Java\nDESCRIPTION: Example of spawning two Child Workflows of the same type in parallel. This demonstrates how to create multiple workflow stubs and use asynchronous execution to achieve concurrent child workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, \"Hello\", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, \"Bye\", name);\n\n        // Do something else here.\n        ...\n        return \"First: \" + greeting1.get() + \", second: \" + greeting2.get();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Updatable Timer Class in Temporal TypeScript\nDESCRIPTION: Shows the implementation details of an `UpdatableTimer` class for Temporal Workflows. It uses a `while` loop and `wf.condition` to wait either until the deadline is reached or until the deadline is updated (signaled by `deadlineUpdated` flag). It implements `PromiseLike` to be awaitable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/timers.mdx#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// implementation\nexport class UpdatableTimer implements PromiseLike<void> {\n  deadlineUpdated = false;\n  #deadline: number;\n\n  constructor(deadline: number) {\n    this.#deadline = deadline;\n  }\n\n  private async run(): Promise<void> {\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      this.deadlineUpdated = false;\n      if (\n        !(await wf.condition(\n          () => this.deadlineUpdated,\n          this.#deadline - Date.now(),\n        ))\n      ) {\n        break;\n      }\n    }\n  }\n\n  then<TResult1 = void, TResult2 = never>(\n    onfulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>,\n    onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>,\n  ): PromiseLike<TResult1 | TResult2> {\n    return this.run().then(onfulfilled, onrejected);\n  }\n\n  set deadline(value: number) {\n    this.#deadline = value;\n    this.deadlineUpdated = true;\n  }\n\n  get deadline(): number {\n    return this.#deadline;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Task Token for Asynchronous Activity Completion in Go\nDESCRIPTION: Retrieves Activity information including the Task Token using the GetInfo() API. The Task Token will be sent to an external service that will eventually complete the Activity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/asynchronous-activity-completion.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Retrieve the Activity information needed to asynchronously complete the Activity.\nactivityInfo := activity.GetInfo(ctx)\ntaskToken := activityInfo.TaskToken\n// Send the taskToken to the external service that will complete the Activity.\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with the Temporal TypeScript client\nDESCRIPTION: Example showing how to start a workflow using the Temporal TypeScript client and obtain a workflow handle for further interaction. The handle can be used to send Queries, Signals, or Updates to the workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(greetingWorkflow, {\n  taskQueue: 'my-task-queue',\n  args: [myArg],\n  workflowId: 'my-workflow-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Testing a Workflow Signal Timeout in xUnit\nDESCRIPTION: This test demonstrates how to use manual time skipping to test a timeout scenario in a Workflow. It creates a worker with SignalWorkflow, starts the workflow, skips time by 50 seconds, and verifies that the timeout result is returned.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Testing;\nusing Temporalio.Worker;\n\n[Fact]\npublic async Task SignalWorkflow_SignalTimeout_HasExpectedResult()\n{\n    await using var env = WorkflowEnvironment.StartTimeSkippingAsync();\n    using var worker = new TemporalWorker(\n        env.Client,\n        new TemporalWorkerOptions($\"task-queue-{Guid.NewGuid()}\").\n            AddWorkflow<SignalWorkflow>());\n    await worker.ExecuteAsync(async () =>\n    {\n        var handle = await env.Client.StartWorkflowAsync(\n            (SignalWorkflow wf) => wf.RunAsync(),\n            new(id: $\"wf-{Guid.NewGuid()}\", taskQueue: worker.Options.TaskQueue!));\n        await env.DelayAsync(TimeSpan.FromSeconds(50));\n        Assert.Equal(\"got timeout\", await handle.GetResultAsync());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating Patch to Transition Activities in Temporal Workflow - Python\nDESCRIPTION: Shows how to use the Temporal Python SDK's `deprecate_patch` mechanism to signal that only the new activity should run while keeping historical replay safe for previously patched Workflows. This pattern helps retire the old activity after verifying no legacy runs remain, by recording a deprecated patch marker that doesn't enforce the presence of old code during replay. Dependencies include `deprecate_patch` and the new activity function. Outputs are the result of the new activity with the deprecation marker added to history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@workflow.defn\\nclass MyWorkflow:\\n    @workflow.run\\n    async def run(self) -> None:\\n        workflow.deprecate_patch(\\\"my-patch\\\")\\n        self._result = await workflow.execute_activity(\\n            post_patch_activity,\\n            schedule_to_close_timeout=timedelta(minutes=5),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Implementing a Loan Application Workflow in Go\nDESCRIPTION: A more detailed example of a Temporal Workflow function in Go. This function executes an Activity to perform a credit check and returns the results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc LoanApplication(ctx workflow.Context, input *LoanApplicationWorkflowInput) (*LoanApplicationWorkflowResult, error) {\n\t// ...\n\tvar result activities.CreditCheckResult\n\tf := workflow.ExecuteActivity(ctx, a.CreditCheck, CreditCheckInput(*input))\n\terr := f.Get(ctx, &result)\n\t// ...\n\t// Return the results\n\treturn &loanApplicationResults, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Worker with Encrypted Data Converter\nDESCRIPTION: Code example showing how to configure a Temporal Worker with a custom data converter that supports encryption. This enables the worker to decrypt incoming payloads and encrypt outgoing ones.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'encryption',\n  dataConverter: await getDataConverter(),\n});\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Activity for Greeting Service - Temporal Activity Pattern - .NET C#\nDESCRIPTION: Defines a strongly-typed Temporal Activity in C# that asynchronously returns a greeting for a specified language, simulating a network service call. This code requires an enumeration for Language, the Temporalio .NET SDK, and correct Activity attribute usage. The main parameter is the language type; the result is a language-appropriate greeting string, or null if not available. It demonstrates proper async Activity handling and result dispatching.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActivities\n{\n    private static readonly Dictionary<Language, string> Greetings = new()\n    {\n        [Language.Arabic] = \"\\u0645\\u0631\\u062d\\u0628\\u0627 \\u0628\\u0627\\u0644\\u0639\\u0627\\u0644\\u0645\",\n        [Language.Chinese] = \"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\",\n        [Language.English] = \"Hello, world\",\n        [Language.French] = \"Bonjour, monde\",\n        [Language.Hindi] = \"\\u0928\\u092e\\u0938\\u094d\\u0924\\u0947 \\u0926\\u0941\\u0928\\u093f\\u092f\\u093e\",\n        [Language.Spanish] = \"Hola mundo\",\n    };\n\n    [Activity]\n    public async Task<string?> CallGreetingServiceAsync(Language language)\n    {\n        // Pretend that we are calling a remove service\n        await Task.Delay(200);\n        return Greetings.TryGetValue(language, out var value) ? value : null;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Signal Handler Methods in Temporal Python Workflows - Python\nDESCRIPTION: This code snippet shows how to define a Signal handler method on a Workflow class using the Temporal Python SDK. Signal handlers allow asynchronous state mutation within the Workflow based on client messages. The snippet demonstrates best practices such as using dataclasses for strongly-typed input, mutating Workflow instance state, and marking the method with the correct decorator. No return value is expected, and input is provided via the ApproveInput dataclass.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass ApproveInput:\n    name: str\n\n@workflow.defn\nclass GreetingWorkflow:\n    ...\n    @workflow.signal\n    def approve(self, input: ApproveInput) -> None:\n        # \\ud83d\\udc49 A Signal handler mutates the Workflow state but cannot return a value.\n        self.approved_for_release = True\n        self.approver_name = input.name\n```\n\n----------------------------------------\n\nTITLE: Sending a Query Message to a Workflow using WorkflowHandle in Temporal Python SDK - Python\nDESCRIPTION: This snippet demonstrates the use of the WorkflowHandle.query method to synchronously retrieve Workflow state by calling a previously defined Query handler. The code uses async/await patterns supported by the Temporal Python SDK. Inputs and outputs are strongly typed, and it shows how to make a client-side query for supported languages, leveraging the dataclass input type. No additional dependencies are required beyond the Temporal Python client.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsupported_languages = await workflow_handle.query(\n    GreetingWorkflow.get_languages, GetLanguagesInput(supported_only=True)\n)\n```\n\n----------------------------------------\n\nTITLE: Worker Process with Host Builder and DI in C#\nDESCRIPTION: Shows how to create a Worker Process using the HostBuilder and Dependency Injection approach with the Temporalio.Extensions.Hosting extension. It configures logging, services, and the Temporal worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar host = Host.CreateDefaultBuilder(args)\n    .ConfigureLogging(ctx => ctx.AddSimpleConsole().SetMinimumLevel(LogLevel.Information))\n    .ConfigureServices(ctx =>\n        ctx.\n            AddScoped<IMyDatabaseClient, MyDatabaseClient>().\n            AddHostedTemporalWorker(\n                clientTargetHost: \"localhost:7233\",\n                clientNamespace: \"default\",\n                taskQueue: \"my-task-queue\").\n            AddScopedActivities<MyActivities>().\n            AddWorkflow<MyWorkflow>())\n    .Build();\nawait host.RunAsync();\n```\n\n----------------------------------------\n\nTITLE: Using Selectors with Timers in Temporal Go SDK\nDESCRIPTION: Example of setting up a race between a timer and an activity, implementing a \"soft\" timeout that sends a notification email if the activity takes too long without canceling it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/selectors.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar processingDone bool\nf := workflow.ExecuteActivity(ctx, OrderProcessingActivity)\nselector.AddFuture(f, func(f workflow.Future) {\n\tprocessingDone = true\n\t// cancel timerFuture\n\tcancelHandler()\n})\n\n// use timer future to send notification email if processing takes too long\ntimerFuture := workflow.NewTimer(childCtx, processingTimeThreshold)\nselector.AddFuture(timerFuture, func(f workflow.Future) {\n\tif !processingDone {\n\t\t// processing is not done yet when timer fires, send notification email\n\t\t_ = workflow.ExecuteActivity(ctx, SendEmailActivity).Get(ctx, nil)\n\t}\n})\n\n// wait the timer or the order processing to finish\nselector.Select(ctx)\n```\n\n----------------------------------------\n\nTITLE: Using workflow.Go() for Deterministic Threading in Go SDK\nDESCRIPTION: The Temporal Go SDK provides workflow.Go() as a replacement for native Go threading in Workflows. This mechanism ensures deterministic execution by controlling thread access through a deterministic runner, which executes one thread at a time in a controlled order.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/go-sdk-multithreading.mdx#2025-04-23_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Implementing Custom PayloadCodec Encode/Decode Functions\nDESCRIPTION: Implementation of a custom PayloadCodec that uses Snappy compression for encoding and decoding payloads. Includes both Encode and Decode methods with proper error handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/converters-and-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Codec implements converter.PayloadEncoder for snappy compression.\ntype Codec struct{}\n\n// Encode implements converter.PayloadCodec.Encode.\nfunc (Codec) Encode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {\n\tresult := make([]*commonpb.Payload, len(payloads))\n\tfor i, p := range payloads {\n\t\t// Marshal proto\n\t\torigBytes, err := p.Marshal()\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t\t// Compress\n\t\tb := snappy.Encode(nil, origBytes)\n\t\tresult[i] = &commonpb.Payload{\n\t\t\tMetadata: map[string][]byte{converter.MetadataEncoding: []byte(\"binary/snappy\")},\n\t\t\tData:     b,\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\n// Decode implements converter.PayloadCodec.Decode.\nfunc (Codec) Decode(payloads []*commonpb.Payload) ([]*commonpb.Payload, error) {\n\tresult := make([]*commonpb.Payload, len(payloads))\n\tfor i, p := range payloads {\n\t\t// Decode only if it's our encoding\n\t\tif string(p.Metadata[converter.MetadataEncoding]) != \"binary/snappy\" {\n\t\t\tresult[i] = p\n\t\t\tcontinue\n\t\t}\n\t\t// Uncompress\n\t\tb, err := snappy.Decode(nil, p.Data)\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t\t// Unmarshal proto\n\t\tresult[i] = &commonpb.Payload{}\n\t\terr = result[i].Unmarshal(b)\n\t\tif err != nil {\n\t\t\treturn payloads, err\n\t\t}\n\t}\n\n\treturn result, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Canceling a Temporal Workflow Execution in Python\nDESCRIPTION: This snippet demonstrates how to gracefully cancel a running Temporal Workflow Execution using the Python SDK. It retrieves the Workflow handle using its ID via the client and then calls the `cancel()` method on the handle. This sends a cancellation request to the Workflow, allowing it to perform cleanup actions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/cancellation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nawait client.get_workflow_handle(\"your_workflow_id\").cancel()\n```\n\n----------------------------------------\n\nTITLE: Handling Cancellation in Temporal Workflow - Go\nDESCRIPTION: This snippet shows how to handle a Cancellation request within a Workflow using Go's defer and the workflow.NewDisconnectedContext API. It includes setting up Activity options, handling cleanup on cancellation, and executing Activities that may be canceled or skipped.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/cancellation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflow(ctx workflow.Context) error {\n\tactivityOptions := workflow.ActivityOptions{\n\t\tHeartbeatTimeout:    5 * time.Second,\n\t\tWaitForCancellation: true,\n\t}\n\tdefer func() {\n\t\tif !errors.Is(ctx.Err(), workflow.ErrCanceled) {\n\t\t\treturn\n\t\t}\n\t\tnewCtx, _ := workflow.NewDisconnectedContext(ctx)\n\t\terr := workflow.ExecuteActivity(newCtx, a.CleanupActivity).Get(ctx, nil)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"CleanupActivity failed\", \"Error\", err)\n\t\t}\n\t}()\n\terr := workflow.ExecuteActivity(ctx, a.ActivityToBeCanceled).Get(ctx, &result)\n\terr = workflow.ExecuteActivity(ctx, a.ActivityToBeSkipped).Get(ctx, nil)\n\treturn err\n}\n```\n\n----------------------------------------\n\nTITLE: Using Update-With-Start from a Temporal Client in Python\nDESCRIPTION: This snippet showcases the Update-With-Start feature, which sends an Update that starts the Workflow if it doesn't exist, or updates the existing one. It uses `client.execute_update_with_start_workflow`, requiring a `WithStartWorkflowOperation` object that defines the workflow to start (including ID, task queue, and ID conflict policy). The example attempts the update, handles potential `WorkflowUpdateFailedError`, and retrieves the workflow handle from the start operation object.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n```python\nstart_op = WithStartWorkflowOperation(\n    ShoppingCartWorkflow.run,\n    id=cart_id,\n    id_conflict_policy=common.WorkflowIDConflictPolicy.USE_EXISTING,\n    task_queue=\"my-task-queue\",\n)\ntry:\n    price = Decimal(\n        await temporal_client.execute_update_with_start_workflow(\n            ShoppingCartWorkflow.add_item,\n            ShoppingCartItem(sku=item_id, quantity=quantity),\n            start_workflow_operation=start_op,\n        )\n    )\nexcept WorkflowUpdateFailedError:\n    price = None\n\nworkflow_handle = await start_op.workflow_handle()\n\nreturn price, workflow_handle\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow with Typed Object Parameters in TypeScript\nDESCRIPTION: Defines a TypeScript Workflow function `example` within a `workflows.ts` file that accepts a typed object parameter. An interface `ExampleParam` (with `name` and `born` properties) is defined and used to type the function's input parameter. It uses destructuring to access the parameter properties and returns a Promise resolving to a formatted string incorporating these values. This demonstrates using interfaces for clearer Workflow signatures and type safety.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface ExampleParam {\n  name: string;\n  born: number;\n}\nexport async function example({ name, born }: ExampleParam): Promise<string> {\n  return `Hello ${name}, you were born in ${born}.`;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Starting a Child Workflow with Temporal TypeScript SDK\nDESCRIPTION: This snippet demonstrates how to start a Child Workflow Execution using the Temporal TypeScript SDK's startChild function. It imports the necessary dependency (@temporalio/workflow) and shows how to obtain a handle for the running Child Workflow, signal it, and get its result. Key options such as workflowId, cancellationType, and parentClosePolicy may be specified as needed. The function expects an array of names as input and supports advanced control operations through the handle.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { startChild } from '@temporalio/workflow';\n\nexport async function parentWorkflow(names: string[]) {\n  const childHandle = await startChild(childWorkflow, {\n    args: [name],\n    // workflowId, // add business-meaningful workflow id here\n    // // regular workflow options apply here, with two additions (defaults shown):\n    // cancellationType: ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,\n    // parentClosePolicy: ParentClosePolicy.PARENT_CLOSE_POLICY_TERMINATE\n  });\n  // you can use childHandle to signal or get result here\n  await childHandle.signal('anySignal');\n  const result = childHandle.result();\n  // you can use childHandle to signal, query, cancel, terminate, or get result here\n}\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowRunTimeout in Go\nDESCRIPTION: This snippet shows how to configure the maximum duration for a single Workflow Run in Go. It uses `client.StartWorkflowOptions` to set the `WorkflowRunTimeout` field with a `time.Duration`. This timeout applies to a single run; retries or Continue-As-New start new runs with their own timeout. By default, it mirrors `WorkflowExecutionTimeout`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowRunTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Handler in Java Workflow\nDESCRIPTION: Demonstrates how to define and implement a Query handler in a Java Workflow. The Query retrieves a list of languages based on the input parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class MessagePassingIntro {\n\n    public enum Language {\n        CHINESE,\n        ENGLISH,\n        FRENCH,\n        SPANISH,\n        PORTUGUESE,\n    }\n\n    public static class GetLanguagesInput {\n        public boolean includeUnsupported;\n\n        public GetLanguagesInput() {\n            this.includeUnsupported = false;\n        }\n\n        public GetLanguagesInput(boolean includeUnsupported) {\n            this.includeUnsupported = includeUnsupported;\n        }\n    }\n\n    @WorkflowInterface\n    public interface GreetingWorkflow {\n        ...\n        // 👉 Use the @QueryMethod annotation to define a Query handler in the\n        // Workflow interface.\n        @QueryMethod\n        List<Language> getLanguages(GetLanguagesInput input);\n    }\n\n    public static class GreetingWorkflowImpl implements GreetingWorkflow {\n        ...\n        @Override\n        public List<Language> getLanguages(GetLanguagesInput input) {\n            // 👉 The Query handler returns a value: it must not mutate the Workflow state\n            // or perform blocking operations.\n            if (input.includeUnsupported) {\n                return Arrays.asList(Language.values());\n            } else {\n                return new ArrayList(greetings.keySet());\n            }\n        }\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Parameters Struct in Go\nDESCRIPTION: Defines a Go struct `YourActivityParam` to encapsulate data passed as parameters to an Activity Definition. This approach is recommended to maintain function signature compatibility even if the parameter fields change over time. The example shows the struct definition and its usage in the `YourActivityDefinition` function signature, which also includes the standard `context.Context` as the first parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n// YourActivityParam is the struct passed to your Activity.\n// Use a struct so that your function signature remains compatible if fields change.\ntype YourActivityParam struct {\n    ActivityParamX string\n    ActivityParamY int\n}\n// ...\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using nonCancellable to Shield Activities from Cancellation\nDESCRIPTION: This example shows how to use CancellationScope.nonCancellable to prevent an activity from being cancelled. The workflow will continue to execute the activity to completion regardless of any cancellation requests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nonCancellable(url: string): Promise<any> {\n  // Prevent Activity from being cancelled and await completion.\n  // Note that the Workflow is completely oblivious and impervious to cancellation in this example.\n  return CancellationScope.nonCancellable(() => httpGetJSON(url));\n}\n```\n\n----------------------------------------\n\nTITLE: Developing Starter for Caller Workflow in Go\nDESCRIPTION: This snippet demonstrates how to develop a starter program to initiate the caller Workflow. It sets up the client, executes the Workflows, and prints the results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"go.temporal.io/sdk/client\"\n\n\t\"github.com/temporalio/samples-go/nexus/caller\"\n\t\"github.com/temporalio/samples-go/nexus/options\"\n\t\"github.com/temporalio/samples-go/nexus/service\"\n)\n\nfunc main() {\n\tclientOptions, err := options.ParseClientOptionFlags(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatalf(\"Invalid arguments: %v\", err)\n\t}\n\tc, err := client.Dial(clientOptions)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\trunWorkflow(c, caller.EchoCallerWorkflow, \"Nexus Echo 👋\")\n\trunWorkflow(c, caller.HelloCallerWorkflow, \"Nexus\", service.ES)\n}\n\nfunc runWorkflow(c client.Client, workflow interface{}, args ...interface{}) {\n\tctx := context.Background()\n\tworkflowOptions := client.StartWorkflowOptions{\n\t\tID:        \"nexus_hello_caller_workflow_\" + time.Now().Format(\"20060102150405\"),\n\t\tTaskQueue: caller.TaskQueue,\n\t}\n\n\twr, err := c.ExecuteWorkflow(ctx, workflowOptions, workflow, args...)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to execute workflow\", err)\n\t}\n\tlog.Println(\"Started workflow\", \"WorkflowID\", wr.GetID(), \"RunID\", wr.GetRunID())\n\n\t// Synchronously wait for the workflow completion.\n\tvar result string\n\terr = wr.Get(context.Background(), &result)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable get workflow result\", err)\n\t}\n\tlog.Println(\"Workflow result:\", result)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing an Update on a Workflow in Temporal TypeScript\nDESCRIPTION: Example showing how to synchronously execute an Update on a Workflow and wait for completion using WorkflowHandle.executeUpdate. This is a blocking call that can change Workflow state and return a result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nlet previousLanguage = await handle.executeUpdate(setLanguage, {\n  args: [Language.CHINESE],\n});\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Deterministic Workflow Execution in Python\nDESCRIPTION: This code snippet illustrates a Workflow Definition that violates the determinism constraint by using a random number generator. It shows how this can lead to different execution paths during replay, causing a non-deterministic error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/event-history/python.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\n@workflow.defn\nclass NonDeterministicWorkflow:\n    @workflow.run\n    async def run(self):\n        await workflow.execute_activity(\n            import_sales_data,\n            start_to_close_timeout=timedelta(seconds=5)\n        )\n        \n        if random.randint(0, 100) > 80:\n            await workflow.timer(timedelta(seconds=5))\n        \n        await workflow.execute_activity(\n            run_daily_report,\n            start_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n----------------------------------------\n\nTITLE: Wait Condition for Signal Handling\nDESCRIPTION: Example showing how to use workflow.wait_condition to pause workflow execution until a specific signal is received.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@workflow.defn\nclass GreetingWorkflow:\n    def __init__(self) -> None:\n        self.approved_for_release = False\n        self.approver_name: Optional[str] = None\n\n    @workflow.signal\n    def approve(self, input: ApproveInput) -> None:\n        self.approved_for_release = True\n        self.approver_name = input.name\n\n    @workflow.run\n    async def run(self) -> str:\n        await workflow.wait_condition(lambda: self.approved_for_release)\n        ...\n        return self.greetings[self.language]\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client for Temporal Cloud Connection in Java\nDESCRIPTION: This code snippet demonstrates how to initialize a Temporal Client to connect to Temporal Cloud in Java. It includes setting up SSL context, gRPC endpoint, and configuring the service stub and client options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n// Generate an SSL context\nInputStream clientCertInputStream = new FileInputStream(clientCertPath);\nInputStream clientKeyInputStream = new FileInputStream(clientKeyPath);\nSslContext sslContext = SimpleSslContextBuilder.forPKCS8(clientCertInputStream, clientKeyInputStream).build();\n\n// Set the Service Stub options (SSL context and gRPC endpoint)\nWorkflowServiceStubsOptions stubsOptions = WorkflowServiceStubsOptions\n    .newBuilder()\n    .setSslContext(sslContext)\n    .setTarget(gRPCEndpoint)\n    .build();\n\n // Create a stub that accesses a Temporal Service\nWorkflowServiceStubs serviceStub = WorkflowServiceStubs.newServiceStubs(stubsOptions);\n\n// Set the Client options\nWorkflowClientOptions clientOptions = WorkflowClientOptions\n    .newBuilder()\n    .setNamespace(namespace)\n    .build();\n\n// Initialize the Temporal Client\n// This application uses the Client to communicate with the Temporal Service\nWorkflowClient client = WorkflowClient.newInstance(serviceStub, clientOptions);\n```\n\n----------------------------------------\n\nTITLE: Ensuring Handlers Finish Before Workflow Completion in Go\nDESCRIPTION: Example of using workflow.Await with AllHandlersFinished to ensure all handlers complete before the Workflow finishes. This prevents handler interruption and client errors when trying to retrieve Update results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n    ...\n\terr = workflow.Await(ctx, func() bool {\n\t\treturn workflow.AllHandlersFinished(ctx)\n\t})\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Upserting Custom Search Attributes within a Workflow in Python\nDESCRIPTION: Shows how to update or add Search Attributes to a running workflow using `workflow.upsert_search_attributes()`. It passes a `TypedSearchAttributes` object containing `SearchAttributePair` instances to update the value associated with `customer_id_key`. This operation requires the Temporal Python SDK (`temporalio`) and is executed within the workflow's code, assuming `customer_id_key` is accessible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n```python\nworkflow.upsert_search_attributes(TypedSearchAttributes([\n    SearchAttributePair(customer_id_key, \"customer_2\")\n]))\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Activity Parameter Validation in Go\nDESCRIPTION: Shows how to override an Activity with a custom implementation to validate that it's called with the expected parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityParamCorrect() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          func(ctx context.Context, value string) (string, error) {\n                s.Equal(\"test_success\", value)\n                return value, nil\n        })\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Worker Process in C#\nDESCRIPTION: Demonstrates how to create and run a Worker Process that polls for tasks from a specific Task Queue and executes Workflows and Activities. It includes error handling and cancellation support.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\")\n{\n    LoggerFactory = LoggerFactory.Create(builder =>\n        builder.\n            AddSimpleConsole(options => options.TimestampFormat = \"[HH:mm:ss] \").\n            SetMinimumLevel(LogLevel.Information)),\n});\n\nusing var tokenSource = new CancellationTokenSource();\nConsole.CancelKeyPress += (_, eventArgs) =>\n{\n    tokenSource.Cancel();\n    eventArgs.Cancel = true;\n};\n\nvar activities = new MyActivities();\n\nConsole.WriteLine(\"Running worker\");\nusing var worker = new TemporalWorker(\n    client,\n    new TemporalWorkerOptions(taskQueue: \"my-task-queue\").\n        AddAllActivities(activities).\n        AddWorkflow<MyWorkflow>());\ntry\n{\n    await worker.ExecuteAsync(tokenSource.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Worker cancelled\");\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Workflow Start Using Typed Stub - Temporal PHP\nDESCRIPTION: Initiates a Workflow Execution asynchronously using a Workflow stub and the Temporal Client, returning a WorkflowRun object for result inspection or control. This method is suited for scenarios not requiring immediate result blocking. Required elements include the WorkflowClient, an interface-compliant stub, and the necessary transfer parameters; the WorkflowRun object handles execution reference and result retrieval.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_9\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$accountTransfer = $workflowClient->newWorkflowStub(\\n    AccountTransferWorkflowInterface::class,\\n);\\n\\n$run = $this->workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow Executions using listWorkflowExecutions in PHP\nDESCRIPTION: Demonstrates how to use the listWorkflowExecutions() method on the Workflow Client to query and iterate over Workflow Executions using a List Filter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$paginator = $workflowClient->listWorkflowExecutions('WorkflowType=\"GreetingWorkflow\"');\n\nforeach ($paginator as $info) {\n    echo \"Workflow ID: {$info->execution->getID()}\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Child Workflow Execution in PHP\nDESCRIPTION: This snippet demonstrates how to start a Child Workflow Execution using Temporal's PHP SDK. It shows how to create a Child Workflow stub, configure options, and handle the result asynchronously using promises.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$child = Workflow::newChildWorkflowStub(\n    ChildWorkflowInterface::class,\n    ChildWorkflowOptions::new()\n        ->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW')\n        ->withExecutionStartToCloseTimeout(DateInterval::createFromDateString('30 minutes'))\n);\n\n$promise = $child->workflowMethod('value');\n\ntry{\n    $value = yield $promise;\n} catch(TemporalException $e) {\n    $logger->error('child workflow failed');\n    throw $e;\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Build ID and Opting In to Worker Versioning in TypeScript (Legacy)\nDESCRIPTION: This snippet demonstrates how to configure a Temporal Worker in TypeScript to use the legacy Worker Versioning feature. It involves passing a `buildId` (e.g., from an environment variable or code hash) and setting `useVersioning` to `true` within the `Worker.create` options. This Worker will only process tasks once assignment rules are configured for its `buildId`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nconst worker = await Worker.create({\n  taskQueue: 'your_task_queue_name',\n  buildId: buildId,\n  useVersioning: true,\n  // ...\n});\n// ...\n```\n\n----------------------------------------\n\nTITLE: Querying a Workflow Using the Temporal Go Client\nDESCRIPTION: Shows how to execute a query against a specific Workflow Execution using `temporalClient.QueryWorkflow`. It passes the necessary context, identifiers (Workflow ID, Run ID), query name (`message.GetLanguagesQuery`), and input arguments (`message.GetLanguagesInput`). The code then retrieves the query result into the `supportedLang` variable using `supportedLangResult.Get()` and logs it, including error handling. Queries are read-only operations and don't affect Workflow state or history; they require an active Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// ...\nsupportedLangResult, err := temporalClient.QueryWorkflow(context.Background(), we.GetID(), we.GetRunID(), message.GetLanguagesQuery, message.GetLanguagesInput{IncludeUnsupported: false})\nif err != nil {\n    log.Fatalf(\"Unable to query workflow: %v\", err)\n}\nvar supportedLang []message.Language\nerr = supportedLangResult.Get(&supportedLang)\nif err != nil {\n    log.Fatalf(\"Unable to get query result: %v\", err)\n}\nlog.Println(\"Supported languages:\", supportedLang)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Handling Signals in a Workflow Implementation in PHP\nDESCRIPTION: This snippet shows how to implement a Workflow that handles signals. It demonstrates the use of the SignalMethod attribute to define a method that updates a value in response to a signal, and uses Workflow::await() to wait for the value to change.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: PHP\nCODE:\n```\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private bool $value;\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        yield Workflow::await(fn()=> $this->value);\n        return 'OK';\n    }\n\n    #[Workflow\\SignalMethod]\n    public function setValue(bool $value)\n    {\n        $this->value = $value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Upserting Temporal Search Attributes within a Workflow in TypeScript\nDESCRIPTION: This snippet illustrates how to modify Search Attributes from within a running Temporal Workflow function using the TypeScript SDK. It reads an existing attribute using `workflowInfo().searchAttributes`, then uses `upsertSearchAttributes` to overwrite one attribute (`CustomIntField`), delete another (`CustomBoolField` by setting it to an empty array), and add a new one (`CustomDoubleField`). The function returns the updated search attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nimport { workflowInfo, upsertSearchAttributes } from '@temporalio/workflow';\nimport { SearchAttributes } from '@temporalio/common';\n\nexport async function example(): Promise<SearchAttributes> {\n  const customInt =\n    (workflowInfo().searchAttributes.CustomIntField?.[0] as number) || 0;\n  upsertSearchAttributes({\n    // overwrite the existing CustomIntField: [2]\n    CustomIntField: [customInt + 1],\n\n    // delete the existing CustomBoolField: [true]\n    CustomBoolField: [],\n\n    // add a new value\n    CustomDoubleField: [3.14],\n  });\n  return workflowInfo().searchAttributes;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Timeout for Multiple Activities with withTimeout\nDESCRIPTION: This example demonstrates using CancellationScope.withTimeout to set a common timeout for multiple activities. If the timeout triggers before all activities complete, the workflow will fail with a CancelledError.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nexport function multipleActivitiesSingleTimeout(\n  urls: string[],\n  timeoutMs: number,\n): Promise<any> {\n  const { httpGetJSON } = proxyActivities<typeof activities>({\n    startToCloseTimeout: timeoutMs,\n  });\n\n  // If timeout triggers before all activities complete\n  // the Workflow will fail with a CancelledError.\n  return CancellationScope.withTimeout(\n    timeoutMs,\n    () => Promise.all(urls.map((url) => httpGetJSON(url))),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Prometheus Metrics Reporting in Temporal Java SDK (Java)\nDESCRIPTION: This Java snippet shows how to initialize and configure the Prometheus registry and stats reporter within a Temporal Java SDK Client. It sets up metric reporting with custom tag values, configures Prometheus metrics scraping at a designated port (8077), and integrates the metrics scope into WorkflowServiceStubs and WorkflowClient. Dependencies include Micrometer, PrometheusMeterRegistry, StatsReporter, and proper import statements for supporting classes and Temporal SDK. The setup requires Micrometer and Prometheus Java libraries plus any Temporal SDK tooling necessary. Inputs include registry configuration, client/service stubs options, and scope definitions; outputs are active metrics endpoints and enabled reporting for Prometheus to scrape. The code assumes support for proper shutdown handling and guidance provided in Micrometer documentation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n//...\\n// You need to import the following packages to set up metrics in Java.\\n// See the Developer's guide for packages required for the other SDKs.\\nimport com.sun.net.httpserver.HttpServer;\\nimport com.uber.m3.tally.RootScopeBuilder;\\nimport com.uber.m3.tally.Scope;\\nimport com.uber.m3.util.Duration;\\nimport com.uber.m3.util.ImmutableMap;\\n\\n  // See the Micrometer documentation for configuration details on other supported monitoring systems.\\n  // This example shows how to set up the Prometheus registry and stats reported.\\n\\n  PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\\n  StatsReporter reporter = new MicrometerClientStatsReporter(registry);\\n\\n   // set up a new scope, report every 10 seconds\\n    Scope scope = new RootScopeBuilder()\\n            .tags(ImmutableMap.of(\\n                         \"workerCustomTag1\",\\n                         \"workerCustomTag1Value\",\\n                         \"workerCustomTag2\",\\n                         \"workerCustomTag2Value\"))\\n            .reporter(reporter)\\n            .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\\n\\n  // For Prometheus collection, expose the scrape endpoint at port 8077. See Micrometer documentation for details on starting the Prometheus scrape endpoint. For example,\\n  HttpServer scrapeEndpoint = MetricsUtils.startPrometheusScrapeEndpoint(registry, 8077); //note: MetricsUtils is a utility file with the scrape endpoint configuration. See Micrometer docs for details on this configuration.\\n  // Stopping the starter stops the HTTP server that exposes the scrape endpoint.\\n  //Runtime.getRuntime().addShutdownHook(new Thread(() -> scrapeEndpoint.stop(1)));\\n\\n  //Create Workflow service stubs to connect to the Frontend Service.\\n  WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(\\n         WorkflowServiceStubsOptions.newBuilder()\\n                 .setMetricsScope(scope) //set the metrics scope for the WorkflowServiceStubs\\n                 .build());\\n\\n  //Create a Workflow service client, which can be used to start, signal, and query Workflow Executions.\\n  WorkflowClient yourClient = WorkflowClient.newInstance(service,\\n         WorkflowClientOptions.newBuilder().build());\\n\\n  //...\n```\n\n----------------------------------------\n\nTITLE: Registering an Activity with a Custom Name in a Temporal Worker (TypeScript)\nDESCRIPTION: Illustrates how to assign a custom name (`activityFoo`) to an Activity function (`greet`) when registering activities with a Temporal Worker using `Worker.create`. This allows decoupling the implementation function name from the Activity Type name used for invocation from a Workflow. Requires the `@temporalio/worker` package and the Activity function implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { Worker } from '@temporalio/worker';\nimport { greet } from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities: {\n      activityFoo: greet,\n    },\n  });\n\n  await worker.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Checksum Calculation with Version Control\nDESCRIPTION: Modified implementation that adds checksum calculation while maintaining backward compatibility using Workflow.getVersion().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        int version = Workflow.getVersion(\"checksumAdded\", Workflow.DEFAULT_VERSION, 1);\n        if (version == Workflow.DEFAULT_VERSION) {\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } else {\n            long checksum = activities.calculateChecksum(processedName);\n            activities.uploadWithChecksum(\n                args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n        }\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replaying Workflow Executions Using WorkflowReplayer in Java\nDESCRIPTION: This Java code illustrates how to fetch a list of Workflow Event Histories from a Temporal server based on a Task Queue query and replay the executions using the WorkflowReplayer class. Dependencies include a properly initialized WorkflowServiceStubs and WorkflowClient, as well as access to the temporal-testing package. Required parameters include the namespace, Task Queue, and one or more Workflow classes. The snippet expects Advanced Visibility to be enabled and will throw errors if the history is non-deterministic. Inputs are the Task Queue name and desired Workflows, and outputs are handled by exceptions or logging from the replay call.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n// Note we assume you already have a WorkflowServiceStubs (`service`) and WorkflowClient (`client`)\nListWorkflowExecutionsRequest listWorkflowExecutionRequest =\n    ListWorkflowExecutionsRequest.newBuilder()\n        .setNamespace(client.getOptions().getNamespace())\n        .setQuery(\"TaskQueue = 'mytaskqueue'\")\n        .build();\nListWorkflowExecutionsResponse listWorkflowExecutionsResponse =\n    service.blockingStub().listWorkflowExecutions(listWorkflowExecutionRequest);\nList<WorkflowExecutionHistory> histories =\n    listWorkflowExecutionsResponse.getExecutionsList().stream()\n        .map(\n            (info) -> {\n              GetWorkflowExecutionHistoryResponse weh =\n                  service.blockingStub().getWorkflowExecutionHistory(\n                      GetWorkflowExecutionHistoryRequest.newBuilder()\n                          .setNamespace(testEnvironment.getNamespace())\n                          .setExecution(info.getExecution())\n                          .build());\n              return new WorkflowExecutionHistory(\n                  weh.getHistory(), info.getExecution().getWorkflowId());\n            })\n        .collect(Collectors.toList());\n\nWorkflowReplayer.replayWorkflowExecutions(\n    histories, true, WorkflowA.class, WorkflowB.class, WorkflowC.class);\n```\n\n----------------------------------------\n\nTITLE: Working with Nested Cancellation Scopes in TypeScript\nDESCRIPTION: This example shows complex workflow patterns with nested cancellation scopes. It demonstrates setup in a nonCancellable scope, an activity with a timeout, and cleanup in another nonCancellable scope if cancellation occurs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\n\nimport type * as activities from '../activities';\n\nconst { setup, httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nestedCancellation(url: string): Promise<void> {\n  await CancellationScope.cancellable(async () => {\n    await CancellationScope.nonCancellable(() => setup());\n    try {\n      await CancellationScope.withTimeout(\n        1000,\n        () => httpPostJSON(url, { some: 'data' }),\n      );\n    } catch (err) {\n      if (isCancellation(err)) {\n        await CancellationScope.nonCancellable(() => cleanup(url));\n      }\n      throw err;\n    }\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Search Attributes in Temporal WorkflowOptions - Java\nDESCRIPTION: This snippet shows how to define a custom SearchAttributeKey and include a custom Search Attribute when starting a Workflow Execution using the Java SDK. The Search Attribute key is defined as a shared constant, ensuring reusability across multiple files. The snippet uses the WorkflowOptions builder pattern to set the workflow ID, task queue, and custom Search Attributes, which are generated with a helper function. Key parameters include workflow ID, task queue name, and the map of Search Attributes. Requires Temporal Java SDK and appropriate imports.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\n    // In a shared constants file, so all files have access\n\n    public static final SearchAttributeKey<Boolean> IS_ORDER_FAILED = SearchAttributeKey.forBoolean(\"isOrderFailed\");\n...\n    // In main\n    WorkflowOptions options = WorkflowOptions.newBuilder()\n        .setWorkflowId(workflowID)\n        .setTaskQueue(Constants.TASK_QUEUE_NAME)\n        .setTypedSearchAttributes(generateSearchAttributes())\n        .build();\n\n    PizzaWorkflow workflow = client.newWorkflowStub(PizzaWorkflow.class, options);\n...\n    // Further down in the file\n    private static Map<String, Object> generateSearchAttributes(){\n        return SearchAttributes.newBuilder().set(Constants.IS_ORDER_FAILED, false).build();\n    }\n```\n\n----------------------------------------\n\nTITLE: Basic Side Effect Random Number Generation - Java\nDESCRIPTION: Example showing how to generate a random number using Side Effect in a Workflow and use it for conditional logic. The random value is stored in the Workflow Event History for consistent replays.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/side-effects.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nint random = Workflow.sideEffect(Integer.class, () -> random.nextInt(100));\nif random < 50 {\n       ....\n} else {\n       ....\n}\n```\n\n----------------------------------------\n\nTITLE: Proxying Dependency-Injected Activities in a Temporal Workflow (TypeScript)\nDESCRIPTION: Shows how to correctly type and proxy Temporal Activities defined using a factory function (`createActivities`) within a Workflow, completing the dependency injection pattern. It uses `proxyActivities` combined with the `ReturnType<typeof createActivities>` utility type to infer the types of the proxied activities (`greet`, `greet_es`), ensuring type safety during invocation. Requires `@temporalio/workflow` and the activity factory function type.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nimport type { createActivities } from './activities';\n\n// Note usage of ReturnType<> generic since createActivities is a factory function\nconst { greet, greet_es } = proxyActivities<\n  ReturnType<typeof createActivities>\n>({\n  startToCloseTimeout: '30 seconds',\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Timeouts in .NET\nDESCRIPTION: Example of setting Workflow execution timeouts using WorkflowOptions when executing a Workflow. Demonstrates setting the WorkflowExecutionTimeout property.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = await client.ExecuteWorkflowAsync(\n    (MyWorkflow wf) => wf.RunAsync(),\n    new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\")\n    {\n        WorkflowExecutionTimeout = TimeSpan.FromMinutes(5),\n    });\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring a Basic Temporal PHP Worker\nDESCRIPTION: This snippet demonstrates how to create a Worker using the Temporal\\WorkerFactory, register workflow and activity types, and start the primary execution loop. It shows the basic structure for setting up a worker that listens on a Task Queue and handles both workflow and activity implementations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_11\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\ndeclare(strict_types=1);\n\nuse Temporal\\WorkerFactory;\n\nini_set('display_errors', 'stderr');\ninclude \"vendor/autoload.php\";\n\n// factory initiates and runs task queue specific activity and workflow workers\n$factory = WorkerFactory::create();\n\n// Worker that listens on a Task Queue and hosts both workflow and activity implementations.\n$worker = $factory->newWorker();\n\n// Workflows are stateful. So you need a type to create instances.\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n\n// Activities are stateless and thread safe. So a shared instance is used.\n$worker->registerActivity(App\\DemoActivity::class);\n\n// In case an activity class requires some external dependencies provide a callback - factory\n// that creates or builds a new activity instance. The factory should be a callable which accepts\n// an instance of ReflectionClass with an activity class which should be created.\n$worker->registerActivity(App\\DemoActivity::class, fn(ReflectionClass $class) => $container->create($class->getName()));\n\n// start primary loop\n$factory->run();\n```\n\n----------------------------------------\n\nTITLE: Controlling and Terminating Workflows Using Temporal TypeScript SDK\nDESCRIPTION: This snippet shows how to programmatically control and terminate an active Workflow Execution in the Temporal TypeScript SDK by obtaining a handle to itself. It uses getExternalWorkflowHandle and workflowInfo from '@temporalio/workflow' and calls handle.cancel() to request cancellation. No input parameters are required, and the snippet demonstrates the pattern to access and operate on other Workflows from inside a Workflow. This approach is essential for implementing cancellation, termination, or signaling logic from within Workflow code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/child-workflows.mdx#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getExternalWorkflowHandle, workflowInfo } from '@temporalio/workflow';\n\nexport async function terminateWorkflow() {\n  const { workflowId } = workflowInfo(); // no await needed\n  const handle = getExternalWorkflowHandle(workflowId); // sync function, not async\n  await handle.cancel();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Scheduled Workflow with Temporal Python SDK\nDESCRIPTION: Demonstrates how to create a new Workflow Schedule using the Temporal Python SDK. Requires the Temporal Python SDK and an available Temporal server. The main function uses an asynchronous client to connect to the service, creates a unique schedule with specified interval, task queue, and workflow, and can include a custom note. Schedule parameters include interval, cron expressions, and optional jitter. Requires correct imports and a defined workflow function. Inputs: Schedule ID and configuration. Output: Schedule is created on the Temporal server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n\\n    await client.create_schedule(\\n        \"workflow-schedule-id\",\\n        Schedule(\\n            action=ScheduleActionStartWorkflow(\\n                YourSchedulesWorkflow.run,\\n                \"my schedule arg\",\\n                id=\"schedules-workflow-id\",\\n                task_queue=\"schedules-task-queue\",\\n            ),\\n            spec=ScheduleSpec(\\n                intervals=[ScheduleIntervalSpec(every=timedelta(minutes=2))]\\n            ),\\n            state=ScheduleState(note=\"Here's a note on my Schedule.\"),\\n        ),\\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Activity in Java\nDESCRIPTION: Example of implementing a Dynamic Activity using the DynamicActivity interface in Temporal Java SDK. The execute method handles any unregistered Activity type, using Activity.getExecutionContext() to get Activity information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_21\n\nLANGUAGE: java\nCODE:\n```\npublic static class DynamicGreetingActivityImpl implements DynamicActivity {\n   @Override\n   public Object execute(EncodedValues args) {\n     String activityType = Activity.getExecutionContext().getInfo().getActivityType();\n     return activityType\n         + \": \"\n         + args.get(0, String.class)\n         + \" \"\n         + args.get(1, String.class)\n         + \" from: \"\n         + args.get(2, String.class);\n   }\n }\n```\n\n----------------------------------------\n\nTITLE: Initiating Temporal Update-With-Start Waiting for Result (Java)\nDESCRIPTION: Illustrates using the `WorkflowClient.executeUpdateWithStart` method in Java. Similar to `startUpdateWithStart`, it sends an Update (`workflow::setLanguage`) and potentially starts a Workflow (`workflow::getGreetings`). However, this method blocks until the Update completes and directly returns the result (`previousLanguage`). `UpdateOptions` can be minimal or explicitly set to wait for `WorkflowUpdateStage.COMPLETED`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: java\nCODE:\n```\n```java\nLanguage previousLanguage =\n    WorkflowClient.executeUpdateWithStart(\n        workflow::setLanguage,\n        Language.ENGLISH,\n        UpdateOptions.<Language>newBuilder().build(),\n        new WithStartWorkflowOperation<>(workflow::getGreetings));\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Local Temporal Client in .NET\nDESCRIPTION: Demonstrates how to create and connect a Temporal Client to a local Temporal Service using the default connection settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/temporal-client.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring Heartbeat Timeout for Activities - Temporal Python SDK\nDESCRIPTION: Demonstrates how to schedule an Activity in a Temporal workflow with a custom heartbeat timeout using the \"start_activity()\" function. The Activity is configured with both \"schedule_to_close_timeout\" and \"heartbeat_timeout\" parameters (both set as timedeltas), allowing control over activity heartbeat intervals and failure criteria. Requires the Temporal Python SDK, and \"timedelta\" imported from Python's datetime module. Input parameters include the activity name and timeout durations; the output is an Activity handle which can be awaited or cancelled as needed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nworkflow.start_activity(\n    activity=\"your-activity\",\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n----------------------------------------\n\nTITLE: Invoking Local Activities with proxyLocalActivities - Temporal TypeScript\nDESCRIPTION: This snippet demonstrates how to call Local Activities from a workflow using proxyLocalActivities in the Temporal TypeScript SDK. It sets up a proxied Local Activity called getEnvVar with a StartToClose timeout, then asynchronously invokes it within a workflow called yourWorkflow. Required dependencies are '@temporalio/workflow', and the relevant Local Activities must be registered with the Worker. Key parameters include the Local Activity method name and timeout settings. The input to the workflow is none directly; it invokes getEnvVar with a string, and the output is awaited as the result. Limitation: Only works with properly registered Local Activities in the Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/asynchronous-activity-completion.mdx#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as workflow from '@temporalio/workflow';\\n\\nconst { getEnvVar } = workflow.proxyLocalActivities({\\n  startToCloseTimeout: '2 seconds',\\n});\\n\\nexport async function yourWorkflow(): Promise<void> {\\n  const someSetting = await getEnvVar('SOME_SETTING');\\n  // ...\\n}\n```\n\n----------------------------------------\n\nTITLE: Coordinating Handler Execution with asyncio.Lock in Temporal Python (Python)\nDESCRIPTION: This snippet demonstrates how to make asynchronous Workflow handlers safe for concurrent invocation using asyncio.Lock. By wrapping the core work of the handler signal method in an async with block, only one instance may run the critical section at a time, preventing inconsistent state changes. It depends on the Temporal Python SDK and Python's asyncio module, assumes instance variables for state, and is recommended when message ordering and atomicity are critical in the Workflow logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@workflow.defn\nclass MyWorkflow:\n    def __init__(self) -> None:\n        ...\n        self.lock = asyncio.Lock()\n        ...\n\n    @workflow.signal\n    async def safe_async_handler(self):\n        async with self.lock:\n            data = await workflow.execute_activity(\n                fetch_data, start_to_close_timeout=timedelta(seconds=10)\n            )\n            self.x = data.x\n            # ✅ OK: the scheduler may switch now to a different handler execution, or to the main workflow\n            # method, but no other execution of this handler can run until this execution finishes.\n            await asyncio.sleep(1)  # or await anything else\n            self.y = data.y\n```\n\n----------------------------------------\n\nTITLE: Implementing Start Delay for Workflow Execution in Java\nDESCRIPTION: This code illustrates how to delay the start of a Workflow Execution using StartDelay. It creates an instance of WorkflowStub and sets the StartDelay using setStartDelay to schedule the Workflow Execution at a specific future point.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWorkflow\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Start the workflow in 12 hours\n                .setStartDelay(Duration.ofHours(12))\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Creating Datadog Tracing Interceptor in Go\nDESCRIPTION: This snippet illustrates how to create a Datadog tracing interceptor in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// create Interceptor\ntracingInterceptor, err := tracing.NewTracingInterceptor(tracing.TracerOptions{})\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start from a Client in Java\nDESCRIPTION: Shows how to use the Signal-With-Start feature from a Temporal Client. It obtains an untyped `WorkflowStub` and calls `signalWithStart`, providing the Signal name (`\"setCustomer\"`), Signal arguments (`new Object[] {customer2}`), and Workflow start arguments (`new Object[] {customer1}`). This signals the Workflow if running or starts it and then immediately signals it. The example subsequently waits for the Workflow result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npublic static void signalWithStart() {\n    // WorkflowStub is a client-side stub to a single Workflow instance\n    WorkflowStub untypedWorkflowStub = client.newUntypedWorkflowStub(\"GreetingWorkflow\",\n    WorkflowOptions.newBuilder()\n            .setWorkflowId(workflowId)\n            .setTaskQueue(taskQueue)\n            .build());\n\n    untypedWorkflowStub.signalWithStart(\"setCustomer\", new Object[] {customer2}, new Object[] {customer1});\n\n    String greeting = untypedWorkflowStub.getResult(String.class);\n}\n```\n\n----------------------------------------\n\nTITLE: Printing event version in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that includes event version information in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --print_event_version\n```\n\n----------------------------------------\n\nTITLE: Executing a Temporal Workflow with a Cron Schedule in Python\nDESCRIPTION: This snippet demonstrates how to start a Temporal Workflow Execution that repeats based on a cron schedule. It uses the `execute_workflow` method of the Temporal Client, providing the Workflow function (`CronWorkflow.run`), necessary IDs, task queue, and the `cron_schedule` option with a standard cron string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# ...\n    result = await client.execute_workflow(\n        CronWorkflow.run,\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        cron_schedule=\"* * * * *\",\n    )\n    print(f\"Results: {result}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a Temporal Activity Using Protobufs - TypeScript\nDESCRIPTION: This activity takes a protobuf input, constructs a new protobuf result using the static create method, and returns it. It demonstrates best practices for protobuf object creation in TypeScript, ensuring compatibility with Temporal's serialization logic. Requires access to the generated protobuf types and proper payload converter setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\nimport { foo, ProtoResult } from '../protos/root';\n\nexport async function protoActivity(\n  input: foo.bar.ProtoInput,\n): Promise<ProtoResult> {\n  return ProtoResult.create({\n    sentence: `${input.name} is ${input.age} years old.`,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Augmenting the Default Data Converter To Insert Custom Payload Converter in Temporal Go\nDESCRIPTION: This Go snippet demonstrates building a Composite Data Converter by listing all the default Payload Converters in order and injecting a custom Payload Converter before the JSON fall-through. Requires importing \"go.temporal.io/sdk/converter\" and implementing YourCustomPayloadConverter(). Key parameters are the ordered list of built-in converters and the custom one, which ensures type-specific converters are tried in sequence. Input: instances of each required Payload Converter. Output: a Data Converter that preserves default behavior and adds your custom logic with minimal disruption. Custom converter should be placed thoughtfully since order determines which converter is used during serialization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/converters-and-encryption.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ndataConverter := converter.NewCompositeDataConverter(\n  converter.NewNilPayloadConverter(),\n  converter.NewByteSlicePayloadConverter(),\n  converter.NewProtoJSONPayloadConverter(),\n  converter.NewProtoPayloadConverter(),\n  YourCustomPayloadConverter(),\n  converter.NewJSONPayloadConverter(),\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Payload Converter in Temporal Java SDK\nDESCRIPTION: This code defines a class implementing the PayloadConverter interface to serialize and deserialize a custom object type to and from Payloads in Temporal workflows. Developers must provide logic for converting to and from data, specify a unique encoding type, and handle exceptions such as DataConverterException. Dependencies include the Temporal Java SDK and its converter interfaces; input objects and Payload types must align with the application's serialization needs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/converters-and-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n/** Payload Converter specific to your custom object */\\npublic class YourCustomPayloadConverter implements PayloadConverter {\\n //...\\n  @Override\\n  public String getEncodingType() {\\n    return \\\"json/plain\\\"; // The encoding type determines which default conversion behavior to override.\\n  }\\n\\n  @Override\\n  public Optional<Payload> toData(Object value) throws DataConverterException {\\n      // Add your convert-to logic here.\\n  }\\n\\n  @Override\\n  public <T> T fromData(Payload content, Class<T> valueClass, Type valueType)\\n      throws DataConverterException {\\n    // Add your convert-from logic here.\\n  }\\n//...\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker Session in Go SDK\nDESCRIPTION: Use the CreateSession API within Workflow code to create a Session with a Worker. This snippet shows how to create a Session Context, use it for Activity Executions, and properly manage the session lifecycle.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/sessions.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc SomeFileProcessingWorkflow(ctx workflow.Context, param FileProcessingWFParam) error {\n\tactivityOptions := workflow.ActivityOptions{\n\t\tStartToCloseTimeout: time.Minute,\n\t}\n\tctx = workflow.WithActivityOptions(ctx, activityOptions)\n\n\tsessionOptions := &workflow.SessionOptions{\n\t\tCreationTimeout:  time.Minute,\n\t\tExecutionTimeout: time.Minute,\n\t}\n\t// Create a Session with the Worker so that all Activities execute with the same Worker.\n\tsessionCtx, err := workflow.CreateSession(ctx, sessionOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer workflow.CompleteSession(sessionCtx)\n\n\terr = workflow.ExecuteActivity(sessionCtx, a.DownloadFile, param).Get(sessionCtx, &downloadResult)\n\terr = workflow.ExecuteActivity(sessionCtx, a.ProcessFile, processParam).Get(sessionCtx, &processResult)\n\terr = workflow.ExecuteActivity(sessionCtx, a.UploadFile, uploadParam).Get(sessionCtx, nil)\n}\n```\n\n----------------------------------------\n\nTITLE: Signaling Asynchronous Activity Completion in Python\nDESCRIPTION: This snippet demonstrates how to mark a Temporal Activity for asynchronous completion from within the Activity function itself. It first captures the Activity's unique `task_token` using `activity.info().task_token` for later use by an external system, and then calls `activity.raise_complete_async()` to signal to the Temporal Cluster that the Activity will be completed externally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/asynchronous-activity-completion.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Capture token for later completion\ncaptured_token = activity.info().task_token\nactivity.raise_complete_async()\n```\n\n----------------------------------------\n\nTITLE: Defining the PayloadConverter Interface in TypeScript\nDESCRIPTION: Outlines the TypeScript interface `PayloadConverter` required for creating custom data converters that operate within the Workflow sandbox. Implementations must provide synchronous `toPayload` for serializing application values into Temporal Payloads and `fromPayload` for deserializing Payloads back into application values. This is essential for handling non-standard data types like BigInt or Date that are not JSON-serializable by default.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface PayloadConverter {\n  /**\n   * Converts a value to a {@link Payload}.\n   * @param value The value to convert. Example values include the Workflow args sent by the client and the values returned by a Workflow or Activity.\n   */\n  toPayload<T>(value: T): Payload;\n\n  /**\n   * Converts a {@link Payload} back to a value.\n   */\n  fromPayload<T>(payload: Payload): T;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowTaskTimeout using Temporal Java SDK\nDESCRIPTION: This code demonstrates how to set the Workflow Task Timeout in WorkflowOptions when instantiating a Temporal workflow stub. The setWorkflowTaskTimeout method allows you to specify the maximum allowed duration for each workflow task, defaulting to 10 seconds and capped at 60 seconds. Requires the Temporal Java SDK and java.time.Duration. The snippet limits the time each workflow task can remain uncompleted before triggering failure behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_15\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\\nYourWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"YourWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                // Set Workflow Task Timeout duration\\n                .setWorkflowTaskTimeout(Duration.ofSeconds(10))\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Shielding Activities with nonCancellable Scopes in Temporal Workflows\nDESCRIPTION: Shows how activities started in a nonCancellable scope remain protected from cancellation even when awaited outside that scope. This pattern can be used to ensure critical operations complete regardless of workflow cancellation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function shieldAwaitedInRootScope(): Promise<any> {\n  let p: Promise<any> | undefined = undefined;\n\n  await CancellationScope.nonCancellable(async () => {\n    p = httpGetJSON('http://example.com'); // <-- Start activity in nonCancellable scope without awaiting completion\n  });\n  // Activity is shielded from cancellation even though it is awaited in the cancellable root scope\n  return p;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Workflow Executions by Search Attribute in TypeScript\nDESCRIPTION: This snippet demonstrates how to query for Temporal Workflow Executions using the `listWorkflowExecutions` method from the TypeScript client library. It establishes a connection to the Temporal service and then lists executions matching a specific query string, in this case, filtering for executions with the status 'Running'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Connection } from '@temporalio/client';\n\nconst connection = await Connection.connect();\nconst response = await connection.workflowService.listWorkflowExecutions({\n  query: `ExecutionStatus = \"Running\"`,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow Interface with Object Parameters (PHP)\nDESCRIPTION: This snippet demonstrates declaring a Workflow interface in PHP for Temporal, recommending an object Argument type for the method parameter. The #[WorkflowInterface] attribute designates the interface as Temporal Workflow, while #[WorkflowMethod] marks the processFile method as the Workflow logic entrypoint. The code ensures future compatibility and parameter extensibility, assuming all arguments are serializable via the default or a custom DataConverter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Custom Logger with Logur in Go\nDESCRIPTION: This code example shows how to provide a custom logger (Logrus) to the Temporal Client using the Logur adapter in Go.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\nimport (\n  \"go.temporal.io/sdk/client\"\n\n\t\"github.com/sirupsen/logrus\"\n\tlogrusadapter \"logur.dev/adapter/logrus\"\n\t\"logur.dev/logur\"\n)\n\nfunc main() {\n  // ...\n  logger := logur.LoggerToKV(logrusadapter.New(logrus.New()))\n  clientOptions := client.Options{\n    Logger: logger,\n  }\n  temporalClient, err := client.Dial(clientOptions)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow Interface for Signal-With-Start in Java\nDESCRIPTION: Provides the `WorkflowInterface` definition corresponding to the Signal-With-Start example. It uses `@WorkflowInterface`, `@WorkflowMethod` (for the main entry point `greet`), `@SignalMethod` (for the `setCustomer` signal handler), and `@QueryMethod` (for `getCustomer`). When using Signal-With-Start, the Signal handler (`setCustomer`) executes before the Workflow method (`greet`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface GreetingWorkflow {\n    @WorkflowMethod\n    String greet(Customer customer);\n\n    @SignalMethod\n    void setCustomer(Customer customer);\n\n    @QueryMethod\n    Customer getCustomer();\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Custom Search Attributes during Workflow Start in Python\nDESCRIPTION: Demonstrates how to define Search Attribute keys using `SearchAttributeKey` (for Keyword and Text types) and set their initial values when starting a workflow via `client.start_workflow()`. It uses `TypedSearchAttributes` and `SearchAttributePair` to associate keys with values. Requires the Temporal Python SDK (`temporalio`) and pre-configured Search Attributes (`CustomerId`, `MiscData`) on the Temporal Cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n```python\ncustomer_id_key = SearchAttributeKey.for_keyword(\"CustomerId\")\nmisc_data_key = SearchAttributeKey.for_text(\"MiscData\")\n\nhandle = await client.start_workflow(\n    GreetingWorkflow.run,\n    id=\"search-attributes-workflow-id\",\n    task_queue=\"search-attributes-task-queue\",\n    search_attributes=TypedSearchAttributes([\n        SearchAttributePair(customer_id_key, \"customer_1\"),\n        SearchAttributePair(misc_data_key, \"customer_1_data\")\n    ]),\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Registering Caller Workflows and Configuring Nexus Endpoint in Java Worker\nDESCRIPTION: Demonstrates setting up a Temporal Worker in Java to host caller Workflows (`EchoCallerWorkflowImpl`, `HelloCallerWorkflowImpl`) that utilize Nexus. It initializes a `WorkflowClient`, creates a `WorkerFactory`, and a `Worker` on a specific task queue. The key part is registering the Workflow implementations using `worker.registerWorkflowImplementationTypes` along with `WorkflowImplementationOptions`. These options configure the Nexus endpoint (`my-nexus-endpoint-name`) associated with the `NexusService` via `setNexusServiceOptions`. Requires Temporal Java SDK, `ClientOptions`, `EchoCallerWorkflowImpl`, and `HelloCallerWorkflowImpl` classes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\npackage io.temporal.samples.nexus.caller;\n\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.samples.nexus.options.ClientOptions;\nimport io.temporal.worker.Worker;\nimport io.temporal.worker.WorkerFactory;\nimport io.temporal.worker.WorkflowImplementationOptions;\nimport io.temporal.workflow.NexusServiceOptions;\nimport java.util.Collections;\n\npublic class CallerWorker {\n  public static final String DEFAULT_TASK_QUEUE_NAME = \"my-caller-workflow-task-queue\";\n\n  public static void main(String[] args) {\n    WorkflowClient client = ClientOptions.getWorkflowClient(args);\n\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n\n    Worker worker = factory.newWorker(DEFAULT_TASK_QUEUE_NAME);\n    worker.registerWorkflowImplementationTypes(\n        WorkflowImplementationOptions.newBuilder()\n            .setNexusServiceOptions(\n                Collections.singletonMap(\n                    \"NexusService\",\n                    NexusServiceOptions.newBuilder().setEndpoint(\"my-nexus-endpoint-name\").build()))\n            .build(),\n        EchoCallerWorkflowImpl.class,\n        HelloCallerWorkflowImpl.class);\n\n    factory.start();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Upserting Search Attributes Dynamically in Temporal Workflows - Java\nDESCRIPTION: This snippet demonstrates updating custom Search Attributes from within a running Workflow using upsertTypedSearchAttributes. It shows how to modify attribute values based on business logic, such as setting 'isOrderFailed' according to the result of an activity. The pattern includes try/catch for error handling, conditional upserts, and references shared constants. Inputs include an address and an activity to compute distance; outputs include a Workflow history update with new Search Attribute values. Requires the Temporal Java SDK and relevant imports.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\n  import io.temporal.workflow.Workflow;\n\n  ...\n\n  // Existing Workflow Logic\n\n  Map<String, Object> searchAttribute = new HashMap<>();\n\n  Distance distance;\n  try {\n    distance = activities.getDistance(address);\n    searchAttribute.put(\"isOrderFailed\", false);\n    Workflow.upsertTypedSearchAttributes(Constants.IS_ORDER_FAILED.valueSet(false));\n  } catch (NullPointerException e) {\n    searchAttribute.put(\"isOrderFailed\", true);\n    Workflow.upsertTypedSearchAttributes(Constants.IS_ORDER_FAILED.valueSet(true));\n    throw new NullPointerException(\"Unable to get distance\");\n  }\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with a Custom Workflow ID\nDESCRIPTION: This code demonstrates how to start a Workflow with a custom Workflow ID that maps to a business process or entity identifier. It also shows how to specify Task Queue name and arguments when starting a Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  workflowId: 'yourWorkflowId',\n  taskQueue: 'yourTaskQueue',\n  args: ['your', 'arg', 'uments'],\n});\n```\n\n----------------------------------------\n\nTITLE: Executing a Synchronous Update from a Temporal Client in Python\nDESCRIPTION: This snippet shows how to send an Update to a Workflow Execution and wait synchronously for its completion using `WorkflowHandle.execute_update`. The method takes the target Update handler method (`GreetingWorkflow.set_language`) and its arguments (`Language.Chinese`), and returns the result of the Update once processed by the Workflow. This call blocks until the update completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n```python\nprevious_language = await workflow_handle.execute_update(\n    GreetingWorkflow.set_language, Language.Chinese\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Blocking Update Handler with Activity Execution in Go\nDESCRIPTION: Example of a blocking Update handler that executes an Activity. The handler modifies a language setting and calls an external service using an Activity when a new language is encountered.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc GreetingWorkflow(ctx workflow.Context) error {\n\tlanguage := English\n\n\terr = workflow.SetUpdateHandler(ctx, SetLanguageUpdate, func(ctx workflow.Context, newLanguage Language) (Language, error) {\n        if _, ok := greeting[newLanguage]; !ok {\n            ao := workflow.ActivityOptions{\n                StartToCloseTimeout: 10 * time.Second,\n            }\n            ctx = workflow.WithActivityOptions(ctx, ao)\n\n            var greeting string\n            err := workflow.ExecuteActivity(ctx, CallGreetingService, newLanguage).Get(ctx, &greeting)\n            if err != nil {\n                return nil, err\n            }\n            greeting[newLanguage] = greeting\n        }\n\t\tvar previousLanguage Language\n\t\tpreviousLanguage, language = language, newLanguage\n\t\treturn previousLanguage, nil\n\t})\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow ID in Java\nDESCRIPTION: This example demonstrates how to set the Workflow ID using WorkflowOptions.Builder.setWorkflowId. It creates a WorkflowStub with a custom Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_10\n\nLANGUAGE: java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                // Set the Workflow Id\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Assigning RetryPolicy to ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Demonstrates setting up a custom `RetryPolicy` and assigning it to the `RetryPolicy` field in ActivityOptions for a Temporal Activity in Go. Shows how retry intervals, backoff, and maximum values are set in the struct, which is then provided to the `ActivityOptions`. Requires both `go.temporal.io/sdk/temporal` and `go.temporal.io/sdk/workflow` packages, and the workflow context must be properly set for execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nretryPolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\n\nactivityOptions := workflow.ActivityOptions{\n  RetryPolicy: retryPolicy,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invoking Activities with Untyped ActivityStub - Temporal Java SDK - Java\nDESCRIPTION: This code demonstrates the use of an untyped Activity stub via Workflow.newUntypedActivityStub, enabling invocation of Activities where the type or interface may not be known at compile time or when working across multiple languages. It sets ActivityOptions for the stub, and demonstrates passing arguments and type information to the execute method. Dependencies include the Temporal Java SDK and configured Activity queues.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_17\n\nLANGUAGE: java\nCODE:\n```\n   // Workflow code\n    ActivityOptions activityOptions =\n        ActivityOptions.newBuilder()\n        .setStartToCloseTimeout(Duration.ofSeconds(3))\n        .setTaskQueue(\"simple-queue-node\")\n        .build();\n\n    ActivityStub activity = Workflow.newUntypedActivityStub(activityOptions);\n    activity.execute(\"ComposeGreeting\", String.class, \"Hello World\" , \"Spanish\");\n```\n\n----------------------------------------\n\nTITLE: Overriding Activity Retry Delay in Temporal Java SDK\nDESCRIPTION: Demonstrates how to override the default retry delay after an Activity failure by throwing an ApplicationFailure with a custom NextRetryDelay. This snippet is intended for use within a Temporal Java activity implementation where retry intervals should vary based on attempt count. Requires Temporal Java SDK and uses Duration, Activity, and ApplicationFailure classes. The variable 'attempt' tracks the current retry attempt, and the next retry delay is set dynamically as three times the attempt in seconds.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nint attempt = Activity.getExecutionContext().getInfo().getAttempt();\\n\\nthrow ApplicationFailure.newFailureWithCauseAndDelay(\\n    \\\"Something bad happened on attempt \\\" + attempt,\\n    \\\"my_failure_type\\\",\\n    null,\\n    3 * Duration.ofSeconds(attempt));\n```\n\n----------------------------------------\n\nTITLE: Handling Workflow Cancellation in .NET\nDESCRIPTION: Demonstrates how to handle cancellation requests within a Workflow Definition, including cleanup activities and exception handling. Uses WorkflowRun attribute and CancellationToken for graceful cancellation handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/cancellation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowRun]\npublic async Task RunAsync()\n{\n    try\n    {\n        await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyNormalActivity(),\n            new() { ScheduleToCloseTimeout = TimeSpan.FromMinutes(5) });\n    }\n    catch (Exception e) when (TemporalException.IsCanceledException(e))\n    {\n        Workflow.Logger.LogError(e, \"Cancellation occurred, performing cleanup\");\n\n        using var detachedCancelSource = new CancellationTokenSource();\n        await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyCancellationCleanupActivity(),\n            new()\n            {\n                ScheduleToCloseTimeout = TimeSpan.FromMinutes(5),\n                CancellationToken = detachedCancelSource.Token;\n            });\n\n        throw;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowExecutionTimeout in Go\nDESCRIPTION: This snippet demonstrates how to set the maximum allowed duration for a complete Workflow Execution (including all retries and Continue-As-New runs) in Go. It involves creating `client.StartWorkflowOptions`, setting the `WorkflowExecutionTimeout` field using `time.Duration` (e.g., 10 years), and passing these options to `c.ExecuteWorkflow`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  WorkflowExecutionTimeout: time.Hours * 24 * 365 * 10,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal WorkflowServiceStubs Connection - Java\nDESCRIPTION: Demonstrates how to create a local connection to the Temporal Service using the Java SDK. The WorkflowServiceStubs instance represents the service endpoint and is necessary for constructing workflow clients and initiating workflow operations. Requires the Temporal Java SDK dependency and is intended as part of a worker or client application setup. Expects that a Temporal server is available locally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-namespace-client-sample/README.md#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\n----------------------------------------\n\nTITLE: Removing Old Workflow Code Version in Go\nDESCRIPTION: Example showing how to safely remove older code paths after all Workflow executions using those versions have completed, by updating the minSupported parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nv := workflow.GetVersion(ctx, \"Step1\", 1, 2)\nif v == 1 {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution with Untyped Workflow Stub - Temporal PHP\nDESCRIPTION: Shows how to execute a Workflow using an untyped stub, where method names and parameters must be provided explicitly as strings. This approach provides flexibility as stubs are not tied to a specific class or interface, but requires manual mapping of method names and parameters. Dependencies include a WorkflowClient and knowledge of the Workflow Type name. This is best used for dynamic scenarios where interface typing is not practical.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_6\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newUntypedWorkflowStub('account.transfer');\\n\\n$workflowClient->start($stub, $transactionId);\\n$stub->update('pay', $from1, $to1, $amount1);\\n$stub->update('pay', $from2, $to2, $amount2);\\n$stub->update('finish');\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Parent Close Policy for Child Workflow in PHP\nDESCRIPTION: This example demonstrates how to set a Parent Close Policy for a Child Workflow using ChildWorkflowOptions. It shows creating an untyped Child Workflow stub with the ABANDON policy and starting it asynchronously.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/child-workflows.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n$child = Workflow::newUntypedChildWorkflowStub(\n    'child-workflow',\n    ChildWorkflowOptions::new()\n        ->withParentClosePolicy(ParentClosePolicy::POLICY_ABANDON)\n);\n\nyield $child->start();\n```\n\n----------------------------------------\n\nTITLE: Defining an Update Function for a Temporal Schedule in Python\nDESCRIPTION: This snippet defines an asynchronous function `update_schedule_simple` that takes `ScheduleUpdateInput` and returns a `ScheduleUpdate`. It demonstrates how to modify the arguments of a Schedule's action if it's a `ScheduleActionStartWorkflow`. This function would typically be passed as a callback to the Schedule handle's update method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# ...\n    async def update_schedule_simple(input: ScheduleUpdateInput) -> ScheduleUpdate:\n        schedule_action = input.description.schedule.action\n\n        if isinstance(schedule_action, ScheduleActionStartWorkflow):\n            schedule_action.args = [\"my new schedule arg\"]\n        return ScheduleUpdate(schedule=input.description.schedule)\n```\n\n----------------------------------------\n\nTITLE: Deprecating Workflow Patch (v3) Using `deprecatePatch`\nDESCRIPTION: This TypeScript snippet (`v3`), sourced from `patching-api/src/workflows-v3.ts`, shows the second step in the patching process. After confirming all `v1` Workflows are complete, the old code path is removed. `deprecatePatch('my-change-id')` is called to insert a marker indicating the patch ID is deprecated, ensuring history compatibility for Workflows started during the `v2` phase. The Workflow now solely contains the new logic (`activityB` and sleep). Requires the `@temporalio/workflow` package.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\n// v3\nimport { deprecatePatch } from '@temporalio/workflow';\n\nexport async function myWorkflow(): Promise<void> {\n  deprecatePatch('my-change-id');\n  await activityB();\n  await sleep('1 days');\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Child Workflow Directly in PHP\nDESCRIPTION: This code snippet shows how to execute a Child Workflow directly using Workflow::executeChildWorkflow without creating a stub. It demonstrates setting options and specifying the return type.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$childResult = yield Workflow::executeChildWorkflow(\n    'ChildWorkflowName',\n    ['args'],\n    ChildWorkflowOptions::new()->withWorkflowId('BID-SIMPLE-CHILD-WORKFLOW'),\n    Type::TYPE_STRING // optional: defines the return type\n);\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Workflow Execution with a Cron Schedule (Go SDK, Go)\nDESCRIPTION: This Go code snippet demonstrates configuring and starting a Temporal Workflow Execution that runs on a schedule using the Go SDK's StartWorkflowOptions. It sets the CronSchedule field to specify the cron timing string, then invokes ExecuteWorkflow with these options and the workflow definition. Dependencies include the go.temporal.io/sdk/client package, and parameters involve the cron schedule and workflow definition. The function expects proper context handling and error management; on success, a WorkflowRun object is returned.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Worker to Pass Through Modules into Sandbox\nDESCRIPTION: This snippet demonstrates how to configure a Temporal Worker in Python to pass through specific modules (e.g., `pydantic`) into the sandbox environment. This is achieved by initializing the `Worker` with a custom `SandboxedWorkflowRunner` whose `restrictions` are modified using `SandboxRestrictions.default.with_passthrough_modules()`. Passing through modules avoids reloading them for each workflow run, potentially improving performance, but should only be done for known deterministic modules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n```python\nmy_worker = Worker(\n  ...,\n  workflow_runner=SandboxedWorkflowRunner(\n    restrictions=SandboxRestrictions.default.with_passthrough_modules(\"pydantic\")\n  )\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Running the Temporal Worker (Go)\nDESCRIPTION: This command compiles and executes the Go program responsible for running the Temporal Worker. The Worker listens for tasks on specific task queues defined in the sample application and executes Workflow and Activity definitions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo run worker/main.go\n```\n\n----------------------------------------\n\nTITLE: Completing an Asynchronous Activity Externally in Python\nDESCRIPTION: This snippet shows how to complete an asynchronously running Activity using its handle obtained via the Temporal Client. After getting the `handle` (e.g., using `get_async_activity_handle`), the `complete()` method is called asynchronously on it, passing the final result (\"Completion value.\") of the Activity. This signals the successful completion of the Activity Execution to the Temporal Cluster. Other methods like `fail`, `heartbeat`, or `report_cancellation` can also be called on the handle.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/asynchronous-activity-completion.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nawait handle.complete(\"Completion value.\")\n```\n\n----------------------------------------\n\nTITLE: Triggering a Schedule for a Workflow in Go\nDESCRIPTION: This snippet illustrates how to trigger a Schedule for a Workflow using the Go SDK. It uses the trigger() method on ScheduleHandle to immediately execute an Action defined in the Schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tfor i := 0; i < 5; i++ {\n\t\tscheduleHandle.Trigger(ctx, client.ScheduleTriggerOptions{\n\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t})\n\t\ttime.Sleep(2 * time.Second)\n\t}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowTaskTimeout in Go\nDESCRIPTION: This snippet illustrates setting the maximum duration for a single Workflow Task execution in Go. It configures the `WorkflowTaskTimeout` field within `client.StartWorkflowOptions` using `time.Duration`. The default is 10 seconds. This timeout dictates how long a Worker has to process a Workflow Task.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowTaskTimeout: time.Second * 10,\n  //...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkflowClient with Custom PayloadCodec in Java SDK\nDESCRIPTION: This code demonstrates how to configure a WorkflowClient with a custom PayloadCodec. It creates a WorkflowClient with a CodecDataConverter that combines DefaultDataConverter with a custom PayloadCodec implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/converters-and-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n  // Client that can be used to start and signal Workflows\n  WorkflowClient client =\n      WorkflowClient.newInstance(\n          service,\n          WorkflowClientOptions.newBuilder()\n              .setDataConverter(\n                  new CodecDataConverter(\n                      DefaultDataConverter.newDefaultInstance(),\n                      Collections.singletonList(new YourCustomPayloadCodec()))) // Sets the custom Payload Codec created in the previous example with an instance of the default Data Converter.\n              .build());\n```\n\n----------------------------------------\n\nTITLE: Signaling a Workflow from a Temporal Go Client\nDESCRIPTION: Illustrates sending a signal to a running Workflow Execution via the Temporal Client's `SignalWorkflow` method. It requires context, Workflow ID (`we.GetID()`), Run ID (`we.GetRunID()` - can be empty string to signal the current run), signal name (`message.ApproveSignal`), and signal payload (`message.ApproveInput`). The call returns immediately after the server accepts the signal, without waiting for the Workflow to process it. Basic error handling is included.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// ...\nerr = temporalClient.SignalWorkflow(context.Background(), we.GetID(), we.GetRunID(), message.ApproveSignal, message.ApproveInput{Name: \"\"})\nif err != nil {\n    log.Fatalf(\"Unable to signal workflow: %v\", err)\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring a Temporal Client with a Custom Data Converter in TypeScript\nDESCRIPTION: Illustrates how to configure a Temporal Client instance in TypeScript to use a custom data converter. Similar to the Worker configuration, it uses the `dataConverter.payloadConverterPath` option to point to the file containing the custom converter definition. This ensures consistent data handling between the Client (e.g., when starting Workflows) and the Workers executing them.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nconst client = new Client({\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Async Signal Handling in Go Workflow\nDESCRIPTION: Demonstrates how to handle Signals asynchronously while allowing the Workflow to continue processing other operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n   var signal MySignal\n   signalChan := workflow.GetSignalChannel(ctx, \"your-signal-name\")\n \tworkflow.Go(ctx, func(ctx workflow.Context) {\n \t\tfor {\n \t\t\tselector := workflow.NewSelector(ctx)\n \t\t\tselector.AddReceive(signalChan, func(c workflow.ReceiveChannel, more bool) {\n \t\t\t\tc.Receive(ctx, &signal)\n \t\t\t})\n \t\t\tselector.Select(ctx)\n \t\t}\n \t})\n }\n```\n\n----------------------------------------\n\nTITLE: Filtering Temporal Cloud Metrics Using Labels\nDESCRIPTION: This example demonstrates how to filter the 'temporal_cloud_v0_poll_success_count' metric using specific labels like 'operation', 'task_type', 'temporal_account', 'temporal_namespace', and 'temporal_service_type'. This allows for targeted analysis of poll success counts for Activity tasks within a specific namespace ('your_namespace.12345') and account ('12345'), handled by the matching service for the 'TaskQueueMgr' operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/reference.mdx#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ntemporal_cloud_v0_poll_success_count{__rollup__=\"true\", operation=\"TaskQueueMgr\", task_type=\"Activity\", temporal_account=\"12345\", temporal_namespace=\"your_namespace.12345\", temporal_service_type=\"matching\"}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Activity Stubs with Custom Timeouts in Temporal Workflow (PHP)\nDESCRIPTION: This pair of snippets illustrates the creation of client-side Activity stubs in PHP with different start-to-close timeout options. The 'ActivityOptions::new()->withStartToCloseTimeout' method is used to configure timeout duration for the stub, which can be varied per Activity as needed. Dependencies include the Temporal SDK, Workflow::newActivityStub, and defined Activity interfaces. Inputs specify timeout strings; output is a configured Activity client stub.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_10\n\nLANGUAGE: php\nCODE:\n```\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 seconds'))\n);\n\n```\n\nLANGUAGE: php\nCODE:\n```\n$greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    ActivityOptions::new()->withStartToCloseTimeout(\\DateInterval::createFromDateString('30 minutes'))\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using doNotCompleteOnReturn() for Asynchronous Activity Completion in Java\nDESCRIPTION: This code snippet shows an alternative approach to asynchronous Activity completion using the doNotCompleteOnReturn() method. It demonstrates how to get the activity execution context, set a correlation token, and execute the activity asynchronously without completing it immediately.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/asynchronous-activity-completion.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n```\n\n----------------------------------------\n\nTITLE: Querying P95 Frontend Service Latency by Operation using PromQL\nDESCRIPTION: This Prometheus query calculates the 95th percentile (P95) latency for requests handled by the Temporal Frontend Service (`service_name=\"frontend\"`) over the last 5 minutes. It uses the `service_latency_bucket` histogram metric and aggregates the results by operation type (`operation` tag) to identify operations experiencing high latency.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_2\n\nLANGUAGE: PromQL\nCODE:\n```\nhistogram_quantile(0.95, sum(rate(service_latency_bucket{service_name=\"frontend\"}[5m])) by (operation, le))\n```\n\n----------------------------------------\n\nTITLE: Getting Last Completion Result for Cron Workflows in Java\nDESCRIPTION: Shows how to retrieve the result of the previous successful run of a Cron Workflow using Workflow.getLastCompletionResult(). This is useful for chaining work between Cron Job executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_26\n\nLANGUAGE: java\nCODE:\n```\npublic String cronWorkflow() {\n    String lastProcessedFileName = Workflow.getLastCompletionResult(String.class);\n\n    // Process work starting from the lastProcessedFileName.\n    // Business logic implementation goes here.\n    // Updates lastProcessedFileName to the new value.\n\n    return lastProcessedFileName;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Parent Close Policy for Child Workflow in .NET\nDESCRIPTION: Shows how to set a Parent Close Policy using ChildWorkflowOptions. This example sets the policy to Abandon, which determines the behavior of the Child Workflow when its Parent Workflow closes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nawait Workflow.ExecuteChildWorkflowAsync(\n  (MyChildWorkflow wf) => wf.RunAsync(),\n  new() { ParentClosePolicy = ParentClosePolicy.Abandon });\n```\n\n----------------------------------------\n\nTITLE: Using Protobuf Types in a Temporal Workflow - TypeScript\nDESCRIPTION: This code defines a Temporal workflow function that takes a protobuf-generated input, proxies an activity, and returns a protobuf result. It illustrates how protobuf types integrate with workflow runtime, ensuring type-safe data flow between activities and workflows. Dependencies include the patched protobuf root module and the referenced activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nimport { proxyActivities } from '@temporalio/workflow';\nimport { foo, ProtoResult } from '../protos/root';\nimport type * as activities from './activities';\n\nconst { protoActivity } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '1 minute',\n});\n\nexport async function example(input: foo.bar.ProtoInput): Promise<ProtoResult> {\n  const result = await protoActivity(input);\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing events to file in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that saves event information to a specified file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --output_filename <filename>\n```\n\n----------------------------------------\n\nTITLE: Completing Activities Asynchronously with AsyncCompletionClient - Temporal TypeScript\nDESCRIPTION: This snippet demonstrates implementing an Activity that completes asynchronously in the Temporal TypeScript SDK. The doSomethingAsync function immediately throws CompleteAsyncError after scheduling asynchronous work, signaling that the Activity will be completed externally. The helper function doSomeWork uses AsyncCompletionClient to complete the Activity, requiring the Activity's taskToken and the result string. Dependencies include '@temporalio/activity' and '@temporalio/client'. Key parameters are the taskToken (an opaque identifier for the Activity Task), and the completion result string. Inputs: none directly; Outputs: completion of the Activity with a result. Limitations: correct handling of taskToken and external completion is essential for correctness.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/asynchronous-activity-completion.mdx#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { activityInfo, CompleteAsyncError } from '@temporalio/activity';\\nimport { AsyncCompletionClient } from '@temporalio/client';\\n\\nexport async function doSomethingAsync(): Promise<string> {\\n  const taskToken = activityInfo().taskToken;\\n  setTimeout(() => doSomeWork(taskToken), 1000);\\n  throw new CompleteAsyncError();\\n}\\n\\n// this work could be done in a different process or on a different machine\\nasync function doSomeWork(taskToken: Uint8Array): Promise<void> {\\n  const client = new AsyncCompletionClient();\\n  // does some work...\\n  await client.complete(taskToken, 'Job\\'s done!');\\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal to a Workflow from a Client in C#\nDESCRIPTION: This snippet demonstrates how to send a Signal to a Workflow from a Client using the WorkflowHandle's SignalAsync method. Signals can modify Workflow state but are fire-and-forget operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nawait workflowHandle.SignalAsync(wf => wf.ApproveAsync(new(\"MyUser\")));\n```\n\n----------------------------------------\n\nTITLE: Setting Heartbeat Timeout for Activity in Go\nDESCRIPTION: This code demonstrates how to set a Heartbeat Timeout for an Activity using the Temporal Go SDK. It creates ActivityOptions with a specified HeartbeatTimeout, applies these options to the workflow context, and then executes the Activity with the configured timeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nactivityoptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Workflow Definition in C#\nDESCRIPTION: This code demonstrates how to create a basic Workflow Definition using the Temporal .NET SDK. It shows the proper use of [Workflow] attribute to identify a Workflow class and includes an example of executing an Activity from within a Workflow using ExecuteActivityAsync.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Workflows;\n\n[Workflow]\npublic class MyWorkflow\n{\n    public async Task<string> RunAsync(string name)\n    {\n        var param = MyActivityParams(\"Hello\", name);\n        return await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyActivity(param),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Query Handler in C# Temporal Workflow\nDESCRIPTION: This code snippet demonstrates how to set up a Dynamic Query Handler in a Temporal Workflow using C#. It uses the WorkflowQuery attribute with Dynamic set to true and handles dynamic parameter conversion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowQuery(Dynamic = true)]\npublic string DynamicQueryAsync(string queryName, IRawValue[] args)\n{\n    var input = Workflow.PayloadConverter.ToValue<MyStatusParam>(args.Single());\n    return statuses[input.Type];\n}\n```\n\n----------------------------------------\n\nTITLE: Logging from a Temporal Activity using Context Logger (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to use the built-in Activity Context logger (`log` from `@temporalio/activity`) to emit log messages from within an Activity function. This logger automatically includes Activity context metadata and handles forwarding logs to the Runtime's logger.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { log } from '@temporalio/activity';\n\nexport async function greet(name: string): Promise<string> {\n  log.info('Log from activity', { name });\n  return `Hello, ${name}!`;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Caller Workflow for Synchronous Nexus Operation in Java\nDESCRIPTION: Illustrates the implementation of a Temporal Workflow (`EchoCallerWorkflowImpl`) that calls a Nexus operation synchronously. It uses `Workflow.newNexusServiceStub` to create a typed stub for the `NexusService`, configuring options like the `scheduleToCloseTimeout` for the operation. The `echo` method directly invokes the `nexusService.echo` operation with the input and returns the message from the output. Depends on the Temporal Java SDK and the `NexusService` interface definition.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npackage io.temporal.samples.nexus.caller;\n\nimport io.temporal.samples.nexus.service.NexusService;\nimport io.temporal.workflow.NexusOperationOptions;\nimport io.temporal.workflow.NexusServiceOptions;\nimport io.temporal.workflow.Workflow;\nimport java.time.Duration;\n\npublic class EchoCallerWorkflowImpl implements EchoCallerWorkflow {\n  NexusService nexusService =\n      Workflow.newNexusServiceStub(\n          NexusService.class,\n          NexusServiceOptions.newBuilder()\n              .setOperationOptions(\n                  NexusOperationOptions.newBuilder()\n                      .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n                      .build())\n              .build());\n\n  @Override\n  public String echo(String message) {\n    return nexusService.echo(new NexusService.EchoInput(message)).getMessage();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ExternalWorkflowStub to Invoke Other Workflows in Java\nDESCRIPTION: This example demonstrates how to use ExternalWorkflowStub within a Workflow to invoke other Workflows by type. It's particularly useful for executing Workflows written in other language SDKs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\n@Override\n  public String yourWFMethod(String name) {\n      ExternalWorkflowStub callOtherWorkflow = Workflow.newUntypedExternalWorkflowStub(\"OtherWFId\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Starting Asynchronous Workflow Execution with Typed WorkflowStub in Java\nDESCRIPTION: Shows how to start a Workflow Execution asynchronously using a typed WorkflowStub. The WorkflowClient.start method initiates the Workflow and returns immediately without waiting for completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_22\n\nLANGUAGE: java\nCODE:\n```\n// create typed Workflow stub\nFileProcessingWorkflow workflow = client.newWorkflowStub(FileProcessingWorkflow.class,\n            WorkflowOptions.newBuilder()\n                    .setTaskQueue(taskQueue)\n                    .setWorkflowId(workflowId)\n                    .build());\n// use WorkflowClient.execute (if your Workflow takes in arguments) or WorkflowClient.start (for zero arguments)\nWorkflowClient.start(workflow::greetCustomer);\n```\n\n----------------------------------------\n\nTITLE: Executing Activities with Heartbeat Timeout - Temporal Python SDK\nDESCRIPTION: Illustrates the use of the \"execute_activity()\" helper function to schedule and wait for an Activity with a specified heartbeat timeout in the Temporal Python SDK. Like \"start_activity()\", it sets both \"schedule_to_close_timeout\" and \"heartbeat_timeout\", but also directly waits for the result. The pattern is suited for cases where handle management and cancellation are not required separately. Dependencies include the Temporal Python SDK and the datetime module's \"timedelta\". Key parameters are the activity name and timeout values. The function returns the Activity's result after execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nworkflow.execute_activity(\n    activity=\"your-activity\",\n    name,\n    schedule_to_close_timeout=timedelta(seconds=5),\n    heartbeat_timeout=timedelta(seconds=1),\n)\n```\n\n----------------------------------------\n\nTITLE: Starting a Child Workflow Execution in Go\nDESCRIPTION: This snippet demonstrates how to start a Child Workflow Execution using the Go SDK. It shows the use of ExecuteChildWorkflow API, workflow.Context, and ChildWorkflowOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{}\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  var result ChildResp\n  err := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{}).Get(ctx, &result)\n  if err != nil {\n    // ...\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an Update Asynchronously using startUpdate in Java\nDESCRIPTION: Demonstrates sending an Update asynchronously using the `startUpdate` method on a `WorkflowStub`. This method returns a `WorkflowUpdateHandle` as soon as the Update is accepted or rejected by the Worker (controlled by `WorkflowUpdateStage.ACCEPTED`), without waiting for the Update handler logic to fully complete. The handle's `getResultAsync().get()` method is then used later to retrieve the final result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nWorkflowUpdateHandle<Language> handle =\n      WorkflowStub.fromTyped(workflow)\n          .startUpdate(\n              \"setLanguage\", WorkflowUpdateStage.ACCEPTED, Language.class, Language.ENGLISH);\n  previousLanguage = handle.getResultAsync().get();\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToStartTimeout in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Demonstrates configuration of the `ScheduleToStartTimeout` option, which limits the wait time from scheduling the Activity to its actual start. Utilizes the Temporal Go SDK's `workflow.ActivityOptions` and `WithActivityOptions` methods. Assumes standard dependencies and an available workflow context. The Activity's result is captured and errors are handled inline.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts with ActivityStub in Java\nDESCRIPTION: Demonstrates how to set Activity timeouts (Schedule-To-Close, Start-To-Close, Schedule-To-Start) using ActivityOptions.Builder with an ActivityStub.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                        // .setStartToCloseTimeout(Duration.ofSeconds(2)\n                        // .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                        .build());\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Data Converter with Codec\nDESCRIPTION: Creates a new CodecDataConverter instance that wraps the default Data Converter with a custom PayloadCodec implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/converters-and-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Create an instance of Data Converter with your codec.\nvar DataConverter = converter.NewCodecDataConverter(\n\tconverter.GetDefaultDataConverter(),\n\tNewPayloadCodec(),\n)\n//...\n// Create an instance of PaylodCodec.\nfunc NewPayloadCodec() converter.PayloadCodec {\n\treturn &Codec{}\n}\n```\n\n----------------------------------------\n\nTITLE: Update Handler with Validation in Go Workflow\nDESCRIPTION: Shows implementation of an Update handler with validation logic for handling synchronous requests that can modify Workflow state.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Language string\n\nconst SetLanguageUpdate = \"set-language\"\n\nfunc GreetingWorkflow(ctx workflow.Context) error {\n\tlanguage := English\n\n\terr = workflow.SetUpdateHandlerWithOptions(ctx, SetLanguageUpdate, func(ctx workflow.Context, newLanguage Language) (Language, error) {\n\t\tvar previousLanguage Language\n\t\tpreviousLanguage, language = language, newLanguage\n\t\treturn previousLanguage, nil\n\t}, workflow.UpdateHandlerOptions{\n\t\tValidator: func(ctx workflow.Context, newLanguage Language) error {\n\t\t\tif _, ok := greeting[newLanguage]; !ok {\n\t\t\t\treturn fmt.Errorf(\"%s unsupported language\", newLanguage)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t})\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from a Client in Java\nDESCRIPTION: Illustrates sending a Signal to an active Workflow Execution from client code. It calls the `approve` method (defined as a `@SignalMethod` in the `GreetingWorkflow` interface) on the typed `WorkflowStub`. The client call returns immediately upon server acceptance, not waiting for Workflow processing. A `WorkflowExecutionSignaled` event is added to the history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nworkflow.approve(new ApproveInput(\"Me\"));\n```\n\n----------------------------------------\n\nTITLE: Sending Heartbeats in Temporal Activities - Python\nDESCRIPTION: Defines an asynchronous Activity using the Temporal Python SDK that sends a heartbeat to the Temporal Service. The Activity uses the \"heartbeat()\" API to report progress, with optional detail data included as arguments. Requires the \"@activity.defn\" decorator and the Temporal Python SDK to be installed. The heartbeat details can be retrieved if the Activity is retried, ensuring that progress is not lost. No input parameters are defined for the Activity, and the output is a string as specified by the function signature.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@activity.defn\nasync def your_activity_definition() -> str:\n    activity.heartbeat(\"heartbeat details!\")\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Timeouts in Java\nDESCRIPTION: Demonstrates how to set Workflow Execution, Run, and Task timeouts using WorkflowOptions.Builder when creating a WorkflowStub instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWorkflow\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Timeout duration\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\n                // .setWorkflowRunTimeout(Duration.ofSeconds(10))\n                // .setWorkflowTaskTimeout(Duration.ofSeconds(10))\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom CompositePayloadConverter Instance in TypeScript\nDESCRIPTION: Shows how to instantiate a custom `CompositePayloadConverter` in TypeScript, defining a specific order of converters. This example prioritizes handling null/undefined values and then uses a custom `EjsonPayloadConverter`, effectively replacing the default JSON serialization. This instance should be provided to both Worker and Client configurations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new EjsonPayloadConverter(),\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Sending an Asynchronous Update from a Temporal PHP Client\nDESCRIPTION: Shows how to send an Update asynchronously from a Temporal Client using the `startUpdate` method on an untyped Workflow Stub. This call potentially returns an `UpdateHandle` quickly, after the update is accepted by the server (validation might still run), allowing the client to proceed. The actual result of the update can be retrieved later using `$handle->getResult()`, optionally with a timeout. The example also demonstrates using `UpdateOptions` to specify the update name ('storeGreetings'), desired lifecycle stage (`LifecycleStage::StageCompleted`), and expected result type (`UuidInterface`). Requires Temporal Client, Workflow Stub, `UpdateOptions`, `UpdateHandle`, `WaitPolicy`, `LifecycleStage`, and potentially `Ramsey\\Uuid\\UuidInterface`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: php\nCODE:\n```\nuse Ramsey\\Uuid\\UuidInterface;\nuse Temporal\\Client\\Update\\UpdateOptions;\nuse Temporal\\Client\\Update\\WaitPolicy;\nuse Temporal\\Client\\Update\\LifecycleStage;\n\n// Create an untyped Workflow stub for GreetingsWorkflow\n$stub = $client->newUntypedWorkflowStub('GreetingWorkflow', $workflowOptions);\n\n// Start the Workflow\n$run = $client->start($stub);\n\n// Send an Update to the Workflow. UpdateHandle returns\n$handle = $stub->startUpdate('addGreeting', 'World');\n\n// Use the UpdateHandle to get the Update result with timeout 2.5 seconds\n$result = $handle->getResult(timeout: 2.5);\n\n// You can get more control using UpdateOptions\n$resultUuid = $stub->startUpdate(\n    UpdateOptions::new('storeGreetings', LifecycleStage::StageCompleted)\n        ->withResultType(UuidInterface::class)\n )->getResult();\n```\n\n----------------------------------------\n\nTITLE: Updating a Scheduled Workflow using Temporal .NET SDK\nDESCRIPTION: This snippet demonstrates how to update an existing Schedule using the UpdateAsync() method on the Schedule Handle. It shows how to modify the Schedule's configuration, such as changing the Workflow action.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nawait handle.UpdateAsync(input =>\n{\n    var newAction =  ScheduleActionStartWorkflow.Create(\n        (MyWorkflow wf) => wf.RunAsync(),\n        new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\"));\n    return new(input.Description.Schedule with { Action = newAction });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a New Change ID for Future Updates in Go\nDESCRIPTION: Example showing how to create a new change ID if the original GetVersion call was removed, allowing for future code changes using a fresh versioning sequence.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nv := workflow.GetVersion(ctx, \"Step1-fix2\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityE, data).Get(ctx, &result1)\n}\n```\n\n----------------------------------------\n\nTITLE: Continuing with Custom Options in Java\nDESCRIPTION: This snippet shows how to provide ContinueAsNewOptions when using Workflow.newContinueAsNewStub() to specify custom options like Task Queue for the continued Workflow Execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/continue-as-new.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nContinueAsNewOptions options = ContinueAsNewOptions.newBuilder()\n        .setTaskQueue(\"newTaskQueueName\")\n        .build();\n\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class, options);\n// ...\ncontinueAsNew.greet(input);\n```\n\n----------------------------------------\n\nTITLE: Creating Shell Alias for tctl Docker Command\nDESCRIPTION: This command creates a shell alias named 'tctl'. When 'tctl' is run in the shell, it will execute the command 'docker exec temporal-admin-tools tctl', allowing users to run tctl commands within the Docker container as if it were installed locally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nalias tctl=\"docker exec temporal-admin-tools tctl\"\n```\n\n----------------------------------------\n\nTITLE: Setting a Cron Schedule in Java\nDESCRIPTION: This snippet demonstrates how to set a Cron Schedule for a Workflow Execution using WorkflowOptions.Builder.setCronSchedule. It changes the Workflow Execution into a Temporal Cron Job with a specified schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Setting HeartbeatTimeout via ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to configure the Heartbeat Timeout for an Activity using `ActivityOptions.newBuilder().setHeartbeatTimeout()` when creating an `ActivityStub` within a Temporal Workflow. It also sets a required `StartToCloseTimeout`. Dependencies include `io.temporal.workflow.Workflow`, `io.temporal.activity.ActivityOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_28\n\nLANGUAGE: java\nCODE:\n```\nprivate final GreetingActivities activities =\n    Workflow.newActivityStub(\n        GreetingActivities.class,\n        ActivityOptions.newBuilder()\n            // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n            // required when setting Activity options.\n            .setStartToCloseTimeout(Duration.ofSeconds(5))\n            .setHeartbeatTimeout(Duration.ofSeconds(2))\n            .build());\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom CamelCase Payload Converter in .NET\nDESCRIPTION: Example of creating and configuring a custom PayloadConverter that converts C# property names to camel case using System.Text.Json.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/converters-and-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Text.Json;\nusing Temporalio.Client;\nusing Temporalio.Converters;\n\npublic class CamelCasePayloadConverter : DefaultPayloadConverter\n{\n    public CamelCasePayloadConverter()\n      : base(new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase })\n    {\n    }\n}\n\nvar client = await TemporalClient.ConnectAsync(new()\n{\n    TargetHost = \"localhost:7233\",\n    Namespace = \"my-namespace\",\n    DataConverter = DataConverter.Default with { PayloadConverter = new CamelCasePayloadConverter() },\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Dynamic Query Handler in Java\nDESCRIPTION: Example of registering a Dynamic Query Handler in Temporal Java SDK. This handler processes any unregistered Queries sent to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_23\n\nLANGUAGE: java\nCODE:\n```\nWorkflow.registerListener(\n  (DynamicQueryHandler)\n      (queryName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowExecutionTimeout using Temporal Java SDK\nDESCRIPTION: This code demonstrates setting the Workflow Execution Timeout option for a Temporal workflow in Java. The WorkflowOptions.Builder.setWorkflowExecutionTimeout sets the maximum duration for the workflow's completion. Dependencies include the Java Temporal SDK and the Duration class. The parameter for timeout accepts a java.time.Duration object, with unlimited as default if unspecified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_13\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\\nYourWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"YourWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                // Set Workflow Execution Timeout duration\\n                .setWorkflowExecutionTimeout(Duration.ofSeconds(10))\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Dynamic Signal Handler with Temporal Python SDK (Python)\nDESCRIPTION: This snippet shows how to register a dynamic signal handler using the Temporal Python SDK for Python. By setting dynamic=True in the @workflow.signal decorator and accepting (self, name: str, args: Sequence[RawValue]), the handler will receive unmatched signals by name, enabling dynamic processing. The snippet imports necessary types, illustrates usage of RawValue for payload management, and is essential when the signal names aren't known at registration time. Dependencies include temporalio.common.RawValue, Python type hints, and a compatible Temporal Worker setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\n\nfrom temporalio.common import RawValue\n...\n\n    @workflow.signal(dynamic=True)\n    async def dynamic_signal(self, name: str, args: Sequence[RawValue]) -> None:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Interface with Update Methods - Temporal PHP\nDESCRIPTION: Defines a Workflow interface for account transfer in PHP using Temporal SDK. This interface, equipped with attributes for WorkflowMethod and UpdateMethod, lists the set of operations allowed on the Workflow, such as beginning the transfer, making moves between accounts, committing, or rolling back transactions. Dependencies include the PHP Temporal SDK and the UuidInterface type. Each method represents a Workflow interaction point; method parameters correspond to transfer details and all interactions are type-safe.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n#[WorkflowInterface]\\ninterface AccountTransferWorkflowInterface\\n{\\n    #[WorkflowMethod(name: \\\"account.transfer\\\")]\\n    public function begin(UuidInterface $transactionId);\\n\\n    #[UpdateMethod(name: \\\"pay\\\")]\\n    public function move(UuidInterface $from, UuidInterface $to, int $amount);\\n\\n    #[UpdateMethod(name: \\\"finish\\\")]\\n    public function commit();\\n\\n    #[UpdateMethod(name: \\\"cancel\\\")]\\n    public function rollback(string $reason);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Version History After Namespace Failover in Temporal Workflow\nDESCRIPTION: This snippet shows how version history changes after a namespace failover is triggered, changing the namespace version to 2. The fourth event is added with the new version, creating a new entry in the version history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Executing a Temporal Workflow with a Start Delay in Python\nDESCRIPTION: This snippet shows how to schedule a Temporal Workflow Execution to start after a specific delay, rather than immediately or on a recurring schedule. It uses the `execute_workflow` method with the `start_delay` option, providing a `timedelta` object to specify the delay duration. The example includes basic `asyncio` setup to run the asynchronous `main` function.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        start_delay=timedelta(hours=1, minutes=20, seconds=30)\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Defining a Dynamic Workflow with Temporal .NET SDK in C#\nDESCRIPTION: This snippet demonstrates how to define a dynamic workflow by setting the Dynamic property to true in the [Workflow] attribute. The RunAsync method is the workflow entry point, accepting parameters as IRawValue[] and using the Workflow.PayloadConverter to retrieve input values. It shows invoking an activity within the workflow and returning the result as a string. Dependencies include the Temporalio.Converters and Temporalio.Workflows namespaces; you must register the workflow with a worker before use.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow(Dynamic = true)]\npublic class DynamicWorkflow\n{\n    [WorkflowRun]\n    public async Task<string> RunAsync(IRawValue[] args)\n    {\n        var name = Workflow.PayloadConverter.ToValue<string>(args.Single());\n        var param = MyActivityParams(\"Hello\", name);\n        return await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyActivity(param),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentLocalActivityExecutionSize for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of concurrent Local Activity Executions the Worker can handle. Local Activities execute within the Workflow Worker process. The type is `int`, and the default value is `1000`. Setting it to `0` uses the default value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_30\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    MaxConcurrentLocalActivityExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring a Retry Policy for Workflows in Go\nDESCRIPTION: This snippet demonstrates creating and applying a custom retry policy for a Workflow Execution in Go. It involves instantiating `temporal.RetryPolicy` from `go.temporal.io/sdk/temporal`, configuring parameters like `InitialInterval`, `BackoffCoefficient`, and `MaximumInterval`, and assigning this policy to the `RetryPolicy` field of `client.StartWorkflowOptions` before calling `ExecuteWorkflow`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n```go\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Activity Type Name in Go\nDESCRIPTION: Demonstrates how to customize the Activity Type name when registering an Activity with a Temporal Worker in Go. It uses `activity.RegisterOptions` to set a custom `Name` ('JustAnotherActivity' in this case) and passes these options to `yourWorker.RegisterActivityWithOptions` along with the Activity function definition (`yourapp.YourSimpleActivityDefinition`). This allows referencing the Activity by the custom name instead of the default derived from the function name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n    yourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n// ...\n    // Use RegisterOptions to change the name of the Activity Type for example.\n    registerAOptions := activity.RegisterOptions{\n        Name: \"JustAnotherActivity\",\n    }\n    yourWorker.RegisterActivityWithOptions(yourapp.YourSimpleActivityDefinition, registerAOptions)\n    // Run the Worker\n    err = yourWorker.Run(worker.InterruptCh())\n// ...\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Overriding Activity Next Retry Delay in PHP\nDESCRIPTION: This PHP code snippet shows how to dynamically set the next retry delay for an Activity failure within the Activity implementation. It retrieves the current attempt number using `Activity::getInfo()->attempt` and throws an `ApplicationFailure` with a calculated `nextRetryDelay` based on the attempt number. This overrides the interval defined in the standard Retry Policy. Dependencies include the Temporal PHP SDK (`Activity`, `Exception\\Failure\\ApplicationFailure`) and PHP's `DateInterval`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n$attempt = \\Temporal\\Activity::getInfo()->attempt;\n\nthrow new \\Temporal\\Exception\\Failure\\ApplicationFailure(\n    message: \"Something bad happened on attempt $attempt\",\n    type: 'my_failure_type',\n    nonRetryable: false,\n    nextRetryDelay: \\DateInterval::createFromDateString(\\sprintf('%d seconds', $attempt * 3)),\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts in Go SDK\nDESCRIPTION: This snippet shows how to set Activity timeouts using ActivityOptions. It demonstrates setting the ScheduleToCloseTimeout, which limits the overall Activity Execution time. Other available timeouts include StartToCloseTimeout and ScheduleToStartTimeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nactivityoptions := workflow.ActivityOptions{\n  // Set Activity Timeout duration\n  ScheduleToCloseTimeout: 10 * time.Second,\n  // StartToCloseTimeout: 10 * time.Second,\n  // ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityoptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Signals to Child Workflows in Java\nDESCRIPTION: Example of sending a Signal from a Parent Workflow to a Child Workflow. This demonstrates how to define signal methods in the workflow interface and invoke them from the parent.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n// Child Workflow interface\n@WorkflowInterface\npublic interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\n// Parent Workflow implementation\npublic class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, \"Hello\", name);\n        child.updateName(\"Temporal\");\n        return greeting.get();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Timeouts using Temporal Python SDK\nDESCRIPTION: Demonstrates how to set Workflow Execution timeouts (`execution_timeout`, `run_timeout`, `task_timeout`) when initiating a Workflow using `client.execute_workflow`. These parameters control the maximum duration for the entire execution, a single run, and an individual Workflow Task, respectively. Timeouts are specified as `timedelta` objects. Note that setting Workflow Timeouts is generally discouraged in favor of using Timers within the Workflow logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your timeout argument\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        # Set Workflow Timeout duration\n        execution_timeout=timedelta(seconds=2),\n        # run_timeout=timedelta(seconds=2),\n        # task_timeout=timedelta(seconds=2),\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating OpenTelemetry Interceptor in Go\nDESCRIPTION: This code shows the creation of an OpenTelemetry interceptor for distributed tracing in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// create Interceptor\ntracingInterceptor, err := opentelemetry.NewTracingInterceptor(opentelemetry.TracerOptions{})\n```\n\n----------------------------------------\n\nTITLE: Handling Activity Cancellation in .NET\nDESCRIPTION: Shows how to implement cancellation handling in an Activity using heartbeats and CancellationToken. The Activity continuously checks for cancellation while performing work.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/cancellation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Activity]\npublic async Task MyActivityAsync()\n{\n    while (true)\n    {\n        ActivityExecutionContext.Current.Heartbeat();\n        await Task.Delay(1000, ActivityExecutionContext.Current.CancellationToken);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RegisterActivityOptions in Go\nDESCRIPTION: Demonstrates how to set options when registering Activities with a Worker. Options include customizing the Activity Type name, disabling duplicate registration checks, and handling invalid struct functions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_50\n\nLANGUAGE: go\nCODE:\n```\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  DisableAlreadyRegisteredCheck: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Returning Activity Result Pending Error in Go\nDESCRIPTION: Returns an activity.ErrResultPending error to indicate that the Activity is completing asynchronously and not through the normal return mechanism.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/asynchronous-activity-completion.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nreturn \"\", activity.ErrResultPending\n```\n\n----------------------------------------\n\nTITLE: Setting Up Logging in Temporal Workflow with Java\nDESCRIPTION: This code snippet shows how to obtain a standard slf4j logger in Temporal Workflow code using the Workflow.getLogger method. It demonstrates the recommended way to create a logger instance for use within a Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nprivate static final Logger logger = Workflow.getLogger(DynamicDslWorkflow.class);\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Activity Completion with ActivityCompletionClient in Java\nDESCRIPTION: This code snippet demonstrates how to implement asynchronous Activity completion using the ActivityCompletionClient interface. It shows how to get the activity execution context, set a correlation token, execute the activity asynchronously, and complete it using the ActivityCompletionClient.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/asynchronous-activity-completion.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n    @Override\n    public String composeGreeting(String greeting, String name) {\n\n      // Get the activity execution context\n      ActivityExecutionContext context = Activity.getExecutionContext();\n\n      // Set a correlation token that can be used to complete the activity asynchronously\n      byte[] taskToken = context.getTaskToken();\n\n      /**\n       * For the example we will use a {@link java.util.concurrent.ForkJoinPool} to execute our\n       * activity. In real-life applications this could be any service. The composeGreetingAsync\n       * method is the one that will actually complete workflow action execution.\n       */\n      ForkJoinPool.commonPool().execute(() -> composeGreetingAsync(taskToken, greeting, name));\n      context.doNotCompleteOnReturn();\n\n      // Since we have set doNotCompleteOnReturn(), the workflow action method return value is\n      // ignored.\n      return \"ignored\";\n    }\n\n    // Method that will complete action execution using the defined ActivityCompletionClient\n    private void composeGreetingAsync(byte[] taskToken, String greeting, String name) {\n      String result = greeting + \" \" + name + \"!\";\n\n      // Complete our workflow activity using ActivityCompletionClient\n      completionClient.complete(taskToken, result);\n    }\n```\n\n----------------------------------------\n\nTITLE: Executing Update-with-Start on Temporal Workflow - .NET C#\nDESCRIPTION: Demonstrates how to use Temporal's .NET client to execute an Update-with-Start operation, which either sends an Update to an existing Workflow or starts a new one if it does not exist, all in one call. Requires references to the Temporalio .NET SDK, a valid client instance, proper Workflow type, and activity definitions. Inputs are a session ID and a ShoppingCartItem; output is an AddCartItemResult object. The code includes handling for item-unavailable failures and ensures safe single-use for the WithStartWorkflowOperation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nasync Task<AddCartItemResult> AddCartItemAsync(string sessionId, ShoppingCartItem item)\n{\n    // Issue an update-with-start that will create the workflow if it does not\n    // exist before attempting the update\n\n    // Create the start operation\n    var startOperation = WithStartWorkflowOperation.Create(\n        (ShoppingCartWorkflow wf) => wf.RunAsync(),\n        new(id: $\"cart-{sessionId}\", taskQueue: TaskQueue)\n        {\n            IdConflictPolicy = Temporalio.Api.Enums.V1.WorkflowIdConflictPolicy.UseExisting,\n        });\n\n    // Issue the update-with-start, swallowing item-unavailable failure\n    decimal? subtotal;\n    try\n    {\n        subtotal = await client.ExecuteUpdateWithStartWorkflowAsync(\n            (ShoppingCartWorkflow wf) => wf.AddItemAsync(item),\n            new(startOperation));\n    }\n    catch (WorkflowUpdateFailedException e) when (\n        e.InnerException is ApplicationFailureException appErr && appErr.ErrorType == \"ItemUnavailable\")\n    {\n        // Set subtotal to null if item was not found\n        subtotal = null;\n    }\n\n    return new(await startOperation.GetHandleAsync(), subtotal);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts in Go\nDESCRIPTION: Illustrates how to configure mandatory Activity Timeouts in Go using `workflow.ActivityOptions`. At least `ScheduleToCloseTimeout` or `StartToCloseTimeout` must be set. This example demonstrates setting `ScheduleToCloseTimeout`. The configured options are then associated with the workflow context using `workflow.WithActivityOptions(ctx, activityOptions)` before calling `workflow.ExecuteActivity`. This ensures the Activity Execution adheres to the specified time limits.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  // Set Activity Timeout duration\n  ScheduleToCloseTimeout: 10 * time.Second,\n  // StartToCloseTimeout: 10 * time.Second,\n  // ScheduleToStartTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Metrics and Logging Level in Temporal Worker TelemetryOptions (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure telemetry options for a Temporal Worker. It sets up a Prometheus metrics endpoint by specifying the `bindAddress` and configures the logging level for forwarded logs to `DEBUG`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntelemetryOptions: {\n    metrics: {\n      prometheus: { bindAddress: '0.0.0.0:9464' },\n    },\n    logging: { forward: { level: 'DEBUG' } },\n  },\n```\n\n----------------------------------------\n\nTITLE: Registering a Nexus Service in a Go Temporal Worker\nDESCRIPTION: This code demonstrates how to register a Nexus Service in a Temporal Worker. It creates a client, initializes a worker, registers a service with operations, and then registers both the Nexus Service and a workflow handler before running the worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/nexus-services.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\tc, err := client.Dial(client.Options{})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\n\tw := worker.New(c, taskQueue, worker.Options{})\n\tservice := nexus.NewService(service.HelloServiceName)\n\terr = service.Register(handler.EchoOperation, handler.HelloOperation)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to register operations\", err)\n\t}\n\tw.RegisterNexusService(service)\n\tw.RegisterWorkflow(handler.HelloHandlerWorkflow)\n\n\terr = w.Run(worker.InterruptCh())\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to start worker\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Heartbeating an Activity Execution in Temporal Java SDK\nDESCRIPTION: Illustrates sending a heartbeat from a running Activity to the Temporal Service using Activity.getExecutionContext().heartbeat(). This method can accept any Java object as a 'details' argument to track progress. The example is part of an activity implementation class and assumes integration with the Temporal Java SDK. Passing heartbeat details allows workflows to resume or retry with saved state after interruptions and supports progress tracking or cancellation detection.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npublic class YourActivityDefinitionImpl implements YourActivityDefinition {\\n\\n  @Override\\n  public String yourActivityMethod(YourActivityMethodParam param) {\\n    // ...\\n    Activity.getExecutionContext().heartbeat(details);\\n    // ...\\n  }\\n  // ...\\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Child Workflow Execution in .NET\nDESCRIPTION: Demonstrates how to start a Child Workflow Execution using ExecuteChildWorkflowAsync method. This method starts the Child Workflow and waits for its completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/child-workflows.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nawait Workflow.ExecuteChildWorkflowAsync((MyChildWorkflow wf) => wf.RunAsync());\n```\n\n----------------------------------------\n\nTITLE: Setting RetryOptions using Temporal Java SDK\nDESCRIPTION: This code snippet demonstrates configuring RetryOptions for workflow execution retries via WorkflowOptions.Builder.setRetryOptions. The RetryOptions object defines retry behavior such as maximum attempts and backoff intervals. Dependencies are the Temporal Java SDK and a builder for RetryOptions. If unset, the workflow performs no retries after failure.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_17\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for GreetWorkflowInterface\\nGreetWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"GreetWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                // Set Workflow Retry Options\\n                .setRetryOptions(RetryOptions.newBuilder()\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Replaying a Single Temporal Workflow History from JSON File (TypeScript)\nDESCRIPTION: Demonstrates reading a Workflow Event History from a JSON file using `fs.promises.readFile` and replaying it with `Worker.runReplayHistory`. This is useful for testing Workflow Definition changes against specific, known histories, often obtained via the CLI or Web UI. It requires the path to the Workflow Definition file and the parsed history object.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\nconst filePath = './history_file.json';\nconst history = await JSON.parse(fs.promises.readFile(filePath, 'utf8'));\nawait Worker.runReplayHistory(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  history,\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Retry Policy in .NET\nDESCRIPTION: Shows how to configure retry policies for Workflow executions using WorkflowOptions. Sets MaximumInterval for retry attempts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = await client.ExecuteWorkflowAsync(\n    (MyWorkflow wf) => wf.RunAsync(),\n    new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\")\n    {\n        RetryPolicy = new() { MaximumInterval = TimeSpan.FromSeconds(10) },\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Activity in PHP\nDESCRIPTION: Shows how to implement an asynchronous activity using Activity::doNotCompleteOnReturn(). The activity logs the task token and indicates that it should be completed externally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/asynchronous-activity-completion.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nclass GreetingActivity implements GreetingActivityInterface\n{\n    private LoggerInterface $logger;\n\n    public function __construct()\n    {\n        $this->logger = new Logger();\n    }\n    /**\n     * Demonstrates how to implement an Activity asynchronously.\n     * When {@link Activity::doNotCompleteOnReturn()} is called,\n     * the Activity implementation function that returns doesn't complete the Activity.\n     */\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        // In real life this request can be executed anywhere. By a separate service for example.\n        $this->logger->info(sprintf('GreetingActivity token: %s', base64_encode(Activity::getInfo()->taskToken)));\n        // Send the taskToken to the external service that will complete the Activity.\n        // Return from the Activity a function indicating that Temporal should wait\n        // for an async completion message.\n        Activity::doNotCompleteOnReturn();\n        // When doNotCompleteOnReturn() is invoked the return value is ignored.\n        return 'ignored';\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using WorkflowLock to Control Handler Concurrency\nDESCRIPTION: A corrected implementation using WorkflowLock to prevent concurrent execution of critical sections in a Signal handler. The lock ensures that only one handler instance can access and modify workflow state at a time.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_19\n\nLANGUAGE: java\nCODE:\n```\npublic class DataWorkflowImpl implements DataWorkflow {\n    WorkflowLock lock = Workflow.newWorkflowLock();\n    ...\n    @Override\n    public void safeSignalHandler() {\n        try {\n            lock.lock();\n            Data data = activity.fetchData();\n            this.x = data.x;\n            // ✅ OK: the scheduler may switch now to a different handler execution,\n            // or to the main workflow method, but no other execution of this handler\n            // can run until this execution finishes.\n            Workflow.sleep(Duration.ofSeconds(1));\n            this.y = data.y;\n        } finally {\n            lock.unlock()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Return Types with #[ReturnType()] (PHP)\nDESCRIPTION: This code shows how to explicitly specify the return type of a Workflow method in PHP Temporal SDK using the #[ReturnType()] attribute. The processFile method in FileProcessingWorkflow interface declares its output as a string for type safety in client invocation. This enables Temporal's DataConverter to appropriately serialize and deserialize outputs and is required since Workflow methods return generators, making PHP's default return type syntax unsuitable. All parameters and return values must be serializable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n\n    #[WorkflowMethod]\n    #[ReturnType(\"string\")]\n    public function processFile(Argument $args);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Workflow Unit Test Implementation\nDESCRIPTION: Implementation of unit tests for HelloActivity sample using TestWorkflowEnvironment with actual activity implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class HelloActivityTest {\n\n    private TestWorkflowEnvironment testEnv;\n    private Worker worker;\n    private WorkflowClient client;\n\n    // Set up the test workflow environment\n    @Before\n    public void setUp() {\n        testEnv = TestWorkflowEnvironment.newInstance();\n        worker = testEnv.newWorker(TASK_QUEUE);\n        // Register your workflow implementations\n        worker.registerWorkflowImplementationTypes(GreetingWorkflowImpl.class);\n\n        client = testEnv.getWorkflowClient();\n    }\n\n    // Clean up test environment after tests are completed\n    @After\n    public void tearDown() {\n        testEnv.close();\n    }\n\n    @Test\n    public void testActivityImpl() {\n        // This uses the actual activity impl\n        worker.registerActivitiesImplementations(new GreetingActivitiesImpl());\n\n        // Start test environment\n        testEnv.start();\n\n        // Create the workflow stub\n        GreetingWorkflow workflow =\n                client.newWorkflowStub(\n                        GreetingWorkflow.class, WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).build());\n\n        // Execute our workflow waiting for it to complete\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Continue-As-New in Temporal .NET SDK\nDESCRIPTION: This code snippet demonstrates how to use Continue-As-New in a Temporal Workflow using the .NET SDK. It throws an exception created by CreateContinueAsNewException() to stop the current Workflow and start a new one with the same Workflow Id but a different Run Id.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nthrow Workflow.CreateContinueAsNewException((MyWorkflow wf) => wf.RunAsync(myNewParam));\n```\n\n----------------------------------------\n\nTITLE: Sleeping with Asyncio in Temporal Workflow - Python\nDESCRIPTION: This Python code snippet demonstrates how to use the asyncio.sleep() function to implement a durable timer within a Temporal Workflow. The sleep call allows the workflow to pause for a specified number of seconds (10 in this example), and resumes execution even if the Worker or Temporal Service experiences downtime. This approach requires the Python asyncio library and a properly configured Temporal Workflow environment. The main input is the sleep duration in seconds, and there are no direct outputs beyond workflow progression after the wait period. The technique is suitable for long waits but requires Python's async context and Temporal SDK integration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\n        await asyncio.sleep(10)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Timer Sleep in Temporal Java Workflow\nDESCRIPTION: Demonstrates how to implement a basic timer sleep operation in a Temporal workflow using the Workflow.sleep() method. The timer is durable and persists even if the Worker or Temporal Service goes down during execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nsleep(5);\n```\n\n----------------------------------------\n\nTITLE: Updating a Schedule for a Workflow in Go\nDESCRIPTION: This code shows how to update a Schedule for a Workflow using the Go SDK. It uses the Update() method on the ScheduleHandle to modify the configuration of an existing Schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tupdateSchedule := func(input client.ScheduleUpdateInput) (*client.ScheduleUpdate, error) {\n\t\treturn &client.ScheduleUpdate{\n\t\t\tSchedule: &input.Description.Schedule,\n\t\t}, nil\n\t}\n\n\t_ = scheduleHandle.Update(ctx, client.ScheduleUpdateOptions{\n\t\tDoUpdate: updateSchedule,\n\t})\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Encryption Payload Codec in .NET\nDESCRIPTION: Example implementation of an IPayloadCodec that performs base64 encryption and decryption of payloads. The codec implements EncodeAsync and DecodeAsync methods to handle payload transformation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/converters-and-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EncryptionCodec : IPayloadCodec\n{\n    public Task<IReadOnlyCollection<Payload>> EncodeAsync(IReadOnlyCollection<Payload> payloads) =>\n        Task.FromResult<IReadOnlyCollection<Payload>>(payloads.Select(p =>\n        {\n            return new Payload()\n            {\n                // Set our specific encoding. We may also want to add a key ID in here for use by\n                // the decode side\n                Metadata = { [\"encoding\"] = \"binary/my-payload-encoding\" },\n                Data = ByteString.CopyFrom(Encrypt(p.ToByteArray())),\n            };\n        }).ToList());\n\n    public Task<IReadOnlyCollection<Payload>> DecodeAsync(IReadOnlyCollection<Payload> payloads) =>\n        Task.FromResult<IReadOnlyCollection<Payload>>(payloads.Select(p =>\n        {\n            // Ignore if it doesn't have our expected encoding\n            if (p.Metadata.GetValueOrDefault(\"encoding\") != \"binary/my-payload-encoding\")\n            {\n                return p;\n            }\n            // Decrypt\n            return Payload.Parser.ParseFrom(Decrypt(p.Data.ToByteArray()));\n        }).ToList());\n\n    private byte[] Encrypt(byte[] data) => Encoding.ASCII.GetBytes(Convert.ToBase64String(data));\n\n    private byte[] Decrypt(byte[] data) => Convert.FromBase64String(Encoding.ASCII.GetString(data));\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Synchronous Update from a Temporal PHP Client\nDESCRIPTION: Illustrates how to send an Update request synchronously from a Temporal Client in PHP. It involves creating a typed Workflow Stub (`GreetingWorkflow`) using `newWorkflowStub`, starting the Workflow via `start`, and then directly calling the Update method defined in the interface (e.g., `$workflow->addGreeting(\"World\")`) on the stub. The client call blocks until the Update is processed by the Workflow and its result (the count of greetings) is returned. Requires the Temporal Client (`$workflowClient`) and a typed Workflow Stub.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: php\nCODE:\n```\n// Create a typed Workflow stub for GreetingsWorkflow\n$workflow = $workflowClient->newWorkflowStub(GreetingWorkflow::class, $workflowOptions);\n\n// Start the Workflow\n$run = $workflowClient->start($workflow);\n\n// Send an update to the Workflow. addGreeting returns\n// the number of greetings our workflow has received.\n$count = $workflow->addGreeting(\"World\");\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowRunTimeout using Temporal Java SDK\nDESCRIPTION: This snippet configures the Workflow Run Timeout for a workflow stub using the Java SDK for Temporal. It employs WorkflowOptions.Builder.setWorkflowRunTimeout to specify a duration distinct from the workflow's overall execution timeout. The code requires the java.time.Duration and the Temporal SDK. Provide the run timeout with a Duration object; the default inherits from the defined WorkflowExecutionTimeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_14\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\\nYourWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"YourWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                // Set Workflow Run Timeout duration\\n                .setWorkflowRunTimeout(Duration.ofSeconds(10))\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Listing Scheduled Workflows with Temporal Python SDK\nDESCRIPTION: Provides an example of enumerating all existing schedules using the Temporal Python SDK. The snippet uses the list_schedules() async generator on the client to iterate through schedules, printing their information. Useful for inventory and management tasks. Requires active Temporal server. Inputs: None (lists all current schedules). Outputs: Prints schedule info for all found schedules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ...\\nasync def main() -> None:\\n    client = await Client.connect(\"localhost:7233\")\\n    async for schedule in await client.list_schedules():\\n        print(f\"List Schedule Info: {schedule.info}.\")\n```\n\n----------------------------------------\n\nTITLE: Preventing Concurrent Handler Execution with Mutex Lock in Temporal Workflow - TypeScript\nDESCRIPTION: Illustrates the use of the 'async-mutex' Mutex class to prevent concurrent handler instances from corrupting shared state within a Temporal TypeScript workflow. This pattern ensures that only one handler execution can mutate shared data ('x', 'y') at a time. Dependencies include Temporal TypeScript SDK and the async-mutex npm library. The critical section is enclosed using 'lock.runExclusive'. Expected input is that multiple signals might arrive, and output is an object with at least a 'name' field. The major constraint is that all handler mutations to shared state must occur within the exclusive lock.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Mutex } from 'async-mutex';  // https://github.com/DirtyHairy/async-mutex\n\n...\n\nexport async function myWorkflow(): Promise<MyWorkflowOutput> {\n  let x = 0;\n  let y = 0;\n  const lock = new Mutex();\n\n  wf.setHandler(mySignal, async () => {\n    await lock.runExclusive(async () => {\n      const data = await myActivity();\n      x = data.x;\n\n      // ✅ OK: node's event loop may switch now to a different handler\n      // execution, or to the main workflow function, but no other execution of\n      // this handler can run until this execution finishes.\n      await wf.sleep(500); // or await anything else\n\n      y = data.y;\n    });\n  });\n  return {\n    name: 'hello',\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Activity Heartbeat in Temporal TypeScript SDK\nDESCRIPTION: This snippet demonstrates how to send heartbeats from an Activity to inform the Temporal Service that the Activity is making progress. The Activity loops 1000 times, sleeping for 1 second between iterations and calling the heartbeat() function to signal progress.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function myActivity(): Promise<void> {\n  for (let progress = 1; progress <= 1000; ++progress) {\n    // Do something that takes time\n    await sleep('1s');\n\n    heartbeat();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Query Handler in Temporal PHP Workflow\nDESCRIPTION: Shows how to define a basic Query handler method named `getValue` inside a PHP Workflow interface using the `#[Workflow\\QueryMethod]` attribute. This method is part of the Workflow's public interface and can be called from a client to retrieve data (in this case, a static value 42) without altering the Workflow state. Requires the `Temporal\\Workflow` namespace attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: php\nCODE:\n```\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    #[Workflow\\QueryMethod]\n    public function getValue()\n    {\n        return 42;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // workflow code\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing and Checking Temporal Service Client Connection - Temporal PHP\nDESCRIPTION: Explains how to establish a gRPC connection to the Temporal Service proactively by calling connect() or getServerCapabilities() on the service client. This is needed in non-lazy or startup connection scenarios, before first Workflow or Activity invocation. Dependencies include an initialized ServiceClient or equivalent connection object; a timeout parameter can be supplied to connect().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_15\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n// ...\\n$serviceClient->getConnection()->connect(timeout: 10);\\n\\n// or\\n$serviceClient->getServerCapabilities();\\n\n```\n\n----------------------------------------\n\nTITLE: Listing Kubernetes Pods in Namespace using Shell\nDESCRIPTION: This shell command uses `kubectl get pods` to list all pods running within the `temporal-system` namespace (note: example text uses `your-namespace` earlier, adjust as needed). This is used to verify that the Worker deployment created pods successfully and to get the names of the running pods.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n```\nkubectl get pods -n temporal-system\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Tuning in Python SDK\nDESCRIPTION: Examples of configuring worker tuning in Python using resource-based tuning and composite tuning with different slot suppliers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Just resource based\ntuner = WorkerTuner.create_resource_based(\n    target_memory_usage=0.5,\n    target_cpu_usage=0.5,\n)\nworker = Worker(client, task_queue=\"foo\", tuner=tuner)\n# Combining different types\nresource_based_options = ResourceBasedTunerConfig(0.8, 0.9)\ntuner = WorkerTuner.create_composite(\n    workflow_supplier=FixedSizeSlotSupplier(10),\n    activity_supplier=ResourceBasedSlotSupplier(\n        ResourceBasedSlotConfig(),\n        resource_based_options,\n    ),\n    local_activity_supplier=ResourceBasedSlotSupplier(\n        ResourceBasedSlotConfig(),\n        resource_based_options,\n    ),\n)\nworker = Worker(client, task_queue=\"foo\", tuner=tuner)\n```\n\n----------------------------------------\n\nTITLE: Updating a Schedule in Java\nDESCRIPTION: This code shows how to update an existing Schedule using a callback function that takes ScheduleUpdateInput and returns ScheduleUpdate. The example updates the Schedule to set a limited number of actions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\nhandle.update(\n    (ScheduleUpdateInput input) -> {\n      Schedule.Builder builder = Schedule.newBuilder(input.getDescription().getSchedule());\n      // Make the schedule paused to demonstrate how to unpause a schedule\n      builder.setState(\n          ScheduleState.newBuilder()\n              .setLimitedAction(true)\n              .setRemainingActions(10)\n              .build());\n      return new ScheduleUpdate(builder.build());\n    });\n```\n\n----------------------------------------\n\nTITLE: Replacing the Default Data Converter Using NewCompositeDataConverter in Temporal Go\nDESCRIPTION: This Go snippet creates a Composite Data Converter using a custom Payload Converter and sets it as the Data Converter for the Temporal client. Requires importing \"go.temporal.io/sdk/converter\" as a dependency. The function YourCustomPayloadConverter() should return an implementation of the PayloadConverter interface. This replaces the default Payload handling with custom serialization logic. Inputs: an instance of a custom Payload Converter. Outputs: a Data Converter configured to use only your custom logic, potentially limiting built-in type support.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/converters-and-encryption.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ndataConverter := converter.NewCompositeDataConverter(YourCustomPayloadConverter())\n```\n\n----------------------------------------\n\nTITLE: Returning Results from a Workflow Execution\nDESCRIPTION: This example shows how to return results from a Workflow Execution. It demonstrates constructing a string that includes the Workflow ID and a calculated value (totalCharged) that represents the result of the Workflow's business logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nreturn (\n  'Completed '\n  + wf.workflowInfo().workflowId\n  + ', Total Charged: '\n  + totalCharged\n);\n```\n\n----------------------------------------\n\nTITLE: Setting a Cron Schedule for Workflows in Go\nDESCRIPTION: This snippet shows how to schedule a Workflow Execution using a cron expression in Go. The `CronSchedule` field within `client.StartWorkflowOptions` is set to a standard cron string (e.g., \"15 8 * * *\") to define the recurring schedule. This transforms the Workflow into a Temporal Cron Job.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_13\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  CronSchedule: \"15 8 * * *\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring a Temporal Worker with a Custom Data Converter in TypeScript\nDESCRIPTION: Provides a TypeScript code example for configuring a Temporal Worker using `Worker.create`. It specifies the path to a custom payload converter implementation (e.g., one defined using `CompositePayloadConverter`) via the `dataConverter.payloadConverterPath` option. This ensures the Worker uses the defined custom serialization/deserialization logic for Workflow and Activity inputs/outputs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'ejson',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring ActivityID with ActivityOptions in Temporal Go SDK - Go\nDESCRIPTION: Demonstrates how to assign a specific `ActivityID` to an Activity invocation using the `ActivityOptions` struct in Temporal's Go SDK. Requires importing `go.temporal.io/sdk/workflow` and assumes access to a `workflow.Context` as well as a defined Activity and parameter. The code sets the `ActivityID` field, applies options to the workflow context, executes the activity, and handles error output. The Activity receives a unique identifier, and the error must be managed as shown. No other fields are set in this snippet.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  ActivityID: \"your-activity-id\",\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Wait Conditions in Update Handlers with Temporal TypeScript\nDESCRIPTION: Shows how to use workflow.condition within an Update handler to pause execution until a specific condition is met. This allows for controlled execution of Updates based on Workflow state.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nlet readyForUpdateToExecute = false;\n\nwf.setHandler(myUpdate, async (input: MyUpdateInput): Promise<MyUpdateOutput> => {\n  await wf.condition(() => readyForUpdateToExecute);\n  ...\n});\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with String Workflow Type in Go\nDESCRIPTION: This snippet demonstrates how to start a Workflow Execution when the invocation process does not have direct access to the Workflow Definition. The Workflow Type is provided as a string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"YourWorkflowDefinition\", param)\n```\n\n----------------------------------------\n\nTITLE: Failing Asynchronous Activity with Temporal Client in Go\nDESCRIPTION: Demonstrates how to fail an asynchronous Activity using the Temporal Client. This is used when the Activity needs to be marked as failed rather than completed successfully.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/asynchronous-activity-completion.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// Fail the Activity.\nclient.CompleteActivity(context.Background(), taskToken, nil, err)\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Retry Policy in Go SDK\nDESCRIPTION: This code demonstrates how to set a Workflow Retry Policy using the RetryPolicy struct from the temporal package. The policy controls retry behavior with parameters like InitialInterval, BackoffCoefficient, and MaximumInterval when a Workflow Execution fails.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nretrypolicy := &temporal.RetryPolicy{\n  InitialInterval:    time.Second,\n  BackoffCoefficient: 2.0,\n  MaximumInterval:    time.Second * 100,\n}\nworkflowOptions := client.StartWorkflowOptions{\n  RetryPolicy: retrypolicy,\n  // ...\n}\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Workflow with JSON Input using Temporal CLI\nDESCRIPTION: This command shows how to start a Workflow Execution with JSON input. It uses single quotes to wrap the JSON input, allowing for structured data to be passed to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute --workflow-id=meaningful-business-id --type-MyWorkflow --task-queue-MyTaskQueue --input='{\"JSON\": \"Input\"}'\n```\n\n----------------------------------------\n\nTITLE: Using WaitConditionAsync in Update Handlers in C# Temporal Workflows\nDESCRIPTION: This code demonstrates how to use Workflow.WaitConditionAsync to block an Update handler until a specific condition is met. The handler waits until the ReadyForUpdateToExecute method returns true before proceeding with execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowUpdate]\npublic async Task<string> MyUpdateAsync(UpdateInput updateInput)\n{\n    await Workflow.WaitConditionAsync(() => ReadyForUpdateToExecute(updateInput));\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Signaling Workflows Using Common Interfaces in Java\nDESCRIPTION: Shows how to use common interfaces to signal different types of Workflows using their WorkflowIds.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nRetryable r1 = client.newWorkflowStub(Retryable.class, firstWorkflowId);\nRetryable r2 = client.newWorkflowStub(Retryable.class, secondWorkflowId);\nr1.retryNow();\nr2.retryNow();\n```\n\n----------------------------------------\n\nTITLE: Logging from a Temporal Workflow using Context Logger (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates how to use the Workflow Context logger (`log` from `@temporalio/workflow`) within a Workflow function. This logger is necessary because Workflows run in a sandboxed environment without direct I/O and must handle potential replays; it funnels logs to the Runtime's logger and avoids re-emitting logs during replay.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { log } from '@temporalio/workflow';\n\nexport async function myWorkflow(name: string): Promise<string> {\n  log.info('Log from workflow', { name });\n  return `Hello, ${name}!`;\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Timer from Within a Workflow in TypeScript\nDESCRIPTION: This example demonstrates how to cancel a timer internally within a workflow using a cancellable scope. The workflow sleeps for 1 millisecond but the timer is cancelled immediately, resulting in a CancelledFailure that is caught and handled.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimer(): Promise<void> {\n  // Timers and Activities are automatically cancelled when their containing scope is cancelled.\n  try {\n    await CancellationScope.cancellable(async () => {\n      const promise = sleep(1); // <-- Will be cancelled because it is attached to this closure's scope\n      CancellationScope.current().cancel();\n      await promise; // <-- Promise must be awaited in order for `cancellable` to throw\n    });\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow and Getting a WorkflowHandle with Temporal Python Client - Python\nDESCRIPTION: This code demonstrates how to start a Workflow using the Temporal Python Client and obtain a WorkflowHandle for subsequent message passing. The example uses async methods to connect to Temporal, start a named Workflow on a specified task queue, and illustrates necessary parameters such as the Workflow definition and instance identifiers. Dependencies include the Temporal SDK, and this pattern is required for sending Queries, Signals, or Updates to Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclient = await Client.connect(\"localhost:7233\")\nworkflow_handle = await client.start_workflow(\n    GreetingWorkflow.run, id=\"greeting-workflow-1234\", task_queue=\"my-task-queue\"\n)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Workflow Update Handler with Concurrency Control - Temporal Workflow - .NET C#\nDESCRIPTION: Implements an asynchronous WorkflowUpdate handler method in a Temporal Workflow class for setting the current language, invoking an async Activity, and ensuring updates are handled in order using a Mutex. Requires a proper Workflow context, a valid Mutex implementation compatible with async, the Temporalio .NET SDK, and supporting class members. Takes a Language parameter, updates shared state, conditionally triggers an Activity call, and returns the previous language. Throws ApplicationFailureException if the requested language is unsupported; sync validation only is enforced for update validators.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class GreetingWorkflow\n{\n    private readonly Mutex mutex = new();\n\n    // ...\n\n    [WorkflowUpdate]\n    public async Task<Language> SetLanguageAsync(Language language)\n    {\n        // 👉 Use a mutex here to ensure that multiple calls to SetLanguageAsync are processed in order.\n        await mutex.WaitOneAsync();\n        try\n        {\n            if (!greetings.ContainsKey(language))\n            {\n                var greeting = Workflow.ExecuteActivityAsync(\n                    (MyActivities acts) => acts.CallGreetingServiceAsync(language),\n                    new() { StartToCloseTimeout = TimeSpan.FromSeconds(10) });\n                if (greeting == null)\n                {\n                    // 👉 An update validator cannot be async, so cannot be used to check that the remote\n                    // CallGreetingServiceAsync supports the requested language. Throwing ApplicationFailureException\n                    // will fail the Update, but the WorkflowExecutionUpdateAccepted event will still be\n                    // added to history.\n                    throw new ApplicationFailureException(\n                        $\"Greeting service does not support {language}\");\n                }\n                greetings[language] = greeting;\n            }\n            var previousLanguage = CurrentLanguage;\n            CurrentLanguage = language;\n            return previousLanguage;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Handlers Finish Before Workflow Completion\nDESCRIPTION: Example showing how to use Workflow.await with isEveryHandlerFinished to ensure all handlers complete before the Workflow execution finishes. This prevents interruption of crucial handler work and avoids client errors when retrieving Update results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: java\nCODE:\n```\npublic class MyWorkflowImpl implements MyWorkflow {\n    ...\n    @Override\n    public String run() {\n        ...\n        Workflow.await(() -> Workflow.isEveryHandlerFinished());\n        return \"workflow-result\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Dynamic Signal Handler in Java\nDESCRIPTION: Example of registering a Dynamic Signal Handler in Temporal Java SDK. This handler processes any unregistered Signals sent to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_22\n\nLANGUAGE: java\nCODE:\n```\nWorkflow.registerListener(\n  (DynamicSignalHandler)\n      (signalName, encodedArgs) -> name = encodedArgs.get(0, String.class));\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start with the Temporal Go Client\nDESCRIPTION: Demonstrates the Signal-With-Start operation using `temporalClient.SignalWithStartWorkflow`. This client method targets a specific Workflow ID (`\"your-workflow-id\"`). If a Workflow with that ID is running, it sends the specified signal (`\"your-signal-name\"` with payload `signal`); otherwise, it starts a new Workflow Execution with that ID (using default Workflow options) and immediately delivers the signal. It requires context, Workflow ID, signal name, and signal arguments but does not accept a Run ID. Includes basic error handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// ...\nsignal := MySignal {\n  Message: \"Some important data\",\n}\nerr = temporalClient.SignalWithStartWorkflow(context.Background(), \"your-workflow-id\", \"your-signal-name\", signal)\nif err != nil {\n\tlog.Fatalln(\"Error sending the Signal\", err)\n\treturn\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client for Custom Namespace in Java\nDESCRIPTION: This code snippet shows how to initialize a Temporal Client to connect to a custom Namespace by setting Client options in Java. This allows for isolating Workflow Executions in development environments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Add the Namespace as a Client Option\nWorkflowClientOptions clientOptions = WorkflowClientOptions\n    .newBuilder()\n    .setNamespace(namespace)\n    .build();\n\n// Initialize the Temporal Client\n// This application uses the Client to communicate with the Temporal Service\nWorkflowClient client = WorkflowClient.newInstance(service, clientOptions);\n```\n\n----------------------------------------\n\nTITLE: Handling Cancellation Scopes with Callbacks in Temporal Workflows\nDESCRIPTION: Shows how to handle cancellation in callback-based code by consuming the CancellationScope.cancelRequested promise. This pattern can be used in the rare cases where callbacks are necessary in Temporal Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope } from '@temporalio/workflow';\n\nfunction doSomething(callback: () => any) {\n  setTimeout(callback, 10);\n}\n\nexport async function cancellationScopesWithCallbacks(): Promise<void> {\n  await new Promise<void>((resolve, reject) => {\n    doSomething(resolve);\n    CancellationScope.current().cancelRequested.catch(reject);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Version Search Attributes Implementation\nDESCRIPTION: Implementation for handling multiple version changes in search attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nList<String> list = new ArrayList<String>();\nint versionOne = Workflow.getVersion(\"versionOne\", Workflow.DEFAULT_VERSION, 1);\nint versionTwo = Workflow.getVersion(\"versionTwo\", Workflow.DEFAULT_VERSION, 1);\nif ( versionOne != Workflow.DEFAULT_VERSION ) {\n   list.append(\"versionOne-\" + versionOne);\n}\nif (versionTwo != Workflow.DEFAULT_VERSION) {\n   list.append(\"versionTwo-\" + versionTwo);\n}\nWorkflow.upsertTypedSearchAttributes(Constants.TEMPORAL_CHANGE_VERSION.valueSet(list));\n```\n\n----------------------------------------\n\nTITLE: Protecting an Activity from Cancellation with nonCancellable in TypeScript\nDESCRIPTION: This snippet shows how to use `CancellationScope.nonCancellable` to shield an Activity (`httpGetJSON`) from cancellation. Even if the Workflow containing this scope receives a cancellation request, the cancellation will not propagate into the `nonCancellable` scope, allowing the `httpGetJSON` Activity to run to completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function nonCancellable(url: string): Promise<any> {\n  // Prevent Activity from being cancelled and await completion.\n  // Note that the Workflow is completely oblivious and impervious to cancellation in this example.\n  return CancellationScope.nonCancellable(() => httpGetJSON(url));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RPC Timeout in Temporal PHP Client\nDESCRIPTION: Shows how to set a timeout duration for RPC calls in a Temporal client. The example demonstrates creating a WorkflowClient with a 5.75 second timeout for all RPC operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_17\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$serviceClient = ServiceClient::create('localhost:7233');\n$workflowClient = WorkflowClient::create($serviceClient)\n    ->withTimeout(5.75);\n\n// Create a Workflow stub\n$stub = $workflowClient->newWorkflowStub(AccountTransferWorkflowInterface::class);\n\n// If the Workflow does not complete within 5.75 seconds, a TimeoutException will be thrown\n$result = $stub->transfer('fromID', 'toID', 'refID', 1000);\n```\n\n----------------------------------------\n\nTITLE: Continuing as Different Workflow Type in Java\nDESCRIPTION: This example demonstrates how to continue the execution of a currently running Workflow as a completely different Workflow Type using Workflow.newContinueAsNewStub().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/continue-as-new.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nMyOtherWorkflow continueAsNew = Workflow.newContinueAsNewStub(MyOtherWorkflow.class);\nconinueAsNew.greet(input);\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowIdReusePolicy using Temporal Java SDK\nDESCRIPTION: This snippet configures the WorkflowIdReusePolicy in WorkflowOptions when building a Temporal workflow stub in Java. Using setWorkflowIdReusePolicy, you determine rules for reusing workflow IDs after previous workflow conclusion. Dependencies include the Temporal Java SDK, an enum for reuse policies, and application code. The primary input is a constant from WorkflowIdReusePolicy specifying allowed reuse scenarios.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_16\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for GreetWorkflowInterface\\nGreetWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                .setWorkflowId(\\\"GreetWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                // Set Workflow Id Reuse Policy\\n                .setWorkflowIdReusePolicy(\\n                        WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE)\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Failing an Asynchronous Activity Externally in Java\nDESCRIPTION: This snippet shows how to fail an asynchronous Activity from outside the original Activity worker process. It uses the `ActivityCompletionClient`'s `completeExceptionally` method, passing the `taskToken` and the `Exception` that caused the failure. This is used when the asynchronous operation initiated by the Activity fails. Requires an instance of `ActivityCompletionClient`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_38\n\nLANGUAGE: java\nCODE:\n```\n  public void failActivity(byte[] taskToken, Exception failure) {\n    completionClient.completeExceptionally(taskToken, failure);\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Cancellation Scopes with Callbacks in TypeScript\nDESCRIPTION: This example demonstrates how to handle cancellation when using callbacks in a workflow. It uses CancellationScope.cancelRequested to ensure the promise can be rejected if cancellation is requested.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope } from '@temporalio/workflow';\n\nfunction doSomething(callback: () => any) {\n  setTimeout(callback, 10);\n}\n\nexport async function cancellationScopesWithCallbacks(): Promise<void> {\n  await new Promise<void>((resolve, reject) => {\n    doSomething(resolve);\n    CancellationScope.current().cancelRequested.catch(reject);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a Workflow Signal Reception in xUnit\nDESCRIPTION: This test demonstrates how to send a signal to a Workflow and verify that it processes the signal correctly. It creates a worker with SignalWorkflow, starts the workflow, sends a signal, and verifies the result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Testing;\nusing Temporalio.Worker;\n\n[Fact]\npublic async Task SignalWorkflow_SendSignal_HasExpectedResult()\n{\n    await using var env = WorkflowEnvironment.StartTimeSkippingAsync();\n    using var worker = new TemporalWorker(\n        env.Client,\n        new TemporalWorkerOptions($\"task-queue-{Guid.NewGuid()}\").\n            AddWorkflow<SignalWorkflow>());\n    await worker.ExecuteAsync(async () =>\n    {\n        var handle = await env.Client.StartWorkflowAsync(\n            (SignalWorkflow wf) => wf.RunAsync(),\n            new(id: $\"wf-{Guid.NewGuid()}\", taskQueue: worker.Options.TaskQueue!));\n        await handle.SignalAsync(wf => wf.SomeSignalAsync());\n        Assert.Equal(\"got signal\", await handle.GetResultAsync());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Pausing a Scheduled Workflow with Temporal Python SDK\nDESCRIPTION: Demonstrates pausing a Workflow Schedule using the Temporal Python SDK, temporarily suspending automatic Workflow executions. After retrieving the schedule handle, the pause() method is called asynchronously with an optional note. Useful for maintenance windows or controlled scheduling. Inputs: Schedule ID and optional pause note. Output: Schedule resumes only when unpaused.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# ...\\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n    handle = client.get_schedule_handle(\\n        \"workflow-schedule-id\",\\n    )\\n\\n    await handle.pause(note=\"Pausing the schedule for now\")\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Results Using a Workflow Handle\nDESCRIPTION: This code shows how to get a Workflow handle by its ID and wait for the result asynchronously. It provides a way to access the result of a Workflow that was previously started.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\n----------------------------------------\n\nTITLE: Upserting Temporal Search Attributes in Go\nDESCRIPTION: Demonstrates using `workflow.UpsertSearchAttributes` within a Go Workflow function to add or update Search Attributes. The function takes a context and a map of attribute keys (string) to values (interface{}). This example shows two consecutive calls, updating `CustomIntField` and adding `CustomKeywordField`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflow(ctx workflow.Context, input string) error {\n\n    attr1 := map[string]interface{}{\n        \"CustomIntField\": 1,\n        \"CustomBoolField\": true,\n    }\n    workflow.UpsertSearchAttributes(ctx, attr1)\n\n    attr2 := map[string]interface{}{\n        \"CustomIntField\": 2,\n        \"CustomKeywordField\": \"seattle\",\n    }\n    workflow.UpsertSearchAttributes(ctx, attr2)\n}\n```\n\n----------------------------------------\n\nTITLE: Running Temporal Worker and Client\nDESCRIPTION: Commands to start the Temporal worker process and execute the banking client application using Poetry to manage the Python environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/workflow_failures/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npoetry run python worker.py\npoetry run python banking-client.py\n```\n\n----------------------------------------\n\nTITLE: Starting Asynchronous Workflow Execution with Untyped WorkflowStub in Java\nDESCRIPTION: Demonstrates initiating a Workflow Execution asynchronously using an untyped WorkflowStub. This approach specifies the Workflow type as a string and blocks only until the Workflow Execution has started.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_23\n\nLANGUAGE: java\nCODE:\n```\nWorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n                  WorkflowOptions.newBuilder()\n                          .setWorkflowId(workflowId)\n                          .setTaskQueue(taskQueue)\n                          .build());\n\n// blocks until Workflow Execution has been started (not until it completes)\nuntyped.start(argument);\n```\n\n----------------------------------------\n\nTITLE: Overriding Synchronous Nexus Operation in Go\nDESCRIPTION: This snippet demonstrates how to override a synchronous Nexus operation in a Temporal Workflow test. It creates a custom Nexus operation, registers it with a service, and executes a test Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_NexusSyncOperation() {\n        var SampleOperation = nexus.NewSyncOperation(\n                \"sample-operation\",\n                func(ctx context.Context, input SampleInput, options nexus.StartOperationOptions) (SampleOutput, error) {\n                        // Custom logic here.\n                        return SampleOutput{}, nil\n                },\n        )\n\n        service := nexus.NewService(\"sample-service\")\n        s.NoError(service.Register(SampleOperation))\n        env.RegisterNexusService(service)\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_nexus_operation\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Untyped Child Workflow in Java\nDESCRIPTION: Example of executing an untyped Child Workflow asynchronously using ChildWorkflowStub. This approach allows dynamic workflow type specification and parameter passing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n//...\nChildWorkflowStub childUntyped =\n    Workflow.newUntypedChildWorkflowStub(\n        \"GreetingChild\", // your workflow type\n        ChildWorkflowOptions.newBuilder().setWorkflowId(\"childWorkflow\").build());\n\nPromise<String> greeting =\n    childUntyped.executeAsync(String.class, String.class, \"Hello\", name);\nString result = greeting.get();\n//...\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Worker with Custom EJSON PayloadConverter in TypeScript\nDESCRIPTION: Shows how to initialize a Temporal Worker instance with custom payloadConverter via dataConverter property, enabling EJSON serialization for workflow arguments. Depends on Worker from Temporal SDK and the export from 'payload-converter'. Requires workflowsPath, taskQueue, and payloadConverterPath as parameters; returns an initialized Worker. This setup enables all workflows processed by this Worker to serialize/deserialize using EJSON.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  taskQueue: 'ejson',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying Mock Expectations After Workflow Tests in Go\nDESCRIPTION: Implements an AfterTest function that verifies all mock expectations were met after each test completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) AfterTest(suiteName, testName string) {\n        s.env.AssertExpectations(s.T())\n}\n```\n\n----------------------------------------\n\nTITLE: Overview of Temporal Java SDK Testing Framework\nDESCRIPTION: This text introduces the testing capabilities within the Temporal Java SDK. It points to the `testing` package (available via `io.temporal:temporal-testing`) as the provider of a test environment for Workflows and Activities. The text also highlights support for both JUnit4 and JUnit5 testing frameworks, specifically mentioning the JUnit5 integration package (`io.temporal:temporal-testing-junit5`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/README.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nEach Temporal SDK has a testing suite that can be used in conjunction with a typical language\n specific testing framework. In the Temporal Java SDK, the `testing` package\n (https://www.javadoc.io/doc/io.temporal/temporal-testing/latest/index.html) provides a test\n environment in which the Workflow and Activity code may be run for test purposes. Temporal\n supports both JUnit4 and JUnit5 packages. The examples in this dev guide will use\n [JUnit5](https://www.javadoc.io/doc/io.temporal/temporal-testing-junit5/latest/index.html)\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging in .NET SDK\nDESCRIPTION: This snippet demonstrates how to configure logging in the Temporal .NET SDK. It sets up console logging with a timestamp format and sets the minimum log level to Information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\")\n{\n    LoggerFactory = LoggerFactory.Create(builder =>\n        builder.\n            AddSimpleConsole(options => options.TimestampFormat = \"[HH:mm:ss] \").\n            SetMinimumLevel(LogLevel.Information)),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Update-With-Start in Go SDK\nDESCRIPTION: Example of creating, configuring, and using UpdateWithStart to either update an existing Workflow or start a new one if it doesn't exist. The code demonstrates how to set up the necessary options and handle the results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nctxWithTimeout, cancel := context.WithTimeout(context.Background(), 15*time.Second)\ndefer cancel()\n\nworkflowOptions := client.StartWorkflowOptions{\n    ID:                       \"some-workflow-id\",\n    TaskQueue:                \"some-task-queue\",\n    WorkflowIDConflictPolicy: enumspb.WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING,\n}\n\nupdateOptions := client.UpdateWorkflowOptions{\n    UpdateName:   message.SetLanguageUpdate,\n    WaitForStage: client.WorkflowUpdateStageCompleted,\n}\n\nstartWorkflowOp := temporalClient.NewWithStartWorkflowOperation(workflowOptions, MyWorkflow)\nupdateHandle, err := temporalClient.UpdateWithStartWorkflow(\n\tctxWithTimeout,\n\tclient.UpdateWithStartWorkflowOptions{\n        StartWorkflowOperation: startWorkflowOp,\n        UpdateOptions:          updateOptions,\n    })\nif err != nil {\n    log.Fatalf(\"Unable to execute update-with-start: %v\", err)\n}\n\nvar previousLang message.Language\nerr = updateHandle.Get(ctxWithTimeout, &previousLang)\nif err != nil {\n    log.Fatalf(\"Unable to obtain update result: %v\", err)\n}\n\nworkflowRun, err := startWorkflowOp.Get(ctxWithTimeout)\nif err != nil {\n    log.Fatalf(\"Unable to obtain workflow run: %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Dynamic Activity with Temporal .NET SDK in C#\nDESCRIPTION: This snippet illustrates defining a dynamic activity by using [Activity(Dynamic = true)] on the method. The DynamicActivity method accepts arguments as IRawValue[] and leverages ActivityExecutionContext.Current.PayloadConverter to extract strongly typed parameter objects. It then formats and returns a greeting string as output. Register the activity with a worker before invocation; it requires using the Temporalio.Converters and Temporalio.Activities namespaces.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyActivities\n{\n    [Activity(Dynamic = true)]\n    public string DynamicActivity(IRawValue[] args)\n    {\n        var input = ActivityExecutionContext.Current.PayloadConverter.ToValue<MyActivityParams>(args.Single());\n        return $\"{input.Greeting}, {input.Name}!\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker with Task Queue Configuration (Simplified)\nDESCRIPTION: This example shows the minimal required configuration for creating a Worker in Temporal TypeScript SDK. It demonstrates specifying activities and a task queue, which is the required parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst worker = await Worker.create({\n  // imported elsewhere\n  activities,\n  taskQueue: 'your-task-queue',\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Activity Retry Policy with ActivityStub in Java\nDESCRIPTION: Demonstrates how to set a custom Activity Retry Policy using ActivityOptions.Builder with an ActivityStub.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nprivate final ActivityOptions options =\n      ActivityOptions.newBuilder()\n          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n          // required when setting Activity options.\n          .setStartToCloseTimeout(Duration.ofSeconds(5))\n          .setRetryOptions(\n              RetryOptions.newBuilder()\n                  .setInitialInterval(Duration.ofSeconds(1))\n                  .setMaximumInterval(Duration.ofSeconds(10))\n                  .build())\n          .build();\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Child Workflows in Go\nDESCRIPTION: This code snippet shows how to implement asynchronous Child Workflows in Go. It includes setting the Parent Close Policy to 'Abandon' and waiting for the Child Workflow Execution to start.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // Wait for the Child Workflow Execution to spawn\n  var childWE workflow.Execution\n  if err := childWorkflowFuture.GetChildWorkflowExecution().Get(ctx, &childWE); err != nil {\n     return err\n  }\n  // ...\n  return resp, nil\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts with WorkflowImplementationOptions in Java\nDESCRIPTION: Shows how to set Activity timeouts using WorkflowImplementationOptions.Builder, allowing for per-Activity timeout configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                                    \"GetCustomerGreeting\",\n                                    // Set Activity Execution timeout\n                                    ActivityOptions.newBuilder()\n                                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                        // .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                        // .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                        .build()))\n                    .build();\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution in .NET\nDESCRIPTION: Illustrates how to start a workflow execution with specific workflow options including workflow ID and task queue configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/temporal-client.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = await client.ExecuteWorkflowAsync(\n    (MyWorkflow wf) => wf.RunAsync(),\n    new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\");\nConsole.WriteLine(\"Result: {0}\", result);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Asynchronous Workflow Completion with Typed WorkflowStub in Java\nDESCRIPTION: Shows how to wait for an asynchronously started Workflow to complete using a typed WorkflowStub. This approach reconnects to an existing Workflow and waits for its result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_24\n\nLANGUAGE: java\nCODE:\n```\nYourWorkflow workflow = client.newWorkflowStub(YourWorkflow.class, workflowId);\n\n// Returns the result after waiting for the Workflow to complete.\nString result = workflow.yourMethod();\n```\n\n----------------------------------------\n\nTITLE: Describing a Scheduled Workflow with Temporal Python SDK\nDESCRIPTION: Describes how to obtain the configuration and metadata for an existing Workflow Schedule using the Temporal Python SDK. After connecting to the server and getting the schedule handle, the code calls the describe() method, returning a ScheduleDescription object. The returned data can include notes and other attributes. Requires the Temporal SDK and server connectivity. Inputs: Schedule ID. Outputs: Schedule description printed to stdout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ...\\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n    handle = client.get_schedule_handle(\\n        \"workflow-schedule-id\",\\n    )\\n\\n    desc = await handle.describe()\\n\\n    print(f\"Returns the note: {desc.schedule.state.note}\")\n```\n\n----------------------------------------\n\nTITLE: Executing Initial Activity in Temporal Workflow - Python\nDESCRIPTION: Defines a basic Temporal Workflow in Python that runs the original activity (`pre_patch_activity`). The code uses the Python Temporal SDK, imports the required activity with `workflow.unsafe.imports_passed_through()`, and executes the activity with a specified timeout. Inputs include no external parameters, and the activity is awaited for completion. This is the pre-migration state and serves as the starting point before applying patching or updating Workflow behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\\n\\nfrom temporalio import workflow\\n\\nwith workflow.unsafe.imports_passed_through():\\n    from activities import pre_patch_activity\\n# ...\\n@workflow.defn\\nclass MyWorkflow:\\n    @workflow.run\\n    async def run(self) -> None:\\n        self._result = await workflow.execute_activity(\\n            pre_patch_activity,\\n            schedule_to_close_timeout=timedelta(minutes=5),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start in C# Temporal SDK\nDESCRIPTION: This snippet demonstrates how to use Signal-With-Start, which allows sending a Signal to a Workflow and starting it if it's not already running. It uses the SignalWithStart option when starting a Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\nvar options = new WorkflowOptions(id: \"your-signal-with-start-workflow\", taskQueue: \"signal-tq\");\noptions.SignalWithStart((GreetingWorkflow wf) => wf.SubmitGreetingAsync(\"User Signal with Start\"));\nawait client.StartWorkflowAsync((GreetingWorkflow wf) => wf.RunAsync(), options);\n```\n\n----------------------------------------\n\nTITLE: Setting Parent Close Policy for Child Workflows - Temporal Python SDK\nDESCRIPTION: This Python snippet illustrates how to configure the parent_close_policy parameter using the Temporal Python SDK when spawning a child workflow. It introduces the ParentClosePolicy dependency from temporalio.workflow and demonstrates the use of the ABANDON policy so that if the parent workflow closes, the child workflow is abandoned rather than terminated. All required parent and child workflow definitions are present, and the pattern shows the insertion of the policy argument within the child execution call. The code enforces control over child workflow fate based on parent closure and is intended for scenarios that require non-default workflow lifecycle handling.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/child-workflows.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.workflow import ParentClosePolicy\n# ...\n# ...\n@workflow.defn\nclass ComposeGreetingWorkflow:\n    @workflow.run\n    async def run(self, input: ComposeGreetingInput) -> str:\n        return f\"{input.greeting}, {input.name}!\"\n\n\n@workflow.defn\nclass GreetingWorkflow:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_child_workflow(\n            ComposeGreetingWorkflow.run,\n            ComposeGreetingInput(\"Hello\", name),\n            id=\"hello-child-workflow-workflow-child-id\",\n            parent_close_policy=ParentClosePolicy.ABANDON,\n        )\n```\n\n----------------------------------------\n\nTITLE: Handling Workflow Execution Errors in TypeScript\nDESCRIPTION: This snippet demonstrates error handling when retrieving Workflow results. It catches WorkflowFailedError and other errors, providing appropriate error messages with the original error as the cause.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error('Temporal workflow failed: ' + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error('error from Temporal workflow ' + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Blocking Wait Conditions to Update Handlers in Go\nDESCRIPTION: Example of using workflow.Await to add wait conditions in an Update handler. This pattern helps ensure that certain conditions are met before the handler continues execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nerr = workflow.SetUpdateHandler(ctx, \"UpdateHandler\", func(ctx workflow.Context, input UpdateInput) error {\n    workflow.Await(ctx, updateUnblockedFunc)\n    ...\n})\n```\n\n----------------------------------------\n\nTITLE: Listing Scheduled Workflows in .NET\nDESCRIPTION: This snippet shows how to list all available Scheduled Workflows using the ListSchedulesAsync method, which returns an async enumerable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\nawait foreach (var desc in client.ListSchedulesAsync())\n{\n    Console.WriteLine(\"Schedule info: {0}\", desc.Info);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Temporal Activity Function with requests in Python\nDESCRIPTION: Shows an alternative implementation of the synchronous Temporal Activity `greet_in_spanish` as a standalone decorated function instead of a class method. It uses the `requests` library via the `call_service` helper function for HTTP requests. This functional approach is suitable when no shared state (like a session object managed via `__init__`) is needed across Activity method calls.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sync-vs-async.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@activity.defn\ndef greet_in_spanish(name: str) -> str:\n    greeting = call_service(\"get-spanish-greeting\", name)\n    return greeting\n\n# Utility method for making calls to the microservices\ndef call_service(stem: str, name: str) -> str:\n    base = f\"http://localhost:9999/{stem}\"\n    url = f\"{base}?name={urllib.parse.quote(name)}\"\n\n    response = requests.get(url)\n    return response.text\n```\n\n----------------------------------------\n\nTITLE: Creating a Nexus Endpoint in Temporal Cloud\nDESCRIPTION: Bash command to create a Nexus endpoint in Temporal Cloud that routes requests from caller to handler namespace. This configures the cross-namespace communication channel with appropriate access controls.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ntcld nexus endpoint create \\\n  --name <my-nexus-endpoint-name> \\\n  --target-task-queue my-handler-task-queue \\\n  --target-namespace <my-target-namespace.account> \\\n  --allow-namespace <my-caller-namespace.account> \\\n  --description-file ./core/src/main/java/io/temporal/samples/nexus/service/description.md\n```\n\n----------------------------------------\n\nTITLE: Retrieving Available Regions in Temporal Cloud using Terraform\nDESCRIPTION: This snippet demonstrates how to use the temporalcloud_regions data source to retrieve a list of available regions in your Temporal Cloud account. It also shows how to output the retrieved regions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\ndata \"temporalcloud_regions\" \"regions\" {}\n\noutput \"regions\" {\n  value = data.temporalcloud_regions.regions.regions\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering a Schedule in Java\nDESCRIPTION: This snippet demonstrates how to trigger an immediate action for a Schedule using the trigger() method on the ScheduleHandle. It's useful for executing a Workflow outside of its scheduled time.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\nhandle.trigger();\n```\n\n----------------------------------------\n\nTITLE: Setting a Durable Timer in PHP Temporal Workflow\nDESCRIPTION: This code snippet demonstrates how to set a durable timer for 5 minutes in a Temporal Workflow using PHP. It uses the Workflow::timer() method, passing the number of seconds to wait before continuing execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\nyield Workflow::timer(300); // sleep for 5 minutes\n```\n\n----------------------------------------\n\nTITLE: Removing a Temporal Search Attribute within a Workflow in TypeScript\nDESCRIPTION: This snippet demonstrates the specific action of removing a previously set Search Attribute from within a Temporal Workflow using the TypeScript SDK. It calls `upsertSearchAttributes` and provides the target attribute key (`CustomIntField`) with an empty array `[]` as its value, effectively deleting it from the Workflow Execution's Search Attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { upsertSearchAttributes } from '@temporalio/workflow';\n\nasync function yourWorkflow() {\n  upsertSearchAttributes({ CustomIntField: [1, 2, 3] });\n\n  // ... later, to remove:\n  upsertSearchAttributes({ CustomIntField: [] });\n}\n```\n\n----------------------------------------\n\nTITLE: Terminating a Temporal Workflow Execution in Python\nDESCRIPTION: This snippet demonstrates how to forcefully terminate a running Temporal Workflow Execution using the Python SDK. It retrieves the Workflow handle using its ID via the client and then calls the `terminate()` method. This immediately stops the Workflow Execution without allowing any cleanup logic within the Workflow code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/cancellation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nawait client.get_workflow_handle(\"your_workflow_id\").terminate()\n```\n\n----------------------------------------\n\nTITLE: Synchronous Workflow Start Using Typed Stub - Temporal PHP\nDESCRIPTION: Demonstrates how to synchronously initiate a Workflow Execution and obtain its result using a typed Workflow stub in PHP. This pattern acquires a stub for the Workflow interface, starts the Workflow, and directly receives the result. Required dependencies are the WorkflowClient, the Workflow interface, and the inputs such as account IDs and transfer amount.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_8\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$accountTransfer = $workflowClient->newWorkflowStub(\\n    AccountTransferWorkflowInterface::class,\\n);\\n\\n$result = $accountTransfer->transfer('fromID', 'toID', 'refID', 1000);\\n\n```\n\n----------------------------------------\n\nTITLE: Setting TaskQueue via ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to specify a custom Task Queue for an Activity using `ActivityOptions.newBuilder().setTaskQueue()` when creating an `ActivityStub` within a Temporal Workflow. This directs the Activity Task to the specified queue ('yourTaskQueue'). It also sets a required `StartToCloseTimeout`. Dependencies include `io.temporal.workflow.Workflow`, `io.temporal.activity.ActivityOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_30\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        // note that either StartToCloseTimeout or ScheduleToCloseTimeout are required when\n                        // setting Activity options.\n                        .setStartToCloseTimeout(Duration.ofSeconds(5))\n                        .setTaskQueue(\"yourTaskQueue\")\n                        .build());\n```\n\n----------------------------------------\n\nTITLE: Backfilling a Scheduled Workflow in .NET\nDESCRIPTION: This code shows how to backfill a Scheduled Workflow using the BackfillAsync method. It executes missed actions within a specified time range.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nvar now = DateTime.Now;\nawait handle.BackfillAsync(new List<ScheduleBackfill>\n{\n    new(\n        StartAt: now - TimeSpan.FromDays(30),\n        EndAt: now - TimeSpan.FromDays(20),\n        Overlap: ScheduleOverlapPolicy.AllowAll),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Payload Codec with Compression - Temporal Python SDK (Python)\nDESCRIPTION: This snippet demonstrates the implementation of a custom Payload Codec for the Temporal Python SDK, providing an encode function to marshal and compress payloads using the 'cramjam' library (with 'snappy' compression), and a decode function to decompress and unmarshal them. Dependencies include 'cramjam', 'temporalio.api.common.v1.Payload', and 'temporalio.converter.PayloadCodec'. The codec processes sequences of payloads, tagging their encoding metadata and handling the binary conversion steps necessary for client-side compression in Temporal Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/converters-and-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cramjam\nfrom temporalio.api.common.v1 import Payload\nfrom temporalio.converter import PayloadCodec\n\nclass EncryptionCodec(PayloadCodec):\n    async def encode(self, payloads: Iterable[Payload]) -> List[Payload]:\n        return [\n            Payload(\n                metadata={\n                    \"encoding\": b\"binary/snappy\",\n                },\n                data=(bytes(cramjam.snappy.compress(p.SerializeToString()))),\n            )\n            for p in payloads\n        ]\n\n    async def decode(self, payloads: Iterable[Payload]) -> List[Payload]:\n        ret: List[Payload] = []\n        for p in payloads:\n            if p.metadata.get(\"encoding\", b\"\").decode() != \"binary/snappy\":\n                ret.append(p)\n                continue\n            ret.append(Payload.FromString(bytes(cramjam.snappy.decompress(p.data))))\n        return ret\n```\n\n----------------------------------------\n\nTITLE: Setting up a Temporal Cron Job in PHP\nDESCRIPTION: This code demonstrates how to set up a Temporal Cron Job using PHP. It creates a new Workflow stub with a Cron Schedule that runs every minute, sets execution and run timeouts, and starts the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$workflow = $this->workflowClient->newWorkflowStub(\n    CronWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(CronWorkflowInterface::WORKFLOW_ID)\n        ->withCronSchedule('* * * * *')\n        // Execution timeout limits total time. Cron will stop executing after this timeout.\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(10))\n        // Run timeout limits duration of a single workflow invocation.\n        ->withWorkflowRunTimeout(CarbonInterval::minute(1))\n);\n\n$output->writeln(\"Starting <comment>CronWorkflow</comment>... \");\n\ntry {\n    $run = $this->workflowClient->start($workflow, 'Antony');\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Interrupt Handling in Go\nDESCRIPTION: Employs temporal.NewServer() with temporal.InterruptOn(temporal.InterruptCh()) to set up graceful shutdown of the server in response to a termination signal (e.g., Ctrl+C). This blocks server.Start() until a signal is received. Inputs include an interrupt channel, and it is compatible with standard signal handling; dependencies are the go.temporal.io/server/temporal package. Ensures controlled server shutdown for production or development environments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.InterruptOn(temporal.InterruptCh()),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Loan Application Workflow Implementation in Go\nDESCRIPTION: A complete example of a loan application Workflow in Go. This function demonstrates multiple steps including notifying the applicant, performing credit and approval checks, and handling the results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// LoanApplicationWorkflow is the workflow definition.\nfunc LoanApplicationWorkflow(ctx workflow.Context, applicantName string, loanAmount int) (string, error) {\n\t// Step 1: Notify the applicant that the application process has started\n\terr := workflow.ExecuteActivity(ctx, NotifyApplicantActivity, applicantName, \"Application process started\").Get(ctx, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Step 2: Perform a credit check\n\tvar creditCheckResult string\n\terr = workflow.ExecuteActivity(ctx, LoanCreditCheckActivity, loanAmount).Get(ctx, &creditCheckResult)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Step 3: Perform an automatic approval check\n\tvar approvalCheckResult string\n\terr = workflow.ExecuteActivity(ctx, AutomaticApprovalCheckActivity, creditCheckResult).Get(ctx, &approvalCheckResult)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Step 4: Notify the applicant of the decision\n\tvar notificationResult string\n\terr = workflow.ExecuteActivity(ctx, NotifyApplicantActivity, applicantName, approvalCheckResult).Get(ctx, &notificationResult)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn notificationResult, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Through Modules into Python Sandbox at Import Time\nDESCRIPTION: This example illustrates how to use the `workflow.unsafe.imports_passed_through()` context manager within a Python workflow file. This allows specified modules, like `pydantic`, to be imported directly from the host environment into the sandbox, bypassing the default behavior of reloading non-standard modules for each workflow run. This is intended for known side-effect-free modules to improve performance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n```python\n# my_workflow_file.py\n\nfrom temporalio import workflow\n\nwith workflow.unsafe.imports_passed_through():\n    import pydantic\n\n@workflow.defn\nclass MyWorkflow:\n     # ...\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Progress Query in a Temporal Go Workflow\nDESCRIPTION: Demonstrates a unit test for the ProgressWorkflow using Temporal's Go SDK test environment, focusing on querying the workflow's state with delayed callbacks. The test uses RegisterDelayedCallback to simulate passage of time and ensure the getProgress query returns correct values at different time points. Dependencies include the Temporal Go SDK test suite environment and correct registration of the workflow and its query handlers; the main parameter is the workflow environment state. Expected input is the trigger timing and query name, outputs are the queried progress values. Best used for validating logic in environments with simulated time advancement.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_ProgressWorkflow() {\n\tvalue := 0\n\n\t// After 10 seconds plus padding, progress should be 10.\n\t// Note that `RegisterDelayedCallback()` doesn't actually make your test wait for 10 seconds!\n\t// Temporal's test framework advances time internally, so this test should take < 1 second.\n\ts.env.RegisterDelayedCallback(func() {\n\t\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\t\ts.NoError(err)\n\t\terr = res.Get(&value)\n\t\ts.NoError(err)\n\t\ts.Equal(10, value)\n\t}, time.Second*10+time.Millisecond*1)\n\n\ts.env.ExecuteWorkflow(ProgressWorkflow, 0)\n\n\ts.True(s.env.IsWorkflowCompleted())\n\n\t// Once the workflow is completed, progress should always be 100\n\tres, err := s.env.QueryWorkflow(\"getProgress\")\n\ts.NoError(err)\n\terr = res.Get(&value)\n\ts.NoError(err)\n\ts.Equal(value, 100)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Logging from a Temporal Workflow\nDESCRIPTION: Example of using the built-in logging functionality from within a Temporal Workflow. This demonstrates how to log information in a deterministic way that's compatible with Temporal's execution model.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as wf from '@temporalio/workflow';\n\nexport async function logSampleWorkflow(): Promise<void> {\n  wf.log.info('Workflow execution started');\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-Stage Dockerfile for Temporal TypeScript Worker using Distroless Image\nDESCRIPTION: This multi-stage Dockerfile creates a minimal and secure container for a Temporal TypeScript Worker using a `distroless/nodejs` base image. The first stage (`builder`) uses a standard Node.js image to install dependencies and build the application. The final stage copies only the built application artifacts from the builder stage into the lightweight `gcr.io/distroless/nodejs20-debian11` image, reducing the final image size and potential security surface. The `CMD` uses `node` directly as `npm` is not available in distroless images.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_26\n\nLANGUAGE: dockerfile\nCODE:\n```\n```dockerfile\n# -- BUILD STEP --\n\nFROM node:20-bullseye AS builder\n\nCOPY . /app\nWORKDIR /app\n\nRUN npm install --only=production \\\n    && npm run build\n\n# -- RESULTING IMAGE --\n\nFROM gcr.io/distroless/nodejs20-debian11\n\nCOPY --from=builder /app /app\nWORKDIR /app\n\nCMD [\"node\", \"build/worker.js\"]\n```\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution Asynchronously with Untyped WorkflowStub in Java\nDESCRIPTION: This snippet demonstrates starting a Workflow Execution asynchronously using an untyped WorkflowStub. It creates the stub with the Workflow type, ID, and Task Queue, then uses the start method to initiate the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nWorkflowStub untyped = client.newUntypedWorkflowStub(\"FileProcessingWorkflow\",\n      WorkflowOptions.newBuilder()\n              .setWorkflowId(workflowId)\n              .setTaskQueue(taskQueue)\n              .build());\n\n// blocks until Workflow Execution has been started (not until it completes)\nuntyped.start(argument);\n```\n\n----------------------------------------\n\nTITLE: Executing Update-With-Start in TypeScript Temporal SDK\nDESCRIPTION: Demonstrates how to use executeUpdateWithStart to start an Update and wait for the result. It shows the usage of WithStartWorkflowOperation to define the Workflow that will be started if necessary.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst startWorkflowOperation = new WithStartWorkflowOperation.create(\n  transactionWorkflow,\n  {\n    workflowId,\n    args: [transactionID],\n    taskQueue: 'early-return',\n    workflowIdConflictPolicy: 'FAIL',\n  },\n);\n\nconst earlyConfirmation = await client.workflow.executeUpdateWithStart(\n  getTransactionConfirmation,\n  {\n    startWorkflowOperation,\n  },\n);\n\nconst wfHandle = await startWorkflowOperation.workflowHandle();\nconst finalReport = await wfHandle.result();\n```\n\n----------------------------------------\n\nTITLE: Applying Patching Logic with Feature Flag in Temporal Workflow - Python\nDESCRIPTION: Demonstrates the use of Temporal Python SDK's `patched` function to conditionally execute either the old or new activity within a Workflow. The function inserts a marker (`my-patch`) into Workflow history, serving as a feature flag to control which activity is used. During replay, Workers verify patch presence to maintain deterministic execution. The snippet requires the `patched` API and both `pre_patch_activity` and `post_patch_activity` available. Inputs are implicit based on patch marker; output is the result of the selected activity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@workflow.defn\\nclass MyWorkflow:\\n    @workflow.run\\n    async def run(self) -> None:\\n        if workflow.patched(\\\"my-patch\\\"):\\n            self._result = await workflow.execute_activity(\\n                post_patch_activity,\\n                schedule_to_close_timeout=timedelta(minutes=5),\\n            )\\n        else:\\n            self._result = await workflow.execute_activity(\\n                pre_patch_activity,\\n                schedule_to_close_timeout=timedelta(minutes=5),\\n            )\n```\n\n----------------------------------------\n\nTITLE: Racing Timers and Signals in Temporal TypeScript Workflows\nDESCRIPTION: Uses `Promise.race` to wait for either a predefined duration ('30 days' via `sleep`) or an external Signal ('completeUserInteraction') received via a `Trigger`. This allows workflows to react efficiently to both timeouts and external events like human interaction.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/timers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { defineSignal, sleep, Trigger } from '@temporalio/workflow';\n\nconst userInteraction = new Trigger<boolean>();\nconst completeUserInteraction = defineSignal('completeUserInteraction');\n\nexport async function yourWorkflow(userId: string) {\n  setHandler(completeUserInteraction, () => userInteraction.resolve(true)); // programmatic resolve\n  const userInteracted = await Promise.race([\n    userInteraction,\n    sleep('30 days'),\n  ]);\n  if (!userInteracted) {\n    await sendReminderEmail(userId);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing File Processing Activity Interface in Temporal (PHP)\nDESCRIPTION: This snippet provides a concrete PHP implementation of a Temporal Activity interface for file processing operations using an S3 client. It covers upload, download, processing, and deletion of files, requiring dependencies such as S3Client and access to a local directory. Key configuration, such as Activity logic and resource locations, is provided via constructor injection. Each public method maps to a specific Activity for file manipulation. All method inputs are strongly typed, and the processFile function demonstrates returning a string after presumably compressing a file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_8\n\nLANGUAGE: php\nCODE:\n```\n// An implementation of an Activity interface.\nclass FileProcessingActivitiesImpl implements FileProcessingActivities {\n\n    private S3Client $s3Client;\n\n    private string $localDirectory;\n\n    public function __construct(S3Client $s3Client, string $localDirectory) {\n        $this->s3Client = $s3Client;\n        $this->localDirectory = $localDirectory;\n    }\n\n    // Uploading a file to S3.\n    public function upload(string $bucketName, string $localName, string $targetName): void\n    {\n        $this->s3Client->putObject(\n            $bucketName,\n            $targetName,\n            fopen($this->localDirectory . $localName, 'rb+')\n        );\n    }\n\n// Downloading a file from S3.\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->s3Client->downloadObject(\n            $bucketName,\n            $remoteName,\n            fopen($this->localDirectory .$localName, 'wb+')\n        );\n    }\n\n// A function that takes a local file name as an argument and returns a string.\n    public function processFile(string $localName): string\n    {\n        // Implementation omitted for brevity.\n        return compressFile($this->localDirectory . $localName);\n    }\n\n    public function deleteLocalFile(string $fileName): void\n    {\n        unlink($this->localDirectory . $fileName);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Signal Handler in Java Workflow\nDESCRIPTION: Shows how to define and implement a Signal handler in a Java Workflow. The Signal handler modifies the Workflow state by changing the language.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic class MessagePassingIntro {\n\n    public static class ApproveInput {\n        private String name;\n\n        public ApproveInput() {}\n\n        public ApproveInput(String name) {\n            this.name = name;\n        }\n    }\n\n    @WorkflowInterface\n    public interface GreetingWorkflow {\n        ...\n        // 👉 Use the @SignalMethod annotation to define a Signal handler in the\n        // Workflow interface.\n        @SignalMethod\n        void approve(ApproveInput input);\n    }\n\n    public static class GreetingWorkflowImpl implements GreetingWorkflow {\n        ...\n        @Override\n        public Language setLanguage(Language language) {\n            // 👉 The Signal handler mutates the Workflow state but cannot return a value.\n            Language previousLanguage = this.language;\n            this.language = language;\n            return previousLanguage;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Timer Internally using CancellationScope.cancellable in TypeScript\nDESCRIPTION: This snippet demonstrates how to internally cancel a timer (`sleep`) within a Temporal Workflow. It creates a cancellable scope using `CancellationScope.cancellable`, starts a 1ms timer, immediately cancels the scope using `CancellationScope.current().cancel()`, and then awaits the timer's promise. The `try...catch` block handles the expected `CancelledFailure` that is thrown when awaiting the cancelled timer.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimer(): Promise<void> {\n  // Timers and Activities are automatically cancelled when their containing scope is cancelled.\n  try {\n    await CancellationScope.cancellable(async () => {\n      const promise = sleep(1); // <-- Will be cancelled because it is attached to this closure's scope\n      CancellationScope.current().cancel();\n      await promise; // <-- Promise must be awaited in order for `cancellable` to throw\n    });\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Workflow ID using Temporal Python SDK\nDESCRIPTION: This snippet shows how to assign a specific Workflow ID when starting a Workflow Execution via the `client.execute_workflow` method, using the `id` parameter. Providing a unique, business-relevant Workflow ID is crucial for identifying and managing Workflow Executions. Dependencies include `temporalio.client` and `asyncio`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/temporal-clients.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Search Attributes in Temporal .NET SDK\nDESCRIPTION: This snippet demonstrates how to set custom Search Attributes when starting a Workflow using the Temporal .NET SDK. It uses the TypedSearchAttributes property on WorkflowOptions for StartWorkflowAsync, creating a SearchAttributeCollection with a builder.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// This only needs to be created once, so it is common to make it a static readonly even though we\n// create inline here for demonstration\nvar myKeywordAttributeKey = SearchAttributeKey.CreateKeyword(\"MyKeywordAttribute\");\n\n// Start workflow with the search attribute collection\nvar handle = await client.StartWorkflowAsync(\n    (MyWorkflow wf) => wf.RunAsync(),\n    new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\")\n    {\n        TypedSearchAttributes = new SearchAttributeCollection.Builder().\n            Set(myKeywordAttributeKey, \"SomeKeywordValue\").\n            ToSearchAttributeCollection(),\n    });\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Execution Result After Asynchronous Start - Temporal PHP\nDESCRIPTION: Illustrates how to block for and retrieve the result of a Workflow Execution started asynchronously, by calling getResult() on the WorkflowRun object. This is necessary when immediate Workflow state or output is needed post-launch. Required dependencies include the WorkflowClient, a stub instance, and parameters suitable for the Workflow interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_13\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newWorkflowStub(YourWorkflowInterface::class);\\n$run = $workflowClient->start($stub, 'fromID', 'toID', 'refID', 1000);\\n\\nvar_dump($run->getResult());\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow Executions with ListWorkflow in Go\nDESCRIPTION: This snippet demonstrates how to query Workflow Executions using the ListWorkflow function and a List Filter in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nrequest := &workflowservice.ListWorkflowExecutionsRequest{ Query: \"CloseTime = missing\" }\n\nresp, err := temporalClient.ListWorkflow(ctx.Background(), request)\nif err != nil {\n  return err\n}\n\nfmt.Println(\"First page of results:\")\nfor _, exec := range resp.Executions {\n  fmt.Printf(\"Workflow ID %v\\n\", exec.Execution.WorkflowId)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Injecting Sink Function into a Temporal Worker\nDESCRIPTION: Example showing how to implement and inject a sink function into a Temporal Worker. This demonstrates setting up custom alerting functionality that can be called from workflows while maintaining determinism.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InjectedSinks, Worker } from '@temporalio/worker';\nimport { MySinks } from './workflows';\n\nasync function main() {\n  const sinks: InjectedSinks<MySinks> = {\n    alerter: {\n      alert: {\n        fn(workflowInfo, message) {\n          console.log('sending SMS alert!', {\n            workflowId: workflowInfo.workflowId,\n            workflowRunId: workflowInfo.runId,\n            message,\n          });\n        },\n        callDuringReplay: false, // The default\n      },\n    },\n  };\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'sinks',\n    sinks,\n  });\n  await worker.run();\n  console.log('Worker gracefully shutdown');\n}\n\nmain().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing PrePatchActivity in .NET Temporal Workflow\nDESCRIPTION: This snippet shows the initial implementation of a Workflow using PrePatchActivity. It demonstrates how to execute an activity within a Workflow using the Temporal .NET SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        this.result = await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.PrePatchActivity(),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Completing Asynchronous Activity Externally in PHP\nDESCRIPTION: Demonstrates how to complete an asynchronous activity externally using WorkflowClient. It uses the activity completion client to complete the activity by token.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/asynchronous-activity-completion.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n$client = $this->workflowClient->newActivityCompletionClient();\n// Complete the Activity.\n$client->completeByToken(\n    base64_decode($input->getArgument('token')),\n    $input->getArgument('message')\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutable Side Effects in Temporal Go SDK\nDESCRIPTION: This example demonstrates how to use the MutableSideEffect function to maintain a configurable value that only updates in the Workflow History when changed. It requires a unique ID, a getter function, and an equality function to compare values. This reduces the number of events recorded in the Workflow History.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/side-effects.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nif err := workflow.MutableSideEffect(ctx, \"configureNumber\", get, eq).Get(&number); err != nil {\n    panic(\"can't decode number:\" + err.Error())\n  }\n```\n\n----------------------------------------\n\nTITLE: Ensuring Handlers Complete Before Workflow Finishes in Temporal PHP\nDESCRIPTION: Demonstrates how to ensure all Signal and Update handlers complete their work before a Workflow finishes execution, preventing handlers from being interrupted mid-execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_18\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\nclass MyWorkflow\n{\n    #[WorkflowMethod]\n    public function run()\n    {\n        // ...\n        yield Workflow::await(fn() => Workflow::allHandlersFinished());\n        return \"workflow-result\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToStartTimeout with ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to set the ScheduleToStartTimeout using an ActivityStub within a Workflow implementation. It also includes setting the required ScheduleToCloseTimeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_24\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                          // required when setting Activity options.\n                          .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                          .build());\n```\n\n----------------------------------------\n\nTITLE: Temporal Service gRPC Command Names\nDESCRIPTION: Key gRPC commands and events used in Temporal workflow execution including RespondWorkflowTaskCompleted, ScheduleActivityTask, ActivityTaskScheduled, and CompleteWorkflowExecution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/event-history/typescript.mdx#2025-04-23_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nRespondWorkflowTaskCompleted\nScheduleActivityTask\nActivityTaskScheduled\nActivityTaskStarted\nActivityTaskCompleted\nWorkflowTaskScheduled\nWorkflowTaskStarted\nWorkflowTaskCompleted\nStartTimer\nTimerStarted\nTimerFired\nWorkflowExecutionStarted\nWorkflowExecutionCompleted\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Search Attributes in Go\nDESCRIPTION: This code shows how to set custom Search Attributes when starting a Workflow using StartWorkflowOptions in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (c *Client) CallYourWorkflow(ctx context.Context, workflowID string, payload map[string]interface{}) error {\n    // ...\n    searchAttributes := map[string]interface{}{\n        \"CustomerId\": payload[\"customer\"],\n        \"MiscData\": payload[\"miscData\"]\n    }\n    options := client.StartWorkflowOptions{\n        SearchAttributes:   searchAttributes\n        // ...\n    }\n    we, err := c.Client.ExecuteWorkflow(ctx, options, app.YourWorkflow, payload)\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Cluster Search Attributes with tctl (Bash)\nDESCRIPTION: This command uses `tctl admin cluster add-search-attributes` to add one or more custom Search Attributes to a Temporal Cluster. It requires specifying the attribute name (`--name`) and its value type (`--type`, e.g., Text, Keyword, Int). Users running Temporal via the standard docker-compose setup might need to increase Docker memory. Note that due to Elasticsearch limitations, attributes cannot be renamed or removed from the index once added, only new ones can be added.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/admin.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl admin cluster add-search-attributes --name <SearchAttributeName> --type <SearchAttributeValueType>\n```\n\n----------------------------------------\n\nTITLE: Starting Activity Execution in C#\nDESCRIPTION: Illustrates how to start an Activity Execution from within a Workflow Definition using the ExecuteActivityAsync method. It includes setting Activity options like timeouts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Workflows;\n\n[Workflow]\npublic class MyWorkflow\n{\n    public async Task<string> RunAsync(string name)\n    {\n        var param = MyActivityParams(\"Hello\", name);\n        return await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyActivity(param),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom DataConverter in Client Options\nDESCRIPTION: Shows how to configure a Temporal client to use a custom DataConverter with the payload codec during client initialization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/converters-and-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//...\nc, err := client.Dial(client.Options{\n\t\t// Set DataConverter here to ensure that Workflow inputs and results are\n\t\t// encoded as required.\n\t\tDataConverter: mycodecpackage.DataConverter,\n\t})\n//...\n```\n\n----------------------------------------\n\nTITLE: Updating a Temporal Cloud Service Account Description using tcld (bash)\nDESCRIPTION: Illustrates how to update the description of an existing Service Account using the `tcld service-account update` command. It uses the `--id` flag to specify the Service Account and the `-d` flag to provide the new description (`\"new description\"`). Other commands like `set-account-role` and `set-namespace-permissions` are available for updating other attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/service-accounts.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld service-account update --id \"2f68507677904e09b9bcdbf93380bb95\" -d \"new description\"\n```\n\n----------------------------------------\n\nTITLE: Dynamically Referencing Temporal Activities by Name in JavaScript\nDESCRIPTION: Illustrates how to dynamically invoke a Temporal Activity within a Workflow using its string name stored in a variable (`activityName`). This is achieved by calling `proxyActivities` and then accessing the desired activity using bracket notation (`acts[activityName](...args)`). This allows for flexible Activity invocation based on runtime conditions, though explicit type safety is reduced compared to static references.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_21\n\nLANGUAGE: js\nCODE:\n```\nexport async function DynamicWorkflow(activityName, ...args) {\n  const acts = proxyActivities(/* activityOptions */);\n\n  // these are equivalent\n  await acts.activity1();\n  await acts['activity1']();\n\n  // dynamic reference to activities using activityName\n  let result = await acts[activityName](...args);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ProtobufBinaryPayloadConverter for Binary Encoding - TypeScript\nDESCRIPTION: This TypeScript snippet sets up a `ProtobufBinaryPayloadConverter`, which serializes all handled protobuf objects using binary encoding for efficiency, rather than JSON. This can save storage but may impact readability in debugging tools like the Temporal Web UI. Use this converter when binary protobuf payload format is needed and only protobuf types are expected.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new ProtobufBinaryPayloadConverter(root);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Hello Workflow in C#\nDESCRIPTION: This snippet defines a basic Workflow class called SayHelloWorkflow with a WorkflowRun method that takes a name parameter and returns a greeting string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class SayHelloWorkflow\n{\n    [WorkflowRun]\n    public async Task<string> RunAsync(string name)\n    {\n        return $\"Hello, {name}!\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Cancellation of Temporal Workflow - Go\nDESCRIPTION: This snippet shows how to request Cancellation of a Workflow using the CancelWorkflow API in Go. It demonstrates canceling a Workflow by its ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/cancellation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\terr = temporalClient.CancelWorkflow(context.Background(), cancellation.WorkflowId, \"\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to cancel Workflow Execution\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Replaying Multiple Temporal Workflow Histories in Bulk via SDK Client (TypeScript)\nDESCRIPTION: Illustrates how to fetch multiple Workflow Event Histories matching a specific query using `client.workflow.list` (requires Advanced Visibility) and `executions.intoHistories()`. These histories are then replayed concurrently using `Worker.runReplayHistories`. The code iterates through the results to identify any replay failures, which is crucial for CI checks validating Workflow Definition changes against a set of production histories.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\nconst executions = client.workflow.list({\n  query: 'TaskQueue=foo and StartTime > \"2022-01-01T12:00:00\"',\n});\nconst histories = executions.intoHistories();\nconst results = Worker.runReplayHistories(\n  {\n    workflowsPath: require.resolve('./your/workflows'),\n  },\n  histories,\n);\nfor await (const result of results) {\n  if (result.error) {\n    console.error('Replay failed', result);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Completed Update Results in Temporal PHP\nDESCRIPTION: This example demonstrates how to explicitly wait for an Update operation to complete by setting the lifecycle stage to StageCompleted, allowing the client to get the result once available.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_16\n\nLANGUAGE: php\nCODE:\n```\n$handle = $workflowClient->updateWithStart(\n    workflow: $stub,\n    update: UpdateOptions::new('addItem', LifecycleStage::StageCompleted),\n    updateArgs: [$itemId, $quantity],\n);\n\nassert($handle->hasResult() === true);\n$price = $handle->getResult();\n```\n\n----------------------------------------\n\nTITLE: Handling Workflow Failures When Retrieving Results\nDESCRIPTION: This example demonstrates proper error handling when retrieving Workflow results. It catches WorkflowFailedError for workflows that ended prematurely and handles other types of errors, providing better context in the error message.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = client.getHandle(workflowId);\ntry {\n  const result = await handle.result();\n} catch (err) {\n  if (err instanceof WorkflowFailedError) {\n    throw new Error('Temporal workflow failed: ' + workflowId, {\n      cause: err,\n    });\n  } else {\n    throw new Error('error from Temporal workflow ' + workflowId, {\n      cause: err,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Dockerfile for Temporal TypeScript Worker using Node.js Image\nDESCRIPTION: This Dockerfile provides a basic setup for containerizing a Temporal TypeScript Worker application using the standard `node:20-bullseye` base image. It copies the application code, installs production dependencies using `npm install --only=production`, builds the application with `npm run build`, and sets the default command to start the application using `npm start`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_24\n\nLANGUAGE: dockerfile\nCODE:\n```\n```dockerfile\nFROM node:20-bullseye\n\n# For better cache utilization, copy package.json and lock file first and install the dependencies before copying the\n# rest of the application and building.\nCOPY . /app\nWORKDIR /app\n\n# Alternatively, run npm ci, which installs only dependencies specified in the lock file and is generally faster.\nRUN npm install --only=production \\\n    && npm run build\n\nCMD [\"npm\", \"start\"]\n```\n```\n\n----------------------------------------\n\nTITLE: Simple Success Test for Go Workflow\nDESCRIPTION: A simple test case that executes a Workflow and verifies its successful completion without errors. This demonstrates the most basic testing pattern for Temporal Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/debugging.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_Success() {\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_success\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Signaling with Start Using Temporal Workflows via Command-Line - command\nDESCRIPTION: This command-line example demonstrates how to perform 'Signal With Start' on a Temporal workflow with Python. In one terminal, run 'your_worker.py' to start the worker; in another, execute 'signal_with_start_dacx.py' to both start the workflow and send a signal in a single step. Poetry is required, and Temporal's Python SDK must be set up in the environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/signal_your_workflow/README.md#2025-04-23_snippet_2\n\nLANGUAGE: command\nCODE:\n```\n# terminal one\\npoetry run python your_worker.py\\n# terminal two\\npoetry run python signal_with_start_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Customizing Runtime Logger in Temporal TypeScript SDK\nDESCRIPTION: Example of how to customize the Runtime Logger in Temporal TypeScript SDK using DefaultLogger. This demonstrates registering a custom logger that processes log messages and configuring telemetry options for the underlying Core SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  DefaultLogger,\n  makeTelemetryFilterString,\n  Runtime,\n} from '@temporalio/worker';\n\n// This is your custom Logger.\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\n\nRuntime.install({\n  logger,\n  // The following block is optional, but generally desired.\n  // It allows capturing log messages emitted by the underlying Temporal Core SDK (native code).\n  // The Telemetry Filter String determine the desired verboseness of messages emitted by the\n  // Temporal Core SDK itself (\"core\"), and by other native libraries (\"other\").\n  telemetryOptions: {\n    logging: {\n      filter: makeTelemetryFilterString({ core: 'INFO', other: 'INFO' }),\n      forward: {},\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Workflow Outbound Interceptor for Activity Logging in TypeScript\nDESCRIPTION: This snippet defines an `ActivityLogInterceptor` class that implements `WorkflowOutboundCallsInterceptor`. It intercepts the `scheduleActivity` call from a Workflow to log messages before the Activity starts and after it completes. The interceptor takes the `workflowType` in its constructor for contextual logging.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/interceptors.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  ActivityInput,\n  Next,\n  WorkflowOutboundCallsInterceptor,\n} from '@temporalio/workflow';\n\nexport class ActivityLogInterceptor\n  implements WorkflowOutboundCallsInterceptor\n{\n  constructor(public readonly workflowType: string) {}\n\n  async scheduleActivity(\n    input: ActivityInput,\n    next: Next<WorkflowOutboundCallsInterceptor, 'scheduleActivity'>,\n  ): Promise<unknown> {\n    console.log('Starting activity', { activityType: input.activityType });\n    try {\n      return await next(input);\n    } finally {\n      console.log('Completed activity', {\n        workflow: this.workflowType,\n        activityType: input.activityType,\n      });\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Wait Condition in Update Handler\nDESCRIPTION: Implementation of a wait condition within an Update handler to ensure specific conditions are met before proceeding.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@workflow.update\nasync def my_update(self, update_input: UpdateInput) -> str:\n    await workflow.wait_condition(\n        lambda: self.ready_for_update_to_execute(update_input)\n    )\n```\n\n----------------------------------------\n\nTITLE: Deleting a Scheduled Workflow with Temporal Python SDK\nDESCRIPTION: Shows the process of deleting an existing Workflow Schedule via the Temporal Python SDK. The code asynchronously connects to the Temporal server, retrieves a schedule handle by schedule ID, and calls the delete() method to remove it. This operation does not affect already started Workflows. Requires the Temporal Python SDK and an active server. Inputs: Schedule ID. Output: Schedule is deleted from the server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n    handle = client.get_schedule_handle(\\n        \"workflow-schedule-id\",\\n    )\\n\\n    await handle.delete()\n```\n\n----------------------------------------\n\nTITLE: Setting StartToCloseTimeout in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Illustrates how to configure the `StartToCloseTimeout`, a required field (if `ScheduleToCloseTimeout` is not set), defining the maximum duration for Activity execution after it starts. The snippet uses ActivityOptions with only this field set, applied to the context and used in Activity execution with error checking. Assumes dependencies on the Go Temporal workflow SDK and valid types for activity and results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  StartToCloseTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal from a Temporal Client in Python\nDESCRIPTION: This snippet demonstrates how a Temporal Client sends a Signal to a running Workflow Execution using the `WorkflowHandle.signal` method. The call returns immediately after the server accepts the Signal, without waiting for the Workflow to process it. An `ApproveInput` object containing the signal payload is passed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n```python\nawait workflow_handle.signal(GreetingWorkflow.approve, ApproveInput(name=\"me\"))\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Workflow Interface (PHP)\nDESCRIPTION: This code shows a Workflow interface (YourWorkflowDefinitionInterface) definition in PHP using Temporal SDK. The #[WorkflowInterface] attribute designates the interface, and the processFile method, marked with #[WorkflowMethod], serves as the entrypoint. Arguments are serializable; naming conventions follow Temporal's default behavior unless overridden.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface YourWorkflowDefinitionInterface\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Schedules for Workflows in Go\nDESCRIPTION: This snippet shows how to list all Schedules for Workflows using the Go SDK. It uses the ScheduleClient.List() method to return information on all available Schedules and their respective Schedule IDs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tlistView, _ := temporalClient.ScheduleClient().List(ctx, client.ScheduleListOptions{\n\t\tPageSize: 1,\n\t})\n\n\tfor listView.HasNext() {\n\t\tlog.Println(listView.Next())\n\t}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowIDReusePolicy in Go\nDESCRIPTION: This snippet demonstrates configuring the Workflow ID reuse policy in Go. It sets the `WorkflowIdReusePolicy` field in `client.StartWorkflowOptions` using a value from `go.temporal.io/api/enums/v1`, such as `enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE`. This policy determines whether a Workflow Execution can start if another closed Workflow with the same ID already exists.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowIdReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting a Workflow Task Queue using Temporal Python SDK\nDESCRIPTION: This snippet demonstrates how to execute a Temporal Workflow and specify its Task Queue using the `task_queue` parameter within the `client.execute_workflow` method. It requires an active Temporal Client connected to the cluster and the `asyncio` library for running the asynchronous code. The Task Queue name routes the Workflow Task to the correct Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/temporal-clients.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n\n    result = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your name\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n    )\n\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Getting an Async Activity Handle in C#\nDESCRIPTION: Demonstrates how to get an asynchronous Activity handle using the GetAsyncActivityHandle method with a captured Task Token.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/asynchronous-activity.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar handle = myClient.GetAsyncActivityHandle(capturedToken);\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Timeouts in Go SDK\nDESCRIPTION: This snippet demonstrates how to set Workflow timeouts using StartWorkflowOptions. It shows how to configure WorkflowExecutionTimeout to control the maximum duration of a Workflow Execution. Other available timeout options include WorkflowRunTimeout and WorkflowTaskTimeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  // Set Workflow Timeout duration\n  WorkflowExecutionTimeout: 24 * 365 * 10 * time.Hour,\n  // WorkflowRunTimeout: 24 * 365 * 10 * time.Hour,\n  // WorkflowTaskTimeout: 10 * time.Second,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Describing a Schedule in Java\nDESCRIPTION: This code demonstrates how to describe a Schedule using the describe() method on the ScheduleHandle. It provides detailed information about the current Schedule configuration, including past, current, and future Workflow Runs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\nScheduleDescription description = handle.describe();\n```\n\n----------------------------------------\n\nTITLE: Sending an External Signal from a Workflow in Java\nDESCRIPTION: Demonstrates how one Workflow can send a Signal (an External Signal) to another Workflow Execution. It uses `Workflow.newExternalWorkflowStub` within the sending Workflow's code to create a stub for the target Workflow (`OtherWorkflow`) and then calls the target's Signal method (`mySignalMethod`) on that stub. This generates events in both sender and recipient histories.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nOtherWorkflow other = Workflow.newExternalWorkflowStub(OtherWorkflow.class, otherWorkflowID);\nother.mySignalMethod();\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Heartbeat Timeout in Temporal TypeScript SDK\nDESCRIPTION: This snippet demonstrates how to set a Heartbeat Timeout for an Activity using the ActivityOptions.heartbeatTimeout property. If the Temporal Server doesn't receive a heartbeat before this timeout expires, the Activity is considered timed out and may be retried.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { myLongRunningActivity } = proxyActivities<typeof activities>({\n  // ...\n  heartbeatTimeout: '30s',\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Elasticsearch for Primary and Secondary Visibility Stores\nDESCRIPTION: Bash script showing the environment variables needed to set up Elasticsearch for both primary and secondary Visibility stores. This includes defining both primary and secondary index names.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# Elasticsearch\n: \"${ENABLE_ES:=false}\"\n: \"${ES_SCHEME:=http}\"\n: \"${ES_SEEDS:=}\"\n: \"${ES_PORT:=9200}\"\n: \"${ES_USER:=}\"\n: \"${ES_PWD:=}\"\n: \"${ES_VERSION:=v7}\"\n: \"${ES_VIS_INDEX:=temporal_visibility_v1_dev}\"\n: \"${ES_SEC_VIS_INDEX:=temporal_visibility_v1_new}\"\n: \"${ES_SCHEMA_SETUP_TIMEOUT_IN_SECONDS:=0}\"\n\n#...\n\n# Validate your ES environment\n#...\n# Wait for ES to start\n#...\n```\n\n----------------------------------------\n\nTITLE: Deterministic UUID Generation - Java\nDESCRIPTION: Demonstrates generating random UUIDs deterministically using Temporal's randomUUID() method, ensuring consistent UUID generation during Workflow replays.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/side-effects.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// implementation of the @WorkflowMethod\npublic void execute() {\n    String randomUUID = Workflow.randomUUID().toString();\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Durable Timer in .NET Workflow\nDESCRIPTION: Demonstrates how to pause a Workflow execution for a specified duration using Workflow.DelayAsync. This example shows a 3-day sleep period implementation that persists through system downtimes and remains resource-efficient.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/durable-timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Sleep for 3 days\nawait Workflow.DelayAsync(TimeSpan.FromDays(3));\n```\n\n----------------------------------------\n\nTITLE: Customizing Activity Execution Behavior in Go\nDESCRIPTION: An example of how to customize Activity Execution behavior in a Temporal Workflow using the Go SDK. This code sets custom timeout and retry policies for an Activity execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// LoanApplicationWorkflow is the Workflow Definition.\nfunc LoanApplicationWorkflow(ctx workflow.Context, applicantName string, loanAmount int) (string, error) {\n    // ...\n    var creditCheckResult string\n    // set a Retry Policy\n    ao := workflow.ActivityOptions{\n\t\tScheduleToCloseTimeout: time.Hour,\n\t\tHeartbeatTimeout:       time.Minute,\n\t\tRetryPolicy:            &temporal.RetryPolicy{\n\t\t\tInitialInterval:    time.Second,\n\t\t\tBackoffCoefficient: 2,\n\t\t\tMaximumInterval:    time.Minute,\n\t\t\tMaximumAttempts:    5,\n\t\t},\n\t}\n    ctx = workflow.WithActivityOptions(ctx, ao)\n    err = workflow.ExecuteActivity(ctx, LoanCreditCheckActivity, loanAmount).Get(ctx, &creditCheckResult)\n    if err != nil {\n        return \"\", err\n    }\n\t// ...\n    return notificationResult, nil\n}\n\n// LoanCreditCheckActivity is an Activity function that performs a credit check.\nfunc LoanCreditCheckActivity(ctx context.Context, loanAmount int) (string, error) {\n\t// ... your logic here ...\n\treturn \"Credit check passed\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an Update and Waiting for Completion in Java\nDESCRIPTION: Illustrates sending an Update to a Workflow Execution from client code using a typed `WorkflowStub`. The code calls the Update method (`setLanguage`) directly on the stub. This is a synchronous, blocking call that waits for the Update handler in the Workflow to complete and return a result (`previousLanguage`). Updates can modify Workflow state and add `WorkflowExecutionUpdateAccepted` and `WorkflowExecutionUpdateCompleted` events to the history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nLanguage previousLanguage = workflow.setLanguage(Language.CHINESE);\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Go SDK using API Key (pre v1.26.0)\nDESCRIPTION: Example of creating a Temporal client connection using an API key in Go SDK versions prior to 1.26.0. Includes creating a custom headers provider.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// Create headers provider\ntype APIKeyProvider struct {\n    APIKey string\n    Namespace string\n}\n\nfunc (a *APIKeyProvider) GetHeaders(context.Context) (map[string]string, error) {\n    return map[string]string{\"Authorization\": \"Bearer \" + a.APIKey, \"temporal-namespace\": a.Namespace}, nil\n}\n\n// Use headers provider\napiKeyProvider := &APIKeyProvider{APIKey: <APIKey>, Namespace: <namespace_id>.<account_id>}\nc, err := client.Dial(client.Options{\n    HostPort: <endpoint>,\n    Namespace: <namespace_id>.<account_id>,\n    HeadersProvider: apiKeyProvider,\n    ConnectionOptions: client.ConnectionOptions{TLS: &tls.Config{\n    }},\n})\n```\n\n----------------------------------------\n\nTITLE: Creating an API Key with Expiry Duration - tcld CLI - Bash\nDESCRIPTION: This example shows creation of an API Key with a set duration (e.g., 24 hours) before expiration, using the --duration flag. The duration is specified relative to the time of command execution, taking the format like '24h'. This flag is ignored if --expiry is also set. Requires the tcld CLI and API Key creation privileges.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey create --name <name> --duration 24h\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker with Protobuf Payload Converter - TypeScript\nDESCRIPTION: This async code configures a Temporal Worker using a custom payload converter path pointing to the protobuf-enabled converter file. It imports workflows and activities, sets the task queue, and ensures all payloads are encoded/decoded using the specified converter. Prerequisites are the setup of a payload converter as shown in previous steps and the existence of referenced modules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  activities,\n  taskQueue: 'protobufs',\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Maximum Sticky Cache Size with Prometheus\nDESCRIPTION: A PromQL query that retrieves the maximum value of the `temporal_sticky_cache_size` SDK metric over the last 10 minutes within a specific `$namespace`. This helps monitor if the sticky cache usage is approaching or exceeding the configured `WorkflowCacheSize`. Consistently high values near the configured limit might indicate potential performance issues or the need for configuration adjustments (increasing cache size or adding workers). Requires a `$namespace` variable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_10\n\nLANGUAGE: promql\nCODE:\n```\nmax_over_time(temporal_sticky_cache_size{namespace=\"$namespace\"}[10m])\n```\n\n----------------------------------------\n\nTITLE: Implementing Signal Handlers in .NET Workflow\nDESCRIPTION: Shows how to create a Signal handler in a Temporal .NET Workflow. Signals are asynchronous messages used to change Workflow state or control flow. The example demonstrates an async Signal handler that updates Workflow state.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowSignal]\npublic async Task ApproveAsync(ApproveInput input)\n{\n    approvedForRelease = true;\n    approverName = input.Name;\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an External Signal from a Temporal Workflow in Python\nDESCRIPTION: This snippet shows how a Workflow ('WorkflowB') can send a Signal to another Workflow ('WorkflowA'). It first obtains a handle to the target workflow using `workflow.get_external_workflow_handle_for` with the target Workflow's run method and ID, and then calls the `signal` method on that handle, passing the target signal method and arguments. This results in specific events being added to both the sender's and recipient's Event Histories.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n```python\n# ...\n@workflow.defn\nclass WorkflowB:\n    @workflow.run\n    async def run(self) -> None:\n        handle = workflow.get_external_workflow_handle_for(WorkflowA.run, \"workflow-a\")\n        await handle.signal(WorkflowA.your_signal, \"signal argument\")\n```\n```\n\n----------------------------------------\n\nTITLE: Calling a Dynamic Workflow Implementation in Java\nDESCRIPTION: This example shows how to call a Dynamic Workflow implementation using an untyped WorkflowStub. It creates a WorkflowClient and sets up the stub with the dynamic Workflow type and options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nWorkflowClient client = WorkflowClient.newInstance(service);\n/**\n  * Note that for this part of the client code, the dynamic Workflow implementation must\n  * be known to the Worker at runtime in order to dispatch Workflow tasks, and may be defined\n  * in the Worker definition as:*/\n// worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n/* Create the Workflow stub to call the dynamic Workflow.\n* Note that the Workflow Type is not explicitly registered with the Worker.*/\nWorkflowOptions workflowOptions =\n    WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\nWorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n```\n\n----------------------------------------\n\nTITLE: Starting Dynamic Query Worker (Bash/Python)\nDESCRIPTION: Executes the Python script `your_worker_query_dacx.py` using `poetry run`. This script starts a Temporal Worker configured to listen for tasks on the `dynamic-query-task-queue` and handle dynamic queries (query requests for which no specific query handler is registered).\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python your_worker_query_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Sleep Workflow in TypeScript\nDESCRIPTION: Simple Workflow implementation that demonstrates a sleep operation lasting one day.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sleep } from '@temporalio/workflow';\n\nexport async function sleeperWorkflow() {\n  await sleep('1 day');\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud with TLS in .NET\nDESCRIPTION: Shows how to establish a secure connection to Temporal Cloud using TLS certificates and necessary configuration options including namespace and endpoint settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/temporal-client.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"my-namespace.a1b2c.tmprl.cloud:7233\")\n{\n    Namespace = \"my-namespace.a1b2c\",\n    Tls = new()\n    {\n        ClientCert = await File.ReadAllBytesAsync(\"my-cert.pem\"),\n        ClientPrivateKey = await File.ReadAllBytesAsync(\"my-key.pem\"),\n    },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Update Handler Method in Temporal PHP\nDESCRIPTION: Provides the basic syntax for declaring an Update handler method `myUpdate` within a PHP class or interface using the `#[UpdateMethod]` attribute. This attribute signifies that the method is intended to handle incoming Update requests, which, unlike Queries, are allowed to mutate the Workflow's state. The method accepts a string argument `$value`. Requires the `Temporal\\Workflow\\UpdateMethod` attribute.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: php\nCODE:\n```\n#[UpdateMethod]\npublic function myUpdate(string $value);\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity Heartbeat in .NET\nDESCRIPTION: Demonstrates implementing Activity heartbeat mechanism using ActivityExecutionContext to monitor Activity progress and handle cancellation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[Activity]\npublic async Task MyActivityAsync()\n{\n    while (true)\n    {\n        // Send heartbeat\n        ActivityExecutionContext.Current.Heartbeat();\n\n        // Do some work, passing the cancellation token\n        await Task.Delay(1000, ActivityExecutionContext.Current.CancellationToken);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Event History - Temporal Go SDK - Go\nDESCRIPTION: This Go snippet defines a function to retrieve the full Event History of a Workflow Execution using the Temporal Go SDK. It uses the client.Client's GetWorkflowHistory method and iterates through all retrieved events, accumulating them in a history.History structure. Requires the go.temporal.io/sdk/client and go.temporal.io/api packages. Inputs include context, client, workflow id, and run id; output is a pointer to a history.History or an error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/api/enums/v1\"\n\t\"go.temporal.io/api/history/v1\"\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {\n\tvar hist history.History\n\titer := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)\n\tfor iter.HasNext() {\n\t\tevent, err := iter.Next()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\thist.Events = append(hist.Events, event)\n\t}\n\treturn &hist, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Handling External Workflow Cancellation During Activity Execution in TypeScript\nDESCRIPTION: This Workflow demonstrates handling an external cancellation request while an Activity (`httpPostJSON`) is running. It attempts to execute the activity within the default root scope. If a cancellation occurs (detected using `isCancellation(err)`), it logs a message and then executes a cleanup Activity (`cleanup`) within a `CancellationScope.nonCancellable` block. This ensures the cleanup logic runs even though the parent scope (the Workflow's root scope) has been cancelled.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function handleExternalWorkflowCancellationWhileActivityRunning(\n  url: string,\n  data: any,\n): Promise<void> {\n  try {\n    await httpPostJSON(url, data);\n  } catch (err) {\n    if (isCancellation(err)) {\n      console.log('Workflow cancelled');\n      // Cleanup logic must be in a nonCancellable scope\n      // If we'd run cleanup outside of a nonCancellable scope it would've been cancelled\n      // before being started because the Workflow's root scope is cancelled.\n      await CancellationScope.nonCancellable(() => cleanup(url));\n    }\n    throw err; // <-- Fail the Workflow\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Inheritable Workflow Interfaces in Java\nDESCRIPTION: Shows how to create reusable Workflow interface components using inheritance, including Signal and Query methods.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic interface Retryable {\n    @SignalMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface FileProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name=\"history\")\n    List<String> getHistory();\n\n    @QueryMethod\n    String getStatus();\n\n    @SignalMethod\n    void abandon();\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Temporal Sync Match Rate Directly - PromQL\nDESCRIPTION: This formula computes the Sync Match Rate by dividing the count of successfully sync-matched task polls (immediately delivered) by the total poll success count in Temporal Cloud. It requires both 'temporal_cloud_v0_poll_success_sync_count' and 'temporal_cloud_v0_poll_success_count' metrics to be present. The result, N, represents the proportion of tasks matched without persistence, a key health metric. Inputs: two metric timeseries. Output: ratio value (float). Useful for quick dashboard calculations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_4\n\nLANGUAGE: promql\nCODE:\n```\ntemporal_cloud_v0_poll_success_sync_count \\u00F7 temporal_cloud_v0_poll_success_count = N\n```\n\n----------------------------------------\n\nTITLE: Adding Search Attributes with Resource Version in Temporal Cloud CLI\nDESCRIPTION: Command to add custom search attributes using a specific resource version (ETag) to ensure the operation is based on the correct version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes add \\\n    --resource-version <etag> \\\n    --search-attribute <value>\n```\n\n----------------------------------------\n\nTITLE: Calculating Average Replication Lag in PromQL\nDESCRIPTION: This PromQL query calculates the average replication lag for Temporal Cloud High Availability Namespaces. It divides the rate of the sum of replication lag values by the rate of the count of replication events over a dynamic interval (`$__rate_interval`), grouped by Temporal Namespace. This provides a general measure of the typical replication delay.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/monitor.mdx#2025-04-23_snippet_1\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(temporal_cloud_v0_replication_lag_sum[$__rate_interval])) by (temporal_namespace)\n/\nsum(rate(temporal_cloud_v0_replication_lag_count[$__rate_interval])) by (temporal_namespace)\n```\n\n----------------------------------------\n\nTITLE: Getting an Asynchronous Activity Handle in Python\nDESCRIPTION: This snippet illustrates how to obtain a handle to an asynchronously completing Activity from an external process using the Temporal Client. It uses the `get_async_activity_handle()` method on a client instance (`my_client`), passing the previously captured `task_token` to identify the specific Activity Execution. This handle is required to interact with (e.g., complete, fail, heartbeat) the Activity externally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/asynchronous-activity-completion.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nhandle = my_client.get_async_activity_handle(task_token=captured_token)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Caller Workflow for Asynchronous Nexus Operation in Java\nDESCRIPTION: Shows how to implement a Temporal Workflow (`HelloCallerWorkflowImpl`) that invokes a Nexus operation asynchronously using `Workflow.startNexusOperation`. It creates a `NexusService` stub similar to the synchronous example. The `hello` method initiates the `nexusService.hello` operation, receiving a `NexusOperationHandle`. It then waits for the operation execution to be acknowledged (`handle.getExecution().get()`) and finally retrieves and returns the result (`handle.getResult().get().getMessage()`). Requires the Temporal Java SDK and the `NexusService` interface definition.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\npackage io.temporal.samples.nexus.caller;\n\nimport io.temporal.samples.nexus.service.NexusService;\nimport io.temporal.workflow.NexusOperationHandle;\nimport io.temporal.workflow.NexusOperationOptions;\nimport io.temporal.workflow.NexusServiceOptions;\nimport io.temporal.workflow.Workflow;\nimport java.time.Duration;\n\npublic class HelloCallerWorkflowImpl implements HelloCallerWorkflow {\n  NexusService nexusService =\n      Workflow.newNexusServiceStub(\n          NexusService.class,\n          NexusServiceOptions.newBuilder()\n              .setOperationOptions(\n                  NexusOperationOptions.newBuilder()\n                      .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n                      .build())\n              .build());\n\n  @Override\n  public String hello(String message, NexusService.Language language) {\n    NexusOperationHandle<NexusService.HelloOutput> handle =\n        Workflow.startNexusOperation(\n            nexusService::hello, new NexusService.HelloInput(message, language));\n    // Optionally wait for the operation to be started. NexusOperationExecution will contain the\n    // operation token in case this operation is asynchronous.\n    handle.getExecution().get();\n    return handle.getResult().get().getMessage();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TaskQueueName with ActivityOptions in Temporal Go SDK - Go\nDESCRIPTION: This snippet illustrates how to set the `TaskQueueName` property when constructing `ActivityOptions` for an Activity in the Temporal Go SDK. It specifies which Task Queue the Activity should be routed to, overriding the default inherited from the Workflow. Required dependencies include `go.temporal.io/sdk/workflow` and a valid workflow context. The Activity will be executed against the defined Task Queue, and standard error handling is applied after execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  TaskQueueName: \"your-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace with Temporal CLI\nDESCRIPTION: Deletes a specified namespace from the Temporal system using the CLI command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace delete <namespace>\n```\n\n----------------------------------------\n\nTITLE: Ensuring Handler Completion Before Workflow Ends in C# Temporal\nDESCRIPTION: This snippet shows how to use Workflow.WaitConditionAsync with Workflow.AllHandlersFinished to ensure all async handlers complete before the Workflow finishes. This prevents premature Workflow completion that could interrupt handlers and cause client errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task<string> RunAsync()\n    {\n        // ...\n        await Workflow.WaitConditionAsync(() => Workflow.AllHandlersFinished);\n        return \"workflow-result\";\n    }\n\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Side Effect in PHP Workflow\nDESCRIPTION: This snippet demonstrates how to use Workflow::sideEffect() to generate a random number in a Workflow. The Side Effect is used to execute non-deterministic code without compromising the Workflow's determinism.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/side-effects.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\n#[Workflow\\WorkflowMethod]\npublic function run()\n{\n    $random = yield Workflow::sideEffect(fn() => random_int(0, 100));\n    if ($random < 50) {\n        // ...\n    } else {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Query to a Workflow in Java\nDESCRIPTION: Shows how to send a Query to a running or completed Workflow Execution using a typed `WorkflowStub`. The code calls the `getLanguages` method (defined in the `GreetingWorkflow` interface) on the stub, passing necessary arguments. Queries do not alter Workflow state or Event History and require an active Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nList<Language> languages = workflow.getLanguages(new GetLanguagesInput(false));\nSystem.out.println(\"Supported languages: \" + languages);\n```\n\n----------------------------------------\n\nTITLE: Configuring API Key for Temporal Cloud Connection in PHP\nDESCRIPTION: This code snippet shows how to provide an API key to RoadRunner when connecting to Temporal Cloud. It uses the ServiceCredentials DTO to configure authentication when creating the WorkerFactory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_15\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Worker\\ServiceCredentials;\n\n$workerFactory = \\Temporal\\WorkerFactory::create(\n    credentials: ServiceCredentials::create()->withApiKey('your-api-key'),\n);\n```\n\n----------------------------------------\n\nTITLE: Querying a Workflow in Temporal TypeScript\nDESCRIPTION: Example of sending a Query to a Workflow Execution using the WorkflowHandle.query method. This demonstrates how to pass parameters to the query and receive the result without adding events to the Workflow's Event History.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst supportedLanguages = await handle.query(getLanguages, {\n  includeUnsupported: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Options in Temporal PHP\nDESCRIPTION: This snippet demonstrates how to configure additional WorkerOptions using the Temporal\\Worker\\WorkerOptions class. It shows how to set options like the maximum number of concurrent workflow task pollers when creating a new worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_13\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Worker\\WorkerOptions;\n\n$worker = $factory->newWorker(\n    'your-task-queue',\n    WorkerOptions::new()\n        ->withMaxConcurrentWorkflowTaskPollers(10)\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Runtime with Prometheus Metrics in Python\nDESCRIPTION: Demonstrates how to create a Temporal Runtime configured to expose Prometheus metrics on a specific address (0.0.0.0:9000). This custom runtime must be created before any other Temporal code (like Client connection) to avoid the default runtime being used, and is then passed during Client connection. Metrics configuration is global.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.runtime import Runtime, TelemetryConfig, PrometheusConfig\n\n# Create a new runtime that has telemetry enabled. Create this first to avoid\n# the default Runtime from being lazily created.\nnew_runtime = Runtime(telemetry=TelemetryConfig(metrics=PrometheusConfig(bind_address=\"0.0.0.0:9000\")))\nmy_client = await Client.connect(\"my.temporal.host:7233\", runtime=new_runtime)\n```\n\n----------------------------------------\n\nTITLE: Continuing Same Workflow Execution in Java\nDESCRIPTION: This snippet shows how to continue the execution of the same Workflow that is currently running using the Workflow.continueAsNew() method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nWorkflow.continueAsNew(input1, ...);\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start in Temporal TypeScript\nDESCRIPTION: Example demonstrating how to use Signal-With-Start to send a Signal to a Workflow Execution while starting it if it's not already running. This can only be used from a Client, not from within a Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from '@temporalio/client';\nimport { joinSignal, yourWorkflow } from './workflows';\n\nconst client = new Client();\n\nawait client.workflow.signalWithStart(yourWorkflow, {\n  workflowId: 'workflow-id-123',\n  taskQueue: 'my-taskqueue',\n  args: [{ foo: 1 }],\n  signal: joinSignal,\n  signalArgs: [{ userId: 'user-1', groupId: 'group-1' }],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack with Terser to Preserve Function Names\nDESCRIPTION: Configuration for webpack.config.js to prevent function name stripping in production builds. This ensures that Workflow Type names are preserved when using the Temporal Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          keep_fnames: true, // don't strip function names in production\n        },\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Elasticsearch as Visibility Store in Temporal Service YAML\nDESCRIPTION: Example YAML configuration for setting up Elasticsearch as the Visibility store in Temporal Service. This shows how to define the Visibility store name and configure connection details for Elasticsearch v7.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  ...\n  visibilityStore: es-visibility\n  datastores:\n    ...\n    es-visibility: # Define the Elasticsearch datastore connection information under the `es-visibility` key\n      elasticsearch:\n        version: \"v7\"\n        url:\n          scheme: \"http\"\n          host: \"127.0.0.1:9200\"\n        indices:\n          visibility: temporal_visibility_v1_dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Stub with Workflow ID - Temporal PHP\nDESCRIPTION: Demonstrates setting a specific Workflow ID for a Workflow Execution by configuring WorkflowOptions on stub creation. This helps map Workflow Executions to business entities for tracking purposes. Dependencies are a WorkflowClient, the Workflow interface, and a unique Workflow ID string assigned via withWorkflowId().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_12\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newWorkflowStub(\\n    YourWorkflowInterface::class,\\n    WorkflowOptions::new()\\n        ->withWorkflowId(\\\"Workflow-Id\\\"),\\n);\\n\n```\n\n----------------------------------------\n\nTITLE: Marking an Activity for Asynchronous Completion in C#\nDESCRIPTION: Shows how to capture the Task Token and throw a CompleteAsyncException to indicate that an Activity will be completed asynchronously.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/asynchronous-activity.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Capture token for later completion\ncapturedToken = ActivityExecutionContext.Current.Info.TaskToken;\n\n// Throw special exception that says an activity will be completed somewhere else\nthrow new CompleteAsyncException();\n```\n\n----------------------------------------\n\nTITLE: Defining a Dynamic Workflow with Temporal Python SDK\nDESCRIPTION: This snippet implements a dynamic Workflow class by setting dynamic=True in the @workflow.defn decorator, allowing it to serve as a fallback handler for unknown Workflow Execution requests. The main run method expects a single argument, a sequence of RawValue objects, and demonstrates how to extract string values using the payload_converter from the workflow context. Dependencies include the Temporal Python SDK, proper registration with a Worker, and the existence of the referenced Activity function default_greeting and YourDataClass. The Workflow method returns the result of an Activity execution, showing required argument parsing and invocation mechanics, expecting one raw argument (the name), and returning its Activity result as a string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@workflow.defn(dynamic=True)\\nclass DynamicWorkflow:\\n    @workflow.run\\n    async def run(self, args: Sequence[RawValue]) -> str:\\n        name = workflow.payload_converter().from_payload(args[0].payload, str)\\n        return await workflow.execute_activity(\\n            default_greeting,\\n            YourDataClass(\"Hello\", name),\\n            start_to_close_timeout=timedelta(seconds=10),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Starting a New Workflow Execution Using Temporal CLI (shell)\nDESCRIPTION: Shows the syntax for starting a new Workflow Execution with the Temporal CLI using the 'temporal workflow start' command. The example specifies the task queue and workflow type, demonstrating how to launch a workflow with user-defined parameters. Requires a correctly configured Temporal CLI, access to the Temporal cluster, and relevant flags (such as --task-queue and --type) to identify the workflow and control its execution parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow start --task-queue=MyTaskQueue --type=MyWorkflow\n```\n\n----------------------------------------\n\nTITLE: Specifying Activity Return Values in TypeScript\nDESCRIPTION: Demonstrates how to define the return type of a Temporal Activity in TypeScript. The `greet` function explicitly returns a `Promise<string>`, which is required for async Activity functions in the Temporal TypeScript SDK, as all data returned must be serializable and is recorded in the Workflow Execution Event History.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting an API Key - tcld CLI - Bash\nDESCRIPTION: This command deletes an API Key specified by its --id parameter. It requires the user to have delete permissions and authenticated access via the tcld CLI. Optionally, --resource-version and --request-id can be included to specify the etag/version being deleted and to track the request operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey delete --id <apikey_id>\n```\n\n----------------------------------------\n\nTITLE: Replaying Workflow History from JSON in Temporal .NET SDK (C#)\nDESCRIPTION: This C# function demonstrates how to replay a single Workflow history provided as a JSON string using the Temporal .NET SDK. It initializes a `WorkflowReplayer` with the target Workflow type (`MyWorkflow`) and uses `WorkflowHistory.FromJson` to parse the input JSON before calling `ReplayWorkflowAsync`. A `NonDeterminismException` (or similar) is thrown if the replay fails due to non-deterministic code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing Temporalio;\nusing Temporalio.Worker;\n\npublic static async Task ReplayFromJsonAsync(string historyJson)\n{\n    var replayer = new WorkflowReplayer(\n        new WorkflowReplayerOptions().AddWorkflow<MyWorkflow>());\n    await replayer.ReplayWorkflowAsync(WorkflowHistory.FromJson(\"my-workflow-id\", historyJson));\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate using tcld (Shell)\nDESCRIPTION: Uses the `tcld gen leaf` command to generate a new end-entity (leaf) certificate (`client.pem`) and its private key (`client.key`). The certificate is signed using the previously generated CA certificate (`ca.pem`) and key (`ca.key`). It's set for the organization 'temporal' with a duration of 364 days, ensuring it expires before the CA. The resulting `client.pem` and `client.key` are used to configure the Temporal client.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntcld gen leaf --org temporal -d 364d --ca-cert ca.pem --ca-key ca.key --cert client.pem --key client.key\n```\n\n----------------------------------------\n\nTITLE: Upserting Search Attributes in Temporal .NET SDK Workflow\nDESCRIPTION: This snippet shows how to upsert Search Attributes within Workflow code using the Temporal .NET SDK. It uses the UpsertTypedSearchAttributes() method with a set of updates, demonstrating how to add, update, and remove Search Attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// These only need to be created once, so it is common to make them static readonly even though we\n// create inline here for demonstration\nvar myKeywordAttributeKey = SearchAttributeKey.CreateKeyword(\"MyKeywordAttribute\");\nvar myTextAttributeKey = SearchAttributeKey.CreateText(\"MyTextAttribute\");\n\n// Add/Update the keyword one and remove the text one\nWorkflow.UpsertTypedSearchAttributes(\n    myKeywordAttributeKey.ValueSet(\"SomeKeywordValue\"),\n    myTextAttrbiuteKey.ValueUnset());\n```\n\n----------------------------------------\n\nTITLE: Customizing Workflow Type Names with WorkflowMethod Attribute (PHP)\nDESCRIPTION: This snippet illustrates how to customize the Workflow Type by passing a name to the #[WorkflowMethod] attribute in a PHP interface. Naming the Workflow Type explicitly overrides the default of using the interface name, helping with registration and invocation. If no name is given, it will default to the interface's name (e.g., YourWorkflowDefinitionInterface). The code maintains standard serialization requirements and annotation patterns.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowMethod(name)]\n```\n\n----------------------------------------\n\nTITLE: Adding Client CA Certificate with Resource Version\nDESCRIPTION: This command adds a client CA certificate with a specified resource version (ETag) to ensure updates are applied to the intended version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add \\\n    --resource-version <etag> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Configuring Versioning for Continue-As-New in Go\nDESCRIPTION: This snippet shows how to specify versioning intent when using the Continue-As-New feature in workflows. It uses the WithWorkflowVersioningIntent context modifier to set the versioning behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nctx = workflow.WithWorkflowVersioningIntent(ctx, temporal.VersioningIntentUseAssignmentRules)\nerr := workflow.NewContinueAsNewError(ctx, \"WorkflowName\")\n```\n\n----------------------------------------\n\nTITLE: Running the Workflow Test Suite in Go\nDESCRIPTION: Creates the main test function that runs the test suite, making it compatible with Go's testing framework.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc TestUnitTestSuite(t *testing.T) {\n        suite.Run(t, new(UnitTestSuite))\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions in .NET SDK\nDESCRIPTION: This snippet demonstrates how to list Workflow Executions using the ListWorkflowsAsync() method on the Client. It uses a List Filter to filter the listed Workflows and prints the ID of each workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nawait foreach (var wf in client.ListWorkflowsAsync(\"WorkflowType='GreetingWorkflow'\"))\n{\n    Console.WriteLine(\"Workflow: {0}\", wf.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Activity Heartbeats with Progress in PHP\nDESCRIPTION: This PHP code snippet shows how to implement Activity Heartbeats within a Temporal Activity method (`download`). It uses `Activity::heartbeat()` inside a progress callback to periodically report the download progress to the Temporal Server. A final heartbeat signals the completion of the download. This mechanism helps detect Activity failures quickly and allows checkpointing progress.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: php\nCODE:\n```\n```php\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting StartToCloseTimeout with WorkflowImplementationOptions in Java\nDESCRIPTION: This code shows how to set the StartToCloseTimeout using WorkflowImplementationOptions within a Worker. It sets the timeout for a specific Activity named 'EmailCustomerGreeting'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_27\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"EmailCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                            // Set Activity Execution timeout (single run)\n                                            .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                            .build()))\n                      .build();\n```\n\n----------------------------------------\n\nTITLE: Parsing EJSON-Serialized Workflow Arguments in Temporal Workflows using TypeScript\nDESCRIPTION: Defines a sample workflow that receives a User argument, processes its properties, and returns a computed result. Demonstrates compatibility with EJSON-serialized values, type imports, and typical TypeScript workflow export structure. No external dependencies except correct types imported. Parameters: user (User). Returns an object with detailed success status and timestamp. Ensures correct deserialization and runtime use of special types like Date and RegExp.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Result, User } from './types';\n\nexport async function example(user: User): Promise<Result> {\n  const success = user.createdAt.getTime() < Date.now()\n    && user.hp > 50\n    && user.matcher.test('Kaladin Stormblessed')\n    && user.token instanceof Uint8Array;\n  return { success, at: new Date() };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker for Testing in PHP\nDESCRIPTION: PHP code to create a Worker using WorkerFactory from the Temporal\\Testing namespace for testing purposes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Testing\\WorkerFactory;\n\n$factory = WorkerFactory::create();\n$worker = $factory->newWorker();\n\n$worker->registerWorkflowTypes(MyWorkflow::class);\n$worker->registerActivity(MyActivity::class);\n$factory->run();\n```\n\n----------------------------------------\n\nTITLE: Example: Querying Temporal Cloud Metrics via curl and jq\nDESCRIPTION: Provides a complete example of querying the Temporal Cloud Prometheus endpoint using `curl` with client certificate authentication (`--cert client.pem --key client-key.pem`). The output is piped to `jq` for formatting the JSON response, illustrating the structure of the metric data returned, including status, result type, and metric details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/general-setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ curl --cert client.pem --key client-key.pem \"https://<account-id>.tmprl.cloud/prometheus/api/v1/query?query=temporal_cloud_v0_state_transition_count\" | jq .\n{\n  \"status\": \"success\",\n  \"data\": {\n    \"resultType\": \"vector\",\n    \"result\": [\n      {\n        \"metric\": {\n          \"__name__\": \"temporal_cloud_v0_state_transition_count\",\n          \"__rollup__\": \"true\",\n          \"operation\": \"WorkflowContext\",\n          \"temporal_account\": \"your-account\",\n          \"temporal_namespace\": \"your-namespace.your-account-is\",\n          \"temporal_service_type\": \"history\"\n        },\n        \"value\": [\n          1672347471.2,\n          \"0\"\n        ]\n      },\n      ...\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Failovers with tcld CLI in Bash\nDESCRIPTION: This command uses the tcld CLI to disable automatic, Temporal-initiated failovers for a specified High Availability Namespace. It requires the `namespace_id` and `account_id`. Setting `--disable-auto-failover` to `true` disables the feature, while `false` re-enables it. If using API key authentication, the `--api-key` flag must be placed immediately after `tcld` and before the `namespace update-high-availability` subcommand.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/how-to/failovers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-high-availability \\\n    --namespace <namespace_id>.<account_id> \\\n    --disable-auto-failover=true\n```\n\n----------------------------------------\n\nTITLE: Querying Average Available Workflow Worker Task Slots with Prometheus\nDESCRIPTION: A PromQL query that calculates the average value of the `temporal_worker_task_slots_available` SDK metric for workers of type `WorkflowWorker` over the last 10 minutes within a specific `$namespace`. This helps identify if workers have sufficient concurrent execution capacity (`maxConcurrentWorkflowTaskExecutionSize`) or if they are consistently saturated (value near 0), indicating potential misconfiguration or task backlog. Requires a `$namespace` variable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_8\n\nLANGUAGE: promql\nCODE:\n```\navg_over_time(temporal_worker_task_slots_available{namespace=\"$namespace\",worker_type=\"WorkflowWorker\"}[10m])\n```\n\n----------------------------------------\n\nTITLE: Final Implementation with Removed Legacy Code\nDESCRIPTION: Updated implementation after all Workflows using the old version are completed, with legacy code removed while maintaining version checking.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic void processFile(Arguments args) {\n    String localName = null;\n    String processedName = null;\n    try {\n        localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n        processedName = activities.processFile(localName);\n        // getVersion call is left here to ensure that any attempt to replay history\n        // for a different version fails. It can be removed later when there is no possibility\n        // of this happening.\n        Workflow.getVersion(\"checksumAdded\", 1, 1);\n        long checksum = activities.calculateChecksum(processedName);\n        activities.uploadWithChecksum(\n            args.getTargetBucketName(), args.getTargetFilename(), processedName, checksum);\n    } finally {\n        if (localName != null) { // File was downloaded.\n            activities.deleteLocalFile(localName);\n        }\n        if (processedName != null) { // File was processed.\n            activities.deleteLocalFile(processedName);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Activity Failure Scenarios in Go\nDESCRIPTION: Demonstrates how to mock an Activity to return an error and verify that the Workflow handles the error correctly.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_ActivityFails() {\n        s.env.OnActivity(SimpleActivity, mock.Anything, mock.Anything).Return(\n          \"\", errors.New(\"SimpleActivityFailure\"))\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_failure\")\n\n        s.True(s.env.IsWorkflowCompleted())\n\n        err := s.env.GetWorkflowError()\n        s.Error(err)\n        var applicationErr *temporal.ApplicationError\n        s.True(errors.As(err, &applicationErr))\n        s.Equal(\"SimpleActivityFailure\", applicationErr.Error())\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Build ID and Enabling Worker Versioning in Java\nDESCRIPTION: This snippet demonstrates how to assign a Build ID to a Worker and enable Worker Versioning using WorkerOptions. It sets the Build ID and turns on versioning for the Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nWorkerOptions workerOptions = WorkerOptions.newBuilder()\n    .setBuildId(buildId)\n    .setUseBuildIdForVersioning(true)\n    // ...\n    .build();\nWorker w = workerFactory.newWorker(\"your_task_queue_name\", workerOptions);\n```\n\n----------------------------------------\n\nTITLE: Using UpdateWithStart in PHP Temporal SDK\nDESCRIPTION: Example showing how to use updateWithStart to add an item to a shopping cart Workflow, which either updates an existing Workflow or creates a new one if needed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: php\nCODE:\n```\n$stub = $workflowClient->newUntypedWorkflowStub(\n    ShoppingCartWorkflow::class,\n    WorkflowOptions::new()\n        ->withTaskQueue('service-queue')\n        ->withWorkflowId($cartId)\n        ->withWorkflowIdConflictPolicy(WorkflowIdConflictPolicy::UseExisting),\n);\n$handle = $workflowClient->updateWithStart(\n    workflow: $stub,\n    update: 'addItem',\n    updateArgs: [$itemId, $quantity],\n);\n\n$price = $handle->getResult();\n```\n\n----------------------------------------\n\nTITLE: Querying with Custom Search Attributes - Temporal CLI - shell\nDESCRIPTION: Shows how to use 'temporal workflow list' to filter workflows by a combination of default and custom Search Attributes in Temporal CLI. This functionality is available when advanced Visibility is enabled and, depending on Temporal Server version, may require Elasticsearch or a supported SQL database. The query combines WorkflowType, a custom attribute and its value, and time-based filters. Prerequisites include proper server configuration and indexed custom Search Attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/search-attributes.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --query \"WorkflowType = 'main.YourWorkflowDefinition' and YourCustomSA = 'YourCustomSAValue' and (StartTime > '2022-06-07T16:46:34.236-08:00' or CloseTime < '2022-06-08T16:46:34-08:00')\"\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowId using Temporal Java SDK\nDESCRIPTION: This Java snippet demonstrates how to configure a WorkflowId when building WorkflowOptions for a Temporal workflow stub. It illustrates the use of WorkflowOptions.Builder to assign a unique identifier for the workflow instance. Required dependencies include the Temporal Java SDK and the user-defined workflow and client classes. The key parameter is 'setWorkflowId', with the created stub being ready for workflow execution under that ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_11\n\nLANGUAGE: Java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\\nYourWorkflowInterface workflow1 =\\n    WorkerGreet.greetclient.newWorkflowStub(\\n        GreetWorkflowInterface.class,\\n        WorkflowOptions.newBuilder()\\n                // Set the Workflow Id\\n                .setWorkflowId(\\\"YourWF\\\")\\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Backfilling a Schedule in Java\nDESCRIPTION: This code shows how to backfill a Schedule using the backfill() method on the ScheduleHandle. It executes Actions ahead of their specified time range, which is useful for executing missed or delayed Actions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\n\nInstant now = Instant.now();\nhandle.backfill(\n    Arrays.asList(\n        new ScheduleBackfill(now.minusMillis(5500), now.minusMillis(2500)),\n        new ScheduleBackfill(now.minusMillis(2500), now)));\n```\n\n----------------------------------------\n\nTITLE: Completing an Asynchronous Activity in C#\nDESCRIPTION: Shows how to complete an asynchronous Activity by calling CompleteAsync on the Activity handle with a completion value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/asynchronous-activity.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nawait handle.CompleteAsync(\"Completion value.\");\n```\n\n----------------------------------------\n\nTITLE: Replaying Workflow Executions in PHP\nDESCRIPTION: PHP code demonstrating how to fetch and replay Workflow executions using WorkflowReplayer.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_6\n\nLANGUAGE: php\nCODE:\n```\n/**\n * We assume you already have a WorkflowClient and WorkflowReplayer in scope.\n * @var \\Temporal\\Client\\WorkflowClientInterface $workflowClient\n * @var \\Temporal\\Testing\\Replay\\WorkflowReplayer $replayer\n */\n\n// Find all workflow executions of type \"MyWorkflow\" and task queue \"MyTaskQueue\".\n$executions = $workflowClient->listWorkflowExecutions(\n    \"WorkflowType='MyWorkflow' AND TaskQueue='MyTaskQueue'\"\n);\n\n// Replay each workflow execution.\nforeach ($executions as $executionInfo) {\n    try {\n        $replayer->replayFromServer(\n            workflowType: $executionInfo->type->name,\n            execution: $executionInfo->execution,\n        );\n    } catch (\\Temporal\\Testing\\Replay\\Exception\\ReplayerException $e) {\n        // Handle a replay error.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for All Handlers to Finish Using Temporal Workflow Condition in TypeScript\nDESCRIPTION: Demonstrates how to use the Temporal.io Workflow API's condition helper to ensure that all async handlers complete before allowing a Workflow to finish. Depends on the Temporal TypeScript SDK with access to wf.condition and wf.allHandlersFinished. \"myWorkflow\" first suspends completion until all handlers resolve, then returns the final output. The output is the object 'workflowOutput', and the main constraint is that this should be used in workflows where asynchronous handlers may be unresolved at termination.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function myWorkflow(): Promise<MyWorkflowOutput> {\n  await wf.condition(wf.allHandlersFinished);\n  return workflowOutput;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Patched Method for Versioning in .NET Temporal Workflow\nDESCRIPTION: This snippet illustrates how to use the Patched method to implement versioning in a Temporal Workflow. It allows running both PrePatchActivity and PostPatchActivity code concurrently, enabling safe deployment of new versions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        if (Workflow.Patched(\"my-patch\"))\n        {\n            this.result = await Workflow.ExecuteActivityAsync(\n                (MyActivities a) => a.PostPatchActivity(),\n                new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n        }\n        else\n        {\n            this.result = await Workflow.ExecuteActivityAsync(\n                (MyActivities a) => a.PrePatchActivity(),\n                new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n        }\n\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentActivityTaskPollers for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of goroutines that will concurrently poll the Task Queue for Activity Tasks. Adjusting this affects the rate at which the Worker consumes Activity Tasks. The type is `int`, and the default value is `2`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_33\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    MaxConcurrentActivityTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Retry Policy with Temporal TypeScript SDK - TypeScript\nDESCRIPTION: This snippet illustrates how to set a Retry Policy for Workflow Executions in the Temporal TypeScript SDK. The retry property defines maximumAttempts and maximumInterval for workflow retries in case of failure. It requires the Temporal Client and the Workflow definition. Parameters such as maximumAttempts control retry count, maximumInterval sets the maximum delay between retries. Returns a handle to the started workflow. By default, workflows do not retry unless explicitly configured.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(example, {\n  taskQueue,\n  workflowId,\n  retry: {\n    maximumAttempts: 3,\n    maximumInterval: '30 seconds',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Nexus Service in Go Worker\nDESCRIPTION: This snippet shows how to register a Nexus Service in a Temporal Worker. It sets up the client, creates a worker, registers the Nexus service and operations, and runs the worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n\n\t\"github.com/nexus-rpc/sdk-go/nexus\"\n\t\"github.com/temporalio/samples-go/nexus/handler\"\n\t\"github.com/temporalio/samples-go/nexus/options\"\n\t\"github.com/temporalio/samples-go/nexus/service\"\n)\n\nconst (\n\ttaskQueue = \"my-handler-task-queue\"\n)\n\nfunc main() {\n\t// The client and worker are heavyweight objects that should be created once per process.\n\tclientOptions, err := options.ParseClientOptionFlags(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatalf(\"Invalid arguments: %v\", err)\n\t}\n\tc, err := client.Dial(clientOptions)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\n\tw := worker.New(c, taskQueue, worker.Options{})\n\tservice := nexus.NewService(service.HelloServiceName)\n\terr = service.Register(handler.EchoOperation, handler.HelloOperation)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to register operations\", err)\n\t}\n\tw.RegisterNexusService(service)\n\tw.RegisterWorkflow(handler.HelloHandlerWorkflow)\n\n\terr = w.Run(worker.InterruptCh())\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to start worker\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Query to a Workflow in C#\nDESCRIPTION: This code shows how to send a Query to a Workflow using the WorkflowHandle's QueryAsync method. Queries don't modify Workflow state and can be sent to closed Workflows within the retention period.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar supportedLanguages = await workflowHandle.QueryAsync(wf => wf.GetLanguages(new(false)));\n```\n\n----------------------------------------\n\nTITLE: Implementing a Time-Based Workflow in C#\nDESCRIPTION: This Workflow demonstrates the use of time-based operations in Temporal by waiting for a day using Workflow.DelayAsync before returning a result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class WaitADayWorkflow\n{\n    [WorkflowRun]\n    public async Task<string> RunAsync()\n    {\n        await Workflow.DelayAsync(TimeSpan.FromDays(1));\n        return \"all done\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Activities in PHP Workflow\nDESCRIPTION: Demonstrates how to perform parallel operations in a Workflow using Workflow::async. It shows two asynchronous functions that compose greetings and combine their results.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/asynchronous-activity-completion.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\npublic function greet(string $name): \\Generator\n{\n    // Workflow::async runs it's activities and child workflows in a separate coroutine. Use keyword yield to merge\n    // it back to parent process.\n\n    $first = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hello', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Bye', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    $second = Workflow::async(\n        function () use ($name) {\n            $hello = yield $this->greetingActivity->composeGreeting('Hola', $name);\n            $bye = yield $this->greetingActivity->composeGreeting('Chao', $name);\n\n            return $hello . '; ' . $bye;\n        }\n    );\n\n    // blocks until $first and $second complete\n    return (yield $first) . \"\\n\" . (yield $second);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Version Check for Activity Update in PHP\nDESCRIPTION: Demonstrates how to use Workflow::getVersion() to safely transition between pre-patch and post-patch activities. This allows for backward compatibility with running Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\nclass MyWorkflow\n{\n    // ...\n\n    #[WorkflowMethod]\n    public function runAsync()\n    {\n        $version = yield Workflow::getVersion('Step 1', Workflow::DEFAULT_VERSION, 1);\n\n        $result = $version === Workflow::DEFAULT_VERSION\n            ? yield $this->activity->prePatchActivity()\n            : yield $this->activity->postPatchActivity();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Client with Protobuf Payload Converter - TypeScript\nDESCRIPTION: This code snippet demonstrates creating a Temporal Client that uses a custom payload converter to support Protobuf. It initializes a workflow with protobuf arguments, sets a unique workflow ID, and fetches the result, ensuring all data passed to and from workflows is properly serialized with protobuf. Requires a proper payload converter file and setup as shown previously.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_19\n\nLANGUAGE: ts\nCODE:\n```\nimport { Client } from '@temporalio/client';\nimport { v4 as uuid } from 'uuid';\nimport { foo, ProtoResult } from '../protos/root';\nimport { example } from './workflows';\n\nasync function run() {\n  const client = new Client({\n    dataConverter: {\n      payloadConverterPath: require.resolve('./payload-converter'),\n    },\n  });\n\n  const handle = await client.workflow.start(example, {\n    args: [foo.bar.ProtoInput.create({ name: 'Proto', age: 2 })],\n    // can't do:\n    // args: [new foo.bar.ProtoInput({ name: 'Proto', age: 2 })],\n    taskQueue: 'protobufs',\n    workflowId: 'my-business-id-' + uuid(),\n  });\n\n  console.log(`Started workflow ${handle.workflowId}`);\n\n  const result: ProtoResult = await handle.result();\n  console.log(result.toJSON());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Unfinished Handler Policy\nDESCRIPTION: Example showing how to configure the unfinishedPolicy for Update methods to control what happens when a Workflow completes with unfinished handlers. The ABANDON policy silences warnings about unfinished handlers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_16\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface MyWorkflow {\n    ...\n    @UpdateMethod(unfinishedPolicy = HandlerUnfinishedPolicy.ABANDON)\n    void myUpdate();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Temporal Activity Function in TypeScript\nDESCRIPTION: Shows a simple TypeScript async function `greet` intended as a Temporal Activity. It accepts a `name` string parameter and returns a greeting `Promise<string>`, illustrating the fundamental structure and parameter definition for an Activity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nexport async function greet(name: string): Promise<string> {\n  return `👋 Hello, ${name}!`;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Metric Meter in .NET SDK\nDESCRIPTION: This example shows how to set a custom metric meter on the telemetry options to handle metrics programmatically. It uses the Temporalio.Extensions.DiagnosticSource extension to send all metrics to a System.Diagnostics.Metrics.Meter instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Diagnostics.Metrics;\nusing Temporalio.Client;\nusing Temporalio.Extensions.DiagnosticSource;\nusing Temporalio.Runtime;\n\n// Create .NET meter\nusing var meter = new Meter(\"My.Meter\");\n// Can create MeterListener or OTel meter provider here...\n\n// Create Temporal runtime with a custom metric meter for that meter\nvar runtime = new TemporalRuntime(new()\n{\n    Telemetry = new()\n    {\n        Metrics = new() { CustomMetricMeter = new CustomMetricMeter(meter) },\n    },\n});\nvar client = await Temporalio.ConnectAsync(new(\"localhost:7233\") { Runtime = runtime });\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate with Organization Unit using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying an optional organization unit name via the `--organization-unit` modifier. Replace `<value>` with the actual organization unit name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --organization-unit <value>\n```\n\n----------------------------------------\n\nTITLE: Terminating Workflows using Temporal CLI\nDESCRIPTION: This command terminates running workflows of a specific type using a query filter. It demonstrates how to use the 'workflow terminate' command with a List Filter to forcefully end Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow terminate \\\n  --query 'ExecutionStatus = \"Running\" AND WorkflowType=\"YourWorkflow\"' \\\n  --reason \"Testing\"\n```\n\n----------------------------------------\n\nTITLE: Terraform Namespace Creation Success Output\nDESCRIPTION: Example output shown in the terminal after `terraform apply` successfully creates a Temporal Cloud Namespace. It indicates the resource type, name, completion status, time taken, and the unique ID of the created Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntemporalcloud_namespace.terraform: Creation complete after 2m17s [id=<your-namespace>]\n```\n\n----------------------------------------\n\nTITLE: Defining Serializable Activity Return Values in Temporal (PHP)\nDESCRIPTION: These snippets show how to define an Activity class in PHP with methods returning either a primitive type or an object. The Activity interface must be implemented, and each method must return serializable values (the default serialization is JSON, customizable via DataConverter). All function parameters and return types are explicitly typed. Outputs must be compatible with the configured DataConverter implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: php\nCODE:\n```\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): string\n    {\n        return $greeting . ' ' . $name;\n    }\n}\n```\n\nLANGUAGE: php\nCODE:\n```\nclass GreetingActivity implements GreetingActivityInterface\n{\n    public function composeGreeting(string $greeting, string $name): Greeting\n    {\n        return new Greeting($greeting, $name);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Payload Codec with Temporal Client\nDESCRIPTION: Example showing how to configure a Temporal client to use a custom PayloadCodec for data encryption.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/converters-and-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar myClient = await TemporalClient.ConnectAsync(new(\"localhost:7233\")\n{\n    DataConverter = DataConverter.Default with { PayloadCodec = new EncryptionCodec() },\n});\n```\n\n----------------------------------------\n\nTITLE: GCP PSC Service Name for asia-south1\nDESCRIPTION: The Google Cloud Private Service Connect (PSC) Service Attachment Name required to connect to Temporal Cloud in the `asia-south1` region. Use this identifier when configuring your private endpoint.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/references/regions/private-service.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nprojects/prod-d5spc2sfeshws33bg33vwdef7/regions/asia-south1/serviceAttachments/pl-7w7tw\n```\n\n----------------------------------------\n\nTITLE: Inviting a User with Role and Namespace Permissions via tcld CLI - Command\nDESCRIPTION: Invites a new user to Temporal Cloud, assigning a specific account role and namespace permissions in a single command. --user-email, --account-role, and --namespace-permission are required; --request-id is optional for asynchronous tracking. Multiple --namespace-permission flags can assign permissions to different namespaces.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_4\n\nLANGUAGE: command\nCODE:\n```\ntcld user invite --user-email <test@example.com> --account-role developer --namespace-permission ns1=Admin --namespace-permission ns2=Write --request-id <123456>\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous Nexus Operation Handler in Java\nDESCRIPTION: Defines a Java class `NexusServiceImpl` annotated with `@ServiceImpl` to implement the `NexusService` interface. The `hello` method, annotated with `@OperationImpl`, returns an `OperationHandler` created using `WorkflowRunOperation.fromWorkflowMethod`. This handler is designed to start a `HelloHandlerWorkflow` instance when the Nexus operation is invoked, using the operation's request ID as the Workflow ID for idempotency and deduplication. Requires the Temporal Java SDK, a defined `NexusService` interface, and a corresponding `HelloHandlerWorkflow` definition.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n// To create a service implementation, annotate the class with @ServiceImpl and provide the\n// interface that the service implements. The service implementation class should have methods that\n// return OperationHandler that correspond to the operations defined in the service interface.\n@ServiceImpl(service = NexusService.class)\npublic class NexusServiceImpl {\n// ...\n  @OperationImpl\n  public OperationHandler<NexusService.HelloInput, NexusService.HelloOutput> hello() {\n    // Use the WorkflowRunOperation.fromWorkflowMethod constructor, which is the easiest\n    // way to expose a workflow as an operation.\n    return WorkflowRunOperation.fromWorkflowMethod(\n        (ctx, details, input) ->\n            Nexus.getOperationContext()\n                    .getWorkflowClient()\n                    .newWorkflowStub(\n                        HelloHandlerWorkflow.class,\n                        // Workflow IDs should typically be business meaningful IDs and are used to\n                        // dedupe workflow starts.\n                        // For this example, we're using the request ID allocated by Temporal when\n                        // the\n                        // caller workflow schedules\n                        // the operation, this ID is guaranteed to be stable across retries of this\n                        // operation.\n                        //\n                        // Task queue defaults to the task queue this operation is handled on.\n                        WorkflowOptions.newBuilder().setWorkflowId(details.getRequestId()).build())\n                ::hello);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initiating Temporal Update-With-Start Waiting for Acceptance (Java)\nDESCRIPTION: Demonstrates using the `WorkflowClient.startUpdateWithStart` method in Java to send an Update (`workflow::setLanguage` with `Language.ENGLISH`) to a Workflow. If the Workflow doesn't exist, it starts a new one (`workflow::getGreetings`). The call returns a `WorkflowUpdateHandle` once the Update reaches the specified stage (`WorkflowUpdateStage.ACCEPTED`). The result of the Update is then retrieved asynchronously.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: java\nCODE:\n```\n```java\nWorkflowUpdateHandle<Language> handle =\n    WorkflowClient.startUpdateWithStart(\n        workflow::setLanguage,\n        Language.ENGLISH,\n        UpdateOptions.<Language>newBuilder().setWaitForStage(WorkflowUpdateStage.ACCEPTED).build(),\n        new WithStartWorkflowOperation<>(workflow::getGreetings));\n\nLanguage previousLanguage = handle.getResultAsync().get();\n```\n```\n\n----------------------------------------\n\nTITLE: Final Code After All Older Versions Completed in Go\nDESCRIPTION: The final code after all Workflow executions for previous versions have completed, showing the preserved GetVersion call with identical min and max versions for safety.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n_ := workflow.GetVersion(ctx, \"Step1\", 2, 2)\nerr = workflow.ExecuteActivity(ctx, ActivityD, data).Get(ctx, &result1)\n```\n\n----------------------------------------\n\nTITLE: Deterministic Random Number Generation - Java\nDESCRIPTION: Shows how to generate random numbers deterministically using Temporal's built-in newRandom() method, which ensures consistency during Workflow replays.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/side-effects.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\n// implementation of the @WorkflowMethod\npublic void execute() {\n    int randomInt = Workflow.newRandom().nextInt();\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Backfilling a Schedule for a Workflow in Go\nDESCRIPTION: This code shows how to backfill a Schedule for a Workflow using the Go SDK. It uses the Backfill() method on ScheduleHandle to execute Workflow Tasks ahead of the scheduled time range.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\terr = scheduleHandle.Backfill(ctx, client.ScheduleBackfillOptions{\n\t\tBackfill: []client.ScheduleBackfill{\n\t\t\t{\n\t\t\t\tStart:   now.Add(-4 * time.Minute),\n\t\t\t\tEnd:     now.Add(-2 * time.Minute),\n\t\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t\t},\n\t\t\t{\n\t\t\t\tStart:   now.Add(-2 * time.Minute),\n\t\t\t\tEnd:     now,\n\t\t\t\tOverlap: enums.SCHEDULE_OVERLAP_POLICY_ALLOW_ALL,\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to Backfill Schedule\", err)\n\t}\n// ...\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: Registering Workflow and Activity Types in PHP\nDESCRIPTION: This snippet demonstrates how to register Workflow Types and Activity Types with a Worker. It shows the basic registration methods for both stateful Workflows and stateless Activities in a Temporal PHP application.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_16\n\nLANGUAGE: php\nCODE:\n```\n// Workflows are stateful. So you need a type to create instances:\n$worker->registerWorkflowTypes(App\\DemoWorkflow::class);\n// Activities are stateless and thread safe:\n$worker->registerActivity(App\\DemoActivity::class);\n```\n\n----------------------------------------\n\nTITLE: Initializing Default Token Key Provider for JWT ClaimMapper (Go)\nDESCRIPTION: This Go code sample illustrates how to instantiate the Temporal default TokenKeyProvider, used by the JWT ClaimMapper plugin to retrieve and refresh public keys for JWT validation. The function 'NewDefaultTokenKeyProvider' requires a configuration object and logger as parameters. Prerequisites are a properly constructed 'cfg' instance per Temporal authorization configuration, and an initialized logger implementation. The output is a provider instance compliant with JWKS specification, supporting key rotation without requiring service restarts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nprovider := authorization.NewDefaultTokenKeyProvider(cfg, logger)\n```\n\n----------------------------------------\n\nTITLE: Terraform Namespace Update Success Output\nDESCRIPTION: Example output shown in the terminal after `terraform apply` successfully updates a Temporal Cloud Namespace. It confirms the modification, indicates the time taken, and shows the Namespace ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\ntemporalcloud_namespace.namespace: Modifications complete after 10s [id=terraform.a1bb2]\n```\n\n----------------------------------------\n\nTITLE: Specifying Details for tctl Activity Failure (Bash)\nDESCRIPTION: This command shows how to provide detailed information when failing a Temporal Activity Execution using the deprecated `tctl` tool via the `--detail` modifier. Replace `<value>` with the detailed description of the failure. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity fail --detail <value>\n```\n\n----------------------------------------\n\nTITLE: Accessing API Key Token Securely\nDESCRIPTION: Bash command to securely access the sensitive API Key token from Terraform output. This command outputs the token value in JSON format.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nterraform output -json apikey_token\n```\n\n----------------------------------------\n\nTITLE: Implementing GetVersion for First Activity Change in Go\nDESCRIPTION: Implementation of the workflow.GetVersion() pattern to handle the first change (replacing ActivityA with ActivityC) while maintaining backward compatibility with ongoing Workflow executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nvar err error\nv := workflow.GetVersion(ctx, \"Step1\", workflow.DefaultVersion, 1)\nif v == workflow.DefaultVersion {\n        err = workflow.ExecuteActivity(ctx, ActivityA, data).Get(ctx, &result1)\n} else {\n        err = workflow.ExecuteActivity(ctx, ActivityC, data).Get(ctx, &result1)\n}\nif err != nil {\n        return \"\", err\n}\n\nvar result2 string\nerr = workflow.ExecuteActivity(ctx, ActivityB, result1).Get(ctx, &result2)\nreturn result2, err\n```\n\n----------------------------------------\n\nTITLE: Configuring Update Handler Unfinished Policy in Go\nDESCRIPTION: Example of configuring the unfinished policy for an Update handler using UpdateHandlerOptions. This silences warnings when a Workflow finishes with unfinished Update handler executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nerr = workflow.SetUpdateHandlerWithOptions(ctx, UpdateHandlerName, UpdateFunc, workflow.UpdateHandlerOptions{\n       UnfinishedPolicy: workflow.HandlerUnfinishedPolicyAbandon,\n})\n```\n\n----------------------------------------\n\nTITLE: Listing Schedules in Java\nDESCRIPTION: This snippet shows how to list all available Schedules using the listSchedules() asynchronous method on the ScheduleClient. It returns a stream of ScheduleListDescription objects.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nStream<ScheduleListDescription> scheduleStream = client.listSchedules();\n```\n\n----------------------------------------\n\nTITLE: Calculating Average Latency and Histogram Quantile with Prometheus (PromQL)\nDESCRIPTION: This composite snippet contains two PromQL queries for Temporal Cloud latency analysis. The first expression calculates average latency by dividing the sum of observed latencies by the count, using the `rate()` function for time windowing. The second expression estimates the 99th percentile latency per operation using `histogram_quantile`, combining `sum` and `rate` for correct bucketing. Dependencies: Prometheus instance with metrics `temporal_cloud_v0_service_latency_sum`, `temporal_cloud_v0_service_latency_count`, and `temporal_cloud_v0_service_latency_bucket` exposed. Parameters: `$__rate_interval` for rate window, and `operation` label for grouping. Outputs: Time series of average and p99 latencies.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/reference.mdx#2025-04-23_snippet_1\n\nLANGUAGE: PromQL\nCODE:\n```\n# Average latency\\nrate(temporal_cloud_v0_service_latency_sum[$__rate_interval])\\n/ rate(temporal_cloud_v0_service_latency_count[$__rate_interval])\n```\n\nLANGUAGE: PromQL\nCODE:\n```\n# Approximate 99th percentile latency broken down by operation\\nhistogram_quantile(0.99, sum(rate(temporal_cloud_v0_service_latency_bucket[$__rate_interval])) by (le, operation))\n```\n\n----------------------------------------\n\nTITLE: Implementing an EJSON PayloadConverter for Temporal TypeScript SDK\nDESCRIPTION: Defines a custom PayloadConverterWithEncoding that serializes and deserializes values using EJSON, ensuring compatibility with Temporal UI and CompositePayloadConverter. It handles errors for non-EJSON-serializable types and adds custom metadata to each payload. Required dependencies: @temporalio/common, ejson. Inputs are arbitrary JavaScript values and outputs are EJSON-encoded Payloads; limitations include unsupported data types like BigInt. The error class UnsupportedEjsonTypeError extends PayloadConverterError for clear reporting.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  EncodingType,\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadConverterError,\n  PayloadConverterWithEncoding,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport EJSON from 'ejson';\n\n/**\n * Converts between values and [EJSON](https://docs.meteor.com/api/ejson.html) Payloads.\n */\nexport class EjsonPayloadConverter implements PayloadConverterWithEncoding {\n  // Use 'json/plain' so that Payloads are displayed in the UI\n  public encodingType = 'json/plain' as EncodingType;\n\n  public toPayload(value: unknown): Payload | undefined {\n    if (value === undefined) return undefined;\n    let ejson;\n    try {\n      ejson = EJSON.stringify(value);\n    } catch (e) {\n      throw new UnsupportedEjsonTypeError(\n        `Can't run EJSON.stringify on this value: ${value}. Either convert it (or its properties) to EJSON-serializable values (see https://docs.meteor.com/api/ejson.html ), or create a custom data converter. EJSON.stringify error message: ${\n          errorMessage(\n            e,\n          )\n        }`,\n        e as Error,\n      );\n    }\n\n    return {\n      metadata: {\n        [METADATA_ENCODING_KEY]: encode('json/plain'),\n        // Include an additional metadata field to indicate that this is an EJSON payload\n        format: encode('extended'),\n      },\n      data: encode(ejson),\n    };\n  }\n\n  public fromPayload<T>(content: Payload): T {\n    return content.data ? EJSON.parse(decode(content.data)) : content.data;\n  }\n}\n\nexport class UnsupportedEjsonTypeError extends PayloadConverterError {\n  public readonly name: string = 'UnsupportedJsonTypeError';\n\n  constructor(\n    message: string | undefined,\n    public readonly cause?: Error,\n  ) {\n    super(message ?? undefined);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Updated Activity in Temporal Workflow - Python\nDESCRIPTION: Illustrates the final Workflow state where only the updated activity (`post_patch_activity`) is executed using the Temporal Python SDK. This snippet assumes all legacy Workflow runs have completed, allowing safe removal of old activities and patch markers. The Workflow imports the new activity and executes it with a five-minute timeout, maintaining deterministic replay. No parameters are required except the new activity import; the Workflow awaits completion as before.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\\n\\nfrom temporalio import workflow\\n\\nwith workflow.unsafe.imports_passed_through():\\n    from activities import post_patch_activity\\n# ...\\n@workflow.defn\\nclass MyWorkflow:\\n    @workflow.run\\n    async def run(self) -> None:\\n        self._result = await workflow.execute_activity(\\n            post_patch_activity,\\n            schedule_to_close_timeout=timedelta(minutes=5),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Retry Policy using Temporal Python SDK\nDESCRIPTION: Illustrates how to apply a Retry Policy to a Workflow Execution using the `retry_policy` parameter in `client.execute_workflow`. This example configures a `RetryPolicy` with a specified `maximum_interval`. Workflow Executions do not retry by default, and defining a Retry Policy enables automatic retries upon failure according to the specified policy.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# ...\n    handle = await client.execute_workflow(\n        YourWorkflow.run,\n        \"your retry policy argument\",\n        id=\"your-workflow-id\",\n        task_queue=\"your-task-queue\",\n        retry_policy=RetryPolicy(maximum_interval=timedelta(seconds=2)),\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting Heartbeat Timeout via ActivityStub in Temporal Java SDK\nDESCRIPTION: Shows how to configure heartbeat timeout and start-to-close timeout for an activity when creating an ActivityStub inside a Workflow. Uses ActivityOptions.newBuilder().setHeartbeatTimeout() with a value of two seconds, in addition to mandatory start-to-close timeout. Requires inclusion of Temporal Java SDK, appropriate Activity interface, and uses Duration for specifying timeouts. Overriding activity options via ActivityStub in the workflow takes precedence over other declarations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nprivate final GreetingActivities activities =\\n    Workflow.newActivityStub(\\n        GreetingActivities.class,\\n        ActivityOptions.newBuilder()\\n            // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\\n            // required when setting Activity options.\\n            .setStartToCloseTimeout(Duration.ofSeconds(5))\\n            .setHeartbeatTimeout(Duration.ofSeconds(2))\\n            .build());\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Workflows with Search Attributes Filter in Python\nDESCRIPTION: Demonstrates how to use the Temporal Client's `list_workflows` asynchronous iterator method to query for Workflow Executions based on a Search Attribute filter specified as a string query. This example filters for Workflows where `WorkflowType` is 'GreetingWorkflow' and prints the ID of each matching workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ...\n    async for workflow in client.list_workflows('WorkflowType=\"GreetingWorkflow\"'):\n        print(f\"Workflow: {workflow.id}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkflowPanicPolicy for Temporal Worker in Go\nDESCRIPTION: Defines how the Worker handles panics originating from Workflow Definition code, including non-deterministic history events. The type is `WorkflowPanicPolicy`, and the default is `BlockWorkflow` (which blocks progress on the specific workflow). The provided code example incorrectly uses `DisableStickyExecution` as the key; it should likely be `WorkflowPanicPolicy`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_40\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    DisableStickyExecution: internal.BlockWorkflow, // Note: Key might be incorrect in source, should likely be WorkflowPanicPolicy\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Backfilling a Scheduled Workflow with Temporal Python SDK\nDESCRIPTION: Illustrates how to execute actions in a time range prior to their scheduled time using Temporal's backfill feature. The snippet connects to the Temporal server, retrieves a schedule handle, creates a backfill time window, and executes missed or test runs according to overlap policy. Dependencies include the Temporal Python SDK and valid imports. The method is asynchronous and expects a valid Schedule ID. Inputs: Schedule ID, time window for backfill, and overlap policy. Output: Executes Workflow runs in specified interval.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\\nfrom datetime import datetime, timedelta\\n\\nfrom temporalio.client import Client, ScheduleBackfill, ScheduleOverlapPolicy\\n\\n\\n\\nasync def main():\\n    client = await Client.connect(\"localhost:7233\")\\n    handle = client.get_schedule_handle(\\n        \"workflow-schedule-id\",\\n    )\\n    now = datetime.utcnow()\\n    (\\n        await handle.backfill(\\n            ScheduleBackfill(\\n                start_at=now - timedelta(minutes=10),\\n                end_at=now - timedelta(minutes=9),\\n                overlap=ScheduleOverlapPolicy.ALLOW_ALL,\\n            ),\\n        ),\\n    )\n```\n\n----------------------------------------\n\nTITLE: Extending Reusable Workflow Interfaces in Java\nDESCRIPTION: Demonstrates how to extend a reusable Workflow interface to create a new Workflow type with shared functionality.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface MediaProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processBlob(Arguments args);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Schedule for a Workflow in Go\nDESCRIPTION: This snippet demonstrates how to create a Schedule for a Workflow using the Go SDK. It initializes a Schedule with a unique ID, specification, and action using the Client's Create() method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tscheduleID := \"schedule_id\"\n\tworkflowID := \"schedule_workflow_id\"\n\t// Create the schedule.\n\tscheduleHandle, err := temporalClient.ScheduleClient().Create(ctx, client.ScheduleOptions{\n\t\tID:   scheduleID,\n\t\tSpec: client.ScheduleSpec{},\n\t\tAction: &client.ScheduleWorkflowAction{\n\t\t\tID:        workflowID,\n\t\t\tWorkflow:  schedule.ScheduleWorkflow,\n\t\t\tTaskQueue: \"schedule\",\n\t\t},\n\t})\n// ...\n}\n// ...\n```\n\n----------------------------------------\n\nTITLE: JUnit4 Test Implementation with TestWorkflowRule\nDESCRIPTION: Implementation of unit tests using JUnit4's TestWorkflowRule for simplified test environment setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic class HelloActivityJUnit4Test {\n    @Rule\n    public TestWorkflowRule testWorkflowRule =\n            TestWorkflowRule.newBuilder()\n                    .setWorkflowTypes(GreetingWorkflowImpl.class)\n                    .setActivityImplementations(new GreetingActivitiesImpl())\n                    .build();\n\n    @Test\n    public void testActivityImpl() {\n        // Get a workflow stub using the same task queue the worker uses.\n        GreetingWorkflow workflow =\n                testWorkflowRule\n                        .getWorkflowClient()\n                        .newWorkflowStub(\n                                GreetingWorkflow.class,\n                                WorkflowOptions.newBuilder().setTaskQueue(testWorkflowRule.getTaskQueue()).build());\n        // Execute a workflow waiting for it to complete.\n        String greeting = workflow.getGreeting(\"World\");\n        assertEquals(\"Hello World!\", greeting);\n\n        testWorkflowRule.getTestEnvironment().shutdown();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Start Delay for Workflow Execution in Temporal .NET SDK\nDESCRIPTION: This snippet shows how to use the StartDelay option to schedule a Workflow Execution at a specific one-time future point. It demonstrates setting the StartDelay on WorkflowOptions when starting a workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar handle = await client.StartWorkflowAsync(\n    (MyWorkflow wf) => wf.RunAsync(),\n    new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\")\n    {\n        StartDelay = TimeSpan.FromHours(3),\n    });\n```\n\n----------------------------------------\n\nTITLE: Developing Caller Workflow for Nexus Service in Go\nDESCRIPTION: This snippet demonstrates how to develop a caller Workflow that uses the Nexus Service. It includes two Workflows: EchoCallerWorkflow and HelloCallerWorkflow, which execute Nexus operations using the workflow.NewNexusClient.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage caller\n\nimport (\n\t\"github.com/temporalio/samples-go/nexus/service\"\n\t\"go.temporal.io/sdk/workflow\"\n)\n\nconst (\n\tTaskQueue    = \"my-caller-workflow-task-queue\"\n\tendpointName = \"my-nexus-endpoint-name\"\n)\n\nfunc EchoCallerWorkflow(ctx workflow.Context, message string) (string, error) {\n\tc := workflow.NewNexusClient(endpointName, service.HelloServiceName)\n\n\tfut := c.ExecuteOperation(ctx, service.EchoOperationName, service.EchoInput{Message: message}, workflow.NexusOperationOptions{})\n\n\tvar res service.EchoOutput\n\tif err := fut.Get(ctx, &res); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Message, nil\n}\n\nfunc HelloCallerWorkflow(ctx workflow.Context, name string, language service.Language) (string, error) {\n\tc := workflow.NewNexusClient(endpointName, service.HelloServiceName)\n\n\tfut := c.ExecuteOperation(ctx, service.HelloOperationName, service.HelloInput{Name: name, Language: language}, workflow.NexusOperationOptions{})\n\tvar res service.HelloOutput\n\n\t// Optionally wait for the operation to be started. NexusOperationExecution will contain the operation token in\n\t// case this operation is asynchronous.\n\tvar exec workflow.NexusOperationExecution\n\tif err := fut.GetNexusOperationExecution().Get(ctx, &exec); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := fut.Get(ctx, &res); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn res.Message, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Continue-As-New in a PHP Temporal Workflow\nDESCRIPTION: This snippet demonstrates how to implement Continue-As-New in a PHP Temporal Workflow. It shows a periodic Workflow that uses Continue-As-New to maintain a counter between runs while preventing the Event History from growing too large.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/continue-as-new.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\n#[Workflow\\WorkflowMethod]\npublic function periodic(string $name, int $value = 0)\n{\n    for ($i = 0; $i < 100; $i++) {\n        // do something\n        $value++;\n    }\n\n    // maintain $value counter between runs\n    return Workflow::newContinueAsNewStub(self::class)->periodic($name, $value);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Tuning in TypeScript SDK\nDESCRIPTION: Examples of setting up worker tuning options in TypeScript using resource-based tuning and combining different types of slot suppliers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Just resource based\nconst resourceBasedTunerOptions: ResourceBasedTunerOptions = {\n  targetMemoryUsage: 0.8,\n  targetCpuUsage: 0.9,\n};\nconst workerOptions = {\n  tuner: {\n    tunerOptions: resourceBasedTunerOptions,\n  },\n};\n// Combining different types\nconst resourceBasedTunerOptions: ResourceBasedTunerOptions = {\n  targetMemoryUsage: 0.8,\n  targetCpuUsage: 0.9,\n};\nconst workerOptions = {\n  tuner: {\n    activityTaskSlotSupplier: {\n      type: 'resource-based',\n      tunerOptions: resourceBasedTunerOptions,\n    },\n    workflowTaskSlotSupplier: {\n      type: 'fixed-size',\n      numSlots: 10,\n    },\n    localActivityTaskSlotSupplier: {\n      type: 'resource-based',\n      tunerOptions: resourceBasedTunerOptions,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: RoadRunner Server Configuration for Temporal PHP Workers\nDESCRIPTION: This YAML configuration shows how to set up RoadRunner to manage Temporal PHP worker processes. It specifies the worker file to execute, address settings for the Temporal service, and configures the number of activity workers to run.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nrpc:\n  listen: tcp://127.0.0.1:6001\n\nserver:\n  command: 'php worker.php'\n\ntemporal:\n  address: 'temporal:7233'\n  activities:\n    num_workers: 10\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace with Multiple Configurations using tcld (Bash)\nDESCRIPTION: This comprehensive example demonstrates creating a Temporal Cloud Namespace with various optional configurations, including retention period, certificate filters (via JSON input), user permissions, custom search attributes, and codec server settings. It requires the namespace identifier and primary region.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace create \\\n    --namespace <namespace_id> \\\n    --region us-west-2 \\\n    --retention-days 60 \\\n    --certificate-filter-input '{\"filters\": [{\"commonName\": \"test1\"}]}' \\\n    --user-namespace-permission \"user@example.com=Admin\" \\\n    --search-attribute \"customer_id=Int\" \\\n    --search-attribute \"customer_name=Text\" \\\n    --endpoint \"https://test-codec-server.com\" \\\n    --pass-access-token \\\n    --include-credentials\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentWorkflowTaskExecutionSize for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of concurrent Workflow Task Executions the Worker can handle. The type is `int`, and the default value is `1000`. Setting it to `0` uses the default value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_34\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    MaxConcurrentWorkflowTaskExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Validating Namespace Creation using tcld CLI\nDESCRIPTION: Uses the `tcld namespace get` command to retrieve details about a specific Temporal Cloud Namespace, verifying its existence and configuration after creation via Terraform. Replace `<your-namespace>.<your-account-id>` with the actual Cloud Namespace Name and Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace get -n \"<your-namespace>.<your-account-id>\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity Heartbeats in PHP\nDESCRIPTION: This snippet demonstrates how to send Heartbeats from within an Activity implementation using `Activity::heartbeat()` in the Temporal PHP SDK. It shows sending progress details (like download percentage) within a callback function during a long-running operation and sending a final Heartbeat upon completion. This allows the Temporal Service to detect Worker crashes and enables Cancellation handling. Depends on the Temporal PHP SDK (`Activity`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Activity;\n\nclass FileProcessingActivitiesImpl implements FileProcessingActivities\n{\n    // ...\n    public function download(\n        string $bucketName,\n        string $remoteName,\n        string $localName\n    ): void\n    {\n        $this->dowloader->downloadWithProgress(\n            $bucketName,\n            $remoteName,\n            $localName,\n            // on progress\n            function ($progress) {\n                Activity::heartbeat($progress);\n            }\n        );\n\n        Activity::heartbeat(100); // download complete\n\n        // ...\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CancellationType via WorkflowImplementationOptions in Java\nDESCRIPTION: This snippet shows how to set the Activity cancellation type (`WAIT_CANCELLATION_COMPLETED`) per Activity type (`EmailCustomerGreeting`) using `WorkflowImplementationOptions`. This configuration applies to all Activities of that type executed by Workers using these options. Dependencies include `io.temporal.worker.WorkflowImplementationOptions`, `com.google.common.collect.ImmutableMap`, `io.temporal.activity.ActivityOptions`, and `io.temporal.activity.ActivityCancellationType`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_35\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n        WorkflowImplementationOptions.newBuilder()\n               .setActivityOptions(\n                    ImmutableMap.of(\n                        \"EmailCustomerGreeting\",\n                        ActivityOptions.newBuilder()\n                              .setCancellationType(ActivityCancellationType.WAIT_CANCELLATION_COMPLETED)\n                              .build()))\n              .build();\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow and Obtaining WorkflowHandle in C#\nDESCRIPTION: This snippet demonstrates how to connect to a Temporal server, start a Workflow, and obtain its WorkflowHandle. The WorkflowHandle is used to send messages to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\nvar workflowHandle = await client.StartWorkflowAsync(\n    (GreetingWorkflow wf) => wf.RunAsync(),\n    new(id: \"message-passing-workflow-id\", taskQueue: \"message-passing-sample\"));\n```\n\n----------------------------------------\n\nTITLE: Setting Up Time Skipping in PHP Tests\nDESCRIPTION: PHP bootstrap file for setting up the time-skipping test framework in Temporal PHP SDK tests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\ndeclare(strict_types=1);\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse Temporal\\Testing\\Environment;\n\n$environment = Environment::create();\n$environment->start();\nregister_shutdown_function(fn () => $environment->stop());\n```\n\n----------------------------------------\n\nTITLE: Implementing DeprecatePatch in .NET Temporal Workflow\nDESCRIPTION: This snippet shows how to use the DeprecatePatch method to safely transition from PrePatchActivity to PostPatchActivity. It adds a marker to the Workflow History without causing replay failures for older versions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        Workflow.DeprecatePatch(\"my-patch\")\n        this.result = await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.PostPatchActivity(),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Parent Close Policy for Child Workflow in Go\nDESCRIPTION: This snippet demonstrates how to set a Parent Close Policy for a Child Workflow Execution using the Go SDK. It shows the use of ParentClosePolicy field in ChildWorkflowOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/child-workflows.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n  // ...\n  \"go.temporal.io/api/enums/v1\"\n)\n\nfunc YourWorkflowDefinition(ctx workflow.Context, params ParentParams) (ParentResp, error) {\n  // ...\n  childWorkflowOptions := workflow.ChildWorkflowOptions{\n    // ...\n    ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,\n  }\n  ctx = workflow.WithChildOptions(ctx, childWorkflowOptions)\n  childWorkflowFuture := workflow.ExecuteChildWorkflow(ctx, YourOtherWorkflowDefinition, ChildParams{})\n  // ...\n}\n\nfunc YourOtherWorkflowDefinition(ctx workflow.Context, params ChildParams) (ChildResp, error) {\n  // ...\n  return resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start in PHP Temporal Client\nDESCRIPTION: This code shows how to use the Signal-With-Start functionality in a Temporal Client. It demonstrates creating a Workflow stub and using startWithSignal to either signal an existing Workflow or start a new one and immediately signal it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_4\n\nLANGUAGE: PHP\nCODE:\n```\n$workflow = $workflowClient->newWorkflowStub(YourWorkflow::class);\n\n$run = $workflowClient->startWithSignal(\n    $workflow,\n    'setValue',\n    [true], // signal arguments\n    [] // start arguments\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Dependency-Injected Activities in a Temporal Worker (TypeScript)\nDESCRIPTION: Demonstrates how to register Activities created using a factory function (`createActivities`) within a Temporal Worker as part of a dependency injection pattern. It involves initializing the dependency (a mock `db` object here) and passing it to the factory function when configuring the `activities` property in `Worker.create`. Requires `@temporalio/worker` and the activity factory function.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nimport { createActivities } from './activities';\n\nasync function run() {\n  // Mock DB connection initialization in Worker\n  const db = {\n    async get(_key: string) {\n      return 'Temporal';\n    },\n  };\n\n  const worker = await Worker.create({\n    taskQueue: 'dependency-injection',\n    workflowsPath: require.resolve('./workflows'),\n    activities: createActivities(db),\n  });\n\n  await worker.run();\n}\n\nrun().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Mocking Activities in PHP Workflow Tests\nDESCRIPTION: PHP test case demonstrating how to mock Activities using ActivityMocker for Workflow testing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\nfinal class SimpleWorkflowTestCase extends TestCase\n{\n    private WorkflowClient $workflowClient;\n    private ActivityMocker $activityMocks;\n\n    protected function setUp(): void\n    {\n        $this->workflowClient = new WorkflowClient(ServiceClient::create('localhost:7233'));\n        $this->activityMocks = new ActivityMocker();\n\n        parent::setUp();\n    }\n\n    protected function tearDown(): void\n    {\n        $this->activityMocks->clear();\n        parent::tearDown();\n    }\n\n    public function testWorkflowReturnsUpperCasedInput(): void\n    {\n        $this->activityMocks->expectCompletion('SimpleActivity.doSomething', 'world');\n        $workflow = $this->workflowClient->newWorkflowStub(SimpleWorkflow::class);\n        $run = $this->workflowClient->start($workflow, 'hello');\n        $this->assertSame('world', $run->getResult('string'));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Starting Temporal Server in Go\nDESCRIPTION: This code snippet demonstrates how to instantiate a Temporal Server using the temporal.NewServer() function and start it with s.Start(). Both creation and start calls are checked for errors, and the process will terminate on failure using log.Fatal. Required dependencies include the go.temporal.io/server/temporal package and logging utilities. No configuration options are passed, so all defaults are used; input/output consists of server lifecycle events and logged errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer()\nif err != nil {\n\tlog.Fatal(err)\n}\nerr = s.Start()\nif err != nil{\n\tlog.Fatal(err)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Cloud User by ID via tcld CLI - Command\nDESCRIPTION: Illustrates how to remove a user by unique identifier in Temporal Cloud using tcld. The --user-id flag specifies the user's unique ID. Proper authentication and permissions are required; successful execution deletes the corresponding user account.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_1\n\nLANGUAGE: command\nCODE:\n```\ntcld user delete --user-id <test-user-id>\n```\n\n----------------------------------------\n\nTITLE: Upgrading PostgreSQL Visibility Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command uses the `temporal-sql-tool` to upgrade the visibility schema for a Temporal Server using PostgreSQL (targeting v9.6 schema compatibility). It connects via TLS, authenticates using certificates and credentials, specifies the `postgres` plugin, targets the `temporal_visibility` database, and applies schema updates from the specified directory. It requires the `temporal-sql-tool` executable and appropriate schema files.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal_visibility update-schema -d ./schema/postgresql/v96/visibility/versioned\n```\n\n----------------------------------------\n\nTITLE: Creating Temporal Cloud Service Accounts and API Keys\nDESCRIPTION: Terraform configuration for creating a Temporal Cloud Service Account with Admin access and an associated API Key. This demonstrates how to configure API key properties including display name, expiry time, and ownership.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_21\n\nLANGUAGE: yml\nCODE:\n```\nterraform {\n  required_providers {\n    temporalcloud = {\n      source = \"temporalio/temporalcloud\"\n    }\n  }\n}\n\nprovider \"temporalcloud\" {\n\n}\n\nresource \"temporalcloud_service_account\" \"global_service_account\" {\n  name           = \"admin\"\n  account_access = \"Admin\"\n}\n\nresource \"temporalcloud_apikey\" \"global_apikey\" {\n  display_name = \"admin\"\n  owner_type   = \"service-account\"\n  owner_id     = temporalcloud_service_account.global_service_account.id\n  expiry_time  = \"2024-11-01T00:00:00Z\"\n  disabled     = false\n}\n```\n\n----------------------------------------\n\nTITLE: Using cancelRequested with nonCancellable Scopes in Temporal Workflows\nDESCRIPTION: Demonstrates how to use cancelRequested to make a Workflow aware of cancellation while waiting on activities in nonCancellable scopes. This allows for graceful handling of cancellation requests while ensuring certain operations complete.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function resumeAfterCancellation(url: string): Promise<any> {\n  let result: any = undefined;\n  const scope = new CancellationScope({ cancellable: false });\n  const promise = scope.run(() => httpGetJSON(url));\n  try {\n    result = await Promise.race([scope.cancelRequested, promise]);\n  } catch (err) {\n    if (!(err instanceof CancelledFailure)) {\n      throw err;\n    }\n    // Prevent Workflow from completing so Activity can complete\n    result = await promise;\n  }\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Start Delay for a Workflow in Go\nDESCRIPTION: This snippet demonstrates how to delay the start of a Workflow Execution using Start Delay with the Temporal Go SDK. It sets the StartDelay field in StartWorkflowOptions to schedule a Workflow Execution at a specific future point.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  // Start the workflow in 12 hours\n  StartDelay: time.Hours * 12,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Namespace Configuration in Temporal Java SDK\nDESCRIPTION: This code snippet demonstrates how to update the configuration of a Namespace using the UpdateNamespace API. It updates the description and workflow execution retention period for a specified Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nimport io.temporal.api.workflowservice.v1.*;\n//...\nUpdateNamespaceRequest updateNamespaceRequest = UpdateNamespaceRequest.newBuilder()\n            .setNamespace(\"your-namespace-name\") //the namespace that you want to update\n            .setUpdateInfo(UpdateNamespaceInfo.newBuilder() //has options to update namespace info\n                    .setDescription(\"your updated namespace description\") //updates description in the namespace info.\n                    .build())\n            .setConfig(NamespaceConfig.newBuilder() //has options to update namespace configuration\n                    .setWorkflowExecutionRetentionTtl(Durations.fromHours(30)) //updates the retention period for the namespace \"your-namespace--name\" to 30 hrs.\n                    .build())\n            .build();\n    UpdateNamespaceResponse updateNamespaceResponse = namespaceservice.blockingStub().updateNamespace(updateNamespaceRequest);\n//...\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Tuning in .NET C# SDK\nDESCRIPTION: Examples of configuring worker tuning in C# using resource-based tuning and combining different types of slot suppliers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Just resource based\nvar worker = new TemporalWorker(\n            Client,\n            new TemporalWorkerOptions(\"my-task-queue\")\n            {\n                Tuner = WorkerTuner.CreateResourceBased(0.8, 0.9),\n            };\n// Combining different types\nvar resourceTunerOptions = new ResourceBasedTunerOptions(0.8, 0.9);\nvar worker = new TemporalWorker(\n            Client,\n            new TemporalWorkerOptions(\"my-task-queue\")\n            {\n                Tuner = new WorkerTuner(\n                    new FixedSizeSlotSupplier(10),\n                    new ResourceBasedSlotSupplier(\n                        new ResourceBasedSlotSupplierOptions(),\n                        resourceTunerOptions),\n                    new ResourceBasedSlotSupplier(\n                        new ResourceBasedSlotSupplierOptions(),\n                        resourceTunerOptions),\n            };\n```\n\n----------------------------------------\n\nTITLE: SearchAttributes Import and Key Definition\nDESCRIPTION: Code for importing and defining SearchAttributes for version tracking in the Event History.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nimport io.temporal.common.SearchAttributeKey;\n\npublic static final SearchAttributeKey<List<String>> TEMPORAL_CHANGE_VERSION = SearchAttributeKey.forKeywordList(\"TemporalChangeVersion\");\n```\n\n----------------------------------------\n\nTITLE: Logging within a Temporal Workflow in Python\nDESCRIPTION: Shows how to log messages from inside a Temporal Workflow definition using the `workflow.logger` object provided by the SDK. This logger integrates with the Worker's logging setup. This example logs an informational message containing a Workflow input parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ...\n        workflow.logger.info(\"Workflow input parameter: %s\" % name)\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Concurrent Sessions in Go SDK\nDESCRIPTION: Adjust the maximum concurrent Sessions of a Worker by setting the MaxConcurrentSessionExecutionSize field in worker.Options. This limits the number of concurrent sessions running on a Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/sessions.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\tworkerOptions := worker.Options{\n\t\t// This configures the maximum allowed concurrent sessions.\n\t\t// Customize this value only if you need to.\n\t\tMaxConcurrentSessionExecutionSize: 1000,\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Asynchronous Nexus Operation in Go\nDESCRIPTION: This example shows how to mock an asynchronous Nexus operation in a Temporal Workflow test. It uses OnNexusOperation to set up the mock and RegisterNexusAsyncOperationCompletion to register the result of the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_NexusAsyncOperation() {\n        s.env.OnNexusOperation(\n                \"sample-service\",\n                nexus.NewOperationReference[SampleInput, SampleOutput](\"sample-operation\"),\n                SampleInput{},\n                workflow.NexusOperationOptions{},\n        ).Return(\n                &nexus.HandlerStartOperationResultAsync{\n                        OperationToken: \"sample-operation-token\",\n                },\n                nil, // error if you want to simulate an error in the ExecuteOperation call\n        )\n        err := env.RegisterNexusAsyncOperationCompletion(\n                \"sample-service\",\n                \"sample-operation\",\n                \"sample-operation-token\", // must match the OperationToken above\n                SampleOutput{},\n                nil,            // error if you want to simulate an error in the operation\n                2*time.Second,  // delay to simulate how long the operation takes after it starts\n        )\n        s.NoError(err)\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_nexus_operation\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mutex to Control Handler Concurrency in C# Temporal Workflows\nDESCRIPTION: This example shows how to use Workflows.Mutex to prevent concurrent execution of critical sections in a handler. The mutex ensures only one handler instance can execute the protected code at any time, preventing race conditions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    private readonly Mutex mutex = new();\n\n    // ...\n\n    [WorkflowSignal]\n    public async Task SafeHandlerAsync()\n    {\n        await mutex.WaitOneAsync();\n        try\n        {\n            var data = await Workflow.ExecuteActivityAsync(\n                (MyActivities acts) => acts.FetchDataAsync(),\n                new() { StartToCloseTimeout = TimeSpan.FromSeconds(10) });\n            this.x = data.X;\n            // ✅ OK: the scheduler may switch now to a different handler execution, or to the main workflow\n            // method, but no other execution of this handler can run until this execution finishes.\n            await Workflow.DelayAsync(1000);\n            this.y = data.Y;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Signal-With-Start from a Temporal Client in Python\nDESCRIPTION: This snippet illustrates the Signal-With-Start feature, allowing a Client to send a Signal that starts the Workflow Execution if it's not already running. It uses the `client.start_workflow` method, providing the `start_signal` name and `start_signal_args` in addition to standard workflow start parameters like ID and task queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n```python\nfrom temporalio.client import Client\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    await client.start_workflow(\n        GreetingWorkflow.run,\n        id=\"your-signal-with-start-workflow\",\n        task_queue=\"signal-tq\",\n        start_signal=\"submit_greeting\",\n        start_signal_args=[\"User Signal with Start\"],\n    )\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow in TypeScript\nDESCRIPTION: This snippet shows how to implement a Workflow in TypeScript using the Temporal SDK. It defines an async function that takes arguments and returns a Promise.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntype BasicWorkflowArgs = {\n  param: string;\n};\n\nexport async function WorkflowExample(\n  args: BasicWorkflowArgs,\n): Promise<{ result: string }> {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Activity Result Struct in Go\nDESCRIPTION: Defines a Go struct `YourActivityResultObject` to structure the return values of an Activity Definition. Using a struct allows returning multiple values of different types and ensures the function signature remains compatible if the result fields change. The example shows the struct definition and how an instance of this struct is populated and returned from the `YourActivityDefinition` function, along with a nil error on success. All returned data must be serializable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n// YourActivityResultObject is the struct returned from your Activity.\n// Use a struct so that you can return multiple values of different types.\n// Additionally, your function signature remains compatible if the fields change.\ntype YourActivityResultObject struct {\n    ResultFieldX string\n    ResultFieldY int\n}\n// ...\nfunc (a *YourActivityObject) YourActivityDefinition(ctx context.Context, param YourActivityParam) (*YourActivityResultObject, error) {\n// ...\n    result := &YourActivityResultObject{\n        ResultFieldX: \"Success\",\n        ResultFieldY: 1,\n    }\n    // Return the results back to the Workflow Execution.\n    // The results persist within the Event History of the Workflow Execution.\n    return result, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Signal to a Running Workflow in PHP\nDESCRIPTION: This snippet illustrates how to send a signal to an already running Workflow using the Workflow ID. It uses newRunningWorkflowStub to create a stub for the running Workflow and then sends a signal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_3\n\nLANGUAGE: PHP\nCODE:\n```\n$workflow = $workflowClient->newRunningWorkflowStub(YourWorkflow::class, 'workflowID');\n$workflow->setValue(true);\n```\n\n----------------------------------------\n\nTITLE: Registering Activity Finalizers in Temporal PHP\nDESCRIPTION: This snippet demonstrates how to register a finalizer callback that runs after each activity invocation. This is useful for cleaning up resources when an activity completes execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_18\n\nLANGUAGE: php\nCODE:\n```\n$worker->registerActivityFinalizer(fn() => $kernel->showtdown());\n```\n\n----------------------------------------\n\nTITLE: Querying Percentile History Task Attempt Count using PromQL\nDESCRIPTION: This Prometheus query calculates a specified percentile (defined by `$percentile`) of the number of attempts made for active History task executions (`task_attempt_bucket`) over the last 1 minute. It filters for operations matching `TransferActive.*` and uses a variable `$service`. High attempt counts can indicate persistent issues requiring investigation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_10\n\nLANGUAGE: PromQL\nCODE:\n```\nhistogram_quantile($percentile, sum(rate(task_attempt_bucket{service=\"$service\",operation=~\"TransferActive.*\"}[1m])) by (operation, le))\n```\n\n----------------------------------------\n\nTITLE: Registering Workflow Interceptor Modules with a Temporal Worker in TypeScript\nDESCRIPTION: This snippet demonstrates how to register the Workflow interceptors defined in a separate module (like `your-interceptors.ts`) when creating a Temporal Worker. It uses the `interceptors.workflowModules` option within `Worker.create`'s `WorkerOptions`, providing the resolved path to the interceptor module.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/interceptors.mdx#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst worker = await Worker.create({\n  workflowsPath: require.resolve('./workflows'),\n  interceptors: {\n    workflowModules: [require.resolve('./workflows/your-interceptors')],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Upserting Search Attributes in a Workflow Update Method in PHP\nDESCRIPTION: Demonstrates how to dynamically add or update Search Attributes within a Workflow using the upsertTypedSearchAttributes method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n#[Workflow\\UpdateMethod]\npublic function postponeDestinationTime(\\DateInterval $interval)\n{\n    // Get the key for the DestinationTime attribute\n    $keyDestinationTime = SearchAttributeKey::forDatetime('DestinationTime');\n\n    /** @var DateTimeImmutable $destinationTime */\n    $destinationTime = Workflow::getInfo()->typedSearchAttributes->get($keyDestinationTime);\n\n    Workflow::upsertTypedSearchAttributes(\n        $keyDestinationTime->valueSet($destinationTime->add($interval)),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Pydantic Data Converter in Temporal Python Client - Python\nDESCRIPTION: This snippet demonstrates configuring the Temporal Python SDK Client to use the Pydantic data converter, enabling seamless use of Pydantic model instances for workflow and activity inputs/outputs. The integration requires the temporalio.contrib.pydantic module and assumes Pydantic is installed. This approach supports all Pydantic-serializable types alongside basic and extended JSON types, ensuring round-trip conversion between Pydantic models and stored JSON payloads. Intended for use in workflow clients and tasks requiring strongly-typed data.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/converters-and-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.contrib.pydantic import pydantic_data_converter\n\nclient = Client(data_converter=pydantic_data_converter, ...)\n```\n\n----------------------------------------\n\nTITLE: Replaying Multiple Workflow Histories from Client in Temporal .NET SDK (C#)\nDESCRIPTION: This C# function demonstrates fetching and replaying multiple past Workflow histories for a specific Workflow type (`MyWorkflow`) using the Temporal .NET SDK. It uses an `ITemporalClient` to list histories based on a query (`WorkflowType = 'SayHello'`) and iterates through the replay results using `ReplayWorkflowsAsync`. If any replay fails due to non-determinism, the corresponding exception is re-thrown using `ExceptionDispatchInfo.Throw`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing Temporalio;\nusing Temporalio.Client;\nusing Temporalio.Worker;\n\npublic static async Task CheckPastHistoriesAsync(ITemporalClient client)\n{\n    var replayer = new WorkflowReplayer(\n        new WorkflowReplayerOptions().AddWorkflow<MyWorkflow>());\n    var listIter = client.ListWorkflowHistoriesAsync(\"WorkflowType = 'SayHello'\");\n    await foreach (var result in replayer.ReplayWorkflowsAsync(listIter))\n    {\n        if (result.ReplayFailure != null)\n        {\n            ExceptionDispatchInfo.Throw(result.ReplayFailure);\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Resource-Based and Composite Tuners in Go SDK\nDESCRIPTION: This Go code demonstrates initializing a `ResourceBasedTuner` with specific memory (80%) and CPU (90%) targets and configuring a `CompositeTuner`. The composite tuner combines a `FixedSizeSlotSupplier` for Workflow and Nexus tasks with `ResourceBasedSlotSupplier` instances for Activity and Local Activity tasks, sharing a common `ResourceController`. The configured tuner is then assigned to the `worker.Options` for a Temporal Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\n// Using the ResourceBasedTuner in worker options\ntuner, err := resourcetuner.NewResourceBasedTuner(resourcetuner.ResourceBasedTunerOptions{\n    TargetMem: 0.8,\n    TargetCpu: 0.9,\n})\nif err != nil {\n  return err\n}\nworkerOptions := worker.Options{\n    Tuner: tuner\n}\n// Combining different types\noptions := DefaultResourceControllerOptions()\noptions.MemTargetPercent = 0.8\noptions.CpuTargetPercent = 0.9\ncontroller := NewResourceController(options)\nwfSS, err := worker.NewFixedSizeSlotSupplier(10)\nif err != nil {\n  return err\n}\nactSS := &ResourceBasedSlotSupplier{controller: controller,\n    options: defaultActivityResourceBasedSlotSupplierOptions()}\nlaSS := &ResourceBasedSlotSupplier{controller: controller,\n    options: defaultActivityResourceBasedSlotSupplierOptions()}\nnexusSS, err := worker.NewFixedSizeSlotSupplier(10)\nif err != nil {\n  return err\n}\ncompositeTuner, err := worker.NewCompositeTuner(worker.CompositeTunerOptions{\n    WorkflowSlotSupplier:      wfSS,\n    ActivitySlotSupplier:      actSS,\n    LocalActivitySlotSupplier: laSS,\n    NexusSlotSupplier:         nexusSS,\n})\nif err != nil {\n  return err\n}\nworkerOptions := worker.Options{\n    Tuner: compositeTuner\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Removing CA Certificate with Resource Version - tcld CLI - Bash\nDESCRIPTION: This snippet removes a CA certificate from the metrics endpoint using a specific resource version (ETag) for version control. Parameters: --resource-version (ETag value) and --ca-certificate (base64-encoded PEM of the CA certificate to remove). Ensures safe concurrent modifications. Requires tcld CLI and appropriate access.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca remove --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentWorkflowTaskPollers for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of goroutines that will concurrently poll the Task Queue for Workflow Tasks. Adjusting this affects the rate at which the Worker consumes Workflow Tasks. The type is `int`, and the default value is `2`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_35\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    MaxConcurrentWorkflowTaskPollers: 2,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts in PHP\nDESCRIPTION: This code illustrates how to configure Activity timeouts (Schedule-To-Close, Start-To-Close, Schedule-To-Start) when creating an Activity stub within a Workflow using `ActivityOptions` in the Temporal PHP SDK. It shows setting the `ScheduleToCloseTimeout` and comments out the others. Dependencies include the Temporal PHP SDK (`Workflow`, `ActivityOptions`) and Carbon (`CarbonInterval`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n$this->greetingActivity = Workflow::newActivityStub(\n    GreetingActivityInterface::class,\n    // Set Activity Timeout duration\n    ActivityOptions::new()\n        ->withScheduleToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withStartToCloseTimeout(CarbonInterval::seconds(2))\n        // ->withScheduleToStartTimeout(CarbonInterval::seconds(10))\n);\n```\n\n----------------------------------------\n\nTITLE: Registering DynamicWorkflow and DynamicActivity Implementations - Java\nDESCRIPTION: This snippet demonstrates a complete main method that registers a DynamicWorkflow and DynamicActivity implementation with a Worker using the Temporal Java SDK. It covers the setup of WorkflowServiceStubs, WorkflowClient, WorkerFactory, the registration of a dynamic workflow and activity, creation of a Workflow stub, and triggering of workflow execution with a signal. All dependencies (Temporal SDK, implementations) must be present, and the worker must be attached to the correct task queue. Inputs include task queue, workflow id, and signal/arguments. The workflow is started, signaled, and its result is printed before process termination.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_41\n\nLANGUAGE: Java\nCODE:\n```\n  public static void main(String[] arg) {\n\n    WorkflowServiceStubs service = WorkflowServiceStubs.newInstance();\n    WorkflowClient client = WorkflowClient.newInstance(service);\n    WorkerFactory factory = WorkerFactory.newInstance(client);\n    Worker worker = factory.newWorker(TASK_QUEUE);\n\n    /* Register the Dynamic Workflow implementation with the Worker. Workflow implementations\n    ** must be known to the Worker at runtime to dispatch Workflow Tasks.\n    */\n    worker.registerWorkflowImplementationTypes(DynamicGreetingWorkflowImpl.class);\n\n    // Start all the Workers that are in this process.\n    factory.start();\n\n    /* Create the Workflow stub. Note that the Workflow Type is not explicitly registered with the Worker. */\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(TASK_QUEUE).setWorkflowId(WORKFLOW_ID).build();\n    WorkflowStub workflow = client.newUntypedWorkflowStub(\"DynamicWF\", workflowOptions);\n    /**\n     * Register Dynamic Activity implementation with the Worker. Since Activities are stateless\n     * and thread-safe, we need to register a shared instance.\n    */\n    worker.registerActivitiesImplementations(new DynamicGreetingActivityImpl());\n\n    /* Start Workflow Execution and immmediately send Signal. Pass in the Workflow args and Signal args. */\n    workflow.signalWithStart(\"greetingSignal\", new Object[] {\"John\"}, new Object[] {\"Hello\"});\n\n    // Wait for the Workflow to finish getting the results.\n    String result = workflow.getResult(String.class);\n\n    System.out.println(result);\n\n    System.exit(0);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Formatting and Linting Codebase with Poe – Bash\nDESCRIPTION: Invokes formatting and linting tasks using 'poe format' and 'poe lint', which are typically Poe the Poet tasks calling Ruff. Requires 'poe' (Poe the Poet) and 'ruff' to be installed and configured in the project. 'poe format' applies formatting rules, while 'poe lint' performs code linting; both help ensure code adheres to repository standards before pull requests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoe format\npoe lint\n```\n\n----------------------------------------\n\nTITLE: Example JWT Payload for Default JWT ClaimMapper (JSON)\nDESCRIPTION: This JSON sample illustrates the payload structure of a JWT as expected by the Temporal default JWT ClaimMapper, containing permissions, audience, expiry, and issuer claims. 'permissions' contains an array of permission strings mapping to Temporal roles, 'aud' specifies the audience, 'exp' gives the expiration timestamp, and 'iss' identifies the token issuer. This payload must match the expected schema so that the ClaimMapper can successfully extract roles and enforce proper access control.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"permissions\":[\n      \"temporal-system:read\",\n      \"namespace1:write\"\n   ],\n   \"aud\":[\n      \"audience\"\n   ],\n   \"exp\":1630295722,\n   \"iss\":\"Issuer\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RPC Retry Policy in Temporal PHP Client\nDESCRIPTION: Demonstrates how to configure retry policy options for Temporal client connections including maximum attempts, intervals, backoff coefficient, and jitter. The code shows creation of a WorkflowClient with custom retry settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_16\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Client\\Common\\RpcRetryOptions;\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$serviceClient = ServiceClient::create('localhost:7233');\n$workflowClient = WorkflowClient::create($serviceClient)\n    ->withRetryOptions(\n        RpcRetryOptions::new()\n            ->withMaximumAttempts(10)\n            ->withInitialInterval('1 second')   // The first retry will be in 1 second\n            ->withBackoffCoefficient(2.5)       // Each next retry time will be multiplied by 2.5\n            ->withMaximumInterval('20 seconds') // The maximum interval between attempts\n            ->withMaximumJitterCoefficient(0.2) // Actual retry time can be +/- 20% of the calculated time\n    );\n```\n\n----------------------------------------\n\nTITLE: Querying Enhanced Task Queue Info with Go SDK\nDESCRIPTION: This Go code snippet demonstrates how to retrieve detailed statistics for multiple Temporal Task Queues using the Go SDK. It iterates over a list of Task Queue names (`taskQueueNames`), calls the `DescribeTaskQueueEnhanced` method on the client (`s.client`) for each queue, specifying the queue name and setting `ReportStats` to `true`. It logs any errors encountered during the description process and accumulates the backlog count using a helper function `getBacklogCount` applied to the response (`resp`). Requires a Temporal Go SDK client instance (`s.client`), a context (`ctx`), and a slice of task queue names (`taskQueueNames`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n```go\nfor _, taskQueueName := range taskQueueNames {\n        resp, err := s.client.DescribeTaskQueueEnhanced(ctx, client.DescribeTaskQueueEnhancedOptions{\n            TaskQueue:   taskQueueName,\n            ReportStats: true,\n        })\n        if err != nil {\n            log.Printf(\"Error describing task queue %s: %v\", taskQueueName, err)\n        }\n\n        // Get the backlog count from the enhanced response\n        backlogCount += getBacklogCount(resp)\n    }\n```\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToCloseTimeout with WorkflowImplementationOptions in Java\nDESCRIPTION: This code shows how to set the ScheduleToCloseTimeout using WorkflowImplementationOptions within a Worker. It's part of the ActivityOptions reference section.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_23\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n              WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                      \"GetCustomerGreeting\",\n                                      ActivityOptions.newBuilder()\n                                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                          .build()))\n                      .build();\n```\n\n----------------------------------------\n\nTITLE: Defining Context Propagator Interface in Go\nDESCRIPTION: This code snippet defines the ContextPropagator interface in Go. It includes four methods for injecting and extracting context information between Go contexts and Temporal headers, both for regular contexts and workflow contexts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype ContextPropagator interface {\n  Inject(context.Context, HeaderWriter) error\n\n  Extract(context.Context, HeaderReader) (context.Context, error)\n\n  InjectFromWorkflow(Context, HeaderWriter) error\n\n  ExtractToWorkflow(Context, HeaderReader) (Context, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Interface with Signals and Queries in PHP\nDESCRIPTION: This code snippet demonstrates how to define a Workflow interface with WorkflowMethod, SignalMethod, and QueryMethod attributes in PHP. It shows the structure for processing files, handling signals, and responding to queries.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PHP\nCODE:\n```\nuse Temporal\\Workflow\\WorkflowInterface;\nuse Temporal\\Workflow\\WorkflowMethod;\nuse Temporal\\Workflow\\SignalMethod;\nuse Temporal\\Workflow\\QueryMethod;\n\n#[WorkflowInterface]\ninterface FileProcessingWorkflow\n{\n    #[WorkflowMethod]\n    public function processFile(Argument $args);\n\n    #[QueryMethod(\"history\")]\n    public function getHistory(): array;\n\n    #[QueryMethod(\"status\")]\n    public function getStatus(): string;\n\n    #[SignalMethod]\n    public function retryNow(): void;\n\n    #[SignalMethod]\n    public function abandon(): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Search Attributes when Starting a Workflow in PHP\nDESCRIPTION: Shows how to set custom Search Attributes using the withTypedSearchAttributes method on WorkflowOptions when creating a new Workflow stub.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$keyDestinationTime = SearchAttributeKey::forDatetime('DestinationTime');\n$keyOrderId = SearchAttributeKey::forKeyword('OrderId');\n\n$workflow = $workflowClient->newWorkflowStub(\n    OrderWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowExecutionTimeout('10 minutes')\n        ->withTypedSearchAttributes(\n            TypedSearchAttributes::empty()\n                ->withValue($keyOrderId, $orderid)\n                ->withValue($keyDestinationTime, new \\DateTimeImmutable('2028-11-05T00:10:07Z'))\n        ),\n);\n```\n\n----------------------------------------\n\nTITLE: Testing GCP PSC Connection with grpcURL (API Key)\nDESCRIPTION: This command demonstrates testing the Private Service Connect connection using `grpcurl` with API key authentication. It includes the API key in the `authorization` header (as a Bearer token) and the target namespace in the `temporal-namespace` header. The TLS server name (`-servername`) is overridden to the regional Temporal Cloud API endpoint. It targets the PSC endpoint IP and port and calls the `GetSystemInfo` method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/gcp-private-service-connect.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngrpcurl \\\n    -H \"authorization: Bearer <api_key>\" \\\n    -H \"temporal-namespace: <namespace>.<account>\" \\\n    -servername <region>.<cloud_provider>.api.temporal.io \\\n    <IP address of the PSC endpoint>:7233 \\\n    temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo\n```\n\n----------------------------------------\n\nTITLE: Signaling Non-Retryable Errors in Custom Temporal Archiver (Go)\nDESCRIPTION: Shows how a custom Temporal Archiver's `Archive` method in Go can signal a non-retryable error to the caller. It uses the `FeatureCatalog` obtained from `ArchiverOptions` to check if the `NonRetryableError` feature is available and returns a specific error type to prevent further retries.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n\n    err: = youArchiverImpl()\n\n    if nonRetryableErr(err) {\n        if featureCatalog.NonRetryableError != nil {\n            return featureCatalog.NonRetryableError() // when the caller gets this error type back it will not retry anymore.\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Temporal Cloud Users with Terraform Configuration\nDESCRIPTION: Terraform configuration for creating Temporal Cloud Users with different access levels. This snippet defines a namespace and two users: one with Global Admin access and another with Namespace Admin access. It demonstrates how to set up provider requirements and configure user permissions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_14\n\nLANGUAGE: yml\nCODE:\n```\nterraform {\n  required_providers {\n    temporalcloud = {\n      source = \"temporalio/temporalcloud\"\n    }\n  }\n}\n\nprovider \"temporalcloud\" {\n\n}\n\nresource \"temporalcloud_namespace\" \"namespace\" {\n  name               = \"terraform\"\n  regions            = [\"aws-us-east-1\"]\n  accepted_client_ca = base64encode(file(\"ca.pem\"))\n  retention_days     = 14\n}\n\nresource \"temporalcloud_user\" \"global_admin\" {\n  email          = <admin-email>\n  account_access = \"Admin\"\n}\n\nresource \"temporalcloud_user\" \"namespace_admin\" {\n  email          = <developer-email>\n  account_access = \"Developer\"\n  namespace_accesses = [\n    {\n      namespace_id = temporalcloud_namespace.namespace.id\n      permission = \"Write\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Replaying a Workflow Execution from File Using WorkflowReplayer in Java\nDESCRIPTION: This Java example demonstrates how to use WorkflowReplayer to validate a single Workflow Event History loaded from a JSON file. It requires the input file with the execution history and the corresponding Workflow class expected to match the execution. The snippet is useful for CI checks, relies on classes from temporal-testing, and throws errors if the replayed history does not match the current Workflow definition. Inputs are the file location and Workflow class; output is validation via exceptions/logging.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nFile file = new File(\"my_history.json\");\nWorkflowReplayer.replayWorkflowExecution(file, MyWorkflow.class);\n```\n\n----------------------------------------\n\nTITLE: Terminating Workflow Execution in .NET\nDESCRIPTION: Shows how to forcefully terminate a Workflow Execution using the TerminateAsync method. This is a last resort option when normal cancellation is not possible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/cancellation.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar handle = myClient.GetWorkflowHandle(\"my-workflow-id\");\nawait handle.TerminateAsync();\n```\n\n----------------------------------------\n\nTITLE: Setting HeartbeatTimeout in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Demonstrates the assignment of `HeartbeatTimeout` within ActivityOptions, which controls the allowed interval between heartbeats from an Activity to avoid timeout failures. Assumes the presence of `go.temporal.io/sdk/workflow` and a correctly prepared context. The code executes the Activity with this timeout enforced and handles the result and errors as shown.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  HeartbeatTimeout: 10 * time.Second,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Unfinished Handler Policy in Temporal PHP\nDESCRIPTION: Shows how to configure the unfinished policy for Update and Signal handlers to suppress warnings when handlers are abandoned at Workflow completion.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_19\n\nLANGUAGE: php\nCODE:\n```\n#[UpdateMethod(unfinishedPolicy: HandlerUnfinishedPolicy::Abandon)]\npublic function myUpdate()\n{\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RegisterWorkflowOptions in Go\nDESCRIPTION: Demonstrates how to set options when registering a Workflow with a Worker. Options include customizing the Workflow Type name and disabling checks for already registered workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_49\n\nLANGUAGE: go\nCODE:\n```\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := workflow.RegisterOptions{\n  DisableAlreadyRegisteredCheck: `false`,\n  // ...\n}\nw.RegisterWorkflowWithOptions(YourWorkflowDefinition, registerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Workflow Interceptors in TypeScript\nDESCRIPTION: This snippet shows the structure of a file (e.g., `your-interceptors.ts`) used to define and export Workflow interceptors. It exports an `interceptors` function which returns an object containing arrays for `outbound` and `inbound` interceptors. It instantiates `ActivityLogInterceptor` (using `workflowInfo` to get the `workflowType`) and places it in the `outbound` array.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/interceptors.mdx#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { workflowInfo } from '@temporalio/workflow';\n\nexport const interceptors = () => ({\n  outbound: [new ActivityLogInterceptor(workflowInfo().workflowType)],\n  inbound: [],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Temporal Workflow in Go\nDESCRIPTION: A simple example of a Temporal Workflow function in Go. This function takes a context parameter and returns an error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc LoanApplication(ctx context.Context) (error) {\n    // ...\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Shielding Activities from Cancellation in Temporal TypeScript\nDESCRIPTION: This snippet shows how to shield an activity from cancellation by starting it in a nonCancellable scope, even when it's awaited in a cancellable scope. The activity is protected from cancellation because it's bound to the nonCancellable scope where it was created.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function shieldAwaitedInRootScope(): Promise<any> {\n  let p: Promise<any> | undefined = undefined;\n\n  await CancellationScope.nonCancellable(async () => {\n    p = httpGetJSON('http://example.com'); // <-- Start activity in nonCancellable scope without awaiting completion\n  });\n  // Activity is shielded from cancellation even though it is awaited in the cancellable root scope\n  return p;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nexus Service Contract in Java\nDESCRIPTION: Java interface defining the Nexus Service contract. It includes enums, input/output classes for operations, and method declarations for 'hello' and 'echo' operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n@Service\npublic interface NexusService {\n  enum Language {\n    EN,\n    FR,\n    DE,\n    ES,\n    TR\n  }\n\n  class HelloInput {\n    private final String name;\n    private final Language language;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public HelloInput(\n        @JsonProperty(\"name\") String name, @JsonProperty(\"language\") Language language) {\n      this.name = name;\n      this.language = language;\n    }\n\n    @JsonProperty(\"name\")\n    public String getName() {\n      return name;\n    }\n\n    @JsonProperty(\"language\")\n    public Language getLanguage() {\n      return language;\n    }\n  }\n\n  class HelloOutput {\n    private final String message;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public HelloOutput(@JsonProperty(\"message\") String message) {\n      this.message = message;\n    }\n\n    @JsonProperty(\"message\")\n    public String getMessage() {\n      return message;\n    }\n  }\n\n  class EchoInput {\n    private final String message;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public EchoInput(@JsonProperty(\"message\") String message) {\n      this.message = message;\n    }\n\n    @JsonProperty(\"message\")\n    public String getMessage() {\n      return message;\n    }\n  }\n\n  class EchoOutput {\n    private final String message;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public EchoOutput(@JsonProperty(\"message\") String message) {\n      this.message = message;\n    }\n\n    @JsonProperty(\"message\")\n    public String getMessage() {\n      return message;\n    }\n  }\n\n  @Operation\n  HelloOutput hello(HelloInput input);\n\n  @Operation\n  EchoOutput echo(EchoInput input);\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Workflow Type in Go with Temporal SDK\nDESCRIPTION: Shows how to register a Workflow with a custom name by using RegisterOptions. The Workflow Type name can be different from the function name when registered with a Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"log\"\n\n    \"go.temporal.io/sdk/activity\"\n    \"go.temporal.io/sdk/client\"\n    \"go.temporal.io/sdk/worker\"\n    \"go.temporal.io/sdk/workflow\"\n\n    \"documentation-samples-go/yourapp\"\n)\n// ...\nfunc main() {\n// ...\n    yourWorker := worker.New(temporalClient, \"your-custom-task-queue-name\", worker.Options{})\n// ...\n    // Use RegisterOptions to set the name of the Workflow Type for example.\n    registerWFOptions := workflow.RegisterOptions{\n        Name: \"JustAnotherWorkflow\",\n    }\n    yourWorker.RegisterWorkflowWithOptions(yourapp.YourSimpleWorkflowDefinition, registerWFOptions)\n// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PostPatchActivity in .NET Temporal Workflow\nDESCRIPTION: This snippet demonstrates the updated implementation of a Workflow using PostPatchActivity. It shows the desired end state after the versioning process.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/versioning.mdx#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        this.result = await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.PostPatchActivity(),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering a Scheduled Workflow in .NET\nDESCRIPTION: This snippet illustrates how to trigger an immediate execution of a Scheduled Workflow using the TriggerAsync method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nawait handle.TriggerAsync();\n```\n\n----------------------------------------\n\nTITLE: Skipping Python Sandbox Restrictions for a Code Block\nDESCRIPTION: This snippet demonstrates how to temporarily disable the Temporal sandbox restrictions for a specific block of Python code within a Workflow using the `temporalio.workflow.unsafe.sandbox_unrestricted()` context manager. Code executed within this block will not be subject to the sandbox's determinism checks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nwith temporalio.workflow.unsafe.sandbox_unrestricted():\n    # Your code\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Codec Server Decode Request Body Structure in JSON\nDESCRIPTION: This JSON snippet exemplifies the structure of the POST request body sent to the `/decode` endpoint of a custom Codec Server. It contains an array of `payloads`, where each payload object includes `metadata` (with a base64 encoded encoding hint) and `data` (the potentially encrypted and base64 encoded payload data). The Codec Server uses this structure to receive and process payloads for decoding.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"payloads\": [{\n    \"metadata\": {\n      \"encoding\": <base64EncodedEncodingHint>\n    },\n    \"data\": <encryptedPayloadData>\n  }, ...]\n}\n```\n\n----------------------------------------\n\nTITLE: Workflow .editorconfig Configuration for C# Development\nDESCRIPTION: This configuration snippet shows recommended .editorconfig settings for Temporal Workflow development in C#. It disables specific analyzer rules that conflict with Temporal Workflow development patterns, such as those related to task scheduling, async/await usage, and other Workflow-specific requirements.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n##### Configuration specific for Temporal workflows #####\n[*.workflow.cs]\n\n# We use getters for queries, they cannot be properties\ndotnet_diagnostic.CA1024.severity = none\n\n# Don't force workflows to have static methods\ndotnet_diagnostic.CA1822.severity = none\n\n# Do not need ConfigureAwait for workflows\ndotnet_diagnostic.CA2007.severity = none\n\n# Do not need task scheduler for workflows\ndotnet_diagnostic.CA2008.severity = none\n\n# Workflow randomness is intentionally deterministic\ndotnet_diagnostic.CA5394.severity = none\n\n# Allow async methods to not have await in them\ndotnet_diagnostic.CS1998.severity = none\n\n# Don't avoid, but rather encourage things using TaskScheduler.Current in workflows\ndotnet_diagnostic.VSTHRD105.severity = none\n```\n\n----------------------------------------\n\nTITLE: Getting Synchronous Workflow Execution Results in Java\nDESCRIPTION: Demonstrates how to execute a Workflow synchronously and wait for its results. The client thread blocks until the Workflow Execution completes or fails, and returns the result or error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_21\n\nLANGUAGE: java\nCODE:\n```\n FileProcessingWorkflow workflow = client.newWorkflowStub(\n                FileProcessingWorkflow.class,\n                WorkflowOptions.newBuilder()\n                        .setWorkflowId(workflowId)\n                        .setTaskQueue(taskQueue)\n                        .build();\n\n// start sync and wait for results (or failure)\nString result = workflow.processfile(new Argument());\n```\n\n----------------------------------------\n\nTITLE: Configuring Metrics Handler in Go SDK\nDESCRIPTION: This snippet demonstrates how to create a metrics handler from Client Options and specify a listener address for Prometheus in the Temporal Go SDK. It uses the sdktally package to create a new metrics handler with Prometheus configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nclient.Options{\n\t\tMetricsHandler: sdktally.NewMetricsHandler(newPrometheusScope(prometheus.Configuration{\n\t\t\tListenAddress: \"0.0.0.0:9090\",\n\t\t\tTimerType:     \"histogram\",\n\t\t}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Handler Unfinished Policy in C# Temporal Workflows\nDESCRIPTION: This code shows how to configure a Workflow Update handler with HandlerUnfinishedPolicy.Abandon to silence warnings about unfinished handlers. This is useful when you intentionally allow a handler to be abandoned when a Workflow completes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowUpdate(UnfinishedPolicy = HandlerUnfinishedPolicy.Abandon)]\npublic async Task MyUpdateAsync()\n{\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Importing Certificate Filters with Resource Version in Temporal Cloud CLI\nDESCRIPTION: Command to import certificate filters using a specific resource version (ETag) to ensure the import updates from the correct version of the resource.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters import \\\n    --resource-version <etag> \\\n    --certificate-filter-input <json>\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom PayloadCodec Interface in TypeScript\nDESCRIPTION: Specifies the TypeScript interface for creating custom Payload Codecs. Implementations must provide `encode` and `decode` async methods, which transform arrays of Payloads. This allows for operations like encryption, compression, or offloading outside the Workflow sandbox, as Codecs are not subject to its restrictions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface PayloadCodec {\n  /**\n   * Encode an array of {@link Payload}s for sending over the wire.\n   * @param payloads May have length 0.\n   */\n  encode(payloads: Payload[]): Promise<Payload[]>;\n\n  /**\n   * Decode an array of {@link Payload}s received from the wire.\n   */\n  decode(payloads: Payload[]): Promise<Payload[]>;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing PrivateLink with API Key Authentication (Temporal CLI)\nDESCRIPTION: Command to test AWS PrivateLink connectivity using the Temporal CLI with API key authentication. It demonstrates how to set the TLS server name and use the API key for namespace authentication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/aws-privatelink.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow count \\\n    --address <DNS associated with VPC endpoint>:7233 \\\n    --namespace <namespace>.<account> \\\n    --api-key <api_key> \\\n    --tls-server-name <region>.<cloud_provider>.api.temporal.io \\\n    --tls\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow Execution with Typed Workflow Stub - Temporal PHP\nDESCRIPTION: Illustrates starting a Workflow Execution using a typed Workflow stub and Temporal Client in PHP. The snippet demonstrates creating a stub from a type-safe interface, starting a Workflow, invoking Workflow update methods, and then committing changes. Dependencies include the WorkflowClient instance, the Workflow interface, and relevant domain types for transfer details. The expected inputs are account references and transfer amounts; outputs are execution effects in the Temporal platform.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_5\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newWorkflowStub(AccountTransferWorkflowInterface::class);\\n\\n$workflowClient->start($stub, $transactionId);\\n$stub->move($from1, $to1, $amount1);\\n$stub->move($from2, $to2, $amount2);\\n$stub->commit();\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client with Custom EJSON PayloadConverter in TypeScript\nDESCRIPTION: Demonstrates how to create a Temporal Client configured to use the custom payloadConverter for EJSON serialization of workflow arguments. Depends on Client from @temporalio/client and the exported payloadConverter. Requires payloadConverterPath as a configuration parameter. Returns a Client instance; all started workflows serialize arguments using the custom EJSON logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  dataConverter: {\n    payloadConverterPath: require.resolve('./payload-converter'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistence Layer with Multiple Datastores in YAML\nDESCRIPTION: This YAML snippet illustrates how to configure the persistence layer in `development.yaml`. It defines the primary (`defaultStore`), visibility (`visibilityStore`), and optional secondary visibility (`secondaryVisibilityStore`) stores, specifies the number of history shards (`numHistoryShards`), and provides connection details for different named datastores (`datastores`), such as Cassandra (`default`, `cass-visibility`) and Elasticsearch (`es-visibility`), including hosts, keyspaces, credentials, version, URL, indices and connection settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  defaultStore: default\n  visibilityStore: cass-visibility # The primary Visibility store.\n  secondaryVisibilityStore: es-visibility # A secondary Visibility store added to enable Dual Visibility.\n  numHistoryShards: 512\n  datastores:\n    default:\n      cassandra:\n        hosts: '127.0.0.1'\n        keyspace: 'temporal'\n        user: 'username'\n        password: 'password'\n    cass-visibility:\n      cassandra:\n        hosts: '127.0.0.1'\n        keyspace: 'temporal_visibility'\n    es-visibility:\n      elasticsearch:\n        version: 'v7'\n        logLevel: 'error'\n        url:\n          scheme: 'http'\n          host: '127.0.0.1:9200'\n        indices:\n          visibility: temporal_visibility_v1_dev\n        closeIdleConnectionsInterval: 15s\n```\n\n----------------------------------------\n\nTITLE: Implementing EncryptionCodec with PayloadCodec Interface in TypeScript\nDESCRIPTION: A class that implements the PayloadCodec interface to provide encryption and decryption of Temporal payloads. It handles encrypting entire payloads while preserving metadata, and includes key management functionality.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  METADATA_ENCODING_KEY,\n  Payload,\n  PayloadCodec,\n  ValueError,\n} from '@temporalio/common';\nimport { decode, encode } from '@temporalio/common/lib/encoding';\nimport { temporal } from '@temporalio/proto';\nimport { webcrypto as crypto } from 'node:crypto';\nimport { decrypt, encrypt } from './crypto';\n\nconst ENCODING = 'binary/encrypted';\nconst METADATA_ENCRYPTION_KEY_ID = 'encryption-key-id';\n\nexport class EncryptionCodec implements PayloadCodec {\n  constructor(\n    protected readonly keys: Map<string, crypto.CryptoKey>,\n    protected readonly defaultKeyId: string,\n  ) {}\n\n  static async create(keyId: string): Promise<EncryptionCodec> {\n    const keys = new Map<string, crypto.CryptoKey>();\n    keys.set(keyId, await fetchKey(keyId));\n    return new this(keys, keyId);\n  }\n\n  async encode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => ({\n        metadata: {\n          [METADATA_ENCODING_KEY]: encode(ENCODING),\n          [METADATA_ENCRYPTION_KEY_ID]: encode(this.defaultKeyId),\n        },\n        // Encrypt entire payload, preserving metadata\n        data: await encrypt(\n          temporal.api.common.v1.Payload.encode(payload).finish(),\n          this.keys.get(this.defaultKeyId)!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        ),\n      })),\n    );\n  }\n\n  async decode(payloads: Payload[]): Promise<Payload[]> {\n    return Promise.all(\n      payloads.map(async (payload) => {\n        if (\n          !payload.metadata\n          || decode(payload.metadata[METADATA_ENCODING_KEY]) !== ENCODING\n        ) {\n          return payload;\n        }\n        if (!payload.data) {\n          throw new ValueError('Payload data is missing');\n        }\n\n        const keyIdBytes = payload.metadata[METADATA_ENCRYPTION_KEY_ID];\n        if (!keyIdBytes) {\n          throw new ValueError(\n            'Unable to decrypt Payload without encryption key id',\n          );\n        }\n\n        const keyId = decode(keyIdBytes);\n        let key = this.keys.get(keyId);\n        if (!key) {\n          key = await fetchKey(keyId);\n          this.keys.set(keyId, key);\n        }\n        const decryptedPayloadBytes = await decrypt(payload.data, key);\n        console.log('Decrypting payload.data:', payload.data);\n        return temporal.api.common.v1.Payload.decode(decryptedPayloadBytes);\n      }),\n    );\n  }\n}\n\nasync function fetchKey(_keyId: string): Promise<crypto.CryptoKey> {\n  // In production, fetch key from a key management system (KMS). You may want to memoize requests if you'll be decoding\n  // Payloads that were encrypted using keys other than defaultKeyId.\n  const key = Buffer.from('test-key-test-key-test-key-test!');\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    key,\n    {\n      name: 'AES-GCM',\n    },\n    true,\n    ['encrypt', 'decrypt'],\n  );\n\n  return cryptoKey;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Namespace using Go SDK\nDESCRIPTION: Creates a new Namespace on the Temporal Service using the NamespaceClient interface. Requires setting a mandatory Workflow Execution Retention Period with minimum value of 1 day.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/namespaces.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nclient, err := client.NewNamespaceClient(client.Options{HostPort: ts.config.ServiceAddr})\n        //...\n    err = client.Register(ctx, &workflowservice.RegisterNamespaceRequest{\n        Namespace: your-namespace-name,\n        WorkflowExecutionRetentionPeriod: &retention,\n    })\n```\n\n----------------------------------------\n\nTITLE: Handling Progress Recording in Custom Temporal Archiver (Go)\nDESCRIPTION: Demonstrates how to use `ArchiverOptions` and `FeatureCatalog` within a custom Temporal Archiver's `Archive` method in Go to load previously recorded progress and save the current progress, allowing retries to resume efficiently. It checks if the `ProgressManager` feature is enabled before attempting to load or record progress.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc(a * Archiver) Archive(ctx context.Context, URI string, request * ArchiveRequest, opts...ArchiveOption) error {\n    featureCatalog: = GetFeatureCatalog(opts...) // this function is defined in options.go\n    var progress progress\n    // Check if the feature for recording progress is enabled.\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.LoadProgress(ctx, & prevProgress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n\n    // Your archiver implementation...\n\n    // Record current progress\n    if featureCatalog.ProgressManager != nil {\n        if err: = featureCatalog.ProgressManager.RecordProgress(ctx, progress);\n        err != nil {\n            // log some error message and return error if needed.\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting StartToCloseTimeout with ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to set the StartToCloseTimeout using an ActivityStub within a Workflow implementation. It's part of the ActivityOptions reference section.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_26\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n              ActivityOptions.newBuilder()\n                      .setStartToCloseTimeout(Duration.ofSeconds(2))\n                      .build());\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Direct Function Reference in Go\nDESCRIPTION: This code shows how to start a Workflow Execution when the invocation process has direct access to the Workflow function. The Workflow Type name is passed as if it were a variable, without quotations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nworkflowRun, err := temporalClient.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition, param)\n```\n\n----------------------------------------\n\nTITLE: Removing a Search Attribute from a Workflow in PHP\nDESCRIPTION: Shows how to remove a previously set Search Attribute by setting it to an empty Map using the upsertTypedSearchAttributes method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n#[Workflow\\UpdateMethod]\npublic function unsetDestinationTime()\n{\n    // Get the key for the DestinationTime attribute\n    $keyDestinationTime = SearchAttributeKey::forDatetime('DestinationTime');\n\n    Workflow::upsertTypedSearchAttributes(\n        $keyDestinationTime->valueUnset(),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Single-Entity Workflow Pattern in TypeScript\nDESCRIPTION: This TypeScript code demonstrates a Temporal Workflow implementing the single-entity pattern. It handles initial setup (`isNew`), queues updates received via a Signal (`updateSignal`), processes these updates within a loop, waits for updates using `condition` with a timeout, and uses `continueAsNew` to persist the Workflow state across executions while respecting history limits. Graceful cancellation handling is included using `CancellationScope`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/entity-pattern.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ninterface Input {\n  /* Define your Workflow input type here */\n}\ninterface Update {\n  /* Define your Workflow update type here */\n}\n\nconst MAX_ITERATIONS = 1;\n\nexport async function entityWorkflow(\n  input: Input,\n  isNew = true,\n): Promise<void> {\n  try {\n    const pendingUpdates = Array<Update>();\n    setHandler(updateSignal, (updateCommand) => {\n      pendingUpdates.push(updateCommand);\n    });\n\n    if (isNew) {\n      await setup(input);\n    }\n\n    for (let iteration = 1; iteration <= MAX_ITERATIONS; ++iteration) {\n      // Ensure that we don't block the Workflow Execution forever waiting\n      // for updates, which means that it will eventually Continue-As-New\n      // even if it does not receive updates.\n      await condition(() => pendingUpdates.length > 0, '1 day');\n\n      while (pendingUpdates.length) {\n        const update = pendingUpdates.shift();\n        await runAnActivityOrChildWorkflow(update);\n      }\n    }\n  } catch (err) {\n    if (isCancellation(err)) {\n      await CancellationScope.nonCancellable(async () => {\n        await cleanup();\n      });\n    }\n    throw err;\n  }\n  await continueAsNew<typeof entityWorkflow>(input, false);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Blocking Temporal Update Handler in Java\nDESCRIPTION: Shows an example of a blocking Update handler (`setLanguage`) within a Temporal Workflow implementation (`GreetingWorkflowImpl`). The handler calls a potentially blocking Activity (`activity.greetingService`) to fetch data. If the Activity indicates failure (returns null), it throws an `ApplicationFailure` to fail the Update. Otherwise, it updates the Workflow state (`greetings`, `this.language`) and returns the previous language.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_13\n\nLANGUAGE: java\nCODE:\n```\n```java\npublic static class GreetingWorkflowImpl implements GreetingWorkflow {\n    ...\n    @Override\n    public Language setLanguage(Language language) {\n        if (!greetings.containsKey(language)) {\n            String greeting = activity.greetingService(language);\n            if (greeting == null) {\n                // 👉 An update validator cannot be blocking, so cannot be used to check that the remote\n                // greetingService supports the requested language. Throwing an ApplicationFailure\n                // will fail the Update, but the WorkflowExecutionUpdateAccepted event will still be\n                // added to history.\n                throw ApplicationFailure.newFailure(\"Greeting service does not support: \" + language, \"GreetingFailure\")\n            }\n            greetings.put(language, greeting);\n        }\n        Language previousLanguage = this.language;\n        this.language = language;\n        return previousLanguage;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Incorrect Side Effect Implementation in Temporal Go SDK\nDESCRIPTION: This example shows an incorrect way to use the SideEffect function where the random value is modified within the function rather than returned. This breaks determinism because on replay the function is not executed again, meaning the random value will always default to 0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/side-effects.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Warning: This is an incorrect example.\n// This code is non-deterministic.\nvar random int\nworkflow.SideEffect(func(ctx workflow.Context) interface{} {\n      random = rand.Intn(100)\n      return nil\n})\n// random will always be 0 in replay, so this code is non-deterministic.\n```\n\n----------------------------------------\n\nTITLE: Configuring Cassandra Visibility Store in Temporal YAML\nDESCRIPTION: This YAML snippet shows the configuration for using Cassandra as the Visibility store (noting its deprecation). It sets 'cass-visibility' as the `visibilityStore` and defines its connection parameters under `datastores`, primarily the Cassandra host addresses and the target keyspace name ('temporal_visibility').\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n#...\npersistence:\n  #...\n  visibilityStore: cass-visibility\n  #...\n  datastores:\n    default:\n    #...\n    cass-visibility:\n      cassandra:\n        hosts: '127.0.0.1'\n        keyspace: 'temporal_visibility'\n#...\n```\n\n----------------------------------------\n\nTITLE: Configuring Task Queue Partitioning with Dynamic Config in YAML\nDESCRIPTION: These YAML snippets configure how many partitions are allocated for read and write operations on task queues in a Temporal Cluster. Each configuration key ('matching.numTaskqueueReadPartitions' and 'matching.numTaskqueueWritePartitions') accepts constraint selectors such as namespace, taskQueueName, and taskType to apply differing values for specific scenarios. It is essential that read and write partition numbers are synchronized for high-throughput queues. No extra dependencies are required, but these settings must be tested for performance impact before production deployment. The input is YAML config with entries per key/constraint combination; the output governs internal task queue partitioning.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/dynamic-configuration.mdx#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nmatching.numTaskqueueReadPartitions: # Number of Task Queue partitions for read operations.\n  - constraints: { namespace: 'namespace1', taskQueueName: 'tq' } # Applies to the \"tq\" Task Queue for both Workflows and Activities.\n    value: 8 # The default value for this key is 4. Task Queues that need to support high traffic require higher number of partitions. Set these values in accordance to your poller count.\n  - constraints: {\n        namespace: 'namespace1',\n        taskQueueName: 'other-tq',\n        taskType: 'Activity',\n      } # Applies to the \"other_tq\" Task Queue for Activities specifically.\n    value: 20\n  - constraints: { namespace: 'namespace2' } # Applies to all task queues in \"namespace2\".\n    value: 10\n  - constraints: {} # Applies to all other task queues in \"namespace1\" and all other Namespaces.\n    value: 16\nmatching.numTaskqueueWritePartitions: # Number of Task Queue partitions for write operations.\n  - constraints: { namespace: 'namespace1', taskQueueName: 'tq' } # Applies to the \"tq\" Task Queue for both Workflows and Activities.\n    value: 8 # The default value for this key is 4. Task Queues that need to support high traffic require higher number of partitions. Set these values in accordance to your poller count.\n  - constraints: {\n        namespace: 'namespace1',\n        taskQueueName: 'other-tq',\n        taskType: 'Activity',\n      } # Applies to the \"other_tq\" Task Queue for Activities specifically.\n    value: 20\n  - constraints: { namespace: 'namespace2' } # Applies to all task queues in \"namespace2\".\n    value: 10\n  - constraints: {} # Applies to all other task queues in \"namespace1\" and all other Namespaces.\n    value: 16\n```\n\n----------------------------------------\n\nTITLE: Workflow Activation Failure due to Invalid Export Structure - bash\nDESCRIPTION: Shows Temporal Worker output when a custom bundled workflow fails to export the API shape expected by the SDK, resulting in ReferenceError and activation failure. The log pinpoints runId, error, and that workflow does not exist. Useful during custom workflow code bundling or if exporting methods incorrectly.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[ERROR] Failed to activate workflow {\\n  runId: 'aaf84a83-51ce-462a-9ab7-6a641a703bff',\\n  error: ReferenceError: exports is not defined,\\n  workflowExists: false\\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Schedule for a Workflow in Go\nDESCRIPTION: This snippet illustrates how to delete a Schedule for a Workflow using the Go SDK. It uses the Delete() method on the ScheduleHandle to erase a Schedule without affecting Workflows started by it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tdefer func() {\n\t\tlog.Println(\"Deleting schedule\", \"ScheduleID\", scheduleHandle.GetID())\n\t\terr = scheduleHandle.Delete(ctx)\n\t\tif err != nil {\n\t\t\tlog.Fatalln(\"Unable to delete schedule\", err)\n\t\t}\n\t}()\n// ...\n```\n\n----------------------------------------\n\nTITLE: Recording External Activity Heartbeat in Go\nDESCRIPTION: This code shows how to record a heartbeat for an Activity from an external source using the Temporal Go SDK. It creates a Temporal client and uses the RecordActivityHeartbeat method to send a heartbeat with a task token and details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n// Record heartbeat.\nerr := temporalClient.RecordActivityHeartbeat(ctx, taskToken, details)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Bimodal Temporal Worker Entrypoint (Python)\nDESCRIPTION: This Python snippet sets up the core imports, argument parsing, and Temporal client instantiation for a bimodal Worker application that can switch between replay verification and production run modes. It requires the temporalio package and a Workflow/Activity implementation. Key parameters include the Temporal service endpoint (localhost:7233), the Task Queue, and specified Workflow and Activity classes. Inputs are command-line arguments for mode, and outputs are none at this stage. This establishes the basic structure for flexible Worker management.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/safe-deployments.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport asyncio\nfrom datetime import datetime, timedelta\n\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker, Replayer\n\nasync def main():\n    parser = argparse.ArgumentParser(prog='MyTemporalWorker')\n    parser.add_argument('mode', choices=['verify', 'run'])\n    args = parser.parse_args()\n\n    temporal_url = \"localhost:7233\"\n    task_queue = \"your-task-queue\"\n    my_workflows = [YourWorkflow]\n    my_activities = [your_activity]\n\n    client = await Client.connect(temporal_url)\n\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in Go SDK (pre v1.26.0)\nDESCRIPTION: Example of updating an API key for an existing Temporal client connection in Go SDK versions prior to 1.26.0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_10\n\nLANGUAGE: go\nCODE:\n```\napiKeyProvider.APIKey = myKeyUpdated\n```\n\n----------------------------------------\n\nTITLE: Pausing a Scheduled Workflow in .NET\nDESCRIPTION: This code demonstrates how to pause a Scheduled Workflow using the PauseAsync method, including the option to provide a reason for pausing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nawait handle.PauseAsync(\"Pausing the schedule for now\");\n```\n\n----------------------------------------\n\nTITLE: Using cancelRequested with nonCancellable Scopes\nDESCRIPTION: This example shows how to make a workflow aware of cancellation while waiting on nonCancellable scopes. It uses Promise.race to detect cancellation while allowing an activity to complete even after the workflow is cancelled.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function resumeAfterCancellation(url: string): Promise<any> {\n  let result: any = undefined;\n  const scope = new CancellationScope({ cancellable: false });\n  const promise = scope.run(() => httpGetJSON(url));\n  try {\n    result = await Promise.race([scope.cancelRequested, promise]);\n  } catch (err) {\n    if (!(err instanceof CancelledFailure)) {\n      throw err;\n    }\n    // Prevent Workflow from completing so Activity can complete\n    result = await promise;\n  }\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom JacksonJsonPayloadConverter in Temporal Java SDK\nDESCRIPTION: This snippet demonstrates constructing a JacksonJsonPayloadConverter with a custom ObjectMapper, allowing control over JSON serialization/deserialization. Developers can add custom logic or modules to the ObjectMapper as needed, and the resulting converter can be integrated into DataConverter configurations. Requires the Temporal Java SDK and Jackson ObjectMapper as dependencies.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/converters-and-encryption.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n//...\\nprivate static JacksonJsonPayloadConverter yourCustomJacksonJsonPayloadConverter() {\\n  ObjectMapper objectMapper = new ObjectMapper();\\n  // Add your custom logic here.\\n  return new JacksonJsonPayloadConverter(objectMapper);\\n}//...\\n\n```\n\n----------------------------------------\n\nTITLE: Setting WaitForCancellation in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Shows how to use the `WaitForCancellation` field in ActivityOptions, dictating if an Activity should complete running after a cancellation request is received. The value is set to `false` in this snippet, which is also the default. Requires Go Temporal workflow dependencies and a running context for execution. Standard Activity invocation and error handling patterns are used.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  WaitForCancellation: false,\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing a Dynamic Workflow (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow execute` command to request the start of a workflow of type `UnRegisterWorkflow`. It targets the `dynamic-workflow-task-queue` where the dynamic workflow worker is listening, passes the string \"SomeName\" as input, and runs in the `default` namespace. Since `UnRegisterWorkflow` might not be statically registered, it's expected to be handled by the dynamic workflow implementation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute \\\n --task-queue dynamic-workflow-task-queue \\\n --type UnRegisterWorkflow \\\n --input '\"SomeName\"' \\\n --namespace default\n```\n\n----------------------------------------\n\nTITLE: Removing Deprecated Versions in PHP Workflow\nDESCRIPTION: Illustrates how to remove support for older versions once all Workflows using those versions have completed. This helps in maintaining clean and up-to-date code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n    #[WorkflowMethod]\n    public function runAsync()\n    {\n        $version = yield Workflow::getVersion('Step 1', minSupported: 2, maxSupported: 2);\n\n        $result = yield $this->activity->anotherPatchActivity();\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a Nexus Service Contract in Go\nDESCRIPTION: Go code that defines a Nexus Service contract with a service name and operation, along with input and output types for the Echo operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// ...\n\nconst HelloServiceName = \"my-hello-service\"\n\n// Echo operation\nconst EchoOperationName = \"echo\"\n\ntype EchoInput struct {\n\tMessage string\n}\n\ntype EchoOutput EchoInput\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker with Build ID for Versioning in Go\nDESCRIPTION: This snippet shows how to enable Worker Versioning by assigning a Build ID to a worker and turning on the versioning feature. The worker won't receive tasks until assignment rules are set up.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n   BuildID: buildID,\n   UseBuildIDForVersioning: true,\n// ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Adding a Memo to a Workflow in Go\nDESCRIPTION: This snippet demonstrates how to attach arbitrary, non-indexed metadata (a memo) to a Workflow Execution at startup in Go. It sets the `Memo` field in `client.StartWorkflowOptions` to a `map[string]interface{}` containing the desired key-value pairs. Memos are visible in the UI and API but not searchable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_14\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  Memo: map[string]interface{}{\n    \"description\": \"Test search attributes workflow\",\n  },\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Returning Results from a Workflow Execution in TypeScript\nDESCRIPTION: This snippet shows how to return results from a Workflow Execution. It demonstrates accessing workflow information and returning a formatted string with workflow execution data.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nreturn 'Completed ' + wf.workflowInfo().workflowId + ', Total Charged: '\n  + totalCharged;\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace in Temporal Java SDK\nDESCRIPTION: This code snippet demonstrates how to delete a Namespace using the DeleteNamespace API. Deleting a Namespace removes all running and completed Workflow Executions from the persistence and visibility stores.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n//...\nDeleteNamespaceResponse res =\nOperatorServiceStubs.newServiceStubs(OperatorServiceStubsOptions.newBuilder()\n        .setChannel(service.getRawChannel())\n        .validateAndBuildWithDefaults())\n    .blockingStub()\n    .deleteNamespace(DeleteNamespaceRequest.newBuilder().setNamespace(\"your-namespace-name\").build());\n//...\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Workflow in Java\nDESCRIPTION: Example of implementing a Dynamic Workflow using the DynamicWorkflow interface in Temporal Java SDK. The execute method takes EncodedValues as input and is called for any unregistered Workflow type.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_20\n\nLANGUAGE: java\nCODE:\n```\npublic class MyDynamicWorkflow implements DynamicWorkflow {\n   @Override\n    public Object execute(EncodedValues args) {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Workflow Execution Details and Result - Temporal PHP\nDESCRIPTION: Shows how to obtain information and await results from a WorkflowRun object after starting a Workflow with the Temporal PHP SDK. The snippet covers retrieving identifiers, describing the Workflow Execution, and blocking for a result with a timeout. Necessary dependencies include a WorkflowRun instance (from an asynchronous Workflow start) and access to execution parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_10\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$run = $workflowClient->start($accountTransfer, 'fromID', 'toID', 'refID', 1000);\\n\\n// Get the Workflow ID\\nvar_dump($run->getExecution()->getID());\\n\\n// Describe the Workflow Execution\\nvar_dump($run->describe());\\n\\n// Wait for the Workflow to complete and get the result with 10-second timeout\\nvar_dump($run->getResult(timeout: 10));\\n\n```\n\n----------------------------------------\n\nTITLE: Registering Activities with Dependencies in Temporal PHP\nDESCRIPTION: This code shows how to register an Activity that requires external dependencies. It uses a factory callback that accepts a ReflectionClass instance and creates the activity using a dependency container.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_17\n\nLANGUAGE: php\nCODE:\n```\n$worker->registerActivity(\n    App\\DemoActivity::class,\n    fn(ReflectionClass $class) => $container->create($class->getName())\n);\n```\n\n----------------------------------------\n\nTITLE: Defining an Update Handler with a Custom Name in Temporal PHP\nDESCRIPTION: Illustrates how to assign a custom name ('pause') to an Update handler method `pauseProcessing` within a PHP Workflow interface. This is achieved using the `name` parameter of the `#[UpdateMethod(name: 'pause')]` attribute. This overrides the default naming convention where the Update type would match the method name (`pauseProcessing`). Requires the `Temporal\\Workflow\\WorkflowInterface` and `Temporal\\Workflow\\UpdateMethod` attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_10\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    public function processFiles(FileList $files);\n\n    #[UpdateMethod(name: 'pause')]\n    public function pauseProcessing(): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Reply URL for Microsoft Entra ID SAML Integration\nDESCRIPTION: Shows a concrete example of a correctly formatted Reply URL (Assertion Consumer Service URL) for Temporal Cloud SAML integration using Microsoft Entra ID. This example uses 'f45a2' as the placeholder Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhttps://login.tmprl.cloud/login/callback?connection=f45a2-saml\n```\n\n----------------------------------------\n\nTITLE: Adding New Build ID to Existing Compatible Set via Task Queue Update (Legacy)\nDESCRIPTION: This snippet demonstrates adding a new `buildId` ('deadbeef') to an existing compatible version set on a Task Queue using the deprecated `client.taskQueue.updateBuildIdCompatibility` method. The `addNewCompatibleVersion` operation targets the set containing `existingCompatibleBuildId` and adds 'deadbeef' to it, marking 'deadbeef' as the new default Build ID within that specific set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nawait client.taskQueue.updateBuildIdCompatibility('your_task_queue_name', {\n  operation: 'addNewCompatibleVersion',\n  buildId: 'deadbeef',\n  existingCompatibleBuildId: 'some-existing-build-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Building a Multi-Platform Docker Image using Bash\nDESCRIPTION: This Bash command uses `docker buildx build` to create the Docker image defined by the Dockerfile in the current directory (`.`). It explicitly targets the `linux/amd64` platform, which is common for EKS nodes, and tags the resulting image as `your-app`. This ensures compatibility when deploying to the Kubernetes cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ndocker buildx build \\\n    --platform linux/amd64 \\\n    -t your-app .\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an Update Validator Method in Temporal PHP Workflow Interface\nDESCRIPTION: Shows how to define an Update Validator method `addGreetingValidator` associated with the `addGreeting` Update handler using the `#[UpdateValidatorMethod(forUpdate: 'addGreeting')]` attribute within a PHP Workflow interface (`GreetingWorkflow`). The validator method must accept the same input parameters as the Update handler it validates (here, `string $name`). It should return `void` and throw an exception if the validation criteria are not met. Requires the `Temporal\\Workflow\\WorkflowInterface`, `Temporal\\Workflow\\UpdateMethod`, and `Temporal\\Workflow\\UpdateValidatorMethod` attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_12\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface GreetingWorkflow {\n    #[WorkflowMethod]\n    public function getGreetings(): array;\n\n    #[UpdateMethod]\n    public function addGreeting(string $name): int;\n\n    #[UpdateValidatorMethod(forUpdate: 'addGreeting')]\n    public function addGreetingValidator(string $name): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity with Heartbeat Recovery in Go\nDESCRIPTION: This snippet illustrates how to implement an Activity that can recover from a failure using heartbeat details. It checks for existing heartbeat details, resumes from the last recorded progress, and continues to record heartbeats as it processes items.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/failure-detection.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc SampleActivity(ctx context.Context, inputArg InputParams) error {\n    startIdx := inputArg.StartIndex\n    if activity.HasHeartbeatDetails(ctx) {\n        // Recover from finished progress.\n        var finishedIndex int\n        if err := activity.GetHeartbeatDetails(ctx, &finishedIndex); err == nil {\n            startIdx = finishedIndex + 1 // Start from next one.\n        }\n    }\n\n    // Normal Activity logic...\n    for i:=startIdx; i<inputArg.EndIdx; i++ {\n        // Code for processing item i goes here...\n        activity.RecordHeartbeat(ctx, i) // Report progress.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Archival Providers - Temporal Service - YAML\nDESCRIPTION: Sets the Archival configuration in the Temporal Service by specifying providers, file permissions, and default Namespace behaviors. Requires editing of the config/development.yaml file. Parameters include state (enabled/disabled), provider settings for filestore and gstorage, credential paths, file and directory modes, and default Namespace URI. Inputs are YAML configuration values; outputs are service-level archival settings. Limitation: Only takes effect after Temporal service reload.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Temporal Service level Archival config\\narchival:\\n  # Event History configuration\\n  history:\\n    # Archival is enabled at the Temporal Service level\\n    state: 'enabled'\\n    enableRead: true\\n    # Namespaces can use either the local filestore provider or the Google Cloud provider\\n    provider:\\n      filestore:\\n        fileMode: '0666'\\n        dirMode: '0766'\\n      gstorage:\\n        credentialsPath: '/tmp/gcloud/keyfile.json'\\n\\n# Default values for a Namespace if none are provided at creation\\nnamespaceDefaults:\\n  # Archival defaults\\n  archival:\\n    # Event History defaults\\n    history:\\n      state: 'enabled'\\n      # New Namespaces will default to the local provider\\n      URI: 'file:///tmp/temporal_archival/development'\\n\n```\n\n----------------------------------------\n\nTITLE: Promoting a Compatible Set to Default using Python SDK (Deprecated)\nDESCRIPTION: Demonstrates using the deprecated `client.update_worker_build_id_compatibility` method with `BuildIdOpPromoteSetByBuildId`. This promotes the entire compatible version set containing the specified Build ID (`deadbeef`) to become the default set for the Task Queue. New Workflow Executions will then start on the default Build ID associated with this newly promoted set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# ...\nawait client.update_worker_build_id_compatibility(\n    \"your_task_queue_name\", BuildIdOpPromoteSetByBuildId(\"deadbeef\")\n)\n```\n\n----------------------------------------\n\nTITLE: Setting RetryOptions via ActivityStub in Java\nDESCRIPTION: This snippet demonstrates configuring a custom Retry Policy (Retry Options) for an Activity using `ActivityOptions.newBuilder().setRetryOptions()` when creating an `ActivityStub`. It sets initial and maximum retry intervals. A `StartToCloseTimeout` is also required. Dependencies include `io.temporal.activity.ActivityOptions`, `io.temporal.common.RetryOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_32\n\nLANGUAGE: java\nCODE:\n```\nprivate final ActivityOptions options =\n    ActivityOptions.newBuilder()\n        // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n        // required when setting Activity options.\n        .setStartToCloseTimeout(Duration.ofSeconds(5))\n        .setRetryOptions(\n            RetryOptions.newBuilder()\n                .setInitialInterval(Duration.ofSeconds(1))\n                .setMaximumInterval(Duration.ofSeconds(10))\n                .build())\n        .build();\n```\n\n----------------------------------------\n\nTITLE: Cloning and Building tcld from Source (bash)\nDESCRIPTION: These commands clone the tcld source code repository from GitHub, navigate into the cloned directory, and then compile the tcld executable using the `make` command. This process requires Git, Go 1.18+, and Make to be installed on the system. The compiled `tcld` binary will be placed in the current directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/index.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/temporalio/tcld.git\ncd tcld\nmake\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Timeouts in PHP\nDESCRIPTION: This snippet demonstrates how to configure Workflow timeouts (Execution, Run, Task) when creating a Workflow stub using `WorkflowOptions` in the Temporal PHP SDK. It specifically shows setting the `WorkflowExecutionTimeout` while commenting out the Run and Task timeouts. Dependencies include the Temporal PHP SDK (`WorkflowOptions`, `WorkflowIdReusePolicy`) and Carbon for time intervals (`CarbonInterval`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$workflow = $this->workflowClient->newWorkflowStub(\n    DynamicSleepWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowId(DynamicSleepWorkflow::WORKFLOW_ID)\n        ->withWorkflowIdReusePolicy(WorkflowIdReusePolicy::WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE)\n        // Set Workflow Timeout duration\n        ->withWorkflowExecutionTimeout(CarbonInterval::minutes(2))\n        // ->withWorkflowRunTimeout(CarbonInterval::minute(2))\n        // ->withWorkflowTaskTimeout(CarbonInterval::minute(2))\n);\n```\n\n----------------------------------------\n\nTITLE: Checking Workflow Type in Dynamic Workflow Implementation in Java\nDESCRIPTION: This snippet shows how to check the Workflow type when executing a Dynamic Workflow. It uses the getWorkflowType() method to retrieve the type at runtime.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nString type = Workflow.getInfo().getWorkflowType();\n```\n\n----------------------------------------\n\nTITLE: Removing Python Sandbox Restriction for a Specific Module Member\nDESCRIPTION: This Python code shows how to customize the Temporal sandbox restrictions to allow access to a typically restricted member, specifically `datetime.date.today()`. It involves creating modified restrictions by replacing the default `invalid_module_members` using `SandboxRestrictions.default.with_child_unrestricted()` and then passing these custom restrictions to the `SandboxedWorkflowRunner` when initializing the Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n```python\nmy_restrictions = dataclasses.replace(\n    SandboxRestrictions.default,\n    invalid_module_members=SandboxRestrictions.invalid_module_members_default.with_child_unrestricted(\n      \"datetime\", \"date\", \"today\",\n    ),\n)\nmy_worker = Worker(..., workflow_runner=SandboxedWorkflowRunner(restrictions=my_restrictions))\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes ConfigMap using Bash\nDESCRIPTION: This Bash command uses `kubectl apply` to create or update the Kubernetes resource defined in the `config-map.yaml` file. The `-f` flag specifies the file path, and the `--namespace` flag ensures the ConfigMap is applied within the `your-namespace` namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nkubectl apply -f config-map.yaml \\\n    --namespace your-namespace\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Kubernetes Namespace using Bash\nDESCRIPTION: This Bash command uses `kubectl create namespace` to create a new namespace named `your-namespace` within the configured Kubernetes cluster. Namespaces provide a way to scope resources and isolate applications within a cluster. The Temporal Worker deployment and its related resources will be placed in this namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nkubectl create namespace your-namespace\n```\n```\n\n----------------------------------------\n\nTITLE: Pausing and Unpausing a Schedule for a Workflow in Go\nDESCRIPTION: This code demonstrates how to pause and unpause a Schedule for a Workflow using the Go SDK. It uses the Pause() and Unpause() methods on the ScheduleHandle to control future Workflow Runs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\terr = scheduleHandle.Pause(ctx, client.SchedulePauseOptions{\n\t\tNote: \"The Schedule has been paused.\",\n\t})\n// ...\n\terr = scheduleHandle.Unpause(ctx, client.ScheduleUnpauseOptions{\n\t\tNote: \"The Schedule has been unpaused.\",\n\t})\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with TLS Config Provider in Go\nDESCRIPTION: Illustrates how to override the default TLS configuration in Temporal Server using temporal.WithTLSConfigFactory(yourTLSConfigProvider). This allows custom certificate management via a TLSConfigProvider (from go.temporal.io/server/common/rpc/encryption). Precondition: yourTLSConfigProvider implements the required provider interface; ensures secure communication in the deployment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.WithTLSConfigFactory(yourTLSConfigProvider),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Checking History Size Against Error Limit in Temporal (Go)\nDESCRIPTION: Go code snippet from the Temporal history service (`workflowExecutionContext.go`) showing the condition check for Workflow Execution history size against the configured error limit (default 50 MB). An error occurs, potentially terminating the Workflow, if the size exceeds this limit.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nif mutableState.GetHistorySize() > h.config.HistorySizeLimitError() || mutableState.GetExecutionInfo().ExecutionStats.HistorySize > h.config.HistorySizeLimitError() || int64(mutableState.GetNextEventID()-1) > h.config.HistoryCountLimitError() {\n```\n\n----------------------------------------\n\nTITLE: Overriding Dynamic Configuration Keys in YAML\nDESCRIPTION: This YAML snippet provides a template for configuring dynamic configuration keys and their values for a Temporal Cluster. It allows for specifying general and constrained overrides by namespace or task queues. The snippet covers various property keys, demonstrating value assignment for boolean, duration, float, and map types, as well as nested structures. There are no dependencies beyond Temporal's configuration loader. Key parameters include 'value' and optional 'constraints' for scoping overrides. Inputs are key-value objects per configuration key; outputs are applied overrides in the Temporal Cluster. All constraints are optional and act as selectors for the configuration scope.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/dynamic-configuration.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntestGetBoolPropertyKey:\n  - value: false\n  - value: true\n    constraints:\n      namespace: 'your-namespace'\n  - value: false\n    constraints:\n      namespace: 'your-other-namespace'\ntestGetDurationPropertyKey:\n  - value: '1m'\n    constraints:\n      namespace: 'your-namespace'\n      taskQueueName: 'longIdleTimeTaskqueue'\ntestGetFloat64PropertyKey:\n  - value: 12.0\n    constraints:\n      namespace: 'your-namespace'\ntestGetMapPropertyKey:\n  - value:\n      key1: 1\n      key2: 'value 2'\n      key3:\n        - false\n        - key4: true\n          key5: 2.0\n```\n\n----------------------------------------\n\nTITLE: Specifying Versioning Intent for Activities in Go\nDESCRIPTION: This code demonstrates how to override the default versioning behavior by specifying a VersioningIntent for an Activity. This example configures an activity to use the latest assignment rules rather than inheriting from its parent workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// ...\nao := workflow.ActivityOptions{\n    VersioningIntent: VersioningIntentUseAssignmentRules,\n    // ...other options\n}\nactivityCtx := workflow.WithActivityOptions(ctx, ao)\nvar yourActivityResult YourActivityResultType\nerr := workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Triggering a Temporal Scheduled Workflow Execution in Python\nDESCRIPTION: This snippet shows how to connect to a Temporal Client, get a handle for an existing Schedule using its ID, and then trigger an immediate execution of that Scheduled Workflow using the `trigger()` asynchronous method. This is useful for running a scheduled task outside its regular interval, subject to the Schedule's Overlap Policy.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# ...\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    handle = client.get_schedule_handle(\n        \"workflow-schedule-id\",\n    )\n\n    await handle.trigger()\n```\n\n----------------------------------------\n\nTITLE: Implementing Queryable Sleep Workflow\nDESCRIPTION: Workflow implementation with a query handler to track the number of elapsed days during sleep operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sleep } from '@temporalio/workflow';\nimport { defineQuery, setHandler } from '@temporalio/workflow';\n\nexport const daysQuery = defineQuery('days');\n\nexport async function sleeperWorkflow() {\n  let numDays = 0;\n\n  setHandler(daysQuery, () => numDays);\n\n  for (let i = 0; i < 100; i++) {\n    await sleep('1 day');\n    numDays++;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Activity Cancellation in .NET\nDESCRIPTION: Shows how to explicitly cancel an Activity within a Workflow using CancellationTokenSource. Includes example of linking cancellation to workflow cancellation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/cancellation.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowRun]\npublic async Task RunAsync()\n{\n    using var cancelActivitySource = CancellationTokenSource.CreateLinkedTokenSource(\n        Workflow.CancellationToken);\n\n    var activityTask = Workflow.ExecuteActivityAsync(\n        (MyActivities a) => a.MyNormalActivity(),\n        new()\n        {\n            ScheduleToCloseTimeout = TimeSpan.FromMinutes(5),\n            CancellationToken = cancelActivitySource.Token;\n        });\n    activityTask.Start();\n\n    await Workflow.DelayAsync(TimeSpan.FromMinutes(5));\n    cancelActivitySource.Cancel();\n\n    await activityTask;\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying PromQL-to-Datadog with Helm Including Certificate Files - Bash\nDESCRIPTION: This Bash command deploys the prometheus-to-datadog integration using Helm with several configuration parameters, including the Prometheus endpoint URL, Datadog API key, querying interval, and file paths for the certificate and key. It assumes the user has updated the certificate and key paths appropriately and set required environment variables (ACCOUNT_ID, DD_API_KEY). Inputs: ACCOUNT_ID, DD_API_KEY, certificate/key paths. Outputs: Helm release deployment in Kubernetes. Dependencies: Helm CLI, Kubernetes (Minikube), certificate files.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nhelm install promqltodd . \\\\n  --set prom_endpoint=https://${ACCOUNT_ID}.tmprl.cloud/prometheus \\\\n  --set dd_api_key=${DD_API_KEY} \\\\n  --set query_interval_seconds=15 \\\\n  --set-file 'ca_cert=../out/metrics-cert.crt' \\\\n  --set-file 'ca_key=../out/metrics-cert.key'\n```\n\n----------------------------------------\n\nTITLE: Setting Up Prometheus Metrics Endpoint Using Temporal Java SDK - Java\nDESCRIPTION: This Java snippet demonstrates how to set up a Prometheus metrics endpoint for collection by Prometheus using the Temporal Java SDK. It uses Micrometer to set up the metrics registry and exposes the metrics via an HTTP server on port 8077, with reporting every 10 seconds. Required dependencies include Temporal Java SDK, io.micrometer.prometheus, com.uber.m3.tally, and Java standard library packages. Key parameters include custom metric tags, scrape endpoint port, and registry configuration. The expected input is proper Java environment setup and dependency resolution; output is an HTTP endpoint at /metrics emitting Prometheus-formatted metrics. The implementation assumes that the registry and client configuration occur in the correct order and that port 8077 is available.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/prometheus-grafana.mdx#2025-04-23_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n//You need the following packages to set up metrics in Java.\n//See the Developer's guide for packages required for other SDKs.\n\n//…\nimport com.sun.net.httpserver.HttpServer;\nimport com.uber.m3.tally.RootScopeBuilder;\nimport com.uber.m3.tally.Scope;\nimport com.uber.m3.util.Duration;\nimport com.uber.m3.util.ImmutableMap;\n\nimport io.micrometer.prometheus.PrometheusConfig;\nimport io.micrometer.prometheus.PrometheusMeterRegistry;\nimport io.temporal.common.reporter.MicrometerClientStatsReporter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\n\nimport io.temporal.serviceclient.SimpleSslContextBuilder;\nimport io.temporal.serviceclient.WorkflowServiceStubs;\nimport io.temporal.serviceclient.WorkflowServiceStubsOptions;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n//…\n   {\n     // See the Micrometer documentation for configuration details on other supported monitoring systems.\n     // Set up the Prometheus registry.\n     PrometheusMeterRegistry yourRegistry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\n\n       public static Scope yourScope(){\n     //Set up a scope, report every 10 seconds\n       Scope yourScope = new RootScopeBuilder()\n               .tags(ImmutableMap.of(\n                       \"customtag1\",\n                       \"customvalue1\",\n                       \"customtag2\",\n                       \"customvalue2\"))\n               .reporter(new MicrometerClientStatsReporter(yourRegistry))\n               .reportEvery(Duration.ofSeconds(10));\n\n     //Start Prometheus scrape endpoint at port 8077 on your local host\n     HttpServer scrapeEndpoint = startPrometheusScrapeEndpoint(yourRegistry, 8077);\n     return yourScope;\n   }\n\n   /**\n    * Starts HttpServer to expose a scrape endpoint. See\n    * https://micrometer.io/docs/registry/prometheus for more info.\n    */\n\n   public static HttpServer startPrometheusScrapeEndpoint(\n           PrometheusMeterRegistry yourRegistry, int port) {\n       try {\n           HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n           server.createContext(\n                   \"/metrics\",\n                   httpExchange -> {\n                       String response = registry.scrape();\n                       httpExchange.sendResponseHeaders(200, response.getBytes(UTF_8).length);\n                       try (OutputStream os = httpExchange.getResponseBody()) {\n                           os.write(response.getBytes(UTF_8));\n                       }\n                   });\n           server.start();\n           return server;\n       } catch (IOException e) {\n           throw new RuntimeException(e);\n       }\n   }\n}\n\n//…\n\n// With your scrape endpoint configured, set the metrics scope in your Workflow service stub and\n// use it to create a Client to start your Workers and Workflow Executions.\n\n//…\n{\n    //Create Workflow service stubs to connect to the Frontend Service.\n    WorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(\n               WorkflowServiceStubsOptions.newBuilder()\n                      .setMetricsScope(yourScope()) //set the metrics scope for the WorkflowServiceStubs\n                      .build());\n\n   //Create a Workflow service client, which can be used to start, signal, and query Workflow Executions.\n   WorkflowClient yourClient = WorkflowClient.newInstance(service,\n          WorkflowClientOptions.newBuilder().build());\n}\n\n//…\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Injection for Temporal Activities in TypeScript\nDESCRIPTION: Presents a pattern for dependency injection in Temporal Activities using a factory function `createActivities`. This function accepts a dependency conforming to the `DB` interface (e.g., a database connection) and returns an object containing Activity functions (`greet`, `greet_es`) that utilize the injected dependency. This pattern helps share expensive resources or inject secrets.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nexport interface DB {\n  get(key: string): Promise<string>;\n}\n\nexport const createActivities = (db: DB) => ({\n  async greet(msg: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${msg}: ${name}`;\n  },\n  async greet_es(mensaje: string): Promise<string> {\n    const name = await db.get('name'); // simulate read from db\n    return `${mensaje}: ${name}`;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Results in .NET\nDESCRIPTION: Demonstrates how to obtain workflow execution results using workflow handle and result retrieval methods.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/temporal-client.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar handle = client.GetWorkflowHandle(\"my-workflow-id\");\nvar result = await client.GetResultAsync<string>();\nConsole.WriteLine(\"Result: {0}\", result);\n```\n\n----------------------------------------\n\nTITLE: Logging into Temporal Cloud with tcld CLI - Shell\nDESCRIPTION: This shell snippet demonstrates how to authenticate to Temporal Cloud using the tcld CLI utility. The command initializes a login session, opening a browser for user authentication. The output provides a URL with an activation code, which the user must visit and confirm to complete device authorization. 'tcld' must be installed and accessible from the command line; user credentials and network access to Temporal Cloud are prerequisites.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/namespaces.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntcld login\n```\n\n----------------------------------------\n\nTITLE: Creating OpenTracing Interceptor in Go\nDESCRIPTION: This snippet demonstrates how to create an OpenTracing interceptor for distributed tracing in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// create Interceptor\ntracingInterceptor, err := opentracing.NewInterceptor(opentracing.TracerOptions{})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Signal-Based Workflow in C#\nDESCRIPTION: This Workflow demonstrates waiting for a signal with a timeout. It waits for 45 seconds for the signal and returns different results based on whether the signal was received or timed out.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/testing-suite.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class SignalWorkflow\n{\n    private bool signalReceived = false;\n\n    [WorkflowRun]\n    public async Task<string> RunAsync()\n    {\n        // Wait for signal or timeout in 45 seconds\n        if (Workflow.WaitConditionAsync(() => signalReceived, TimeSpan.FromSeconds(45)))\n        {\n            return \"got signal\";\n        }\n        return \"got timeout\";\n    }\n\n    [WorkflowSignal]\n    public async Task SomeSignalAsync() => signalReceived = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Pausing a Schedule in Java\nDESCRIPTION: This code illustrates how to pause a Schedule using the pause() method on the ScheduleHandle. It allows temporarily halting future Workflow Runs associated with the Schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\nhandle.pause(\"Pausing the schedule for now\");\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Task Queue in Java\nDESCRIPTION: This snippet shows how to set the Workflow Task Queue using WorkflowOptions.Builder.setTaskQueue. It creates a WorkflowStub with the specified Task Queue name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                // Set the Task Queue\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Listing All Namespaces in Temporal Java SDK\nDESCRIPTION: This code snippet demonstrates how to list all registered Namespaces using the ListNamespace API. It returns information and configuration details for all registered Namespaces on the Temporal Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nimport io.temporal.api.workflowservice.v1.*;\n//...\nListNamespacesRequest listNamespaces = ListNamespacesRequest.newBuilder().build();\n    ListNamespacesResponse listNamespacesResponse = namespaceservice.blockingStub().listNamespaces(listNamespaces); //lists 1-100 namespaces (1 page) in the active Temporal Service. To list all, set the page size or loop until NextPageToken is nil.\n//...\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace in Go\nDESCRIPTION: Deletes a Namespace and all its associated Workflow Executions from both persistence and visibility stores using the DeleteNamespace API.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/namespaces.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n//...\nclient.OperatorService().DeleteNamespace(ctx, &operatorservice.DeleteNamespaceRequest{...\n//...\n```\n\n----------------------------------------\n\nTITLE: Setting a Sleep Duration using workflow.Sleep() in Go SDK\nDESCRIPTION: Pauses workflow execution for the specified duration using the Sleep() function. A zero or negative sleep duration returns immediately. The timer persists through system downtime.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/timers.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nsleep = workflow.Sleep(ctx, 10*time.Second)\n```\n\n----------------------------------------\n\nTITLE: Defining Money Transfer Workflow Interface - Temporal PHP\nDESCRIPTION: Provides a Workflow interface definition for a money transfer operation, indicating method signatures, attribute annotations, and return types using Temporal PHP SDK. The contract establishes expected inputs (account IDs, reference IDs, and amount as integer cents) and specifies that a UUID will be returned. Required dependencies include UuidInterface and the Temporal WorkflowMethod and ReturnType annotations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_7\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n#[WorkflowInterface]\\ninterface AccountTransferWorkflowInterface\\n{\\n    #[WorkflowMethod(name: \\\"MoneyTransfer\\\")]\\n    #[ReturnType(UuidInterface::class)]\\n    public function transfer( string $fromAccountId, string $toAccountId, string $referenceId, int $amountCents);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom IPv4Address Encoding Payload Converter - Python\nDESCRIPTION: This example shows how to implement a new EncodingPayloadConverter for supporting custom types (e.g., ipaddress.IPv4Address) in Temporal workflows. The converter provides specialized serialization logic and encoding, and is composed into a CompositePayloadConverter for integration. Dependencies include the ipaddress module as well as the Temporal Python SDK's converter classes. The snippet details overriding both to_payload and from_payload, composing with defaults to maintain broad compatibility. Use this when a type is not handled by the default JSON or Pydantic converters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/converters-and-encryption.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass IPv4AddressEncodingPayloadConverter(EncodingPayloadConverter):\n    @property\n    def encoding(self) -> str:\n        return \"text/ipv4-address\"\n\n    def to_payload(self, value: Any) -> Optional[Payload]:\n        if isinstance(value, ipaddress.IPv4Address):\n            return Payload(\n                metadata={\"encoding\": self.encoding.encode()},\n                data=str(value).encode(),\n            )\n        else:\n            return None\n\n    def from_payload(self, payload: Payload, type_hint: Optional[Type] = None) -> Any:\n        assert not type_hint or type_hint is ipaddress.IPv4Address\n        return ipaddress.IPv4Address(payload.data.decode())\n\nclass IPv4AddressPayloadConverter(CompositePayloadConverter):\n    def __init__(self) -> None:\n        # Just add ours as first before the defaults\n        super().__init__(\n            IPv4AddressEncodingPayloadConverter(),\n            *DefaultPayloadConverter.default_encoding_payload_converters,\n        )\n\nmy_data_converter = dataclasses.replace(\n    DataConverter.default,\n    payload_converter_className=IPv4AddressPayloadConverter,\n)\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Cloud Prometheus API Endpoint URL Format\nDESCRIPTION: Shows the URL structure for directly querying the Temporal Cloud Prometheus HTTP API. The `<account-id>` placeholder must be replaced with the specific Temporal Cloud account ID. A sample query parameter (`query=temporal_cloud_v0_state_transition_count`) is included as an example.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/general-setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://<account-id>.tmprl.cloud/prometheus/api/v1/query?query=temporal_cloud_v0_state_transition_count\n```\n\n----------------------------------------\n\nTITLE: Creating WorkflowServiceStubs Connection - Temporal Java SDK - Java\nDESCRIPTION: This snippet demonstrates how to instantiate a WorkflowServiceStubs object using the Temporal Java SDK to connect a client to a locally running Temporal Service. The method newLocalServiceStubs() provides a ready-to-use stub configured for local development environments. No additional dependencies apart from the Temporal Java SDK are required. The connection object serves as the entry point for further Workflow operations and client configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-client-sample/README.md#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n// Create a stub that accesses a Temporal Service on the local development machine\\nWorkflowServiceStubs service = WorkflowServiceStubs.newLocalServiceStubs();\n```\n\n----------------------------------------\n\nTITLE: Removing a Remote Cluster with Temporal CLI\nDESCRIPTION: Removes a specified remote Cluster from the system. The command requires the name of the cluster to be removed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator cluster remove --name=SomeCluster\n```\n\n----------------------------------------\n\nTITLE: Defining an Update Handler in a Temporal PHP Workflow Interface\nDESCRIPTION: Shows how to define an Update handler method `pauseProcessing` within a PHP Workflow interface (`FileProcessingWorkflow`) using the `#[UpdateMethod]` attribute. This method, part of the Workflow's contract, is intended to handle Update requests that might pause the workflow's processing. It takes no arguments and returns `void`. Requires the `Temporal\\Workflow\\WorkflowInterface` and `Temporal\\Workflow\\UpdateMethod` attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface FileProcessingWorkflow {\n    #[WorkflowMethod]\n    #[ReturnType(ProcessResult::class)]\n    public function processFile(File $file);\n\n    #[UpdateMethod]\n    public function pauseProcessing(): void;\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an Update to a Workflow and Waiting for Result in C#\nDESCRIPTION: This code shows how to send an Update to a Workflow using ExecuteUpdateAsync and wait for the result. Updates can modify Workflow state and return a result, but are blocking calls.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar previousLanguage = await workflowHandle.ExecuteUpdateAsync(\n  wf => wf.SetCurrentLanguageAsync(GreetingWorkflow.Language.Chinese));\n```\n\n----------------------------------------\n\nTITLE: Checking History Event Count Against Warning Limit (Go)\nDESCRIPTION: Go code snippet from the Temporal history service (`workflowExecutionContext.go`) showing the condition check for the number of events in a Workflow Execution history against the configured warning limit (default 10,240 events). A warning is logged if the count exceeds this limit.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nif mutableState.GetHistorySize() > h.config.HistorySizeLimitWarn() || mutableState.GetExecutionInfo().ExecutionStats.HistorySize > h.config.HistorySizeLimitWarn() || int64(mutableState.GetNextEventID()-1) > h.config.HistoryCountLimitWarn() {\n```\n\n----------------------------------------\n\nTITLE: Terminating a Workflow Execution Using Temporal CLI (shell)\nDESCRIPTION: Provides an example of terminating a running Workflow Execution via the Temporal CLI using the 'temporal workflow terminate' command with a specific Workflow ID. This operation appends a WorkflowExecutionTerminated event to the workflow's event history and prevents further command scheduling. Assumes a valid Workflow ID, Temporal cluster connectivity, and appropriate permissions; customizable with additional flags for context, such as --reason.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow terminate --workflow-id=meaningful-business-id\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Workflow ID in Go\nDESCRIPTION: This snippet illustrates how to set a custom Workflow ID using the StartWorkflowOptions struct. Setting a custom ID is recommended for mapping to business processes or entity identifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nworkflowOptions := client.StartWorkflowOptions{\n  // ...\n  ID: \"Your-Custom-Workflow-Id\",\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating an API Key for a Service Account with tcld CLI – Command\nDESCRIPTION: This snippet explains how administrators or account owners can create an API key for a Service Account using the CLI tool. The command requires prior authentication (`tcld login`) and uses `tcld apikey create` with flags for name, description, duration, and the Service Account identifier. The resulting key must be saved securely, as it is only shown once. Required dependencies: tcld CLI, admin/owner account, valid Service Account ID. Inputs are API key and Service Account properties; output is the API key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_3\n\nLANGUAGE: command\nCODE:\n```\ntcld apikey create \\\n    --name <api-key-name> \\\n    --description \"<api-key-description>\" \\\n    --duration <api-key-duration> \\\n    --service-account-id <service-account-id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Activity Retry Policy in .NET\nDESCRIPTION: Example of setting up retry policies for Activities with both timeout and retry configuration using ActivityOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nreturn await Workflow.ExecuteActivityAsync(\n    (MyActivities a) => a.MyActivity(param),\n    new()\n    {\n        StartToCloseTimeout = TimeSpan.FromMinutes(5),\n        RetryPolicy = new() { MaximumInterval = TimeSpan.FromSeconds(10) },\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Activity Retry Delay Override in .NET\nDESCRIPTION: Shows how to override retry delay intervals by throwing an ApplicationFailureException with a custom nextRetryDelay value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar attempt = ActivityExecutionContext.Current.Info.Attempt;\n\nthrow new ApplicationFailureException(\n    $\"Something bad happened on attempt {attempt}\",\n    errorType: \"my_failure_type\",\n    nextRetryDelay: TimeSpan.FromSeconds(3 * attempt));\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Connection Parameters in Python\nDESCRIPTION: This Python snippet demonstrates retrieving Temporal connection details (address, namespace, task queue, API key) from environment variables. It provides default values for local development ('localhost:7233', 'default', 'test-task-queue', empty API key). This pattern allows dynamic configuration in different deployment environments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nTEMPORAL_ADDRESS = os.environ.get(\"TEMPORAL_ADDRESS\", \"localhost:7233\")\nTEMPORAL_NAMESPACE = os.environ.get(\"TEMPORAL_NAMESPACE\", \"default\")\nTEMPORAL_TASK_QUEUE = os.environ.get(\"TEMPORAL_TASK_QUEUE\", \"test-task-queue\")\nTEMPORAL_API_KEY = os.environ.get(\"TEMPORAL_API_KEY\", \"\")\n```\n```\n\n----------------------------------------\n\nTITLE: Emitting Metrics with MicrometerClientStatsReporter in Java\nDESCRIPTION: This snippet demonstrates how to set up metrics emission using MicrometerClientStatsReporter with Prometheus in a Temporal Java application. It configures a metrics scope and adds it to WorkflowServiceStubsOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nPrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);\nStatsReporter reporter = new MicrometerClientStatsReporter(registry);\nScope scope = new RootScopeBuilder()\n        .reporter(reporter)\n        .reportEvery(com.uber.m3.util.Duration.ofSeconds(10));\nWorkflowServiceStubsOptions stubOptions =\n    WorkflowServiceStubsOptions.newBuilder().setMetricsScope(scope).build();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Local Temporal gRPC API using Evans Shell Command\nDESCRIPTION: Shows how to use the `evans` CLI tool to interactively explore the Temporal gRPC WorkflowService API. It specifies the path to the protobuf definition file (`service.proto`) and the default port (`7233`) for a local Temporal Server. Requires `evans` to be installed and the `temporalio/api` repository to be cloned.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/server-frontend-api-reference.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd /path/to/api\nevans --proto temporal/api/workflowservice/v1/service.proto --port 7233\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Config Loader in Go\nDESCRIPTION: Demonstrates using temporal.NewServer() with the temporal.WithConfigLoader(configDir, env, zone) option to load configuration from a specified directory and environment. This approach is suitable for dynamic or environment-based deployments. Inputs include configDir (path), env, and zone; outputs a server instance using the loaded configuration. All parameters must be defined ahead, and required imports are go.temporal.io/server/temporal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.WithConfigLoader(configDir, env, zone),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Update Handler in C# Temporal Workflow\nDESCRIPTION: This code snippet illustrates the implementation of a Dynamic Update Handler in a Temporal Workflow using C#. It uses the WorkflowUpdate attribute with Dynamic set to true and shows how to handle dynamic input and return a result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowUpdate(Dynamic = true)]\npublic async Task<string> DynamicUpdateAsync(string updateName, IRawValue[] args)\n{\n    var input = Workflow.PayloadConverter.ToValue<DoSomethingParam>(args.Single());\n    pendingThings.Add(input);\n    return statuses[input.Type];\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Frontend Service Error Rate by Type using PromQL (v1.17.0+)\nDESCRIPTION: This Prometheus query calculates the per-second average rate of errors (`service_errors_with_type`) encountered by the Temporal Frontend Service (`service_name=\"frontend\"`) over the last 5 minutes. Requires Temporal v1.17.0 or later. The results are aggregated by error type (`error_type` tag), helping to identify the kinds of errors occurring.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_3\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(service_errors_with_type{service_name=\"frontend\"}[5m])) by (error_type)\n```\n\n----------------------------------------\n\nTITLE: Merging Compatibility Sets via Task Queue Update (Legacy)\nDESCRIPTION: This snippet illustrates merging two distinct compatibility sets on a Task Queue using the deprecated `client.taskQueue.updateBuildIdCompatibility` method. The `mergeSets` operation combines the set containing `secondaryBuildId` into the set containing `primaryBuildId`. The default Build ID of the primary set remains the default for the resulting merged set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nawait client.taskQueue.updateBuildIdCompatibility('your_task_queue_name', {\n  operation: 'mergeSets',\n  primaryBuildId: 'deadbeef',\n  secondaryBuildId: 'some-existing-build-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToCloseTimeout with ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to set the ScheduleToCloseTimeout using an ActivityStub within a Workflow implementation. It's part of the ActivityOptions reference section.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_22\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                  ActivityOptions.newBuilder()\n                          .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                          .build());\n```\n\n----------------------------------------\n\nTITLE: Counting Workflows by Type using Temporal CLI, jq, and uniq in Shell\nDESCRIPTION: This command counts the number of workflows for each type using the Temporal CLI, jq for JSON processing, and uniq for counting unique occurrences.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --fields long --output json | jq '.[].type.name' | uniq -c\n```\n\n----------------------------------------\n\nTITLE: Configuring Task Queue Name for a Temporal PHP Worker\nDESCRIPTION: This code shows how to specify a custom Task Queue name when creating a new Worker. The Task Queue name is provided as the first argument to the newWorker method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_12\n\nLANGUAGE: php\nCODE:\n```\n$worker = $factory->newWorker('your-task-queue');\n```\n\n----------------------------------------\n\nTITLE: Cloning and Navigating Prometheus-to-Datadog Integration Repository - Bash\nDESCRIPTION: This snippet demonstrates cloning the Temporal samples server repository and changing directory into the Go-based PromQL-to-Datadog integration sample. It is the initial step to access example code for exporting Temporal Cloud metrics, leveraging GitHub CLI as a requirement. Inputs: None required. Outputs: Directory ready for sample setup. Dependencies: GitHub CLI (gh), network access.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngh repo clone temporalio/samples-server\\ncd samples-server/cloud/observability/promql-to-dd-go\n```\n\n----------------------------------------\n\nTITLE: Creating Connection with .NET SDK v1.1.0+ using API Key\nDESCRIPTION: Establishes a connection to Temporal Cloud using the .NET SDK v1.1.0 or newer. Requires endpoint URL, namespace information, and API key. Uses the dedicated ApiKey property for authentication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nvar myClient = TemporalClient.ConnectAsync(new(<endpoint>)\n{\n    Namespace = <namespace_id>.<account_id>,\n    ApiKey = <APIKey>,\n    RpcMetadata = new Dictionary<string, string>()\n    {\n        [\"temporal-namespace\"] = \"${<namespace_id>.<account_id>}\",\n    },\n    Tls = new(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Logger Sink Interface in Temporal\nDESCRIPTION: Example of declaring a custom logger sink interface in Temporal TypeScript SDK. Sinks enable one-way export of logs from Workflow isolate to the Node.js environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Sinks } from '@temporalio/workflow';\n\nexport interface CustomLoggerSinks extends Sinks {\n  customLogger: {\n    info(message: string): void;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Workflow Functions in Context\nDESCRIPTION: Example of testing a function that needs to run in Workflow context with time manipulation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sleep } from '@temporalio/workflow';\n\nexport async function functionToTest(): Promise<number> {\n  await sleep('1 day');\n  return 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling External Workflow Cancellation During Activity Execution\nDESCRIPTION: This example demonstrates how to handle external workflow cancellation while an activity is running. It uses a nonCancellable scope to execute cleanup logic that won't be cancelled even if the main workflow is cancelled.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  isCancellation,\n  proxyActivities,\n} from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpPostJSON, cleanup } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function handleExternalWorkflowCancellationWhileActivityRunning(\n  url: string,\n  data: any,\n): Promise<void> {\n  try {\n    await httpPostJSON(url, data);\n  } catch (err) {\n    if (isCancellation(err)) {\n      console.log('Workflow cancelled');\n      // Cleanup logic must be in a nonCancellable scope\n      // If we'd run cleanup outside of a nonCancellable scope it would've been cancelled\n      // before being started because the Workflow's root scope is cancelled.\n      await CancellationScope.nonCancellable(() => cleanup(url));\n    }\n    throw err; // <-- Fail the Workflow\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Failing Over a Namespace with API Key Authentication - TCLD CLI - Bash\nDESCRIPTION: Initiates a failover for a Temporal Cloud Namespace using the `tcld` CLI with API key authentication. The operation transitions the primary Namespace region to the specified replica using the `--namespace` and `--region` flags. Inputs required are API key, namespace, and target region. This variant is for environments needing API key credentialing; success or error is returned by CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntcld --api-key <your_api_key> \\\n    namespace failover \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <target_region>\n```\n\n----------------------------------------\n\nTITLE: Setting Prometheus Endpoint in .NET SDK\nDESCRIPTION: This snippet demonstrates how to expose a Prometheus endpoint on port 9000 using the Temporal .NET SDK. It configures the metrics settings on the TemporalRuntime object, which should be created globally and used for all clients.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Runtime;\n\nvar runtime = new TemporalRuntime(new()\n{\n    Telemetry = new() { Metrics = new() { Prometheus = new(\"0.0.0.0:9000\") } },\n});\nvar client = await Temporalio.ConnectAsync(new(\"localhost:7233\") { Runtime = runtime });\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Cluster Replication in v1.14 and Later\nDESCRIPTION: Example YAML configuration showing how to set up local cluster settings for multi-cluster replication in Temporal v1.14 and later, requiring additional CLI commands to connect clusters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: true\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: true\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterB\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n----------------------------------------\n\nTITLE: Defining a State-Returning Query Handler in Temporal PHP Workflow\nDESCRIPTION: Demonstrates defining a Query handler `getCurrentState` with a custom name 'current_state' using `#[Workflow\\QueryMethod('current_state')]`. The handler returns the value of the private property `$currentState`, which is updated throughout the Workflow's execution lifecycle (e.g., waiting for timers or activities). Query handlers must not cause Command generation. Requires the `Temporal\\Workflow` namespace and associated classes like `Workflow`, `ActivityOptions`, `DateInterval`, etc.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_6\n\nLANGUAGE: php\nCODE:\n```\n#[Workflow\\WorkflowInterface]\nclass YourWorkflow\n{\n    private string $currentState;\n\n    #[Workflow\\QueryMethod('current_state')]\n    public function getCurrentState(): string\n    {\n        return $this->currentState;\n    }\n\n    #[Workflow\\WorkflowMethod]\n    public function run()\n    {\n        // Your normal Workflow code begins here, and you update the currentState\n        // as the code makes progress.\n        $this->currentState = 'waiting timer';\n        try{\n            yield Workflow::timer(DateInterval::createFromDateString('1 hour'));\n        } catch (\\Throwable $e) {\n            $this->currentState = 'timer failed';\n            throw $e;\n        }\n\n        $yourActivity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n\n        $this->currentState = 'waiting activity';\n        try{\n            yield $yourActivity->doSomething('some input');\n        } catch (\\Throwable $e) {\n            $this->currentState = 'activity failed';\n            throw $e;\n        }\n\n        $this->currentState = 'done';\n\n        return null;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Promoting an Existing Build ID within its Set using Python SDK (Deprecated)\nDESCRIPTION: Shows how to use the deprecated `client.update_worker_build_id_compatibility` method with `BuildIdOpPromoteBuildIdWithinSet`. This operation promotes an existing Build ID (`deadbeef`) to become the default Build ID within its current compatible set on the specified Task Queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ...\nawait client.update_worker_build_id_compatibility(\n    \"your_task_queue_name\", BuildIdOpPromoteBuildIdWithinSet(\"deadbeef\")\n)\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow Executions with Temporal CLI\nDESCRIPTION: The 'temporal workflow reset' command resets a Workflow Execution to a certain point without losing parameters or Event History. It can reset to a specific Event Type or any Event after WorkflowTaskStarted.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow reset --workflow-id=meaningful-business-id --type=LastContinuedAsNew\n```\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow reset --workflow-id=meaningful-business-id --event-id=MyLastEvent\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Workflow Definition in Go\nDESCRIPTION: This snippet shows how to define a basic Workflow in Go using the Temporal SDK. It defines a function that takes a workflow context and returns an error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc YourBasicWorkflow(ctx workflow.Context) error {\n    // ...\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Worker Sessions in Go SDK\nDESCRIPTION: Set EnableSessionWorker to true in the Worker options to enable Worker Sessions. This code snippet demonstrates how to configure a Worker with sessions enabled and register workflows and activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/sessions.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n\t// Enable Sessions for this Worker.\n\tworkerOptions := worker.Options{\n\t\tEnableSessionWorker: true,\n\t}\n\tw := worker.New(temporalClient, \"fileprocessing\", workerOptions)\n\tw.RegisterWorkflow(sessions.SomeFileProcessingWorkflow)\n\tw.RegisterActivity(&sessions.FileActivities{})\n\terr = w.Run(worker.InterruptCh())\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Default Logger in Temporal TypeScript SDK\nDESCRIPTION: Example of customizing the default logger in Temporal by creating a new DefaultLogger instance with custom log level and handler function. This shows how to filter log messages by severity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DefaultLogger, Runtime } from '@temporalio/worker';\n\nconst logger = new DefaultLogger('WARN', ({ level, message }) => {\n  console.log(`Custom logger: ${level} — ${message}`);\n});\nRuntime.install({ logger });\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Handler and Validator in Java Workflow\nDESCRIPTION: Illustrates how to define and implement an Update handler and its validator in a Java Workflow. The Update handler changes the Workflow state and returns a value, while the validator performs input validation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class MessagePassingIntro {\n    @WorkflowInterface\n    public interface GreetingWorkflow {\n        ...\n        // 👉 Use the @UpdateMethod annotation to define an Update handler in the\n        // Workflow interface.\n        @UpdateMethod\n        Language setLanguage(Language language);\n\n        // 👉 Update validators are optional\n        @UpdateValidatorMethod(updateName = \"setLanguage\")\n        void setLanguageValidator(Language language);\n    }\n\n    public static class GreetingWorkflowImpl implements GreetingWorkflow {\n        ...\n        @Override\n        public Language setLanguage(Language language) {\n            // 👉 The Update handler can mutate the Workflow state and return a value.\n            Language previousLanguage = this.language;\n            this.language = language;\n            return previousLanguage;\n        }\n\n        @Override\n        public void setLanguageValidator(Language language) {\n            // 👉 The Update validator performs validation but cannot mutate the Workflow state.\n            if (!greetings.containsKey(language)) {\n                throw new IllegalArgumentException(\"Unsupported language: \" + language);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Temporal Schedule Configuration\nDESCRIPTION: Command structure for updating an existing Schedule with new configuration parameters. Includes workflow ID, task queue, and workflow type specifications.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/schedule.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal schedule update \\\n    --schedule-id 'your-schedule-id' \\\n    --workflow-id 'your-workflow-id' \\\n    --task-queue 'your-task-queue' \\\n    --workflow-type 'YourWorkflowType'\n```\n\n----------------------------------------\n\nTITLE: Managing Cluster Connections with Temporal CLI\nDESCRIPTION: Shell commands for adding, disabling, and removing cluster connections using the Temporal operator CLI, which must be executed in both clusters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n# Add a cluster\ntemporal operator cluster upsert --frontend_address=\"127.0.2.1:8233\"\n\n# Disable connections\ntemporal operator cluster upsert --frontend_address=\"localhost:8233\" --enable_connection false\n\n# Delete connections\ntemporal operator cluster remove --name=\"someClusterName\"\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Interface in PHP\nDESCRIPTION: This snippet demonstrates how to define a Workflow interface in PHP using Temporal attributes. It includes a method annotated with #[WorkflowMethod].\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\ninterface YourBasicWorkflow {\n    #[WorkflowMethod]\n    public function workflowMethod(Arguments args);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Visibility Store in Temporal YAML\nDESCRIPTION: This YAML snippet configures SQLite as the Temporal Visibility store. It sets 'sqlite-visibility' as the `visibilityStore` and defines its datastore parameters under `datastores`, specifying the 'sqlite' plugin, database name ('default'), and connection attributes for an in-memory database (`mode: 'memory'`, `cache: 'private'`). It also includes basic connection pool and TLS settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  # ...\n  visibilityStore: sqlite-visibility\n  # ...\n  datastores:\n    # ...\n    sqlite-visibility:\n      sql:\n        user: 'username_for_auth'\n        password: 'password_for_auth'\n        pluginName: 'sqlite'\n        databaseName: 'default'\n        connectAddr: 'localhost'\n        connectProtocol: 'tcp'\n        connectAttributes:\n          mode: 'memory'\n          cache: 'private'\n        maxConns: 1\n        maxIdleConns: 1\n        maxConnLifetime: '1h'\n        tls:\n          enabled: false\n          caFile: ''\n          certFile: ''\n          keyFile: ''\n          enableHostVerification: false\n          serverName: ''\n```\n\n----------------------------------------\n\nTITLE: Coordinating Concurrent Signal Handler with Mutex in Temporal PHP Workflow\nDESCRIPTION: This improved PHP code snippet demonstrates the use of Workflow\\Mutex to serialize concurrent executions of a signal handler in a Temporal Workflow. The handler locks the critical section that updates object state, preventing race conditions and ensuring only one handler instance runs the code at a time. Prerequisites: Temporal PHP SDK, Workflow\\Mutex. Receives signals and fetches data with an Activity; updates Workflow variables safely without concurrency bugs. Outputs are consistent state transitions. Limitations: other parts of handler outside the Mutex are not protected.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_22\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass MyWorkflow\n{\n    // ...\n\n    private Workflow\\Mutex $mutex;\n\n    public function __construct()\n    {\n        $this->mutex = new Workflow\\Mutex();\n    }\n\n    #[Workflow\\SignalMethod]\n    public function safeAsyncHandler()\n    {\n        $data = yield Workflow::executeActivity(\n            type: 'fetch_data',\n            args: ['url' => 'http://example.com'],\n            options: ActivityOptions::new()->withStartToCloseTimeout('10 seconds'),\n        );\n        yield Workflow::runLocked($this->mutex, function () use ($data) {\n            $this->x = $data->x;\n            # ✅ OK: the scheduler may switch now to a different handler execution, or to the main workflow\n            # method, but no other execution of this handler can run until this execution finishes.\n            yield Workflow::timer(1);  # or await anything else\n            $this->y = $data->y;\n        });\n    }\n```\n\n----------------------------------------\n\nTITLE: Safely Finalizing Activity Update in Temporal Workflow - Python\nDESCRIPTION: Reiterates the complete migration state for a Temporal Workflow in Python where all patching logic is removed and only the updated activity is executed. This step should be deployed only after ensuring all historical Workflows using earlier code paths are completed. The code is identical to the final state snippet and indicates normal operation post-migration. Dependencies are only the Python Temporal SDK and the new activity definition. No version markers or conditional logic remain.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/versioning.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@workflow.defn\\nclass MyWorkflow:\\n    @workflow.run\\n    async def run(self) -> None:\\n        self._result = await workflow.execute_activity(\\n            post_patch_activity,\\n            schedule_to_close_timeout=timedelta(minutes=5),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf TypeScript Declarations - Shell Script\nDESCRIPTION: This shell command generates TypeScript declaration files for the protobuf messages defined in the `protos/*.proto` files. It first generates a static JS module using protobufjs (`pbjs -t static-module`), pipes the output to `pbts` to create type definitions in `protos/root.d.ts`. This enables type-safe imports and usage of protobuf messages throughout the TypeScript codebase.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\npbjs -t static-module protos/*.proto | pbts -o protos/root.d.ts -\n```\n\n----------------------------------------\n\nTITLE: Completing an Activity Execution with Temporal CLI\nDESCRIPTION: Command example for completing an Activity Execution with a specified result. This command marks the Activity as successfully completed and returns the specified result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/activity.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal activity complete --activity-id=MyActivity --result=ActivityComplete\n```\n\n----------------------------------------\n\nTITLE: Showing Workflow Execution History with Temporal CLI\nDESCRIPTION: The 'temporal workflow show' command displays the Event History for a Workflow Execution. It supports various options to customize the output and behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Connecting to Local Temporal Service in PHP\nDESCRIPTION: This snippet demonstrates how to create ServiceClient and WorkflowClient instances to connect to a local Temporal Service using the PHP SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Client\\GRPC\\ServiceClient;\nuse Temporal\\Client\\WorkflowClient;\n\n$serviceClient = ServiceClient::create('localhost:7233');\n$workflowClient = WorkflowClient::create($serviceClient);\n\n// Use $workflowClient to work with Workflows ...\n```\n\n----------------------------------------\n\nTITLE: Listing All Users in Temporal Cloud via tcld CLI - Command\nDESCRIPTION: Executes a simple list command to return a paginated list of all users in Temporal Cloud. No additional parameters are required; outputs are paginated with a default page size of 10 users per page.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_5\n\nLANGUAGE: command\nCODE:\n```\ntcld user list\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running a Temporal Worker in Python\nDESCRIPTION: This complete Python script provides boilerplate code for a Temporal Worker. It imports necessary libraries, retrieves configuration from environment variables, connects the Temporal Client asynchronously, initializes a Worker with specific Workflows and Activities for a given Task Queue, and starts the Worker execution using `asyncio`. This is the main entry point for the Worker process.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n```python\nimport asyncio\nimport os\n\nfrom temporalio.worker import Worker\nfrom temporalio.client import Client\n\nfrom workflows import your_workflow\nfrom activities import your_first_activity, your_second_activity, your_third_activity\n\nTEMPORAL_ADDRESS = os.environ.get(\"TEMPORAL_ADDRESS\", \"localhost:7233\")\nTEMPORAL_NAMESPACE = os.environ.get(\"TEMPORAL_NAMESPACE\", \"default\")\nTEMPORAL_TASK_QUEUE = os.environ.get(\"TEMPORAL_TASK_QUEUE\", \"test-task-queue\")\nTEMPORAL_API_KEY = os.environ.get(\"TEMPORAL_API_KEY\", \"your-api-key\")\n\nasync def main():\n  client = await Client.connect(\n    TEMPORAL_ADDRESS,\n    namespace=TEMPORAL_NAMESPACE,\n    rpc_metadata={\"temporal-namespace\": TEMPORAL_NAMESPACE},\n    api_key=TEMPORAL_API_KEY,\n    tls=True\n  )\n\nprint(\"Initializing worker...\")\n  # Run the worker\n  worker = Worker(\n    client,\n    task_queue=TEMPORAL_TASK_QUEUE,\n    workflows=[your_workflow],\n    activities=[\n      your_first_activity,\n      your_second_activity,\n      your_third_activity\n    ]\n  )\n\n  print(\"Starting worker... Waiting for tasks.\")\n  await worker.run()\n\nif __name__ == \"__main__\":\n  asyncio.run(main())\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Custom Authorizer in Go\nDESCRIPTION: Demonstrates the use of temporal.WithAuthorizer(myAuthorizer) during server creation to inject a custom authorization mechanism for inbound API calls. The myAuthorizer object must conform to Temporal Server's expected authorization interface. Dependencies include a valid authorizer and the go.temporal.io/server/temporal package. This enables low-level control over access, critical for securing self-hosted deployments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.WithAuthorizer(myAuthorizer),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes Deployment using Bash\nDESCRIPTION: This Bash command uses `kubectl apply` to create or update the Kubernetes Deployment defined in the `deployment.yaml` file. The `-f` flag specifies the manifest file, and the `--namespace` flag targets the `your-namespace` namespace. This command initiates the deployment of the Temporal Worker pod(s) onto the EKS cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nkubectl apply -f deployment.yaml \\\n    --namespace your-namespace\n```\n```\n\n----------------------------------------\n\nTITLE: Final Persistence Configuration After Visibility Store Migration\nDESCRIPTION: YAML configuration that shows the final setup after completing migration to a new visibility store. The secondary store (Elasticsearch) has been promoted to be the primary visibility store, and all references to the old store have been removed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  visibilityStore: es-visibility\n  datastores:\n    es-visibility:\n    elasticsearch:\n      version: 'v7'\n      logLevel: 'error'\n      url:\n      scheme: 'http'\n      host: '127.0.0.1:9200'\n      indices:\n      visibility: temporal_visibility_v1_dev\n      closeIdleConnectionsInterval: 15s\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Address with Temporal CLI\nDESCRIPTION: Demonstrates how to set the address property for a local environment using the 'temporal env set' command, specifying the IP and port for the Temporal Server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env set local.address 127.0.0.1:7233\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Activity Task Latency Percentile with Prometheus - PromQL\nDESCRIPTION: This query determines the 99th percentile schedule-to-start latency for activity tasks in Temporal workflows, aggregating data by namespace and task_queue over 5 minutes. It uses 'temporal_activity_schedule_to_start_latency_seconds_bucket', making it fundamental for detecting high-latency activity queues or operational delays. Suitable for dashboards or alerting on percentile-based performance thresholds.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_2\n\nLANGUAGE: promql\nCODE:\n```\nhistogram_quantile(0.99, sum(rate(temporal_activity_schedule_to_start_latency_seconds_bucket[5m])) by (le, namespace, task_queue))\n```\n\n----------------------------------------\n\nTITLE: Implementing the Default CompositePayloadConverter in TypeScript\nDESCRIPTION: Displays the TypeScript class definition for `DefaultPayloadConverter`, which inherits from `CompositePayloadConverter`. It demonstrates the default sequence of converters (`UndefinedPayloadConverter`, `BinaryPayloadConverter`, `JsonPayloadConverter`) used internally by the Temporal SDK for serializing and deserializing data before any custom converters are applied.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nexport class DefaultPayloadConverter extends CompositePayloadConverter {\n  constructor() {\n    super(\n      new UndefinedPayloadConverter(),\n      new BinaryPayloadConverter(),\n      new JsonPayloadConverter(),\n    );\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SkipInvalidStructFunctions for Activity Registration in Go\nDESCRIPTION: Shows how to configure the SkipInvalidStructFunctions option when registering a struct containing Activity methods. This determines whether invalid functions should be skipped or cause a panic during registration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_51\n\nLANGUAGE: go\nCODE:\n```\n// ...\nw := worker.New(temporalClient, \"your_task_queue_name\", worker.Options{})\nregisterOptions := activity.RegisterOptions{\n  SkipInvalidStructFunctions: false,\n  // ...\n}\nw.RegisterActivityWithOptions(a.YourActivityDefinition, registerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Scrape Targets for Temporal Metrics - YAML\nDESCRIPTION: This snippet provides a Prometheus configuration YAML segment for adding scrape targets to collect metrics from Temporal Service and SDK client endpoints. It sets a global scrape interval, defines scrape jobs (here named 'temporalmetrics'), and specifies targets and labels for server- and SDK-side metric groups. The expected input is a valid Prometheus YAML configuration file, with endpoints matching the Temporal Service and SDK HTTP metrics exporters. Limitations include the need to update port numbers and targets to correspond to actual service configurations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nglobal:\n scrape_interval: 10s\nscrape_configs:\n - job_name: 'temporalmetrics'\n   metrics_path: /metrics\n   scheme: http\n   static_configs:\n     # Temporal Service metrics target\n     - targets:\n         - 'host.docker.internal:8000'\n       labels:\n         group: 'server-metrics'\n\n     # Local app targets (if configured)\n     - targets:\n         - 'host.docker.internal:8077'\n         - 'host.docker.internal:8078'\n       labels:\n         group: 'sdk-metrics'\n```\n\n----------------------------------------\n\nTITLE: Initializing a Composite Data Converter in Temporal Go SDK\nDESCRIPTION: This Go code demonstrates the construction of the default composite data converter in the Temporal Go SDK by chaining several Payload Converter implementations in a specific precedence order. Each converter attempts to serialize/deserialize values during Data Converter operations until one succeeds, providing extensibility for custom data types. The snippet requires the Temporal Go SDK and assumes all referenced converter constructors (e.g., NewNilPayloadConverter) are available; the order is significant for correct behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/data-conversion/payload-converter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ndefaultDataConverter = NewCompositeDataConverter(\n    NewNilPayloadConverter(),\n    NewByteSlicePayloadConverter(),\n    NewProtoJSONPayloadConverter(),\n    NewProtoPayloadConverter(),\n    NewJSONPayloadConverter(),\n)\n```\n\n----------------------------------------\n\nTITLE: Decoding Payload via HTTP POST to Codec Server /decode Endpoint\nDESCRIPTION: Sample HTTP POST request to a Codec Server's `/decode` endpoint (`https://dev.mydomain.com/codec/decode`). It includes necessary headers like `Content-Type`, `X-Namespace`, and `Authorization` (Bearer token). The request body contains base64 encoded payloads under the 'payloads' key. The corresponding 200 OK response shows the decoded payloads in JSON format.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 POST /decode\nHost: https://dev.mydomain.com/codec\nContent-Type: application/json\nX-Namespace: myapp-dev.acctid123\nAuthorization: Bearer <token>\n\n{\"payloads\":[{\"metadata\":{\"encoding\":\"anNvbi9wcm90b2J1Zg==\",\"messageType\":\"dGVtcG9yYWxfc2hvcC5vcmNoZXN0cmF0aW9ucy52MS5TdGFydFNob3BwaW5nQ2FydFJlcXVlc3Q=\"},\"data\":\"eyJjYXJ0SWQiOiJleGFtcGxlLWNhcnQiLCJzaG9wcGVySWQiOiJ5b3VyLXNob3BwZXItaWQtZXhhbXBsZSIsImVtYWlsIjoieW91ci1lbWFpbEBkb21haW4uY29tIn0\"}]}\n```\n\nLANGUAGE: http\nCODE:\n```\n200 OK\nContent-Type: application/json\n\n{\n  \"payloads\": [{\n    \"metadata\":{\n      \"encoding\": \"json/protobuf\",\n      \"messageType\": \"temporal_shop.orchestrations.v1.StartShoppingCartRequest\"\n    },\n    \"data\":{\n      \"cartId\":\"example-cart\",\n      \"shopperId\":\"your-shopper-id-example\",\n      \"email\":\"your-email@domain.com\"\n    }}]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Client Connection with TypeScript SDK v1.10.0+ using API Key\nDESCRIPTION: Establishes a client connection to Temporal Cloud using TypeScript SDK v1.10.0 or newer. Uses the dedicated apiKey parameter for authentication and sets up the client with the namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = await Connection.connect(\n    address: <endpoint>,\n    tls: true,\n    apiKey: <APIKey>,\n    metadata: {\n        'temporal-namespace': <namespace_id>.<account_id>,\n    },\n)\nconst client = new Client({\n    connection,\n    namespace: <namespace_id>.<account_id>,\n});\n```\n\n----------------------------------------\n\nTITLE: Explaining the Temporal Cron String Format\nDESCRIPTION: This text block breaks down the format of a cron string used for scheduling Temporal Workflows. It clearly indicates the position and range for minute, hour, day of the month, month, and day of the week.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/schedules.mdx#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkerStopTimeout for Temporal Worker in Go\nDESCRIPTION: Sets the duration the Worker will wait for currently running activities and workflows to complete during a graceful shutdown initiated by `worker.Stop()`. The type is `time.Duration`, the default is `0` (meaning no wait), and the value resolution is in seconds.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_41\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    WorkerStopTimeout: time.Second(0),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Creating an S3 Export Sink with TCLD CLI - Bash\nDESCRIPTION: Creates a new S3 export sink for a Temporal Cloud Namespace using `tcld namespace export s3 create`. Requires `--namespace`, `--sink-name`, `--s3-bucket-name`, and `--role-arn` flags. This enables exporting workflow histories to AWS S3; ensure roles and permissions are provisioned. Inputs are the namespace, export sink name, S3 bucket name, and IAM role ARN; the output will confirm creation or report errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 create \\\n    --namespace <namespace_id> \\\n    --sink-name <sink_name> \\\n    --s3-bucket-name <bucket_name> \\\n    --role-arn <role_arn>\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenTracing Client Interceptor for Temporal Client in Java\nDESCRIPTION: This code example shows how to set up tracing by registering the OpenTracingClientInterceptor on the Temporal Client side. It demonstrates two ways to add the interceptor to WorkflowClientOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nWorkflowClientOptions.newBuilder()\n   //...\n   .setInterceptors(new OpenTracingClientInterceptor())\n   .build();\n```\n\nLANGUAGE: java\nCODE:\n```\nWorkflowClientOptions clientOptions =\n    WorkflowClientOptions.newBuilder()\n        .setInterceptors(new OpenTracingClientInterceptor(JaegerUtils.getJaegerOptions(type)))\n        .build();\nWorkflowClient client = WorkflowClient.newInstance(service, clientOptions);\n```\n\n----------------------------------------\n\nTITLE: Namespace Creation Confirmation - Temporal CLI - Shell\nDESCRIPTION: Shows the CLI's success confirmation after registering a new namespace. Confirms that the namespace is available for subsequent workflow operations and project development activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-namespace-client-sample/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nNamespace custom-namespace successfully registered.\n```\n\n----------------------------------------\n\nTITLE: Creating a Scheduled Workflow in .NET\nDESCRIPTION: This snippet demonstrates how to create a Scheduled Workflow using the CreateScheduleAsync method. It sets up a schedule that runs a workflow every 5 days.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = await client.CreateScheduleAsync(\n    \"my-schedule-id\",\n    new(\n        Action: ScheduleActionStartWorkflow.Create(\n            (MyWorkflow wf) => wf.RunAsync(),\n            new(id: \"my-workflow-id\", taskQueue: \"my-task-queue\")),\n        Spec: new()\n        {\n            Intervals = new List<ScheduleIntervalSpec> { new(Every: TimeSpan.FromDays(5)) },\n        }));\n```\n\n----------------------------------------\n\nTITLE: Adding a New Default Build ID to a Task Queue using Python SDK (Deprecated)\nDESCRIPTION: Uses the deprecated `client.update_worker_build_id_compatibility` method with `BuildIdOpAddNewDefault` to add a new Build ID (`deadbeef`) to a specified Task Queue. This operation creates a new version set containing only this Build ID and makes it the default set for the queue, directing new Workflow Executions to Workers with this Build ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# ...\nawait client.update_worker_build_id_compatibility(\n    \"your_task_queue_name\", BuildIdOpAddNewDefault(\"deadbeef\")\n)\n```\n\n----------------------------------------\n\nTITLE: Instantiating Temporal WorkflowServiceStubs in Java\nDESCRIPTION: This Java code snippet demonstrates how to create an instance of `WorkflowServiceStubs` using `WorkflowServiceStubs.newServiceStubs()`. This object represents the connection to the Temporal Service and requires a pre-configured `stubsOptions` object (not shown) containing connection details like the gRPC endpoint and mTLS credentials for Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/cloudserver-client-sample/README.md#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nWorkflowServiceStubs serviceStub = WorkflowServiceStubs.newServiceStubs(stubsOptions);\n```\n\n----------------------------------------\n\nTITLE: Validating an S3 Export Sink Configuration with TCLD CLI - Bash\nDESCRIPTION: Checks validity of an S3 export sink configuration for a Temporal Cloud Namespace using `tcld namespace export s3 validate`. The required parameters are `--namespace`, `--sink-name`, `--s3-bucket-name`, and `--role-arn`. This helps preempt configuration or permission issues before production use. Inputs are the namespace, sink name, S3 bucket, and IAM role; output will indicate valid/invalid state and any detected issues.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 validate \\\n    --namespace <namespace_id> \\\n    --sink-name <sink_name> \\\n    --s3-bucket-name <bucket_name> \\\n    --role-arn <role_arn>\n```\n\n----------------------------------------\n\nTITLE: Running the Temporal Worker in Production Mode (Python)\nDESCRIPTION: This snippet launches the Temporal Worker in run mode, connecting it to the client, Task Queue, and provided Workflows/Activities for production operation. It uses the temporalio Python SDK and assumes prior instantiation of the client, Workflow, and Activity sets. Upon execution, the Worker pulls Tasks from the designated Task Queue and processes them according to the current code. Inputs are not required at runtime beyond setup. This pattern allows seamless transition from verification to active processing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/safe-deployments.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n    else:\n        worker = Worker(\n            client,\n            task_queue=task_queue,\n            workflows=my_workflows,\n            activities=my_activities,\n        )\n        await worker.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Go SDK using API Key (v1.26.0+)\nDESCRIPTION: Example of creating a Temporal client connection using an API key in Go SDK version 1.26.0 or higher. Includes setting up client options and creating the connection.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nclientOptions := client.Options{\n    HostPort: <endpoint>,\n    Namespace: <namespace_id>.<account_id>,\n    ConnectionOptions: client.ConnectionOptions{\n        TLS: &tls.Config{},\n        DialOptions: []grpc.DialOption{\n            grpc.WithUnaryInterceptor(\n                func(ctx context.Context, method string, req any, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n                    return invoker(\n                        metadata.AppendToOutgoingContext(ctx, \"temporal-namespace\", <namespace_id>.<account_id>),\n                        method,\n                        req,\n                        reply,\n                        cc,\n                        opts...,\n                    )\n                },\n            ),\n        },\n    },\n    Credentials: client.NewAPIKeyStaticCredentials(apiKey),\n}\nc, err := client.Dial(clientOptions)\nif err != nil {\n  log.Fatalf(\"error creating temporal client: %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Concurrent Update Handler Implementation in Go\nDESCRIPTION: Example of an incorrectly implemented Update handler that can cause race conditions when multiple instances execute simultaneously. The code demonstrates potential issues when handling data fetching and assignment without proper synchronization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunc YourWorkflowDefinition(ctx workflow.Context, param YourWorkflowParam) error {\n    ...\n    err := workflow.SetUpdateHandler(ctx, \"BadUpdateHandler\", func(ctx workflow.Context) error {\n        ao := workflow.ActivityOptions{\n            StartToCloseTimeout: 10 * time.Second,\n        }\n        ctx = workflow.WithActivityOptions(ctx, ao)\n\n        var result Data\n        err := workflow.ExecuteActivity(ctx, FetchData, name).Get(ctx, &result)\n        x = result.x\n        // 🐛🐛 Bug!! If multiple instances of this handler are executing concurrently, then\n        // there may be times when the Workflow has self.x from one Activity execution and self.y from another.\n        err = workflow.Sleep(ctx, time.Second)\n        if err != nil {\n            return err\n        }\n        y = result.y\n    })\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Workflow History with Nexus Events using Temporal CLI\nDESCRIPTION: This command displays the Workflow history, which includes Nexus events. Replace <ID> with the actual Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow show -w <ID>\n```\n\n----------------------------------------\n\nTITLE: Initializing Pre-Patch Workflow in PHP\nDESCRIPTION: Defines a basic Workflow class with a pre-patch activity. This represents the initial version of the Workflow before any updates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\nclass MyWorkflow\n{\n    private $activity;\n\n    public function __construct()\n    {\n        $this->activity = Workflow::newActivityStub(\n            YourActivityInterface::class,\n            ActivityOptions::new()->withScheduleToStartTimeout(60)\n        );\n    }\n\n    #[WorkflowMethod]\n    public function runAsync()\n    {\n        $result = yield $this->activity->prePatchActivity();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nexus and Configuring Callbacks in Dynamic Config (YAML)\nDESCRIPTION: This YAML snippet details the dynamic configuration changes needed to activate Nexus and manage its callback behavior. It enables Nexus globally using `system.enableNexus`. It defines the public callback URL template with `component.nexusoperations.callback.endpoint.template`, using Go template syntax to interpolate Namespace details; this URL must be accessible if external services need to call back. Finally, it configures `component.callbacks.allowedAddresses` to restrict which callback URLs the server will accept, acting as a security measure against potential attacks. The example uses a permissive pattern (`*`) suitable only for development.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/temporal-nexus.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\nsystem.enableNexus:\n  - value: true\ncomponent.nexusoperations.callback.endpoint.template:\n  # The URL must be publicly accessible if the callback is meant to be called by external services.\n  # When using Nexus for cross namespace calls, the URL's host is irrelevant as the address is resolved using\n  # membership. The URL is a Go template that interpolates the `NamepaceName` and `NamespaceID` variables.\n  - value: https://$PUBLIC_URL:7243/namespaces/{{.NamespaceName}}/nexus/callback\ncomponent.callbacks.allowedAddresses:\n  # This list is a security mechanism for limiting which callback URLs are accepted by the server.\n  # Attackers may leverage the callback mechanism to force the server to call arbitrary URLs.\n  # The config below is only recommended for development, tune this to your requirements.\n  - value:\n      - Pattern: \"*\"\n        AllowInsecure: true\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent Signal Handler without Mutex in Temporal PHP Workflow\nDESCRIPTION: This PHP code snippet shows a Temporal Workflow class that defines a signal handler which may be executed concurrently. The handler runs an Activity to fetch data and updates the Workflow object state variable $this->x and $this->y. Because concurrent executions are not coordinated, there is a bug where the object may have inconsistent state if multiple instances of the handler execute at once. Requires Temporal PHP SDK and its Workflow API. Inputs are signals to the Workflow; outputs are state changes and possibly inconsistent object state in high-concurrency scenarios.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_21\n\nLANGUAGE: php\nCODE:\n```\nuse Temporal\\Workflow;\n\n#[Workflow\\WorkflowInterface]\nclass MyWorkflow\n{\n    // ...\n\n    #[Workflow\\SignalMethod]\n    public function badAsyncHandler()\n    {\n        $data = yield Workflow::executeActivity(\n            type: 'fetch_data',\n            args: ['url' => 'http://example.com'],\n            options: ActivityOptions::new()->withStartToCloseTimeout('10 seconds'),\n        );\n        $this->x = $data->x;\n        # 🐛🐛 Bug!! If multiple instances of this handler are executing concurrently, then\n        # there may be times when the Workflow has $this->x from one Activity execution and $this->y from another.\n        yield Workflow::timer(1);  # or await anything else\n        $this->y = $data->y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Signal Handler in C# Temporal Workflow\nDESCRIPTION: This code snippet shows how to implement a Dynamic Signal Handler in a Temporal Workflow using C#. It uses the WorkflowSignal attribute with Dynamic set to true and demonstrates handling of dynamic arguments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n[WorkflowSignal(Dynamic = true)]\npublic async Task DynamicSignalAsync(string signalName, IRawValue[] args)\n{\n    var input = Workflow.PayloadConverter.ToValue<DoSomethingParam>(args.Single());\n    pendingThings.Add(input);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Temporal Cluster Health using Temporal CLI\nDESCRIPTION: Uses the Temporal CLI command `temporal operator cluster health` to check the overall health status of the Temporal cluster services. The `--address` flag specifies the target Temporal Frontend Service address (defaulting to localhost and standard port in this example). This command is useful for verifying basic connectivity and service availability, particularly for self-hosted OSS users.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/deadline-exceeded-error.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntemporal operator cluster health --address 127.0.0.1:7233\n```\n\n----------------------------------------\n\nTITLE: Canceling a Workflow Execution using Temporal CLI\nDESCRIPTION: This command cancels a Workflow Execution using its Workflow ID. It records a WorkflowExecutionCancelRequested event in the Event History and schedules a new Workflow Task for cleanup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow cancel --workflow-id=meaningful-business-id\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow in Python\nDESCRIPTION: This snippet demonstrates how to define a Workflow in Python using Temporal decorators. It defines a class with a method annotated with @workflow.run.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@workflow.defn\nclass YourWorkflow:\n    @workflow.run\n    async def YourBasicWorkflow(self, input: str) -> str:\n        # ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Terraform Output for API Key Token\nDESCRIPTION: Terraform output configuration to securely access the API Key token. This setup marks the token as sensitive to prevent accidental exposure in logs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_22\n\nLANGUAGE: yml\nCODE:\n```\noutput \"apikey_token\" {\n  value = temporalcloud_apikey.global_apikey.token\n  sensitive = true\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for a Python Temporal Worker\nDESCRIPTION: This Dockerfile defines the container image for the Python Temporal Worker. It starts from a Python 3.11 slim base image, sets the working directory, installs system dependencies (gcc) and the `temporalio` Python SDK using pip, copies the application code into the image, sets an environment variable for unbuffered Python output, and specifies the command to run the `worker.py` script.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_3\n\nLANGUAGE: docker\nCODE:\n```\n```docker\n# Use Python 3.11 slim image as base\nFROM python:3.11-slim\n\n# Set working directory\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    gcc \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install the Temporal Python SDK dependency\nRUN pip install --no-cache-dir temporalio\n\n# Copy application code\nCOPY . .\n\n# Set Python to run in unbuffered mode\nENV PYTHONUNBUFFERED=1\n\n# Run the worker\nCMD [\"python\", \"worker.py\"]\n```\n```\n\n----------------------------------------\n\nTITLE: WorkflowId OR ExecutionStatus Filter\nDESCRIPTION: List Filter that matches either a specific WorkflowId or any Workflow in Running status.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_10\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId = '<workflow-id>' or ExecutionStatus = 'Running'\n```\n\n----------------------------------------\n\nTITLE: Listing Namespaces using tcld CLI - Shell\nDESCRIPTION: This shell snippet lists the Namespaces associated with a Temporal Cloud account using the tcld CLI. Issue the command after successfully logging in with tcld; the CLI will output a list of Namespaces in JSON format. The command requires an authenticated session and network connectivity. Outputs details about each Namespace, including the suffixed Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/namespaces.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntcld namespace list\n```\n\n----------------------------------------\n\nTITLE: Configuring TaskQueueActivitiesPerSecond for Temporal Worker in Go\nDESCRIPTION: Rate limits the number of Activity Task Executions started per second across the entire Task Queue, managed by the Temporal Service. This contrasts with `WorkerActivitiesPerSecond`, which is per-Worker. The type is `float64` (allowing rates less than 1), and the default is `100000`. Setting it to `0` uses the default. Useful for protecting downstream services from being overwhelmed by all workers on the queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_32\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    TaskQueueActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Upgrading Cassandra Default Schema using temporal-cassandra-tool in Bash\nDESCRIPTION: This command uses the `temporal-cassandra-tool` to update the default persistence schema for a Temporal Server instance backed by Cassandra. It connects to the specified Cassandra endpoint using TLS, authenticates, targets the `temporal` keyspace, and applies schema updates found in the specified versioned schema directory. A timeout of 120 seconds is set for the operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/temporal/versioned\n```\n\n----------------------------------------\n\nTITLE: Retrieving Environment Properties with Temporal CLI\nDESCRIPTION: Shows how to use the 'temporal env get' command to retrieve properties for a specific environment. The example demonstrates getting all properties for the 'local' namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env get local\n```\n\n----------------------------------------\n\nTITLE: Disabling Workflow Signaling (workflowSignalDisabled) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to specifically disable the ability for users to send signals to Workflow Executions from the Temporal Web UI. Set to `true` to disable. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\nworkflowSignalDisabled: false\n```\n\n----------------------------------------\n\nTITLE: Registering Caller Workflow in Go Worker\nDESCRIPTION: This snippet shows how to register the caller Workflow with a Temporal Worker. It sets up the client, creates a worker, registers the Workflows, and runs the worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/temporalio/samples-go/nexus/caller\"\n\t\"github.com/temporalio/samples-go/nexus/options\"\n\n\t\"go.temporal.io/sdk/client\"\n\t\"go.temporal.io/sdk/worker\"\n)\n\nfunc main() {\n\t// The client and worker are heavyweight objects that should be created once per process.\n\tclientOptions, err := options.ParseClientOptionFlags(os.Args[1:])\n\tif err != nil {\n\t\tlog.Fatalf(\"Invalid arguments: %v\", err)\n\t}\n\tc, err := client.Dial(clientOptions)\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\n\tw := worker.New(c, caller.TaskQueue, worker.Options{})\n\n\tw.RegisterWorkflow(caller.EchoCallerWorkflow)\n\tw.RegisterWorkflow(caller.HelloCallerWorkflow)\n\n\terr = w.Run(worker.InterruptCh())\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to start worker\", err)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace Region with TCLD CLI - Bash\nDESCRIPTION: Removes a region from a specified Temporal Cloud Namespace using the `tcld namespace delete-region` command. Requires the Namespace and the region to be specified via the `--namespace` and `--region` flags. Upon successful execution, replication is stopped and the Namespace converts to a Standard Namespace. This is used in environments where decommissioning a region is required. Inputs are the namespace and the replica region to remove; output is the command's execution result or error.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace delete-region \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Tagging and Pushing Docker Image to AWS ECR using Bash\nDESCRIPTION: These Bash commands first tag the locally built Docker image (`your-app`) with the full ECR repository URI, including the AWS account ID, region, repository name, and the `latest` tag. Then, it pushes the tagged image to the specified Amazon ECR repository using `docker push`. The image is now available for use in EKS.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ndocker tag your-app $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/your-app:latest\ndocker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/your-app:latest\n```\n```\n\n----------------------------------------\n\nTITLE: Defining HeaderWriter and HeaderReader Interfaces in Go\nDESCRIPTION: This snippet shows the definitions of HeaderWriter and HeaderReader interfaces in Go. These interfaces are used for reading and writing Temporal Server headers, which are used for context propagation across Workflow transitions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype HeaderWriter interface {\n\tSet(string, *commonpb.Payload)\n}\n\ntype HeaderReader interface {\n\tGet(string) (*commonpb.Payload, bool)\n\tForEachKey(handler func(string, *commonpb.Payload) error) error\n}\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Java SDK using API Key\nDESCRIPTION: Example of creating a Temporal client connection using an API key in Java SDK. Includes setting up WorkflowServiceStubs and WorkflowClient.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_11\n\nLANGUAGE: java\nCODE:\n```\n// Create the Workflow service stub.\nWorkflowServiceStubsOptions.Builder stubOptions =\n    WorkflowServiceStubsOptions.newBuilder()\n        .addApiKey(() -> <APIKey>)\n        .setEnableHttps(true)\n        .setTarget(<endpoint>);\n\nWorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(stubOptions.build());\n\n/*\n * Get a Workflow service client which can be used to start, Signal, and Query Workflow Executions.\n */\nWorkflowClient client =\n    WorkflowClient.newInstance(\n        service, WorkflowClientOptions.newBuilder().setNamespace(<namespace_id>.<account_id>).build());\n```\n\n----------------------------------------\n\nTITLE: Describing a Scheduled Workflow in .NET\nDESCRIPTION: This code demonstrates how to retrieve detailed information about a Scheduled Workflow using the DescribeAsync method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nvar desc = await handle.DescribeAsync();\nConsole.WriteLine(\"Schedule info: {0}\", desc.Info);\n```\n\n----------------------------------------\n\nTITLE: Defining the Temporal Cloud Audit Log Format\nDESCRIPTION: This JSON structure outlines the format of audit log entries sent to the configured data stream (like Amazon Kinesis). Key fields include `emit_time` (when the operation was recorded), `level` (log severity), `user_email` (initiating user), `caller_ip_address` (source IP in X-Forwarded-For format), `operation` (action performed), `details` (operation specifics), `status` (outcome), `category` (Admin or System), `version`, `log_id` (unique entry ID), `principal` (initiator details), and an optional `request_id`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/audit-logging.mdx#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"emit_time\": // Time the operation was recorded\n  \"level\": // Level of the log entry, such as info, warning, or error\n  \"user_email\":  // Email address of the user who initiated the operation\n  \"caller_ip_address\": // Customer IP address in the X-Forwarded-For format\n  \"operation\":  // Operation that was performed\n  \"details\":  // Details of the operation\n  \"status\": // Status, such as OK or ERROR\n  \"category\":  // Category of the log entry: Admin or System\n  \"version\": // Version of the log entry\n  \"log_id\": // Unique ID of the log entry\n  \"principal\": // Information about who initiated the operation\n  \"request_id\": // Optional async request id set by the user when sending a request\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Average Replication Lag with Prometheus - PromQL\nDESCRIPTION: This PromQL snippet calculates the average replication lag per Temporal namespace using the sum and count histogram series: temporal_cloud_v0_replication_lag_sum and temporal_cloud_v0_replication_lag_count. The rate function normalizes these values over the chosen interval, and the result is the average lag per observed event. Provided Prometheus ingests these metrics, the query returns average lag times grouped by namespace. No additional dependencies required.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/service-health.mdx#2025-04-23_snippet_3\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(temporal_cloud_v0_replication_lag_sum[$__rate_interval])) by (temporal_namespace)\n/\nsum(rate(temporal_cloud_v0_replication_lag_count[$__rate_interval])) by (temporal_namespace)\n```\n\n----------------------------------------\n\nTITLE: Configuring ESbuild to Preserve Function Names\nDESCRIPTION: Configuration for ESbuild to prevent function name stripping in production builds. This ensures that Workflow Type names are preserved when using the Temporal Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nrequire('esbuild').buildSync({\n  entryPoints: ['app.js'],\n  minify: true,\n  keepNames: true,\n  outfile: 'out.js',\n});\n```\n\n----------------------------------------\n\nTITLE: Completing Asynchronous Activity with Temporal Client in Go\nDESCRIPTION: Instantiates a Temporal service client and uses it to complete an Activity asynchronously using the Task Token obtained earlier. This code would be executed by the external system.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/asynchronous-activity-completion.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Instantiate a Temporal service client.\n// The same client can be used to complete or fail any number of Activities.\n// The client is a heavyweight object that should be created once per process.\ntemporalClient, err := client.Dial(client.Options{})\n\n// Complete the Activity.\ntemporalClient.CompleteActivity(context.Background(), taskToken, result, nil)\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Retries in PHP\nDESCRIPTION: This snippet shows how to attach a Retry Policy to a Workflow Execution using `WorkflowOptions` and `RetryOptions` in the Temporal PHP SDK. It configures the initial retry interval. Dependencies include the Temporal PHP SDK (`WorkflowOptions`, `RetryOptions`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: php\nCODE:\n```\n$workflow = $this->workflowClient->newWorkflowStub(\n      CronWorkflowInterface::class,\n      WorkflowOptions::new()->withRetryOptions(\n        RetryOptions::new()->withInitialInterval(120)\n      )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating an API Key with tcld CLI - Bash\nDESCRIPTION: This snippet demonstrates how to create a new API Key in Temporal Cloud using the tcld CLI with the required --name flag. Dependencies include the installed tcld CLI with access to Temporal Cloud. The main parameter is --name specifying the display name; additional parameters may include --description, --duration, --expiry, and --request-id. The command outputs confirmation and details about the new API Key. The key name must be provided, and appropriate credentials are required.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey create --name <name>\n```\n\n----------------------------------------\n\nTITLE: WorkflowId AND ExecutionStatus Filter\nDESCRIPTION: List Filter that matches a specific WorkflowId that is in Running status.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId = '<workflow-id>' and ExecutionStatus = 'Running'\n```\n\n----------------------------------------\n\nTITLE: Calculating Temporal Workflow Task Latency Average with Prometheus - PromQL\nDESCRIPTION: This Prometheus query calculates the average end-to-end schedule-to-start latency for workflow tasks on Temporal, using bucketed sum and count metrics collected from the Temporal SDK or Temporal Cloud. Requires 'temporal_workflow_task_schedule_to_start_latency_seconds_sum' and 'temporal_workflow_task_schedule_to_start_latency_seconds_count' metrics over a 5-minute window, grouped by namespace and task_queue. Inputs: metrics scope. Output: average latency per task queue. Useful for tracking ongoing system latency health.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_1\n\nLANGUAGE: promql\nCODE:\n```\nsum(increase(temporal_workflow_task_schedule_to_start_latency_seconds_sum[5m])) by (namespace, task_queue)\n/\nsum(increase(temporal_workflow_task_schedule_to_start_latency_seconds_count[5m])) by (namespace, task_queue)\n```\n\n----------------------------------------\n\nTITLE: Registering Dynamic Update Handler in Java\nDESCRIPTION: Example of registering a Dynamic Update Handler in Temporal Java SDK. This handler processes any unregistered Updates sent to the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_24\n\nLANGUAGE: java\nCODE:\n```\nWorkflow.registerListener(\n  (DynamicUpdateHandler)\n      (updateName, encodedArgs) -> encodedArgs.get(0, String.class));\n```\n\n----------------------------------------\n\nTITLE: Promoting Build ID Within Set via Task Queue Update (Legacy)\nDESCRIPTION: This snippet shows how to make an existing Build ID the default within its current compatibility set using the deprecated `client.taskQueue.updateBuildIdCompatibility` method. The `promoteBuildIdWithinSet` operation targets the set containing the specified `buildId` ('deadbeef') and designates it as the default version for task processing within that set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nawait client.taskQueue.updateBuildIdCompatibility('your_task_queue_name', {\n  operation: 'promoteBuildIdWithinSet',\n  buildId: 'deadbeef',\n});\n```\n\n----------------------------------------\n\nTITLE: Dockerfile for Temporal TypeScript Worker using Node.js Slim Image\nDESCRIPTION: This Dockerfile demonstrates how to use a `node:20-bullseye-slim` base image for a smaller Temporal TypeScript Worker container. Since slim images lack root TLS certificates required by the Temporal SDK, it explicitly installs the `ca-certificates` package using `apt-get`. Failure to include this package can lead to transport errors when the Worker tries to connect.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_25\n\nLANGUAGE: dockerfile\nCODE:\n```\n```dockerfile\nFROM node:20-bullseye-slim\n\nRUN apt-get update \\\n    && apt-get install -y ca-certificates \\\n    && rm -rf /var/lib/apt/lists/*\n\n# ... same as with regular image\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Codec Server with HTTPS Endpoint for Temporal Cloud\nDESCRIPTION: This command sets up a codec server with an HTTPS endpoint for a Temporal Cloud Namespace. The endpoint must be a valid HTTPS URL for secure payload decoding.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_62\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-codec-server \\\n    --namespace <namespace_id> \\\n    --endpoint <https_url>\n```\n\n----------------------------------------\n\nTITLE: Specifying Versioning Intent for Activities in Java\nDESCRIPTION: This code shows how to set the versioning intent for an Activity to use the latest assignment rules rather than inheriting from its parent Workflow. It uses the ActivityOptions builder to set the VersioningIntent.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nprivate final MyActivity activity =\n    Workflow.newActivityStub(\n        MyActivity.class,\n        ActivityOptions.newBuilder()\n          .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n          .setVersioningIntent(VersioningIntent.VERSIONING_INTENT_USE_ASSIGNMENT_RULES)\n          // ...other options\n          .build()\n    );\n```\n\n----------------------------------------\n\nTITLE: Describing a Namespace in Temporal Java SDK\nDESCRIPTION: This code snippet shows how to get details for a registered Namespace using the DescribeNamespace API. It returns information and configuration details for the specified Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nimport io.temporal.api.workflowservice.v1.*;\n//...\nDescribeNamespaceRequest descNamespace = DescribeNamespaceRequest.newBuilder()\n            .setNamespace(\"your-namespace-name\") //specify the namespace you want details for\n            .build();\n    DescribeNamespaceResponse describeNamespaceResponse = namespaceservice.blockingStub().describeNamespace(descNamespace);\n    System.out.println(\"Namespace Description: \" + describeNamespaceResponse);\n//...\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Dynamic Activity and Its Workflow Caller in Temporal Python SDK\nDESCRIPTION: These snippets demonstrate (1) how to define a dynamic Activity handler by applying @activity.defn(dynamic=True) so it can resolve invocations of Activities with unknown types, and (2) how to call such a dynamic Activity from within a Workflow. The dynamic Activity receives its arguments as a sequence of RawValue objects, transforms the payload using the activity payload_converter, and builds a formatted result string. The Workflow definition shows how to invoke an Activity by name, with dependencies on YourDataClass and the Temporal Python SDK. Both snippets should be registered appropriately with the Worker, and the Activity expects a single argument with greeting and name attributes. The example highlights the mechanics for dynamic type resolution, input conversion, and temporal invocation constraints.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@activity.defn(dynamic=True)\\nasync def dynamic_greeting(args: Sequence[RawValue]) -> str:\\n    arg1 = activity.payload_converter().from_payload(args[0].payload, YourDataClass)\\n    return (\\n        f\"{arg1.greeting}, {arg1.name}!\\\\nActivity Type: {activity.info().activity_type}\"\\n    )\n```\n\nLANGUAGE: python\nCODE:\n```\n# ...\\n@workflow.defn\\nclass GreetingWorkflow:\\n    @workflow.run\\n    async def run(self, name: str) -> str:\\n        return await workflow.execute_activity(\\n            \"unregistered_activity\",\\n            YourDataClass(\"Hello\", name),\\n            start_to_close_timeout=timedelta(seconds=10),\\n        )\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate with Validity Period using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the validity duration with the `--validity-period` modifier. The value should be formatted as 'd/h', e.g., `30d`. Replace `<value>` with the desired duration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --validity-period <value>\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Job with a Reason (Bash)\nDESCRIPTION: Initiates a `tctl` batch job using a query to select Workflow Executions and includes a reason for the batch operation using the `--reason` modifier. This provides context for why the batch job is being run.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --reason <string>\n```\n\n----------------------------------------\n\nTITLE: Antipattern: Importing Node.js Built-ins in Temporal Workflow Code - TypeScript\nDESCRIPTION: Demonstrates incorrect usage of a Node.js built-in module (fs) within Workflow code, which is disallowed in Temporal Workflow isolates due to non-determinism. The snippet reads from the filesystem using fs.readFileSync, a pattern that should be moved to Activities. No external dependencies except Node.js built-in modules; not allowed in Workflows because file reading is non-deterministic and not replayable. Input is a file path, output is file contents; this approach is unsupported.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport fs from 'fs';\\n\\nconst config = fs.readFileSync('config.json', 'utf8');\n```\n\n----------------------------------------\n\nTITLE: Running Temporal Web UI with Docker and Environment Variables\nDESCRIPTION: This shell command demonstrates how to run the Temporal Web UI Docker container (`temporalio/ui`) while dynamically configuring it using various environment variables (`-e`). It sets parameters such as the Temporal server address (`TEMPORAL_ADDRESS`), UI port (`TEMPORAL_UI_PORT`), public path, authentication details (OIDC provider, client ID/secret, callback URL), TLS settings (CA, cert, key paths), codec server endpoint, and other UI display options. This method allows for flexible configuration without modifying configuration files directly.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-environment-variables.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker run\\\n-e TEMPORAL_ADDRESS=127.0.0.1:7233\\\n-e TEMPORAL_UI_PORT=8080\\\n-e TEMPORAL_UI_PUBLIC_PATH=path/to/webui\\\n-e TEMPORAL_UI_ENABLED=true\\\n-e TEMPORAL_BANNER_TEXT=\"Some banner text\"\\\n-e TEMPORAL_CLOUD_UI=false\\\n-e TEMPORAL_DEFAULT_NAMESPACE=default\\\n-e TEMPORAL_FEEDBACK_URL=https://feedback.here\\\n-e TEMPORAL_NOTIFY_ON_NEW_VERSION=true\\\n-e TEMPORAL_CONFIG_REFRESH_INTERVAL=0s\\\n-e TEMPORAL_SHOW_TEMPORAL_SYSTEM_NAMESPACE=false\\\n-e TEMPORAL_DISABLE_WRITE_ACTIONS=false\\\n-e TEMPORAL_AUTH_ENABLED=true\\\n-e TEMPORAL_AUTH_TYPE=oidc\\\n-e TEMPORAL_AUTH_PROVIDER_URL=https://accounts.google.com\\\n-e TEMPORAL_AUTH_ISSUER_URL=https://accounts.google.com\\\n-e TEMPORAL_AUTH_CLIENT_ID=xxxxx-xxxx.apps.googleusercontent.com\\\n-e TEMPORAL_AUTH_CLIENT_SECRET=xxxxxxxxxxxxxxx\\\n-e TEMPORAL_AUTH_CALLBACK_URL=https://xxxx.com:8080/auth/sso/callback\\\n-e TEMPORAL_AUTH_SCOPES=openid,email,profile\\\n-e TEMPORAL_TLS_CA=../ca.cert\\\n-e TEMPORAL_TLS_CERT=../cluster.pem\\\n-e TEMPORAL_TLS_KEY=../cluster.key\\\n-e TEMPORAL_TLS_ENABLE_HOST_VERIFICATION=true\\\n-e TEMPORAL_TLS_SERVER_NAME=tls-server\\\n-e TEMPORAL_CODEC_ENDPOINT=https://codec.server\\\n-e TEMPORAL_CODEC_PASS_ACCESS_TOKEN=false\\\n-e TEMPORAL_CODEC_INCLUDE_CREDENTIALS=false\\\n-e TEMPORAL_HIDE_LOGS=false\\\ntemporalio/ui:<tag>\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Version Updates in PHP Workflow\nDESCRIPTION: Shows how to manage multiple version updates in a Workflow using Workflow::getVersion(). This pattern allows for gradual updates and maintains compatibility across different versions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/versioning.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n#[WorkflowInterface]\nclass MyWorkflow\n{\n    // ...\n\n    #[WorkflowMethod]\n    public function runAsync()\n    {\n        $version = yield Workflow::getVersion('Step 1', Workflow::DEFAULT_VERSION, maxSupported: 2);\n\n        $result = match($version) {\n            Workflow::DEFAULT_VERSION => yield $this->activity->prePatchActivity()\n            1 => yield $this->activity->postPatchActivity();\n            2 => yield $this->activity->anotherPatchActivity();\n        };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Cron Schedule for Workflow Execution in Java\nDESCRIPTION: Creates a Workflow stub with a Cron Schedule option that turns the Workflow Execution into a Temporal Cron Job. The example shows how to set a cron expression using the WorkflowOptions.Builder with setCronSchedule method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_18\n\nLANGUAGE: java\nCODE:\n```\n//create Workflow stub for YourWorkflowInterface\nYourWorkflowInterface workflow1 =\n    YourWorker.yourclient.newWorkflowStub(\n        YourWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"YourWF\")\n                .setTaskQueue(YourWorker.TASK_QUEUE)\n                // Set Cron Schedule\n                .setCronSchedule(\"* * * * *\")\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Final Implementation of PostPatchActivity in .NET Temporal Workflow\nDESCRIPTION: This snippet demonstrates the final implementation of the Workflow using PostPatchActivity after all versioning steps have been completed and older versions are no longer in use.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/versioning.mdx#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    [WorkflowRun]\n    public async Task RunAsync()\n    {\n        this.result = await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.PostPatchActivity(),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Upserting a Remote Cluster with Frontend Address\nDESCRIPTION: Adds or updates a remote Cluster by specifying its frontend address. This command can be used to configure new clusters or modify existing ones.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator cluster upsert --frontend-address=\"127.0.2.1\"\n```\n\n----------------------------------------\n\nTITLE: Canceling Workflows using a List Filter in Temporal CLI\nDESCRIPTION: This command demonstrates how to cancel Workflows using a List Filter instead of a specific Workflow ID. It allows for more flexible cancellation based on custom criteria.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow cancel --query=MyListFilter\n```\n\n----------------------------------------\n\nTITLE: Default Values for Temporal Retry Policy\nDESCRIPTION: The default configuration values for a Temporal Retry Policy. These values apply to Activity Task Executions by default, including the initial interval of 1 second, backoff coefficient of 2.0, maximum interval of 100× initial interval, unlimited maximum attempts, and no defined non-retryable errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/retry-policies.mdx#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nInitial Interval     = 1 second\nBackoff Coefficient  = 2.0\nMaximum Interval     = 100 × Initial Interval\nMaximum Attempts     = ∞\nNon-Retryable Errors = []\n```\n\n----------------------------------------\n\nTITLE: Consuming Kinesis Audit Logs from S3 using Go\nDESCRIPTION: This Go code snippet demonstrates how to consume Temporal Cloud Audit Logs that have been delivered to an S3 bucket via AWS Kinesis. It uses the AWS SDK for Go (v2) to connect to S3 using a specified profile, retrieve a specific log file object by bucket name and key, read its content, and print it to the standard output. Requires the AWS Go SDK v2, configured AWS credentials (e.g., via profile 'your_profile'), and the correct S3 bucket name and object key ('your_bucket_name', 'your_s3_file_path'). Error handling is basic, printing errors to the console.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/audit-logging-aws.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc main() {\n   fmt.Println(\"print audit log from S3\")\n   cfg, err := config.LoadDefaultConfig(context.TODO(),\n      config.WithSharedConfigProfile(\"your_profile\"),\n   )\n   if err != nil {\n      fmt.Println(err)\n   }\n   s3Client := s3.NewFromConfig(cfg)\n   response, err := s3Client.GetObject(\n      context.Background(),\n      &s3.GetObjectInput{\n         Bucket: aws.String(\"your_bucket_name\"),\n         Key:    aws.String(\"your_s3_file_path\")})\n   if err != nil {\n      fmt.Println(err)\n   }\n   defer response.Body.Close()\n\n   content, err := io.ReadAll(response.Body)\n\n   fmt.Println(string(content))\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Development Server with Nexus\nDESCRIPTION: Command to start the Temporal development server with Nexus enabled. This sets up the server, Web UI, creates the default namespace, and uses an in-memory database.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev\n```\n\n----------------------------------------\n\nTITLE: Deleting a Scheduled Workflow in .NET\nDESCRIPTION: This snippet illustrates how to delete a Scheduled Workflow using the DeleteAsync method on the Schedule Handle.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/schedules.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Client;\nusing Temporalio.Client.Schedules;\n\nvar client = await TemporalClient.ConnectAsync(new(\"localhost:7233\"));\n\nvar handle = client.GetScheduleHandle(\"my-schedule-id\");\nawait handle.DeleteAsync();\n```\n\n----------------------------------------\n\nTITLE: Example Output of Namespace List API - JSON\nDESCRIPTION: This JSON snippet shows the output format returned by the 'tcld namespace list' command. The 'namespaces' array includes Namespace names suffixed with the Account ID, separated by a period. The 'nextPageToken' is provided for pagination but can be empty if no additional results exist. This structure is helpful for programmatic parsing and integration with scripts or automation tools.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/namespaces.mdx#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"namespaces\": [\n    \"your-namespace.123de\",\n    \"another-namespace.123de\"\n  ],\n  \"nextPageToken\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Retryable Nexus Handler Error in Go\nDESCRIPTION: Demonstrates how to create a specific type of Nexus error (`HandlerError`) using the Temporal Go SDK's `nexus` package. This function takes an error type (e.g., `HandlerErrorTypeInternal`) and a message, typically resulting in a retryable error according to the Nexus error retry table. It's recommended for use within Nexus Operation handlers for improved semantics and mapping to HTTP status codes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/failures.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nnexus.HandlerError(nexus.HandlerErrorType, msg)\n```\n\n----------------------------------------\n\nTITLE: Describing Task Queue Poller Information using Temporal CLI\nDESCRIPTION: This command provides poller information for a given Task Queue, including the last access time for each poll request. It's useful for troubleshooting server issues and monitoring Worker capacity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/task-queue.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal task-queue describe --task-queue=MyTaskQueue --task-queue-type=\"activity\"\n```\n\n----------------------------------------\n\nTITLE: Deleting a Namespace Region with API Key Authentication - TCLD CLI - Bash\nDESCRIPTION: Removes a region from a specified Temporal Cloud Namespace using API key authentication with the `tcld` CLI. The `--api-key` flag provides the necessary credentials. Use this when secure access requiring API key is mandated. Inputs include API key, namespace, and replica region. Outputs/errors mirror the CLI's responses.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld --api-key <your_api_key> \\\n    delete-region \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace with Replication using the tcld CLI - Bash\nDESCRIPTION: This CLI snippet demonstrates how to create a new Temporal Cloud Namespace and enable High Availability by configuring primary and replica regions using the tcld command line tool. Requires tcld CLI installed and appropriate authentication. The --namespace flag combines your namespace and account id, while --region must be specified twice: once for the primary and once for the replica. Inputs are the desired namespace identifier and the codes for both regions (must be within the same continent). Using different region codes enables Multi-region Replication. The --api-key flag, if used, must appear immediately after 'tcld' and before 'namespace create'. Output is a new Namespace set up for high availability with ongoing and historical workflows replicated.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/enable.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace create \\\n   --namespace <namespace_id>.<account_id> \\\n   --region <primary_region> \\\n   --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Registering a Namespace with Archival Enabled - Bash\nDESCRIPTION: Registers a new Namespace in Temporal with archival enabled and a specific retention period using the temporal operator CLI. Requires the Temporal service to be running and the operator CLI installed. Parameters include Namespace name, archival state (enabled), and retention duration. Output is a new Namespace configured for archival. Limitation: Some parameters must conform to allowed retention range (1–30 days).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./temporal operator namespace create --namespace=\\\"my-namespace\\\" --global false --history-archival-state=\\\"enabled\\\" --retention=\\\"4d\\\"\\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Winston with Temporal for File Logging\nDESCRIPTION: Example of integrating Winston logger with Temporal to write logs to a file. This approach is useful for production environments where logs need to be collected by external monitoring services.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Runtime } from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\nRuntime.install({ logger });\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Custom Config in Go\nDESCRIPTION: Shows server instantiation via temporal.NewServer() with the temporal.WithConfig(cfg) option to use a specific configuration object (cfg) instead of the default config file. The code assumes cfg is properly constructed according to Temporal Server's requirements. Requires go.temporal.io/server/temporal and a configuration object; result is a server instance using custom settings for operational parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.WithConfig(cfg),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates with Certificate Bundle File\nDESCRIPTION: This command sets the client CA certificates for a Namespace using a certificate bundle file during a certificate rollover process.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Python SDK using API Key (pre v1.6.0)\nDESCRIPTION: Example of creating a Temporal client connection using an API key in Python SDK versions prior to 1.6.0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclient = await Client.connect(\n    <endpoint>,\n    namespace=<namespace_id>.<account_id>,\n    rpc_metadata={\"temporal-namespace\": <namespace_id>.<account_id>, \"Authorization\": f\"Bearer {<APIKey>}\"},\n    tls=True,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Activity Interface in PHP\nDESCRIPTION: PHP interface definition for a simple Activity with a single method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n#[ActivityInterface(prefix: \"SimpleActivity.\")]\ninterface SimpleActivityInterface\n{\n    #[ActivityMethod('doSomething')]\n    public function doSomething(string $input): string;\n```\n\n----------------------------------------\n\nTITLE: Resending Invitation to a User by Email via tcld CLI - Bash\nDESCRIPTION: Resends a Temporal Cloud invitation to a user identified by email. The --user-email flag provides the target address; the command expects the user to have a pending invitation. The process is asynchronous and may require a request ID for tracking.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld user resend-invite --user-email <test@example.com>\n```\n\n----------------------------------------\n\nTITLE: Signing Certificate Request with certstrap (Command Line)\nDESCRIPTION: Uses the `certstrap sign` command to sign the previously generated Certificate Signing Request (CSR) associated with the `NAMESPACE_NAME`. The signing is done using the Certificate Authority (CA) named \"CertAuth\" created earlier. This command generates the final end-entity certificate file (`your-namespace.crt`) in the `out` subdirectory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_6\n\nLANGUAGE: command\nCODE:\n```\n./certstrap sign ${NAMESPACE_NAME} --CA \"CertAuth\"\n```\n\n----------------------------------------\n\nTITLE: Setting Memo for Workflow Execution in Java\nDESCRIPTION: Demonstrates how to add non-indexed information to a Workflow Execution using the Memo option. The example creates a Workflow stub with a Memo containing a key-value pair.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_19\n\nLANGUAGE: java\nCODE:\n```\n//create Workflow stub for GreetWorkflowInterface\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Memo. You can set additional non-indexed info via Memo\n                        .setMemo(ImmutableMap.of(\n                                \"memoKey\", \"memoValue\"\n                        ))\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Adding a Compatible Build ID to an Existing Set using Python SDK (Deprecated)\nDESCRIPTION: Illustrates using the deprecated `client.update_worker_build_id_compatibility` method with `BuildIdOpAddNewCompatible`. This adds a new Build ID (`deadbeef`) to the existing compatible set that already contains `some-existing-build-id` on the specified Task Queue, marking the new Build ID as the default within that set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# ...\nawait client.update_worker_build_id_compatibility(\n    \"your_task_queue_name\", BuildIdOpAddNewCompatible(\"deadbeef\", \"some-existing-build-id\")\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Durable Timer using NewTimer() in Go SDK\nDESCRIPTION: Creates a new Timer in a Temporal Workflow using the NewTimer() function. This timer will persist even through Worker or Temporal Service downtime.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/timers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntimer := workflow.NewTimer(timerCtx, duration)\n```\n\n----------------------------------------\n\nTITLE: Webpack Error Output for Missing Node.js Module in Workflow Bundle - bash\nDESCRIPTION: Shows a sample of the error log output generated by Webpack and the Temporal TypeScript SDK logger when unsupported Node.js built-ins are imported in Workflows. Reveals a module resolution failure for 'fs', assisting in diagnosis. No code dependencies; input is invalid import, output is multistep error log.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n2021-10-14T19:22:00.606Z [INFO] Module not found: Error: Can't resolve 'fs' in '/Users/you/your-project/src'\\n2021-10-14T19:22:00.606Z [INFO] resolve 'fs' in '/Users/you/your-project/src'\\n2021-10-14T19:22:00.606Z [INFO]   Parsed request is a module\\n2021-10-14T19:22:00.606Z [INFO]   using description file: /Users/you/your-project/package.json (relative path: ./src)\\n2021-10-14T19:22:00.606Z [INFO]     Field 'browser' doesn't contain a valid alias configuration\n```\n\n----------------------------------------\n\nTITLE: Defining a Temporal Cloud Namespace Resource in HCL\nDESCRIPTION: Defines a Terraform configuration (`terraform.tf`) to create a Temporal Cloud Namespace. It specifies the required provider (`temporalio/temporalcloud`), provider configuration (implicitly using environment variables or manual setup), and the `temporalcloud_namespace` resource block with parameters like name, regions, accepted client CA (read from `ca.pem` and base64 encoded), and retention period.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_3\n\nLANGUAGE: hcl\nCODE:\n```\nterraform {\n  required_providers {\n    temporalcloud = {\n      source = \"temporalio/temporalcloud\"\n    }\n  }\n}\n\nprovider \"temporalcloud\" {\n\n}\n\nresource \"temporalcloud_namespace\" \"namespace\" {\n  name               = \"terraform\"\n  regions            = [\"aws-us-east-1\"]\n  accepted_client_ca = base64encode(file(\"ca.pem\"))\n  retention_days     = 14\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Workflow with Encrypted Data\nDESCRIPTION: An example workflow function that receives and returns encrypted string data. The encryption/decryption is handled transparently by the PayloadCodec implementation, allowing the workflow code to operate on plaintext data.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function example(message: string): Promise<string> {\n  return `${message}\\nBob: Hi Alice, I'm Workflow Bob.`;\n}\n```\n\n----------------------------------------\n\nTITLE: Describing a Workflow Execution using Temporal CLI\nDESCRIPTION: This command retrieves and displays information about a specific Workflow Execution using its Workflow ID. It's useful for troubleshooting and understanding the state of a Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow describe --workflow-id=meaningful-business-id\n```\n\n----------------------------------------\n\nTITLE: Creating an API Key with Description - tcld CLI - Bash\nDESCRIPTION: This snippet demonstrates adding a description to the API Key upon creation via the tcld CLI. The --description parameter (alias -desc) is used alongside --name to annotate the purpose or usage context for the API Key. The CLI must be properly authenticated with Temporal Cloud. The output will include the API Key with its description.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey create --name <name> --description \"Your API Key\"\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Job without Confirmation (Bash)\nDESCRIPTION: Starts a `tctl` batch job, automatically bypassing the confirmation prompt using the `--yes` (or `-y`) modifier. This is useful for scripting batch operations. The `--query` modifier selects the target Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --yes\n```\n\n----------------------------------------\n\nTITLE: Counting Workflow Executions with tctl Query (Bash)\nDESCRIPTION: Counts Workflow Executions matching a specific SQL-like query using Search Attributes. This command requires Elasticsearch to be enabled on the Temporal Cluster. The example counts all currently running Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow count --query 'ExecutionStatus=\"Running\"'\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Retryable Nexus Operation Error in Go\nDESCRIPTION: Shows how to create an `UnsuccessfulOperationError` using the Temporal Go SDK's `nexus` package, likely via a struct literal taking the operation state and failure details. Throwing this error from a Nexus Operation handler signals a non-retryable failure for the operation, corresponding to the `UnsuccessfulOperationError` Nexus error type, and is recommended for improved semantics.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/failures.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nnexus.UnsuccessfulOperationError{state, failure}\n```\n\n----------------------------------------\n\nTITLE: Registering a Dynamic Update Handler and Validator in Temporal PHP\nDESCRIPTION: Demonstrates registering an Update handler dynamically within the Workflow implementation code using `Workflow::registerUpdate()`. It registers an update named 'pause' with a handler function (closure) that sets the `$this->paused` property to true. An optional validator function is also provided, which checks if the workflow is already paused (`$this->paused === false`) and throws an exception if the validation fails, preventing the handler from running. Requires the `Temporal\\Workflow` facade.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_11\n\nLANGUAGE: php\nCODE:\n```\nWorkflow::registerUpdate(\n    name: 'pause',\n    handler: fn() => $this->paused = true,\n    validator: fn() => $this->paused === false or throw new \\Exception('Workflow is already paused'),\n);\n```\n\n----------------------------------------\n\nTITLE: Source Code for `defineSignal` and `defineQuery` in Temporal SDK (TypeScript)\nDESCRIPTION: Shows the TypeScript source code for the `defineSignal` and `defineQuery` functions from the Temporal TypeScript SDK (`@temporalio/workflow`). These functions return simple definition objects containing the type ('signal' or 'query') and the provided name, rather than creating unique instances. This illustrates the intentional API design.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/**\n * Define a signal method for a Workflow.\n */\nexport function defineSignal<Args extends any[] = []>(\n  name: string,\n): SignalDefinition<Args> {\n  return {\n    type: 'signal',\n    name,\n  };\n}\n\n/**\n * Define a query method for a Workflow.\n */\nexport function defineQuery<Ret, Args extends any[] = []>(\n  name: string,\n): QueryDefinition<Ret, Args> {\n  return {\n    type: 'query',\n    name,\n  };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Connecting Temporal Client with API Key in Python\nDESCRIPTION: This Python snippet shows how to asynchronously connect to a Temporal Cluster using the `temporalio.client.Client`. It uses the previously defined environment variables for the address, namespace, and API key. It also explicitly enables TLS (`tls=True`) and sets the `rpc_metadata` for the namespace, which is typically required for Temporal Cloud connections.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n```\nclient = await Client.connect(\n    TEMPORAL_ADDRESS,\n    namespace=TEMPORAL_NAMESPACE,\n    rpc_metadata={\"temporal-namespace\": TEMPORAL_NAMESPACE},\n    api_key=TEMPORAL_API_KEY,\n    tls=True\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Predefined Cron Schedules Table\nDESCRIPTION: Shows the robfig predefined schedules with their descriptions and equivalent cron expressions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/cron-job.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Schedules              | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | 0 0 1 1 *     |\n| @monthly               | Run once a month, midnight, first of month | 0 0 1 * *     |\n| @weekly                | Run once a week, midnight between Sat/Sun  | 0 0 * * 0     |\n| @daily (or @midnight)  | Run once a day, midnight                   | 0 0 * * *     |\n| @hourly                | Run once an hour, beginning of hour        | 0 * * * *     |\n```\n\n----------------------------------------\n\nTITLE: Importing and Using CaptionedImage Component in Docusaurus (JavaScript/JSX)\nDESCRIPTION: Imports the CaptionedImage React component from a local project path and demonstrates how to embed an illustrative image with a caption in a Docusaurus Markdown+JSX page. Required dependencies include the Docusaurus project with support for MDX/JSX, React, and the CaptionedImage definition at the specified path. Inputs are the image source, title, and display properties; output is a rendered captioned image in the documentation page.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/how-to/privatelink.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { CaptionedImage } from '@site/src/components';\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<CaptionedImage\n    src=\"/img/cloud/high-availability/private-link.png\"\n    title=\"Customer side solution example\"\n    zoom=\"true\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaces in Temporal Cloud\nDESCRIPTION: Bash commands to create caller and target namespaces in Temporal Cloud. These namespaces are required for cross-namespace communication with Nexus.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntcld login\n\ntcld namespace create \\\n\t--namespace <your-caller-namespace> \\\n\t--region us-west-2 \\\n\t--ca-certificate-file 'path/to/your/ca.pem' \\\n\t--retention-days 1\n\ntcld namespace create \\\n\t--namespace <your-target-namespace> \\\n\t--region us-west-2 \\\n\t--ca-certificate-file 'path/to/your/ca.pem' \\\n\t--retention-days 1\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Workflow Task Latency Percentile with Prometheus - PromQL\nDESCRIPTION: This Prometheus query computes the 99th percentile latency for workflow tasks waiting to be started in Temporal, grouped by queue and namespace. Requires metrics from the Temporal SDK or Temporal Cloud, specifically 'temporal_workflow_task_schedule_to_start_latency_seconds_bucket' with a 5-minute window. Returns time-series data for latency, assisting in identifying bottlenecks; ensure Prometheus is scraping SDK metrics. Inputs: monitored namespace and task_queue. Outputs: 99th percentile latency per queue. Limitations: accuracy depends on sufficient request volume within window.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_0\n\nLANGUAGE: promql\nCODE:\n```\nhistogram_quantile(0.99, sum(rate(temporal_workflow_task_schedule_to_start_latency_seconds_bucket[5m])) by (le, namespace, task_queue))\n```\n\n----------------------------------------\n\nTITLE: Inviting Users with tcld Command-Line Tool\nDESCRIPTION: Provides the specific tcld command used to invite users to Temporal Cloud. Executing this command initiates the invitation process, sending an email to the specified user who must accept the invite to join. Requires appropriate account-level role (Global Admin or Account Owner). Further details and options for the command are available via the linked documentation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/user-invite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntcld user invite\n```\n\n----------------------------------------\n\nTITLE: Overriding Activity Next Retry Delay with ApplicationFailure in Temporal TypeScript SDK - TypeScript\nDESCRIPTION: This code example shows how to override an Activity's next retry delay by throwing an ApplicationFailure with a nextRetryDelay parameter using Temporal's TypeScript SDK. It uses ApplicationFailure.create to set custom retry behavior following a failure, which can be helpful for dynamic backoff strategies. Requires the ApplicationFailure class from the SDK. Inputs include details for the failure and desired retry delay (e.g., '15s'). The Activity will be retried after the specified delay.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nthrow ApplicationFailure.create({\n  // ...\n  nextRetryDelay: '15s',\n});\n```\n\n----------------------------------------\n\nTITLE: gRPC Deadline Exceeded Error\nDESCRIPTION: Example of a gRPC timeout error that can occur due to network issues, short timeouts, or an overloaded server. The error includes a stack trace showing where the timeout occurred.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nError: 4 DEADLINE_EXCEEDED: context deadline exceeded\n    at Object.callErrorFromStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call.js:31:26)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client.js:179:52)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:336:141)\n    at Object.onReceiveStatus (/Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/client-interceptors.js:299:181)\n    at /Users/swyx/Work/Temporal/samples-typescript/nextjs-oneclick/node_modules/@grpc/grpc-js/build/src/call-stream.js:145:78\n    at processTicksAndRejections (node:internal/process/task_queues:78:11) {\n  code: 4,\n  details: 'context deadline exceeded',\n  metadata: Metadata {\n    internalRepr: Map(1) { 'content-type' => [Array] },\n    options: {}\n  },\n  page: '/api/getBuyState'\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Temporal CLI Help Command\nDESCRIPTION: Shows how to access help information for any Temporal CLI command\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntemporal [command] --help\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate using Certificate File\nDESCRIPTION: This command removes a client CA certificate by specifying the path to a CA certificate PEM file instead of using an encoded string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Adding a Region with API Key Authentication using tcld (Bash)\nDESCRIPTION: This command demonstrates adding a replica region to a Temporal Cloud Namespace while authenticating using an API key. The API key is provided via the global `--api-key` flag. The command requires the target namespace and the new region.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld --api-key <your_api_key> \\\n    add-region \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate using tcld (Shell)\nDESCRIPTION: Creates a directory `temporal-certs`, navigates into it, and then uses the `tcld gen ca` command to generate a new Certificate Authority (CA) certificate (`ca.pem`) and its private key (`ca.key`). The certificate is set for the organization 'temporal' with a duration of 1 year. This is part of the process for users without existing certificate infrastructure.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmkdir temporal-certs\ncd temporal-certs\ntcld gen ca --org temporal -d 1y --ca-cert ca.pem --ca-key ca.key\n```\n\n----------------------------------------\n\nTITLE: Setting API Key for Temporal Cloud in PHP\nDESCRIPTION: This PHP code demonstrates how to set up an API key for Temporal Cloud client authentication using the withAuthKey method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n$serviceClient = \\Temporal\\Client\\GRPC\\ServiceClient::createSSL(/*...*/)\n    ->withAuthKey('your-api-key');\n```\n\n----------------------------------------\n\nTITLE: Configuring LocalActivityWorkerOnly for Temporal Worker in Go\nDESCRIPTION: Configures the Worker to handle only Workflow Tasks and Local Activity Tasks, skipping polling for regular Activity Tasks. The type is `bool`, and the default is `false`. Note: The example code assigns `1000`, which is likely incorrect for a boolean type and should probably be `true`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_44\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    LocalActivityWorkerOnly: 1000, // Note: Value '1000' likely incorrect for bool type\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespace Defaults in YAML\nDESCRIPTION: Default archival configuration settings applied to new namespaces including state and URI specifications.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nnamespaceDefaults:\n  archival:\n    history:\n      state: 'enabled'\n      URI: 'file:///tmp/temporal_archival/development'\n    visibility:\n      state: 'disabled'\n      URI: 'file:///tmp/temporal_vis_archival/development'\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate using Certificate Fingerprint\nDESCRIPTION: This command removes a client CA certificate by specifying its fingerprint, which is useful when the certificate file is not available.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --ca-certificate-fingerprint <fingerprint>\n```\n\n----------------------------------------\n\nTITLE: Creating a Standard or High Availability Namespace using tcld (Bash)\nDESCRIPTION: This command creates a new Temporal Cloud Namespace. Supplying a single `--region` flag creates a standard Namespace. Supplying two `--region` flags (primary and replica) creates a Namespace with High Availability features. The namespace identifier and at least one region are required.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace create \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <primary_region> [\\\\]\n    [--region <replica_region>] // if adding replica\n```\n\n----------------------------------------\n\nTITLE: Starting a Temporal Workflow with a Start Delay - TypeScript Temporal SDK\nDESCRIPTION: Demonstrates scheduling a one-time Workflow execution in the future using the startDelay option with Temporal's TypeScript SDK. The startDelay parameter specifies the delay duration before Workflow execution is initiated. Requires a Workflow client and a Workflow function; returns a Workflow handle and does not support recurring schedules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/schedules.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = await client.workflow.start(someWorkflow, {\n  // ...\n  startDelay: '2 hours',\n});\n```\n\n----------------------------------------\n\nTITLE: Workflow Initialization with Input Parameters\nDESCRIPTION: Implementation of workflow initialization using @workflow.init decorator to process workflow input before handler execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass MyWorkflowInput:\n    name: str\n\n\n@workflow.defn\nclass WorkflowRunSeesWorkflowInitWorkflow:\n    @workflow.init\n    def __init__(self, workflow_input: MyWorkflowInput) -> None:\n        self.name_with_title = f\"Sir {workflow_input.name}\"\n        self.title_has_been_checked = False\n\n    @workflow.run\n    async def get_greeting(self, workflow_input: MyWorkflowInput) -> str:\n        await workflow.wait_condition(lambda: self.title_has_been_checked)\n        return f\"Hello, {self.name_with_title}\"\n\n    @workflow.update\n    async def check_title_validity(self) -> bool:\n        is_valid = await workflow.execute_activity(\n            check_title_validity,\n            self.name_with_title,\n            schedule_to_close_timeout=timedelta(seconds=10),\n        )\n        self.title_has_been_checked = True\n        return is_valid\n```\n\n----------------------------------------\n\nTITLE: Assigning Namespace Permissions to a User by Email via tcld CLI - Command\nDESCRIPTION: Assigns namespace-level permissions to a user via email. The --user-email flag specifies the target; --namespace-permission is used to list namespaces and permission types. Can be combined with other modifiers for versioning and asynchronous processing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_11\n\nLANGUAGE: command\nCODE:\n```\ntcld user set-namespace-permissions --user-email <test@example.com>\n```\n\n----------------------------------------\n\nTITLE: Toggling Pause/Unpause on a Temporal Schedule using tctl (Shell)\nDESCRIPTION: Pauses or unpauses a specific Temporal Schedule identified by its ID (`--schedule-id`). Uses the `--pause` or `--unpause` flag, respectively. A reason for the state change can be provided using the `--reason` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl schedule toggle --schedule-id 'your-schedule-id' --pause --reason \"paused because the database is down\"\n$ tctl schedule toggle --schedule-id 'your-schedule-id' --unpause --reason \"the database is back up\"\n```\n\n----------------------------------------\n\nTITLE: Updating Visibility Archival URI for a Namespace using tctl\nDESCRIPTION: Updates the URI for storing archived Visibility records using the `--visibility_uri <uri>` modifier with `tctl namespace update`. Note: The documentation states the URI cannot be changed after Archival is first enabled. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --visibility_uri <uri>\n```\n\n----------------------------------------\n\nTITLE: Result of Merging Temporal Search Attributes in Go\nDESCRIPTION: Shows the final state of the Search Attributes map after the two `workflow.UpsertSearchAttributes` calls from the previous example. It illustrates the merging behavior: `CustomIntField` is updated to the value from the second call (2), `CustomBoolField` remains from the first call, and `CustomKeywordField` is added from the second call.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nmap[string]interface{}{\n    \"CustomIntField\": 2, // last update wins\n    \"CustomBoolField\": true,\n    \"CustomKeywordField\": \"seattle\",\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JWT Authorization with Java SDK\nDESCRIPTION: Example of setting up API call authorization in the Java SDK using JWT tokens. This configures the workflow client with an authorization token supplier to authenticate API calls to the Frontend Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nAuthorizationTokenSupplier tokenSupplier =\n  //your implementation of token supplier\n  () -> \"Bearer <Base64 url-encoded value of the token for default JWT ClaimMapper>\";\nWorkflowServiceStubsOptions serviceStubOptions =\n  WorkflowServiceStubsOptions.newBuilder()\n    //other service stub options\n    .addGrpcMetadataProvider(new AuthorizationGrpcMetadataProvider(tokenSupplier))\n    .build();\nWorkflowServiceStubs service = WorkflowServiceStubs.newServiceStubs(serviceStubOptions);\nWorkflowClient client = WorkflowClient.newInstance(service);\n```\n\n----------------------------------------\n\nTITLE: Disabling Workflow Cancellation (workflowCancelDisabled) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to specifically disable the ability for users to cancel Workflow Executions from the Temporal Web UI. Set to `true` to disable. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\nworkflowCancelDisabled: false\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates for a Namespace\nDESCRIPTION: This command sets the client CA certificates for a specified Namespace in Temporal Cloud using the namespace ID and encoded certificate.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --namespace <namespace_id>\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Activity Retry Policy with WorkflowImplementationOptions in Java\nDESCRIPTION: Shows how to set a custom Activity Retry Policy using WorkflowImplementationOptions.Builder, allowing for per-Activity retry configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n          WorkflowImplementationOptions.newBuilder()\n                 .setActivityOptions(\n                      ImmutableMap.of(\n                          \"EmailCustomerGreeting\",\n                          ActivityOptions.newBuilder()\n                                // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                // required when setting Activity options.\n                                .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                .setRetryOptions(\n                                      RetryOptions.newBuilder()\n                                          .setDoNotRetry(NullPointerException.class.getName())\n                                          .build())\n                                .build()))\n                .build();\n```\n\n----------------------------------------\n\nTITLE: Batch Resetting Workflow Executions with Temporal CLI\nDESCRIPTION: The 'temporal workflow reset-batch' command resets multiple Workflow Executions by resetType. It can use an input file with Workflow IDs or a List Filter to specify the Workflows to reset.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow reset-batch --input-file=MyInput --input-separator=\"\\t\"\n```\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow reset-batch --query=MyListFilter\n```\n\n----------------------------------------\n\nTITLE: Extending Default JSON Payload Converter to Support IPv4Address - Python\nDESCRIPTION: This snippet demonstrates customizing the default JSON plain payload converter to serialize and deserialize Python ipaddress.IPv4Address instances using a subclassed JSONEncoder and JSONTypeConverter. This approach is suited to adding support for new Python types in existing JSON serialization, preserving compatibility with collections, unions, and nested types. The solution requires Python standard library's json and ipaddress, along with Temporal's Data Converter classes. It replaces the default JSON payload converter in the CompositePayloadConverter for seamless operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/converters-and-encryption.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass IPv4AddressJSONEncoder(AdvancedJSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, ipaddress.IPv4Address):\n            return str(o)\n        return super().default(o)\nclass IPv4AddressJSONTypeConverter(JSONTypeConverter):\n    def to_typed_value(\n        self, hint: Type, value: Any\n    ) -> Union[Optional[Any], _JSONTypeConverterUnhandled]:\n        if issubclass(hint, ipaddress.IPv4Address):\n            return ipaddress.IPv4Address(value)\n        return JSONTypeConverter.Unhandled\n\nclass IPv4AddressPayloadConverter(CompositePayloadConverter):\n    def __init__(self) -> None:\n        # Replace default JSON plain with our own that has our encoder and type\n        # converter\n        json_converter = JSONPlainPayloadConverter(\n            encoder=IPv4AddressJSONEncoder,\n            custom_type_converters=[IPv4AddressJSONTypeConverter()],\n        )\n        super().__init__(\n            *[\n                c if not isinstance(c, JSONPlainPayloadConverter) else json_converter\n                for c in DefaultPayloadConverter.default_encoding_payload_converters\n            ]\n        )\n\nmy_data_converter = dataclasses.replace(\n    DataConverter.default,\n    payload_converter_className=IPv4AddressPayloadConverter,\n)\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Timer Internally using new CancellationScope in TypeScript\nDESCRIPTION: This snippet provides an alternative implementation for internally cancelling a timer (`sleep`). It explicitly creates a `CancellationScope` instance, runs the `sleep(1)` operation within this scope using `scope.run()`, immediately calls `scope.cancel()` to initiate cancellation, and then awaits the promise returned by `scope.run()`. The `try...catch` block catches the resulting `CancelledFailure`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimerAltImpl(): Promise<void> {\n  try {\n    const scope = new CancellationScope();\n    const promise = scope.run(() => sleep(1));\n    scope.cancel(); // <-- Cancel the timer created in scope\n    await promise; // <-- Throws CancelledFailure\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Persistence Configuration for Dual Visibility in Temporal\nDESCRIPTION: YAML configuration that shows how to set up both primary and secondary visibility stores in a Temporal cluster. The example demonstrates migrating from Cassandra to Elasticsearch by configuring both datastores and specifying the primary and secondary visibility store references.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  visibilityStore: cass-visibility\n  secondaryVisibilityStore: es-visibility\n  datastores:\n    cass-visibility:\n    cassandra:\n      hosts: '127.0.0.1'\n      keyspace: 'temporal_visibility'\n    es-visibility:\n    elasticsearch:\n      version: 'v7'\n      logLevel: 'error'\n      url:\n      scheme: 'http'\n      host: '127.0.0.1:9200'\n      indices:\n      visibility: temporal_visibility_v1_dev\n      closeIdleConnectionsInterval: 15s\n```\n\n----------------------------------------\n\nTITLE: Specifying Workflow ID in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that shows the History of a Workflow Execution by specifying a Workflow Id. Can be shortened to -w.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --workflow_id <id>\n```\n\n----------------------------------------\n\nTITLE: Testing Temporal Cloud Prometheus Endpoint with curl - Bash\nDESCRIPTION: This snippet demonstrates how to use the curl command in Bash to test the Prometheus metrics endpoint generated by Temporal Cloud. The command uses client certificate-based authentication, specifying the certificate and key files as parameters, and issues a Prometheus query for metric temporal_cloud_v0_state_transition_count. Required dependencies include curl and access to valid certificate files. The command outputs the metric data in response, and may return data only if workflows are running on the Temporal instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/prometheus-grafana.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v --cert <path to your client-cert.pem> --key <path to your client-cert.key> \"<your generated Temporal Cloud prometheus_endpoint>/api/v1/query?query=temporal_cloud_v0_state_transition_count\"\n```\n\n----------------------------------------\n\nTITLE: Adding Event in Cluster C After Failover in Temporal\nDESCRIPTION: This snippet shows adding an event with ID 4 and version 3 in Cluster C after a namespace failover. This illustrates how different clusters can create divergent versions of the workflow history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               | 4               | 3       |\n| 4        | 3               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Incorrect Concurrent Handler State Mutation in Temporal Workflow - TypeScript Example\nDESCRIPTION: Shows a problematic case where multiple concurrent executions of a handler mutate shared state without synchronization. Requires the Temporal TypeScript SDK, and an async handler running in a Temporal workflow, using 'setHandler' and awaiting asynchronous operations (like wf.sleep). The lack of locking can cause state variables 'x' and 'y' to become inconsistent if handler executions interleave. Inputs are not explicitly parameterized, but the code assumes handlers may run concurrently and output is undefined due to potential race conditions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function myWorkflow(): Promise<MyWorkflowOutput> {\n  let x = 0;\n  let y = 0;\n  wf.setHandler(mySignal, async () => {\n    const data = await myActivity();\n    x = data.x;\n\n    // 🐛🐛 Bug!! If multiple instances of this handler are executing\n    // concurrently, then there may be times when the Workflow has x from one\n    // Activity execution and y from another.\n    await wf.sleep(500); // or await anything else\n\n    y = data.y;\n  });\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Temporal Activity Types and Names (PHP)\nDESCRIPTION: This snippet demonstrates how to define an Activity interface in PHP, specifying a custom prefix for all Activity names using the #[ActivityInterface] attribute. It also shows overriding individual method names using #[ActivityMethod]. This approach can help organize and differentiate Activities in workflows. Inputs and outputs are clearly specified; dependencies include the Temporal PHP SDK attributes system.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/core-application.mdx#2025-04-23_snippet_7\n\nLANGUAGE: php\nCODE:\n```\n#[ActivityInterface(\"file_activities.\")]\ninterface FileProcessingActivities\n{\n    public function upload(string $bucketName, string $localName, string $targetName);\n\n    #[ActivityMethod(\"transcode_file\")]\n    public function download(string $bucketName, string $remoteName);\n\n    public function processFile(): string;\n\n    public function deleteLocalFile(string $fileName);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow with Reject Condition in Bash\nDESCRIPTION: Example of using the tctl workflow query command with the query_reject_condition modifier. This allows rejection of queries based on Workflow state, with valid values being 'not_open' and 'not_completed_cleanly'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow query --query_reject_condition <value>\n```\n\n----------------------------------------\n\nTITLE: Adding Search Attributes with Request ID in Temporal Cloud CLI\nDESCRIPTION: Command to add custom search attributes with a specific request identifier for tracking the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes add \\\n    --request-id <request_id> \\\n    --search-attribute <value>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Overlapping Workflow Runs in Temporal Schedules\nDESCRIPTION: This ASCII diagram demonstrates how overlapping Workflow runs are handled in Temporal Schedules, particularly in relation to accessing the last completion result. It shows four runs (A, B, C, D) with different start and end times, explaining which result would be available to run D at a specific point in time.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/schedule.mdx#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ntime ------------------------------------------>\\n A     |----------------------|\\n B               |-------|\\n C                          |---------------|\\n D                                |--------------T\n```\n\n----------------------------------------\n\nTITLE: Testing PrivateLink with Temporal CLI\nDESCRIPTION: Command to test AWS PrivateLink connectivity using the Temporal CLI. It demonstrates how to override the TLS server name and specify the necessary parameters for a secure connection.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/aws-privatelink.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow count \\\n    --address <DNS associated with VPC endpoint>:7233 \\\n    --tls-cert-path /path/to/client.pem \\\n    --tls-key-path /path/to/client.key \\\n    --tls-server-name <namespace_id>.<account_id>.tmprl.cloud \\\n    --namespace <namespace_id>.<account_id>\n```\n\n----------------------------------------\n\nTITLE: Running Caller Worker Connected to Temporal Cloud\nDESCRIPTION: Bash command to run a Nexus caller Worker connected to Temporal Cloud using mTLS certificates. This worker initiates Nexus operations from the caller namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.caller.CallerWorker \\\n  --args=\"-target-host <your-caller-namespace.account>.tmprl.cloud:7233 \\\n  -namespace <your-caller-namespace.account> \\\n  -client-cert 'path/to/your/ca.pem' \\\n  -client-key 'path/to/your/ca.key'\"\n```\n\n----------------------------------------\n\nTITLE: Multiple Search Attributes Creation - Server v1.20\nDESCRIPTION: Bash function to create multiple custom Search Attributes with namespace association, designed for SQL databases in Temporal Server v1.20.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nadd_custom_search_attributes() {\n    until temporal operator search-attribute list --namespace \"${DEFAULT_NAMESPACE}\"; do\n      echo \"Waiting for namespace cache to refresh...\"\n      sleep 1\n    done\n    echo \"Namespace cache refreshed.\"\n\n    echo \"Adding Custom*Field search attributes.\"\n\n    temporal operator search-attribute create --namespace \"${DEFAULT_NAMESPACE}\" --yes \\\n        --name=\"CustomKeywordField\" --type=\"Keyword\" \\\n        --name=\"CustomStringField\" --type=\"Text\" \\\n        --name=\"CustomTextField\" --type=\"Text\" \\\n        --name=\"CustomIntField\" --type=\"Int\" \\\n        --name=\"CustomDatetimeField\" --type=\"Datetime\" \\\n        --name=\"CustomDoubleField\" --type=\"Double\" \\\n        --name=\"CustomBoolField\" --type=\"Bool\"\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Replica Region from a Namespace using the tcld CLI - Bash\nDESCRIPTION: This snippet shows how to remove a replica from a Temporal Cloud Namespace using the tcld CLI, disabling High Availability and automatic failover. Requires tcld and appropriate permissions. The --namespace parameter targets the affected namespace, and --region specifies the replica to remove. If using API key authentication, the --api-key flag must come immediately after 'tcld' and before 'namespace delete-region'. After running the command, High Availability is disabled, related charges cease, and the system enforces a 7-day cooldown before re-enabling replication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/enable.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace delete-region \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Visualizing Workflow Task Event Conflict Resolution\nDESCRIPTION: Diagrams showing how workflow tasks may become invalidated during conflict resolution when a workflow execution has multiple history branches in multi-cluster replication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n| -------- | ------------- |\n| Events   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n|          |\n|          |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event |\n| -------- | ------------- |\n```\n\nLANGUAGE: text\nCODE:\n```\n| ------------- | -------------- |\n| Events        |\n| ------------- | -------------- |\n| Event ID      | Event Version  |\n| ------------- | -------------- |\n| 1             | 1              |\n| 2             | 1              |\n| 3             | 2              |\n| ------------- | -------------- |\n\n| --------------| -------------- |                                  |----------| ----------------- |\n| Event ID | Event Version |  | Event ID | Event Version |\n| -------- | ------------- || -------- | ----------------- |\n| 4   | 2   | <-- task A belongs to this event | 4 | 3 | <-- current branch / mutable state |\n| --- | --- || -------- | ----------------- |\n```\n\n----------------------------------------\n\nTITLE: Printing specific event details in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that displays details of a specific event by ID. Default is 0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --event_id <id>\n```\n\n----------------------------------------\n\nTITLE: Applying Terraform Configuration\nDESCRIPTION: Executes the `terraform apply` command. This command analyzes the Terraform configuration files, determines the necessary changes to reach the desired state, and prompts the user for confirmation before creating, updating, or deleting resources in Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nterraform apply\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate with Resource Version\nDESCRIPTION: This command removes a client CA certificate with a specified resource version (ETag) to ensure updates are applied to the intended version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --resource-version <etag> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS (cors) in Temporal Web UI (YAML)\nDESCRIPTION: Defines Cross-Origin Resource Sharing (CORS) settings for the Temporal Web UI Server API. Specifies a list of allowed origins (domains) and whether cookies can be sent insecurely (e.g., for local development).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ncors:\n  cookieInsecure: false\n  allowOrigins:\n    - http://localhost:3000 # used at development by https://github.com/temporalio/ui\n```\n\n----------------------------------------\n\nTITLE: Disabling Python Sandbox for an Entire Workflow\nDESCRIPTION: This snippet shows how to completely disable the Temporal sandbox environment for an entire Workflow definition in Python. By setting the `sandboxed` argument to `False` in the `@workflow.defn` decorator, the Workflow will execute without any sandbox restrictions or determinism checks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n```python\n@workflow.defn(sandboxed=False)\n```\n```\n\n----------------------------------------\n\nTITLE: Setting ScheduleToStartTimeout with WorkflowImplementationOptions in Java\nDESCRIPTION: This code shows how to set the ScheduleToStartTimeout using WorkflowImplementationOptions within a Worker. It's part of the ActivityOptions reference section.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_25\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n             WorkflowImplementationOptions.newBuilder()\n                      .setActivityOptions(\n                              ImmutableMap.of(\n                                \"GetCustomerGreeting\",\n                                ActivityOptions.newBuilder()\n                                    .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                    .build()))\n                      .build();\n```\n\n----------------------------------------\n\nTITLE: Querying Active History Task Error Rate using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of errors (`task_errors`) encountered during the processing of active history tasks over the last 1 minute. It filters for operations matching the pattern `TransferActive.*`. This helps identify issues in processing critical history tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_9\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(task_errors{operation=~\"TransferActive.*\"}[1m]))\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Cloud Service Account using tcld (bash)\nDESCRIPTION: Demonstrates creating a Temporal Cloud Service Account using the `tcld service-account create` command. It specifies the name (`-n \"sa_test\"`), description (`-d \"this is a test SA\"`), and account role (`--ar \"Read\"`). This command requires `name` and `account-role` attributes and optionally accepts namespace permissions (`--np`). It returns the `ServiceAccountId` upon successful creation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/service-accounts.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld service-account create -n \"sa_test\" -d \"this is a test SA\" --ar \"Read\"\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Cloud Namespace using tcld (Bash)\nDESCRIPTION: This command deletes the specified Temporal Cloud Namespace. It requires the namespace identifier to target the correct Namespace for deletion. Optional flags like `--request-id` and `--resource-version` can be used for asynchronous operations and concurrency control.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace delete \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Logging Level in Python\nDESCRIPTION: Illustrates how to set the minimum logging level for the application using Python's standard `logging` module. This example configures the root logger to output messages with severity INFO and above, affecting logs from both the application and the Temporal SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate Specifying Output File using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the output path for the generated X.509 leaf certificate `.pem` file using the `--certificate-file` modifier. Replace `<path>` with the desired file path for the leaf certificate.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Configuring DisableStickyExecution for Temporal Worker in Go (Deprecated)\nDESCRIPTION: This option, when set to `true`, disables Sticky Executions. Sticky execution is an optimization where Workflow Tasks are preferentially routed to the same Worker. Disabling it can harm performance and is deprecated; `SetStickyWorkflowCacheSize` should be used instead. The type is `bool`, default is `false`. The associated code example actually configures `StickyScheduleToStartTimeout`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_37\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    StickyScheduleToStartTimeout: time.Second(5),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Querying PollWorkflowTaskQueue Rate in Prometheus\nDESCRIPTION: Prometheus query to measure the per-second average rate of PollWorkflowTaskQueue long poll requests. Helps monitor Worker polling frequency for Workflow Tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/performance-bottlenecks.mdx#2025-04-23_snippet_1\n\nLANGUAGE: prometheus\nCODE:\n```\nrate(temporal_long_request_total{operation=\"PollWorkflowTaskQueue\"})\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Nexus Operation Handler in Java\nDESCRIPTION: Java class implementing a synchronous Nexus Operation handler for the 'echo' operation. It uses OperationHandler.sync to define a simple RPC handler that echoes the input message.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n@ServiceImpl(service = NexusService.class)\npublic class NexusServiceImpl {\n  @OperationImpl\n  public OperationHandler<NexusService.EchoInput, NexusService.EchoOutput> echo() {\n    return OperationHandler.sync(\n        (ctx, details, input) -> new NexusService.EchoOutput(input.getMessage()));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Worker Connection with TypeScript SDK v1.10.0+ using API Key\nDESCRIPTION: Establishes a worker connection to Temporal Cloud using TypeScript SDK v1.10.0 or newer with NativeConnection. Sets up the worker with proper authentication and namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = await NativeConnection.connect(\n    address: <endpoint>,\n    tls: true,\n    apiKey: <APIKey>,\n    metadata: {\n      'temporal-namespace': <namespace_id>.<account_id>,\n    },\n)\nconst worker = await Worker.create({\n    connection,\n    namespace: <namespace_id>.<account_id>,\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Globally Disabling Write Actions (disableWriteActions) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to globally disable all user-initiated write actions (like cancel, terminate, signal, reset) within the Temporal Web UI. Setting it to `true` overrides individual action disable flags like `workflowCancelDisabled`. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ndisableWriteActions: false\n```\n\n----------------------------------------\n\nTITLE: Clearing Certificate Filters with Namespace Specification in Temporal Cloud CLI\nDESCRIPTION: Command to clear all certificate filters from a namespace. This allows any client certificate chaining to a configured CA certificate to connect to the namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters clear \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Passing Complex EJSON-Compatible Arguments to Temporal Workflows in TypeScript\nDESCRIPTION: Illustrates constructing a User object with a variety of supported data types and starting a workflow with it as an argument using the custom EJSON payloadConverter. Depends on uuid utility for id generation and a pre-configured Client instance. Shows unsupported BigInt field as a comment. Key parameters include the user object and workflow options. Returns a workflow handle; input is a user object, output is a workflow execution handle.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst user: User = {\n  id: uuid(),\n  // age: 1000n, BigInt isn't supported\n  hp: Infinity,\n  matcher: /.*Stormblessed/,\n  token: Uint8Array.from([1, 2, 3]),\n  createdAt: new Date(),\n};\n\nconst handle = await client.workflow.start(example, {\n  args: [user],\n  taskQueue: 'ejson',\n  workflowId: `example-user-${user.id}`,\n});\n```\n\n----------------------------------------\n\nTITLE: Assigning Temporal Roles Using Bit Masks (Go)\nDESCRIPTION: This Go code sample demonstrates how to combine multiple role constants (RoleReader and RoleWriter) with a bitwise OR operation to create a composite role value for authorization in Temporal. Dependencies include the 'authorization' package which defines role constants, and it must be run in a context where those roles are defined. The code expects to be executed within a plugin such as ClaimMapper, and outputs an integer representing the combined roles, to be returned as Claims for the caller.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nrole := authorization.RoleReader | authorization.RoleWriter\n```\n\n----------------------------------------\n\nTITLE: Bearer Token Format for Authorization Header (Markdown)\nDESCRIPTION: This markdown snippet shows the required format for a JWT bearer token as expected in the HTTP 'Authorization' header for Temporal service authentication. The token must be prefixed by the 'Bearer' keyword and then the encoded JWT. Clients must ensure to use this exact header structure; otherwise, the server may reject requests due to malformed or missing authentication credentials.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nBearer <token>\n```\n\n----------------------------------------\n\nTITLE: Importing React Components in Docusaurus Page (JavaScript)\nDESCRIPTION: This JavaScript snippet imports two React components, RelatedReadContainer and RelatedReadItem, from a site-specific components directory. These components are used within the markdown documentation to render related reading sections or callouts. This import assumes that the documentation is set up using Docusaurus or a similar React-based static site framework that allows inline React component usage in markdown files.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/web-ui.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { RelatedReadContainer, RelatedReadItem } from '@site/src/components';\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal Worker Poll Success Rate with Prometheus\nDESCRIPTION: A PromQL query designed for Prometheus monitoring systems. It calculates the rate of successful polls (sync and async) versus total polls (success + timeouts) over a 5-minute window, aggregated by `temporal_namespace`. Used to detect potential 'greedy worker' scenarios where poll success rate is low. Assumes Prometheus is scraping the relevant Temporal Cloud metrics. Requires a `$namespace` variable to be set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_7\n\nLANGUAGE: promql\nCODE:\n```\n(\n    (\n        sum by(temporal_namespace) (\n          rate(\n            temporal_cloud_v0_poll_success_count{temporal_namespace=~\"$namespace\"}[5m]\n          )\n        )\n      +\n        sum by(temporal_namespace) (\n          rate(\n            temporal_cloud_v0_poll_success_sync_count{temporal_namespace=~\"$namespace\"}[5m]\n          )\n        )\n    )\n  /\n    (\n        (\n            sum by(temporal_namespace) (\n              rate(\n                temporal_cloud_v0_poll_success_count{temporal_namespace=~\"$namespace\"}[5m]\n              )\n            )\n          +\n            sum by(temporal_namespace) (\n              rate(\n                temporal_cloud_v0_poll_success_sync_count{temporal_namespace=~\"$namespace\"}[5m]\n              )\n            )\n        )\n      +\n        sum by(temporal_namespace) (\n          rate(\n            temporal_cloud_v0_poll_timeout_count{temporal_namespace=~\"$namespace\"}[5m]\n          )\n        )\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Starting an Update asynchronously on a Workflow in Temporal TypeScript\nDESCRIPTION: Example demonstrating how to start an Update asynchronously using WorkflowHandle.startUpdate. This returns a handle immediately after the Update is accepted, allowing the caller to fetch results later with updateHandle.result().\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst updateHandle = await handle.startUpdate(setLanguage, {\n  args: [Language.ENGLISH],\n  waitForStage: WorkflowUpdateStage.ACCEPTED,\n});\npreviousLanguage = await updateHandle.result();\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow in C# (.NET)\nDESCRIPTION: This snippet demonstrates how to define a Workflow in C# using Temporal attributes. It defines a class with a method annotated with [WorkflowRun].\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class YourBasicWorkflow {\n\n    [WorkflowRun]\n    public async Task<string> workflowExample(string param) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing All Namespaces with TCLD CLI - Bash\nDESCRIPTION: Lists all existing Temporal Cloud Namespaces using the `tcld namespace list` command. No additional modifiers are necessary for execution. This operation is primarily used for monitoring or enumerating project namespaces. No input is required besides the basic command; output is a list of namespaces managed by the current account.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace list\n```\n\n----------------------------------------\n\nTITLE: Displaying Version History Table Without Data Conflict in Temporal Workflow\nDESCRIPTION: This snippet demonstrates how version history is tracked for a Workflow Execution with no data conflicts across multiple clusters. It shows a step-by-step progression of events with their corresponding versions as new events are added and when namespace failover occurs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 1               | 1       |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Defining Nomad Service Health Check for Temporal - HCL\nDESCRIPTION: These snippets demonstrate how to configure health checks for the Temporal Frontend Service using HashiCorp Nomad's job specification. Both TCP and gRPC methods are provided, each checking connectivity on port 7233 at 10-second intervals with a 2-second timeout. Place these stanzas within the 'service' block of a Nomad job to ensure that orchestrated Temporal containers are reported as healthy only when their main interfaces are reachable. gRPC-based checks require Consul 1.0.5 or newer.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_5\n\nLANGUAGE: hcl\nCODE:\n```\nservice {\n  check {\n    type     = \"tcp\"\n    port     = 7233\n    interval = \"10s\"\n    timeout  = \"2s\"\n  }\n\n```\n\nLANGUAGE: hcl\nCODE:\n```\nservice {\n  check {\n    type         = \"grpc\"\n    port         = 7233\n    interval     = \"10s\"\n    timeout      = \"2s\"\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Executing Workflow for Dynamic Signal (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow execute` command to start an instance of `GreetingWorkflow`. It targets the `dynamic-signal-task-queue` where the dynamic signal worker is listening and runs in the `default` namespace. This workflow is set up to receive signals that will be processed by the dynamic signal handler.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute \\\n --task-queue dynamic-signal-task-queue \\\n --type GreetingWorkflow \\\n --namespace default\n```\n\n----------------------------------------\n\nTITLE: Clearing Certificate Filters with Resource Version in Temporal Cloud CLI\nDESCRIPTION: Command to clear all certificate filters from a namespace using a specific resource version (ETag) to ensure the operation starts from the correct version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters clear \\\n    --resource-version <etag>\n```\n\n----------------------------------------\n\nTITLE: Example Single Sign On URL for Okta SAML Integration\nDESCRIPTION: Provides a concrete example of a correctly formatted Single Sign On URL for Temporal Cloud SAML integration using Okta. This example uses 'f45a2' as the placeholder Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nhttps://login.tmprl.cloud/login/callback?connection=f45a2-saml\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Result from Untyped Workflow Stub - Temporal PHP\nDESCRIPTION: Shows usage of getResult(timeout) on an untyped Workflow stub to retrieve the Workflow Execution result, with an optional timeout in seconds. If the Workflow does not complete within the timeout, an exception is thrown. Dependencies are the WorkflowClient, the untyped stub configured with Workflow Type, and any initialization parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_14\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newUntypedWorkflowStub('account.transfer');\\n$workflowClient->start($stub, 'fromID', 'toID', 'refID', 1000);\\n\\nvar_dump($stub->getResult(timeout: 5.5));\\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Schedule with Interval/Calendar using tctl (Shell)\nDESCRIPTION: Creates a new Temporal Schedule using interval and calendar specifications. This requires setting tctl version to 'next', providing a Schedule ID (`--schedule-id`), interval (`--interval`), calendar spec (`--calendar`), overlap policy (`--overlap-policy`), target Workflow ID (`--workflow-id`), Task Queue (`--task-queue`), and Workflow Type (`--workflow-type`). The example creates a schedule that runs every 5 hours at 15 minutes past the hour, and also at 11:03 on Fridays, buffering overlapping runs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl config set version next   # ensure you're using the new tctl\n$ tctl schedule create \\\n    --schedule-id 'your-schedule-id' \\\n    --interval '5h/15m' \\\n    --calendar '{\"dayOfWeek\":\"Fri\",\"hour\":\"11\",\"minute\":\"3\"}' \\\n    --overlap-policy 'BufferAll' \\\n    --workflow-id 'your-workflow-id' \\\n    --task-queue 'your-task-queue' \\\n    --workflow-type 'YourWorkflowType'\n```\n\n----------------------------------------\n\nTITLE: Applying Terraform Configuration for Temporal Cloud Users\nDESCRIPTION: Command to apply the Terraform configuration to create Temporal Cloud Users. This will prompt for confirmation and execute the defined resources.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_15\n\nLANGUAGE: command\nCODE:\n```\nterraform apply\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates with Resource Version\nDESCRIPTION: This command sets client CA certificates with a specified resource version (ETag) to ensure updates are applied to the intended version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --resource-version <etag> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate Specifying CA Certificate File using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the path to the signing Certificate Authority's X.509 certificate `.pem` file using the `--ca-certificate-file` modifier. Replace `<path>` with the path to the CA certificate file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Setting TaskQueue via WorkflowImplementationOptions in Java\nDESCRIPTION: This snippet shows how to set a specific Task Queue ('yourTaskQueue') per Activity type (`EmailCustomerGreeting`) using `WorkflowImplementationOptions`. This configuration ensures Activities of this type are scheduled on the designated Task Queue when invoked by Workers using these options. It also sets a required `StartToCloseTimeout`. Dependencies include `io.temporal.worker.WorkflowImplementationOptions`, `com.google.common.collect.ImmutableMap`, `io.temporal.activity.ActivityOptions`, and `java.time.Duration`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_31\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                              \"EmailCustomerGreeting\",\n                                    ActivityOptions.newBuilder()\n                                          // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\n                                          // required when setting Activity options.\n                                          .setStartToCloseTimeout(Duration.ofSeconds(5))\n                                          .setTaskQueue(\"yourTaskQueue\")\n                                          .build()))\n                    .build();\n```\n\n----------------------------------------\n\nTITLE: Executing a Workflow using Temporal CLI\nDESCRIPTION: This command starts a new Workflow Execution with specified Workflow ID, type, and Task Queue. It demonstrates the basic syntax for executing a Workflow from the CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute --workflow-id=meaningful-business-id --type=MyWorkflow --task-queue=MyTaskQueue\n```\n\n----------------------------------------\n\nTITLE: Querying Prometheus Metrics for Resource Exhaustion Errors\nDESCRIPTION: A PromQL (Prometheus Query Language) query used to monitor Temporal Service health by checking for resource exhaustion errors. It calculates the rate of `service_errors_resource_exhausted` metrics over a 1-minute window, grouped by the `resource_exhausted_cause` label. This helps identify if the 'deadline exceeded' error might be caused by the Temporal Service being overloaded (e.g., hitting RPS limits, concurrent request limits, or general system overload).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/deadline-exceeded-error.mdx#2025-04-23_snippet_2\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(service_errors_resource_exhausted{}[1m])) by (resource_exhausted_cause)\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace Export Sink with TCLD CLI - Command\nDESCRIPTION: Run this CLI command to create an S3 export sink for a Temporal Cloud Namespace. This command requires the `tcld` CLI tool, and parameters for namespace, sink name, IAM role ARN, and S3 bucket name. Supply the correct values for each parameter to complete the setup; outputs and logs are shown in the standard CLI output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/aws-export-s3.mdx#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ntcld namespace export s3 create --namespace \"your-namespace.your-account\" --sink-name \"your-sink-name\" --role-arn \"arn:aws:iam::123456789012:role/test-sink\" --s3-bucket-name \"your-aws-s3-bucket-name”\n```\n\n----------------------------------------\n\nTITLE: Retrieving an API Key - tcld CLI - Bash\nDESCRIPTION: This command retrieves the details for a specific API Key identified by its unique --id parameter. The command requires the tcld CLI and access rights to query API Keys. The output displays full details for the given API Key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey get --id <apikey_id>\n```\n\n----------------------------------------\n\nTITLE: Using Wait Conditions in Temporal PHP Update Handlers\nDESCRIPTION: Example of using Workflow::await() to make an Update handler wait until a specific condition is met before proceeding with execution, allowing for controlled execution flow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/message-passing.mdx#2025-04-23_snippet_17\n\nLANGUAGE: php\nCODE:\n```\n    #[UpdateMethod]\n    public function myUpdate(UpdateInput $input)\n    {\n        yield Workflow::await(\n            fn() => $this->readyForUpdateToExecute($input),\n        );\n\n        // ...\n    }\n```\n\n----------------------------------------\n\nTITLE: Formatting Cron Schedule in Temporal CLI\nDESCRIPTION: Demonstrates the format for cron schedules in Temporal CLI, showing the standard 5-field cron expression format with minute, hour, day of month, month, and day of week.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/cmd-options.mdx#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate with Validity Period using tcld\nDESCRIPTION: This command generates a Certificate Authority (CA) certificate using `tcld`, specifying the validity duration with the `--validity-period` modifier. The value should be formatted as 'd/h', e.g., `365d`. Replace `<value>` with the desired duration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --validity-period <value>\n```\n\n----------------------------------------\n\nTITLE: Cloning the Temporal Go Samples Repository\nDESCRIPTION: Commands to clone and navigate to the Nexus sample in the Go samples repository, which contains complete example code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/temporalio/samples-go.git\ncd samples-go/nexus\n```\n\n----------------------------------------\n\nTITLE: Displaying tctl Workflow Help\nDESCRIPTION: This command displays help specifically for the 'workflow' subcommand group in tctl, listing available operations related to Temporal Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ntctl workflow -h\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Python Sandbox Restriction for a Module Class\nDESCRIPTION: This Python example demonstrates adding a custom restriction to the Temporal sandbox to prevent the use of the `datetime.date` class. It modifies the default `invalid_module_members` by combining the default restrictions (`SandboxRestrictions.invalid_module_members_default`) with a new `SandboxMatcher` using the pipe operator (`|`). This custom restriction set is then applied to the `SandboxedWorkflowRunner` during Worker initialization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/python-sdk-sandbox.mdx#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n```python\nmy_restrictions = dataclasses.replace(\n    SandboxRestrictions.default,\n    invalid_module_members=SandboxRestrictions.invalid_module_members_default | SandboxMatcher(\n      children={\"datetime\": SandboxMatcher(use={\"date\"})},\n    ),\n)\nmy_worker = Worker(..., workflow_runner=SandboxedWorkflowRunner(restrictions=my_restrictions))\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting Certificate Filters to File in Temporal Cloud CLI\nDESCRIPTION: Command to export existing certificate filters from a namespace to a JSON file. This allows you to save current configurations for backup or modification.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters export \\\n    --certificate-filter-file <path>\n```\n\n----------------------------------------\n\nTITLE: Enabling Cloud UI (cloudUi) in Temporal Web UI (YAML)\nDESCRIPTION: Configuration setting to enable or disable the Temporal Cloud UI features within the self-hosted Web UI. Set to `true` to enable, defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ncloudUi: false\n```\n\n----------------------------------------\n\nTITLE: Creating a Kubernetes Secret for Temporal API Key using Bash\nDESCRIPTION: This Bash command uses `kubectl create secret generic` to create a Kubernetes Secret named `temporal-secret`. It stores the Temporal API key securely, taking the value from the environment variable `$TEMPORAL_API_KEY` using `--from-literal`. The secret is created within the specified `your-namespace` namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nkubectl create secret generic temporal-secret \\\n    --from-literal=TEMPORAL_API_KEY=$TEMPORAL_API_KEY \\\n    --namespace your-namespace\n```\n```\n\n----------------------------------------\n\nTITLE: Generating an API Key with tcld CLI – Command\nDESCRIPTION: This code demonstrates the process for generating a user API key using the Temporal Cloud CLI tool `tcld`. Users must authenticate via `tcld login` first, then execute `tcld apikey create` with `--name`, `--description`, and `--duration` flags (where duration is e.g., '30d'). This command outputs the API key, which must be copied and saved immediately, as it will only be shown once. Dependencies: tcld CLI; the user must have an account and appropriate permissions. Inputs are the API key properties; output is the new API key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ntcld login\ntcld apikey create \\\n    --name <api-key-name> \\\n    --description \"<api-key-description>\" \\\n    --duration <api-key-duration>\n```\n\n----------------------------------------\n\nTITLE: Enabling Frontend HTTP API for Nexus in Static Config (YAML)\nDESCRIPTION: This YAML snippet shows the necessary static configuration adjustments within the Temporal server's configuration file to enable the HTTP API for the Frontend service. It requires setting the `httpPort` under `services.frontend.rpc` and the `httpAddress` under `clusterMetadata.clusterInformation.active`. This HTTP endpoint is essential for Nexus functionality. The `$PUBLIC_URL` placeholder needs to be replaced with a URL accessible to callers, potentially an internal load balancer address.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/temporal-nexus.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\nservices:\n  frontend:\n    rpc:\n      # NOTE: keep other fields as they were\n      httpPort: 7243\n\nclusterMetadata:\n  # NOTE: keep other fields as they were\n  clusterInformation:\n    active:\n      # NOTE: keep other fields as they were\n      httpAddress: $PUBLIC_URL:7243\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeouts in .NET\nDESCRIPTION: Demonstrates setting Activity timeouts using ActivityOptions when executing an Activity. Shows configuration of StartToCloseTimeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nreturn await Workflow.ExecuteActivityAsync(\n    (MyActivities a) => a.MyActivity(param),\n    new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Scrape Endpoint for Temporal SDK Metrics - YAML\nDESCRIPTION: This YAML code configures Prometheus to scrape SDK metrics from a Java service at localhost:8077. The configuration sets the global scrape interval to 10 seconds, defines a scrape job named 'temporalsdkmetrics', and targets the /metrics endpoint exposed by the Java application. There are no external code dependencies for the YAML file, but Prometheus must be installed and running. Key parameters include the job_name, metrics_path, and static_configs targets. The expected output is active metric data ingestion from the Java SDK endpoint for later visualization. Make sure the ports in the Java server and Prometheus config match; otherwise, Prometheus will not receive metrics.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/prometheus-grafana.mdx#2025-04-23_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nglobal:\n  scrape_interval: 10s # Set the scrape interval to every 10 seconds. Default is every 1 minute.\n#...\n\n# Set your scrape configuration targets to the ports exposed on your endpoints in the SDK.\nscrape_configs:\n  - job_name: 'temporalsdkmetrics'\n    metrics_path: /metrics\n    scheme: http\n    static_configs:\n      - targets:\n          # This is the scrape endpoint where Prometheus listens for SDK metrics.\n          - localhost:8077\n        # You can have multiple targets here, provided they are set up in your application code.\n```\n\n----------------------------------------\n\nTITLE: Querying Export Sink Status with TCLD CLI - Command\nDESCRIPTION: Use this CLI command to retrieve the status of an export sink in Temporal Cloud. The command requires the export Namespace and sink name as arguments, and returns details such as sink state and configuration in JSON format. The `tcld` CLI tool must be installed and configured to run this command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/aws-export-s3.mdx#2025-04-23_snippet_1\n\nLANGUAGE: command\nCODE:\n```\ntcld namespace export s3 get --namespace \"your-namespace.your-account\" --sink-name \"your-sink-name\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Workflow Execution Results in TypeScript\nDESCRIPTION: This code shows how to get the result of a Workflow Execution using a Workflow Handle. It demonstrates getting a handle using a workflow ID and awaiting the result.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst handle = client.getHandle(workflowId);\nconst result = await handle.result();\n```\n\n----------------------------------------\n\nTITLE: Getting Help with Temporal Server Configuration\nDESCRIPTION: Command to view the full list of available options when starting the Temporal Development Server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev --help\n```\n\n----------------------------------------\n\nTITLE: Setting Owner Email during Namespace Registration with tctl\nDESCRIPTION: Specifies the email address of the owner for the Namespace being registered using the `--owner_email <value>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --owner_email <value>\n```\n\n----------------------------------------\n\nTITLE: Adding Client CA Certificate using Encoded String\nDESCRIPTION: This command adds a client CA certificate using a base64-encoded string of a CA certificate PEM file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Initial State Before Data Conflict (T=0)\nDESCRIPTION: This table shows the initial state (T=0) of a Workflow Execution history in both Cluster B and Cluster C before any conflicting updates occur. It contains events from version 1 and version 2.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Querying Successful Poll Rate for Matching Service using PromQL\nDESCRIPTION: This Prometheus query calculates the total per-second average rate of successful task polls (`poll_success`) across the Matching Service over the last 5 minutes. This metric indicates the rate at which pollers are successfully matched with available tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_5\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(poll_success{}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Running Temporal Workflow using Python Script via Poetry (Bash)\nDESCRIPTION: Executes the `run_workflow.py` Python script using `poetry run`. This command typically initiates a new Workflow execution on the Temporal cluster. Requires a running Temporal Worker (started via `run_worker.py` or similar) to process the Workflow tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/replay_your_workflow/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python run_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Importing Certificate Filters with Request ID in Temporal Cloud CLI\nDESCRIPTION: Command to import certificate filters using a specific request identifier for tracking the asynchronous operation status.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters import \\\n    --request-id <request_id> \\\n    --certificate-filter-input <json>\n```\n\n----------------------------------------\n\nTITLE: Setting CA Certificate from File - tcld CLI - Bash\nDESCRIPTION: Sets the CA certificate(s) on the metrics endpoint by providing the path to a PEM file using --ca-certificate-file. If both certificate file and direct value are specified, the direct value takes precedence. Intended for situations where certificate content is managed on disk.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca set --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Initializing a Temporal Client and Starting a Workflow in Go\nDESCRIPTION: Example of initializing a Temporal Client in Go, establishing a connection to a Temporal Service, and starting a Workflow Execution. This demonstrates how to set up client-side interaction with Temporal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\n\t\"go.temporal.io/sdk/client\"\n)\n\nfunc main() {\n\t// Temporal Client setup code\n\tc, err := client.NewClient(client.Options{})\n\tif err != nil {\n\t\tlog.Fatalln(\"Unable to create client\", err)\n\t}\n\tdefer c.Close()\n\t// Prepare Workflow option and parameters\n\tworkflowOptions := client.StartWorkflowOptions{\n\t\tID:        \"loan-application-1\",\n\t\tTaskQueue: \"loan-application-task-queue\",\n\t}\n\tapplicantDetails := ApplicantDetails{\n\t\t// ...\n\t}\n\t// Start the Workflow\n\tworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, \"loan-application-workflow\", applicantDetails)\n\tif err != nil {\n\t\t// ...\n\t}\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Failing a tctl Activity using Activity ID (Bash)\nDESCRIPTION: This command illustrates failing a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Activity ID with the `--activity_id` modifier. Replace `<id>` with the actual Activity ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity fail --activity_id <id>\n```\n\n----------------------------------------\n\nTITLE: Applying Terraform Configuration Update\nDESCRIPTION: Runs the `terraform apply` command again after modifying the configuration file (e.g., changing the retention period). Terraform detects the change and applies the update to the corresponding Temporal Cloud resource after user confirmation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nterraform apply\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Filters with JSON Input in Temporal Cloud CLI\nDESCRIPTION: Command to add certificate filters to a namespace using inline JSON input. This allows specifying certificate filters directly in the command line.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters add \\\n    --certificate-filter-input <JSON>\n```\n\n----------------------------------------\n\nTITLE: Getting Command Reference for Temporal Development Server - Bash\nDESCRIPTION: Provides usage help for the 'temporal server start-dev' command, listing all possible options for customizing the Temporal development server startup. No prerequisites apart from having the CLI installed. Outputs command-line flags and configuration details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev --help\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Custom Claim Mapper in Go\nDESCRIPTION: Configures the Temporal Server with a custom claim mapper for authorization by passing a function to temporal.WithClaimMapper. This function builds an authorization.ClaimMapper using config and logging; typically required for advanced JWT claim mapping. All dependencies such as logger retrieval, claim mapper, and token key provider must be satisfied. Outputs a server with integrated role-based access control.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n  temporal.WithClaimMapper(func(cfg *config.Config) authorization.ClaimMapper {\n  \t\tlogger := getYourLogger() // Replace with how you retrieve or initialize your logger\n\t\treturn authorization.NewDefaultJWTClaimMapper(\n\t\t\tauthorization.NewDefaultTokenKeyProvider(cfg, logger),\n\t\t\tcfg\n\t\t)\n\t}),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Zsh Auto-completion\nDESCRIPTION: Commands to enable Temporal CLI auto-completion in Zsh shell\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\neval \"$(temporal completion zsh)\"\n```\n\n----------------------------------------\n\nTITLE: Listing Batch Jobs in Temporal CLI\nDESCRIPTION: This command lists all Batch jobs in a specific Namespace. It shows how to use the 'batch list' command to retrieve information about ongoing and completed Batch operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntemporal batch list --namespace=MyNamespace\n```\n\n----------------------------------------\n\nTITLE: Example JSON Output of Enabled Temporal Cloud Features\nDESCRIPTION: Provides an example JSON output returned by the `tcld feature get` command. The output is an array of objects, each containing the 'Name' of the feature and its boolean 'Value' indicating if it's enabled (true) or disabled (false).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/feature.mdx#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"Name\": \"enable-apikey\",\n    \"Value\": true\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate Specifying Key File using tcld\nDESCRIPTION: This command generates a Certificate Authority (CA) certificate using `tcld`, specifying the output path for the certificate's private key `.key` file using the `--ca-key-file` modifier. Replace `<path>` with the desired file path.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --ca-key-file <path>\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Temporal CLI in Shell\nDESCRIPTION: These commands set environment variables for a production environment named 'prod' using the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ntemporal env set prod.namespace production.f45a2\ntemporal env set prod.address production.f45a2.tmprl.cloud:7233\ntemporal env set prod.tls-cert-path /temporal/certs/prod.pem\ntemporal env set prod.tls-key-path /temporal/certs/prod.key\n```\n\n----------------------------------------\n\nTITLE: Concatenating CA Certificates for Rotation (File Format)\nDESCRIPTION: Shows the required format for a file containing both old and new CA certificate PEM blocks concatenated together. This format is used during the certificate rollover process with `tcld` to ensure zero downtime by allowing the Namespace to accept connections validated by either certificate.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n----BEGIN CERTIFICATE-----\n... old CA cert ...\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\n... new CA cert ...\n-----END CERTIFICATE-----\n```\n\n----------------------------------------\n\nTITLE: Sending an Asynchronous Update to a Workflow in C#\nDESCRIPTION: This snippet demonstrates how to send an asynchronous Update using StartUpdateAsync, which returns an UpdateHandle. The UpdateHandle can be used later to fetch the results of the Update.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// Wait until the update is accepted\nvar updateHandle = await workflowHandle.StartUpdateAsync(\n    wf => wf.SetGreetingAsync(new HelloWorldInput(\"World\")),\n    new(waitForStage: WorkflowUpdateStage.Accepted));\n// Wait until the update is completed\nvar updateResult = await updateHandle.GetResultAsync();\n```\n\n----------------------------------------\n\nTITLE: Setting up Temporal with Docker Compose for Development\nDESCRIPTION: A Docker Compose configuration for setting up a local Temporal development environment with the required services including the Temporal server, PostgreSQL database, Elasticsearch, and the Temporal Web UI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/Google/vocab.txt#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3.5'\n\nservices:\n  postgresql:\n    image: postgres:13\n    environment:\n      - POSTGRES_USER=temporal\n      - POSTGRES_PASSWORD=temporal\n    ports:\n      - 5432:5432\n  temporal:\n    image: temporalio/auto-setup:${TEMPORAL_VERSION}\n    environment:\n      - DB=postgresql\n      - DB_PORT=5432\n      - POSTGRES_USER=temporal\n      - POSTGRES_PWD=temporal\n      - POSTGRES_SEEDS=postgresql\n      - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development-sql.yaml\n    ports:\n      - 7233:7233\n    depends_on:\n      - postgresql\n  temporal-admin-tools:\n    image: temporalio/admin-tools:${TEMPORAL_VERSION}\n    environment:\n      - TEMPORAL_CLI_ADDRESS=temporal:7233\n    depends_on:\n      - temporal\n  temporal-ui:\n    image: temporalio/ui:${TEMPORAL_UI_VERSION}\n    environment:\n      - TEMPORAL_ADDRESS=temporal:7233\n      - TEMPORAL_CORS_ORIGINS=http://localhost:3000\n    ports:\n      - 8080:8080\n    depends_on:\n      - temporal\n```\n\n----------------------------------------\n\nTITLE: Querying Client Error Rate between Frontend and History using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of client errors (`client_errors`) specifically originating from the Frontend Service (`service_name=\"frontend\"`) when communicating with the History Service (`service_role=\"history\"`) over the last 5 minutes. This indicates potential connection or communication issues between these two services.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_4\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(client_errors{service_name=\"frontend\",service_role=\"history\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Enabling an API Key - tcld CLI - Bash\nDESCRIPTION: This snippet enables a previously disabled API Key, re-activating it for use by referencing its --id. Use is restricted to users with appropriate privileges via the tcld CLI. The command expects a valid API Key ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey enable --id <apikey_id>\n```\n\n----------------------------------------\n\nTITLE: Setting Namespace Retention Period with Temporal Cloud CLI\nDESCRIPTION: This command sets the retention period (in days) for closed Workflows in a specified Namespace. Requires both the namespace identifier and the number of retention days to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_60\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace retention set \\\n    --namespace <namespace_id> \\\n    --retention-days <retention_days>\n```\n\n----------------------------------------\n\nTITLE: Triggering Manual Failover with tcld CLI in Bash\nDESCRIPTION: This command uses the tcld CLI to initiate a manual failover for a specified Temporal Cloud Namespace to a target region. It requires the `namespace_id`, `account_id`, and the desired `target_region` as parameters. If using API key authentication, the `--api-key` flag must be placed immediately after `tcld` and before the `namespace failover` subcommand.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/how-to/failovers.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace failover \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <target_region>\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Cloud Service Account using tcld (bash)\nDESCRIPTION: Provides an example of deleting a specific Service Account using the `tcld service-account delete` command. It requires the `--service-account-id` flag followed by the unique ID of the Service Account to be deleted (e.g., `\"e9d87418221548\"`). Confirmation of deletion can be done by re-listing the service accounts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/service-accounts.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld service-account delete --service-account-id \"e9d87418221548\"\n```\n\n----------------------------------------\n\nTITLE: Sample Workflow Output Log - Shell\nDESCRIPTION: Shows the expected output when running a workflow using the API key approach, echoing both English and Spanish messages. This output validates the successful completion of the workflow and communication flow between the caller and handler workers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n2024/10/04 19:57:40 Workflow result: Nexus Echo 👋\n2024/10/04 19:57:40 Workflow result: ¡Hola! Nexus 👋\n```\n\n----------------------------------------\n\nTITLE: Creating a GCS Export Sink using tcld in Bash\nDESCRIPTION: Demonstrates how to create a GCS export sink using the `tcld namespace export gcs create` command. It specifies the target namespace (`-n`), a name for the sink (`--sink-name`), the GCP service account email (`--service-account-email`), and the destination GCS bucket (`--gcs-bucket`). Requires `tcld` and necessary GCP permissions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/gcp-export-gcs.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld n export gcs create -n test.ns --sink-name test-sink --service-account-email test-sink@test-export-sink.iam.gserviceaccount.com --gcs-bucket test-export-validation`\n```\n\n----------------------------------------\n\nTITLE: Retrieving Archived Workflow Events - Bash\nDESCRIPTION: Fetches archived Event Histories for a completed Workflow by using workflow and run IDs with the CLI. Depends on the Temporal CLI client and access to the correct Namespace. Parameters include workflow-id, run-id, and namespace. Returns the event history for the requested workflow. Limitation: Correct IDs must be specified; error returned if not found.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./temporal workflow show --workflow-id=\\\"my-workflow-id\\\" --run-id=\\\"my-run-id\\\" --namespace=\\\"my-namespace\\\"\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up OpenTelemetry Global Propagators with Jaeger (JavaScript)\nDESCRIPTION: This JavaScript code shows how to configure the global OpenTelemetry propagator to include the Jaeger propagator alongside the default W3C Trace Context and Baggage propagators. This is typically done at the top level of Workflow code to ensure consistent trace context propagation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { propagation } from '@opentelemetry/api';\nimport {\n  CompositePropagator,\n  W3CBaggagePropagator,\n  W3CTraceContextPropagator,\n} from '@opentelemetry/core';\nimport { JaegerPropagator } from '@opentelemetry/propagator-jaeger';\n\npropagation.setGlobalPropagator(\n  new CompositePropagator({\n    propagators: [\n      new W3CTraceContextPropagator(),\n      new W3CBaggagePropagator(),\n      new JaegerPropagator(),\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Worker (Go/Bash)\nDESCRIPTION: This command compiles and runs the Go program located at `worker/main.go` to start a Temporal Worker process. It requires Go to be installed and a local Temporal development cluster to be running. The worker listens for tasks from the Temporal Cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/cancellation/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run worker/main.go\n```\n\n----------------------------------------\n\nTITLE: Example Output after Toggling a Temporal Cloud Feature\nDESCRIPTION: Shows the confirmation message output displayed in the console after successfully executing the `tcld feature toggle-apikey` command. The output indicates the feature flag's name ('enable-apikey') and its new state (true, meaning enabled).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/feature.mdx#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n```\nFeature flag enable-apikey is now true\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Replica Region to an Existing Namespace using the tcld CLI - Bash\nDESCRIPTION: This snippet is for upgrading an existing Temporal Cloud Namespace to enable High Availability by adding a replica region via the tcld CLI. Requires tcld installed and authentication. The --namespace flag specifies the full namespace name, and --region sets the new replica's region code. Using the current region replicates within an isolation domain; using a different region creates Multi-region Replication. The --api-key flag, if used, must directly follow 'tcld' and precede 'namespace add-region'. Output is a Namespace with replication enabled, prepared for failover and improved disaster tolerance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/enable.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace add-region \\\n   --namespace <namespace_id>.<account_id> \\\n   --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Querying Frontend Service Request Rate by Operation using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of service requests (`service_requests`) received by the Temporal Frontend Service (`service_name=\"frontend\"`) over the last 2 minutes. The results are aggregated and shown per operation type (`operation` tag), providing insight into the load distribution across different frontend actions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PromQL\nCODE:\n```\nsum by (operation) (rate(service_requests{service_name=\"frontend\"}[2m]))\n```\n\n----------------------------------------\n\nTITLE: Cloning the Temporal Cloud API Repository using Command Line\nDESCRIPTION: This command clones the `api-cloud` repository from GitHub, which contains the gRPC protobuf definitions for the Temporal Cloud Operations API. It then changes the current directory into the cloned repository.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/operation-api.mdx#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ngit clone https://github.com/temporalio/api-cloud.git\ncd api-cloud\n```\n\n----------------------------------------\n\nTITLE: Enabling an API Key with Request ID - tcld CLI - Bash\nDESCRIPTION: This command provides a --request-id to the enable API Key operation with tcld. Use this flag to enforce operation idempotency and traceability, supporting robust automation and tracking flows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey enable --id <apikey_id> --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Creating an API Key with Request ID - tcld CLI - Bash\nDESCRIPTION: This snippet demonstrates specifying a request-id using the --request-id flag to uniquely identify the asynchronous API Key creation operation, helpful for auditing or idempotency. The server will generate a request ID if not provided. Requires tcld CLI and appropriate Temporal Cloud permissions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey create --name <name> --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Verifying TLS Certificate Using OpenSSL - Command\nDESCRIPTION: This snippet demonstrates checking a server's TLS certificate using OpenSSL's s_client, displaying all certificates in the chain. It requires OpenSSL installed locally and valid paths to the certificate and key. Replace <namespace_grpc_endpoint>, ~/certs/path.pem, and ~/certs/path.key with your endpoint and file paths; this command outputs certificate details for verification, supporting troubleshooting for secure connections.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/last-connection-error.mdx#2025-04-23_snippet_1\n\nLANGUAGE: command\nCODE:\n```\nopenssl s_client -connect <namespace_grpc_endpoint> -showcerts -cert ~/certs/path.pem -key .~/certs/path.key -tls1_2\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Temporal Cloud User with Terraform\nDESCRIPTION: Bash command to import an existing Temporal Cloud User into Terraform state using the user ID. This allows managing existing users through Terraform infrastructure as code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nterraform import temporalcloud_user.user 72360058153949edb2f1d47019c1e85f\n```\n\n----------------------------------------\n\nTITLE: Converting Private Key to PKCS8 for Java SDK (Command Line)\nDESCRIPTION: Uses the `openssl pkcs8` command to convert the private key (`.key`) generated by `certstrap` for the end-entity certificate from the default PKCS1 format to the PKCS8 format. The input key is specified using the `NAMESPACE_NAME` variable, and the output PKCS8 key is saved to `out/${NAMESPACE_NAME}.pkcs8.key`. This conversion is necessary when using the generated certificate with the Temporal Java SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_7\n\nLANGUAGE: command\nCODE:\n```\nopenssl pkcs8 -topk8 -inform PEM -outform PEM -in out/${NAMESPACE_NAME}.key -out out/${NAMESPACE_NAME}.pkcs8.key -nocrypt\n```\n\n----------------------------------------\n\nTITLE: Temporal Cron Schedule Format Example - Temporal Configuration Format\nDESCRIPTION: Provides a reference for the cron schedule string format used by Temporal when configuring Workflow schedule patterns. Each line specifies a time field (minute, hour, day of month, month, day of week) and the valid ranges, serving as a guide for developers constructing valid cronSchedule values. No execution of code—serves as a documentation snippet for correct schedule syntax, with '*' denoting wildcards.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/schedules.mdx#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n└────────── minute (0 - 59)\n│ └───────── hour (0 - 23)\n│ │ └────── day of the month (1 - 31)\n│ │ │ └───── month (1 - 12)\n│ │ │ │ └───── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Querying Schedule Buffer Overrun Rate by Namespace using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of schedule buffer overruns (`schedule_buffer_overruns`) over the last 5 minutes, aggregated by namespace (`$namespace`). Buffer overruns indicate that the buffer for holding scheduled workflows is exceeding capacity, often due to schedules with 'buffer_all' overlap policy having run lengths exceeding their interval.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_17\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(schedule_buffer_overruns{namespace=\"$namespace\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Disabling Workflow Termination (workflowTerminateDisabled) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to specifically disable the ability for users to terminate Workflow Executions from the Temporal Web UI. Set to `true` to disable. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\nworkflowTerminateDisabled: false\n```\n\n----------------------------------------\n\nTITLE: Updating a Nexus Endpoint using Temporal CLI\nDESCRIPTION: This command updates an existing Nexus Endpoint on the Server. It allows updating specific fields while leaving others unchanged. The examples show updating the target task queue and the description.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint update \\\n  --name your-endpoint \\\n  --target-task-queue your-other-queue\n```\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint update \\\n  --name your-endpoint \\\n  --description-file DESCRIPTION.md\n```\n\n----------------------------------------\n\nTITLE: Executing tcld version Command in Shell\nDESCRIPTION: This command executes `tcld version` in a shell environment to display the installed version of the Temporal Cloud CLI tool (`tcld`). It has an alias `v` and accepts no additional modifiers or arguments. Requires `tcld` to be installed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/version.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n`tcld version`\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate Specifying CA Key File using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the path to the signing Certificate Authority's private key `.key` file using the `--ca-key-file` modifier. Replace `<path>` with the path to the CA private key file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --ca-key-file <path>\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenTracing Worker Interceptor for Temporal Worker in Java\nDESCRIPTION: This snippet illustrates how to set up tracing by registering the OpenTracingWorkerInterceptor on the Worker side. It shows two approaches to add the interceptor to WorkerFactoryOptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nWorkerFactoryOptions.newBuilder()\n   //...\n   .setWorkerInterceptors(new OpenTracingWorkerInterceptor())\n   .build();\n```\n\nLANGUAGE: java\nCODE:\n```\nWorkerFactoryOptions factoryOptions =\n    WorkerFactoryOptions.newBuilder()\n        .setWorkerInterceptors(\n            new OpenTracingWorkerInterceptor(JaegerUtils.getJaegerOptions(type)))\n        .build();\nWorkerFactory factory = WorkerFactory.newInstance(client, factoryOptions);\n```\n\n----------------------------------------\n\nTITLE: Running tctl via Docker Image (Linux)\nDESCRIPTION: This command runs the tctl tool using the 'temporalio/admin-tools:1.14.0' Docker image on a Linux host. It uses host networking and sets the Temporal cluster address via an environment variable. The container is removed automatically after execution (--rm), and it runs interactively (-it).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndocker run --rm -it --entrypoint tctl --network host --env TEMPORAL_CLI_ADDRESS=localhost:7233 temporalio/admin-tools:1.14.0\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Visibility Store in Temporal YAML\nDESCRIPTION: This YAML snippet demonstrates how to configure PostgreSQL as the Visibility store within the Temporal Service configuration file. It sets 'postgres-visibility' as the `visibilityStore` and defines its connection parameters under `datastores`, including the plugin name ('postgres12' for v12+), database name, connection address, credentials, and connection pool settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n#...\npersistence:\n  #...\n  visibilityStore: postgres-visibility\n  #...\n  datastores:\n    default:\n    #...\n    postgres-visibility:\n      sql:\n        pluginName: 'postgres12' # For PostgreSQL v12 and later. For earlier versions, use \"postgres\" plugin.\n        databaseName: 'temporal_visibility'\n        connectAddr: ' ' # remote address of this database; for example, 127.0.0.0:5432\n        connectProtocol: ' ' # protocol example: tcp\n        user: 'username_for_auth'\n        password: 'password_for_auth'\n        maxConns: 2\n        maxIdleConns: 2\n        maxConnLifetime: '1h'\n#...\n```\n\n----------------------------------------\n\nTITLE: Configuring MaxConcurrentSessionExecutionSize for Temporal Worker in Go\nDESCRIPTION: Sets the maximum number of concurrent Sessions the Worker can handle when `EnableSessionWorker` is true. The type is `int`, and the default value is `1000`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_43\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    MaxConcurrentSessionExecutionSize: 1000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow by Workflow ID in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the workflow_id modifier. This allows resetting a Workflow Execution by specifying its Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --workflow_id <id>\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions by ID, Type, or Status using tctl (Bash)\nDESCRIPTION: Filters the list of Workflow Executions using basic criteria with `tctl workflow list`. Use `--workflow_id` to filter by a specific Workflow ID, `--workflow_type` to filter by Workflow Type name, and `--status` to filter by execution status (e.g., 'completed', 'failed'). These filters are ignored if the `--query` option is used.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --workflow_id <id>\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --workflow_type <name>\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --status <value>\n```\n\n----------------------------------------\n\nTITLE: Listing All API Keys - tcld CLI - Bash\nDESCRIPTION: This snippet lists all API Keys associated with your Temporal Cloud account using tcld apikey list. No parameters are needed. The command requires the tcld CLI and appropriate permissions, returning a list of key summary information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey list\n```\n\n----------------------------------------\n\nTITLE: Renaming Search Attributes in Temporal Cloud CLI\nDESCRIPTION: Command to rename a search attribute by specifying its existing name and the new name. This preserves all indexed data while changing only the attribute's name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_58\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes rename \\\n    --existing-name <value> \\\n    --new-name <value>\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in Go SDK (v1.26.0+)\nDESCRIPTION: Example of updating an API key for an existing Temporal client connection in Go SDK version 1.26.0 or higher.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Assuming client Credentials created with\nvar myKey string\ncreds := client.NewAPIKeyDynamicCredentials(\n    func(context.Context) (string, error) { return myKey, nil })\n// Just update by replacing\nmyKey = myKeyUpdated\n```\n\n----------------------------------------\n\nTITLE: Setting Temporal API Key Environment Variable on macOS\nDESCRIPTION: Sets the TEMPORAL_API_KEY environment variable on macOS or Linux systems. This variable is used by the Terraform Temporal Cloud provider for authentication. Replace `<your-secret-key>` with the actual secret key obtained from `tcld apikey create`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# replace <your-secret-key> with the \"secretKey\": output from tcld apikey create command\nexport TEMPORAL_API_KEY=<your-secret-key>\n```\n\n----------------------------------------\n\nTITLE: Canceling Workflows using Temporal CLI\nDESCRIPTION: This command cancels running workflows of a specific type using a query filter. It demonstrates how to use the 'workflow cancel' command with a List Filter to target specific Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow cancel \\\n  --query 'ExecutionStatus = \"Running\" AND WorkflowType=\"YourWorkflow\"' \\\n  --reason \"Testing\"\n```\n\n----------------------------------------\n\nTITLE: Setting WorkflowExecutionErrorWhenAlreadyStarted in Go\nDESCRIPTION: This snippet shows how to control error handling when attempting to start a Workflow Execution with an ID that is already running. By setting the `WorkflowExecutionErrorWhenAlreadyStarted` boolean field in `client.StartWorkflowOptions` to `true`, the `ExecuteWorkflow` call will return an error if a Workflow with the same ID is already open. The default is `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-client.mdx#2025-04-23_snippet_11\n\nLANGUAGE: go\nCODE:\n```\n```go\nworkflowOptions := client.StartWorkflowOptions{\n  WorkflowExecutionErrorWhenAlreadyStarted: false,\n  // ...\n}\nworkflowRun, err := c.ExecuteWorkflow(context.Background(), workflowOptions, YourWorkflowDefinition)\nif err != nil {\n  // ...\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving GCS Export Sink Status with tcld in Bash/JSON\nDESCRIPTION: Shows the command `tcld n export gcs g` used to retrieve the details of a GCS export sink and an example JSON output. The output includes the sink's configuration (name, destination type, GCS details), current state ('Active'), health status ('Ok'), and relevant timestamps. This command is used to verify the status after creation or for general inspection.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/gcp-export-gcs.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld n export gcs g -n test.ns --sink-name test-sink\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"name\": \"test.ns\",\n\t\"resourceVersion\": \"b954de0c-c6ae-4dcc-90bd-3918b52c3f28\",\n\t\"state\": \"Active\",\n\t\"spec\": {\n\t\t\"name\": \"test-sink\",\n\t\t\"enabled\": true,\n\t\t\"destinationType\": \"Gcs\",\n\t\t\"s3Sink\": null,\n\t\t\"gcsSink\": {\n\t\t\t\"saId\": \"test-sink\",\n\t\t\t\"bucketName\": \"test-export-validationn\",\n\t\t\t\"gcpProjectId\": \"test-export-sink\"\n\t\t}\n\t},\n\t\"health\": \"Ok\",\n\t\"errorMessage\": \"\",\n\t\"latestDataExportTime\": \"0001-01-01T00:00:00Z\",\n\t\"lastHealthCheckTime\": \"2024-01-23T06:40:02Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking History Event Count Against Error Limit (Go)\nDESCRIPTION: Go code snippet from the Temporal history service (`workflowExecutionContext.go`) showing the condition check for the number of events in a Workflow Execution history against the configured error limit (default 51,200 events). An error occurs, potentially terminating the Workflow, if the count exceeds this limit.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nif mutableState.GetHistorySize() > h.config.HistorySizeLimitError() || mutableState.GetExecutionInfo().ExecutionStats.HistorySize > h.config.HistorySizeLimitError() || int64(mutableState.GetNextEventID()-1) > h.config.HistoryCountLimitError() {\n```\n\n----------------------------------------\n\nTITLE: Handler Completion Handling in Workflow\nDESCRIPTION: Example demonstrating how to ensure all handlers complete before workflow completion using workflow.wait_condition and all_handlers_finished.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@workflow.defn\nclass MyWorkflow:\n    @workflow.run\n    async def run(self) -> str:\n        ...\n        await workflow.wait_condition(workflow.all_handlers_finished)\n        return \"workflow-result\"\n```\n\n----------------------------------------\n\nTITLE: Signaling Temporal Workflows via Command-Line - command\nDESCRIPTION: This snippet illustrates the command-line steps required to signal a Temporal workflow in Python. It assumes the presence of 'your_worker.py' acting as the workflow host and 'signal_dacx.py' as the signaling client. Users should run the worker in one terminal and the signal sender in a separate terminal. Poetry is required for dependency management, and Temporal's Python SDK dependencies should be installed. Input files are Python scripts; execution is via terminal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/signal_your_workflow/README.md#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\n# terminal one\\npoetry run python your_worker.py\\n# terminal two\\npoetry run python signal_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Adding New Build ID as New Default Set via Task Queue Update (Legacy)\nDESCRIPTION: This snippet uses the deprecated `client.taskQueue.updateBuildIdCompatibility` method in the Temporal TypeScript SDK to register a new `buildId` ('deadbeef') with a specific Task Queue. The operation `addNewIdInNewDefaultSet` creates a new version set containing only this Build ID and makes this new set the default for the Task Queue. New Workflows started on this queue will target Workers with this Build ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nawait client.taskQueue.updateBuildIdCompatibility('your_task_queue_name', {\n  operation: 'addNewIdInNewDefaultSet',\n  buildId: 'deadbeef',\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version for tcld Build (bash)\nDESCRIPTION: This command checks the installed version of the Go programming language. It is a prerequisite step for building tcld from source, which requires Go version 1.18 or later. The command outputs the installed Go version string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/index.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo version\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Filters with Certificate Filter File in Temporal Cloud CLI\nDESCRIPTION: Command to add certificate filters to a namespace using a JSON file. The file defines which certificate properties are allowed to connect to the namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters add \\\n    --certificate-filter-file <file>\n```\n\n----------------------------------------\n\nTITLE: Hiding Workflow Query Errors (hideWorkflowQueryErrors) in Temporal Web UI (YAML)\nDESCRIPTION: Configuration setting to control the visibility of errors resulting from queries made to Workflows via the Temporal Web UI. Set to `true` to hide these errors from the user, defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nhideWorkflowQueryErrors: false\n```\n\n----------------------------------------\n\nTITLE: Exporting Certificate Filters for Specific Namespace in Temporal Cloud CLI\nDESCRIPTION: Command to export certificate filters for a specific namespace, using the namespace ID parameter instead of the environment variable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters import \\\n    --namespace <namespace_id> \\\n    --certificate-filter-input <json>\n```\n\n----------------------------------------\n\nTITLE: Listing Temporal Cloud Service Accounts using tcld (bash)\nDESCRIPTION: Shows how to list all Service Accounts within the associated Temporal Cloud account using the `tcld service-account list` command. This command requires no additional arguments and outputs a list of existing Service Accounts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/service-accounts.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld service-account list\n```\n\n----------------------------------------\n\nTITLE: Deleting an API Key with Request ID - tcld CLI - Bash\nDESCRIPTION: This command includes the --request-id flag along with deletion to trace or guarantee uniqueness for the operation. The server assigns one if omitted. Requires tcld CLI and the relevant privileges.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey delete --id <apikey_id> --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Customizing Workflow Type in C#\nDESCRIPTION: Demonstrates how to set a custom name for a Workflow Type using the [Workflow] attribute. The example shows a Workflow that executes an Activity with custom parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/core-application.mdx#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Temporalio.Workflows;\n\n[Workflow(\"MyDifferentWorkflowName\")]\npublic class MyWorkflow\n{\n    public async Task<string> RunAsync(string name)\n    {\n        var param = MyActivityParams(\"Hello\", name);\n        return await Workflow.ExecuteActivityAsync(\n            (MyActivities a) => a.MyActivity(param),\n            new() { StartToCloseTimeout = TimeSpan.FromMinutes(5) });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding New Build ID to Task Queue in Java (Deprecated)\nDESCRIPTION: This deprecated snippet demonstrates how to add a new Build ID to a Task Queue as the sole version in a new default set. It uses the WorkflowClient to update the Worker Build ID compatibility.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.newIdInNewDefaultSet(\"deadbeef\"));\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Codec Server via Temporal CLI\nDESCRIPTION: Shows how to provide authentication details when using a Codec Server endpoint with the Temporal CLI. The `temporal workflow show` command uses both `--codec-endpoint` to specify the server address (including a namespace placeholder) and `--codec-auth` to pass the required authorization header value ('auth-header') to the Codec Server for authentication. Requires the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow show \\\n   --workflow-id converters_workflowID \\\n   --codec-endpoint 'http://localhost:8081/{namespace}' \\\n   --codec-auth 'auth-header'\n```\n\n----------------------------------------\n\nTITLE: Setting up Cassandra Visibility Schema using Bash Script\nDESCRIPTION: This Bash script snippet, part of an auto-setup script, demonstrates setting up the Cassandra keyspace and schema for Temporal Visibility. It defines environment variables for keyspace names, connection details (seeds, port, credentials, TLS), and replication factor. It then uses 'temporal-cassandra-tool' to create the visibility keyspace (if needed) and apply the schema definitions from 'VISIBILITY_SCHEMA_DIR'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# set your Cassandra environment variables\n: \"${KEYSPACE:=temporal}\"\n: \"${VISIBILITY_KEYSPACE:=temporal_visibility}\"\n\n: \"${CASSANDRA_SEEDS:=}\"\n: \"${CASSANDRA_PORT:=9042}\"\n: \"${CASSANDRA_USER:=}\"\n: \"${CASSANDRA_PASSWORD:=}\"\n: \"${CASSANDRA_TLS_ENABLED:=}\"\n: \"${CASSANDRA_CERT:=}\"\n: \"${CASSANDRA_CERT_KEY:=}\"\n: \"${CASSANDRA_CA:=}\"\n: \"${CASSANDRA_REPLICATION_FACTOR:=1}\"\n#...\n# set connection details\n#...\n# set up Cassandra schema\nsetup_cassandra_schema() {\n  #...\n  # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/cassandra/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" create -k \"${VISIBILITY_KEYSPACE}\" --rf \"${CASSANDRA_REPLICATION_FACTOR}\"\n    fi\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" setup-schema -v 0.0\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Connection with .NET SDK pre-v1.1.0 using API Key\nDESCRIPTION: Establishes a connection to Temporal Cloud using .NET SDK versions prior to 1.1.0. Uses RpcMetadata dictionary with Authorization header for API key authentication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nvar myClient = TemporalClient.ConnectAsync(new(<endpoint>)\n{\n    Namespace = <namespace_id>.<account_id>,\n    RpcMetadata = new Dictionary<string, string>()\n    {\n        [\"Authorization\"] = $\"Bearer {<APIKey>}\",\n        [\"temporal-namespace\"] = \"${<namespace_id>.<account_id>}\",\n    },\n    Tls = new(),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Search Attributes\nDESCRIPTION: Command to configure dynamic search attributes in Temporal server\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev --dynamic-config-value system.forceSearchAttributesCacheRefreshOnRead=false\n```\n\n----------------------------------------\n\nTITLE: Setting Public Path (publicPath) for Temporal Web UI (YAML)\nDESCRIPTION: Defines the base path for all assets and API endpoints served by the Temporal Web UI server. Useful when deploying the UI behind a reverse proxy under a specific subpath. Defaults to an empty string (`''`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\npublicPath: ''\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Server with Custom Namespaces\nDESCRIPTION: Command to start Temporal development server with specified custom namespaces\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntemporal server start-dev --namespace foo --namespace bar\n```\n\n----------------------------------------\n\nTITLE: Illustrating Version History State at T=0 (No Conflict)\nDESCRIPTION: This table represents the initial state (T=0) of a Workflow Execution's event history and version history in both Cluster A and Cluster B, before any failover. It shows the first event (ID 1) having version 1.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 1               | 1       |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Syntax for Toggling Temporal Cloud Features with tcld (Bash)\nDESCRIPTION: Displays the general syntax for the `tcld feature toggle-*` command (alias `tak`), used to enable or disable a specific feature in Temporal Cloud. The asterisk `*` must be replaced with the actual name of the feature to be toggled. The command has no modifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/feature.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld feature toggle-*\n```\n\n----------------------------------------\n\nTITLE: Running tctl via Docker Image (macOS/Windows)\nDESCRIPTION: This command runs the tctl tool using the 'temporalio/admin-tools:1.14.0' Docker image on macOS or Windows. It sets the Temporal cluster address to 'host.docker.internal:7233' to connect to a server running on the host machine from within the container. The container is removed automatically (--rm) and runs interactively (-it).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndocker run --rm -it --entrypoint tctl --env TEMPORAL_CLI_ADDRESS=host.docker.internal:7233 temporalio/admin-tools:1.14.0\n```\n\n----------------------------------------\n\nTITLE: Setting Default Namespace (defaultNamespace) in Temporal Web UI (YAML)\nDESCRIPTION: Specifies the default Namespace the Temporal Web UI should display upon loading. If not set, it defaults to the 'default' Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ndefaultNamespace: default\n```\n\n----------------------------------------\n\nTITLE: Toggling Temporal Schedule State\nDESCRIPTION: Commands to pause and unpause a Temporal Schedule. Requires schedule ID and reason for the state change.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/schedule.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal schedule toggle --schedule-id 'your-schedule-id' --pause --reason \"paused because the database is down\"\ntemporal schedule toggle --schedule-id 'your-schedule-id' --unpause --reason \"the database is back up\"\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies using Poetry (Bash)\nDESCRIPTION: This command utilizes Poetry, a Python dependency management tool, to read the `pyproject.toml` file in the project's root directory and install all the required project dependencies into a virtual environment. This is the first step in setting up the project environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/schedule_your_workflow/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions with Temporal CLI\nDESCRIPTION: The 'temporal workflow list' command lists Workflow Executions based on specified criteria. It can return closed or archived workflows and supports various options for customizing the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --query=MyListFilter\n```\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --archived=true\n```\n\n----------------------------------------\n\nTITLE: Setting CA Certificate with Request ID - tcld CLI - Bash\nDESCRIPTION: This command sets (replaces) the configured CA certificates for the metrics endpoint, specifying a new set via the --ca-certificate parameter and tagging the request with --request-id for tracking. Use when replacing or bulk updating certificates. Dependencies: tcld CLI and encoded certificate string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca set --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate with Request ID\nDESCRIPTION: This command removes a client CA certificate with a specified request identifier for tracking the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --request-id <request_id> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Disabling an API Key with Request ID - tcld CLI - Bash\nDESCRIPTION: This command disables an API Key while supplying a --request-id, enabling idempotent or auditable operation submissions. The CLI communicates this ID to the server for tracking. Requires authenticated CLI setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey disable --id <apikey_id> --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Enabling/Disabling API Keys with tcld CLI\nDESCRIPTION: Commands to enable or disable an API key using the tcld CLI. Requires logging in first and specifying the API key ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld login\ntcld apikey disable --id <api-key-id>\ntcld apikey enable --id <api-key-id>\n```\n\n----------------------------------------\n\nTITLE: Getting a Nexus Endpoint using Temporal CLI\nDESCRIPTION: This command retrieves a Nexus Endpoint by name from the Server. It requires specifying the name of the endpoint to be retrieved.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint get --name your-endpoint\n```\n\n----------------------------------------\n\nTITLE: Setting up Elasticsearch Index for Temporal Visibility Store in Bash\nDESCRIPTION: A shell function that configures Elasticsearch for use as a Temporal visibility store. It creates necessary cluster settings, index templates, and indexes for both primary and optional secondary visibility stores using environment variables for configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsetup_es_index() {\n    ES_SERVER=\"${ES_SCHEME}://${ES_SEEDS%%,*}:${ES_PORT}\"\n    # ES_SERVER is the URL of Elasticsearch server i.e. \"http://localhost:9200\".\n    SETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\n    SETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\n    TEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\n    SCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\n    INDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\n    curl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\n    curl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\n    curl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n\n    # Checks for and sets up Elasticsearch as a secondary Visibility store\n    if [[ ! -z \"${ES_SEC_VIS_INDEX}\" ]]; then\n      SEC_INDEX_URL=\"${ES_SERVER}/${ES_SEC_VIS_INDEX}\"\n      curl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SEC_INDEX_URL}\" --write-out \"\\n\"\n    fi\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Temporal Cluster Health after mTLS Configuration\nDESCRIPTION: Uses the Temporal CLI command `temporal operator cluster health` specifically in the context of troubleshooting after enabling mTLS. The `--address` flag requires the actual server address (represented by the placeholder `[SERVER_ADDRESS]`) to be specified. This command verifies that the Temporal cluster remains healthy and reachable after mTLS configuration changes, which often involve updating server names and certificates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/deadline-exceeded-error.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntemporal operator cluster health --address [SERVER_ADDRESS]\n```\n\n----------------------------------------\n\nTITLE: Querying Current Available Workflow Worker Task Slots with Prometheus\nDESCRIPTION: A PromQL query that fetches the current value of the `temporal_worker_task_slots_available` SDK metric for a specific `$task_queue_name` within the specified `$namespace` (here shown as 'default') and for `WorkflowWorker` type. This provides an immediate snapshot of worker slot availability, helping to diagnose task processing bottlenecks related to worker capacity configuration (`maxConcurrentWorkflowTaskExecutionSize`). Requires `$namespace` and `$task_queue_name` variables.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_9\n\nLANGUAGE: promql\nCODE:\n```\ntemporal_worker_task_slots_available{namespace=\"default\", worker_type=\"WorkflowWorker\", task_queue=\"$task_queue_name\"}\n```\n\n----------------------------------------\n\nTITLE: Running Workflow with Input in Bash\nDESCRIPTION: Example of using the tctl workflow run command with the input modifier. This allows passing input for the Workflow in JSON format.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --input <json>\n```\n\n----------------------------------------\n\nTITLE: Querying Metric Rate with Prometheus (PromQL)\nDESCRIPTION: This PromQL example demonstrates how to compute the per-second rate over an interval for a specific Temporal Cloud metric (`temporal_cloud_v0_frontend_service_request_count`). It uses the `rate()` function with a variable interval (e.g., $__rate_interval), which should be defined by the dashboard or alerting environment. The result is a time series representing the request rate, useful for dashboards and alerting. Dependency: Requires a Prometheus data source with Temporal Cloud metrics scraped.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/reference.mdx#2025-04-23_snippet_0\n\nLANGUAGE: PromQL\nCODE:\n```\nrate(temporal_cloud_v0_frontend_service_request_count[$__rate_interval])\n```\n\n----------------------------------------\n\nTITLE: Adding Client CA Certificate using Certificate File\nDESCRIPTION: This command adds a client CA certificate by specifying the path to a CA certificate PEM file instead of using an encoded string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add \\\n    --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: STARTS_WITH for WorkflowType Prefix\nDESCRIPTION: List Filter that matches Workflows whose WorkflowType begins with a specific prefix.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowType STARTS_WITH '<workflow-type-prefix>'\n```\n\n----------------------------------------\n\nTITLE: Retrieving Request Status using tcld request get in Bash\nDESCRIPTION: This command uses the `tcld` CLI to fetch the status of an asynchronous Temporal Cloud request. It requires the `--request-id` modifier (aliased as `-r`) followed by the specific ID of the request whose status needs to be checked. The output will display the current status of that request.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/request.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld request get --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Describing Exported File Directory Structure - Plaintext - Markdown\nDESCRIPTION: This snippet provides the naming convention and directory path structure for the exported workflow history files in object storage. It is intended for users to understand how to locate exported data within their cloud bucket. The placeholders such as [bucket-name], [Namespace], [Year], [Month], [Day], [Hour], and [Minute] indicate where users' unique values will be represented. No dependencies or code execution is required; it serves as a reference for file organization.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/export.mdx#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```  \n//[bucket-name]/temporal-workflow-history/export/[Namespace]/[Year]/[Month]/[Day]/[Hour]/[Minute]/\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling an API Key - tcld CLI - Bash\nDESCRIPTION: This snippet disables an API Key by its --id value, preventing its further use while retaining it in the system. It requires sufficient privileges in the tcld CLI and administrative or owner access on the key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey disable --id <apikey_id>\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate Specifying Output File using tcld\nDESCRIPTION: This command generates a Certificate Authority (CA) certificate using `tcld`, specifying the output path for the generated X.509 certificate `.pem` file using the `--ca-certificate-file` modifier. Replace `<path>` with the desired file path.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Visualizing Out-of-Order Replication Events Between Clusters\nDESCRIPTION: A text-based diagram showing how replication events from Run 1 and Run 2 can arrive at Cluster B in a different order than they were created in Cluster A, leading to zombie workflow states.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n| ------------- |          | ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |     |  |\n        | --- || ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n```\n\n----------------------------------------\n\nTITLE: Removing Search Attribute - SQL Database\nDESCRIPTION: Command to remove a custom Search Attribute in SQL-based Visibility store with namespace specification for v1.20+.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator search-attribute remove \\\n    --name=\"your_custom_attribute\" \\\n    --namespace=\"your_namespace\"\n```\n\n----------------------------------------\n\nTITLE: Starting a Caller Workflow with API Key Authentication - Go CLI\nDESCRIPTION: This snippet illustrates invoking a workflow from the caller namespace using the starter Go program with API key authentication. The command runs in the 'caller' directory, specifying the Temporal Cloud host, namespace, and API key as flags. Requires Go runtime, starter code, and a valid API key. Suitable for initiating workflows securely without managing client certificates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_19\n\nLANGUAGE: go\nCODE:\n```\ncd caller\n\ngo run ./starter \\\n\t-target-host <region>.<cloud_provider>.api.temporal.io:7233 \\\n\t-namespace <your-caller-namespace.account> \\\n\t-api-key <your-api-key>\n```\n\n----------------------------------------\n\nTITLE: Initial State of Version History with Multiple Clusters in Temporal\nDESCRIPTION: This snippet shows the initial version history of a workflow execution across two different clusters. It demonstrates how events are tracked with different version numbers assigned by each cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Documenting Temporal Workflow Execution Events - Markdown\nDESCRIPTION: This Markdown snippet structures documentation for multiple Temporal Workflow event types, including field descriptions in an organized tabular format. Each event section uses Markdown headings followed by tables outlining each field and description for easy reference. The documentation is intended for developers integrating or monitoring Temporal Server workflows; it introduces no dependencies beyond basic Markdown syntax and is designed primarily for static site rendering or documentation generation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/events.mdx#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n### RequestCancelExternalWorkflowExecutionFailed\n\nThis [Event](/workflow-execution/event#event) type indicates that [Temporal Server](/temporal-service/temporal-server) could not cancel the targeted [Workflow](/workflows).\nThis is usually because the target Workflow could not be found.\n\n| Field                            | Description                                                                                     |\n| -------------------------------- | ----------------------------------------------------------------------------------------------- |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with. |\n| namespace                        | [Namespace](/namespaces) of the Workflow that failed to cancel.                                 |\n| workflow_execution               | Identifies the Workflow and the run of the [Workflow Execution](/workflow-execution). |\n| initiated_event_id               | Id of the [RequestCancelExternalWorkflowExecutionInitiated] Event this failure corresponds to.  |\n\n### ExternalWorkflowExecutionCancelRequested\n\nThis [Event](/workflow-execution/event#event) type indicates that the [Temporal Server](/temporal-service/temporal-server) has successfully requested the cancelation of the target [Workflow](/workflows).\n\n| Field              | Description                                                                                                                                                       |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [RequestCancelExternalWorkflowExecutionInitiated](#requestcancelexternalworkflowexecutioninitiated) Event that this cancelation request corresponds to. |\n| namespace          | [Namespace](/namespaces) of the Workflow that was requested to cancel.                                                                                            |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflow-execution).                                                                   |\n\n### ExternalWorkflowExecutionSignaled\n\nThis [Event](/workflow-execution/event#event) type indicates that the [Temporal Server](/temporal-service/temporal-server) has successfully [Signaled](/sending-messages#sending-signals) the targeted [Workflow](/workflows).\n\n| Field              | Description                                                                                                                      |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |\n| initiated_event_id | Id of the [SignalExternalWorkflowExecutionInitiated](#signalexternalworkflowexecutioninitiated) Event this Event corresponds to. |\n| namespace          | [Namespace](/namespaces) of the Workflow that was signaled to.                                                                   |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflow-execution).                                  |\n\n### MarkerRecorded\n\nThis [Event](/workflow-execution/event#event) type is transparent to the [Temporal Server](/temporal-service/temporal-server).\nThe Server will only store it and will not try to understand it.\nThe SDK client may use it for local activities or side effects.\n\n| Field                            | Description                                                                                                         |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| marker_name                      | Identifies various markers.                                                                                         |\n| details                          | Serialized information recorded in the marker.                                                                      |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                     |\n| header                           | Information passed by the sender of the [Signal](/sending-messages#sending-signals) that is copied into the marker. |\n| failure                          | Serialized result of a [Workflow](/workflows) failure.                                                              |\n\n### StartChildWorkflowExecutionInitiated\n\nThis [Event](/workflow-execution/event#event) type indicates that the [Temporal Server](/temporal-service/temporal-server) will try to start a Child Workflow.\n\n| Field         | Description                                     |\n| ------------- | ----------------------------------------------- |\n| namespace     | [Namespace](/namespaces) of the Child Workflow. |\n| workflow_id   | Identifies the Child Workflow.                  |\n| workflow_type | The name/type of Workflow that was initiated.   |\n\n### StartChildWorkflowExecutionFailed\n\nThis [Event](/workflow-execution/event#event) type indicates a [Child Workflow Execution](/child-workflows) cannot be started / triggered.\nIt is usually due to a Child Workflow Id collision.\n\n| Field                            | Description                                                                                                              |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| namespace                        | [Namespace](/namespaces) of the Child Workflow.                                                                          |\n| workflow_id                      | Identifies the Child Workflow.                                                                                           |\n| workflow_type                    | The name/type of Workflow that has failed.                                                                               |\n| initiated_event_id               | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| workflow_task_completed_event_id | The Id of the [WorkflowTaskCompleted](#workflowtaskcompleted) that the Event was reported with.                          |\n\n### ChildWorkflowExecutionStarted\n\nThis [Event](/workflow-execution/event#event) type indicates a [Child Workflow Execution](/child-workflows) has successfully started / triggered.\nThis would also cause the [WorkflowExecutionStarted](#workflowexecutionstarted) to be recorded for the Workflow that has started.\n\n| Field              | Description                                                                                                                      |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |\n| namespace          | [Namespace](/namespaces) of the Child Workflow.                                                                                  |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to.         |\n| workflow_execution | Identifies the Workflow and the run of the Workflow Execution.                                                                   |\n| workflow_type      | The name/type of Workflow that has started execution.                                                                            |\n| header             | Information passed by the sender of the [Signal](/sending-messages#sending-signals) that is copied into the Child Workflow Task. |\n\n### ChildWorkflowExecutionCompleted\n\nThis [Event](/workflow-execution/event#event) type indicates that the [Child Workflow Execution](/child-workflows) has successfully completed.\nThis would also cause the [WorkflowExecutionCompleted](#workflowexecutioncompleted) to be recorded for the [Workflow](/workflows) that has completed.\n\n| Field              | Description                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------ |\n| result             | Serialized result of the completed Child Workflow.                                                                       |\n| namespace          | [Namespace](/namespaces) of the completed Child Workflow.                                                                |\n| workflow_execution | Identifies the Workflow and the run of the [Workflow Execution](/workflow-execution).                          |\n| workflow_type      | The name/type of Workflow that was completed.                                                                            |\n| initiated_event_id | Id of the [StartChildWorkflowExecutionInitiated](#startchildworkflowexecutioninitiated) Event this Event corresponds to. |\n| started_event_id   | Id of the [ChildWorkflowExecutionStarted](#childworkflowexecutionstarted) Event this Event corresponds to.               |\n```\n\n----------------------------------------\n\nTITLE: Displaying Help for Temporal CLI Environment Settings in Shell\nDESCRIPTION: This command displays the help information for setting environment variables in the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\ntemporal env set -h\n```\n\n----------------------------------------\n\nTITLE: Updating Version History Table with New Events in Temporal Workflow\nDESCRIPTION: This snippet shows the version history table after adding a second event with version 1. The table maintains the history of events and their associated versions across both clusters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL Visibility Store in Temporal Service YAML\nDESCRIPTION: This YAML configuration snippet illustrates how to specify MySQL as the Visibility store in the Temporal Service persistence section. It includes setting the 'visibilityStore' key to identify the MySQL visibility store and defines detailed connection and pool parameters under 'datastores'. The configuration requires the appropriate MySQL plugin (version-dependent), database name, connection address, protocol, authentication credentials, and connection pool options; credentials and network details must be securely provided prior to deployment. The file must be integrated as part of Temporal Server's YAML configuration, and inputs may vary depending on the precise MySQL or plugin version targeted.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n#...\npersistence:\n  #...\n  visibilityStore: mysql-visibility\n  #...\n  datastores:\n    default:\n      #...\n    mysql-visibility:\n      sql:\n        pluginName: 'mysql8' # For MySQL v8.0.17 and later. For earlier versions, use \"mysql\" plugin.\n        databaseName: 'temporal_visibility'\n        connectAddr: ' ' # Remote address of this database; for example, 127.0.0.0:3306\n        connectProtocol: ' ' # Protocol example: tcp\n        user: 'username_for_auth'\n        password: 'password_for_auth'\n        maxConns: 2\n        maxIdleConns: 2\n        maxConnLifetime: '1h'\n#...\n```\n\n----------------------------------------\n\nTITLE: Composing a CompositePayloadConverter with Binary Protobufs - TypeScript\nDESCRIPTION: This snippet creates a `CompositePayloadConverter` which combines support for undefined values, binary buffers, protobuf binary encoding, and JSON objects. Each converter handles its respective encoding type, with `ProtobufBinaryPayloadConverter` providing efficient protobuf serialization, and others (undefined, binary, and JSON) covering the default Temporal types. This is recommended when you have mixed payload types in your workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  BinaryPayloadConverter,\n  CompositePayloadConverter,\n  JsonPayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { ProtobufBinaryPayloadConverter } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new BinaryPayloadConverter(),\n  new ProtobufBinaryPayloadConverter(root),\n  new JsonPayloadConverter(),\n);\n```\n\n----------------------------------------\n\nTITLE: Printing datetime in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that displays formatted timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --print_datetime\n```\n\n----------------------------------------\n\nTITLE: Deleting an API Key with Resource Version - tcld CLI - Bash\nDESCRIPTION: This snippet adds the --resource-version option to specify an etag or version for concurrency control during API Key deletion. If not set, the CLI uses the latest version. Useful in distributed or automated environments to avoid stale updates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey delete --id <apikey_id> --resource-version <version>\n```\n\n----------------------------------------\n\nTITLE: Terminating a Workflow Execution with Reason\nDESCRIPTION: Shows how to terminate a Workflow Execution while providing a reason for the termination.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_66\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow terminate --workflow_id --reason <string>\n```\n\n----------------------------------------\n\nTITLE: Adding a New Build ID to Task Queue in Go (Deprecated)\nDESCRIPTION: This code shows how to update a task queue with a new Build ID by adding it as the sole version in a new default set. This creates a new compatibility set and marks it as the default for the queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDOpAddNewIDInNewDefaultSet{\n      BuildID: \"deadbeef\",\n   },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow State\nDESCRIPTION: Example of querying a workflow's state using the getCount query type\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\n```\n\n----------------------------------------\n\nTITLE: Updating Namespace CA Certificates using tcld (Bash)\nDESCRIPTION: Demonstrates the `tcld` command used to update the accepted client CA certificates for a Temporal Cloud Namespace. The `--ca-certificate-file` flag specifies the path to a file containing one or more CA certificate PEM blocks (e.g., the concatenated file shown previously for rotation).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Listing Users by Namespace Permissions via tcld CLI - Command\nDESCRIPTION: Lists users with specific namespace permissions using the --namespace flag. The flag filters the user list by namespace ID, showing only users granted permissions on that namespace. Pagination behavior can be modified with additional paging flags.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_6\n\nLANGUAGE: command\nCODE:\n```\ntcld user list --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Setting Global Codec Endpoint for Temporal CLI\nDESCRIPTION: Uses the Temporal CLI `env set` command to configure the Codec Server endpoint (`--codec-endpoint`) globally for the current environment. This command sets the endpoint to `http://localhost:8888`, meaning subsequent CLI commands will use this endpoint by default without needing the flag specified each time. Requires the Temporal CLI to be installed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env set --codec-endpoint \"http://localhost:8888\"\n```\n\n----------------------------------------\n\nTITLE: Managing Temporal Cloud Metrics Endpoint with tcld CLI\nDESCRIPTION: Lists the `tcld` commands for managing the Temporal Cloud metrics endpoint via the command-line interface. Includes the command to add an accepted client CA certificate (`tcld account metrics accepted-client-ca add`), enable the endpoint (`tcld account metrics enable`), and disable the endpoint (`tcld account metrics disable`). These commands facilitate the configuration and control of observability settings programmatically.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/general-setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntcld account metrics accepted-client-ca add\n```\n\nLANGUAGE: shell\nCODE:\n```\ntcld account metrics enable\n```\n\nLANGUAGE: shell\nCODE:\n```\ntcld account metrics disable\n```\n\n----------------------------------------\n\nTITLE: Retrieving Environment Variables for Temporal CLI in Shell\nDESCRIPTION: This command retrieves the environment variables set for the 'prod' environment using the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\ntemporal env get prod\n```\n\n----------------------------------------\n\nTITLE: Setting a Custom Data Converter on Client Connection - Temporal Python SDK (Python)\nDESCRIPTION: This code shows how to instantiate a Temporal client with a custom Data Converter by supplying a Payload Codec via the 'data_converter' parameter. It replaces the default data converter using 'dataclasses.replace', setting 'payload_codec' to an instance of the user-defined 'EncryptionCodec'. Requirements include the custom codec module and standard 'temporalio.converter.default()' method. The configuration ensures all Workflow payloads are processed using the specified codec (for compression/encryption) whenever the client connects to the Temporal Cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/converters-and-encryption.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom codec import EncryptionCodec\n\nclient = await Client.connect(\n\t\"localhost:7233\",\n\tdata_converter=dataclasses.replace(\n\t\ttemporalio.converter.default(), payload_codec=EncryptionCodec()\n\t),\n)\n```\n\n----------------------------------------\n\nTITLE: Upgrading MySQL Default Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command uses the `temporal-sql-tool` to upgrade the default persistence schema for a Temporal Server instance backed by MySQL (specifically targeting v5.7 schema compatibility). It connects securely using TLS, provides necessary certificates and credentials, specifies the `mysql` plugin, targets the `temporal` database, and applies schema updates from the designated MySQL v5.7 schema directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal update-schema -d ./schema/mysql/v57/temporal/versioned/\n```\n\n----------------------------------------\n\nTITLE: Fetching Temporal Workflow History to JSON via Python (Bash)\nDESCRIPTION: Executes the `get_workflow_history.py` Python script using `poetry run`. This command fetches the execution history of a specific Workflow from the Temporal cluster and saves it as a JSON file. This file can then be used for offline analysis or replaying.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/replay_your_workflow/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python get_workflow_history.py\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Search Attributes in Temporal Cloud CLI\nDESCRIPTION: Command to add multiple custom search attributes with different types to a namespace. This allows for various data types to be indexed and searched.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes add \\\n    --search-attribute \"YourSearchAttribute1=Text\" \\\n    --search-attribute \"YourSearchAttribute2=Double\"\n```\n\n----------------------------------------\n\nTITLE: Listing All Workflows with Raw Timestamp\nDESCRIPTION: Command to list all workflows while displaying raw timestamp information\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow listall --print_raw_time\n```\n\n----------------------------------------\n\nTITLE: Adding CA Certificate from File - tcld CLI - Bash\nDESCRIPTION: This example shows how to add a CA certificate to the metrics endpoint using a PEM file path. The --ca-certificate-file parameter specifies the certificate file location, and if both --ca-certificate and --ca-certificate-file are set, --ca-certificate takes precedence. Required dependency: tcld CLI with relevant access, and a valid PEM file on disk.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca add --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Querying Error-Free Request Ratios with Prometheus - PromQL\nDESCRIPTION: This PromQL example calculates the daily average proportion of error-free Temporal service gRPC API requests over 10-minute windows. It uses the request count (temporal_cloud_v0_frontend_service_request_count) and error count (temporal_cloud_v0_frontend_service_error_count) metrics filtered for mission-critical operations. The ratio is averaged using avg_over_time, and a fallback vector(1) ensures valid output if the request count is zero. Requires Prometheus ingestion of relevant metrics. Outputs the average successful request ratio for each monitored namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/service-health.mdx#2025-04-23_snippet_1\n\nLANGUAGE: promql\nCODE:\n```\navg_over_time((\n    (\n        (\n            sum(increase(temporal_cloud_v0_frontend_service_request_count{temporal_namespace=~\"$namespace\", operation=~\"StartWorkflowExecution|SignalWorkflowExecution|SignalWithStartWorkflowExecution|RequestCancelWorkflowExecution|TerminateWorkflowExecution\"}[10m]))\n            -\n            sum(increase(temporal_cloud_v0_frontend_service_error_count{temporal_namespace=~\"$namespace\", operation=~\"StartWorkflowExecution|SignalWorkflowExecution|SignalWithStartWorkflowExecution|RequestCancelWorkflowExecution|TerminateWorkflowExecution\"}[10m]))\n        )\n        /\n        sum(increase(temporal_cloud_v0_frontend_service_request_count{temporal_namespace=~\"$namespace\", operation=~\"StartWorkflowExecution|SignalWorkflowExecution|SignalWithStartWorkflowExecution|RequestCancelWorkflowExecution|TerminateWorkflowExecution\"}[10m]))\n    )\n    or vector(1)\n    )[1d:10m])\n```\n\n----------------------------------------\n\nTITLE: Deleting an S3 Export Sink with TCLD CLI - Bash\nDESCRIPTION: Deletes an existing S3 export sink from the specified Temporal Cloud Namespace using the `tcld namespace export s3 delete` command. Flags required are `--namespace` and `--sink-name`. Useful for cleaning up or revoking obsolete export configurations. Inputs are the namespace and the sink name; CLI output will confirm deletion or state errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 delete \\\n    --namespace <namespace_id> \\\n    --sink-name <sink_name>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Workflow History Branch Before Conflict Resolution\nDESCRIPTION: This ASCII diagram shows a simplified Workflow Execution History at time T=0. It depicts a single history branch where Task A is generated based on Event ID 4, which has version 2. This represents the state before any conflict resolution involving history divergence has occurred.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n| -------- | ------------- |\n| Events   |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 1        | 1             |\n| 2        | 1             |\n| 3        | 2             |\n| -------- | ------------- |\n|          |\n|          |\n| -------- | ------------- |\n| Event ID | Event Version |\n| -------- | ------------- |\n| 4        | 2             | <-- task A belongs to this event |\n| -------- | ------------- |\n```\n\n----------------------------------------\n\nTITLE: Successful API Key Creation Output\nDESCRIPTION: Terminal output showing successful creation of a Temporal Cloud API Key with Terraform. It displays the assigned API key ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_23\n\nLANGUAGE: text\nCODE:\n```\ntemporalcloud_apikey.global_apikey: Creation complete after 1s [id=kayBf38JIWkMPmnfr59iEIaEk2L7uqR4]\n```\n\n----------------------------------------\n\nTITLE: Encoding Payload via HTTP POST to Codec Server /encode Endpoint\nDESCRIPTION: Sample HTTP POST request to a Codec Server's `/encode` endpoint (`https://dev.mydomain.com/codec/encode`). Similar to the decode request, it includes headers like `Content-Type`, `X-Namespace`, and `Authorization`. The request body contains decoded data structures under the 'payloads' key. The 200 OK response provides the corresponding base64 encoded payloads.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_2\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 POST /encode\nHost: https://dev.mydomain.com/codec\nContent-Type: application/json\nX-Namespace: myapp-dev.acctid123\nAuthorization: Bearer <token>\n\n{\"payloads\":[{\"metadata\":{\"encoding\":\"json/protobuf\",\"messageType\":\"temporal_shop.orchestrations.v1.StartShoppingCartRequest\"},\"data\":{\"cartId\":\"example-cart\",\"shopperId\":\"your-shopper-id-example\",\"email\":\"your-email@domain.com\"}}]}\n```\n\nLANGUAGE: http\nCODE:\n```\n200 OK\nContent-Type: application/json\n\n{\n  \"payloads\": [\n    {\n      \"metadata\": {\n        \"encoding\": \"anNvbi9wcm90b2J1Zg==\",\n        \"messageType\": \"dGVtcG9yYWxfc2hvcC5vcmNoZXN0cmF0aW9ucy52MS5TdGFydFNob3BwaW5nQ2FydFJlcXVlc3Q=\"\n      },\n      \"data\": \"eyJjYXJ0SWQiOiJleGFtcGxlLWNhcnQiLCJzaG9wcGVySWQiOiJ5b3VyLXNob3BwZXItaWQtZXhhbXBsZSIsImVtYWlsIjoieW91ci1lbWFpbEBkb21haW4uY29tIn0\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Client CA Certificate to Temporal Cloud Namespace\nDESCRIPTION: This command adds a client CA certificate to a specified Namespace in Temporal Cloud using the namespace ID and an encoded certificate.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add \\\n    --namespace <namespace_id> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Sharing Promises Between Cancellation Scopes in Temporal Workflows\nDESCRIPTION: Illustrates how promises for operations like Activities are bound to the cancellation scope where they were created, not where they are awaited. This allows activities started in one scope to be consumed in another without being affected by cancellation of the consumer scope.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/cancellation.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CancellationScope, proxyActivities } from '@temporalio/workflow';\nimport type * as activities from '../activities';\n\nconst { httpGetJSON } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '10m',\n});\n\nexport async function sharedScopes(): Promise<any> {\n  // Start activities in the root scope\n  const p1 = httpGetJSON('http://url1.ninja');\n  const p2 = httpGetJSON('http://url2.ninja');\n\n  const scopePromise = CancellationScope.cancellable(async () => {\n    const first = await Promise.race([p1, p2]);\n    // Does not cancel activity1 or activity2 as they're linked to the root scope\n    CancellationScope.current().cancel();\n    return first;\n  });\n  return await scopePromise;\n  // The Activity that did not complete will effectively be cancelled when\n  // Workflow completes unless the Activity is awaited:\n  // await Promise.all([p1, p2]);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Cloud Provider API Key Manually in HCL\nDESCRIPTION: Manually configures the Temporal Cloud provider within a Terraform (.tf) file by directly providing the API key. This is an alternative to using environment variables for authentication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_2\n\nLANGUAGE: hcl\nCODE:\n```\nprovider \"temporalcloud\" {\n  api_key = \"my-temporalcloud-api-key\"\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Initial Namespace Version (Cluster B Active)\nDESCRIPTION: Example showing the initial state of Namespace β. When registered with Cluster B (initial version 2) as the active cluster, the namespace's version is set to 2. All subsequent workflow events within this namespace will be tagged with version 2.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nnamespace β's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\n----------------------------------------\n\nTITLE: Illustrating Namespace Version After Failover (A to B)\nDESCRIPTION: Example demonstrating the version change for Namespace α after failing over from Cluster A (initial version 1) to Cluster B (initial version 2). Following the versioning rule, the namespace's version is updated to 2. New events will now be tagged with version 2.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nnamespace α's version is 2\nall workflows events generated within this namespace, will come with version 2\n```\n\n----------------------------------------\n\nTITLE: Placeholder Configuration for Importing Namespace in HCL\nDESCRIPTION: Defines an empty `temporalcloud_namespace` resource block in the Terraform configuration file. This serves as a placeholder required by the `terraform import` command before it can associate an existing Temporal Cloud Namespace with this Terraform resource name (`namespace` in this case).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_12\n\nLANGUAGE: hcl\nCODE:\n```\nresource \"temporalcloud_namespace\" \"namespace\" {\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Active Cluster during Namespace Registration with tctl\nDESCRIPTION: Specifies the name of the active Temporal Cluster when registering a Namespace using the `--active_cluster <name>` modifier with `tctl namespace register`. This is particularly relevant for Global Namespaces where failover can occur. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --active_cluster <name>\n```\n\n----------------------------------------\n\nTITLE: Querying Poll Timeout Rate for Matching Service using PromQL\nDESCRIPTION: This Prometheus query calculates the total per-second average rate of poll timeouts (`poll_timeouts`) across the Matching Service over the last 5 minutes. This occurs when a poller waits for a task but none becomes available within the timeout period.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_6\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(poll_timeouts{}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Describing a Temporal Namespace by ID using tctl\nDESCRIPTION: Describes a specific Temporal Namespace by providing its unique ID using the `tctl namespace describe` command. The `--namespace_id` modifier is required unless the global `--namespace` modifier is specified when invoking `tctl` (e.g., `tctl --namespace <name> describe`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace describe --namespace_id <id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutual TLS (mTLS) for Internode and Frontend in YAML\nDESCRIPTION: This YAML configuration provides a comprehensive example of securing a Temporal Cluster using mutual TLS (mTLS) for both internal service (`internode`) and external client (`frontend`) communication. It requires client authentication (`requireClientAuth: true`) for both, specifies server certificates/keys, the expected server names (`serverName`), and lists the necessary Certificate Authority files (`clientCaFiles`, `rootCaFiles`) for validating both server and client certificates across different communication paths (internode-to-internode and client-to-frontend).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nglobal:\n  tls:\n    internode:\n      server:\n        certFile: /path/to/internode/cert/file\n        keyFile: /path/to/internode/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n      client:\n        serverName: dnsSanInInternodeCertificate\n        rootCaFiles:\n          - /path/to/internode/serverCa\n    frontend:\n      server:\n        certFile: /path/to/frontend/cert/file\n        keyFile: /path/to/frontend/key/file\n        requireClientAuth: true\n        clientCaFiles:\n          - /path/to/internode/serverCa\n          - /path/to/sdkClientPool1/ca\n          - /path/to/sdkClientPool2/ca\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/serverCa\n```\n\n----------------------------------------\n\nTITLE: Configuring Elasticsearch as Both Primary and Secondary Visibility Store\nDESCRIPTION: YAML configuration for using Elasticsearch as both primary and secondary Visibility store. It demonstrates how to configure different indices for primary and secondary visibility in a single Elasticsearch instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  visibilityStore: es-visibility\n  datastores:\n    es-visibility:\n      elasticsearch:\n        version: 'v7'\n        logLevel: 'error'\n        url:\n          scheme: 'http'\n          host: '127.0.0.1:9200'\n        indices:\n          visibility: temporal_visibility_v1\n          secondary_visibility: temporal_visibility_v1_new\n        closeIdleConnectionsInterval: 15s\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow by Run ID in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the run_id modifier. This allows resetting a Workflow Execution by specifying its Run ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate from a Namespace\nDESCRIPTION: This command removes a client CA certificate from a specified Namespace in Temporal Cloud using the namespace ID and encoded certificate.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --namespace <namespace_id> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Requesting End-Entity Certificate with certstrap (Command Line)\nDESCRIPTION: Uses the `certstrap request-cert` command to create a Certificate Signing Request (CSR) for an end-entity certificate. The common name for the certificate is taken from the `NAMESPACE_NAME` environment variable previously set. This step generates the CSR file (`your-namespace.csr`) in the `out` subdirectory but does not create the final certificate yet.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_5\n\nLANGUAGE: command\nCODE:\n```\n./certstrap request-cert --common-name ${NAMESPACE_NAME}\n```\n\n----------------------------------------\n\nTITLE: Output of Specific Property Retrieval with Temporal CLI\nDESCRIPTION: Shows the expected output when retrieving a specific environment property (tls-key-path) from the local environment configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntls-key-path  /home/my-user/certs/cluster.key\n```\n\n----------------------------------------\n\nTITLE: Defining Calendar Expression in JSON for Temporal Schedule\nDESCRIPTION: This JSON snippet demonstrates how to define a calendar expression for a Temporal Schedule. It specifies the year, months, days of the month, and hours for scheduling Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/schedule.mdx#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"year\": \"2022\",\n  \"month\": \"Jan,Apr,Jul,Oct\",\n  \"dayOfMonth\": \"1,15\",\n  \"hour\": \"11-14\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cassandra and MySQL Schemas for Dual Visibility\nDESCRIPTION: Bash script showing how to set up both Cassandra and MySQL database schemas for Dual Visibility. It includes environment variable setup, connection configuration, and schema creation for both primary and secondary Visibility stores.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# set your Cassandra environment variables\n: \"${KEYSPACE:=temporal}\"\n: \"${VISIBILITY_KEYSPACE:=temporal_primary_visibility}\"\n\n: \"${CASSANDRA_SEEDS:=}\"\n: \"${CASSANDRA_PORT:=9042}\"\n: \"${CASSANDRA_USER:=}\"\n: \"${CASSANDRA_PASSWORD:=}\"\n: \"${CASSANDRA_TLS_ENABLED:=}\"\n: \"${CASSANDRA_CERT:=}\"\n: \"${CASSANDRA_CERT_KEY:=}\"\n: \"${CASSANDRA_CA:=}\"\n: \"${CASSANDRA_REPLICATION_FACTOR:=1}\"\n#...\n# set connection details\n#...\n# set up Cassandra schema\nsetup_cassandra_schema() {\n  #...\n  # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/cassandra/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" create -k \"${VISIBILITY_KEYSPACE}\" --rf \"${CASSANDRA_REPLICATION_FACTOR}\"\n    fi\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" setup-schema -v 0.0\n    temporal-cassandra-tool --ep \"${CASSANDRA_SEEDS}\" -k \"${VISIBILITY_KEYSPACE}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n#...\n# set your MySQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_secondary_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${MYSQL_SEEDS:=}\"\n: \"${MYSQL_USER:=}\"\n: \"${MYSQL_PWD:=}\"\n: \"${MYSQL_TX_ISOLATION_COMPAT:=false}\"\n\n#...\n# set connection details\n#...\n# set up MySQL schema\nsetup_mysql_schema() {\n    #...\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/mysql/${MYSQL_VERSION_DIR}/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" setup-schema -v 0.0\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n#...\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Temporal Schedule Execution\nDESCRIPTION: Commands to trigger immediate execution of a Schedule, with optional overlap policy override.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/schedule.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal schedule trigger --schedule-id 'your-schedule-id'\ntemporal schedule trigger --schedule-id 'your-schedule-id' --overlap-policy 'AllowAll'\n```\n\n----------------------------------------\n\nTITLE: Managing Temporal Java Project with Makefile and Maven\nDESCRIPTION: This Makefile defines targets to simplify building and running the Temporal Java client sample project using Maven (`mvn`). The `build` target cleans and installs dependencies, `clean` removes generated files, `worker` compiles and executes the worker application (`clientsample.YourWorkerApp`), and `caller` executes the caller application (`clientsample.YourCallerApp`). These commands streamline the development and execution process.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/cloudserver-client-sample/README.md#2025-04-23_snippet_1\n\nLANGUAGE: makefile\nCODE:\n```\nbuild:\n     mvn clean install -Dmaven.logging.level=0\n\nclean:\n     mvn clean -q -Dmaven.logging.level=0\n\nworker:\n     mvn compile exec:java -Dexec.mainClass=\"clientsample.YourWorkerApp\" -Dmaven.logging.level=1\n\ncaller:\n     mvn exec:java -Dexec.mainClass=\"clientsample.YourCallerApp\" -q -Dmaven.logging.level=1\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in .NET SDK pre-v1.1.0\nDESCRIPTION: Updates the API key on an existing Temporal client connection in .NET SDK versions prior to 1.1.0. Requires setting the entire RpcMetadata dictionary with the new API key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nmyClient.Connection.RpcMetadata = new Dictionary<string, string>()\n{\n    [\"Authorization\"] = $\"Bearer {myKeyUpdated}\",\n};\n```\n\n----------------------------------------\n\nTITLE: Listing S3 Export Sinks in a Namespace with TCLD CLI - Bash\nDESCRIPTION: Lists all defined S3 export sinks for a specific Temporal Cloud Namespace using `tcld namespace export s3 list`. Use the `--namespace` flag to identify the namespace. Supports paging via optional parameters. Provides enumeration of current export sink configurations for workflow history export.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 list \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Filters with Resource Version in Temporal Cloud CLI\nDESCRIPTION: Command to add certificate filters to a namespace using a specific resource version (ETag). This ensures updates are based on the correct version of the resource.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters add \\\n    --resource-version <etag> \\\n    --certificate-filter-file <file>\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Worker using Python Script via Poetry (Bash)\nDESCRIPTION: Executes the `run_worker.py` Python script using `poetry run`. This command starts a Temporal Worker process, which is necessary to listen for and execute Workflow and Activity tasks. Assumes a Python environment managed by Poetry and a configured Temporal cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/replay_your_workflow/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python run_worker.py\n```\n\n----------------------------------------\n\nTITLE: Adding Client CA Certificate with Request ID\nDESCRIPTION: This command adds a client CA certificate with a specified request identifier for tracking the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add \\\n    --request-id <request_id> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Running Patch-Deprecated Workflow Worker in Python\nDESCRIPTION: Command to run the worker with the patch-deprecated workflow implementation. This stage marks the old code path as deprecated after confirming no workflows are using it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python worker.py --workflow patch-deprecated\n```\n\n----------------------------------------\n\nTITLE: Disabling Archival - Temporal Service - YAML\nDESCRIPTION: Disables the Archival feature at both the service and Namespace default levels in Temporal by setting the state to 'disabled' in the config/development.yaml file. No additional dependencies required besides file write access. Inputs are the YAML state values; outputs are service behaviors with archival turned off. Limitation: Must be manually reverted to re-enable Archival.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\narchival:\\n  history:\\n    state: 'disabled'\\n\\nnamespaceDefaults:\\n  archival:\\n    history:\\n      state: 'disabled'\\n\n```\n\n----------------------------------------\n\nTITLE: Export Sink Status Output - JSON\nDESCRIPTION: Example JSON output from the `tcld namespace export s3 get` command, detailing the export sink's configuration and health status. The JSON includes sink identifiers, state, S3 configuration, and timestamps. Inputs reflect matching CLI query parameters; outputs provide sink metadata and operational status, which are essential for monitoring and troubleshooting.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/aws-export-s3.mdx#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"name\": \"your-sink-name\",\\n  \"resourceVersion\": \"a6442895-1c07-4da4-aaca-58d57d338345\",\\n  \"state\": \"Active\",\\n  \"spec\": {\\n    \"name\": \"your-sink-name\",\\n    \"enabled\": true,\\n    \"destinationType\": \"S3\",\\n    \"s3Sink\": {\\n      \"roleName\": \"your-export-test\",\\n      \"bucketName\": \"your-export-test\",\\n      \"region\": \"us-east-1\",\\n      \"kmsArn\": \"\",\\n      \"awsAccountId\": \"123456789012\"\\n    }\\n  },\\n  \"health\": \"Ok\",\\n  \"errorMessage\": \"\",\\n  \"latestDataExportTime\": \"0001-01-01T00:00:00Z\",\\n  \"lastHealthCheckTime\": \"2023-08-14T21:30:02Z\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Temporal Nexus EndpointSpec and Target Types in Protobuf\nDESCRIPTION: References to Protobuf definitions for Temporal Nexus's EndpointSpec and its supported target types. The EndpointSpec supports routing to a Worker target (using Namespace and Task Queue) or an External target (experimental) for Nexus RPC endpoints.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/nexus-endpoints.mdx#2025-04-23_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nhttps://github.com/temporalio/api/blob/2a5b3951e71565e28628edea1b3d88d69ed26607/temporal/api/nexus/v1/message.proto#L170\n```\n\nLANGUAGE: protobuf\nCODE:\n```\nhttps://github.com/temporalio/api/blob/2a5b3951e71565e28628edea1b3d88d69ed26607/temporal/api/nexus/v1/message.proto#L185\n```\n\n----------------------------------------\n\nTITLE: Calculating Temporal Sync Match Rate Using Prometheus Query - PromQL\nDESCRIPTION: This Prometheus query systematically computes the Sync Match Rate as a ratio of sync poll success to total poll success, grouped by temporal_namespace and using a 5-minute rate. It uses 'temporal_cloud_v0_poll_success_sync_count' and 'temporal_cloud_v0_poll_success_count' filtered by namespace. Inputs: metric labels and namespace filter (\\\"$namespace\\\"). Outputs: Sync Match Rate per namespace for use in dashboards or alerting rules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_5\n\nLANGUAGE: promql\nCODE:\n```\nsum by(temporal_namespace) (\n    rate(\n        temporal_cloud_v0_poll_success_sync_count{temporal_namespace=~\"$namespace\"}[5m]\n    )\n)\n/\nsum by(temporal_namespace) (\n    rate(\n        temporal_cloud_v0_poll_success_count{temporal_namespace=~\"$namespace\"}[5m]\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Failing a tctl Activity using Workflow ID (Bash)\nDESCRIPTION: This command demonstrates how to fail a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Workflow ID with the `--workflow_id` (or `-w`) modifier. Replace `<id>` with the actual Workflow ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity fail --workflow_id <id>\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Filters with Request ID and File in Temporal Cloud CLI\nDESCRIPTION: Command to add certificate filters to a namespace using a request ID and certificate filter file. This allows controlling which certificates can connect to the namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters add \\\n    --request-id <request_id> \\\n    --certificate-filter-file <file>\n```\n\n----------------------------------------\n\nTITLE: Sending an Update to the Basic Workflow (Go)\nDESCRIPTION: This command compiles and runs the Go program responsible for sending an update to the basic Workflow. It takes an integer `i` as a command-line argument, which is used as the payload for the Workflow Update signal. Requires a running instance of the basic Workflow started via `starter/main.go`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo run update/main_dacx.go i\n```\n\n----------------------------------------\n\nTITLE: Defining Reply URL Pattern for Microsoft Entra ID SAML Integration\nDESCRIPTION: Specifies the required format pattern for the Reply URL (Assertion Consumer Service URL) for Microsoft Entra ID SAML configuration with Temporal Cloud. Users must replace 'ACCOUNT_ID' with their specific Temporal Cloud Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttps://login.tmprl.cloud/login/callback?connection=ACCOUNT_ID-saml\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Default Max Receive Message Length (C++)\nDESCRIPTION: C++ preprocessor macro defining the default maximum message length (`GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH`) for gRPC, set to 4 MB. This limit applies to each message received by the Temporal service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH (4 * 1024 * 1024)\n```\n\n----------------------------------------\n\nTITLE: Defining NexusOperationCanceled Event Fields in Markdown\nDESCRIPTION: This snippet defines the fields for the NexusOperationCanceled event type using a Markdown table. It includes scheduled_event_id, failure, and request_id fields with their descriptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/events.mdx#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Field | Description |\n| :---- | :---- |\n| scheduled_event_id | The ID of the [NexusOperationScheduled](#nexusoperationscheduled)` event. Uniquely identifies this operation. |\n| failure | Cancellation details. |\n| request_id | The request ID allocated at schedule time. |\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Importing Temporal Cloud User\nDESCRIPTION: Terraform configuration placeholder for importing an existing Temporal Cloud User. This minimal resource definition will be populated with the imported user's details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_19\n\nLANGUAGE: yml\nCODE:\n```\nresource \"temporalcloud_user\" \"user\" {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WorkerLocalActivitiesPerSecond for Temporal Worker in Go\nDESCRIPTION: Rate limits the number of Local Activity Executions started per second for this specific Worker. This helps manage resource consumption. The type is `float64` (allowing rates less than 1), and the default is `100000`. Setting it to `0` uses the default. This can protect downstream services called by Local Activities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_31\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    WorkerLocalActivitiesPerSecond: 100000,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Querying Percentile History Task Processing Latency per Attempt using PromQL\nDESCRIPTION: This Prometheus query calculates a specified percentile (defined by `$percentile`) of the processing latency per attempt (`task_latency_processing_bucket`) for active History tasks (`operation=~\"TransferActive.*\"`) within the History Service (`service_name=\"history\"`) over the last 1 minute. It uses a variable `$service`. This metric helps understand the time taken for each processing attempt of a task.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_11\n\nLANGUAGE: PromQL\nCODE:\n```\nhistogram_quantile($percentile, sum(rate(task_latency_processing_bucket{operation=~\"TransferActive.*\",service=\"$service\", service_name=\"history\"}[1m])) by (operation, le))\n```\n\n----------------------------------------\n\nTITLE: Updating History Archival State for a Namespace using tctl\nDESCRIPTION: Updates the state ('enabled' or 'disabled') for Workflow Execution History Archival for an existing Namespace using the `--history_archival_state <value>` modifier with `tctl namespace update`. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --history_archival_state <value>\n```\n\n----------------------------------------\n\nTITLE: Configuring Archival Settings - Enabled in YAML\nDESCRIPTION: Example configuration for enabling archival features for both history and visibility data with multiple provider options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\narchival:\n  history:\n    state: 'enabled'\n    enableRead: true\n    provider:\n      filestore:\n        fileMode: '0666'\n        dirMode: '0766'\n      gstorage:\n        credentialsPath: '/tmp/gcloud/keyfile.json'\n  visibility:\n    state: 'enabled'\n    enableRead: true\n    provider:\n      filestore:\n        fileMode: '0666'\n        dirMode: '0766'\n```\n\n----------------------------------------\n\nTITLE: Illustrating Version History State at T=2 (No Conflict)\nDESCRIPTION: This table shows the state at T=2 after adding a third event (ID 3) with version 1. The version history is updated to reflect that event ID 3 is the last event associated with version 1.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               |                 |         |\n| 3        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Complex List Filter with Multiple Conditions\nDESCRIPTION: Example of a complex List Filter that combines WorkflowType, ExecutionStatus, StartTime, and CloseTime conditions with AND/OR operators.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowType = \"main.YourWorkflowDefinition\" and ExecutionStatus != \"Running\" and (StartTime > \"2021-06-07T16:46:34.236-08:00\" or CloseTime > \"2021-06-07T16:46:34-08:00\")\n```\n\n----------------------------------------\n\nTITLE: Example: Describing a Global Namespace using tctl (Shorthand)\nDESCRIPTION: Demonstrates describing a Global Namespace named 'canary-namespace' using shorthand aliases (`--ns` for `--namespace`, `n` for `namespace`, `desc` for `describe`). The output displays various details like description, owner email, status, retention period, active cluster, and associated clusters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ tctl --ns canary-namespace n desc\nName: canary-namespace\nDescription: testing namespace\nOwnerEmail: dev@yourtech.io\nNamespaceData:\nStatus: REGISTERED\nRetentionInDays: 7\nEmitMetrics: true\nActiveClusterName: dc1\nClusters: dc1, dc2\n```\n\n----------------------------------------\n\nTITLE: Renaming Search Attributes with Resource Version in Temporal Cloud CLI\nDESCRIPTION: Command to rename a search attribute using a specific resource version (ETag) to ensure the rename operation is based on the correct version.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes rename \\\n    --resource-version <etag> \\\n    --existing-name <value> \\\n    --new-name <value>\n```\n\n----------------------------------------\n\nTITLE: Querying Sticky Cache Eviction Rate with Prometheus\nDESCRIPTION: A PromQL query calculating the per-second rate of forced evictions from the sticky cache, based on the `temporal_sticky_cache_total_forced_eviction_total` SDK metric, over the last 5 minutes within a specific `$namespace`. A high eviction rate can indicate cache inefficiency, often due to the cache size (`WorkflowCacheSize`) being too small relative to the number of active workflows, or potential worker backlogs causing workflows to be unnecessarily evicted. Requires a `$namespace` variable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_11\n\nLANGUAGE: promql\nCODE:\n```\nrate(temporal_sticky_cache_total_forced_eviction_total{namespace=\"$namespace\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in .NET SDK v1.1.0+\nDESCRIPTION: Updates the API key on an existing Temporal client connection in .NET SDK v1.1.0 or newer. Simple property assignment is used to update the key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nmyClient.Connection.ApiKey = myKeyUpdated;\n```\n\n----------------------------------------\n\nTITLE: Configuring Codec Endpoint in Temporal UI Server YAML\nDESCRIPTION: Specifies the Codec Server endpoint within the configuration file for a self-hosted Temporal UI server. The `codec.endpoint` property is set using Go templating, defaulting to the value of the `TEMPORAL_CODEC_ENDPOINT` environment variable if available, or using a pattern involving the `{namespace}` placeholder otherwise. This allows dynamic endpoint configuration based on the environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ncodec:\n    endpoint: {{ default .Env.TEMPORAL_CODEC_ENDPOINT \"{namespace}\"}}\n```\n\n----------------------------------------\n\nTITLE: Printing datetime in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that displays formatted timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_datetime\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Namespace - Temporal CLI - Shell\nDESCRIPTION: Illustrates how to create a new custom namespace in the local Temporal development server using the 'temporal' CLI. This enables environment isolation for different workflow configurations or versions during development. Requires installation of the Temporal CLI, and the server must be running locally. Replace 'new_custom_namespace_name' with your desired namespace identifier.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-namespace-client-sample/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntemporal operator namespace create -n new_custom_namespace_name\n```\n\n----------------------------------------\n\nTITLE: Toggling the 'apikey' Feature in Temporal Cloud with tcld (Bash)\nDESCRIPTION: Demonstrates a specific example of using the `tcld feature toggle-*` command to toggle the state (enable or disable) of the 'apikey' feature within Temporal Cloud. This command directly modifies the feature's enabled status.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/feature.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld feature toggle-apikey\n```\n\n----------------------------------------\n\nTITLE: Getting an S3 Export Sink Details with TCLD CLI - Bash\nDESCRIPTION: Retrieves configuration and details for an existing S3 export sink in a Temporal Cloud Namespace with `tcld namespace export s3 get`. Flags `--namespace` and `--sink-name` must be specified. Mainly used for workflow export audits or verification. Inputs include the namespace and export sink name; output contains the sink details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 get \\\n    --namespace <namespace_id> \\\n    --sink-name <sink_name>\n```\n\n----------------------------------------\n\nTITLE: Removing a Custom Search Attribute from a Workflow - Java\nDESCRIPTION: This snippet illustrates how to remove a custom Search Attribute from a Workflow Execution by unsetting its value using valueUnset(), and then upserting with upsertTypedSearchAttributes. The SearchAttributeKey is shared as a constant for accessibility. After this operation, the attribute will be deleted from the Workflow state. Requires the Temporal Java SDK and proper setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/observability.mdx#2025-04-23_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\n    // In a shared constants file, so all files have access\n\n    public static final SearchAttributeKey<Boolean> IS_ORDER_FAILED = SearchAttributeKey.forBoolean(\"isOrderFailed\");\n\n    ...\n\n    Workflow.upsertTypedSearchAttributes(Constants.IS_ORDER_FAILED.valueUnset());\n```\n\n----------------------------------------\n\nTITLE: Adding Search Attributes with Namespace Specification in Temporal Cloud CLI\nDESCRIPTION: Command to add custom search attributes to a specific namespace in Temporal Cloud. This enables custom indexing and querying capabilities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes add \\\n    --namespace <namespace_id> \\\n    --search-attribute <value>\n```\n\n----------------------------------------\n\nTITLE: Triggering Workflow via HTTP GET\nDESCRIPTION: Access this URL using a web browser or a tool like cURL to send an HTTP GET request to the running gateway process. This request triggers the initiation of the Temporal Workflow defined in the example application. The gateway process started in the previous step must be running and listening on port 8091.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/sessions/README.md#2025-04-23_snippet_2\n\nLANGUAGE: http\nCODE:\n```\nhttp://localhost:8091/start\n```\n\n----------------------------------------\n\nTITLE: Setting a User's Account Role by Email via tcld CLI - Command\nDESCRIPTION: Assigns or updates the account-level role of a user by email. Requires the --user-email and --account-role flags; --account-role value determines user privileges (admin, developer, or read). Optional --request-id and --resource-version flags support asynchronous calls or ETag-based updating.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_9\n\nLANGUAGE: command\nCODE:\n```\ntcld user set-account-role --user-email <test@example.com> --account-role Developer\n```\n\n----------------------------------------\n\nTITLE: Updating Codec Server Configuration with Namespace and Endpoint\nDESCRIPTION: This command updates the codec server configuration for a Temporal Cloud Namespace. It requires specifying both the namespace and an endpoint URL that will be used to decode payloads.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_61\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-codec-server \\\n    --namespace <namespace_id> \\\n    --endpoint <http_url>\n```\n\n----------------------------------------\n\nTITLE: Defining a Kubernetes Deployment for the Temporal Worker in YAML\nDESCRIPTION: This YAML manifest defines a Kubernetes `Deployment` named `your-app` in the `your-namespace` namespace. It specifies 1 replica, selects pods with the label `app: your-app`, and defines the pod template. The template includes a container using the ECR image (`<your-ecr-image-name>`), injects environment variables from the `temporal-worker-config` ConfigMap and `temporal-secret` Secret, and sets CPU/memory resource requests and limits.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n   name: your-app\n   namespace: your-namespace\n   labels:\n      app: your-app\nspec:\n   selector:\n      matchLabels:\n         app: your-app\n   replicas: 1\n   template:\n      metadata:\n         labels:\n            app: your-app\n      spec:\n         serviceAccountName: your-app\n         containers:\n            - name: your-app\n              image: <your-ecr-image-name>\n              env:\n                - name: TEMPORAL_ADDRESS\n                  valueFrom:\n                    configMapKeyRef:\n                      name: temporal-worker-config\n                      key: TEMPORAL_ADDRESS\n                - name: TEMPORAL_NAMESPACE\n                  valueFrom:\n                    configMapKeyRef:\n                      name: temporal-worker-config\n                      key: TEMPORAL_NAMESPACE\n                - name: TEMPORAL_TASK_QUEUE\n                  valueFrom:\n                    configMapKeyRef:\n                      name: temporal-worker-config\n                      key: TEMPORAL_TASK_QUEUE\n                - name: TEMPORAL_API_KEY\n                  valueFrom:\n                    secretKeyRef:\n                      name: temporal-secret\n                      key: TEMPORAL_API_KEY\n              resources:\n                limits:\n                  cpu: \"0.5\"\n                  memory: \"512Mi\"\n                requests:\n                  cpu: \"0.2\"\n                  memory: \"256Mi\"\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Default Transaction Size Limit in Temporal (Go)\nDESCRIPTION: Go code illustrating the default transaction size limit for persistence of Event Histories, set to 4MB (4 * 1024 * 1024 bytes). This value represents the largest transaction size allowed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Based on the pull request https://github.com/temporalio/temporal/pull/1363 \n// which sets the default limit:\ndefaultTransactionSizeLimit = 4 * 1024 * 1024\n```\n\n----------------------------------------\n\nTITLE: Successful User Deletion Output\nDESCRIPTION: Terminal output showing successful deletion of a Temporal Cloud User with Terraform. It confirms the destruction of the specified user resource.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_18\n\nLANGUAGE: text\nCODE:\n```\ntemporalcloud_user.namespace_admin: Destruction complete after 2s\nApply complete! Resources: 0 added, 0 changed, 1 destroyed.\n```\n\n----------------------------------------\n\nTITLE: Printing full event details in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that displays comprehensive event information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --print_full\n```\n\n----------------------------------------\n\nTITLE: Defining Single Sign On URL Pattern for Okta SAML Integration\nDESCRIPTION: Specifies the required format pattern for the Single Sign On URL when configuring an Okta SAML 2.0 application integration for Temporal Cloud. Users must replace 'ACCOUNT_ID' with their specific Temporal Cloud Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nhttps://login.tmprl.cloud/login/callback?connection=ACCOUNT_ID-saml\n```\n\n----------------------------------------\n\nTITLE: Showing only reset-eligible events in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that filters output to show only events eligible for reset.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --reset_points_only\n```\n\n----------------------------------------\n\nTITLE: Renaming Search Attributes with Namespace Specification in Temporal Cloud CLI\nDESCRIPTION: Command to rename a custom search attribute in a specific namespace. This allows changing attribute names while preserving indexed data.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes rename \\\n    --namespace <namespace_id> \\\n    --existing-name <value> \\\n    --new-name <value>\n```\n\n----------------------------------------\n\nTITLE: Patching Protobuf Root for Temporal Integration - JavaScript\nDESCRIPTION: This snippet patches the generated protobuf root object to work correctly with the Temporal TypeScript SDK using a helper from `@temporalio/common`. It imports the root JSON module generated by protobufjs, patches it using `patchProtobufRoot`, and exports the patched root. This module is a prerequisite for setting up any payload converters using protobufs in the Temporal ecosystem.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_13\n\nLANGUAGE: js\nCODE:\n```\nconst { patchProtobufRoot } = require('@temporalio/common/lib/protobufs');\nconst unpatchedRoot = require('./json-module');\nmodule.exports = patchProtobufRoot(unpatchedRoot);\n```\n\n----------------------------------------\n\nTITLE: Setting Workflow Retry Policy in Java\nDESCRIPTION: Shows how to set a Workflow Retry Policy using WorkflowOptions.Builder when creating a WorkflowStub instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nGreetWorkflowInterface workflow1 =\n    WorkerGreet.greetclient.newWorkflowStub(\n        GreetWorkflowInterface.class,\n        WorkflowOptions.newBuilder()\n                .setWorkflowId(\"GreetWF\")\n                .setTaskQueue(WorkerGreet.TASK_QUEUE)\n                // Set Workflow Retry Options\n                .setRetryOptions(RetryOptions.newBuilder()\n                .build());\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Identifier Length in Temporal (YAML)\nDESCRIPTION: Example YAML configuration from a development SQL setup, setting the `limit.maxIDLength` dynamic configuration variable to 255 characters. This limits the length of identifiers like Workflow ID, Workflow Type, and Task Queue name in self-hosted Temporal.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlimit.maxIDLength:\n  - value: 255\n```\n\n----------------------------------------\n\nTITLE: Configuring Authorization (auth) in Temporal Web UI (YAML)\nDESCRIPTION: Sets up authorization for the Temporal Web UI Server. This example shows configuration for an OIDC provider like Google, including client ID, secret, callback URL, and scopes. These settings apply when `auth.enabled` is true.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nauth:\n  enabled: true\n  providers:\n    label: sso # for internal use; in future may expose as button text\n    type: oidc\n    providerUrl: https://accounts.google.com\n    issuerUrl:\n    clientId: xxxxx-xxxx.apps.googleusercontent.com\n    clientSecret: xxxxxxxxxxxxxxxxxxxx\n    callbackUrl: https://xxxx.com:8080/auth/sso/callback\n    scopes:\n      - openid\n      - profile\n      - email\n```\n\n----------------------------------------\n\nTITLE: Example Error: Shared Library Not Found on Alpine Linux\nDESCRIPTION: This shell output shows a typical error encountered when running a Temporal TypeScript Worker built for a glibc-based Linux distribution on an Alpine Linux (musl-based) environment. The error `Error loading shared library ld-linux-x86-64.so.2: No such file or directory` indicates that a fundamental shared library expected by the precompiled native components of the Temporal SDK (`@temporalio/core-bridge/index.node`) is missing in Alpine.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_27\n\nLANGUAGE: sh\nCODE:\n```\n```sh\nError: Error loading shared library ld-linux-x86-64.so.2: No such file or directory (needed by /opt/app/node_modules/@temporalio/core-bridge/index.node)\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal CLI with Homebrew on macOS/Linux\nDESCRIPTION: Command to install the Temporal CLI using Homebrew package manager on macOS or Linux systems.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install temporal\n```\n\n----------------------------------------\n\nTITLE: Example Temporal Cloud Certificate Filter (CN and O Match)\nDESCRIPTION: Illustrates a certificate filter configuration requiring matches on multiple fields. For a client certificate to be authorized, its Common Name (CN) must be 'stage.example.com' AND its Organization (O) field must be 'Example Code Inc.'\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_11\n\nLANGUAGE: json\nCODE:\n```\nAuthorizedClientCertificate {\n  CN : \"stage.example.com\"\n  O : \"Example Code Inc.\"\n}\n```\n\n----------------------------------------\n\nTITLE: Updating the Active Cluster for a Namespace using tctl\nDESCRIPTION: Updates the currently active Temporal Cluster for a Namespace (typically a Global Namespace during failover) using the `--active_cluster <name>` modifier with `tctl namespace update`. Requires the target namespace to be specified (e.g., via the global `--namespace` flag).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --active_cluster <name>\n```\n\n----------------------------------------\n\nTITLE: Simple WorkflowId List Filter\nDESCRIPTION: Basic List Filter that matches a specific WorkflowId.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId = '<workflow-id>'\n```\n\n----------------------------------------\n\nTITLE: Terminating a Batch Job in Temporal CLI\nDESCRIPTION: This command terminates a specific Batch job. It shows how to use the 'batch terminate' command with a Job ID and a reason to stop an ongoing Batch operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal batch terminate --job-id=MyJobId --reason=JobReason\n```\n\n----------------------------------------\n\nTITLE: Specifying Failover Clusters during Namespace Registration with tctl\nDESCRIPTION: Defines a space-separated list of Temporal Cluster names to which a Global Namespace can fail over using the `--clusters <names>` modifier with `tctl namespace register`. This setting requires the `--global_namespace` modifier to be set to true and cannot be changed after registration. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --clusters <names>\n```\n\n----------------------------------------\n\nTITLE: Configuring Codec Server with Cross-Origin Credentials\nDESCRIPTION: This command sets up a codec server with cross-origin credentials enabled. The --include-credentials modifier allows the inclusion of credentials in cross-origin requests to the codec server endpoint.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_64\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-codec-server \\\n    --namespace <namespace_id> \\\n    --endpoint <https_url> \\\n    --include-credentials true\n```\n\n----------------------------------------\n\nTITLE: Importing Certificate Filters from File in Temporal Cloud CLI\nDESCRIPTION: Command to import certificate filters from a JSON file. The filters specify which certificate attributes are allowed to connect to the namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters import \\\n    --certificate-filter-file <path>\n```\n\n----------------------------------------\n\nTITLE: Using memo_file option in tctl workflow run command\nDESCRIPTION: Command that passes information for a memo from a JSON file. For multiple JSON objects, they can be concatenated with spaces or newlines, matching the order of keys in memo_key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --memo_file <filename>\n```\n\n----------------------------------------\n\nTITLE: Event Type Enumeration Definition in Protocol Buffers\nDESCRIPTION: Reference to the enum definition for Event Types in the Temporal Server API, which defines all possible events that can occur during Workflow Execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/event.mdx#2025-04-23_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n// Referenced from: github.com/temporalio/api/blob/master/temporal/api/enums/v1/event_type.proto\n```\n\n----------------------------------------\n\nTITLE: Removing a Custom Search Attribute within a Workflow in Python\nDESCRIPTION: Explains how to remove an existing Search Attribute from a workflow by using `workflow.upsert_search_attributes()`. Setting the value of the `SearchAttributePair` to an empty list (`[]`) effectively removes the attribute associated with `customer_id_key`. This operation requires the Temporal Python SDK (`temporalio`) and is executed within the workflow's code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n```python\nworkflow.upsert_search_attributes(TypedSearchAttributes([\n    SearchAttributePair(customer_id_key, [])\n]))\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Top-Level tctl Help\nDESCRIPTION: This command displays the general help message for the tctl tool, listing top-level commands and global options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ntctl -h\n```\n\n----------------------------------------\n\nTITLE: Executing Workflow for Dynamic Activity (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow execute` command to start an instance of `GreetingWorkflow`. It targets the `dynamic-activity-task-queue` where the dynamic activity worker is listening, passes the string \"Dynamic Activity argument\" as input, and runs in the `default` namespace. This workflow is expected to invoke an activity that will be handled by the dynamic activity handler.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute \\\n --task-queue dynamic-activity-task-queue \\\n --type GreetingWorkflow \\\n --input '\"Dynamic Activity argument\"'  \\\n --namespace default\n```\n\n----------------------------------------\n\nTITLE: Successful User Creation Output\nDESCRIPTION: Terminal output showing successful creation of a Temporal Cloud User with Terraform. It displays the assigned user ID and summary of resources.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_16\n\nLANGUAGE: text\nCODE:\n```\ntemporalcloud_user.namespace_admin: Creation complete after 1s [id=12a34bc5678910d38d9e8390636e7412]\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\n```\n\n----------------------------------------\n\nTITLE: Calculating Temporal Activity Task Latency Average with Prometheus - PromQL\nDESCRIPTION: This average latency query calculates mean schedule-to-start duration for all activity tasks across given namespaces and queues in a 5-minute window. Built from the 'temporal_activity_schedule_to_start_latency_seconds_sum' and 'temporal_activity_schedule_to_start_latency_seconds_count' metrics, it lets you monitor ongoing application responsiveness. Inputs are metric timeseries; output is a floating-point average, grouped by both namespace and task queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_3\n\nLANGUAGE: promql\nCODE:\n```\nsum(increase(temporal_activity_schedule_to_start_latency_seconds_sum[5m])) by (namespace, task_queue)\n/\nsum(increase(temporal_activity_schedule_to_start_latency_seconds_count[5m])) by (namespace, task_queue)\n```\n\n----------------------------------------\n\nTITLE: Setting CA Certificate with Resource Version - tcld CLI - Bash\nDESCRIPTION: Sets the CA certificate for the metrics endpoint using a specific resource version to guard against conflicts. Required parameters: --resource-version (the ETag) and --ca-certificate (certificate string). Ensures only intended changes are applied. The tcld CLI must be configured.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca set --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Logs from a Kubernetes Pod using Shell\nDESCRIPTION: This shell command uses `kubectl logs` to fetch the logs from a specific pod, identified by `<pod-name>`, within the `temporal-system` namespace (note: example text uses `your-namespace` earlier, adjust as needed). This is crucial for checking if the Worker started correctly and connected successfully to the Temporal Cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n```\nkubectl logs <pod-name> -n temporal-system\n```\n```\n\n----------------------------------------\n\nTITLE: Getting User Information via tcld CLI by User ID - Command\nDESCRIPTION: Demonstrates fetching user information using the --user-id flag. This command returns account and permission details for the specified user ID. Prerequisites are identical to the email-based approach: CLI authentication and required permissions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_3\n\nLANGUAGE: command\nCODE:\n```\ntcld user delete --user-id <test-user-id>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Namespace Retention Settings with Temporal Cloud CLI\nDESCRIPTION: This command retrieves the length of time (in days) a closed Workflow will be preserved before deletion for a specified Namespace. The --namespace modifier is required to specify the target Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_59\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace retention get \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Cluster Replication Prior to v1.14\nDESCRIPTION: Example YAML configuration showing how to set up multi-cluster replication for Temporal versions before v1.14, with necessary settings for two clusters (A and B).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n# cluster A\nclusterMetadata:\n  enableGlobalNamespace: true\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterA\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n\n# cluster B\nclusterMetadata:\n  enableGlobalNamespace: true\n  failoverVersionIncrement: 100\n  masterClusterName: \"clusterA\"\n  currentClusterName: \"clusterB\"\n  clusterInformation:\n    clusterA:\n      enabled: true\n      initialFailoverVersion: 1\n      rpcAddress: \"127.0.0.1:7233\"\n    clusterB:\n      enabled: true\n      initialFailoverVersion: 2\n      rpcAddress: \"127.0.0.1:8233\"\n```\n\n----------------------------------------\n\nTITLE: Deleting an API Key with tcld CLI – Command\nDESCRIPTION: This snippet details the deletion of an API key using the Temporal Cloud CLI. Users authenticate with `tcld login` and then invoke `tcld apikey delete --id <api-key-id>`, where the key ID must be supplied. After execution, the API key is immediately invalidated. Dependencies include access to the tcld CLI and sufficient permission to delete the specified key. Input required: API key ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_2\n\nLANGUAGE: command\nCODE:\n```\ntcld login\ntcld apikey delete --id <api-key-id>\n```\n\n----------------------------------------\n\nTITLE: Specifying Run ID in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that shows the History of a Workflow Execution by specifying a Run Id. Can be shortened to -r.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: Example Temporal Cloud Certificate Filter (Exact CN Match)\nDESCRIPTION: Provides an example structure for a Temporal Cloud certificate filter. This specific filter configuration requires the client certificate's Common Name (CN) field in the subject to exactly match 'code.example.com' for authorization. Other fields are not checked.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\nAuthorizedClientCertificate {\n  CN : \"code.example.com\"\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Temporal Schedules using tctl (Shell)\nDESCRIPTION: Lists existing Temporal Schedules. When using standard Visibility, the output might only include Schedule IDs without further details. The Schedule Spec output might be in a canonical form.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ntctl schedule list\n```\n\n----------------------------------------\n\nTITLE: Viewing Temporal Cloud API Key State\nDESCRIPTION: Bash command and output showing how to view the Terraform state for an API Key resource. Note that the sensitive token value is hidden.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nterraform state show temporalcloud_apikey.global_apikey\n\n# temporalcloud_apikey.global_apikey:\nresource \"temporalcloud_apikey\" \"global_apikey\" {\n    disabled     = false\n    display_name = \"adminKey3\"\n    expiry_time  = \"2024-12-01T00:00:00Z\"\n    id           = \"kayBf38JIWkMPmnfr59iEIaEk2L7uqR4\"\n    owner_id     = \"b81336a6097449cba75c2e5500df3d31\"\n    owner_type   = \"service-account\"\n    state        = \"active\"\n    token        = (sensitive value)\n}\n```\n\n----------------------------------------\n\nTITLE: Running Handler Worker Connected to Temporal Cloud\nDESCRIPTION: Bash command to run a Nexus handler Worker connected to Temporal Cloud using mTLS certificates. This worker processes incoming Nexus requests from the caller namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.handler.HandlerWorker \\\n  --args=\"-target-host <your-target-namespace.account>.tmprl.cloud:7233 \\\n  -namespace <your-target-namespace.account> \\\n  -client-cert 'path/to/your/ca.pem' \\\n  -client-key 'path/to/your/ca.key'\"\n```\n\n----------------------------------------\n\nTITLE: Checking History Size Against Warning Limit in Temporal (Go)\nDESCRIPTION: Go code snippet from the Temporal history service (`workflowExecutionContext.go`) showing the condition check for Workflow Execution history size against the configured warning limit (default 10 MB). A warning is logged if the size exceeds this limit.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nif mutableState.GetHistorySize() > h.config.HistorySizeLimitWarn() || mutableState.GetExecutionInfo().ExecutionStats.HistorySize > h.config.HistorySizeLimitWarn() || int64(mutableState.GetNextEventID()-1) > h.config.HistoryCountLimitWarn() {\n```\n\n----------------------------------------\n\nTITLE: Deleting a Nexus Endpoint using Temporal CLI\nDESCRIPTION: This command deletes a Nexus Endpoint from the Server. It requires specifying the name of the endpoint to be deleted.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint delete --name your-endpoint\n```\n\n----------------------------------------\n\nTITLE: Accessing Temporal Cloud Namespace Details URL\nDESCRIPTION: This snippet illustrates the URL format for accessing the details webpage of a specific Namespace within the Temporal Cloud environment. Users need to substitute 'your_namespace' and 'your_account_id' with their specific Namespace name and account identifier to navigate to the correct page.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/references/concepts.mdx#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://cloud.temporal.io/namespaces/your_namespace.your_account_id\n```\n\n----------------------------------------\n\nTITLE: Antipattern: Avoid Racing `sleep().then()` Chains in JavaScript\nDESCRIPTION: Highlights a potential pitfall when using `Promise.race` with a `sleep` followed by a `.then()` callback in JavaScript. The `.then()` callback might execute even if the other promise in the race finishes first, potentially leading to unexpected state inconsistencies.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/timers.mdx#2025-04-23_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nawait Promise.race([\n  sleep('5s').then(() => (status = 'timed_out')),\n  somethingElse.then(() => (status = 'processed')),\n]);\n\nif (status === 'processed') await complete(); // takes more than 5 seconds\n// status = timed_out\n```\n\n----------------------------------------\n\nTITLE: Illustrating Temporal Cloud Audit Log Examples\nDESCRIPTION: This snippet presents several example audit log entries in JSON format, as they would appear in the configured stream. Each line represents a separate log entry detailing specific administrative actions performed in Temporal Cloud, such as updating account settings (`UpdateAccount`), deleting users (`DeleteUser`), inviting users (`InviteUsers`), updating user roles (`UpdateUser`), modifying Namespace configurations (`UpdateNamespace`), and changing user permissions (`UpdateUserNamespacePermissions`). The `**********` separators visually distinguish individual log entries in the documentation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/audit-logging.mdx#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\"emit_time\":\"2023-10-24T08:19:41Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.1.2.3, 10.4.5.6\",\"user_email\":\"user1@example.com\",\"operation\":\"UpdateAccount\",\"details\":{\"client_ca_fingerprints\":[\"5bb99d14fa602f7d39b7d048674a2251\"],\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb634\",\"principal\":{\"id\":\"988cb80b-d6be-4bb5-9c87-d09f93f58ed3\",\"type\":\"user\",\"name\":\"user1@example.com\"}}\n**********\n{\"emit_time\":\"2023-10-25T21:16:42Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.7.8.9\",\"user_email\":\"user2@example.com\",\"operation\":\"DeleteUser\",\"details\":{\"target_users\":[\"0b741c47-e093-47d1-9b74-f2359129f78f\"],\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb635\",\"request_id\":\"445297d3-43a7-4793-8a04-1b1dd1999641\",\"principal\":{\"id\":\"b160473e-e40d-4a81-90d1-f4218269e6e4\",\"type\":\"user\",\"name\":\"user2@example.com\"}}\n**********\n{\"emit_time\":\"2023-11-03T19:31:45Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.1.2.3, 10.10.11.12\",\"user_email\":\"user3@example.com\",\"operation\":\"InviteUsers\",\"details\":{\"target_users\":[\"user3@example.net\"],\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb636\",\"principal\":{\"id\":\"35fdc757-9637-446b-b386-12ed475511ad\",\"type\":\"user\",\"name\":\"user3@example.com\"}}\n**********\n{\"emit_time\":\"2023-11-08T08:06:40Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.1.2.3, 10.4.5.6\",\"user_email\":\"user1@example.com\",\"operation\":\"UpdateUser\",\"details\":{\"target_users\":[\"user1@example.net\"],\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb637\",\"request_id\":\"445297d3-43a7-4793-8a04-1b1dd1999640\",\"principal\":{\"id\":\"988cb80b-d6be-4bb5-9c87-d09f93f58ed3\",\"type\":\"user\",\"name\":\"user1@example.com\"}}\n**********\n{\"emit_time\":\"2023-11-08T08:14:09Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.1.2.3, 10.4.5.6\",\"user_email\":\"user1@example.com\",\"operation\":\"UpdateNamespace\",\"details\":{\"namespace\":\"audit-log-test.example-dev\",\"client_ca_fingerprints\":[\"f186d0bd971ff7d52dc6cc9d9b6f7644\"],\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb638\",\"principal\":{\"id\":\"988cb80b-d6be-4bb5-9c87-d09f93f58ed3\",\"type\":\"user\",\"name\":\"user1@example.com\"}}\n**********\n{\"emit_time\":\"2023-11-08T09:20:22Z\",\"level\":\"LOG_LEVEL_INFO\",\"caller_ip_address\":\"10.1.2.3, 10.4.5.6\",\"user_email\":\"user1@example.com\",\"operation\":\"UpdateUserNamespacePermissions\",\"details\":{\"namespace\":\"audit-log-test.example-dev\",\"search_attribute_update\":{}},\"status\":\"OK\",\"category\":\"LOG_CATEGORY_ADMIN\",\"log_id\":\"0mc69c0323b871293ce231dd1c7fb639\",\"principal\":{\"id\":\"988cb80b-d6be-4bb5-9c87-d09f93f58ed3\",\"type\":\"user\",\"name\":\"user1@example.com\"}}\n**********\n```\n\n----------------------------------------\n\nTITLE: Triggering a Temporal Schedule with Overlap Policy Override using tctl (Shell)\nDESCRIPTION: Manually triggers the action for a specific Temporal Schedule (`--schedule-id`) to run immediately, overriding its default overlap policy for this specific trigger. The example uses `--overlap-policy 'AllowAll'` to ensure the Workflow starts even if others are running or buffered.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl schedule trigger --schedule-id 'your-schedule-id' --overlap-policy 'AllowAll'\n```\n\n----------------------------------------\n\nTITLE: WorkflowId with StartTime Filter\nDESCRIPTION: List Filter that matches a specific WorkflowId that started after a specific timestamp.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_11\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId = '<workflow-id>' and StartTime > '2021-08-22T15:04:05+00:00'\n```\n\n----------------------------------------\n\nTITLE: Enabling Cross-Cluster Connection\nDESCRIPTION: Enables or disables cross-cluster connection using the upsert command. This is useful for managing cluster interconnectivity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator cluster upsert --enable-connection=true\n```\n\n----------------------------------------\n\nTITLE: Keyword STARTS_WITH List Filter Example\nDESCRIPTION: Example of a List Filter using the STARTS_WITH operator to match WorkflowIds that begin with a specific prefix.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId STARTS_WITH \"order-\"\n```\n\n----------------------------------------\n\nTITLE: Setting AWS Account ID and Region Environment Variables in Bash\nDESCRIPTION: These Bash commands export the AWS account ID and AWS region as environment variables. These variables are typically required by the `aws` CLI and other tools (like Docker for ECR login) to interact with the correct AWS account and region. Replace `<your_aws_account_id>` and `<your_aws_region>` with actual values.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nexport AWS_ACCOUNT_ID=<your_aws_account_id>\nexport AWS_REGION=<your_aws_region>\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Components in MDX Files\nDESCRIPTION: Example showing how to import multiple specific components at once from the site's component library in MDX files.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { RelatedReadContainer, RelatedReadItem } from '@site/src/components';\n```\n\n----------------------------------------\n\nTITLE: Updating a Namespace with Temporal CLI\nDESCRIPTION: Updates various settings of a namespace, including active cluster, global status, and archival states using the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace update --active-cluster=NewActiveCluster\n```\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace --promote-global=true\n```\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace update --history-archival-state=\"enabled\" --visibility-archival-state=\"disabled\"\n```\n\n----------------------------------------\n\nTITLE: Adding Certificate Filters to a Namespace\nDESCRIPTION: This command adds additional certificate filters to a Namespace using a certificate filter file. These filters authorize client certificates based on distinguished name fields.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters add \\\n    --namespace <namespace_id> \\\n    --certificate-filter-file <file>\n```\n\n----------------------------------------\n\nTITLE: Integrating Winston Logger with Temporal Runtime\nDESCRIPTION: Example showing how to integrate the Winston logging library with Temporal's Runtime to output logs to a file. This approach allows logs to be collected by external services like Datadog Agent.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  DefaultLogger,\n  makeTelemetryFilterString,\n  Runtime,\n} from '@temporalio/worker';\nimport winston from 'winston';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [new transports.File({ filename: '/path/to/worker.log' })],\n});\n\nRuntime.install({\n  logger,\n  // The following block is optional, but generally desired.\n  // It allows capturing log messages emitted by the underlying Temporal Core SDK (native code).\n  // The Telemetry Filter String determine the desired verboseness of messages emitted by the\n  // Temporal Core SDK itself (\"core\"), and by other native libraries (\"other\").\n  telemetryOptions: {\n    logging: {\n      filter: makeTelemetryFilterString({ core: 'INFO', other: 'INFO' }),\n      forward: {},\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tctl via Go\nDESCRIPTION: This command installs the latest version of the tctl tool using the Go programming language's package management. It requires Go to be installed and configured correctly, including the GOPATH environment variable. The tctl binary will be installed in the GOPATH's bin directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngo install github.com/temporalio/tctl/cmd/tctl@latest\n```\n\n----------------------------------------\n\nTITLE: Sending an Exit Signal (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow signal` command to send an `exit` signal to a specific workflow instance identified by `<your workflow id>c` (Note: the 'c' suffix might be a typo in the source). This signal is intended to trigger the workflow's completion logic and targets the `default` namespace. It sends no input payload.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow signal \\\n --workflow-id <your workflow id>c \\\n --namespace default \\\n --name \"exit\" \\\n```\n\n----------------------------------------\n\nTITLE: Expected JSON Output from Prometheus Query - JSON\nDESCRIPTION: This snippet shows a successful JSON response from the Prometheus API when querying the 'temporal_cloud_v0_state_transition_count' metric. The output confirms correct certificate setup and expected data format. No dependencies for the output itself, but reachable Prometheus endpoint and proper authentication are prerequisites. Inputs: N/A. Outputs: Status, metric name, operation, namespace, service type, and metric value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"status\\\": \\\"success\\\",\\n  \\\"data\\\": {\\n    \\\"resultType\\\": \\\"vector\\\",\\n    \\\"result\\\": [\\n      {\\n        \\\"metric\\\": {\\n          \\\"__name__\\\": \\\"temporal_cloud_v0_state_transition_count\\\",\\n          \\\"__rollup__\\\": \\\"true\\\",\\n          \\\"operation\\\": \\\"WorkflowContext\\\",\\n          \\\"temporal_namespace\\\": \\\"namespace.id\\\",\\n          \\\"temporal_service_type\\\": \\\"history\\\"\\n        },\\n        \\\"value\\\": [123456.789, \\\"12\\\"]\\n      }\\n    ]\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting API Keys with tcld CLI\nDESCRIPTION: Command to delete an API key using the tcld CLI. Requires logging in first and specifying the API key ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntcld login\ntcld apikey delete --id <api-key-id>\n```\n\n----------------------------------------\n\nTITLE: Initial Workflow Code (v1) Before Patching\nDESCRIPTION: This TypeScript snippet shows the initial version (`v1`) of the `myWorkflow` function, sourced from `patching-api/src/workflows-v1.ts`. It calls `activityA`, sleeps for a day, and then calls `activityThatMustRunAfterA`. This represents the starting point for the multi-step patching example that follows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// v1\nexport async function myWorkflow(): Promise<void> {\n  await activityA();\n  await sleep('1 days'); // arbitrary long sleep to simulate a long running workflow we need to patch\n  await activityThatMustRunAfterA();\n}\n```\n\n----------------------------------------\n\nTITLE: Final Version History State in Temporal Workflow Without Conflicts\nDESCRIPTION: This snippet presents the final state of version history after adding a fifth event with version 2. It demonstrates how events are tracked across version changes in a workflow without data conflicts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 5               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| 5        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Installing tcld via Homebrew (bash)\nDESCRIPTION: This command installs the Temporal Cloud CLI (tcld) using the Homebrew package manager on macOS or Linux. It requires Homebrew to be pre-installed and configured on the system. The command adds the `temporalio/brew` tap if not already present and installs the `tcld` formula.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/index.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install temporalio/brew/tcld\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud gRPC API Securely using Evans Shell Command\nDESCRIPTION: Provides an example `evans` command to connect to a Temporal Cloud gRPC endpoint. It specifies the service proto file, the Cloud host address, port, enables TLS, and provides paths to the client certificate and private key files for mTLS authentication. Requires `evans` installed, API repo cloned, and valid Temporal Cloud certificates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/server-frontend-api-reference.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nevans --proto temporal/api/workflowservice/v1/service.proto --host devrel.a2dd6.tmprl.cloud --port 7233 --tls --cert /Users/me/certs/temporal.pem --certkey /Users/me/certs/temporal.key\n```\n\n----------------------------------------\n\nTITLE: Setting CA Certificate Directly - tcld CLI - Bash\nDESCRIPTION: Sets one or more CA certificates to the metrics endpoint using the --ca-certificate parameter. This command replaces all existing certificates with the new value(s). Required: base64-encoded certificate PEM and tcld CLI access. Used in certificate rotation or initial setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca set --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Querying History Service Persistence Error Rate using PromQL\nDESCRIPTION: This Prometheus query calculates the total per-second average rate of persistence errors (`persistence_errors`) encountered by the History Service (`service_name=\"history\"`) over the last 1 minute. It uses a variable `$service`. This is a key indicator for problems between the History Service and the persistence store.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_14\n\nLANGUAGE: PromQL\nCODE:\n```\nsum (rate(persistence_errors{service=\"$service\",service_name=\"history\"}[1m]))\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Server - Bash\nDESCRIPTION: Starts the Temporal server process locally by invoking the temporal-server CLI. Requires Temporal binaries in the execution path and sufficient resource permissions. Input is a shell command; output is a running Temporal server instance. Limitation: Must be run from the proper directory/context.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/archival.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-server start\\n\n```\n\n----------------------------------------\n\nTITLE: Batch Resetting Workflows with Query in Bash\nDESCRIPTION: Example of using the tctl workflow reset-batch command with the query modifier. This allows resetting Workflow Executions that match a specified SQL-like query of Search Attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset-batch --query <value>\n```\n\n----------------------------------------\n\nTITLE: Defining Prometheus and Grafana Services with Docker Compose - YAML\nDESCRIPTION: These snippets show how to define Prometheus and Grafana as services in a Docker Compose file, including port mappings, volumes for configuration, and service dependencies on Temporal and Prometheus respectively. The Prometheus service mounts a custom configuration from the project directory and exposes Prometheus on port 9090. The Grafana service is configured for anonymous access, mounts provisioning directories, and is made dependent on the Prometheus container. These components are essential for establishing monitoring and metrics visualization in a local Temporal deployment. Key parameters include service image tags, port mappings, bind mounts for configurations, and environment flags for Grafana.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.5\"\nservices:\n#...\n  prometheus:\n   container_name: prometheus\n   image: prom/prometheus:v2.37.0\n   ports:\n     - 9090:9090\n   volumes:\n     - type: bind\n       source:./deployment/prometheus/config.yml\n       target: /etc/prometheus/prometheus.yml\n   depends_on:\n     - temporal\n#...\n```\n\nLANGUAGE: yaml\nCODE:\n```\nversion: \"3.5\"\nservices:\n#...\n  grafana:\n   container_name: grafana\n   image: grafana/grafana:7.5.16\n   environment:\n     - GF_AUTH_DISABLE_LOGIN_FORM=true\n     - GF_AUTH_ANONYMOUS_ENABLED=true\n     - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin\n   ports:\n     - 8085:3000\n   volumes:\n     - type: bind\n       source: ./deployment/grafana/provisioning/datasources\n       target: /etc/grafana/provisioning/datasources\n   depends_on:\n     - prometheus\n#...\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Development Server with Persistent Database in Shell\nDESCRIPTION: This command starts the Temporal development server with a specified database file for persistence. It's useful for maintaining application state across server restarts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ntemporal server start-dev --db-filename temporal.db\n```\n\n----------------------------------------\n\nTITLE: Configuring History Event Count Limits in Temporal (Go)\nDESCRIPTION: Go source code from Temporal's history configuration (`configs/config.go`) defining how the dynamic configuration properties `HistoryCountLimitWarn` and `HistoryCountLimitError` are retrieved, with defaults of 10,240 and 51,200 events respectively.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nHistoryCountLimitError:                 dc.GetIntPropertyFilteredByNamespace(dynamicconfig.HistoryCountLimitError, 51200),\nHistoryCountLimitWarn:                  dc.GetIntPropertyFilteredByNamespace(dynamicconfig.HistoryCountLimitWarn, 10240),\n```\n\n----------------------------------------\n\nTITLE: Configuring Public Client in YAML\nDESCRIPTION: Configuration for public client settings specifying how workers connect to the Temporal frontend server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\npublicClient:\n  hostPort: 'localhost:8933'\n```\n\n----------------------------------------\n\nTITLE: Signaling Workflows using Temporal CLI\nDESCRIPTION: This command sends a signal to running workflows of a specific type using a query filter. It shows how to use the 'workflow signal' command with a List Filter, specifying the signal name and input.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow signal \\\n  --workflow-id MyWorkflowId \\\n  --name MySignal \\\n  --input '{\"Input\": \"As-JSON\"}' \\\n  --query 'ExecutionStatus = \"Running\" AND WorkflowType=\"YourWorkflow\"' \\\n  --reason \"Testing\"\n```\n\n----------------------------------------\n\nTITLE: Example Error: Symbol Not Found on Alpine Linux\nDESCRIPTION: This shell output displays another common error when attempting to use the Temporal TypeScript SDK on Alpine Linux. The error `Error relocating ... __register_atfork: symbol not found` signifies an incompatibility at the C library level (glibc vs. musl) where a required symbol (`__register_atfork`) needed by the SDK's native code is not available or defined differently in Alpine's musl libc.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_28\n\nLANGUAGE: sh\nCODE:\n```\n```sh\nError: Error relocating /opt/app/node_modules/@temporalio/core-bridge/index.node: __register_atfork: symbol not found\n```\n```\n\n----------------------------------------\n\nTITLE: Accumulating Logs for Testing in Temporal\nDESCRIPTION: Example of accumulating logs in an array for testing and reporting purposes in Temporal. This approach captures all log entries for later analysis or verification in tests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/observability.mdx#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DefaultLogger, LogEntry, LogLevel } from '@temporalio/worker';\n\nconst logs: LogEntry[] = [];\nconst logger = new DefaultLogger(LogLevel.TRACE, (entry) => logs.push(entry));\n\nlogger.debug('hey', { a: 1 });\nlogger.info('ho');\nlogger.warn('lets', { a: 1 });\nlogger.error('go');\n```\n\n----------------------------------------\n\nTITLE: Initializing MySQL Visibility Schema with temporal-sql-tool in Bash\nDESCRIPTION: This Bash script snippet demonstrates how to set environment variables and invoke the 'setup_mysql_schema' function to initialize the MySQL Visibility schema for Temporal. The function uses the 'temporal-sql-tool' command-line utility to create databases and apply schema setup and updates based on the Temporal version. Required dependencies include bash, properly set MySQL environment variables, and access to the 'temporal-sql-tool' executable in your PATH. Key parameters include the database name, connection details, and schema directory, with output affecting the structure of the 'executions_visibility' table for advanced Visibility features. Ensure all environment variables are correctly set to connect securely to your MySQL service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# set your MySQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${MYSQL_SEEDS:=}\"\n: \"${MYSQL_USER:=}\"\n: \"${MYSQL_PWD:=}\"\n: \"${MYSQL_TX_ISOLATION_COMPAT:=false}\"\n\n#...\n# set connection details\n#...\n# set up MySQL schema\nsetup_mysql_schema() {\n    #...\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/mysql/${MYSQL_VERSION_DIR}/visibility/versioned\n    if [[ ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" setup-schema -v 0.0\n    temporal-sql-tool --ep \"${MYSQL_SEEDS}\" -u \"${MYSQL_USER}\" -p \"${DB_PORT}\" \"${MYSQL_CONNECT_ATTR[@]}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n#...\n}\n```\n\n----------------------------------------\n\nTITLE: Printing memo in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that includes memo information in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_memo\n```\n\n----------------------------------------\n\nTITLE: Generating mTLS Certificates for Temporal Cloud\nDESCRIPTION: Bash command to generate CA certificates for mTLS Worker authentication in Temporal Cloud. These certificates are used to secure the connection between Workers and Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntcld gen ca --org $YOUR_ORG_NAME --validity-period 1y --ca-cert ca.pem --ca-key ca.key\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Certificate Path with Temporal CLI\nDESCRIPTION: Shows how to set the TLS certificate path for a production environment using the 'temporal env set' command with the environment name and property path.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env set prod.tls-cert-path /home/my-user/certs/cluster.cert\n```\n\n----------------------------------------\n\nTITLE: Copying tcld Executable to PATH (bash)\nDESCRIPTION: This command copies the compiled `tcld` executable (assumed to be in the current directory after running `make`) to the `/usr/local/bin` directory. Placing the executable in a directory listed in the system's PATH environment variable makes the `tcld` command accessible from any location in the terminal. Requires write permissions to the target directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/index.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncp tcld /usr/local/bin/tcld\n```\n\n----------------------------------------\n\nTITLE: Creating AWS ECR Repository and Logging In Docker using Bash\nDESCRIPTION: This sequence of Bash commands first uses the `aws ecr create-repository` command to create a new repository named `your-app` in Amazon ECR. Then, it retrieves an ECR login password using `aws ecr get-login-password` and pipes it to `docker login` to authenticate the Docker CLI with the ECR registry for the specified account and region. This allows pushing images to the repository.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n```bash\naws ecr create-repository \\\n    --repository-name your-app\naws ecr get-login-password --region $AWS_REGION | \\\n    docker login --username AWS --password-stdin \\\n            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com\n```\n```\n\n----------------------------------------\n\nTITLE: Querying with Combined Default Search Attributes - Temporal CLI - shell\nDESCRIPTION: Illustrates a more advanced workflow query using multiple default Search Attributes with logical and comparison operators. This is supported only when advanced Visibility is enabled. The command filters by WorkflowType, ExecutionStatus, StartTime, and CloseTime in a composite expression. Requires Temporal CLI and an advanced Visibility backend.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/search-attributes.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --query \"WorkflowType = 'main.YourWorkflowDefinition' and ExecutionStatus != 'Running' and (StartTime > '2022-06-07T16:46:34.236-08:00' or CloseTime < '2022-06-08T16:46:34-08:00')\"\n```\n\n----------------------------------------\n\nTITLE: Configuring RoadRunner for Temporal Cloud in YAML\nDESCRIPTION: This YAML configuration snippet shows how to set up RoadRunner for managing Worker processes in Temporal Cloud, including TLS settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntemporal:\n  # ...\n  tls:\n    # root_ca: 'certs/server-root-ca-cert.pem'\n    key: 'certs/client-private-key.pem'\n    cert: 'certs/client-cert.pem'\n    client_auth_type: require_and_verify_client_cert\n    # server_name: 'tls-sample'\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate with RSA Algorithm using tcld\nDESCRIPTION: This command generates a Certificate Authority (CA) certificate using `tcld`, forcing the use of a 4096-bit RSA key pair instead of the default ECDSA P-384 by enabling the `--rsa-algorithm` flag. Replace `<boolean>` with `true` or `false` (or omit value for true).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --rsa-algorithm <boolean>\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow Executions with Temporal CLI\nDESCRIPTION: The 'temporal workflow query' command sends a Query to a Workflow Execution to retrieve all or part of the Workflow state. It can be used on both running and completed Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow query --workflow-id=meaningful-business-id --type=MyQueryType\n```\n\n----------------------------------------\n\nTITLE: Listing Workflows with Temporal CLI in Shell\nDESCRIPTION: This command lists all workflows using the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list\n```\n\n----------------------------------------\n\nTITLE: Setting Retention Period during Namespace Registration with tctl\nDESCRIPTION: Sets the Retention Period (in days) for closed Workflow Executions within the Namespace being registered using the `--retention <value>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --retention <value>\n```\n\n----------------------------------------\n\nTITLE: Defining a Kubernetes ConfigMap for Temporal Worker Configuration in YAML\nDESCRIPTION: This YAML manifest defines a Kubernetes `ConfigMap` named `temporal-worker-config` within the `temporal-system` namespace (note: example text uses `your-namespace` later, adjust as needed). It stores non-sensitive configuration data as key-value pairs: `TEMPORAL_HOST_URL`, `TEMPORAL_NAMESPACE`, and `TEMPORAL_TASK_QUEUE`. These values will be injected as environment variables into the Worker pods. Replace placeholder values.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: temporal-worker-config\n  namespace: temporal-system\ndata:\n  TEMPORAL_HOST_URL: “<your-temporal-address>“\n  TEMPORAL_NAMESPACE: “<your-temporal-cloud-namespace>”\n  TEMPORAL_TASK_QUEUE: “<your-task-queue>”\n```\n```\n\n----------------------------------------\n\nTITLE: CA Certificate Bundle Format for Certificate Rollover\nDESCRIPTION: This shows the format for creating a CA certificate bundle file containing both old and new certificates for rollover. The PEM blocks are concatenated on adjacent lines.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_30\n\nLANGUAGE: text\nCODE:\n```\n-----BEGIN CERTIFICATE-----\n... old CA cert ...\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\n... new CA cert ...\n-----END CERTIFICATE-----\n```\n\n----------------------------------------\n\nTITLE: Enabling Tracing with ClientOptions in Go\nDESCRIPTION: This code demonstrates how to enable tracing by passing the created interceptor to ClientOptions in Temporal Go SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/observability.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nc, err := client.Dial(client.Options{\n  Interceptors:       []interceptor.ClientInterceptor{tracingInterceptor},\n})\n```\n\n----------------------------------------\n\nTITLE: Promoting Set to Default via Task Queue Update (Legacy)\nDESCRIPTION: This snippet demonstrates promoting an entire compatibility set to become the default set for a Task Queue using the deprecated `client.taskQueue.updateBuildIdCompatibility` method. The `promoteSetByBuildId` operation identifies the set containing the specified `buildId` ('deadbeef') and makes that entire set the default for the Task Queue. New Workflows will start targeting the default Build ID of this newly promoted set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nawait client.taskQueue.updateBuildIdCompatibility('your_task_queue_name', {\n  operation: 'promoteSetByBuildId',\n  buildId: 'deadbeef',\n});\n```\n\n----------------------------------------\n\nTITLE: Renaming Search Attributes with Request ID in Temporal Cloud CLI\nDESCRIPTION: Command to rename a search attribute with a specific request identifier for tracking the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_56\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace search-attributes rename \\\n    --request-id <request_id> \\\n    --existing-name <value> \\\n    --new-name <value>\n```\n\n----------------------------------------\n\nTITLE: Querying Workflows with Default Search Attributes - Temporal CLI - shell\nDESCRIPTION: Demonstrates how to use the 'temporal workflow list' command with a default Search Attribute in Temporal CLI. This example is valid when advanced Visibility is not enabled, showing a simple equality query on a single default attribute. No dependencies are required other than the Temporal CLI being installed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/search-attributes.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --query \"ExecutionStatus = 'Completed'\"\n```\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --query \"WorkflowType = 'YourWorkflow'\"\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Temporal CLI using API Key\nDESCRIPTION: Example of using an API key to authenticate with Temporal Cloud via the CLI. Includes setting environment variables and required command-line options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport TEMPORAL_API_KEY=<key-secret>\ntemporal workflow list \\\n    --address <endpoint> \\\n    --namespace <namespace_id>.<account_id> \\\n    --grpc-meta \"temporal-namespace=<namespace_id>.<account_id>\" \\\n    --tls\n```\n\n----------------------------------------\n\nTITLE: Promoting an Existing Build ID in Go (Deprecated)\nDESCRIPTION: This snippet shows how to promote an existing Build ID to be the default within its compatibility set. This changes which worker version will be used for new workflow executions without adding any new Build IDs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDPromoteIDWithinSet{\n      BuildID: \"some-existing-build-id\",\n   },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Datacenter Redirection Policy in YAML\nDESCRIPTION: Sets up the Frontend datacenter API redirection policy for cross-DC replication. This example configures the 'selected-apis-forwarding' policy, which forwards specific APIs to the active Cluster based on the Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n#...\ndcRedirectionPolicy:\n  policy: 'selected-apis-forwarding'\n#...\n```\n\n----------------------------------------\n\nTITLE: Configuring Dual Visibility with Cassandra Primary and MySQL Secondary Store\nDESCRIPTION: YAML configuration example showing how to set up Dual Visibility with Cassandra as the primary Visibility store and MySQL as the secondary Visibility store. It includes database connection details for both stores.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\npersistence:\n  visibilityStore: cass-visibility # This is your primary Visibility store\n  secondaryVisibilityStore: mysql-visibility # This is your secondary Visibility store\n  datastores:\n    cass-visibility:\n      cassandra:\n        hosts: '127.0.0.1'\n        keyspace: 'temporal_primary_visibility'\n    mysql-visibility:\n      sql:\n        pluginName: 'mysql8' # Verify supported versions. Use a version of SQL that supports advanced Visibility.\n        databaseName: 'temporal_secondary_visibility'\n        connectAddr: '127.0.0.1:3306'\n        connectProtocol: 'tcp'\n        user: 'temporal'\n        password: 'temporal'\n```\n\n----------------------------------------\n\nTITLE: Canceling Workflow Execution with tctl (Bash)\nDESCRIPTION: Examples demonstrating how to cancel a specific Workflow Execution using `tctl workflow cancel`. The command can target a Workflow by its Workflow ID or a specific Run ID. Canceling requests a graceful shutdown, allowing cleanup logic within the Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow cancel --workflow_id <id>\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow cancel --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: Setting Global Dynamic Config Values in YAML\nDESCRIPTION: This YAML snippet shows how to set a global (unconstrained) value for a dynamic configuration key in a Temporal Cluster. The example uses 'frontend.globalNamespaceRPS' to set a cluster-wide RPC rate limit applied per namespace. No explicit dependencies except for being loaded as a Temporal dynamic config file. The 'value' parameter specifies the global rate limit. The input is a YAML config file; the output is the effective global setting for all namespaces.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/dynamic-configuration.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nfrontend.globalNamespaceRPS: # Total per-Namespace RPC rate limit applied across the Cluster.\n  - value: 5000\n```\n\n----------------------------------------\n\nTITLE: Checking Workflow Status with Circuit Breaker Information Using Temporal CLI\nDESCRIPTION: This command uses the Temporal CLI to describe a workflow execution, which shows details about pending Nexus operations including circuit breaker status. The output includes information about blocked operations, failure reasons, and circuit breaker state.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/nexus-operations.mdx#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ntemporal workflow describe -w my-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server with Custom Metrics Reporter in Go\nDESCRIPTION: Shows how to use temporal.WithCustomMetricsReporter(myReporter) to set a custom tally metric reporter for Temporal Server metrics. The myReporter variable must implement the expected metrics interface. Inputs include the custom reporter; output is a server instance reporting metrics through the specialized channel. Useful for integrating with external monitoring endpoints like Datadog.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.WithCustomMetricsReporter(myReporter),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Using WorkflowInit Annotation with Workflow Input\nDESCRIPTION: A complete example showing how to use the @WorkflowInit annotation on a constructor to process Workflow input before any handlers execute. This ensures handlers can access processed input data even before the main Workflow method runs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_17\n\nLANGUAGE: java\nCODE:\n```\npublic class GreetingExample {\n    @WorkflowInterface\n    public interface GreetingWorkflow {\n        @WorkflowMethod\n        String getGreeting(String input);\n\n        @UpdateMethod\n        boolean checkTitleValidity();\n    }\n\n    public static class GreetingWorkflowImpl implements GreetingWorkflow {\n        private final String nameWithTitle;\n        private boolean titleHasBeenChecked;\n        ...\n        // Note the annotation is on a public constructor\n        @WorkflowInit\n        public GreetingWorkflowImpl(String input) {\n          this.nameWithTitle = \"Sir \" + input;\n          this.titleHasBeenChecked = false;\n        }\n\n        @Override\n        public String getGreeting(String input) {\n          Workflow.await(() -> titleHasBeenChecked)\n          return \"Hello \" + nameWithTitle;\n        }\n\n        @Override\n        public boolean checkTitleValidity() {\n          // 👉 The handler is now guaranteed to see the workflow input\n          // after it has been processed by the constructor.\n          boolean isValid = activity.checkTitleValidity(nameWithTitle);\n          titleHasBeenChecked = true;\n          return isValid;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Build ID to Existing Compatibility Set in Go (Deprecated)\nDESCRIPTION: This example demonstrates how to add a new Build ID to an existing compatibility set. It adds the new Build ID to the set containing the specified existing Build ID and marks it as the new default for that set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/worker-versioning-legacy.mdx#2025-04-23_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// ...\nerr := client.UpdateWorkerBuildIdCompatibility(ctx, &client.UpdateWorkerBuildIdCompatibilityOptions{\n   TaskQueue: \"your_task_queue_name\",\n   Operation: &client.BuildIDOpAddNewCompatibleVersion{\n      BuildID:                   \"deadbeef\",\n      ExistingCompatibleBuildId: \"some-existing-build-id\",\n   },\n})\n```\n\n----------------------------------------\n\nTITLE: Replay-Mode Verification for Temporal Worker Deployments (Python)\nDESCRIPTION: This snippet implements replay verification logic for a Temporal Worker using Python. If the mode is 'verify', it queries for recent Workflow executions from the given Task Queue, fetches their histories, and runs these through a Replayer instance to validate determinism and code compatibility. The code requires the temporalio Python SDK, Workflow/Activity definitions, and access to a running Temporal service. Failure in any replayed Workflow raises an exception, while successful completion suggests safe deployment is possible. Inputs include the designated verification period and Task Queue name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/safe-deployments.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\n    if args.mode == 'verify':\n        start_time = (datetime.now() - timedelta(hours=10)).isoformat(timespec='seconds')\n        workflows = client.list_workflows(\n\t        f\"TaskQueue={task_queue} and StartTime > '{start_time}'\",\n\t      limit = 100)\n        histories = workflows.map_histories()\n        replayer = Replayer(\n            workflows=my_workflows,\n            activities=my_activities,\n        )\n        await replayer.replay_workflows(histories)\n        return\n\n```\n\n----------------------------------------\n\nTITLE: Setting Server Port (port) for Temporal Web UI (YAML)\nDESCRIPTION: Specifies the network port on which the Temporal Web UI Server will listen for incoming HTTP requests and serve the UI and its APIs. Defaults to 8080.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nport: 8080\n```\n\n----------------------------------------\n\nTITLE: Describing Workflow Execution by ID with tctl (Bash)\nDESCRIPTION: Shows information about a specific Workflow Execution using the shortcut command `tctl workflow describeid`. Requires the Workflow ID as a positional argument and optionally accepts a Run ID. Supports modifiers like `--print_raw` for raw data output and `--reset_points_only` to list eligible reset events.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Example printing raw properties for a specific Workflow ID and Run ID\ntctl workflow describeid <workflow_id> <id> --print_raw\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example showing reset points for a specific Workflow ID (latest run)\ntctl workflow describeid <workflow_id> --reset_points_only\n```\n\n----------------------------------------\n\nTITLE: Setting Namespace Environment Variable (macOS/Linux)\nDESCRIPTION: Exports an environment variable named `NAMESPACE_NAME` and sets its value to the user's specific Temporal Cloud namespace name (replacing `your-namespace`). This variable is used in subsequent `certstrap` commands to set the common name for the end-entity certificate on macOS or Linux systems.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_3\n\nLANGUAGE: command\nCODE:\n```\nexport NAMESPACE_NAME=your-namespace\n```\n\n----------------------------------------\n\nTITLE: Querying Replication Lag P99 with Prometheus - PromQL\nDESCRIPTION: This PromQL snippet computes the 99th percentile replication lag for Temporal Cloud namespaces, crucial in high-availability/failover scenarios. It uses the temporal_cloud_v0_replication_lag_bucket metric with histogram_quantile and sum(rate(...)) by temporal_namespace and le, reflecting per-bucket lag statistics. Prometheus must be set up to gather these histograms. The query returns time series data for the P99 replication lag by namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/service-health.mdx#2025-04-23_snippet_2\n\nLANGUAGE: promql\nCODE:\n```\nhistogram_quantile(0.99, sum(rate(temporal_cloud_v0_replication_lag_bucket[$__rate_interval])) by (temporal_namespace, le))\n```\n\n----------------------------------------\n\nTITLE: Upgrading Cassandra Visibility Schema using temporal-cassandra-tool in Bash\nDESCRIPTION: This command utilizes the `temporal-cassandra-tool` to update the visibility schema for a Temporal Server instance using Cassandra. It connects securely via TLS, authenticates, targets the `temporal_visibility` keyspace, and applies the relevant schema updates from the specified visibility schema directory. The command includes parameters for TLS configuration, credentials, endpoint, keyspace, and timeout.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal_v1.2.1 $ temporal-cassandra-tool \\\n   --tls \\\n   --tls-ca-file <...> \\\n   --user <cassandra-user> \\\n   --password <cassandra-password> \\\n   --endpoint <cassandra.example.com> \\\n   --keyspace temporal_visibility \\\n   --timeout 120 \\\n   update \\\n   --schema-dir ./schema/cassandra/visibility/versioned\n```\n\n----------------------------------------\n\nTITLE: Setting maximum field length in tctl workflow run command\nDESCRIPTION: Command that specifies the maximum length for each attribute field, with a default of 0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --max_field_length <length>\n```\n\n----------------------------------------\n\nTITLE: Creating Nexus Endpoint for Request Routing\nDESCRIPTION: Command to create a Nexus Endpoint that routes requests from the caller to the handler namespace. It specifies the endpoint name, target namespace, and task queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint create \\\n  --name my-nexus-endpoint-name \\\n  --target-namespace my-target-namespace \\\n  --target-task-queue my-handler-task-queue\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow Stack Traces Using Temporal CLI (shell)\nDESCRIPTION: Demonstrates how to use the Temporal CLI to query a Workflow Execution's call stack for troubleshooting purposes, relying on the 'temporal workflow stack' command and optionally providing connection/auth flags. Useful in production debugging scenarios where complete thread stack information is needed. Requires a running Temporal server, correct Workflow ID, and appropriate credentials as specified by the provided options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow stack [flags]\n```\n\n----------------------------------------\n\nTITLE: Overriding Asynchronous Nexus Operation in Go\nDESCRIPTION: This example shows how to override an asynchronous Nexus operation in a Temporal Workflow test. It creates a custom Workflow-based Nexus operation, registers it with a service, and executes a test Workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) Test_SimpleWorkflow_NexusSyncOperation() {\n        SampleHandlerWorkflow := func(_ workflow.Context, input SampleInput) (SampleOutput, error) {\n                // Custom logic here.\n                return SampleOutput{}, nil\n        }\n        SampleOperation := nexus.NewWorkflowRunOperation(\n                \"sample-operation\",\n                SampleHandlerWorkflow,\n                func(ctx context.Context, input SampleInput, options nexus.StartOperationOptions) (client.StartWorkflowOptions, error) {\n                        // Custom logic to build client.StartWorkflowOptions.\n                        return client.StartWorkflowOptions{}, nil\n                },\n        )\n\n        service := nexus.NewService(\"sample-service\")\n        s.NoError(service.Register(SampleOperation))\n        env.RegisterNexusService(service)\n        s.env.ExecuteWorkflow(SimpleWorkflow, \"test_nexus_operation\")\n\n        s.True(s.env.IsWorkflowCompleted())\n        s.NoError(s.env.GetWorkflowError())\n}\n```\n\n----------------------------------------\n\nTITLE: Updating an S3 Export Sink Configuration with TCLD CLI - Bash\nDESCRIPTION: Modifies settings of an existing S3 export sink within a Temporal Cloud Namespace using `tcld namespace export s3 update`. Required are `--namespace` and `--sink-name`; `--enabled` specifies activation state. This is used to enable, disable, or change destination/IAM roles for export sinks. Inputs include namespace, sink name, and desired enabled state; output is success/error as reported by the CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace export s3 update \\\n    --namespace <namespace_id> \\\n    --sink-name <sink_name> \\\n    --enabled true\n```\n\n----------------------------------------\n\nTITLE: Describing a Namespace with Temporal CLI\nDESCRIPTION: Retrieves and displays the description of a namespace using its ID with the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace describe --namespace-id=meaningful-business-id\n```\n\n----------------------------------------\n\nTITLE: Sending Signal to Update Workflow Greeting\nDESCRIPTION: Commands demonstrating how to send signals to update greeting values in a running Workflow\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_59\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow signal --workflow_id \"HelloSignal\" --name \"updateGreeting\" --input \\\"Hi\\\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to Temporal Cloud using Temporal CLI with Certificates (Shell)\nDESCRIPTION: Shows the command structure for using the Temporal CLI to interact with a Temporal Cloud Namespace secured by mTLS. It requires specifying paths to the server CA certificate (`--tls-ca-path`), the client certificate (`--tls-cert-path`), the client's private key (`--tls-key-path`), and potentially overriding the target TLS server name (`--tls-server-name`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ntemporal <command> <subcommand> \\\n    --tls-ca-path <Path to server CA certificate> \\\n    --tls-cert-path <Path to x509 certificate> \\\n    --tls-key-path <Path to private certificate key> \\\n    --tls-server-name <Override for target TLS server name>\n```\n\n----------------------------------------\n\nTITLE: Importing Certificate Filters with JSON Input in Temporal Cloud CLI\nDESCRIPTION: Command to import certificate filters using inline JSON input instead of a file. This allows directly specifying filters in the command line.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters import \\\n    --certificate-filter-input <json>\n```\n\n----------------------------------------\n\nTITLE: Filtering Workflows by Type using Temporal CLI and jq in Shell\nDESCRIPTION: This command filters workflows based on their type using the Temporal CLI and jq for JSON processing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --fields long --output json | jq '.[].type.name'\n```\n\n----------------------------------------\n\nTITLE: Deleting Environment Property with Temporal CLI\nDESCRIPTION: Shows the basic syntax for deleting an environment or a specific environmental property using the 'temporal env delete' command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env delete [environment or property]\n```\n\n----------------------------------------\n\nTITLE: Example Output of tctl cluster get-search-attributes\nDESCRIPTION: Shows a sample output format for the `tctl cluster get-search-attributes` command. It displays a table listing the names and corresponding data types (Keyword, Int, Bool, Datetime, Double, String) of the available Search Attributes within the Temporal Cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/cluster.mdx#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n+-----------------------+----------+\n|         NAME          |   TYPE   |\n+-----------------------+----------+\n| BinaryChecksums       | Keyword  |\n| CloseTime             | Int      |\n| CustomBoolField       | Bool     |\n| CustomDatetimeField   | Datetime |\n| CustomDoubleField     | Double   |\n| CustomIntField        | Int      |\n| CustomKeywordField    | Keyword  |\n| CustomNamespace       | Keyword  |\n| CustomStringField     | String   |\n| ExecutionStatus       | Int      |\n| ExecutionTime         | Int      |\n| Operator              | Keyword  |\n| RunId                 | Keyword  |\n| StartTime             | Int      |\n| TaskQueue             | Keyword  |\n| TemporalChangeVersion | Keyword  |\n| WorkflowId            | Keyword  |\n| WorkflowType          | Keyword  |\n+-----------------------+----------+\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Endpoint in Temporal Service with Docker Compose (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to configure Temporal's docker-compose service to expose a Prometheus endpoint by setting the PROMETHEUS_ENDPOINT environment variable and mapping ports. It is used to make Temporal Service metrics available for Prometheus metric scraping, with port 8000 exposed specifically for this purpose. Dependencies include Docker Compose, a working local setup for Temporal and its related services (PostgreSQL, Elasticsearch), and proper network/volume configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3.5'\\nservices:\\n  #...\\n\\n  temporal:\\n    container_name: temporal\\n    depends_on:\\n      - postgresql\\n      - elasticsearch\\n    environment:\\n      - DB=postgresql\\n      - DB_PORT=5432\\n      - POSTGRES_USER=temporal\\n      - POSTGRES_PWD=temporal\\n      - POSTGRES_SEEDS=postgresql\\n      - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development-sql.yaml\\n      - ENABLE_ES=true\\n      - ES_SEEDS=elasticsearch\\n      - ES_VERSION=v7\\n      - PROMETHEUS_ENDPOINT=0.0.0.0:8000 #expose a port for Prometheus\\n    image: temporalio/auto-setup:${TEMPORAL_VERSION}\\n    networks:\\n      - temporal-network\\n    ports:\\n      - 7233:7233\\n      - 8000:8000 #add your port\\n    volumes:\\n      - ./dynamicconfig:/etc/temporal/config/dynamicconfig\\n#...\n```\n\n----------------------------------------\n\nTITLE: Clearing Certificate Filters with Request ID in Temporal Cloud CLI\nDESCRIPTION: Command to clear all certificate filters with a specific request identifier for the asynchronous operation tracking.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace certificate-filters clear\n    --request-id <request_id>\n```\n\n----------------------------------------\n\nTITLE: Describing a Namespace in Go\nDESCRIPTION: Retrieves information and configuration details for a specific registered Namespace using the DescribeNamespace API.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/namespaces.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n//...\n  client, err := client.NewNamespaceClient(client.Options{})\n  //...\n  client.Describe(context.Background(), \"default\")\n//...\n```\n\n----------------------------------------\n\nTITLE: Customizing Namespace-Level Dynamic Config in YAML\nDESCRIPTION: This YAML snippet demonstrates how to set both a default and namespace-specific values for a dynamic configuration key ('frontend.persistenceNamespaceMaxQPS') in a Temporal Cluster. Each list entry can have its own constraints, targeting namespaces as required. The snippet requires no special dependencies and must be placed in the correct Temporal configuration path. Use the 'namespace' key in constraints to target specific Temporal Namespaces. Default (empty {}) constraints apply globally unless overridden. The input is a YAML-formatted config file and the output is tailored QPS limits per namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/dynamic-configuration.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nfrontend.persistenceNamespaceMaxQPS: # Rate limit on the number of queries the Frontend sends to the Persistence store.\n  - constraints: {} # Sets default value that applies to all Namespaces\n    value: 2000 # The default value for this key is 0.\n  - constraints: { namespace: 'namespace1' } # Sets limit on number of queries that can be sent from \"namespace1\" Namespace to the Persistence store.\n    value: 4000\n  - constraints: { namespace: 'namespace2' }\n    value: 1000\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate with Organization using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the organization name via the `--organization` modifier. This certificate will be signed by a CA specified in other modifiers. Replace `<value>` with the actual organization name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --organization <value>\n```\n\n----------------------------------------\n\nTITLE: Listing Workflows in Production Environment using Temporal CLI in Shell\nDESCRIPTION: This command lists workflows in the production environment using the Temporal CLI with the 'prod' environment settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --env prod\n```\n\n----------------------------------------\n\nTITLE: Enabling or Disabling an API Key with tcld CLI – Command\nDESCRIPTION: This snippet shows how to enable or disable an existing API key via the Temporal Cloud CLI. After authenticating with `tcld login`, users can use `tcld apikey disable --id <api-key-id>` to disable or `tcld apikey enable --id <api-key-id>` to re-enable a key. Required: tcld CLI tool, user permissions for the relevant key. Parameter: the API key ID to act upon. These commands do not output the API key secret, only trigger a state change.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_1\n\nLANGUAGE: command\nCODE:\n```\ntcld login\ntcld apikey disable --id <api-key-id>\ntcld apikey enable --id <api-key-id>\n```\n\n----------------------------------------\n\nTITLE: Batch Resetting Workflows from Input File in Bash\nDESCRIPTION: Example of using the tctl workflow reset-batch command with the input_file modifier. This allows resetting multiple Workflow Executions specified in an input file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset-batch --input_file <filename>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dynamic Configuration Client in YAML\nDESCRIPTION: Configures the file-based dynamic configuration client for the Temporal Cluster. This example specifies the filepath for the dynamic configuration YAML file and sets a poll interval of 10 seconds for checking updates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\ndynamicConfigClient:\n  filepath: 'config/dynamicconfig/development-cass.yaml'\n  pollInterval: '10s'\n```\n\n----------------------------------------\n\nTITLE: Printing specific event details in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that displays details of a specific event by ID. Default is 0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --event_id <id>\n```\n\n----------------------------------------\n\nTITLE: Assigning Build ID and Enabling Legacy Worker Versioning in Python Worker\nDESCRIPTION: Configures a Temporal Worker in Python by assigning a `build_id` (e.g., from an environment variable) and explicitly enabling the deprecated Worker Versioning feature by setting `use_worker_versioning=True`. This setup requires subsequent configuration of assignment rules before the Worker can process tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# ...\nworker = Worker(\n  task_queue=\"your_task_queue_name\",\n  build_id=build_id,\n  use_worker_versioning=True,\n  # ... register workflows & activities, etc\n)\n# ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Settings with Membership and Prometheus Metrics in YAML\nDESCRIPTION: This YAML snippet demonstrates a minimal configuration for the `global` section in a Temporal Cluster's `development.yaml` file. It sets the `broadcastAddress` for cluster membership communication using the gossip protocol and configures Prometheus as the metrics provider, specifying its framework (`tally`) and listening address for scraping.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nglobal:\n  membership:\n    broadcastAddress: '127.0.0.1'\n  metrics:\n    prometheus:\n      framework: 'tally'\n      listenAddress: '127.0.0.1:8000'\n```\n\n----------------------------------------\n\nTITLE: Signaling Workflow Executions with Temporal CLI\nDESCRIPTION: The 'temporal workflow signal' command sends a Signal to a Workflow Execution identified by Workflow ID or List Filter. It allows customization of the signal's behavior and input.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Hiding Server Logs (hideLogs) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to control whether the Temporal Web UI server prints logs to the console. Set to `true` to disable logging output, defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nhideLogs: true\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow with Reapply Type in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the reset_reapply_type modifier. This allows specifying the types of events to reapply after the reset point.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --reset_reapply_type <value>\n```\n\n----------------------------------------\n\nTITLE: Installing the Temporal Go SDK\nDESCRIPTION: Command to add the Temporal Go SDK to your project using the Go package manager.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo get go.temporal.io/sdk\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Cloud User via tcld CLI - Command\nDESCRIPTION: Demonstrates how to delete a user in Temporal Cloud via the tcld CLI using the --user-email modifier. Requires tcld to be installed/configured and authenticated. The --user-email flag specifies the email address of the user to remove; the output and server response will depend on the existence of the user and permissions of the requester.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ntcld user delete --user-email <test@example.com>\n```\n\n----------------------------------------\n\nTITLE: Upgrading MySQL v8+ Visibility Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command is tailored for upgrading the Temporal visibility schema on MySQL version 8.0.17 or later using `temporal-sql-tool`. It uses the `mysql8` plugin (`--pl mysql8`) to support advanced Visibility features available with Temporal Server v1.20. The command connects via TLS, targets the `temporal_visibility` database, and applies updates from the MySQL v8 schema directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl mysql8 --db temporal_visibility update-schema -d ./schema/mysql/v8/visibility/versioned.\n```\n\n----------------------------------------\n\nTITLE: Displaying tctl Namespace Help\nDESCRIPTION: This command displays help specifically for the 'namespace' subcommand group in tctl, listing available operations related to Temporal Namespaces.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ntctl namespace -h\n```\n\n----------------------------------------\n\nTITLE: Querying Workflows and Nexus Events using Temporal CLI - Shell\nDESCRIPTION: Demonstrates use of the Temporal CLI to inspect running workflows and Nexus operation events. The 'workflow describe' command outputs workflow metadata by ID, and 'workflow show' displays detailed history, including NexusOperation events. Requires installed Temporal CLI and access credentials. Useful for debugging and observability in distributed workflow systems, with different event sets depending on synchronous vs. asynchronous operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow describe -w <ID>\n```\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow show -w <ID>\n```\n\n----------------------------------------\n\nTITLE: Failing a tctl Activity using Run ID (Bash)\nDESCRIPTION: This command shows how to fail a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Run ID with the `--run_id` (or `-r`) modifier. Replace `<id>` with the actual Run ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity fail --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: Configuring High Availability with API Key Authentication\nDESCRIPTION: This command updates high availability settings using API key authentication. It demonstrates how to include API credentials when configuring auto-failover settings for a Temporal Cloud Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_66\n\nLANGUAGE: bash\nCODE:\n```\ntcld --api-key <your_api_key> \\\n    namespace update-high-availability \\\n    --namespace <namespace_id>.<account_id> \\\n    --disable-auto-failover=true\n```\n\n----------------------------------------\n\nTITLE: Executing Temporal Operator Cluster List Command\nDESCRIPTION: Lists all remote Clusters on the system using the Temporal CLI. This command supports various options to customize output and behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator cluster list\n```\n\n----------------------------------------\n\nTITLE: Setting DeadlockDetectionTimeout Worker Option in Go\nDESCRIPTION: Sets the maximum time that a Workflow Task can execute for. The timeout is specified in seconds and helps detect potential deadlocks in workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_46\n\nLANGUAGE: go\nCODE:\n```\n// ...\nworkerOptions := worker.Options{\n    DeadlockDetectionTimeout: time.Second(1),\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Using SQL-like query in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that specifies an SQL-like query of Search Attributes. Can be shortened to -q.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --query <value>\n```\n\n----------------------------------------\n\nTITLE: Adding Third Event to Version History in Temporal Workflow\nDESCRIPTION: This snippet illustrates the version history after adding a third event with version 1. The table shows how multiple events can be associated with the same version number.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               |                 |         |\n| 3        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Sending a Dynamic Signal (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow signal` command to send a signal to a specific, running workflow instance identified by `<your workflow id>`. The signal is named `unregister_signal` (which might be handled dynamically), carries the string \"Dynamic Signal argument 1\" as input payload, and targets the `default` namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow signal \\\n --workflow-id <your workflow id> \\\n --namespace default \\\n --name \"unregister_signal\" \\\n --input '\"Dynamic Signal argument 1\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring BackgroundActivityContext for Temporal Worker in Go (Not Recommended)\nDESCRIPTION: Sets a base `context.Context` that will be available to all Activity Task Executions run by this Worker. This was previously used for passing dependencies like database connections but is **not recommended**. The preferred method is using struct-based dependency injection for Activities. The type is `context.Context`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_39\n\nLANGUAGE: go\nCODE:\n```\n// ...\nctx := context.WithValue(context.Background(), \"your-key\", \"your-value\")\nworkerOptions := worker.Options{\n    BackgroundActivityContext: ctx,\n  // ...\n}\nw := worker.New(c, \"your_task_queue_name\", workerOptions)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Listing tctl Batch Jobs with Pagination (Bash)\nDESCRIPTION: Retrieves a list of existing `tctl` batch jobs. The `--pagesize` modifier controls the maximum number of jobs displayed per page, with a default of 30.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch list --pagesize <value>\n```\n\n----------------------------------------\n\nTITLE: Upgrading PostgreSQL Default Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command employs the `temporal-sql-tool` to upgrade the default persistence schema for a Temporal Server using PostgreSQL (specifically targeting v9.6 schema compatibility). It connects to the PostgreSQL instance using TLS with host verification, provides client certificate/key paths, specifies connection details (endpoint, port, user, password), indicates the `postgres` plugin, targets the `temporal` database, and applies updates from the versioned schema directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres --db temporal update-schema -d ./schema/postgresql/v96/temporal/versioned\n```\n\n----------------------------------------\n\nTITLE: Removing Cluster Search Attribute Metadata with tctl (Bash)\nDESCRIPTION: This command utilizes `tctl admin cluster remove-search-attributes` to remove the metadata of a custom Search Attribute from a Temporal Cluster's configuration. The `--name` flag specifies the key of the attribute to remove. This operation only affects the Cluster's metadata and does not alter the underlying Elasticsearch index schema; the attribute remains in the index and can be re-added later with the same type. Default Search Attributes cannot be removed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/admin.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl admin cluster remove-search-attributes --name <SearchAttributeKey>\n```\n\n----------------------------------------\n\nTITLE: Enabling Server-Side TLS for Frontend Service in YAML\nDESCRIPTION: This YAML configuration snippet enables server-side TLS (HTTPS) for communication between SDK clients and the Temporal Frontend Service. It specifies the paths to the server's certificate (`certFile`) and private key (`keyFile`) within the `global.tls.frontend.server` section and sets the expected server name (`serverName`) in the `client` section for certificate validation by the SDK client.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n```\n\n----------------------------------------\n\nTITLE: Generating End-Entity Certificate Specifying Key File using tcld\nDESCRIPTION: This command generates an end-entity (leaf) certificate using `tcld`, specifying the output path for the leaf certificate's private key `.key` file using the `--key-file` modifier. Replace `<path>` with the desired file path for the leaf private key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates end-entity-certificate --key-file <path>\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace with Temporal CLI\nDESCRIPTION: Creates a new namespace using the Temporal CLI. This command allows specifying the cluster, global status, retention period, and visibility archival settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace create --retention=RetentionMyWorkflow --visibility-archival-state=\"enabled\" --visibility-uri=\"some-uri\"\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in Java SDK\nDESCRIPTION: Example of updating an API key for an existing Temporal client connection in Java SDK. Shows how to update the key at a per-call level.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_12\n\nLANGUAGE: java\nCODE:\n```\nString myKey = <APIKey>;\nWorkflowServiceStubsOptions stubOptions =\n    WorkflowServiceStubsOptions.newBuilder()\n        .addApiKey(() -> myKey)\n        .build();\n\n// Just update by replacing, this must be done in a thread safe way\nmyKey = \"Bearer \" + <new APIKey>;\n```\n\n----------------------------------------\n\nTITLE: Updating Owner Email for a Namespace using tctl\nDESCRIPTION: Updates the owner's email address for an existing Namespace using the `--owner_email <value>` modifier with `tctl namespace update`. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --owner_email <value>\n```\n\n----------------------------------------\n\nTITLE: Enabling Server-Side TLS for Frontend with Custom Root CA in YAML\nDESCRIPTION: This YAML snippet demonstrates configuring server-side TLS for the Temporal Frontend Service while also explicitly providing the Root CA certificate files (`rootCaFiles`) needed for client validation. This is necessary when the Certificate Authority that signed the server's certificate is not automatically trusted by the client hosts (SDKs). It includes paths for the server's certificate (`certFile`), key (`keyFile`), the expected server name (`serverName`), and the custom Root CA file(s).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nglobal:\n  tls:\n    frontend:\n      server:\n        certFile: /path/to/cert/file\n        keyFile: /path/to/key/file\n      client:\n        serverName: dnsSanInFrontendCertificate\n        rootCaFiles:\n          - /path/to/frontend/server/CA/files\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Schedule using tctl (Shell)\nDESCRIPTION: Deletes a specific Temporal Schedule identified by its ID (`--schedule-id`). This action does not affect any Workflow Executions already started by the schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl schedule delete --schedule-id 'your-schedule-id'\n```\n\n----------------------------------------\n\nTITLE: Querying Schedule Missed Catchup Window Rate - PromQL\nDESCRIPTION: PromQL query to measure the rate of schedule executions that missed their catchup window within a 5-minute interval. Useful for monitoring system outages affecting scheduled workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_18\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(schedule_missed_catchup_window{namespace=\"$namespace\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Defining Temporal Schedule Cron String Format (Markdown)\nDESCRIPTION: This markdown code block displays the accepted cron string format for creating Workflow Schedules in Temporal. It visually documents the meaning and allowed ranges for each field (minute, hour, day of month, month, day of week), following a standard cron expression structure. The code block is intended to aid users in configuring schedule parameters when using the Web UI or SDKs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/web-ui.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Signal Job (Bash)\nDESCRIPTION: Initiates a `tctl` batch job specifically to send a signal to multiple Workflow Executions. It requires specifying the batch type as `signal` using `--batch_type` and the name of the signal using `--signal_name`. The `--query` modifier identifies the target workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --batch_type signal --signal_name <name>\n```\n\n----------------------------------------\n\nTITLE: Bundling Workflow Code for Production\nDESCRIPTION: Shows how to pre-bundle Workflow code for improved Worker startup time in production. This script uses bundleWorkflowCode to generate a bundle file that can be loaded by Workers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bundleWorkflowCode } from '@temporalio/worker';\nimport { writeFile } from 'fs/promises';\nimport path from 'path';\n\nasync function bundle() {\n  const { code } = await bundleWorkflowCode({\n    workflowsPath: require.resolve('../workflows'),\n  });\n  const codePath = path.join(__dirname, '../../workflow-bundle.js');\n\n  await writeFile(codePath, code);\n  console.log(`Bundle written to ${codePath}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Logging from a Workflow in .NET SDK\nDESCRIPTION: This example shows how to log from a Workflow using the Workflow.Logger property, which is an instance of .NET's ILogger. It demonstrates logging an information message with a parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/observability.mdx#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nWorkflow.Logger.LogInformation(\"Given name: {Name}\", name);\n```\n\n----------------------------------------\n\nTITLE: Example Output of Failed Nexus Operation via Temporal CLI\nDESCRIPTION: Illustrates the output of the `temporal workflow describe` command for a Workflow with a pending Nexus Operation in a 'BackingOff' state after multiple failed attempts. It shows key fields like state, attempt count, next retry time, and the last attempt's failure details, including the error message and associated application failure info. This example demonstrates how a retryable failure in a Nexus handler surfaces in the Workflow description.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/failures.mdx#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ntemporal workflow describe -w my-workflow-id\n...\nPending Nexus Operations: 1\n\n  Endpoint                 myendpoint\n  Service                  my-hello-service\n  Operation                echo\n  OperationToken\n  State                    BackingOff\n  Attempt                  6\n  ScheduleToCloseTimeout   0s\n  NextAttemptScheduleTime  20 seconds from now\n  LastAttemptCompleteTime  11 seconds ago\n  LastAttemptFailure       {\"message\":\"unexpected response status: \\\"500 Internal Server Error\\\": internal error\",\"applicationFailureInfo\":{}}\n```\n\n----------------------------------------\n\nTITLE: Terminating a Workflow Execution with Workflow ID\nDESCRIPTION: Shows how to terminate a Workflow Execution using the required --workflow_id modifier with the tctl workflow terminate command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_64\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow terminate --workflow_id <id>\n```\n\n----------------------------------------\n\nTITLE: Configuring Feedback URL (feedbackUrl) in Temporal Web UI (YAML)\nDESCRIPTION: Specifies the URL that users are directed to when clicking the 'Feedback' button in the Temporal Web UI. Defaults to the GitHub issues page for the UI repository if not explicitly set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nfeedbackUrl: https://github.com/temporalio/ui/issues/new/choose\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates with Request ID\nDESCRIPTION: This command sets client CA certificates with a specified request identifier for tracking the asynchronous operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --request-id <request_id> \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Cloning Temporal API Definitions Repository using Shell\nDESCRIPTION: Clones the `temporalio/api` repository containing the protobuf definitions for the Temporal gRPC API and changes the current directory into the cloned repository. This step is necessary for manually interacting with the gRPC API using tools like `evans` or BloomRPC.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/server-frontend-api-reference.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/temporalio/api.git\ncd api\n```\n\n----------------------------------------\n\nTITLE: Setting Up Codec Server with Access Token Authorization\nDESCRIPTION: This command configures a codec server with user access token authorization. It enables passing the user's access token with requests to the remote endpoint by setting the --pass-access-token modifier.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_63\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-codec-server \\\n    --namespace <namespace_id> \\\n    --endpoint <https_url> \\\n    --pass-access-token <bool>\n```\n\n----------------------------------------\n\nTITLE: Describing Temporal Namespace with TLS/MTLS - Command\nDESCRIPTION: This snippet uses the Temporal CLI to describe a namespace, connecting securely via TLS or mTLS. Required dependencies include the temporal CLI and access to the necessary certificate and key files. Replace <namespace_id>.<account_id>, <namespace_grpc_endpoint>, <path-to-mTLS-pem-file>, and <path-to-mTLS-key-file> with appropriate values; the command returns detailed metadata about the Temporal namespace, helping administrators verify secure server access.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/last-connection-error.mdx#2025-04-23_snippet_2\n\nLANGUAGE: command\nCODE:\n```\ntemporal namespace describe \\\n    --namespace <namespace_id>.<account_id> \\\n    --address <namespace_grpc_endpoint> \\\n    --tls-cert-path <path-to-mTLS-pem-file> \\\n    --tls-key-path <path-to-mTLS-key-file>\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow with Bad Binary Checksum in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the reset_bad_binary_checksum modifier. This is used when resetting to the point where a bad binary was used.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --reset_bad_binary_checksum <value>\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow in PHP\nDESCRIPTION: This snippet shows the implementation of a Workflow interface in PHP. It defines a class that implements the previously defined interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-definition.mdx#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\nclass YourBasicWorkflowImpl implements YourBasicWorkflow {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Audience URI for Okta SAML Integration\nDESCRIPTION: Shows a concrete example of a correctly formatted Audience URI (SP Entity ID) for Temporal Cloud SAML integration using Okta. This example uses 'f45a2' as the placeholder Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nurn:auth0:prod-tmprl:f45a2-saml\n```\n\n----------------------------------------\n\nTITLE: Displaying Temporal Development Server Help in Shell\nDESCRIPTION: This command displays the full list of options available for the Temporal development server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ntemporal server start-dev --help\n```\n\n----------------------------------------\n\nTITLE: Example Workflow Start Command with Custom ID\nDESCRIPTION: Complete example of starting a Workflow with custom ID, task queue, and other parameters\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_61\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow start  --workflow_id \"HelloTemporal1\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"Temporal\\\"\n```\n\n----------------------------------------\n\nTITLE: Running Hyperlink Checker\nDESCRIPTION: Command to check for broken links in the documentation using hyperlink tool.\nSOURCE: https://github.com/temporalio/documentation/blob/main/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn check-links\n```\n\n----------------------------------------\n\nTITLE: Illustrating Version History State at T=3 (Post-Failover)\nDESCRIPTION: This table represents the state at T=3 after a namespace failover has occurred, incrementing the active namespace version to 2. A new event (ID 4) is added with version 2. The version history now tracks the last event for version 1 (ID 3) and the last event for version 2 (ID 4).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Replaying Temporal Workflow History from JSON File via Python (Bash)\nDESCRIPTION: Executes the `replay_history_from_json.py` Python script using `poetry run`. This command replays a Workflow's execution history using a previously generated JSON file (e.g., created by `get_workflow_history.py`). This is useful for deterministic testing or debugging based on a recorded history.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/replay_your_workflow/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python replay_history_from_json.py\n```\n\n----------------------------------------\n\nTITLE: Defining NexusOperationTimedOut Event Fields in Markdown\nDESCRIPTION: This snippet defines the fields for the NexusOperationTimedOut event type using a Markdown table. It includes scheduled_event_id, failure, and request_id fields with their descriptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/events.mdx#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Field | Description |\n| :---- | :---- |\n| scheduled_event_id | The ID of the [NexusOperationScheduled](#nexusoperationscheduled)` event. Uniquely identifies this operation. |\n| failure | Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo. |\n| request_id | The request ID allocated at schedule time. |\n```\n\n----------------------------------------\n\nTITLE: Running tctl via Docker Compose\nDESCRIPTION: This command executes a tctl command within a running Docker container named 'temporal-admin-tools', typically part of a Temporal Server setup using Docker Compose. Replace 'YOUR COMMANDS HERE' with the actual tctl command and arguments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndocker exec temporal-admin-tools tctl YOUR COMMANDS HERE\n```\n\n----------------------------------------\n\nTITLE: Checking Individual Temporal Service Health using grpc-health-probe\nDESCRIPTION: Demonstrates using the `grpc-health-probe` tool to individually check the health of the Temporal Frontend, Matching, and History services. Each command targets a specific service's gRPC endpoint using the `-addr` flag (requiring replacement of placeholders like `frontendAddress:frontendPort` with actual values) and specifies the gRPC service name with the `-service` flag. This allows for granular health checks of core Temporal components.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/deadline-exceeded-error.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./grpc-health-probe -addr=frontendAddress:frontendPort -service=temporal.api.workflowservice.v1.WorkflowService\n\n./grpc-health-probe -addr=matchingAddress:matchingPort -service=temporal.api.workflowservice.v1.MatchingService\n\n./grpc-health-probe -addr=historyAddress:historyPort -service=temporal.api.workflowservice.v1.HistoryService\n```\n\n----------------------------------------\n\nTITLE: Enabling New Version Notifications (notifyOnNewVersion) in Temporal Web UI (YAML)\nDESCRIPTION: Controls whether the Temporal Web UI displays a notification when a newer version of the Temporal Server is available. Set to `true` to enable these notifications, defaults to `true`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nnotifyOnNewVersion: true\n```\n\n----------------------------------------\n\nTITLE: Setting Grafana Data Source for Prometheus - YAML\nDESCRIPTION: This snippet demonstrates a Grafana provisioning configuration to set Prometheus as the primary data source for Grafana dashboards. The configuration specifies data source name, type, connection URL (pointing to the Prometheus container), organization ID, and visibility parameters. It is meant to be placed in the Grafana provisioning directory (e.g., ./deployment/grafana/provisioning/datasources). This enables Grafana to display real-time metrics from Prometheus related to Temporal. There are no significant constraints besides ensuring the URL is resolvable from the Grafana container.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/monitoring.mdx#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: 1\n\ndatasources:\n - name: 'Temporal Prometheus'\n   type: 'prometheus'\n   org_id: 1\n   url: 'http://prometheus:9090'\n   is_default: true\n   version: 1\n   editable: true\n```\n\n----------------------------------------\n\nTITLE: Enabling Browser UI (enableUi) in Temporal Web UI (YAML)\nDESCRIPTION: Controls whether the Temporal Web UI frontend is served by the server. Setting it to `false` disables the UI but keeps the backend API available. Can also be controlled by the TEMPORAL_UI_ENABLED environment variable. Defaults to `true`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nenableUi: true\n```\n\n----------------------------------------\n\nTITLE: Setting History Archival URI during Namespace Registration with tctl\nDESCRIPTION: Specifies the URI for storing archived Workflow Execution History using the `--history_uri <uri>` modifier with `tctl namespace register`. This URI cannot be changed after Archival is enabled for the first time. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --history_uri <uri>\n```\n\n----------------------------------------\n\nTITLE: Running Handler Worker with API Key Authentication - Go CLI\nDESCRIPTION: This snippet explains how to start the handler worker process using API key authentication, suitable for Temporal Cloud deployments. The Go worker is executed in the 'handler' directory with flags for the region, cloud provider, target namespace, and API key. Requires an active Go environment, handler source files, and a valid API key for access. This approach offers secure key-based access without the need for certificates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_17\n\nLANGUAGE: go\nCODE:\n```\ncd handler\n\ngo run ./worker \\\n\t-target-host <region>.<cloud_provider>.api.temporal.io:7233 \\\n\t-namespace <your-target-namespace.account> \\\n\t-api-key <your-api-key>\n```\n\n----------------------------------------\n\nTITLE: Initializing Terraform Providers\nDESCRIPTION: Runs the `terraform init` command in the terminal. This command downloads and installs the necessary Terraform providers, such as the Temporal Cloud provider, defined in the configuration files within the current directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nterraform init\n```\n\n----------------------------------------\n\nTITLE: Setting History Archival State during Namespace Registration with tctl\nDESCRIPTION: Sets the state ('disabled' or 'enabled') for Workflow Execution History Archival for the Namespace being registered using the `--history_archival_state <value>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --history_archival_state <value>\n```\n\n----------------------------------------\n\nTITLE: Showing System Namespace (showTemporalSystemNamespace) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to control the visibility of the internal 'temporal-system' Namespace in the UI. Set to `true` to make it visible, showing internal platform Workflows. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nshowTemporalSystemNamespace: false\n```\n\n----------------------------------------\n\nTITLE: Backfilling a Temporal Schedule using tctl (Shell)\nDESCRIPTION: Executes past scheduled actions for a specified time range. This command requires the Schedule ID (`--sid`), an overlap policy (`--overlap-policy` like 'BufferAll' or 'AllowAll'), a start time (`--start-time`), and an end time (`--end-time`). It's useful for running missed actions after a pause or before schedule creation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntctl schedule backfill --sid 'your-schedule-id' \\\n  --overlap-policy 'BufferAll'                \\\n  --start-time '2022-05-01T00:00:00Z'         \\\n  --end-time   '2022-05-31T23:59:59Z'\n```\n\n----------------------------------------\n\nTITLE: Monitoring Kubernetes Deployment with K9s - Bash\nDESCRIPTION: This Bash command launches the K9s UI for monitoring Kubernetes resources and deployments. It is used to visually confirm the state and logs of the metrics exporter within the Kubernetes cluster. Inputs: None. Outputs: Interactive resource monitor UI. Dependencies: K9s CLI utility, access to Kubernetes cluster.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nk9s\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal CLI via Homebrew - Bash\nDESCRIPTION: Demonstrates installing the Temporal CLI on macOS and Linux using the Homebrew package manager. This method requires the Homebrew package management system to be installed. No additional parameters are needed. The 'temporal' command-line tool is installed and made available globally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install temporal\n\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Job with Rate Limiting (Bash)\nDESCRIPTION: Initiates a `tctl` batch job while specifying the maximum rate of operations per second using the `--rps` modifier. The default rate is 50 RPS. The `--query` modifier selects the target Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --rps <value>\n```\n\n----------------------------------------\n\nTITLE: Defining NexusOperationFailed Event Fields in Markdown\nDESCRIPTION: This snippet defines the fields for the NexusOperationFailed event type using a Markdown table. It includes scheduled_event_id, failure, and request_id fields with their descriptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/events.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Field              | Description                                                                                                   |\n| :----------------- | :------------------------------------------------------------------------------------------------------------ |\n| scheduled_event_id | The ID of the [NexusOperationScheduled](#nexusoperationscheduled)` event. Uniquely identifies this operation. |\n| failure            | Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo.                              |\n| request_id         | The request ID allocated at schedule time.                                                                    |\n```\n\n----------------------------------------\n\nTITLE: Describing a tctl Batch Job (Bash)\nDESCRIPTION: Fetches and displays the progress and details of a specific `tctl` batch job identified by its Job ID using the required `--job_id` modifier.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch describe --job_id <id>\n```\n\n----------------------------------------\n\nTITLE: Listing Client CA Certificates for a Namespace\nDESCRIPTION: This command lists all client CA certificates currently configured for a specified Namespace in Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca list \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Disabling an API Key with Resource Version - tcld CLI - Bash\nDESCRIPTION: This snippet appends --resource-version to the disable operation, ensuring the command only applies to a specific key version (etag) for safe concurrent updates. Useful in environments with multiple administrators.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey disable --id <apikey_id> --resource-version <version>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Workflow History Divergence After Conflict Resolution\nDESCRIPTION: This ASCII diagram illustrates the state of the Workflow Execution History at time T=1, after conflict resolution. A new history branch has been created or become dominant, resulting in Event ID 4 now having version 3, which represents the current mutable state. The previous branch (with Event ID 4, version 2) still exists but is no longer the current one. Task A, associated with the non-current branch (version 2), is now considered potentially stale.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n| -------- | ------------- |\n| Events        |\n| ------------- | -------------------------------------------- |\n| Event ID      | Event Version                                |\n| --------      | -------------                                |\n| 1             | 1                                            |\n| 2             | 1                                            |\n| 3             | 2                                            |\n| --------      | -------------                                |\n|               |\n| ------------- | -------------------------------------------- |\n|               |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| Event ID      | Event Version                                |                                  | Event ID | Event Version |\n| --------      | -------------                                |                                  | -------- | ------------- |\n| 4             | 2                                            | <-- task A belongs to this event | 4        | 3             | <-- current branch / mutable state |\n| --------      | -------------                                |                                  | -------- | ------------- |\n```\n\n----------------------------------------\n\nTITLE: Configuring High Availability Settings with Auto-Failover Control\nDESCRIPTION: This command updates high availability settings for a Temporal Cloud Namespace, specifically controlling the auto-failover feature. Setting --disable-auto-failover to true prevents Temporal Cloud from performing health checks and automatic failovers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_65\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace update-high-availability \\\n    --namespace <namespace_id>.<account_id> \\\n    --disable-auto-failover=true\n\n```\n\n----------------------------------------\n\nTITLE: Failing an Activity Execution with Temporal CLI\nDESCRIPTION: Command example for failing an Activity Execution in a running Workflow. This command marks the specified Activity as failed, preventing further execution of that Activity instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/activity.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal fail --workflow-id=meaningful-business-id --activity-id=MyActivity\n```\n\n----------------------------------------\n\nTITLE: Using tctl workflow showid command\nDESCRIPTION: Command that shows the Workflow Execution Event History for the specified Workflow ID, acting as a shortcut for the show command with workflow_id option.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id>\n```\n\n----------------------------------------\n\nTITLE: Upgrading PostgreSQL v12+ Visibility Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command is specifically for upgrading the Temporal visibility schema on PostgreSQL version 12 or later using `temporal-sql-tool`. It utilizes the `postgres12` plugin (`--pl postgres12`) to enable advanced Visibility features introduced with Temporal Server v1.20. The command connects via TLS, targets the `temporal_visibility` database, and applies updates from the PostgreSQL v12 schema directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 5432 -u temporal -pw temporal --pl postgres12 --db temporal_visibility update-schema -d ./schema/postgresql/v12/visibility/versioned\n```\n\n----------------------------------------\n\nTITLE: Using Specific Codec Endpoint with Temporal CLI Workflow Show\nDESCRIPTION: Demonstrates how to specify a Codec Server endpoint (`--codec-endpoint \"http://localhost:8888\"`) for a single Temporal CLI command execution (`workflow show`). This overrides any globally configured endpoint for this specific command, allowing viewing of decoded workflow details for `yourWorkflow` in `yourNamespace` using the specified Codec Server. Requires the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/data-encryption.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntemporal --codec-endpoint \"http://localhost:8888\" --namespace \"yourNamespace\" workflow show --workflow-id \"yourWorkflow\"  --run-id \"<yourRunId>\" --output \"table\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace with API Key Authentication using tcld (Bash)\nDESCRIPTION: This example shows how to create a Temporal Cloud Namespace (standard or High Availability) using API key authentication. The API key is specified with the global `--api-key` flag. The namespace identifier and region(s) must be provided.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld --api-key <your_api_key> \\\n    namespace create \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <primary_region> [\\\\]\n    [--region <replica_region>] // if adding replica\n```\n\n----------------------------------------\n\nTITLE: Authenticating with Python SDK using API Key (v1.6.0+)\nDESCRIPTION: Example of creating a Temporal client connection using an API key in Python SDK version 1.6.0 or higher.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclient = await Client.connect(\n    <endpoint>,\n    namespace=<namespace_id>.<account_id>,\n    rpc_metadata={\"temporal-namespace\": <namespace_id>.<account_id>},\n    api_key=<APIKey>,\n    tls=True,\n)\n```\n\n----------------------------------------\n\nTITLE: Updating a Temporal Cloud Namespace Resource in HCL\nDESCRIPTION: Shows an updated Terraform configuration (`.tf` file) for an existing `temporalcloud_namespace` resource. In this example, the `retention_days` parameter is changed from 14 to 30. Applying this configuration will update the Namespace in Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_8\n\nLANGUAGE: hcl\nCODE:\n```\nterraform {\n  required_providers {\n    temporalcloud = {\n      source = \"temporalio/temporalcloud\"\n      version = \">= 0.0.6\"\n    }\n  }\n}\n\nprovider \"temporalcloud\" {\n\n}\n\nresource \"temporalcloud_namespace\" \"namespace\" {\n  name               = \"terraform\"\n  regions            = [\"aws-us-east-1\"]\n  accepted_client_ca = base64encode(file(\"ca.pem\"))\n  retention_days     = 30\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Search Attribute using Temporal CLI\nDESCRIPTION: Command to create a custom text-based Search Attribute named 'CustomKeywordField' using the Temporal operator CLI tool.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/your_visibility/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ntemporal operator search-attribute create --name CustomKeywordField --type text\n```\n\n----------------------------------------\n\nTITLE: Starting Minikube Kubernetes Cluster - Bash\nDESCRIPTION: This command starts a local Kubernetes cluster using Minikube, which is a prerequisite for deploying the temporal metrics integration. It must be run in a terminal with Minikube properly installed. Inputs: None. Outputs: Running local Kubernetes cluster. Dependencies: Minikube installation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nminikube start\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaced Custom Search Attribute - SQL Database\nDESCRIPTION: Command to create a custom Search Attribute with namespace specification, required for SQL databases with advanced Visibility capabilities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator search-attribute create --name=\"CustomSA\" --type=\"Keyword\" --namespace=\"yournamespace\"\n```\n\n----------------------------------------\n\nTITLE: Listing tcld Commands for GCS Export Sink Management in Bash\nDESCRIPTION: Displays the help output for the `tcld namespace export gcs` command, outlining the available subcommands (create, update, validate, get, delete, list) and general options for managing GCS export sinks for a Temporal Cloud Namespace. Requires `tcld` v0.35.0 or higher.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/gcp-export-gcs.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nNAME:\n   tcld namespace export gcs - Manage GCS export sink\n\nUSAGE:\n   tcld namespace export gcs command [command options] [arguments...]\n\nCOMMANDS:\n   create, c    Create export sink\n   update, u    Update export sink\n   validate, v  Validate export sink\n   get, g       Get export sink\n   delete, d    Delete export sink\n   list, l      List export sinks\n   help, h      Shows a list of commands or help for one command\n\nOPTIONS:\n   --help, -h  show help\n```\n\n----------------------------------------\n\nTITLE: Setting Temporal Cluster gRPC Address (temporalGrpcAddress) in Temporal Web UI (YAML)\nDESCRIPTION: Specifies the gRPC address (host:port) of the Temporal Cluster's frontend service that the Web UI server should connect to. Defaults to '127.0.0.1:7233'. The value 'default' likely resolves to the default address.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\ntemporalGrpcAddress: default\n```\n\n----------------------------------------\n\nTITLE: Configuring History Size Limits in Temporal (Go)\nDESCRIPTION: Go source code from Temporal's history configuration (`configs/config.go`) defining how the dynamic configuration properties `HistorySizeLimitWarn` and `HistorySizeLimitError` are retrieved, with defaults of 10 MB and 50 MB respectively.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nHistorySizeLimitError:                  dc.GetIntPropertyFilteredByNamespace(dynamicconfig.HistorySizeLimitError, 50*1024*1024),\nHistorySizeLimitWarn:                   dc.GetIntPropertyFilteredByNamespace(dynamicconfig.HistorySizeLimitWarn, 10*1024*1024),\n```\n\n----------------------------------------\n\nTITLE: Updating Visibility Archival State for a Namespace using tctl\nDESCRIPTION: Updates the state ('enabled' or 'disabled') for Visibility record Archival for an existing Namespace using the `--visibility_archival_state <value>` modifier with `tctl namespace update`. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --visibility_archival_state <value>\n```\n\n----------------------------------------\n\nTITLE: Listing All Namespaces in Go\nDESCRIPTION: Retrieves information and configuration details for all registered Namespaces on the Temporal Service with pagination support.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/namespaces.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n//...\n    namespace.Handler.ListNamespaces(context.Context(), &workflowservice.ListNamespacesRequest{ //lists 1 page (1-100) of namespaces on the active Temporal Service. You can set a large PageSize or loop until NextPageToken is nil\n        //PageSize:        0,\n        //NextPageToken:   nil,\n        //NamespaceFilter: nil,\n        })\n//...\n```\n\n----------------------------------------\n\nTITLE: Testing Certificate Setup with Curl for Prometheus Query - Bash\nDESCRIPTION: This command validates whether the generated certificates are correctly set up for querying Temporal Cloud's Prometheus endpoint. It uses curl to authenticate via client certificates and pipes the JSON output to jq for formatting. Replace <Organization_ID> with your Temporal Cloud account identifier. Inputs: ca.pem, ca.key, Organization_ID. Outputs: JSON response; successful if certificates are correctly configured. Dependencies: curl, jq.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl --cert ca.pem --key ca.key \\\"https://<Organization_ID>.tmprl.cloud/prometheus/api/v1/query?query=temporal_cloud_v0_state_transition_count\\\" | jq .\n```\n\n----------------------------------------\n\nTITLE: Describing a Specific Type of Temporal Task Queue using tctl (Bash)\nDESCRIPTION: Describes poller information for a specific type (`workflow` or `activity`) of Temporal Task Queue. Requires the `--taskqueue` modifier (`<value>`) and optionally accepts `--taskqueuetype <type>` (defaults to `workflow`). This command is part of the deprecated `tctl` utility.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/taskqueue.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl taskqueue describe --taskqueue <value> --taskqueuetype <type>\n```\n\n----------------------------------------\n\nTITLE: Listing all Nexus Endpoints using Temporal CLI\nDESCRIPTION: This command lists all Nexus Endpoints on the Server. It does not require any additional parameters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint list\n```\n\n----------------------------------------\n\nTITLE: Providing a Reason for Namespace Update using tctl\nDESCRIPTION: Specifies a reason for performing the update operation on a Namespace using the `--reason <value>` modifier with `tctl namespace update`. This provides audit context for the change. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --reason <value>\n```\n\n----------------------------------------\n\nTITLE: Testing GCP PSC Connection with Temporal CLI (mTLS)\nDESCRIPTION: This command demonstrates how to test the Private Service Connect connection to Temporal Cloud using the Temporal CLI with mutual TLS (mTLS) authentication. It targets the PSC endpoint IP address and port 7233, provides paths to the client certificate and key, overrides the TLS server name to the specific Temporal Cloud namespace endpoint (`<namespace>.<account>.tmprl.cloud`) for proper certificate validation, and specifies the target namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/gcp-private-service-connect.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow count \\\n    --address <IP address of the PSC endpoint>:7233 \\\n    --tls-cert-path /path/to/client.pem \\\n    --tls-key-path /path/to/client.key \\\n    --tls-server-name <namespace>.<account>.tmprl.cloud \\\n    --namespace <namespace>\n```\n\n----------------------------------------\n\nTITLE: Configuring RoadRunner for Activity Mocking in PHP\nDESCRIPTION: YAML configuration for RoadRunner to enable Activity mocking using Key-Value storage in PHP tests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nkv:\n  test:\n    driver: memory\n    config:\n      interval: 10\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions with Formatting Options using tctl (Bash)\nDESCRIPTION: Demonstrates various formatting options for the `tctl workflow list` command. By default, it lists closed Workflows. Use flags like `--print_raw_time`, `--print_datetime`, `--print_memo`, `--print_search_attr`, `--print_full`, or `--print_json` to customize the output format. The `--open` flag lists open Workflow Executions instead of closed ones.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_raw_time\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_datetime\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_memo\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_search_attr\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_full\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --print_json\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example listing open workflows\ntctl workflow list --open\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Worker with Dynamic Workflow Path\nDESCRIPTION: Demonstrates how to create a Temporal Worker in development mode by dynamically resolving the Workflow path. The Worker is configured with a specified Task Queue and Activity implementations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Worker } from '@temporalio/worker';\nimport * as activities from './activities';\n\nasync function run() {\n  const worker = await Worker.create({\n    workflowsPath: require.resolve('./workflows'),\n    taskQueue: 'snippets',\n    activities,\n  });\n\n  await worker.run();\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Namespace Configuration in Go\nDESCRIPTION: Updates information and configuration for an existing Namespace including description, owner email, and other optional configurations like retention period and replication settings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/namespaces.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n//...\n  err = client.Update(context.Background(), &workflowservice.UpdateNamespaceRequest{\n      Namespace:         \"your-namespace-name\",\n      UpdateInfo:        &namespace.UpdateNamespaceInfo{ //updates info for the namespace \"your-namespace-name\"\n          Description:   \"updated namespace description\",\n          OwnerEmail:    \"newowner@mail.com\",\n          //Data:        nil,\n          //State:       0,\n      },\n      /*other details that you can update:\n      Config:            &namespace.NamespaceConfig{ //updates the configuration of the namespace with the following options\n          //WorkflowExecutionRetentionTtl: nil,\n          //BadBinaries:                   nil,\n          //HistoryArchivalState:          0,\n          //HistoryArchivalUri:            \"\",\n          //VisibilityArchivalState:       0,\n          //VisibilityArchivalUri:         \"\",\n      },\n      ReplicationConfig: &replication.NamespaceReplicationConfig{ //updates the replication configuration for the namespace\n          //ActiveClusterName: \"\",\n          //Clusters:          nil,\n          //State:             0,\n      },\n      SecurityToken:     \"\",\n      DeleteBadBinary:   \"\",\n      PromoteNamespace:  false,\n      })*/\n```\n\n----------------------------------------\n\nTITLE: Setting a User's Account Role by ID via tcld CLI - Command\nDESCRIPTION: Sets or modifies the account-level role for a user specified by user ID. --user-id and --account-role must be provided; this command updates user access within the account accordingly. Can incorporate ETag matching or asynchronous request tracking through additional flags.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_10\n\nLANGUAGE: command\nCODE:\n```\ntcld user set-account-role --user-id <test-user-id> --account-role Developer\n```\n\n----------------------------------------\n\nTITLE: Specifying Reason for tctl Activity Failure (Bash)\nDESCRIPTION: This command demonstrates how to provide a reason when failing a Temporal Activity Execution using the deprecated `tctl` tool via the `--reason` modifier. Replace `<value>` with the reason string for the failure. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity fail --reason <value>\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Custom Search Attribute - Temporal CLI\nDESCRIPTION: Command to create a single custom Search Attribute named 'CustomSA' of type 'Keyword' in a self-hosted Temporal Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator search-attribute create --name=\"CustomSA\" --type=\"Keyword\"`\n```\n\n----------------------------------------\n\nTITLE: Creating a Namespace Scoped Service Account using tcld (bash)\nDESCRIPTION: Demonstrates the creation of a Namespace Scoped Service Account using the `tcld service-account created-scoped` command (note: command name corrected from documentation typo). It specifies the name (`-n \"test_scoped_sa\"`) and the namespace permission (`--np \"foo=Admin\"`), assigning Admin rights to the 'foo' namespace. Namespace Scoped Service Accounts automatically have a 'Read' Account Role.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/service-accounts.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld service-account created-scoped -n \"test_scoped_sa\" --np \"foo=Admin\"\n```\n\n----------------------------------------\n\nTITLE: Date Range Filter with BETWEEN\nDESCRIPTION: List Filter that matches Workflows with ExecutionTime within a specific date range using the BETWEEN operator.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_12\n\nLANGUAGE: sql\nCODE:\n```\nExecutionTime between '2021-08-22T15:04:05+00:00' and '2021-08-28T15:04:05+00:00'\n```\n\n----------------------------------------\n\nTITLE: Makefile Targets for Project Build and Execution - Makefile\nDESCRIPTION: Provides a Makefile containing targets for building, cleaning, and running the worker and caller components using Maven. The 'build' target compiles and packages the project, 'clean' removes build artifacts, while 'worker' and 'caller' execute the respective Java main classes. Maven must be installed and configured. The targets expect that the classes 'clientsample.YourWorkerApp' and 'clientsample.YourCallerApp' exist and are entry points for the worker and caller logic.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-namespace-client-sample/README.md#2025-04-23_snippet_3\n\nLANGUAGE: makefile\nCODE:\n```\nbuild:\n     mvn clean install -Dmaven.logging.level=0\n\nclean:\n     mvn clean -q -Dmaven.logging.level=0\n\nworker:\n     mvn compile exec:java -Dexec.mainClass=\\\"clientsample.YourWorkerApp\\\" -Dmaven.logging.level=1\n\ncaller:\n     mvn exec:java -Dexec.mainClass=\\\"clientsample.YourCallerApp\\\" -q -Dmaven.logging.level=1\n```\n\n----------------------------------------\n\nTITLE: Listing Workflows with Detailed Output in JSON Format using Temporal CLI in Shell\nDESCRIPTION: This command lists workflows with detailed output in JSON format using the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow list --fields long --output json\n```\n\n----------------------------------------\n\nTITLE: Printing full event details in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that displays comprehensive event information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --print_full\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Exporting a Composite PayloadConverter with EJSON Support in TypeScript\nDESCRIPTION: Combines UndefinedPayloadConverter and the custom EjsonPayloadConverter using CompositePayloadConverter to support both undefined and EJSON-serializable types. Exports the configured converter for use in Worker and Client configurations. Requires @temporalio/common and the previously defined EjsonPayloadConverter. No parameters; returns an exportable payloadConverter instance.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CompositePayloadConverter,\n  UndefinedPayloadConverter,\n} from '@temporalio/common';\nimport { EjsonPayloadConverter } from './ejson-payload-converter';\n\nexport const payloadConverter = new CompositePayloadConverter(\n  new UndefinedPayloadConverter(),\n  new EjsonPayloadConverter(),\n);\n```\n\n----------------------------------------\n\nTITLE: Running Individual Temporal Server Services with Docker Run - Bash\nDESCRIPTION: This code runs a specific Temporal Server service (such as history, matching, worker, or frontend) in a Docker container using the docker run command. It sets required environment variables, like SERVICES to choose which service to run, LOG_LEVEL for logging verbosity, and DYNAMIC_CONFIG_FILE_PATH to specify the config file. The temporalio/server:<tag> image must be available locally or pulled from a registry. The snippet omits persistence/schema setup flags, which are typically required for initial database configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/deployment.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run\\n    # persistence/schema setup flags omitted\\n    -e SERVICES=history \\\\                      -- Spin up one or more: history, matching, worker, frontend\\n    -e LOG_LEVEL=debug,info \\\\                           -- Logging level\\n    -e DYNAMIC_CONFIG_FILE_PATH=config/foo.yaml         -- Dynamic config file to be watched\\n    temporalio/server:<tag>\n```\n\n----------------------------------------\n\nTITLE: Specifying Search Attribute value in tctl workflow run command\nDESCRIPTION: Command that specifies a Search Attribute value. Multiple values can be concatenated with pipes (|) as separators. Array values use JSON format.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --search_attr_value <value>\n```\n\n----------------------------------------\n\nTITLE: Specifying Search Attribute key in tctl workflow run command\nDESCRIPTION: Command that specifies a Search Attribute key. Multiple keys can be concatenated using pipes (|) as separators.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --search_attr_key <key>\n```\n\n----------------------------------------\n\nTITLE: Configuring Secondary Visibility Store in Temporal YAML Configuration\nDESCRIPTION: YAML configuration example that demonstrates how to set up dual visibility in Temporal by configuring writing and reading modes for secondary visibility stores. This configuration enables write operations to both primary and secondary stores while disabling reading from the secondary store.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nsystem.secondaryVisibilityWritingMode:\n  - value: 'dual'\n    constraints: {}\nsystem.enableReadFromSecondaryVisibility:\n  - value: false\n    constraints: {}\n```\n\n----------------------------------------\n\nTITLE: String Values for Text Search Attribute Examples\nDESCRIPTION: Examples of string values that can be stored in a Text-type Search Attribute, demonstrating how values are tokenized for searching.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nmy-business-id-foobar\nmy business id foobar\n```\n\n----------------------------------------\n\nTITLE: Running Temporal UI Docker Container with Environment Variables\nDESCRIPTION: Command to run the Temporal UI Docker container with environment variables for configuration. This example shows how to set the Temporal server address and enable HTTPS connections.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/Google/vocab.txt#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -p 8080:8080 -e TEMPORAL_ADDRESS=localhost:7233 -e TEMPORAL_TLS_ENABLE=true temporalio/ui:latest\n```\n\n----------------------------------------\n\nTITLE: Sample Temporal Cloud Audit Log Entry in JSON Format\nDESCRIPTION: Provides an example structure of a Temporal Cloud Audit Log entry delivered via Kinesis, formatted as JSON. It includes fields like emission time (`emit_time`), log level (`level`), caller IP address (`caller_ip_address`), user email (`user_email`), the specific operation performed (`operation`, e.g., 'DeleteUser'), details of the operation (`details`), the status of the operation (`status`), log category (`category`), a unique log identifier (`log_id`), the request identifier (`request_id`), and information about the principal (user or service) performing the action (`principal`).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/audit-logging-aws.mdx#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"emit_time\": \"2023-11-14T07:56:55Z\",\n  \"level\": \"LOG_LEVEL_INFO\",\n  \"caller_ip_address\": \"10.1.2.3, 10.4.5.6\",\n  \"user_email\": \"user1@example.com\",\n  \"operation\": \"DeleteUser\",\n  \"details\": {\n    \"target_users\": [\"d7dca96f-adcc-417d-aafc-e8f5d2ba9fe1\"],\n    \"search_attribute_update\": {}\n  },\n  \"status\": \"OK\",\n  \"category\": \"LOG_CATEGORY_ADMIN\",\n  \"log_id\": \"0mc69c0323b871293ce231dd1c7fb639\",\n  \"request_id\": \"445297d3-43a7-4793-8a04-1b1dd1999640\",\n  \"principal\": {\n    \"id\": \"988cb80b-d6be-4bb5-9c87-d09f93f58ed3\",\n    \"type\": \"user\",\n    \"name\": \"user1@example.com\"\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Calculating Credit Balance in Temporal Cloud\nDESCRIPTION: Shows how to calculate the remaining credit balance after monthly usage. This example assumes an annual spend commitment of $72,000 and details the breakdown of monthly charges.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/pricing.mdx#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nBeginning credit balance of 72,000 - 5800 credits used = 66,200, Temporal Credits remaining.\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Schedule with Cron using tctl (Shell)\nDESCRIPTION: Creates a new Temporal Schedule using a traditional cron string specification. Requires a Schedule ID (`--schedule-id`), cron expression (`--cron`), target Workflow ID (`--workflow-id`), Task Queue (`--task-queue`), and Workflow Type (`--workflow-type`). Supports standard cron features and shorthands like '@weekly'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl schedule create \\\n    --schedule-id 'your-schedule-id' \\\n    --cron '3 11 * * Fri' \\\n    --workflow-id 'your-workflow-id' \\\n    --task-queue 'your-task-queue' \\\n    --workflow-type 'YourWorkflowType'\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS (tls) for Temporal Web UI Connection (YAML)\nDESCRIPTION: Defines Transport Layer Security (TLS) settings for the connection between the Temporal Web UI server and the Temporal Cluster frontend. Includes paths (`caFile`, `certFile`, `keyFile`) or base64-encoded data (`caData`, `certData`, `keyData`) for certificates, plus host verification options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\ntls:\n  caFile: ../ca.cert\n  certFile: ../cluster.pem\n  keyFile: ../cluster.key\n  caData:\n  certData:\n  keyData:\n  enableHostVerification: true\n  serverName: tls-server\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Service with Docker Compose - Bash\nDESCRIPTION: This code initializes and starts a Temporal Service using Docker and Docker Compose. It clones the temporalio/docker-compose repository, changes to the directory, and runs the docker compose up command with the default configuration. This approach requires Docker and Docker Compose to be pre-installed and assumes default ports 7233 (Temporal Service) and 8080 (Web UI). Input is not required beyond running the commands sequentially; the outputs are active Temporal Server containers running locally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/deployment.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/temporalio/docker-compose.git\\ncd docker-compose\\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Querying P95 Async Task Match Latency for Matching Service using PromQL\nDESCRIPTION: This Prometheus query calculates the 95th percentile (P95) latency for asynchronously matched tasks within the Matching Service (`service_name=~\"matching\"`) over the last 5 minutes. It uses the `asyncmatch_latency_bucket` histogram metric and aggregates results by operation. High values indicate tasks are waiting longer in the queue before being picked up by workers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_7\n\nLANGUAGE: PromQL\nCODE:\n```\nhistogram_quantile(0.95, sum(rate(asyncmatch_latency_bucket{service_name=~\"matching\"}[5m])) by (operation, le))\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Data Converter WebSocket URL and Port using tctl (Deprecated)\nDESCRIPTION: This command uses the deprecated `tctl` utility to configure the Temporal Web UI with a custom Data Converter. It specifies both the required WebSocket URL using `--web_ui_url` and an optional port number using `--port`. Replace `<url>` with the WebSocket endpoint and `<value>` with the desired port number. Note that `tctl` is deprecated and users should migrate to `temporal cli`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/dataconverter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl dataconverter web --web_ui_url <url> --port <value>\n```\n\n----------------------------------------\n\nTITLE: Running Caller Worker with TLS Certificates - Go CLI\nDESCRIPTION: This snippet outlines running the caller worker process in Temporal Cloud with TLS certificate authentication. Requires navigating to the 'caller' directory and executing `go run` on the worker code, specifying the target Temporal endpoint, namespace, and client-side TLS credentials. Suitable for secure workload execution under the caller namespace. Must have Go and corresponding client certificate and key. Ensures reliable communication with appropriate scope.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_14\n\nLANGUAGE: go\nCODE:\n```\ncd caller\n\ngo run ./worker \\\n\t-target-host <your-caller-namespace.account>.tmprl.cloud:7233 \\\n\t-namespace <your-caller-namespace.account> \\\n\t-client-cert 'path/to/your/ca.pem' \\\n\t-client-key 'path/to/your/ca.key'\n```\n\n----------------------------------------\n\nTITLE: Compiling Protobuf Files for Python using gRPC Tools\nDESCRIPTION: This Python command uses the `grpc_tools.protoc` module to compile `.proto` files into Python code. It requires the `grpc-tools` package to be installed. The command specifies the source directory for `.proto` files (`-I`), the output directory for generated Python classes (`--python_out`), the output directory for generated gRPC service classes (`--grpc_python_out`), and targets all `.proto` files in the current directory. This process generates the necessary client code to interact with the Temporal Cloud Ops API via gRPC in Python.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/operation-api.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npython -m grpc_tools.protoc -I./ --python_out=./ --grpc_python_out=./ *.proto\n```\n\n----------------------------------------\n\nTITLE: Viewing Pending Callbacks with Temporal CLI\nDESCRIPTION: This snippet shows how to use the temporal CLI to describe a workflow and view its pending Nexus callbacks. It displays information about callbacks sent from the handler's Namespace to the caller's Namespace to complete asynchronous Nexus Operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/nexus-execution-debugging.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow describe\n\nCallbacks: 1\n\n  URL               https://nexus.phil-caller-Namespace.a2dd6.cluster.tmprl.cloud:7243/Namespaces/phil-caller-Namespace.a2dd6/nexus/callback\n  Trigger           WorkflowClosed\n  State             Succeeded\n  Attempt           1\n  RegistrationTime  32 minutes ago\n```\n\n----------------------------------------\n\nTITLE: Listing Namespaces with Temporal CLI\nDESCRIPTION: Lists all namespaces on the Temporal Server using the CLI command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace list\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Data during Namespace Registration with tctl\nDESCRIPTION: Attaches custom key-value pair data (formatted as `k1:v1,k2:v2,k3:v3`) to a Namespace during registration using the `--namespace_data <data>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --namespace_data <data>\n```\n\n----------------------------------------\n\nTITLE: Calculating Essentials Tier Pricing in Temporal Cloud\nDESCRIPTION: Demonstrates how to calculate the monthly bill for an Essentials tier customer with $3,000 of monthly spend. The price is determined as the greater of $100 or 5% of the monthly spend.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/pricing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nGreater of $100 or 5% ⨉ $3,000 = $150, so $150.\n```\n\n----------------------------------------\n\nTITLE: Starting the Temporal Worker using Poetry (Bash)\nDESCRIPTION: This command executes the `run_worker.py` Python script using the environment managed by Poetry. This script is responsible for starting a Temporal Worker process, which listens for tasks associated with Workflows and Activities defined in the project, including those triggered by Schedules.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/schedule_your_workflow/readme.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python run_worker.py\n```\n\n----------------------------------------\n\nTITLE: Printing raw timestamp in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that displays raw timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_raw_time\n```\n\n----------------------------------------\n\nTITLE: Listing Search Attributes - Namespaced\nDESCRIPTION: Command to list Search Attributes for a specific namespace in v1.20+.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ntemporal search-attribute list --namespace=\"yournamespace\"\n```\n\n----------------------------------------\n\nTITLE: Registering a New Temporal Namespace using tctl\nDESCRIPTION: Registers a new Temporal Namespace named 'your-namespace' using the `tctl namespace register` command. The target namespace must be specified using the global `--namespace` (or `--ns`) flag. It also shows the equivalent command using shorthand aliases (`n` for `namespace`, `re` for `register`). This command creates the namespace within the Temporal cluster specified or configured globally.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntctl --namespace your-namespace namespace register\n# OR using short alias\ntctl --ns your-namespace n re\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Test Environment for Each Workflow Test in Go\nDESCRIPTION: Implements a SetupTest method that creates a new test environment before each test, ensuring isolation between test cases.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/test-suites.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (s *UnitTestSuite) SetupTest() {\n        s.env = s.NewTestWorkflowEnvironment()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Temporal Server for Specific Services in Go\nDESCRIPTION: Uses temporal.NewServer() with temporal.ForServices(temporal.Services) to restrict server operation to a specific list of Temporal services. This allows limiting or customizing which internal services are enabled. Dependencies include the go.temporal.io/server/temporal package; expected input is a list of services (typically provided). Output is a server instance constrained to those services.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/server-options.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ns, err := temporal.NewServer(\n\ttemporal.ForServices(temporal.Services),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Querying PollActivityTaskQueue Rate in Prometheus\nDESCRIPTION: Prometheus query to measure the per-second average rate of PollActivityTaskQueue long poll requests. Helps monitor Worker polling frequency for Activity Tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/performance-bottlenecks.mdx#2025-04-23_snippet_0\n\nLANGUAGE: prometheus\nCODE:\n```\nrate(temporal_long_request_total{operation=\"PollActivityTaskQueue\"})\n```\n\n----------------------------------------\n\nTITLE: Building, Cleaning, and Executing with Maven - Makefile\nDESCRIPTION: This Makefile provides targets to build, clean, and run both Worker and Caller applications using the Maven package manager. It includes commands for compilation ('build'), project cleanup ('clean'), starting the Worker ('worker'), and running the Caller application ('caller'). Key parameters include specification of main classes for worker/caller, Maven logging configuration, and silent operation for certain commands. Prerequisite: Maven should be installed and available in the system environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/java/client/devserver-client-sample/README.md#2025-04-23_snippet_1\n\nLANGUAGE: makefile\nCODE:\n```\nbuild:\\n     mvn clean install -Dmaven.logging.level=0\\n\\nclean:\\n     mvn clean -q -Dmaven.logging.level=0\\n\\nworker:\\n     mvn compile exec:java -Dexec.mainClass=\\\"clientsample.YourWorkerApp\\\" -Dmaven.logging.level=1\\n\\ncaller:\\n     mvn exec:java -Dexec.mainClass=\\\"clientsample.YourCallerApp\\\" -q -Dmaven.logging.level=1\n```\n\n----------------------------------------\n\nTITLE: Describing a Workflow with Temporal CLI in Shell\nDESCRIPTION: This command describes a specific workflow using its workflow ID with the Temporal CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow describe --workflow-id 123\n```\n\n----------------------------------------\n\nTITLE: Terminating a Workflow Execution with Run ID\nDESCRIPTION: Demonstrates how to terminate a specific Workflow Execution run using both workflow ID and run ID modifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_65\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow terminate --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Namespace Version After Failover (B to A)\nDESCRIPTION: Example demonstrating the version change for Namespace β after failing over from Cluster B (initial version 2) to Cluster A (initial version 1), given a shared version increment of 10. Following the rule (`version % 10 == 1` and `version >= 2`), the smallest qualifying version is 11. New events will be tagged with version 11.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nnamespace β's version is 11\nall workflows events generated within this namespace, will come with version 11\n```\n\n----------------------------------------\n\nTITLE: Setting Page Size for Workflow Listing\nDESCRIPTION: Command to specify the maximum number of Workflow Executions to list per page\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --pagesize <value>\n```\n\n----------------------------------------\n\nTITLE: Starting HelloSignal Workflow with tctl\nDESCRIPTION: Command to start a Workflow with HelloSignal ID on HelloWorldTaskQueue with specified timeout and input parameters\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_58\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow start  --workflow_id \"HelloSignal\" --taskqueue HelloWorldTaskQueue --workflow_type HelloWorld --execution_timeout 3600 --input \\\"World\\\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Caller Workflow Starter in Java for Temporal Nexus\nDESCRIPTION: This Java class initiates caller Workflows that use Nexus to communicate across namespaces. It creates and starts instances of EchoCallerWorkflow and HelloCallerWorkflow, demonstrating how to initiate cross-namespace communication with Temporal Nexus.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_10\n\nLANGUAGE: java\nCODE:\n```\npackage io.temporal.samples.nexus.caller;\n\nimport io.temporal.api.common.v1.WorkflowExecution;\nimport io.temporal.client.WorkflowClient;\nimport io.temporal.client.WorkflowOptions;\nimport io.temporal.samples.nexus.options.ClientOptions;\nimport io.temporal.samples.nexus.service.NexusService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class CallerStarter {\n  private static final Logger logger = LoggerFactory.getLogger(CallerStarter.class);\n\n  public static void main(String[] args) {\n    WorkflowClient client = ClientOptions.getWorkflowClient(args);\n\n    WorkflowOptions workflowOptions =\n        WorkflowOptions.newBuilder().setTaskQueue(CallerWorker.DEFAULT_TASK_QUEUE_NAME).build();\n    EchoCallerWorkflow echoWorkflow =\n        client.newWorkflowStub(EchoCallerWorkflow.class, workflowOptions);\n    WorkflowExecution execution = WorkflowClient.start(echoWorkflow::echo, \"Nexus Echo 👋\");\n    logger.info(\n        \"Started EchoCallerWorkflow workflowId: {} runId: {}\",\n        execution.getWorkflowId(),\n        execution.getRunId());\n    logger.info(\"Workflow result: {}\", echoWorkflow.echo(\"Nexus Echo 👋\"));\n    HelloCallerWorkflow helloWorkflow =\n        client.newWorkflowStub(HelloCallerWorkflow.class, workflowOptions);\n    execution = WorkflowClient.start(helloWorkflow::hello, \"Nexus\", NexusService.Language.EN);\n    logger.info(\n        \"Started HelloCallerWorkflow workflowId: {} runId: {}\",\n        execution.getWorkflowId(),\n        execution.getRunId());\n    logger.info(\"Workflow result: {}\", helloWorkflow.hello(\"Nexus\", NexusService.Language.ES));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting maximum field length in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that specifies the maximum length for each attribute field. Default is 500.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --max_field_length <length>\n```\n\n----------------------------------------\n\nTITLE: Defining NexusOperationCancelRequested Event Fields in Markdown\nDESCRIPTION: This snippet defines the fields for the NexusOperationCancelRequested event type using a Markdown table. It includes scheduled_event_id and workflow_task_completed_event_id fields with their descriptions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/events.mdx#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Field | Description |\n| :---- | :---- |\n| scheduled_event_id | The id of the [NexusOperationScheduled](#nexusoperationscheduled)` event this cancel request corresponds to. |\n| workflow_task_completed_event_id | The [WorkflowTaskCompleted](#workflowtaskcompleted) event that the corresponding RequestCancelNexusOperation command was reported with. |\n```\n\n----------------------------------------\n\nTITLE: Setting Namespace Environment Variable (Windows)\nDESCRIPTION: Sets an environment variable named `NAMESPACE_NAME` and assigns its value to the user's specific Temporal Cloud namespace name (replacing `your-namespace`). This variable is used in subsequent `certstrap` commands to set the common name for the end-entity certificate on Windows systems.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_4\n\nLANGUAGE: command\nCODE:\n```\nset NAMESPACE_NAME=your-namespace\n```\n\n----------------------------------------\n\nTITLE: Disabling Batch Actions (batchActionsDisabled) in Temporal Web UI (YAML)\nDESCRIPTION: Configuration setting to disable or enable the execution of Batch actions within the Temporal Web UI. Set to `true` to prevent batch actions, defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nbatchActionsDisabled: false\n```\n\n----------------------------------------\n\nTITLE: Printing JSON output in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that displays raw JSON objects in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_json\n```\n\n----------------------------------------\n\nTITLE: Illustrating Version History State at T=1 (No Conflict)\nDESCRIPTION: This table shows the state at T=1 after adding a second event (ID 2) with version 1. The version history now indicates that the last event defining the state up to version 1 is event ID 2.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: IN Operator for Multiple WorkflowIds\nDESCRIPTION: List Filter using the IN operator to match any WorkflowId from a specified set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_8\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId IN ('<workflow-id>', '<another-workflow-id>')\n```\n\n----------------------------------------\n\nTITLE: Installing Poetry Package Manager\nDESCRIPTION: Command to install Poetry, a dependency management tool for Python projects, using the official installer script.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/workflow_failures/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -sSL https://install.python-poetry.org | python3 -\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaces with tcld CLI - Shell\nDESCRIPTION: This snippet shows how to create two Temporal Cloud Namespaces—one for the caller and one for the handler—using the `tcld` CLI. It requires the user to be logged in via `tcld login` and to possess the relevant CA certificate. Flags such as `--namespace`, `--region`, `--ca-certificate-file`, and `--retention-days` control the target namespace, region, certificate file path, and workflow retention window. Adjust the placeholders to match your environment. This setup ensures proper resource partitioning before deploying to Temporal Cloud, as required for secure communication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ntcld login\n\ntcld namespace create \\\n\t--namespace <your-caller-namespace> \\\n\t--region us-west-2 \\\n\t--ca-certificate-file 'path/to/your/ca.pem' \\\n\t--retention-days 1\n\ntcld namespace create \\\n\t--namespace <your-target-namespace> \\\n\t--region us-west-2 \\\n\t--ca-certificate-file 'path/to/your/ca.pem' \\\n\t--retention-days 1\n```\n\n----------------------------------------\n\nTITLE: Creating New Namespace via Operator Command\nDESCRIPTION: Command to create a new namespace using the Temporal operator command\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntemporal operator namespace create --namespace foo\n```\n\n----------------------------------------\n\nTITLE: Displaying Pending Nexus Operations with Temporal CLI\nDESCRIPTION: This snippet demonstrates how to use the temporal CLI to describe a workflow and view its pending Nexus Operations. It shows operation details including endpoint, service, state, attempts, timeouts, and failure information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/nexus-execution-debugging.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow describe\n\nPending Nexus Operations: 1\n\n  Endpoint                 myendpoint\n  Service                  my-hello-service\n  Operation                echo\n  OperationToken\n  State                    BackingOff\n  Attempt                  6\n  ScheduleToCloseTimeout   0s\n  NextAttemptScheduleTime  20 seconds from now\n  LastAttemptCompleteTime  11 seconds ago\n  LastAttemptFailure       {\"message\":\"handler error (INTERNAL): internal error\",\"applicationFailureInfo\":{}}\n```\n\n----------------------------------------\n\nTITLE: Describing a Batch Job in Temporal CLI\nDESCRIPTION: This command describes the progress of a specific Batch job. It demonstrates how to use the 'batch describe' command with a Job ID to get detailed information about a particular Batch operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/batch.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal batch describe --job-id=MyJobId\n```\n\n----------------------------------------\n\nTITLE: Creating a Nexus Endpoint with Temporal CLI\nDESCRIPTION: Creates a new Nexus Endpoint on the Temporal Server, specifying the endpoint name, target namespace, task queue, and description file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint create \\\n  --name your-endpoint \\\n  --target-namespace your-namespace \\\n  --target-task-queue your-task-queue \\\n  --description-file DESCRIPTION.md\n```\n\n----------------------------------------\n\nTITLE: Describing a Workflow Execution with Raw Output and Reset Points\nDESCRIPTION: This command shows how to retrieve Workflow Execution information in raw format and include auto-reset points. It provides more detailed output for advanced analysis.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/workflow.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow describe --workflow-id=meaningful-business-id --raw=true --reset-points=true\n```\n\n----------------------------------------\n\nTITLE: Starting Patch-Deprecated Workflow in Python\nDESCRIPTION: Command to start a workflow instance using the patch-deprecated workflow implementation. At this stage, the old code path is maintained but marked as deprecated.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python starter.py --start-workflow patch-deprecated-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Printing raw timestamp in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that displays raw timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --print_raw_time\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Namespace in Temporal Java SDK\nDESCRIPTION: This code snippet shows how to deprecate a Namespace using the DeprecateNamespace API. It updates the state of a registered Namespace to \"DEPRECATED\", preventing new Workflow Executions from starting on it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nimport io.temporal.api.workflowservice.v1.*;\n//...\nDeprecateNamespaceRequest deprecateNamespace = DeprecateNamespaceRequest.newBuilder()\n            .setNamespace(\"your-namespace-name\") //specify the namespace that you want to deprecate\n            .build();\n    DeprecateNamespaceResponse response = namespaceservice.blockingStub().deprecateNamespace(deprecateNamespace);\n//...\n```\n\n----------------------------------------\n\nTITLE: Antipattern: Importing and Calling Activities Directly in Workflows - TypeScript\nDESCRIPTION: Demonstrates an incorrect approach where a Workflow directly imports and calls an Activity function. Direct references to activity implementations are not allowed due to non-determinism and external dependency. Should use proxyActivities instead. Dependencies include the local activities module. Input is a URL string; output is the result of the HTTP request; however, this is unsupported in Workflow code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeHTTPRequest } from './activities';\\n\\nexport async function yourWorkflow(): Promise<string> {\\n  return await makeHTTPRequest('https://temporal.io');\\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying tctl Task Queue Help\nDESCRIPTION: This command displays help specifically for the 'taskqueue' subcommand group in tctl, listing available operations related to Temporal Task Queues.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ntctl taskqueue -h\n```\n\n----------------------------------------\n\nTITLE: Tree Structure for Conflicting Events in Temporal Version History\nDESCRIPTION: This snippet shows how version history forms a tree structure when replication tasks with conflicting events arrive from different clusters. It demonstrates how Temporal tracks divergent event histories during cluster failovers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n                | -------- | ------------- |\n                | Events        |\n                | ------------- | ------------- |\n                | Event ID      | Event Version |\n                | --------      | ------------- |\n                | 1             | 1             |\n                | 2             | 1             |\n                | 3             | 2             |\n                | --------      | ------------- |\n                |               |\n                | ------------- | ------------  |\n                |               |\n                | --------      | ------------- |  | -------- | ------------- |\n                | Event ID      | Event Version |  | Event ID | Event Version |\n                | --------      | ------------- |  | -------- | ------------- |\n                | 4             | 2             |  | 4        | 3             |\n                | --------      | ------------- |  | -------- | ------------- |\n\n          | --------------- | ------- |\n          | Version History |\n          | --------------- | ------------------- |\n          | Event ID        | Version             |\n          | --------------- | -------             |\n          | 2               | 1                   |\n          | 3               | 2                   |\n          | --------------- | -------             |\n          |                 |\n          | -------         | ------------------- |\n          |                 |\n          | --------------- | -------             |  | --------------- | ------- |\n          | Event ID        | Version             |  | Event ID        | Version |\n          | --------------- | -------             |  | --------------- | ------- |\n          | 4               | 2                   |  | 4               | 3       |\n          | --------------- | -------             |  | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Initializing Default Authorizer in Go\nDESCRIPTION: Creates a new default authorizer instance to handle API call authorization in Temporal Server. This is used when configuring authorization for the server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_5\n\nLANGUAGE: go\nCODE:\n```\na := authorization.NewDefaultAuthorizer()\n```\n\n----------------------------------------\n\nTITLE: Querying Workflow State in Python\nDESCRIPTION: Command to query the state of a running workflow by its ID. This retrieves the current value from the workflow without interrupting its execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python starter.py --query-workflow initial-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Workflow Gateway (Go Example)\nDESCRIPTION: This command compiles and runs the main Go file for the gateway component, which is responsible for starting the Temporal Workflow execution in the sessions example. It requires Go to be installed and depends on the Temporal Cluster being available.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/sessions/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo run sessions/gateway/main_dacx.go\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow with Reason in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the reason modifier. This allows specifying a reason for resetting the Workflow Execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --reason <string>\n```\n\n----------------------------------------\n\nTITLE: Describing a Temporal Task Queue using tctl (Bash)\nDESCRIPTION: Describes the poller information for a specified Temporal Task Queue. The `--taskqueue` modifier is required to specify the target queue name (`<value>`). This command is part of the deprecated `tctl` utility.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/taskqueue.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl taskqueue describe --taskqueue <value>\n```\n\n----------------------------------------\n\nTITLE: Sending an Update to the Validated Workflow (Go)\nDESCRIPTION: This command compiles and runs the Go program that sends an update to the Workflow equipped with a validator. It takes a positive integer `i` as input via the command line. The Workflow's validator function will check this input before the update handler is executed. Providing a non-positive integer will result in a validation error. Requires a running instance of the validated Workflow started via `validstarter/main.go`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ngo run validupdate/main.go i\n```\n\n----------------------------------------\n\nTITLE: Calculating P99 Replication Lag Histogram in PromQL\nDESCRIPTION: This PromQL query calculates the 99th percentile (P99) of the replication lag for Temporal Cloud High Availability Namespaces. It aggregates the rate of replication lag histogram buckets over a dynamic interval (`$__rate_interval`) and groups the results by Temporal Namespace. This metric helps understand the upper-bound latency for 99% of replication events.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/monitor.mdx#2025-04-23_snippet_0\n\nLANGUAGE: promql\nCODE:\n```\nhistogram_quantile(0.99, sum(rate(temporal_cloud_v0_replication_lag_bucket[$__rate_interval])) by (temporal_namespace, le))\n```\n\n----------------------------------------\n\nTITLE: Listing Multiple Workflow Pages\nDESCRIPTION: Command to list more than one page of workflow results using the --more flag\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow list --more\n```\n\n----------------------------------------\n\nTITLE: Specifying Operator Identity for tctl Activity Completion (Bash)\nDESCRIPTION: This command shows how to specify the operator's identity using the `--identity` modifier when completing a Temporal Activity Execution with the deprecated `tctl` tool. Replace `<value>` with the operator's identity string. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --identity <value>\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Dev Server with Updates Enabled (CLI)\nDESCRIPTION: This command starts the Temporal development server using the Temporal CLI. The `--dynamic-config-value frontend.enableUpdateWorkflowExecution=true` flag is crucial for enabling the Workflow Update feature, which might be necessary for Temporal Server versions older than 1.21.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntemporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecution=true\n```\n\n----------------------------------------\n\nTITLE: Terminating a tctl Batch Job (Bash)\nDESCRIPTION: Stops a running `tctl` batch job before it completes. It requires the Job ID of the target batch job specified via the `--job_id` modifier. Termination does not roll back already completed operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch terminate --job_id <id>\n```\n\n----------------------------------------\n\nTITLE: Basic Text-Type Search Attribute List Filter\nDESCRIPTION: Example of a List Filter that matches a specific word in a Text-type Search Attribute. This matches whole words but not partial words.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nDescription = 'foobar'\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in Python SDK (v1.6.0+)\nDESCRIPTION: Example of updating an API key for an existing Temporal client connection in Python SDK version 1.6.0 or higher.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmy_client.api_key = my_key_updated\n```\n\n----------------------------------------\n\nTITLE: Setting Configuration Refresh Interval (refreshInterval) in Temporal Web UI (YAML)\nDESCRIPTION: Determines how frequently the Temporal Web UI server re-reads its configuration file to apply changes. Currently, only TLS settings are updated dynamically on refresh. Uses duration format (e.g., '1m' for one minute).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nrefreshInterval: 1m\n```\n\n----------------------------------------\n\nTITLE: Setting page size in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that specifies the maximum number of Workflow Executions to list on a page (default is 2000).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --pagesize <value>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Conflicting Update in Cluster B (T=1)\nDESCRIPTION: This table shows the state in Cluster B at T=1 after adding event ID 4 with version 2. This update occurs concurrently with a failover and an update in Cluster C.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 2               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Multiple Search Attributes Creation - Pre-v1.20\nDESCRIPTION: Bash function to create multiple custom Search Attributes without namespace association, for Temporal Server v1.19 and earlier or Elasticsearch.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nadd_custom_search_attributes() {\n       echo \"Adding Custom*Field search attributes.\"\n       temporal operator search-attribute create \\\n        --name=\"CustomKeywordField\" --type=\"Keyword\" \\\n        --name=\"CustomStringField\" --type=\"Text\" \\\n        --name=\"CustomTextField\" --type=\"Text\" \\\n        --name=\"CustomIntField\" --type=\"Int\" \\\n        --name=\"CustomDatetimeField\" --type=\"Datetime\" \\\n        --name=\"CustomDoubleField\" --type=\"Double\" \\\n        --name=\"CustomBoolField\" --type=\"Bool\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running Caller Worker with API Key Authentication - Go CLI\nDESCRIPTION: Demonstrates running the caller worker for Temporal Cloud with API key-based authentication. Requires entering the 'caller' directory, running the worker Go program, and specifying the Temporal endpoint, caller namespace, and API key as flags. Facilitates secure key-based access for workloads and is suited for environments where certificate management is avoided.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_18\n\nLANGUAGE: go\nCODE:\n```\ncd caller\n\ngo run ./worker \\\n\t-target-host <region>.<cloud_provider>.api.temporal.io:7233 \\\n\t-namespace <your-caller-namespace.account> \\\n\t-api-key <your-api-key>\n```\n\n----------------------------------------\n\nTITLE: Configuring Bash Auto-completion\nDESCRIPTION: Commands to enable Temporal CLI auto-completion in Bash shell\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\neval \"$(temporal completion bash)\"\n```\n\n----------------------------------------\n\nTITLE: Creating Namespaces for Temporal Nexus\nDESCRIPTION: Commands to create separate Namespaces for the caller and handler applications, which are required before setting up Nexus endpoints.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace create --namespace my-target-namespace\ntemporal operator namespace create --namespace my-caller-namespace\n```\n\n----------------------------------------\n\nTITLE: Completing a tctl Activity using Workflow ID (Bash)\nDESCRIPTION: This command demonstrates how to complete a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Workflow ID with the `--workflow_id` (or `-w`) modifier. Replace `<id>` with the actual Workflow ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --workflow_id <id>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cluster System Information\nDESCRIPTION: Provides information about the system the Cluster is running on, useful for diagnosing problems with the Temporal Server.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/operator.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator cluster system\n```\n\n----------------------------------------\n\nTITLE: Basic Signal Command Structure\nDESCRIPTION: Template showing the two basic patterns for sending signals using tctl workflow command\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_60\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow signal --workflow_id <id> <modifiers>\n```\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow signal --query <query> <modifiers>\n```\n\n----------------------------------------\n\nTITLE: Pseudocode Example of Temporal Workflow with Retry Configuration\nDESCRIPTION: A pseudocode example showing how to configure retry policies and timeouts for Activities in a loan application workflow, demonstrating Temporal's built-in fault-tolerance capabilities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-sdks.mdx#2025-04-23_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nfunc LoanApplicationWorkflow {\n\n    options = {\n        MaxAttempts: 3,\n        StartToCloseTimeout: 30min,\n        HeartbeatTimeout: 10min,\n    }\n\n    sdk.ExecuteActivity(CreditCheck, options)\n\n    sdk.ExecuteActivity(AutomatedApproval)\n\n    sdk.ExecuteActivity(NotifyApplicant)\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Printing event version in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that includes event version information in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --print_event_version\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Header\nDESCRIPTION: YAML frontmatter defining document metadata including ID, title, description, and navigation properties for the documentation page.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/timers-delays.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: timers-delays\ntitle: Timers and Start Delays\nsidebar_label: Timers and Start Delays\ndescription: Temporal SDKs offer Timer APIs so that Workflow Executions are deterministic in their handling of time values.\nslug: /workflow-execution/timers-delays\nkeywords:\n  - timers\n  - start delay\n  - scheduling\ntags:\n  - Concepts\n  - Workflows\n---\n```\n\n----------------------------------------\n\nTITLE: Dynamic Configuration Key for Workflow Callbacks\nDESCRIPTION: Configuration key that controls the maximum number of callbacks that can be attached to a single Workflow Execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/limits.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nMaxCallbacksPerWorkflow\n```\n\n----------------------------------------\n\nTITLE: Keyword BETWEEN List Filter Example\nDESCRIPTION: Example of a List Filter using the BETWEEN operator to match WorkflowIds with a specific prefix and characters within a certain ASCII range.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId BETWEEN \"order-\" AND \"order-~\"\n```\n\n----------------------------------------\n\nTITLE: Temporal Workflow Schedule Cron String Format Explanation\nDESCRIPTION: Illustrates the format of a cron string used for Temporal Workflow Schedules. It breaks down the five components: minute (0-59), hour (0-23), day of the month (1-31), month (1-12), and day of the week (0-6, Sunday to Saturday). This is purely informational.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Executing Temporal Schedule Example Scripts using Poetry (Bash)\nDESCRIPTION: This set of commands uses Poetry to run several distinct Python scripts, each demonstrating a specific interaction with Temporal Schedules. `start_schedule_dacx.py` likely creates a schedule, while the others perform operations like backfilling, deleting, describing, toggling (pausing/unpausing), and updating existing schedules. These scripts should be run after the Worker has been started.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/schedule_your_workflow/readme.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python start_schedule_dacx.py\npoetry run python backfill_schedule_dacx.py\npoetry run python delete_schedule_dacx.py\npoetry run python describe_schedule_dacx.py\npoetry run python toggle_schedule_dacx.py\npoetry run python update_schedule_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Helm Deployment Success Output - Bash\nDESCRIPTION: This sample output logs a successful Helm deployment for the promql-to-dd-go integration in Kubernetes. It confirms the deployed release and provides metadata (deployment time, namespace, status, revision, notes). Inputs: None. Outputs: Informational feedback on deployment state. Dependencies: None; provided for user reference.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nNAME: promqltodd\\nLAST DEPLOYED: [Deployment Time]\\nNAMESPACE: default\\nSTATUS: deployed\\nREVISION: 1\\nTEST SUITE: None\\nNOTES:\\nThank you for installing promql-to-dd-go.\n```\n\n----------------------------------------\n\nTITLE: Signaling and Querying Workflow\nDESCRIPTION: Example showing how to signal a workflow to update its greeting and then query its state\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow signal --workflow_id \"HelloQuery\" --name \"updateGreeting\" --input \\\"Bye\\\"\ntctl workflow query --workflow_id \"HelloQuery\" --query_type \"getCount\"\n```\n\n----------------------------------------\n\nTITLE: Listing Cluster Search Attributes using tctl (v1.17) in Bash\nDESCRIPTION: This command retrieves and lists all Search Attributes configured for the Temporal Cluster. These attributes can be used for filtering and querying Workflow Executions using other `tctl` commands like `tctl workflow list`, `tctl workflow run`, and `tctl workflow start`. The command requires `tctl` to be installed and configured to communicate with the target Temporal Cluster. It has no modifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/cluster.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl cluster get-search-attributes\n```\n\n----------------------------------------\n\nTITLE: Querying History Service Persistence Error Rate by Type using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of persistence errors (`persistence_error_with_type`) encountered by the History Service (`service_name=\"history\"`) over the last 1 minute, aggregated by error type (`error_type`). It uses a variable `$service`. This provides more specific insight into the nature of persistence errors.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_15\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(persistence_error_with_type{service=\"$service\",service_name=\"history\"}[1m])) by (error_type)\n```\n\n----------------------------------------\n\nTITLE: Starting a Specific Type of tctl Batch Job (Bash)\nDESCRIPTION: Starts a `tctl` batch job for a specified operation type (`signal`, `cancel`, or `terminate`) using the `--batch_type` modifier. The `--query` modifier selects the target Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --batch_type <operation>\n```\n\n----------------------------------------\n\nTITLE: Removing CA Certificate by Fingerprint - tcld CLI - Bash\nDESCRIPTION: Removes a CA certificate from the metrics endpoint by specifying its fingerprint with --ca-certificate-fingerprint. When this parameter is used, certificate file or value parameters are ignored. This is useful when the exact certificate fingerprint is known and minimizes ambiguity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca remove --ca-certificate-fingerprint <fingerprint>\n```\n\n----------------------------------------\n\nTITLE: Defining Blob Size Limits in Temporal Frontend Service (Go)\nDESCRIPTION: Go constants defining the warning (`blobSizeWarn`) and error (`blobSizeError`) limits for blob sizes within the Temporal frontend service. These apply to Payloads, Workflow context, arguments, and return values, set at 256 KB and 2 MB respectively.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/defaults.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nblobSizeWarn  = 256 * 1024\nblobSizeError = 2 * 1024 * 1024\n```\n\n----------------------------------------\n\nTITLE: Dynamic Configuration Keys for Workflow Execution Limits\nDESCRIPTION: Configuration keys that control the maximum number of pending operations in a Workflow Execution. These include limits for activities, child executions, signals, and cancel requests.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/limits.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nNumPendingActivitiesLimit\nNumPendingChildExecutionsLimit\nNumPendingSignalsLimit\nNumPendingCancelRequestsLimit\n```\n\n----------------------------------------\n\nTITLE: Dynamic Configuration Key for Nexus Operations\nDESCRIPTION: Configuration key that sets the maximum number of concurrent Nexus Operations allowed before Continue-As-New is required.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/limits.mdx#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nMaxConcurrentOperations\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in Python SDK (pre v1.6.0)\nDESCRIPTION: Example of updating an API key for an existing Temporal client connection in Python SDK versions prior to 1.6.0.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmy_client.rpc_metadata = {\"Authorization\": f\"Bearer {<my_key_updated>}\"}\n```\n\n----------------------------------------\n\nTITLE: Adding Compatible Build ID to Existing Set in Java (Deprecated)\nDESCRIPTION: This deprecated code shows how to add a new Build ID to an existing compatible set on a Task Queue. It marks the new Build ID as the default for that set.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.newCompatibleVersion(\"deadbeef\", \"some-existing-build-id\"));\n```\n\n----------------------------------------\n\nTITLE: Marking a Binary as Bad for a Namespace using tctl\nDESCRIPTION: Adds a binary checksum to the list of 'bad binaries' for a Namespace using the `--add_bad_binary <value>` modifier with `tctl namespace update`. Temporal avoids dispatching commands to workers reporting this binary checksum, often used when resetting Workflow Executions. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --add_bad_binary <value>\n```\n\n----------------------------------------\n\nTITLE: Listing Search Attributes - Basic\nDESCRIPTION: Command to list all Search Attributes in the Visibility store.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator search-attribute list\n```\n\n----------------------------------------\n\nTITLE: Setting up Temporal with Elasticsearch in Docker Compose\nDESCRIPTION: Docker Compose configuration that adds Elasticsearch to a Temporal deployment for advanced visibility features. This setup includes the Elasticsearch service and configures Temporal to use it for search capabilities.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/Google/vocab.txt#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3.5'\n\nservices:\n  elasticsearch:\n    image: elasticsearch:${ELASTICSEARCH_VERSION}\n    environment:\n      - discovery.type=single-node\n      - ES_JAVA_OPTS=-Xms100m -Xmx100m\n      - xpack.security.enabled=false\n    ports:\n      - 9200:9200\n  temporal:\n    image: temporalio/auto-setup:${TEMPORAL_VERSION}\n    environment:\n      # ... other environment variables ...\n      - ENABLE_ES=true\n      - ES_SEEDS=elasticsearch\n      - ES_VERSION=v7\n```\n\n----------------------------------------\n\nTITLE: Sample Workflow Output Log - Shell\nDESCRIPTION: This log output shows the expected results of running the caller workflow, featuring two result messages: one in English ('Nexus Echo') and one in Spanish ('¡Hola! Nexus'). Indicates multi-locale workflow communication success. Outputs are printed to the Go application's standard output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n2024/10/04 19:57:40 Workflow result: Nexus Echo 👋\n2024/10/04 19:57:40 Workflow result: ¡Hola! Nexus 👋\n```\n\n----------------------------------------\n\nTITLE: Specifying Proto File Path for BloomRPC\nDESCRIPTION: Specifies the file path to the `service.proto` definition for the Temporal WorkflowService. This path is used within the BloomRPC application to import the gRPC service definitions after cloning the `temporalio/api` repository.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/server-frontend-api-reference.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n/path/to/api/temporal/api/workflowservice/v1/service.proto\n```\n\n----------------------------------------\n\nTITLE: Running Handler Worker with TLS Certificates - Go CLI\nDESCRIPTION: This Go CLI command sequence is for starting the handler worker process in Temporal Cloud with TLS certificate authentication. The user must change directory to 'handler' and run the worker program using `go run`, passing flags for the target host, namespace, and TLS client credentials. Requires installed Go toolchain, handler source code, valid CA certificate, and private key file. Ensures encrypted and authenticated communication with Temporal Cloud for workflow execution, scoped to the handler namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_13\n\nLANGUAGE: go\nCODE:\n```\ncd handler\n\ngo run ./worker \\\n\t-target-host <your-target-namespace.account>.tmprl.cloud:7233 \\\n\t-namespace <your-target-namespace.account> \\\n\t-client-cert 'path/to/your/ca.pem' \\\n\t-client-key 'path/to/your/ca.key'\n```\n\n----------------------------------------\n\nTITLE: Completing a tctl Activity using Activity ID (Bash)\nDESCRIPTION: This command illustrates completing a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Activity ID with the `--activity_id` modifier. Replace `<id>` with the actual Activity ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --activity_id <id>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Specific Environment Property with Temporal CLI\nDESCRIPTION: Demonstrates how to retrieve a specific property from an environment configuration using dot notation to specify the exact property needed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env get local.tls-key-path\n```\n\n----------------------------------------\n\nTITLE: Showing only reset-eligible events in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that filters output to show only events eligible for reset.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --reset_points_only\n```\n\n----------------------------------------\n\nTITLE: Installing tctl via Homebrew\nDESCRIPTION: This command installs the tctl command-line tool locally using the Homebrew package manager on macOS or Linux.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/index.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbrew install tctl\n```\n\n----------------------------------------\n\nTITLE: Setting Heartbeat Timeout via WorkflowImplementationOptions in Temporal Java SDK\nDESCRIPTION: Demonstrates configuring per-activity-type heartbeat timeout using WorkflowImplementationOptions. The snippet shows mapping an activity name to ActivityOptions with specified start-to-close and heartbeat timeouts using an immutable map. Applies when registering workflow implementations, allowing global per-activity settings. Requires Temporal Java SDK, immutable collections, and correct activity type naming.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/failure-detection.mdx#2025-04-23_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\\n            WorkflowImplementationOptions.newBuilder()\\n                    .setActivityOptions(\\n                            ImmutableMap.of(\\n                              \\\"EmailCustomerGreeting\\\",\\n                                    ActivityOptions.newBuilder()\\n                                        // note that either StartToCloseTimeout or ScheduleToCloseTimeout are\\n                                        // required when setting Activity options.\\n                                          .setStartToCloseTimeout(Duration.ofSeconds(5))\\n                                          .setHeartbeatTimeout(Duration.ofSeconds(2))\\n                                          .build()))\\n                    .build();\n```\n\n----------------------------------------\n\nTITLE: Unpausing Activities in Bulk with Temporal CLI\nDESCRIPTION: Command example for unpausing multiple Activities using a visibility query filter. This allows for bulk management of paused Activities rather than addressing them individually by ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/activity.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal activity unpause --query YourQuery \\\n    --reason YourReasonForUnpause\n```\n\n----------------------------------------\n\nTITLE: Enabling Workflow Update feature in Temporal CLI\nDESCRIPTION: Commands to enable the Workflow Update feature in versions prior to v1.25.0 using the Temporal CLI. This sets the required dynamic config values to true.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow-message-passing/sending-messages.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecution=true\ntemporal server start-dev --dynamic-config-value frontend.enableUpdateWorkflowExecutionAsyncAccepted=true\n```\n\n----------------------------------------\n\nTITLE: Sample Output from Money Transfer Workflow\nDESCRIPTION: Example output displayed after executing the money transfer workflow, showing the withdrawal and deposit operations with transaction details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/workflow_failures/README.md#2025-04-23_snippet_3\n\nLANGUAGE: output\nCODE:\n```\nTransfer complete.\n    Withdraw: {'amount': 250, 'receiver': '43-812', 'reference_id': 'cf82526f-383a-44e4-8e34-b664a98e80c7', 'sender': '85-150'}\n    Deposit: {'amount': 250, 'receiver': '43-812', 'reference_id': 'cf82526f-383a-44e4-8e34-b664a98e80c7', 'sender': '85-150'}\n```\n\n----------------------------------------\n\nTITLE: Non-Matching Partial Word List Filter\nDESCRIPTION: Example of a List Filter that fails to match because it's looking for a partial word in a Text-type Search Attribute.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n// Doesn't match\nDescription = 'foo'\n```\n\n----------------------------------------\n\nTITLE: Specifying Versioning Intent for Activity Execution in Python (Legacy)\nDESCRIPTION: Demonstrates overriding the default versioning behavior for an Activity execution in Python. By setting `versioning_intent=VersioningIntent.USE_ASSIGNMENT_RULES`, the Activity is dispatched based on the latest assignment rules for its Task Queue, rather than inheriting the version from the parent Workflow. Note that Python support for this specific feature was marked as under construction.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/worker-versioning-legacy.mdx#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# ...\nawait workflow.execute_activity(\n    say_hello,\n    \"hi\",\n    versioning_intent=VersioningIntent.USE_ASSIGNMENT_RULES,\n    start_to_close_timeout=timedelta(seconds=5),\n)\n# ...\n```\n\n----------------------------------------\n\nTITLE: Starting Example Scheduler via Command Line Interface - Bash\nDESCRIPTION: This command starts the example scheduler that creates scheduled workflows with the Temporal Go SDK. It requires Go to be installed and the schedule/create/main_dacx.go source file available. Expected input: none. Output: creates and schedules workflows which can then be verified in the Temporal web interface.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/schedules/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run schedule/create/main_dacx.go\n```\n\n----------------------------------------\n\nTITLE: Git Commands for Staging Changes\nDESCRIPTION: Series of git commands to stage, commit and push documentation changes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit status                         # Check the status of your changes\ngit add <file-name>                # Stage files individually\ngit commit -m \"Documentation Change\"           # Commit your changes\ngit push origin my-documentation-contribution  # Push changes\n```\n\n----------------------------------------\n\nTITLE: Printing full message in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that displays the full message without table formatting.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_full\n```\n\n----------------------------------------\n\nTITLE: Disabling Workflow Reset (workflowResetDisabled) in Temporal Web UI (YAML)\nDESCRIPTION: A boolean flag to specifically disable the ability for users to reset Workflow Executions from the Temporal Web UI. Set to `true` to disable. Defaults to `false`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nworkflowResetDisabled: false\n```\n\n----------------------------------------\n\nTITLE: Date Range Filter with Comparison Operators\nDESCRIPTION: List Filter that matches Workflows with ExecutionTime outside a specific date range using comparison operators.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\nExecutionTime < '2021-08-28T15:04:05+00:00' or ExecutionTime > '2021-08-22T15:04:05+00:00'\n```\n\n----------------------------------------\n\nTITLE: Querying Schedule Rate Limited Events - PromQL\nDESCRIPTION: PromQL query to measure the rate of schedule executions that were rate limited within a 5-minute interval. Helps identify scheduling patterns hitting namespace rate limits.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_19\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(schedule_rate_limited{namespace=\"$namespace\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Poetry (Bash)\nDESCRIPTION: Installs Python project dependencies defined in the `pyproject.toml` file using the Poetry package manager. This step is required before running any of the Python worker scripts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Configuring Fish Auto-completion\nDESCRIPTION: Commands to set up Fish shell auto-completion for Temporal CLI\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_9\n\nLANGUAGE: fish\nCODE:\n```\nmkdir -p ~/.config/fish/completions\n```\n\nLANGUAGE: fish\nCODE:\n```\necho 'eval \"$(temporal completion fish)\"' >~/.config/fish/completions/temporal.fish\n```\n\nLANGUAGE: fish\nCODE:\n```\nsource ~/.config/fish/completions/temporal.fish\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting Temporal Server Locally\nDESCRIPTION: Command to install Temporal using Homebrew and start the development server with a custom UI port and database file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/typescript/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nbrew install temporal\ntemporal server start-dev --ui-port 8080 --db-filename clusterdata.db\n```\n\n----------------------------------------\n\nTITLE: Adding Temporal Testing Dependency with Gradle\nDESCRIPTION: Gradle dependency configuration to add temporal-testing library using Groovy DSL.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_1\n\nLANGUAGE: groovy\nCODE:\n```\ntestImplementation (\"io.temporal:temporal-testing:1.17.0\")\n```\n\n----------------------------------------\n\nTITLE: Interval Schedule Format\nDESCRIPTION: Shows the format for specifying interval-based schedules using time.ParseDuration compatible strings.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/cron-job.mdx#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n@every <duration>\n```\n\n----------------------------------------\n\nTITLE: GCP PSC Service Name for us-west1\nDESCRIPTION: The Google Cloud Private Service Connect (PSC) Service Attachment Name required to connect to Temporal Cloud in the `us-west1` region. Use this identifier when configuring your private endpoint.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/references/regions/private-service.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nprojects/prod-rbe76zxxzydz4cbdz2xt5b59q/regions/us-west1/serviceAttachments/pl-94w0x\n```\n\n----------------------------------------\n\nTITLE: Adding Event in Cluster B During Potential Conflict in Temporal\nDESCRIPTION: This snippet demonstrates adding an event with ID 4 and version 2 in Cluster B. This is part of an example showing how version history handles potential conflicts across clusters.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| -------- | ------------- | --------------- | ------- |\n| Events   | Version History |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 4               | 2       |\n| 3        | 2               |                 |         |\n| 4        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Removing Search Attribute - Elasticsearch\nDESCRIPTION: Command to remove a custom Search Attribute in Elasticsearch-based Visibility store.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator search-attribute remove \\\n    --name=\"your_custom_attribute\"\n```\n\n----------------------------------------\n\nTITLE: Adding a Region to a Temporal Cloud Namespace using tcld (Bash)\nDESCRIPTION: This command adds a replica region to an existing Temporal Cloud Namespace, upgrading it to High Availability. It requires specifying the target namespace and the new region to add. This operation is asynchronous.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace add-region \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <replica_region>\n```\n\n----------------------------------------\n\nTITLE: Starting a Caller Workflow with Local Development Server\nDESCRIPTION: Bash command to initiate a Nexus caller Workflow in a local development environment. This starts a Workflow that will make Nexus calls to another namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.caller.CallerStarter \\\n    --args=\"-target-host localhost:7233 -namespace my-caller-namespace\"\n```\n\n----------------------------------------\n\nTITLE: Describing Pending Nexus Operations with Temporal CLI\nDESCRIPTION: This command shows pending Nexus Operations in the caller Workflow and attached callbacks on the handler Workflow. Replace <ID> with the actual Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow describe -w <ID>\n```\n\n----------------------------------------\n\nTITLE: Enabling Secondary Visibility Store as Read Source in Temporal\nDESCRIPTION: YAML configuration that enables reading from the secondary visibility store during database migration. This configuration maintains dual writing to both stores but switches reads to come from the secondary store for validation before completing migration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\nsystem.secondaryVisibilityWritingMode:\n- value: \"dual\"\nconstraints: {}\nsystem.enableReadFromSecondaryVisibility:\n- value: true\nconstraints: {}\n```\n\n----------------------------------------\n\nTITLE: Starting a Caller Workflow with TLS Certificates - Go CLI\nDESCRIPTION: This CLI snippet shows how to start a workflow from the caller Namespace by executing the starter Go program using TLS certificates for authentication. It requires navigation to the 'caller' directory and supplying the Temporal Cloud host, namespace, and certificate flags. Inputs are the required connection options, and outputs include workflow execution with returned results visible in logs. Prerequisites include Go environment, starter program, and valid TLS credentials.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_15\n\nLANGUAGE: go\nCODE:\n```\ncd caller\n\ngo run ./starter \\\n\t-target-host <your-caller-namespace.account>.tmprl.cloud:7233 \\\n\t-namespace <your-caller-namespace.account> \\\n\t-client-cert 'path/to/your/ca.pem' \\\n\t-client-key 'path/to/your/ca.key'\n```\n\n----------------------------------------\n\nTITLE: Setting Visibility Archival URI during Namespace Registration with tctl\nDESCRIPTION: Specifies the URI for storing archived Visibility records using the `--visibility_uri <uri>` modifier with `tctl namespace register`. This URI cannot be changed after Archival is enabled for the first time. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --visibility_uri <uri>\n```\n\n----------------------------------------\n\nTITLE: Starting the Basic Temporal Workflow (Go)\nDESCRIPTION: This command compiles and runs the Go program that acts as a starter. It initiates an execution of the basic Workflow (without update validation) defined in the sample application.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngo run starter/main.go\n```\n\n----------------------------------------\n\nTITLE: Printing search attributes in tctl workflow scan command\nDESCRIPTION: Command modifier for the workflow scan command that includes Search Attributes in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow scan --print_search_attr\n```\n\n----------------------------------------\n\nTITLE: Illustrating Divergent History Tree After Replication (T=2)\nDESCRIPTION: This textual representation depicts the state at T=2 after replication tasks have been exchanged between Cluster B and Cluster C. It shows the event history has diverged into two branches, one ending with event 4 (version 2) and the other ending with event 4 (version 3). The version history reflects the common ancestor state.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n| ------------- | ------------- |\n| Events         |               |\n| -------------- | ------------- |\n| Event ID       | Event Version |\n| -------------  | ------------- |\n| 1              | 1             |\n| 2              | 1             |\n| 3              | 2             |\n| -------------  | ------------- |\n|                |               |\n| -------------  | ------------- |\n|                |               |\n| -------------- | ------------- |  | -------- | ------------- |\n| Event ID       | Event Version |  | Event ID | Event Version |\n| -------------  | ------------- |  | -------- | ------------- |\n| 4              | 2             |  | 4        | 3             |\n| -------------- | ------------- |  | -------- | ------------- |\n\n| --------------- | ----------- |\n| Version History |              |\n| --------------- | ------------ |\n| Event ID        | Version      |\n| --------------- | ------------ |\n| 2               | 1            |\n| 3               | 2            |\n| --------------- | ------------ |\n\n| --------------- | ----------- |  | --------------- | ------- |\n| Event ID | Version |  | Event ID | Version |\n| -------- | ------- || --------------- | ------- |\n| 4   | 2   |  | 4 | 3 |\n| --- | --- || --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Adding Temporal Testing Dependency with Maven\nDESCRIPTION: Maven dependency configuration to add temporal-testing library to the project.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/testing-suite.mdx#2025-04-23_snippet_0\n\nLANGUAGE: maven\nCODE:\n```\n<dependency>\n    <groupId>io.temporal</groupId>\n    <artifactId>temporal-testing</artifactId>\n    <version>1.17.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Out-of-Order Event Replication Between Clusters\nDESCRIPTION: This ASCII diagram depicts a scenario in Temporal Multi-cluster Replication where asynchronous network communication causes replication events for Run 2 to arrive at Cluster B before the events for Run 1, even if Run 1 occurred logically earlier on Cluster A. This out-of-order arrival is key to understanding the potential creation of 'zombie' workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/temporal-service/multi-cluster-replication.mdx#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n| ------------- |          | ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n        |                          |                          |\n        | Run 1 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        | Run 2 Replication Events |                          |\n        | -----------------------> |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          |                          |\n        |                          | Run 2 Replication Events |\n        |                          | -----------------------> |\n        |                          |                          |\n        |                          | Run 1 Replication Events |\n        |                          | -----------------------> |\n        |     |  | \n        | --- || ------------- |          | ------------- |\n| Cluster A |  | Network Layer |  | Cluster B |\n| --------- || ------------- |          | ------------- |\n```\n\n----------------------------------------\n\nTITLE: Starting Dynamic Activity Worker (Bash/Python)\nDESCRIPTION: Executes the Python script `your_worker_activity_dacx.py` using `poetry run`. This script starts a Temporal Worker configured to listen for tasks on the `dynamic-activity-task-queue` and handle dynamic activities (activity invocations for which no specific function is registered).\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python your_worker_activity_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Defining Workflow Parameters in Java\nDESCRIPTION: Demonstrates how to define custom parameters for a Workflow method using a custom object.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\npublic interface YourWorkflow {\n    @WorkflowMethod\n    String yourWFMethod(CustomObj customobj);\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Workflow Execution (Go/Bash)\nDESCRIPTION: This command compiles and runs the Go program located at `starter/main.go`. It initiates a new Workflow Execution on the Temporal Cluster, which will be picked up by a running Worker. Requires Go, a running Temporal cluster, and a running Worker.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/cancellation/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo run starter/main.go\n```\n\n----------------------------------------\n\nTITLE: Using DocsTable Component for Complex Tables in MDX\nDESCRIPTION: Example showing how to use the DocsTable component with column definitions and NewDocsCell separators to create tables that support complex Markdown formatting inside cells.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<DocsTable Columns = {[\"\", \"Column 1\", \"Column 2\"]} >\n\nRow Title\n\n<NewDocsCell />\n\nColumn 1 Markdown content\n\n<NewDocsCell />\n\nColumn 2 Markdown content\n\n</DocsTable>\n```\n\n----------------------------------------\n\nTITLE: Configuring Header Forwarding (forwardHeaders) in Temporal Web UI (YAML)\nDESCRIPTION: Defines a list of HTTP headers that should be forwarded by the Temporal Web UI server, typically used in proxy setups. This example shows an empty list, meaning no specific headers are configured for forwarding by default.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nforwardHeaders:\n  -\n```\n\n----------------------------------------\n\nTITLE: Configuring robots.txt for Temporal Documentation Site\nDESCRIPTION: A standard robots.txt configuration that allows all search engine crawlers to access the entire site and specifies the location of the XML sitemap for better indexing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/static/robots.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nUser-agent: *\nAllow: /\n\nSitemap: https://docs.temporal.io/sitemap.xml\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Worker Process (Go)\nDESCRIPTION: This command compiles and runs the Go program located at `worker/main_dacx.go`. This program acts as the Temporal Worker, responsible for polling task queues and executing Workflow and Activity logic defined in the application.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/yourapp/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo run worker/main_dacx.go\n```\n\n----------------------------------------\n\nTITLE: Starting HTTP Gateway Server (Go)\nDESCRIPTION: This command compiles and runs the Go program located at `gateway/main_dacx.go`. This program starts an HTTP server that likely acts as a gateway or frontend to interact with the Temporal application, potentially starting new Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/yourapp/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo run gateway/main_dacx.go\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Settings for Dual Visibility Mode in Temporal\nDESCRIPTION: YAML configuration for Temporal's dynamic configuration settings that control how visibility data is written and read. This example enables dual write mode to both primary and secondary stores while disabling reads from the secondary store during migration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nsystem.secondaryVisibilityWritingMode:\n- value: \"dual\"\nconstraints: {}\nsystem.enableReadFromSecondaryVisibility:\n- value: false\nconstraints: {}\n```\n\n----------------------------------------\n\nTITLE: Replaying Temporal Workflow History from History Object via Python (Bash)\nDESCRIPTION: Executes the `replay_history.py` Python script using `poetry run`. This script replays a specific Workflow's execution history directly using the Temporal History Object, often for testing or debugging determinism. Assumes the script is configured to target a specific Workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/replay_your_workflow/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python replay_history.py\n```\n\n----------------------------------------\n\nTITLE: Signaling External Temporal Workflows via Command-Line - command\nDESCRIPTION: This snippet provides command-line instructions for sending signals to an external Temporal workflow. The 'external_signal_worker.py' script runs the workflow worker, while 'external_signal_main.py' sends the external signal. Both should be run in separate terminals. Poetry is used for environment management, and the relevant Python scripts must exist and be compatible with Temporal's SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/signal_your_workflow/README.md#2025-04-23_snippet_1\n\nLANGUAGE: command\nCODE:\n```\n# terminal one\\npoetry run python external_signal_worker.py\\n# terminal two\\npoetry run python external_signal_main.py\n```\n\n----------------------------------------\n\nTITLE: Testing Manual Time Skipping in Temporal\nDESCRIPTION: Test implementation demonstrating manual time control using testEnv.sleep() to advance the test server's time.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/testing-suite.mdx#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntest('sleeperWorkflow counts days correctly', async () => {\n  const worker = await Worker.create({\n    connection: testEnv.nativeConnection,\n    taskQueue: 'test',\n    workflowsPath: require.resolve('./workflows'),\n  });\n\n  handle = await testEnv.client.workflow.start(sleeperWorkflow, {\n    workflowId: uuid4(),\n    taskQueue,\n  });\n\n  worker.run();\n\n  let numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 0);\n\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 1);\n\n  await testEnv.sleep('25 hours');\n  numDays = await handle.query(daysQuery);\n  assert.equal(numDays, 2);\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Worker Deployments via Temporal CLI\nDESCRIPTION: Command to start a Temporal development server with Worker Deployments enabled. This requires setting two dynamic configuration values: system.enableDeploymentVersions and frontend.workerVersioningWorkflowAPIs to true.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workers/worker-deployments.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev \\\n   --dynamic-config-value system.enableDeploymentVersions=true \\\n   --dynamic-config-value frontend.workerVersioningWorkflowAPIs=true\n```\n\n----------------------------------------\n\nTITLE: Example Entity ID for Microsoft Entra ID SAML Integration\nDESCRIPTION: Provides a concrete example of a correctly formatted Identifier (Entity ID) for Temporal Cloud SAML integration using Microsoft Entra ID. This example uses 'f45a2' as the placeholder Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nurn:auth0:prod-tmprl:f45a2-saml\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Job with JSON Input (Bash)\nDESCRIPTION: Starts a `tctl` batch job (typically for signaling) and provides input data in JSON format using the `--input` (or `-i`) modifier. The `--query` modifier selects the target Workflow Executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value> --input <json>\n```\n\n----------------------------------------\n\nTITLE: Starting a Caller Workflow Connected to Temporal Cloud\nDESCRIPTION: Bash command to initiate a Nexus caller Workflow in Temporal Cloud using mTLS certificates. This starts a Workflow that will make Nexus calls to another namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.caller.CallerStarter \\\n  --args=\"-target-host <your-caller-namespace.account>.tmprl.cloud:7233 \\\n  -namespace <your-caller-namespace.account> \\\n  -client-cert 'path/to/your/ca.pem' \\\n  -client-key 'path/to/your/ca.key'\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Data Converter WebSocket URL using tctl (Deprecated)\nDESCRIPTION: This command demonstrates the required usage of the deprecated `tctl dataconverter web` command. The mandatory `--web_ui_url` modifier is used to specify the WebSocket URL for a custom Data Converter that Temporal Web UI should connect to. Replace `<url>` with the actual WebSocket endpoint. Remember that `tctl` is deprecated in favor of `temporal cli`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/dataconverter.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl dataconverter web --web_ui_url <url>\n```\n\n----------------------------------------\n\nTITLE: Starting a Temporal Development Server for Nexus\nDESCRIPTION: Command to start a Temporal Development Server that automatically enables the Web UI, creates the default Namespace, and uses an in-memory database.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev\n```\n\n----------------------------------------\n\nTITLE: Printing datetime in tctl workflow show command\nDESCRIPTION: Command modifier for the workflow show command that displays formatted timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow show --print_datetime\n```\n\n----------------------------------------\n\nTITLE: Running Patched Workflow Worker in Python\nDESCRIPTION: Command to run the worker with the patched workflow implementation. This version contains both the old and new code paths wrapped in a patched block.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python worker.py --workflow patched\n```\n\n----------------------------------------\n\nTITLE: Terminating a tctl Batch Job with a Reason (Bash)\nDESCRIPTION: Stops a running `tctl` batch job and provides a reason for the termination using the `--reason` modifier. The `--job_id` modifier is required to identify the batch job.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch terminate --job_id <id> --reason <string>\n```\n\n----------------------------------------\n\nTITLE: Creating a New Temporal Project with TypeScript SDK - Bash\nDESCRIPTION: Uses npx to create a new Temporal application project using the '@temporalio/create' package. This generates standard boilerplate code and configuration to quickly scaffold a new project. Requires Node.js 16.15 or later; creates a directory called './your-app' with setup files.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx @temporalio/create@latest ./your-app\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Buggy Concurrent Signal Handler in Temporal Python (Python)\nDESCRIPTION: This snippet defines a faulty Workflow Signal handler in Python using the Temporal SDK, demonstrating a scenario where lack of concurrency control may lead to inconsistent state if multiple handler instances execute simultaneously. The handler sets instance variables in a non-atomic fashion, making it vulnerable to race conditions. This example is useful for illustrating concurrency pitfalls when writing async handlers in distributed workflows; no explicit dependencies are declared other than the Temporal Python SDK and possibly asyncio.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/message-passing.mdx#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@workflow.defn\nclass MyWorkflow:\n\n    @workflow.signal\n    async def bad_async_handler(self):\n        data = await workflow.execute_activity(\n            fetch_data, start_to_close_timeout=timedelta(seconds=10)\n        )\n        self.x = data.x\n        # 🐛🐛 Bug!! If multiple instances of this handler are executing concurrently, then\n        # there may be times when the Workflow has self.x from one Activity execution and self.y from another.\n        await asyncio.sleep(1)  # or await anything else\n        self.y = data.y\n```\n\n----------------------------------------\n\nTITLE: Illustrating `setHandler` Behavior in Temporal Workflows (TypeScript)\nDESCRIPTION: Provides a TypeScript example demonstrating that calling `wf.setHandler` multiple times for the same Signal definition (`MySignal`) replaces the previously set handler (`handlerFn1` is replaced by `handlerFn2`). This clarifies why the API is named `setHandler` rather than `subscribe`, as only one handler can be active at a time for a given Signal or Query. Requires the '@temporalio/workflow' package and assumes `MySignal`, `handlerFn1`, and `handlerFn2` are defined.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/message-passing.mdx#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nwf.setHandler(MySignal, handlerFn1);\nwf.setHandler(MySignal, handlerFn2); // replaces handlerFn1\n```\n```\n\n----------------------------------------\n\nTITLE: Describing Account-Level Permissions Matrix - Markdown Table - Markdown\nDESCRIPTION: This snippet provides a markdown-formatted table defining which API permissions are granted to users by different account-level roles. The table lists permissions such as creating API keys, viewing account details, and managing users, mapping them to roles from Read-only through Account Owner. This format requires no external dependencies, expects standard markdown-parsing support, and outputs a human-readable permissions matrix; modification of permissions or roles must be performed by editing table content directly.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/users.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Permission                        | Read-only | Developer | Finance Admin | Global Admin | Account Owner |\n| --------------------------------- | --------- | --------- | ------------- | ------------ | ------------- |\n| CountIdentities                   | ✔         | ✔         | ✔             | ✔            | ✔             |\n| CreateAPIKey                      | ✔         | ✔         | ✔             | ✔            | ✔             |\n| CreateNamespace                   |           | ✔         |               | ✔            | ✔             |\n| CreateNexusEndpoint               |           | ✔         |               | ✔            | ✔             |\n| CreateServiceAccount              |           |           |               | ✔            | ✔             |\n| CreateServiceAccountAPIKey        |           |           |               | ✔            | ✔             |\n| CreateStripeCustomerPortalSession |           |           | ✔             |              | ✔             |\n| CreateUser                        |           |           |               | ✔            | ✔             |\n| DeleteAPIKey                      | ✔         | ✔         | ✔             | ✔            | ✔             |\n| DeleteNexusEndpoint               |           | ✔         |               | ✔            | ✔             |\n| DeleteServiceAccount              |           |           |               | ✔            | ✔             |\n| DeleteUser                        |           |           |               | ✔            | ✔             |\n| GetAccount                        | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAccountFeatureFlags            | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAccountLimits                  | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAccountSettings                | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAccountUsage                   |           |           |               | ✔            | ✔             |\n| GetAPIKey                         | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAPIKeys                        | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetAsyncOperation                 | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetDecodedCertificate             | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetIdentities                     | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetIdentity                       | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetNamespaces                     | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetNamespacesUsage                |           |           |               | ✔            | ✔             |\n| GetNexusEndpoint                  | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetNexusEndpoints                 | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRegion                         | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRegions                        | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRequestStatus                  | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRequestStatuses                |           |           |               | ✔            | ✔             |\n| GetRequestStatusesForNamespace    | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRequestStatusesForUser         | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRoles                          | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetRolesByPermissions             | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetServiceAccount                 | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetServiceAccounts                | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetStripeInvoice                  |           |           | ✔             |              | ✔             |\n| GetUser                           | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetUsers                          | ✔         | ✔         | ✔             | ✔            | ✔             |\n| GetUsersWithAccountRoles          | ✔         | ✔         | ✔             | ✔            | ✔             |\n| InviteUsers                       |           |           |               | ✔            | ✔             |\n| ListCreditLedgerEntries           |           |           | ✔             |              | ✔             |\n| ListGrants                        |           |           | ✔             |              | ✔             |\n| ListMetronomeInvoices             |           |           | ✔             |              | ✔             |\n| ListMetronomeInvoicesForNamespace |           |           | ✔             |              | ✔             |\n| ListNamespaces                    | ✔         | ✔         | ✔             | ✔            | ✔             |\n| ListPromotionGrantBalances        |           |           | ✔             |              | ✔             |\n| ResendUserInvite                  |           |           |               | ✔            | ✔             |\n| SetAccountSettings                |           |           |               | ✔            | ✔             |\n| SyncCurrentUserInvite             | ✔         | ✔         | ✔             | ✔            | ✔             |\n| UpdateAccount                     |           |           |               | ✔            | ✔             |\n| UpdateAPIKey                      | ✔         | ✔         | ✔             | ✔            | ✔             |\n| UpdateNexusEndpoint               |           | ✔         |               | ✔            | ✔             |\n| UpdateServiceAccount              |           |           |               | ✔            | ✔             |\n| UpdateUser                        |           |           |               | ✔            | ✔             |\n```\n\n----------------------------------------\n\nTITLE: Checking Specific Build ID Reachability in Temporal CLI\nDESCRIPTION: This command checks the reachability of a specific Build ID (\"2.0\") using the Temporal CLI. It shows whether the Build ID is reachable by new Workflows and existing Workflows across different Task Queues.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/worker-versioning-legacy.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ntemporal task-queue get-build-id-reachability --build-id \"2.0\"\n```\n\n----------------------------------------\n\nTITLE: Testing GCP PSC Connection with Temporal CLI (API Key)\nDESCRIPTION: This command illustrates testing the Private Service Connect connection using the Temporal CLI with API key authentication. It connects to the PSC endpoint IP and port, specifies the target namespace (including the account ID: `<namespace>.<account>`), provides the API key, overrides the TLS server name to the regional Temporal Cloud API endpoint (`<region>.<cloud_provider>.api.temporal.io`), and explicitly enables TLS using the `--tls` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/gcp-private-service-connect.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow count \\\n    --address <IP address of the PSC endpoint>:7233 \\\n    --namespace <namespace>.<account> \\\n    --api-key <api_key> \\\n    --tls-server-name <region>.<cloud_provider>.api.temporal.io \\\n    --tls\n```\n\n----------------------------------------\n\nTITLE: Querying Active History Task Request Rate using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of active task processing requests (`task_requests`) within the History Service over the last 1 minute. It filters for operations matching the pattern `TransferActive.*` and uses a variable `$service` for the specific service instance. This monitors the rate at which active history tasks are being initiated.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_8\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(task_requests{service=\"$service\",operation=~\"TransferActive.*\"}[1m]))\n```\n\n----------------------------------------\n\nTITLE: Running Nexus Caller Worker for Local Development\nDESCRIPTION: Bash command to run a Nexus caller Worker connected to a local development server. This worker initiates Nexus operations from the caller namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.caller.CallerWorker \\\n    --args=\"-target-host localhost:7233 -namespace my-caller-namespace\"\n```\n\n----------------------------------------\n\nTITLE: Checking Cluster Health using tctl (v1.17) in Bash\nDESCRIPTION: This command checks the health status of the Temporal Cluster's Frontend Service. It's a quick way to verify if the service responsible for handling API requests is operational. The command requires `tctl` to be installed and connected to the cluster. It takes no arguments or modifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/cluster.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntctl cluster health\n```\n\n----------------------------------------\n\nTITLE: Building Temporal UI Docker Image with Custom Config\nDESCRIPTION: Shell command for building the Temporal UI Docker image with a custom configuration file. This approach allows for customizing the UI settings by mounting a local configuration file into the container.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/Google/vocab.txt#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -t temporalio/ui:latest . --build-arg CONFIG_FILE=<path-to-config-file>\n```\n\n----------------------------------------\n\nTITLE: Running Initial Workflow Worker in Python\nDESCRIPTION: Command to run the worker with the initial workflow implementation. This sets up the worker to handle the original workflow code before any patches.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python worker.py --workflow initial\n```\n\n----------------------------------------\n\nTITLE: Using DiscoverableDisclosure Component in MDX\nDESCRIPTION: Example demonstrating how to use the DiscoverableDisclosure component with a custom label to create a collapsible content section that's more discoverable than standard Details elements.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<DiscoverableDisclosure label = \"your_summary_text\">\n...your content...\n</DiscoverableDisclosure>\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with Poetry\nDESCRIPTION: Command to install all dependencies defined in the project's pyproject.toml file using Poetry.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/workflow_failures/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow Start Delay in PHP with Temporal\nDESCRIPTION: This snippet shows how to use the Workflow Start Delay functionality in Temporal using PHP. It sets up a new Workflow stub with a 10-minute delay before the first Workflow task is dispatched.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/schedules.mdx#2025-04-23_snippet_0\n\nLANGUAGE: php\nCODE:\n```\n$workflow = $workflowClient->newWorkflowStub(\n    GreeterWorkflowInterface::class,\n    WorkflowOptions::new()\n        ->withWorkflowStartDelay(CarbonInterval::minutes(10)),\n);\n$workflowClient->start($workflow, 'Hello world!');\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Generating Certificates with tcld - Bash\nDESCRIPTION: This code block provides three sequential Bash commands for authenticating to Temporal Cloud using tcld, generating account-specific certificates, and configuring the namespace with the generated certificates for secure API access. It expects the environment variable ACCOUNT_ID to be set. Dependencies: tcld CLI, valid Temporal Cloud access. Inputs: ACCOUNT_ID. Outputs: Certificates stored as ca.pem and ca.key; updated Temporal Cloud namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/datadog.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld login\n```\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --org ${ACCOUNT_ID} -d 1y --ca-cert ca.pem --ca-key ca.key\n```\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca add --ca-certificate-file ca.pem\n```\n\n----------------------------------------\n\nTITLE: Starting a tctl Batch Job with a Query (Bash)\nDESCRIPTION: Initiates a `tctl` batch job, targeting Workflow Executions specified by a List Filter query provided via the `--query` modifier. This command requires the `tctl` utility and interacts with a Temporal Cluster. A confirmation prompt will be shown unless `--yes` is used.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/batch.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntctl batch start --query <value>\n```\n\n----------------------------------------\n\nTITLE: Specifying Result for tctl Activity Completion (Bash)\nDESCRIPTION: This command demonstrates how to provide a result value when completing a Temporal Activity Execution using the deprecated `tctl` tool via the `--result` modifier. Replace `<value>` with the desired result data. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --result <value>\n```\n\n----------------------------------------\n\nTITLE: Canceling Temporal Workflow Execution (Go/Bash)\nDESCRIPTION: This command compiles and runs the Go program located at `cancel/main.go`. It sends a cancellation request to a specific, currently running Workflow Execution via the Temporal Cluster. Requires Go, a running Temporal cluster, and the target Workflow Execution to be active.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/cancellation/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo run cancel/main.go\n```\n\n----------------------------------------\n\nTITLE: Promoting Entire Set to Default in Java (Deprecated)\nDESCRIPTION: This deprecated code shows how to promote an entire compatibility set to become the default set for the Task Queue. New Workflows will start using that set's default Build ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.promoteSetByBuildId(\"deadbeef\"));\n```\n\n----------------------------------------\n\nTITLE: Workflow Type Missing Error\nDESCRIPTION: Error message that appears when Webpack has stripped Workflow function names, causing the Temporal Service to receive an invalid Workflow Type. This typically happens in production builds with minification enabled.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nError: 3 INVALID_ARGUMENT: WorkflowType is not set on request.\n```\n\n----------------------------------------\n\nTITLE: Describing a Temporal Schedule using tctl (Shell)\nDESCRIPTION: Displays the current configuration and state information for a specific Temporal Schedule identified by its ID (`--schedule-id`). This includes details about past, current, and future scheduled runs. The output format might be a canonical representation, potentially differing from the input format.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ntctl schedule describe --schedule-id 'your-schedule-id'\n```\n\n----------------------------------------\n\nTITLE: Creating Related Read Lists using RelatedRead Component in JSX\nDESCRIPTION: Demonstrates how to use the RelatedReadContainer and RelatedReadItem components to create a list of related items with summaries and archetypes. Each item specifies a path, text, and archetype.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\n<RelatedReadContainer>\n  <RelatedReadItem path=\"/cloud/metrics/prometheus-grafana\"\n    text=\"How to set up Grafana with Temporal Cloud observability\"\n    archetype=\"feature-guide\" />\n  <RelatedReadItem path=\"/production-deployment/cloud/worker-health\"\n    text=\"How to monitor Worker Health with Temporal Cloud Metrics\"\n    archetype=\"feature-guide\" />\n  <RelatedReadItem path=\"/production-deployment/cloud/service-health\"\n    text=\"How to monitor Service Health with Temporal Cloud Metrics\"\n    archetype=\"feature-guide\" />\n</RelatedReadContainer>\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Heartbeat Timeout in .NET\nDESCRIPTION: Shows configuration of heartbeat timeout settings using ActivityOptions when executing an Activity.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/failure-detection.mdx#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nawait Workflow.ExecuteActivityAsync(\n    (MyActivities a) => a.MyActivity(param),\n    new()\n    {\n        StartToCloseTimeout = TimeSpan.FromMinutes(5),\n        HeartbeatTimeout = TimeSpan.FromSeconds(30),\n    });\n```\n\n----------------------------------------\n\nTITLE: Alternative Implementation for Cancelling a Timer in TypeScript\nDESCRIPTION: This example shows an alternative approach to cancelling a timer in a workflow by creating a new CancellationScope instance explicitly. It creates a scope, runs a sleep operation within it, then cancels the scope to terminate the timer.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  CancellationScope,\n  CancelledFailure,\n  sleep,\n} from '@temporalio/workflow';\n\nexport async function cancelTimerAltImpl(): Promise<void> {\n  try {\n    const scope = new CancellationScope();\n    const promise = scope.run(() => sleep(1));\n    scope.cancel(); // <-- Cancel the timer created in scope\n    await promise; // <-- Throws CancelledFailure\n  } catch (e) {\n    if (e instanceof CancelledFailure) {\n      console.log('Timer cancelled 👍');\n    } else {\n      throw e; // <-- Fail the workflow\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Worker Script – Bash\nDESCRIPTION: Runs the Temporal worker script 'run_worker.py' via Python 3. Requires Python 3 to be set up and the script accessible in the current directory. The script will start the worker component, and any further behavior depends on its code.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 run_worker.py\n```\n\n----------------------------------------\n\nTITLE: Building Temporal UI Docker Image with Default Config\nDESCRIPTION: Shell command for building the Temporal UI Docker image with the default configuration. This approach is recommended for development environments where custom configuration isn't needed.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/Google/vocab.txt#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndocker build -t temporalio/ui:latest .\n```\n\n----------------------------------------\n\nTITLE: Cloning Temporal Documentation Repository\nDESCRIPTION: Commands to clone the documentation repository and navigate into it.\nSOURCE: https://github.com/temporalio/documentation/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/YOUR_USERNAME/documentation.git\ncd documentation\n```\n\n----------------------------------------\n\nTITLE: Running Patch-Complete Workflow Worker in Python\nDESCRIPTION: Command to run the worker with the final patch-complete workflow implementation. This version has removed the deprecated code completely.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python worker.py --workflow patch-complete\n```\n\n----------------------------------------\n\nTITLE: Support Information Block\nDESCRIPTION: Markdown tip block containing SDK support information and version compatibility details for Start Delay functionality across different programming languages.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/workflow-execution/timers-delays.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n:::tip Support, stability, and dependency info\n\n- Available in the [Go SDK](https://pkg.go.dev/go.temporal.io/sdk/internal#StartWorkflowOptions.StartDelay) since [v1.25.0](https://github.com/temporalio/sdk-go/releases/tag/v1.25.0)\n- Available in the [Java SDK](https://www.javadoc.io/doc/io.temporal/temporal-sdk/latest/io/temporal/client/WorkflowOptions.Builder.html#setStartDelay(java.time.Duration)) since [v1.25.0](https://github.com/temporalio/sdk-java/releases/tag/v1.22.1)\n- Available in the [Python SDK](https://python.temporal.io/temporalio.client.Client.html#start_workflow) since [v1.4.0](https://github.com/temporalio/sdk-python/releases/tag/1.4.0)\n- Available in the [.NET SDK](https://dotnet.temporal.io/api/Temporalio.Client.WorkflowOptions.html#Temporalio_Client_WorkflowOptions_StartDelay) since [v1.0.0](https://github.com/temporalio/sdk-dotnet/releases/tag/1.0.0)\n- Available in the [TypeScript SDK](https://typescript.temporal.io/api/interfaces/client.WorkflowOptions#startdelay) since [v1.9.0](https://github.com/temporalio/sdk-typescript/releases/tag/v1.9.0)\n- Available in the [PHP SDK](https://php.temporal.io/classes/Temporal-Client-WorkflowOptions.html#property_workflowStartDelay) since [v2.7.0](https://github.com/temporalio/sdk-php/releases/tag/v2.7.0)\n\nStart Delay Workflow Execution is incompatible with both [Schedules](/schedule) and [Cron Jobs](/cron-job).\n\n:::\n```\n\n----------------------------------------\n\nTITLE: Overriding Activity Retry Interval with next_retry_delay in Python\nDESCRIPTION: Demonstrates how an Activity implementation can override the next retry delay specified by its Retry Policy. This is achieved by catching an exception, accessing the current attempt number via `activity.info().attempt`, and raising a `temporalio.exceptions.ApplicationError` with the `next_retry_delay` parameter set to a calculated `timedelta`. This allows for custom backoff strategies, such as the linear backoff shown (3 seconds * attempt number).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/failure-detection.mdx#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.exceptions import ApplicationError\nfrom datetime import timedelta\n\n@activity.defn\nasync def my_activity(input: MyActivityInput):\n    try:\n        # Your activity logic goes here\n    except Exception as e:\n        attempt = activity.info().attempt\n        raise ApplicationError(\n            f\"Error encountered on attempt {attempt}\",\n            next_retry_delay=timedelta(seconds=3 * attempt),\n        ) from e\n```\n\n----------------------------------------\n\nTITLE: Updating the Description of a Namespace using tctl\nDESCRIPTION: Updates the description text for an existing Namespace using the `--description <value>` modifier with `tctl namespace update`. Requires the target namespace to be specified (e.g., via the global `--namespace` flag).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --description <value>\n```\n\n----------------------------------------\n\nTITLE: Calculating Temporal Worker Poll Success Rate\nDESCRIPTION: Provides the mathematical formula for calculating the Poll Success Rate using `temporal_cloud_v0_poll_success_count`, `temporal_cloud_v0_poll_success_sync_count`, and `temporal_cloud_v0_poll_timeout_count` metrics. This rate helps identify if too many workers are polling Temporal Cloud ('greedy workers'). A rate below 90-95% may indicate an issue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/worker-health.mdx#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n(temporal_cloud_v0_poll_success_count + temporal_cloud_v0_poll_success_sync_count)\n/\n(temporal_cloud_v0_poll_success_count + temporal_cloud_v0_poll_success_sync_count + temporal_cloud_v0_poll_timeout_count)\n```\n\n----------------------------------------\n\nTITLE: Configuring PHPUnit for Temporal Tests\nDESCRIPTION: XML configuration for PHPUnit to include the bootstrap file and set the TEMPORAL_ADDRESS environment variable.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/testing-suite.mdx#2025-04-23_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/9.3/phpunit.xsd\"\n         bootstrap=\"tests/bootstrap.php\"\n>\n    <php>\n        <env name=\"TEMPORAL_ADDRESS\" value=\"127.0.0.1:7233\" />\n    </php>\n</phpunit>\n```\n\n----------------------------------------\n\nTITLE: Using ToolTipTerm Component for Inline Definitions in JSX\nDESCRIPTION: Shows how to use the ToolTipTerm component to provide definitions or background information at the point of use. It includes an example of using the component within a sentence.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\n<ToolTipTerm term=\"your_term_name\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\nTemporal Cloud strives to maintain a <Components.ToolTipTerm term=\"P95\" /> replication delay of less than 1 minute.\n```\n\n----------------------------------------\n\nTITLE: Initializing Certificate Authority with certstrap (Command Line)\nDESCRIPTION: Uses the `certstrap init` command to create a new self-signed Certificate Authority (CA). It sets the common name for the CA to \"CertAuth\". This command generates the CA certificate file (`CertAuth.crt`) and its key in the `out` subdirectory. This is the first step when using `certstrap` to generate certificates for Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/certificates.mdx#2025-04-23_snippet_2\n\nLANGUAGE: command\nCODE:\n```\n./certstrap init --common-name \"CertAuth\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Frontend Service in YAML\nDESCRIPTION: Minimal configuration example for a frontend service showing RPC settings including gRPC and membership ports.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  frontend:\n    rpc:\n      grpcPort: 8233\n      membershipPort: 8933\n      bindOnIP: '0.0.0.0'\n```\n\n----------------------------------------\n\nTITLE: Using the plainify Bash script for MDX to plain text conversion\nDESCRIPTION: The plainify script converts a single .mdx file to plain text by removing formatting and markup. It supports various options for output handling and can remove frontmatter, code blocks, tables, headings, links, and MDX admonition blocks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/READABILITY.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nUsage: plainify [options] <file.mdx>\n\nOptions:\n  -c            Copy output to clipboard\n  -o            Open output in TextEdit\n  -w            Write output to a .txt file in the same folder\n  -e            Echo to stdout when other flags are used\n  -v            Verbose output\n  -h            Show this help message\n```\n\n----------------------------------------\n\nTITLE: Testing GCP PSC Connection with grpcURL (mTLS)\nDESCRIPTION: This command shows how to test the Private Service Connect connection using `grpcurl`, a command-line tool for interacting with gRPC services, using mTLS authentication. It specifies the required client certificate and key, overrides the TLS server name (`-servername`) to the namespace-specific endpoint for mTLS validation, targets the PSC endpoint IP address and port, and calls the `GetSystemInfo` method of the Temporal Workflow Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/gcp-private-service-connect.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngrpcurl \\\n    -servername <name>.<account>.tmprl.cloud \\\n    -cert /path/to/client.pem \\\n    -key /path/to/client.key \\\n    <IP address of the PSC endpoint>:7233 \\\n    temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow by Event ID in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the event_id modifier. This allows resetting a Workflow Execution to a specific event after WorkflowTaskStarted.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --event_id <id>\n```\n\n----------------------------------------\n\nTITLE: Deleting Temporal Cloud Users with Terraform Configuration\nDESCRIPTION: Terraform configuration showing how to delete a Temporal Cloud User by commenting out or removing the user resource definition. This example demonstrates removing a namespace admin while keeping the global admin.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_17\n\nLANGUAGE: yml\nCODE:\n```\nterraform {\n  required_providers {\n    temporalcloud = {\n      source = \"temporalio/temporalcloud\"\n      version = \">= 0.0.6\"\n    }\n  }\n}\n\nprovider \"temporalcloud\" {\n\n}\n\nresource \"temporalcloud_namespace\" \"namespace\" {\n  name               = \"terraform\"\n  regions            = [\"aws-us-east-1\"]\n  accepted_client_ca = base64encode(file(\"ca.pem\"))\n  retention_days     = 14\n}\n\nresource \"temporalcloud_user\" \"global_admin\" {\n  email          = <admin-email>\n  account_access = \"Admin\"\n}\n\n# resource \"temporalcloud_user\" \"namespace_admin\" {\n#   email          = <developer-email>\n#   account_access = \"Developer\"\n#   namespace_accesses = [\n#     {\n#       namespace_id = temporalcloud_namespace.namespace.id\n#       permission = \"Write\"\n#     }\n#   ]\n# }\n```\n\n----------------------------------------\n\nTITLE: Running Workflow with Memo in Bash\nDESCRIPTION: Example of using the tctl workflow run command with memo and memo_key modifiers. This allows attaching a memo to the Workflow Execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --memo_key <key> --memo <json>\n```\n\n----------------------------------------\n\nTITLE: Deleting a Schedule in Java\nDESCRIPTION: This snippet illustrates how to delete a Schedule using the delete() method on the ScheduleHandle. Deleting a Schedule does not affect any Workflows that were started by the Schedule.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/schedules.mdx#2025-04-23_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nScheduleHandle handle = client.getHandle(\"schedule-id\")\nhandle.delete();\n```\n\n----------------------------------------\n\nTITLE: Defining Temporal Cron Schedule String Format (Reference, Plaintext)\nDESCRIPTION: This snippet provides a plaintext reference of the required format for Temporal Workflow scheduling cron strings, documenting the positional meanings for minute, hour, day of month, month, and day of week. It serves as a usage guide for composing valid cron expressions compatible with Temporal's scheduling. No dependencies or programmatic context are required; used purely as format documentation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n└─┐──────── minute (0 - 59)\n│ └─┐──────── hour (0 - 23)\n│ │ └─┐──────── day of the month (1 - 31)\n│ │ │ └─┐──────── month (1 - 12)\n│ │ │ │ └─┐──────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Using Search Attribute Values with tctl Workflow Start Command\nDESCRIPTION: Demonstrates how to use the --search_attr_value modifier with the tctl workflow start command to specify search attribute values.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_63\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow start --search_attr_value <value>\n```\n\n----------------------------------------\n\nTITLE: Creating an API Key with Absolute Expiry - tcld CLI - Bash\nDESCRIPTION: This snippet creates an API Key with an explicit absolute expiry time using the --expiry flag, which accepts an RFC3339-formatted timestamp. This overrides the --duration flag if both are provided. The CLI requires authentication and correct date-time formatting for the expiry value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey create --name <name> --expiry '2023-11-28T09:23:24-08:00'\n```\n\n----------------------------------------\n\nTITLE: Specifying Versioning Intent for Activities in TypeScript (Legacy)\nDESCRIPTION: This snippet shows how to override the default versioning behavior for Activities in the legacy Temporal TypeScript SDK. By setting `versioningIntent` to `'USE_ASSIGNMENT_RULES'` in the `proxyActivities` options, the Activity is directed to run on a Worker selected based on the current Task Queue assignment rules, rather than inheriting the version from the calling Workflow. Note: The documentation indicates this specific feature might be under construction.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/worker-versioning-legacy.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// ...\nconst { echo } = proxyActivities<typeof activities>({\n  startToCloseTimeout: '20s',\n  versioningIntent: 'USE_ASSIGNMENT_RULES',\n});\n// ...\n```\n\n----------------------------------------\n\nTITLE: Listing Workflow Executions by Time Range using tctl (Bash)\nDESCRIPTION: Filters the list of Workflow Executions based on their start time using `tctl workflow list`. The `--earliest_time` and `--latest_time` modifiers accept various time formats, including RFC3339-like timestamps, Unix Epoch milliseconds, or relative durations (e.g., '15minute', '10second').\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Example using a specific timestamp for earliest time\ntctl workflow list --earliest-time '2022-01-02T15:04:05+05:30'\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example using a relative duration for earliest time\ntctl workflow list --earliest-time '15minute'\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example using a specific timestamp for latest time\ntctl workflow list --latest_time '2022-04-13T23:02:17-07:00'\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example using a relative duration for latest time\ntctl workflow list --latest_time '10second'\n```\n\n----------------------------------------\n\nTITLE: Single Version Search Attribute Implementation\nDESCRIPTION: Implementation for setting search attributes with a single version change.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/versioning.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nint version = Workflow.getVersion(\"MovedThankYouAfterLoop\", Workflow.DEFAULT_VERSION, 1);\n\nif (version != Workflow.DEFAULT_VERSION) {\n  Workflow.upsertTypedSearchAttributes(Constants.TEMPORAL_CHANGE_VERSION\n      .valueSet(Arrays.asList((\"MovedThankYouAfterLoop-\" + version))));\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf JSON Module Using protobufjs - Shell Script\nDESCRIPTION: This shell command uses the protobufjs CLI tool to generate a CommonJS JSON module that is compatible with runtime loading in the project. The generated output file `protos/json-module.js` contains all compiled protobuf messages found in the `protos/*.proto` files and is required for integrating protocol buffer serialization with TypeScript and Temporal. Prior installation of `protobufjs` CLI (`pbjs`) is required.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\npbjs -t json-module --workflow-id commonjs -o protos/json-module.js protos/*.proto\n```\n\n----------------------------------------\n\nTITLE: Adding a CA Certificate to Metrics Endpoint - tcld CLI - Bash\nDESCRIPTION: This snippet shows how to use the tcld CLI to add a specific CA certificate to the metrics endpoint of a Temporal Cloud account, specifying a request identifier. Dependencies: tcld CLI must be installed and configured for authorization. Required parameters are --ca-certificate (a base64-encoded certificate PEM) and optionally --request-id. The command performs an asynchronous operation and outputs the server's confirmation or error. The CA certificate used must comply with account requirements.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca add --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Elasticsearch Index Schema with auto-setup.sh Script\nDESCRIPTION: Bash script example showing how to set up an Elasticsearch Visibility store using the auto-setup.sh script. It includes setting environment variables, validating the environment, and creating the necessary index and templates.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# Elasticsearch\n: \"${ENABLE_ES:=false}\"\n: \"${ES_SCHEME:=http}\"\n: \"${ES_SEEDS:=}\"\n: \"${ES_PORT:=9200}\"\n: \"${ES_USER:=}\"\n: \"${ES_PWD:=}\"\n: \"${ES_VERSION:=v7}\"\n: \"${ES_VIS_INDEX:=temporal_visibility_v1}\"\n: \"${ES_SEC_VIS_INDEX:=}\"\n: \"${ES_SCHEMA_SETUP_TIMEOUT_IN_SECONDS:=0}\"\n#...\n# Validate your ES environment\n#...\n# Wait for ES to start\n#...\n# ES_SERVER is the URL of Elasticsearch server; for example, \"http://localhost:9200\".\nSETTINGS_URL=\"${ES_SERVER}/_cluster/settings\"\nSETTINGS_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/cluster_settings_${ES_VERSION}.json\nTEMPLATE_URL=\"${ES_SERVER}/_template/temporal_visibility_v1_template\"\nSCHEMA_FILE=${TEMPORAL_HOME}/schema/elasticsearch/visibility/index_template_${ES_VERSION}.json\nINDEX_URL=\"${ES_SERVER}/${ES_VIS_INDEX}\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${SETTINGS_URL}\" -H \"Content-Type: application/json\" --data-binary \"@${SETTINGS_FILE}\" --write-out \"\\n\"\ncurl --fail --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${TEMPLATE_URL}\" -H 'Content-Type: application/json' --data-binary \"@${SCHEMA_FILE}\" --write-out \"\\n\"\ncurl --user \"${ES_USER}\":\"${ES_PWD}\" -X PUT \"${INDEX_URL}\" --write-out \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Triggering a Temporal Schedule Action Immediately using tctl (Shell)\nDESCRIPTION: Manually triggers the action associated with a specific Temporal Schedule (`--schedule-id`) to run immediately, regardless of its defined schedule. The execution is subject to the Schedule's configured overlap policy by default.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/schedule.mdx#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ tctl schedule trigger --schedule-id 'your-schedule-id'\n```\n\n----------------------------------------\n\nTITLE: Running Temporal Worker via Command Line Interface - Bash\nDESCRIPTION: This command launches the Temporal worker for scheduled workflows using the Go SDK. The command assumes that the Go environment is set up and dependencies from schedule/worker/main.go are met. No additional command-line parameters are required, and the worker will register with the Temporal service. Input: none. Output: runs worker process to listen for scheduled jobs.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/schedules/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run schedule/worker/main.go\n```\n\n----------------------------------------\n\nTITLE: Removing CA Certificate by Direct Value - tcld CLI - Bash\nDESCRIPTION: Removes a CA certificate from the metrics endpoint by directly specifying the base64-encoded certificate value. Use --ca-certificate to indicate the target certificate. This modifier is required unless a fingerprint or file is provided. If multiple parameters are set, priority and exclusions follow documented behavior.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca remove --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Upgrading MySQL Visibility Schema using temporal-sql-tool in Bash\nDESCRIPTION: This command employs the `temporal-sql-tool` to upgrade the visibility schema for a Temporal Server using MySQL (targeting v5.7 schema compatibility). It establishes a TLS-secured connection, authenticates using certificates and credentials, uses the `mysql` plugin, targets the `temporal_visibility` database, and applies schema updates from the specified MySQL v5.7 visibility schema directory.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/upgrade-server.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./temporal-sql-tool \\\n\t--tls \\\n\t--tls-enable-host-verification \\\n\t--tls-cert-file <path to your client cert> \\\n\t--tls-key-file <path to your client key> \\\n\t--tls-ca-file <path to your CA> \\\n\t--ep localhost -p 3036 -u root -pw root --pl mysql --db temporal_visibility update-schema -d ./schema/mysql/v57/visibility/versioned/\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Stub with Task Queue - Temporal PHP\nDESCRIPTION: Explains how to assign a custom Task Queue to a Workflow Execution using WorkflowOptions when creating a Workflow stub. The method utilizes Temporal's WorkflowOptions::withTaskQueue() for better control over Workflows and improved observability. Required components include a WorkflowClient, an interface definition, and the options object. The key parameter is the Task Queue name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/php/temporal-clients.mdx#2025-04-23_snippet_11\n\nLANGUAGE: php\nCODE:\n```\n<?php\\n$stub = $workflowClient->newWorkflowStub(\\n    YourWorkflowInterface::class,\\n    WorkflowOptions::new()\\n        ->withTaskQueue(\\\"Workflow-Task-Queue-1\\\"),\\n);\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Search Attributes for Child Workflow in Java\nDESCRIPTION: Shows how to configure Search Attributes for a Child Workflow, which are indexed information used for search and visibility. The example demonstrates setting a custom search attribute with a string value.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-client.mdx#2025-04-23_snippet_20\n\nLANGUAGE: java\nCODE:\n```\nprivate static void parentWorkflow() {\n        ChildWorkflowOptions childworkflowOptions =\n                ChildWorkflowOptions.newBuilder()\n                        // Set Search Attributes\n                        .setSearchAttributes(ImmutableMap.of(\"MySearchAttributeNAme\", \"value\"))\n                        .build();\n```\n\n----------------------------------------\n\nTITLE: Registering a Namespace using Java SDK\nDESCRIPTION: This code snippet demonstrates how to register a new Namespace using the RegisterNamespace API in Java. It sets the Namespace name and Workflow Execution retention period.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/namespaces.mdx#2025-04-23_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n//...\nimport com.google.protobuf.util.Durations;\nimport io.temporal.api.workflowservice.v1.RegisterNamespaceRequest;\n//...\npublic static void createNamespace(String name) {\n    RegisterNamespaceRequest req = RegisterNamespaceRequest.newBuilder()\n            .setNamespace(\"your-custom-namespace\")\n            .setWorkflowExecutionRetentionPeriod(Durations.fromDays(3)) // keeps the Workflow Execution\n            //Event History for up to 3 days in the Persistence store. Not setting this value will throw an error.\n            .build();\n    service.blockingStub().registerNamespace(req);\n}\n//...\n```\n\n----------------------------------------\n\nTITLE: Example of Problematic Concurrent Handler Execution in C# Temporal\nDESCRIPTION: This code illustrates a bug that can occur with concurrent handler execution, where multiple instances of a handler could lead to inconsistent state. The workflow might end up with x from one Activity execution and y from another.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class MyWorkflow\n{\n    // ...\n\n    [WorkflowSignal]\n    public async Task BadHandlerAsync()\n    {\n        var data = await Workflow.ExecuteActivityAsync(\n            (MyActivities acts) => acts.FetchDataAsync(),\n            new() { StartToCloseTimeout = TimeSpan.FromSeconds(10) });\n        this.x = data.X;\n        // 🐛🐛 Bug!! If multiple instances of this handler are executing concurrently, then\n        // there may be times when the Workflow has this.x from one Activity execution and this.y from another.\n        await Workflow.DelayAsync(1000);\n        this.y = data.Y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering a React Component - JavaScript/JSX\nDESCRIPTION: This snippet demonstrates how to import a React component from a custom module path and render it within the main documentation page. It is written in JSX and relies on the project's build system to resolve module aliases. The <Intro /> component is used to show introduction content on the homepage. No inputs or outputs are directly involved, as it is a structural inclusion for UI setup.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/index.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Intro } from '@site/src/components';\n\n<Intro />\n```\n\n----------------------------------------\n\nTITLE: Creating Worker Connection with TypeScript SDK pre-v1.10.0 using API Key\nDESCRIPTION: Establishes a worker connection to Temporal Cloud using TypeScript SDK versions prior to 1.10.0 with NativeConnection. Sets the API key in the metadata object with an Authorization header.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = await NativeConnection.connect({\n    address: <endpoint>,\n    tls: true,\n    metadata: {\n        'Authorization': `Bearer ${<APIKey>}`\n        'temporal-namespace': <namespace_id>.<account_id>,\n    },\n})\nconst worker = await Worker.create({\n    connection,\n    namespace: <namespace_id>.<account_id>,\n    // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Temporal CLI in Shell\nDESCRIPTION: This command starts a workflow using the Temporal CLI, specifying the task queue, workflow type, workflow ID, and input.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\ntemporal workflow start \\\n  --task-queue hello-world \\\n  --type MyWorkflow \\\n  --workflow-id 123 \\\n  --input 456\n```\n\n----------------------------------------\n\nTITLE: Initializing DefaultPayloadConverterWithProtobufs - TypeScript\nDESCRIPTION: This snippet creates a new instance of `DefaultPayloadConverterWithProtobufs` by providing it the patched protobuf root. This converter allows automatic serialization and deserialization of protobuf-compatible objects within Temporal payloads, and should be used in conjunction with a properly generated and patched protobuf root. Make sure `@temporalio/common/lib/protobufs` is installed and properly configured.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/converters-and-encryption.mdx#2025-04-23_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\nimport { DefaultPayloadConverterWithProtobufs } from '@temporalio/common/lib/protobufs';\nimport root from '../protos/root';\n\nexport const payloadConverter = new DefaultPayloadConverterWithProtobufs({\n  protobufRoot: root,\n});\n```\n\n----------------------------------------\n\nTITLE: Importing an Existing Namespace into Terraform\nDESCRIPTION: Runs the `terraform import` command to bring an existing Temporal Cloud Namespace under Terraform management. It links the specified Terraform resource address (`temporalcloud_namespace.terraform`) to the existing Namespace identified by its ID (`namespaceid.acctid`). After import, the Namespace's configuration should be managed solely via Terraform.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nterraform import temporalcloud_namespace.terraform namespaceid.acctid\n```\n\n----------------------------------------\n\nTITLE: Creating a Nexus Endpoint\nDESCRIPTION: Command to create a Nexus Endpoint that routes requests from a caller Namespace to a target Namespace and task queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator nexus endpoint create \\\n  --name my-nexus-endpoint-name \\\n  --target-namespace my-target-namespace \\\n  --target-task-queue my-handler-task-queue\n```\n\n----------------------------------------\n\nTITLE: Default Temporal Activity Type Naming in Java\nDESCRIPTION: Demonstrates the default behavior where Temporal Activity Types are automatically generated by capitalizing the first letter of the corresponding method name within an `@ActivityInterface`. This example shows an interface `GreetingActivities` with two methods, `sendMessage` and `composeGreeting`, resulting in Activity Types `SendMessage` and `ComposeGreeting` respectively. Requires the Temporal Java SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_12\n\nLANGUAGE: java\nCODE:\n```\n@ActivityInterface\npublic interface GreetingActivities {\n    String sendMessage(String input);\n\n    @ActivityMethod\n    String composeGreeting(String greeting, String language);\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Component Directory Structure in Temporal Documentation\nDESCRIPTION: A file tree showing the organization of components in the src/components directory, including elements, experimental, formatting, images, and info subdirectories.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncomponents\n├── elements\n│   ├── Button.js\n│   ├── Intro.js\n│   ├── PhotoCarousel.js\n│   ├── RetrySimulator.js\n│   ├── SdkLogos.js\n│   └── retry-simulator.module.css\n├── experimental\n│   ├── CenteredImage.js\n│   ├── CustomWarning.js\n│   ├── DetermineHeader.js\n│   ├── InfoButton.js\n│   ├── NoBreak.js\n│   ├── ResponsivePlayer.js\n│   ├── RowOfImages.js\n│   ├── Spacer.js\n│   └── ToolTipText.js\n├── formatting\n│   └── DocsTable.js\n├── images\n│   ├── CaptionedImage.js\n│   └── CaptionedImage.module.css\n├── index.js\n└── info\n    ├── DiscoverableDisclosure.js\n    ├── RelatedRead.js\n    ├── RelatedRead.module.css\n    ├── RelatedReadList.js\n    └── ToolTipTerm.js\n```\n\n----------------------------------------\n\nTITLE: Setting Deletion Protection on a Temporal Cloud Namespace using tcld CLI - Shell\nDESCRIPTION: This shell command demonstrates enabling or disabling Deletion Protection for a specific Temporal Cloud Namespace using the tcld CLI. It requires tcld to be installed and configured with adequate permissions. The --enable-delete-protection parameter is set to either true or false (Boolean) to toggle protection. Inputs include the fully qualified Namespace ID with account ID, and outputs are CLI feedback/errors for the operation. The command is limited to users with deletion management privileges and affects Namespace security.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/namespaces.mdx#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntcld namespace lifecycle set \\\n    --namespace <namespace_id.account_id> \\\n    --enable-delete-protection <Boolean>\n```\n\n----------------------------------------\n\nTITLE: Starting Headless Temporal Server\nDESCRIPTION: Command to start Temporal development server without the Web UI\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ntemporal server start-dev --headless\n```\n\n----------------------------------------\n\nTITLE: Illustrating Conflicting Update in Cluster C (T=1)\nDESCRIPTION: This table shows the state in Cluster C at T=1 after a failover to it (making version 3 active) and adding event ID 4 with version 3. This creates a history divergence from Cluster B.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 2               | 1       |\n| 2        | 1               | 3               | 2       |\n| 3        | 2               | 4               | 3       |\n| 4        | 3               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Executing Workflow for Dynamic Query (Bash/Temporal CLI)\nDESCRIPTION: Uses the `temporal workflow execute` command to start an instance of `GreetingWorkflow`. It targets the `dynamic-query-task-queue` where the dynamic query worker is listening, passes the string \"SomeName\" as input, and runs in the `default` namespace. This workflow can subsequently be queried using dynamic query handlers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntemporal workflow execute \\\n --task-queue dynamic-query-task-queue \\\n --type GreetingWorkflow \\\n --input '\"SomeName\"' \\\n --namespace default\n```\n\n----------------------------------------\n\nTITLE: Setting Document Head Metadata - HTML\nDESCRIPTION: This HTML snippet sets the browser title for the documentation site by inserting a <title> tag in the <head> element. It is essential for user experience and SEO but does not require any dependencies beyond HTML. No inputs or outputs are involved; it purely configures page metadata.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/index.mdx#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<head>\n  <title>Temporal Platform Documentation</title>\n</head>\n```\n\n----------------------------------------\n\nTITLE: Deleting a Temporal Cloud Namespace with Terraform\nDESCRIPTION: Executes the `terraform destroy` command. This command removes all resources managed by the current Terraform configuration from Temporal Cloud, including the specified Namespace, after prompting for confirmation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nterraform destroy\n```\n\n----------------------------------------\n\nTITLE: Illustrative Initial Workflow (v1) Requiring Patching\nDESCRIPTION: This TypeScript code snippet shows an initial version (v1) of a simple Workflow that calls an activity. It serves as a starting point to illustrate a scenario where adding a `sleep` before the activity in a subsequent version (v2) would cause non-determinism without patching, as explained in the surrounding text.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/versioning.mdx#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// from v1\nexport async function yourWorkflow(value: number): Promise<number> {\n  await runActivity();\n  return 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting an Environment with Temporal CLI\nDESCRIPTION: Demonstrates how to delete an entire environment configuration (local) and all its saved values using the 'temporal env delete' command.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntemporal env delete local\n```\n\n----------------------------------------\n\nTITLE: Getting User Information via tcld CLI by Email - Command\nDESCRIPTION: Shows how to retrieve details of a Temporal Cloud user using their email address. The --user-email flag identifies the target user. User information returned includes roles, permissions, and metadata; requires sufficient permissions to view details.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_2\n\nLANGUAGE: command\nCODE:\n```\ntcld user delete --user-email <test@example.com>\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal CLI on macOS via Homebrew\nDESCRIPTION: Command to install Temporal CLI using the Homebrew package manager on macOS\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbrew install temporal\n```\n\n----------------------------------------\n\nTITLE: Removing CA Certificate from File - tcld CLI - Bash\nDESCRIPTION: Removes a CA certificate using the PEM file path via --ca-certificate-file. This is an alternative to passing a base64 string or fingerprint directly. Dependencies: Valid PEM file and tcld CLI setup. Priority rules for parameters apply if more than one is specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca remove --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Querying History Service Persistence Request Rate by Operation using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of persistence requests (`persistence_requests`) made by the History Service (`service_name=\"history\"`) over the last 1 minute, aggregated by operation type (`operation`). It uses a variable `$service`. This helps monitor the load on the persistence layer caused by the History Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_12\n\nLANGUAGE: PromQL\nCODE:\n```\nsum by (operation) (rate(persistence_requests{service=\"$service\",service_name=\"history\"}[1m]))\n```\n\n----------------------------------------\n\nTITLE: Webpack Error: Module Not Found during Workflow Registration in Monorepo - bash\nDESCRIPTION: Depicts a CLI shell error resulting from Temporal Worker failing to resolve workflow modules (worker-interface.js) in a monorepo scenario. Typically occurs when node_modules location does not align with Webpack configuration. The error aids in diagnosing issues related to custom workflow bundling or misconfigured project structures.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[ERROR] Module not found: Error: Can't resolve '@temporalio/workflow/lib/worker-interface.js' in '/src'\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeout with WorkflowImplementationOptions in Java\nDESCRIPTION: This code shows how to set Activity Timeouts using WorkflowImplementationOptions within a Worker. It sets the ScheduleToCloseTimeout for a specific Activity and includes commented-out options for other timeouts.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_21\n\nLANGUAGE: java\nCODE:\n```\nWorkflowImplementationOptions options =\n            WorkflowImplementationOptions.newBuilder()\n                    .setActivityOptions(\n                            ImmutableMap.of(\n                                    \"GetCustomerGreeting\",\n                                    // Set Activity Execution timeout\n                                    ActivityOptions.newBuilder()\n                                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                                        // .setStartToCloseTimeout(Duration.ofSeconds(2))\n                                        // .setScheduleToStartTimeout(Duration.ofSeconds(5))\n                                        .build()))\n                    .build();\n```\n\n----------------------------------------\n\nTITLE: Testing PrivateLink with API Key Authentication (grpcURL)\nDESCRIPTION: Command to test AWS PrivateLink connectivity using grpcURL with API key authentication. It shows how to set the required headers and TLS server name for making a gRPC call with an API key.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/aws-privatelink.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngrpcurl \\\n    -H \"authorization: Bearer <api_key>\" \\\n    -H \"temporal-namespace: <namespace>.<account>\" \\\n    -servername <region>.<cloud_provider>.api.temporal.io \\\n    <DNS ASSOCIATED WITH VPC ENDPOINT>:7233 \\\n    temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo\n```\n\n----------------------------------------\n\nTITLE: Setting maximum field length in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that specifies the maximum length for each attribute field. Default is 500.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_56\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --max_field_length <length>\n```\n\n----------------------------------------\n\nTITLE: Webpack Error Output for Activity Import in Workflow Bundle - bash\nDESCRIPTION: Captures the Webpack and Temporal SDK logger error output when a Workflow tries to import and use an Activity that relies on prohibited modules (such as 'http'). Demonstrates a typical diagnostics log, including messages about missing polyfills and configuration suggestions. No dependencies; the input context is misconfigured imports.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n2021-10-14T19:46:52.731Z [INFO] ERROR in ./src/activities.ts 8:31-46\\n2021-10-14T19:46:52.731Z [INFO] Module not found: Error: Can't resolve 'http' in '/Users/you/your-project/src'\\n2021-10-14T19:46:52.731Z [INFO]\\n2021-10-14T19:46:52.731Z [INFO] BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\\n2021-10-14T19:46:52.731Z [INFO] This is no longer the case. Verify if you need this module and configure a polyfill for it.\\n2021-10-14T19:46:52.731Z [INFO]\\n2021-10-14T19:46:52.731Z [INFO] If you want to include a polyfill, you need to:\\n2021-10-14T19:46:52.731Z [INFO]         - add a fallback 'resolve.fallback: { \"http\": require.resolve(\"stream-http\") }'\\n2021-10-14T19:46:52.731Z [INFO]         - install 'stream-http'\\n2021-10-14T19:46:52.731Z [INFO] If you don't want to include a polyfill, you can use an empty module like this:\\n2021-10-14T19:46:52.731Z [INFO]         resolve.fallback: { \"http\": false }\n```\n\n----------------------------------------\n\nTITLE: Removing a Binary from Bad List for a Namespace using tctl\nDESCRIPTION: Removes a previously added binary checksum from the 'bad binaries' list for a Namespace using the `--remove_bad_binary <value>` modifier with `tctl namespace update`. This allows Temporal to dispatch commands to workers reporting this binary again. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --remove_bad_binary <value>\n```\n\n----------------------------------------\n\nTITLE: Configuring Codec Server (codec) in Temporal Web UI (YAML)\nDESCRIPTION: Specifies settings for connecting to a Codec Server for custom data encoding/decoding in the UI. Includes endpoint URL, options for passing access tokens, including credentials and decoding event history downloads.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/web-ui-configuration.mdx#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ncodec:\n  endpoint: http://your-codec-server-endpoint\n  passAccessToken: false\n  includeCredentials: false\n  decodeEventHistoryDownload: false\n```\n\n----------------------------------------\n\nTITLE: Incorrect Concurrent Handler Implementation\nDESCRIPTION: An example of incorrect implementation of a Signal handler that can cause race conditions when multiple handler instances run concurrently. The code demonstrates a bug where workflow state can become inconsistent.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/message-passing.mdx#2025-04-23_snippet_18\n\nLANGUAGE: java\nCODE:\n```\npublic class DataWorkflowImpl implements DataWorkflow {\n    ...\n    @Override\n    public void badSignalHandler() {\n        Data data = activity.fetchData();\n        this.x = data.x;\n        // 🐛🐛 Bug!! If multiple instances of this method are executing concurrently, then\n        // there may be times when the Workflow has self.x from one Activity execution and self.y from another.\n        Workflow.sleep(Duration.ofSeconds(1));\n        this.y = data.y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using WorkflowInit Attribute to Process Input Before Handler Execution\nDESCRIPTION: This example demonstrates how to use the WorkflowInit attribute on a constructor to process Workflow input before any handler executes. The constructor and RunAsync method must have matching parameter types, allowing handlers to access processed input.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/dotnet/message-passing.mdx#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[Workflow]\npublic class WorkflowInitWorkflow\n{\n    public record Input(string Name);\n\n    private readonly string nameWithTitle;\n    private bool titleHasBeenChecked;\n\n    [WorkflowInit]\n    public WorkflowInitWorkflow(Input input) =>\n        nameWithTitle = $\"Sir {input.Name}\";\n\n    [WorkflowRun]\n    public async Task<string> RunAsync(Input ignored)\n    {\n        await Workflow.WaitConditionAsync(() => titleHasBeenChecked);\n        return $\"Hello, {nameWithTitle}\";\n    }\n\n    [WorkflowUpdate]\n    public async Task<bool> CheckTitleValidityAsync()\n    {\n        // The handler is now guaranteed to see the workflow input after it has\n        // been processed by the constructor.\n        var valid = await Workflow.ExecuteActivityAsync(\n            (MyActivities acts) -> acts.CheckTitleValidityAsync(nameWithTitle),\n            new() { StartToCloseTimeout = TimeSpan.FromSeconds(10) });\n        titleHasBeenChecked = true;\n        return valid;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Environment Output Example with Temporal CLI\nDESCRIPTION: Shows the expected output when retrieving environment properties for a local environment, displaying certificate paths, address, and namespace information.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/env.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nOutput: tls-cert-path  /home/my-user/certs/cluster.cert tls-key-path   /home/my-user/certs/cluster.key address        127.0.0.1:7233 namespace      accounting\n```\n\n----------------------------------------\n\nTITLE: Starting Dynamic Signal Worker (Bash/Python)\nDESCRIPTION: Executes the Python script `your_worker_signal_dacx.py` using `poetry run`. This script starts a Temporal Worker configured to listen for tasks on the `dynamic-signal-task-queue` and handle dynamic signals (signals sent to the workflow for which no specific signal handler is registered).\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python your_worker_signal_dacx.py\n```\n\n----------------------------------------\n\nTITLE: Showing event details in tctl workflow run command\nDESCRIPTION: Command that enables showing detailed event information when running a workflow.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --show_detail\n```\n\n----------------------------------------\n\nTITLE: Transport Error in Temporal Server Connection\nDESCRIPTION: Example of a transport error that occurs when there's an issue with certificate/key pairs when connecting to Temporal Server in production environments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/debugging.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n[TransportError: transport error]\n```\n\n----------------------------------------\n\nTITLE: Starting a Workflow with Client Connection in TypeScript\nDESCRIPTION: This snippet shows how to create a Temporal Client connection and execute a Workflow. The code specifies required parameters including task queue and workflow ID when starting a Workflow execution.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/temporal-clients.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client, Connection } from '@temporalio/client';\n// This is the code that is used to start a Workflow.\nconst connection = await Connection.create();\nconst client = new Client({ connection });\nconst result = await client.workflow.execute(yourWorkflow, {\n  // required\n  taskQueue: 'your-task-queue',\n  // required\n  workflowId: 'your-workflow-id',\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the Validated Temporal Workflow (Go)\nDESCRIPTION: This command compiles and runs the Go program that starts an execution of the Workflow which includes an Update validator function. This Workflow will validate incoming update payloads (checking if they are positive integers) before processing them.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/updates/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngo run validstarter/main.go\n```\n\n----------------------------------------\n\nTITLE: Listing Partitions of a Temporal Task Queue using tctl (Bash)\nDESCRIPTION: Lists the partitions and their corresponding hostnames for a specified Temporal Task Queue. The `--taskqueue` modifier is required to identify the target queue (`<value>`). This command is part of the deprecated `tctl` utility.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/taskqueue.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntctl taskqueue list-partition --taskqueue <value>\n```\n\n----------------------------------------\n\nTITLE: Installing OpenTelemetry Dependencies for Temporal Python SDK Tracing\nDESCRIPTION: Shows the pip command required to install the optional OpenTelemetry dependencies. These dependencies are necessary to enable tracing capabilities using `temporalio.contrib.opentelemetry.TracingInterceptor` within the Temporal Python SDK.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/python/observability.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# This command installs the `opentelemetry` dependencies.\npip install temporalio[opentelemetry]\n```\n\n----------------------------------------\n\nTITLE: Updating Custom Data for a Namespace using tctl\nDESCRIPTION: Updates the custom key-value pair data (formatted as `k1:v1,k2:v2,k3:v3`) associated with an existing Namespace using the `--namespace_data <data>` modifier with `tctl namespace update`. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --namespace_data <data>\n```\n\n----------------------------------------\n\nTITLE: Enabling an API Key with Resource Version - tcld CLI - Bash\nDESCRIPTION: This variant uses the --resource-version option to restrict the enable command to a specific etag of the API Key for proper concurrency management. It prevents enabling outdated versions in distributed or scripted environments.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/apikey.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntcld apikey enable --id <apikey_id> --resource-version <version>\n```\n\n----------------------------------------\n\nTITLE: Defining Audience URI Pattern for Okta SAML Integration\nDESCRIPTION: Specifies the required format pattern for the Audience URI (SP Entity ID) when configuring an Okta SAML 2.0 application integration for Temporal Cloud. Users must replace 'ACCOUNT_ID' with their specific Temporal Cloud Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nurn:auth0:prod-tmprl:ACCOUNT_ID-saml\n```\n\n----------------------------------------\n\nTITLE: Using ZoomingImage Component for Embedded Images in JSX\nDESCRIPTION: Shows how to use the ZoomingImage component to provide small, expandable images that don't interfere with the main content flow. It includes the basic usage syntax with src and alt attributes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n<ZoomingImage src=\"/path/to/image\" alt=\"Alt text\" />\n```\n\n----------------------------------------\n\nTITLE: Setting Activity Timeout with ActivityStub in Java\nDESCRIPTION: This snippet demonstrates how to set Activity Timeouts using an ActivityStub within a Workflow implementation. It showcases setting the ScheduleToCloseTimeout and comments out other timeout options.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_20\n\nLANGUAGE: java\nCODE:\n```\nGreetingActivities activities = Workflow.newActivityStub(GreetingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setScheduleToCloseTimeout(Duration.ofSeconds(5))\n                        // .setStartToCloseTimeout(Duration.ofSeconds(2)\n                        // .setScheduletoCloseTimeout(Duration.ofSeconds(20))\n                        .build());\n```\n\n----------------------------------------\n\nTITLE: Updating Failover Clusters for a Global Namespace using tctl\nDESCRIPTION: Updates the list of failover Temporal Clusters (space-separated names) for a Global Namespace using the `--clusters <names>` modifier with `tctl namespace update`. This modifier is only valid if the Namespace is already configured as global. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --clusters <names>\n```\n\n----------------------------------------\n\nTITLE: Marking a Namespace as Global during Registration with tctl\nDESCRIPTION: Specifies whether the Namespace being registered is a Global Namespace using the `--global_namespace <boolean>` flag with `tctl namespace register`. Setting this to true enables cross-cluster replication features but cannot be changed later. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --global_namespace <boolean>\n```\n\n----------------------------------------\n\nTITLE: Setting Up Proxy Environment Variable\nDESCRIPTION: Command to set up proxy support for Temporal CLI\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/cli/index.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nexport HTTPS_PROXY=<host>:<port>\n```\n\n----------------------------------------\n\nTITLE: Updating API Key in TypeScript SDK v1.10.0+\nDESCRIPTION: Updates the API key on an existing connection in TypeScript SDK v1.10.0 or newer. Works for both Connection and NativeConnection objects using the setApiKey method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconnection.setApiKey(<APIKey>);\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Content for ToolTipTerm Component in JSX\nDESCRIPTION: Demonstrates how to use the 'src' prop to select a different Markdown file for content, and how to use the 'tooltip' prop to add non-reusable, custom content for a specific tooltip term.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n<Components.ToolTipTerm term=\"fail over\" src=\"failover\" />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n<Components.ToolTipTerm term=\"your term\" tooltip=\"any custom content you want to add\" />\n```\n\n----------------------------------------\n\nTITLE: Querying Matching Service Persistence Request Rate by Operation using PromQL\nDESCRIPTION: This Prometheus query calculates the per-second average rate of persistence requests (`persistence_requests`) made by the Matching Service (`service_name=\"matching\"`) over the last 5 minutes, aggregated by operation type (`operation`). It uses a variable `$cluster`. This helps monitor the load on the persistence layer caused by the Matching Service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_13\n\nLANGUAGE: PromQL\nCODE:\n```\nsum by (operation) (rate(persistence_requests{cluster=\"$cluster\",service_name=\"matching\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Classic Cron Schedule Specification\nDESCRIPTION: Shows the format for classic cron schedule specification with minute, hour, day of month, month, and day of week fields.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/workflow/cron-job.mdx#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12)\n│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n│ │ │ │ │\n│ │ │ │ │\n* * * * *\n```\n\n----------------------------------------\n\nTITLE: Adding a Description during Namespace Registration with tctl\nDESCRIPTION: Adds a descriptive text to a Namespace during registration using the `--description <value>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --description <value>\n```\n\n----------------------------------------\n\nTITLE: Configuring Archival Settings - Disabled in YAML\nDESCRIPTION: Example configuration for disabling archival features across both history and visibility components.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\narchival:\n  history:\n    state: 'disabled'\n    enableRead: false\n  visibility:\n    state: 'disabled'\n    enableRead: false\n\nnamespaceDefaults:\n  archival:\n    history:\n      state: 'disabled'\n    visibility:\n      state: 'disabled'\n```\n\n----------------------------------------\n\nTITLE: Printing raw timestamp in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that displays raw timestamp values in the output.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --print_raw_time\n```\n\n----------------------------------------\n\nTITLE: Configuring Cluster Metadata in YAML\nDESCRIPTION: Example configuration for cluster metadata settings including global namespace, failover version, and cluster information for multi-cluster replication.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/configuration.mdx#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nclusterMetadata:\n  enableGlobalNamespace: true\n  failoverVersionIncrement: 10\n  masterClusterName: 'active'\n  currentClusterName: 'active'\n  clusterInformation:\n    active:\n      enabled: true\n      initialFailoverVersion: 0\n      rpcAddress: '127.0.0.1:7233'\n  #replicationConsumer:\n  #type: kafka\n```\n\n----------------------------------------\n\nTITLE: Using RelatedReadItem Component in MDX\nDESCRIPTION: Example demonstrating how to use the RelatedReadItem component with props for path, text, and archetype to create a related reading link.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<RelatedReadItem\n    path=\"/cloud/metrics/prometheus-grafana\"\n    text=\"How to set up Grafana with Temporal Cloud observability\"\n    archetype=\"feature-guide\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Using CaptionedImage with Zoom Functionality\nDESCRIPTION: Example showing how to enable zoom functionality on a CaptionedImage by setting the zoom prop to true, useful for complex images that need detailed viewing.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<CaptionedImage\n    src=\"/path/to/your/image\"\n    title=\"your caption\"\n    zoom=\"true\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Querying Schedule Action Success Rate - PromQL\nDESCRIPTION: PromQL query to measure the rate of successful schedule executions within a 5-minute interval. Used to monitor the health of scheduled workflow executions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_20\n\nLANGUAGE: promql\nCODE:\n```\nsum(rate(schedule_action_success{namespace=\"$namespace\"}[5m]))\n```\n\n----------------------------------------\n\nTITLE: Defining Terms for ToolTipTerm Component in Markdown\nDESCRIPTION: Explains how to define terms for the ToolTipTerm component using Markdown files. It includes an example of a term definition file and its contents.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\nP95 refers to the 95th percentile of a data set.\nIt identifies values that are greater than or equal to 95% of that set.\n```\n\n----------------------------------------\n\nTITLE: Serializing events to file in tctl workflow showid command\nDESCRIPTION: Command modifier for the workflow showid command that saves event information to a specified file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow showid <workflow_id> --output_filename <filename>\n```\n\n----------------------------------------\n\nTITLE: Running Nexus Handler Worker for Local Development\nDESCRIPTION: Bash command to run a Nexus handler Worker connected to a local development server. This worker processes incoming Nexus requests in the specified namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./gradlew -q execute -PmainClass=io.temporal.samples.nexus.handler.HandlerWorker \\\n    --args=\"-target-host localhost:7233 -namespace my-target-namespace\"\n```\n\n----------------------------------------\n\nTITLE: Querying Percentile History Service Persistence Latency by Operation using PromQL\nDESCRIPTION: This Prometheus query calculates a specified percentile (defined by `$percentile`) of the latency for persistence operations (`persistence_latency_bucket`) initiated by the History Service (`service_name=\"history\"`) over the last 1 minute. It uses a variable `$service` and aggregates results by operation type (`operation`). This helps identify slow persistence operations.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_16\n\nLANGUAGE: PromQL\nCODE:\n```\nhistogram_quantile($percentile, sum(rate(persistence_latency_bucket{service=\"$service\" service_name=\"history\"}[1m])) by (operation, le))\n```\n\n----------------------------------------\n\nTITLE: Testing PrivateLink with grpcURL\nDESCRIPTION: Command to test AWS PrivateLink connectivity using grpcURL. This example shows how to override the TLS server name and make a gRPC call to the Temporal Cloud service.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/evaluate/temporal-cloud/aws-privatelink.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngrpcurl \\\n    -servername <namespace_id>.<account_id>.tmprl.cloud \\\n    -cert /path/to/client.pem \\\n    -key /path/to/client.key \\\n    <DNS ASSOCIATED WITH VPC ENDPOINT>:7233 \\\n    temporal.api.workflowservice.v1.WorkflowService/GetSystemInfo\n```\n\n----------------------------------------\n\nTITLE: Installing tcld CLI for Temporal Cloud\nDESCRIPTION: Bash command to install the Temporal Cloud CLI (tcld) using Homebrew. This tool is required for creating namespaces and Nexus endpoints in Temporal Cloud.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nbrew install temporalio/brew/tcld\n```\n\n----------------------------------------\n\nTITLE: Querying Service Latency SLOs with Prometheus - PromQL\nDESCRIPTION: This PromQL snippet calculates the 99th percentile (P99) service latency for mission-critical Temporal Cloud operations such as SignalWithStartWorkflowExecution and StartWorkflowExecution. It utilizes the histogram_quantile function on the temporal_cloud_v0_service_latency_bucket metric to obtain latency distributions, supporting analysis by temporal_namespace, operation, and latency bucket (le label). No external dependencies are needed beyond a Prometheus instance scraping these metric series. Returns time series data representing the P99 latency grouped by namespace and operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/service-health.mdx#2025-04-23_snippet_0\n\nLANGUAGE: promql\nCODE:\n```\nhistogram_quantile(0.99, sum(rate(temporal_cloud_v0_service_latency_bucket[$__rate_interval])) by (temporal_namespace, operation, le))\n```\n\n----------------------------------------\n\nTITLE: Creating Caller and Handler Namespaces for Nexus\nDESCRIPTION: Commands to create separate namespaces for the caller and handler in Temporal. This setup is used to demonstrate cross-namespace Nexus calls.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/temporal-nexus.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace create --namespace my-target-namespace\ntemporal operator namespace create --namespace my-caller-namespace\n```\n\n----------------------------------------\n\nTITLE: Promoting Existing Build ID Within Set in Java (Deprecated)\nDESCRIPTION: This deprecated snippet demonstrates how to promote an existing Build ID to be the default within its compatibility set on a Task Queue.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/worker-versioning-legacy.mdx#2025-04-23_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nworkflowClient.updateWorkerBuildIdCompatability(\n    \"your_task_queue_name\", BuildIdOperation.promoteBuildIdWithinSet(\"deadbeef\"));\n```\n\n----------------------------------------\n\nTITLE: Starting Patch-Complete Workflow in Python\nDESCRIPTION: Command to start a workflow instance using the patch-complete workflow implementation. This represents the final stage where the patch has been fully implemented.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python starter.py --start-workflow patch-complete-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Querying 'AddWorkflowTask' Request Rate using PromQL\nDESCRIPTION: This Prometheus query calculates the total per-second average rate of `service_requests` specifically for the 'AddWorkflowTask' operation over the last 2 minutes. This helps monitor the frequency of new workflow tasks being added.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/references/cluster-metrics.mdx#2025-04-23_snippet_1\n\nLANGUAGE: PromQL\nCODE:\n```\nsum(rate(service_requests{operation=\\\"AddWorkflowTask\\\"}[2m]))\n```\n\n----------------------------------------\n\nTITLE: Configuring Worker Tuning in Java SDK\nDESCRIPTION: Examples of configuring WorkerOptions using ResourceBasedTuner and CompositeTuner with different slot suppliers for workflow, activity, local activity and nexus tasks.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/worker-performance.mdx#2025-04-23_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n// Just resource based\nWorkerOptions.newBuilder()\n    .setWorkerTuner(\n        ResourceBasedTuner.newBuilder()\n            .setControllerOptions(\n                ResourceBasedControllerOptions.newBuilder(0.8, 0.9).build())\n            .build())\n    .build())\n// Combining different types\nSlotSupplier<WorkflowSlotInfo> workflowTaskSlotSupplier = new FixedSizeSlotSupplier<>(10);\nSlotSupplier<ActivitySlotInfo> activityTaskSlotSupplier =\n    ResourceBasedSlotSupplier.createForActivity(\n        resourceController, ResourceBasedTuner.DEFAULT_ACTIVITY_SLOT_OPTIONS);\nSlotSupplier<LocalActivitySlotInfo> localActivitySlotSupplier =\n    ResourceBasedSlotSupplier.createForLocalActivity(\n        resourceController, ResourceBasedTuner.DEFAULT_ACTIVITY_SLOT_OPTIONS);\nSlotSupplier<NexusSlotInfo> nexusSlotSupplier = new FixedSizeSlotSupplier<>(10);\n\nWorkerOptions.newBuilder()\n    .setWorkerTuner(\n        new CompositeTuner(\n            workflowTaskSlotSupplier,\n            activityTaskSlotSupplier,\n            localActivitySlotSupplier,\n            nexusSlotSupplier))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Importing All Components with Namespace in MDX\nDESCRIPTION: Example showing how to import all components at once with a namespace prefix, allowing access to any component through the Components prefix.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as Components from '@site/src/components';\n```\n\n----------------------------------------\n\nTITLE: Using Namespaced Components in MDX\nDESCRIPTION: Example demonstrating how to use components imported with a namespace, specifically the DiscoverableDisclosure component with content nested inside.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Components.DiscoverableDisclosure>\n...Content that is folded away...\n</Components.DiscoverableDisclosure>\n```\n\n----------------------------------------\n\nTITLE: Starting Patched Workflow in Python\nDESCRIPTION: Command to start a workflow instance using the patched workflow implementation. This creates a new workflow that will use the updated code path.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python starter.py --start-workflow patched-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Removing Client CA Certificate using Encoded String\nDESCRIPTION: This command removes a client CA certificate using a base64-encoded string of a CA certificate PEM file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca remove \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Printing Hello World in Ruby\nDESCRIPTION: A simple Ruby code snippet that prints 'hello world' to the console using the puts method.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/test/bad.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nputs \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Checking Build ID Reachability in Temporal CLI\nDESCRIPTION: This command uses the Temporal CLI to check the reachability of a specific Build ID across Task Queues. It determines whether the Build ID is unreachable, only reachable by closed Workflows, or reachable by open and new Workflows.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/worker-versioning-legacy.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntemporal task-queue get-build-id-reachability\n```\n\n----------------------------------------\n\nTITLE: Creating a Default Namespace with Temporal CLI\nDESCRIPTION: Command to create a default Namespace using the Temporal CLI operator. This is required when deploying through Temporal Helm charts to establish the default Namespace.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/namespaces/namespaces.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntemporal operator namespace create --namespace default\n```\n\n----------------------------------------\n\nTITLE: Starting Initial Workflow in Python\nDESCRIPTION: Command to start a workflow instance using the initial workflow implementation. This creates a new workflow with the specified ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/version_your_workflows/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python starter.py --start-workflow initial-workflow-id\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates using Encoded String\nDESCRIPTION: This command sets client CA certificates using a base64-encoded string of a CA certificate PEM file.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: OR Condition for Multiple WorkflowIds\nDESCRIPTION: List Filter that matches either of two specified WorkflowIds using the OR operator.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/visibility/list-filter.mdx#2025-04-23_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\nWorkflowId = '<workflow-id>' or WorkflowId = '<another-workflow-id>'\n```\n\n----------------------------------------\n\nTITLE: Listing Accepted Client CA Expiration Date with tcld - Command\nDESCRIPTION: This snippet lists the expiration date of the accepted client CA certificate for a given Temporal Cloud namespace using the tcld CLI and jq for parsing JSON output. It requires that both tcld and jq are installed and assumes appropriate namespace and account IDs are provided. The output is the certificate's notAfter field, indicating its expiration date; make sure to replace <namespace_id>.<account_id> with the actual values.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/troubleshooting/last-connection-error.mdx#2025-04-23_snippet_0\n\nLANGUAGE: command\nCODE:\n```\ntcld namespace accepted-client-ca list \\\n    --namespace <namespace_id>.<account_id> | \\\n    jq -r '.[0].notAfter'\n```\n\n----------------------------------------\n\nTITLE: Adding Futures to Selectors in Temporal Go SDK\nDESCRIPTION: Example showing how to add Futures to a Selector after executing Activities, and how to conditionally or repeatedly call Select() to handle multiple pending Futures.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/selectors.mdx#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// API Example: defer code execution until after an activity is done\nwork := workflow.ExecuteActivity(ctx, ExampleActivity)\nselector.AddFuture(work, func(f workflow.Future) {\n\t// deferred code omitted...\n})\n```\n\nLANGUAGE: go\nCODE:\n```\n\t// API Example: blocking conditionally\n  if somecondition != nil {\n\t\tselector.Select(ctx)\n  }\n\n\t// API Example: popping off all remaining Futures\n  for i := 0; i < len(someArray); i++ {\n\t\tselector.Select(ctx) // this will wait for one branch\n\t\t// you can interrupt execution here\n\t}\n```\n\n----------------------------------------\n\nTITLE: Cloning the Temporal Go SDK Repository\nDESCRIPTION: Command to clone the Temporal Go SDK repository from GitHub to your local machine.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:temporalio/sdk-go.git\n```\n\n----------------------------------------\n\nTITLE: Creating a Nexus Endpoint with tcld CLI - Shell\nDESCRIPTION: This snippet demonstrates how to create a Nexus Endpoint using the `tcld` CLI, enabling secure routing of requests from a caller to a handler Namespace within Temporal Cloud. Requires at least Developer role and NamespaceAdmin permission on the target namespace. Key options include endpoint name, the handler's task queue, target namespace, caller namespace allowlist, and an optional description file. Placeholders such as `<my-nexus-endpoint-name>`, `<my-target-namespace.account>`, and `<my-caller-namespace.account>` should be replaced with actual values. Ensures cross-namespace invocation with runtime access control.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/temporal-nexus.mdx#2025-04-23_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ntcld nexus endpoint create \\\n  --name <my-nexus-endpoint-name> \\\n  --target-task-queue my-handler-task-queue \\\n  --target-namespace <my-target-namespace.account> \\\n  --allow-namespace <my-caller-namespace.account> \\\n  --description-file description.md\n```\n\n----------------------------------------\n\nTITLE: Illustrating Initial Namespace Version (Cluster A Active)\nDESCRIPTION: Example showing the initial state of Namespace α. When registered with Cluster A (initial version 1) as the active cluster, the namespace's version is set to 1. All subsequent workflow events within this namespace will be tagged with version 1.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nnamespace α's version is 1\nall workflows events generated within this namespace, will come with version 1\n```\n\n----------------------------------------\n\nTITLE: Describing a Schedule for a Workflow in Go\nDESCRIPTION: This code demonstrates how to describe a Schedule for a Workflow using the Go SDK. It uses the Describe() method on the ScheduleHandle to retrieve information about the current Schedule configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/schedules.mdx#2025-04-23_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n// ...\n\tscheduleHandle.Describe(ctx)\n// ...\n```\n\n----------------------------------------\n\nTITLE: Printing Hello World in Ruby\nDESCRIPTION: A simple Ruby code snippet that prints 'hello world' to the console.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/test/good.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\nputs \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Creating Branch for Documentation Changes\nDESCRIPTION: Command to create and switch to a new branch for documentation contributions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-documentation-contribution\n```\n\n----------------------------------------\n\nTITLE: Updating History Archival URI for a Namespace using tctl\nDESCRIPTION: Updates the URI for storing archived Workflow Execution History using the `--history_uri <uri>` modifier with `tctl namespace update`. Note: The documentation states the URI cannot be changed after Archival is first enabled. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --history_uri <uri>\n```\n\n----------------------------------------\n\nTITLE: Illustrating Version History State at T=4 (Post-Failover)\nDESCRIPTION: This table shows the state at T=4 after adding another event (ID 5) with version 2. The version history is updated to show that event ID 5 is now the last event associated with version 2.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/multi-cluster-replication.mdx#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n| -------- | --------------- | --------------- | ------- |\n| Events   | Version History |                 |         |\n| -------- | --------------- | --------------- | ------- |\n| Event ID | Event Version   | Event ID        | Version |\n| -------- | -------------   | --------------- | ------- |\n| 1        | 1               | 3               | 1       |\n| 2        | 1               | 5               | 2       |\n| 3        | 1               |                 |         |\n| 4        | 2               |                 |         |\n| 5        | 2               |                 |         |\n| -------- | -------------   | --------------- | ------- |\n```\n\n----------------------------------------\n\nTITLE: Customizing Workflow Type Names in Java\nDESCRIPTION: Shows how to set a custom name for a Workflow Type using the @WorkflowMethod annotation's name parameter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/java/core-application.mdx#2025-04-23_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n@WorkflowInterface\n\n  public interface NotifyUserAccounts {\n  @WorkflowMethod(name = \"your-workflow\")\n  void notify(String[] accountIds);\n  }\n```\n\n----------------------------------------\n\nTITLE: Generating CA Certificate with Organization using tcld\nDESCRIPTION: This command generates a Certificate Authority (CA) certificate using `tcld`, specifying the organization name via the `--organization` modifier. Replace `<value>` with the actual organization name.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/generate-certificates.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld generate-certificates certificate-authority-certificate --organization <value>\n```\n\n----------------------------------------\n\nTITLE: Setting Visibility Archival State during Namespace Registration with tctl\nDESCRIPTION: Sets the state ('disabled' or 'enabled') for Visibility record Archival for the Namespace being registered using the `--visibility_archival_state <value>` modifier with `tctl namespace register`. The target namespace must be specified via the global `--namespace` flag.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace register --visibility_archival_state <value>\n```\n\n----------------------------------------\n\nTITLE: Implementing PhotoCarousel Component in React/JSX\nDESCRIPTION: A React component implementation that displays a carousel of images with captions explaining the non-deterministic workflow concept. The component takes arrays of image URLs and corresponding captions as props.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/event-history/java.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<PhotoCarousel\n  images={[\n    \"https://learn.temporal.io/courses/temporal-102/java/event-history-walkthrough/nondeterministic-workflow/nondeterministic-workflow.001.jpeg\",\n    \"https://learn.temporal.io/courses/temporal-102/java/event-history-walkthrough/nondeterministic-workflow/nondeterministic-workflow.002.jpeg\",\n    // ... additional image URLs\n  ]}\n  captions={[\n    \"NA\",\n    \"Imagine the following Workflow Definition is being executed.\",\n    // ... additional captions\n  ]}\n/>\n```\n\n----------------------------------------\n\nTITLE: Starting Dynamic Workflow Worker (Bash/Python)\nDESCRIPTION: Executes the Python script `your_worker_workflow_dacx.py` using `poetry run`. This script starts a Temporal Worker configured to listen for tasks on the `dynamic-workflow-task-queue` and handle dynamic workflow executions (requests to start workflows whose types are not explicitly registered with the worker).\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/dynamic_handlers/README.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python your_worker_workflow_dacx.py\n```\n\n----------------------------------------\n\nTITLE: JWT Permissions Claim Syntax for Temporal Roles (Markdown)\nDESCRIPTION: This markdown snippet describes the expected syntax for individual permission claims within a JWT token for Temporal. Each claim must be structured as '<namespace> : <permission>' and is interpreted by the ClaimMapper to assign roles. Ensuring proper formatting is required for permission mapping; extraneous white space or misused delimiters may result in incorrect role assignment or authorization failures.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/security.mdx#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n<namespace> : <permission>\n```\n\n----------------------------------------\n\nTITLE: Expected Worker Log Output on Successful Connection\nDESCRIPTION: This text snippet shows the expected log output from the Temporal Worker container when it successfully initializes and starts polling for tasks. Seeing these lines in the pod logs confirms that the Worker is running and connected to the Temporal Cluster specified in its configuration.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/how-to-guides/deploy-workers-to-aws-eks.mdx#2025-04-23_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n```\nInitializing worker...\nStarting worker... Waiting for tasks.\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Client Connection with TypeScript SDK pre-v1.10.0 using API Key\nDESCRIPTION: Establishes a client connection to Temporal Cloud using TypeScript SDK versions prior to 1.10.0. Sets the API key in the metadata object with an Authorization header.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/get-started/api-keys.mdx#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = await Connection.connect({\n    address: <endpoint>,\n    tls: true,\n    metadata: {\n        'Authorization': `Bearer ${<APIKey>}`,\n        'temporal-namespace': <namespace_id>.<account_id>,\n    },\n})\nconst client = new Client({\n    connection,\n    namespace: <namespace_id>.<account_id>,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Client CA Certificates using Certificate File\nDESCRIPTION: This command sets client CA certificates by specifying the path to a CA certificate PEM file instead of using an encoded string.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace accepted-client-ca set \\\n    --ca-certificate-file <path>\n```\n\n----------------------------------------\n\nTITLE: Setting up PostgreSQL Visibility Schema using Bash Script\nDESCRIPTION: This Bash script snippet, extracted from an auto-setup script, shows how to initialize the PostgreSQL schema for Temporal Visibility. It sets environment variables for database names and connection details, then uses the 'temporal-sql-tool' with the appropriate plugin to create the visibility database (if needed) and apply the correct schema version located in 'VISIBILITY_SCHEMA_DIR'.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/visibility.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n#...\n# set your PostgreSQL environment variables\n: \"${DBNAME:=temporal}\"\n: \"${VISIBILITY_DBNAME:=temporal_visibility}\"\n: \"${DB_PORT:=}\"\n: \"${POSTGRES_SEEDS:=}\"\n: \"${POSTGRES_USER:=}\"\n: \"${POSTGRES_PWD:=}\"\n\n#... set connection details\n# set up PostgreSQL schema\nsetup_postgres_schema() {\n    #...\n\n    # use valid schema for the version of the database you want to set up for Visibility\n    VISIBILITY_SCHEMA_DIR=${TEMPORAL_HOME}/schema/postgresql/${POSTGRES_VERSION_DIR}/visibility/versioned\n    if [[ ${VISIBILITY_DBNAME} != \"${POSTGRES_USER}\" && ${SKIP_DB_CREATE} != true ]]; then\n        temporal-sql-tool --plugin postgres --ep \"${POSTGRES_SEEDS}\" -u \"${POSTGRES_USER}\" -p \"${DB_PORT}\" --db \"${VISIBILITY_DBNAME}\" create\n    fi\n    temporal-sql-tool --plugin postgres --ep \"${POSTGRES_SEEDS}\" -u \"${POSTGRES_USER}\" -p \"${DB_PORT}\" --db \"${VISIBILITY_DBNAME}\" update-schema -d \"${VISIBILITY_SCHEMA_DIR}\"\n  #...\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Namespace Permissions to a User by ID via tcld CLI - Command\nDESCRIPTION: Sets namespace-level permissions for a user identified by user ID. This command allows you to specify permissions for one or more namespaces. As with other role/permission commands, request IDs and ETags can optimize or monitor the update.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_12\n\nLANGUAGE: command\nCODE:\n```\ntcld user set-namespace-permissions --user-id <test-user-id>\n```\n\n----------------------------------------\n\nTITLE: Failing Over a Namespace Region with TCLD CLI - Bash\nDESCRIPTION: Performs a region failover in a Temporal Cloud Namespace using `tcld namespace failover`. The `--namespace` and `--region` flags specify the target Namespace and the new primary region, respectively. This command is used to switch high-availability regions for fault tolerance or maintenance. Inputs are the target namespace and region; output indicates success or failure of the operation.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace failover \\\n    --namespace <namespace_id>.<account_id> \\\n    --region <target_region>\n```\n\n----------------------------------------\n\nTITLE: Getting Namespace Information with TCLD CLI - Bash\nDESCRIPTION: Fetches details for a given Temporal Cloud Namespace using the `tcld namespace get` command. Requires the `--namespace` flag to specify the namespace of interest. This is used for auditing and verifying Namespace configuration and metadata. The sole input is the namespace ID; output is namespace details as provided by the CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/namespace.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntcld namespace get \\\n    --namespace <namespace_id>\n```\n\n----------------------------------------\n\nTITLE: Running Workflow Script – Bash\nDESCRIPTION: Executes the Python workflow script 'run_workflow.py' using Python 3. Assumes the user has Python 3 installed and the script is present in the current directory. No command-line arguments are passed, and output is determined by the script itself.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/python/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 run_workflow.py\n```\n\n----------------------------------------\n\nTITLE: Local Development Setup Commands\nDESCRIPTION: Commands to install dependencies and start local development server for preview.\nSOURCE: https://github.com/temporalio/documentation/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn            # Install site dependencies\nyarn start      # Start the website on a local port\nyarn build      # Check for build warnings or errors\n```\n\n----------------------------------------\n\nTITLE: Testing Temporal Cloud Metrics Endpoint with curl and Certificates\nDESCRIPTION: Demonstrates how to test the configured Temporal Cloud metrics endpoint using `curl`. This command requires providing the paths to the client certificate (`client-cert.pem`) and private key (`client-cert.key`). It queries a specific Prometheus metric (`temporal_cloud_v0_state_transition_count`) to verify connectivity and check if data is being received.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/metrics/general-setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl -v --cert <path to your client-cert.pem> --key <path to your client-cert.key> \"<your generated Temporal Cloud prometheus_endpoint>/api/v1/query?query=temporal_cloud_v0_state_transition_count\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Operator Identity for tctl Activity Failure (Bash) (Note: Example correction likely needed)\nDESCRIPTION: This command is intended to show how to specify the operator's identity using the `--identity` modifier when failing a Temporal Activity Execution with the deprecated `tctl` tool. However, the provided example incorrectly uses `tctl activity complete`; it should likely be `tctl activity fail --identity <value>`. Replace `<value>` with the operator's identity. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --identity <value>\n```\n\n----------------------------------------\n\nTITLE: Using CaptionedImage Component in MDX\nDESCRIPTION: Example showing how to use the CaptionedImage component with src and title props to display an image with a caption that works in both light and dark modes.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<CaptionedImage\n    src=\"/path/to/your/image\"\n    title=\"your caption\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Setting Temporal API Key Environment Variable on Windows\nDESCRIPTION: Sets the TEMPORAL_API_KEY environment variable on Windows systems using the command prompt. This variable allows the Terraform Temporal Cloud provider to authenticate with Temporal Cloud. Replace `<your-secret-key>` with the actual secret key from `tcld apikey create`.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/terraform-provider.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# replace <your-secret-key> with the \"secretKey\": output from tcld apikey create command\nset TEMPORAL_API_KEY=<your-secret-key>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Enabled Temporal Cloud Features with tcld (Bash)\nDESCRIPTION: Shows an example of using the `tcld feature get` command (alias `g`) to retrieve a list of enabled features and their current status (true/false) in Temporal Cloud. This command requires no additional parameters or modifiers.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/feature.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntcld feature get\n```\n\n----------------------------------------\n\nTITLE: Setting OriginalTaskQueueName in ActivityOptions - Temporal Go SDK - Go\nDESCRIPTION: Demonstrates how to configure the `OriginalTaskQueueName` in ActivityOptions, allowing the Activity to reference or be scheduled on a specific, original Task Queue. Assumes the developer has imported `go.temporal.io/sdk/workflow` and prepared a valid workflow context. Standard execution and error management patterns are applied.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/go/core-application.mdx#2025-04-23_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nactivityOptions := workflow.ActivityOptions{\n  OriginalTaskQueueName: \"your-original-task-queue-name\",\n}\nctx = workflow.WithActivityOptions(ctx, activityOptions)\nvar yourActivityResult YourActivityResult\nerr = workflow.ExecuteActivity(ctx, YourActivityDefinition, yourActivityParam).Get(ctx, &yourActivityResult)\nif err != nil {\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing Site Components in JavaScript/TypeScript\nDESCRIPTION: This JavaScript/TypeScript code imports all exported members from the '@site/src/components' module and groups them under the alias 'Components'. This is a common practice in documentation site generators like Docusaurus to make shared UI components available for use within the specific documentation page (MDX file).\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/high-availability/references/glossary.mdx#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as Components from '@site/src/components';\n```\n\n----------------------------------------\n\nTITLE: Starting the Temporal Development Server - Bash\nDESCRIPTION: Shows how to launch a local Temporal development server using the Temporal CLI. This command starts the Temporal Server and the Web UI with in-memory persistence by default, enabling rapid development without any external dependencies. The server becomes accessible at localhost:7233, and the Web UI at http://localhost:8233.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntemporal server start-dev\n\n```\n\n----------------------------------------\n\nTITLE: Defining Entity ID Pattern for Microsoft Entra ID SAML Integration\nDESCRIPTION: Specifies the required format pattern for the Identifier (Entity ID) when configuring a Microsoft Entra ID Enterprise application for Temporal Cloud SAML. Users must replace 'ACCOUNT_ID' with their specific Temporal Cloud Account ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/saml.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nurn:auth0:prod-tmprl:ACCOUNT_ID-saml\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Client with Custom Failure Converter in Go\nDESCRIPTION: This Go code snippet demonstrates how to initialize a Temporal client using `client.Dial`. It configures the client with a custom `DataConverter` (`mycustom.DataConverter`) and modifies the default `FailureConverter` by setting `EncodeCommonAttributes: true`. This ensures that sensitive information in error messages and stack traces is encoded using the specified `DataConverter`, enhancing security.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/encyclopedia/data-conversion/failure-converter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\nc, err := client.Dial(client.Options{\n\t// Set DataConverter here to ensure that workflow inputs and results are\n\t// encoded as required.\n\tDataConverter: mycustom.DataConverter,\n\tFailureConverter: temporal.NewDefaultFailureConverter(temporal.DefaultFailureConverterOptions{\n\t\tEncodeCommonAttributes: true,\n\t}),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Worker (Go Example)\nDESCRIPTION: This command compiles and runs the main Go file for the Temporal Worker component of the sessions example application. It requires Go to be installed and a Temporal Cluster (or Temporal Cloud) to be accessible for the worker to connect to.\nSOURCE: https://github.com/temporalio/documentation/blob/main/sample-apps/go/features/sessions/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo run sessions/worker/main_dacx.go\n```\n\n----------------------------------------\n\nTITLE: Adding CA Certificate with Resource Version - tcld CLI - Bash\nDESCRIPTION: This snippet adds a CA certificate to the metrics endpoint with a resource version (ETag) for concurrency control. Dependencies: tcld CLI, proper authorization, and a valid resource version string. Required parameters include --resource-version (ETag value) and --ca-certificate (base64-encoded PEM). This approach is used to prevent overwriting changes in environments where the CA configuration is updated by multiple users.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca add --resource-version <etag> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Importing Components in MDX Files\nDESCRIPTION: Example showing how to import individual components from the site's component library in MDX files. Components should be imported at the top of the file after the frontmatter.\nSOURCE: https://github.com/temporalio/documentation/blob/main/COMPONENTS.md#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { CaptionedImage } from '@site/src/components';\n```\n\n----------------------------------------\n\nTITLE: Removing CA Certificate with Request ID - tcld CLI - Bash\nDESCRIPTION: This command removes a CA certificate from the metrics endpoint, specifying a request ID for asynchronous operation. Parameters: --request-id (tracks the async operation on the server) and --ca-certificate (the base64-encoded PEM string representing the certificate to remove). The certificate must match one that is currently configured. The tcld CLI must be authorized.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/account.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntcld account metrics accepted-client-ca remove --request-id <request_id> --ca-certificate <encoded_certificate>\n```\n\n----------------------------------------\n\nTITLE: Adding Temporal TypeScript SDK Packages to Existing Project - Bash\nDESCRIPTION: Installs the Temporal TypeScript SDK packages into an already-initialized Node.js project via npm. This command adds dependencies required for client, worker, workflow, activity, and shared code execution. Requires that 'npm' and Node.js 16.15+ are available in your environment.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/develop/typescript/core-application.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @temporalio/client @temporalio/worker @temporalio/workflow @temporalio/activity @temporalio/common\n\n```\n\n----------------------------------------\n\nTITLE: Verifying tcld Installation (bash)\nDESCRIPTION: This command executes the `tcld` tool with the `version` argument. It serves to verify that tcld has been installed correctly and is accessible through the system's PATH. The command should output the installed version number of the tcld CLI.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/index.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntcld version\n```\n\n----------------------------------------\n\nTITLE: Resending Invitation to a User by ID via tcld CLI - Bash\nDESCRIPTION: Sends another invitation email to a user using their unique user ID. The --user-id flag is used. The command is intended for users not responding to initial invites; requires proper permissions.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/cloud/tcld/user.mdx#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntcld user resend-invite --user-id <test-user-id>\n```\n\n----------------------------------------\n\nTITLE: Querying Temporal HTTP API using Curl Shell Command\nDESCRIPTION: Demonstrates making an HTTP GET request using `curl` to list workflow executions in the 'default' namespace via the Temporal Web UI's backend API running on `localhost:8233`. It also shows an example JSON response containing workflow execution details. This API is currently considered experimental.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/production-deployment/self-hosted-guide/server-frontend-api-reference.mdx#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ curl localhost:8233/api/v1/namespaces/default/workflows\n\n{\n  \"executions\": [\n    {\n      \"execution\": {\n        \"workflowId\": \"workflow-_homozdkzYWLRpX6Rfou5\",\n        \"runId\": \"c981cb26-baa4-4af8-ac5f-866451d3f83c\"\n      },\n      \"type\": {\n        \"name\": \"example\"\n      },\n      \"startTime\": ...\n    },\n    ...\n  ],\n  \"nextPageToken\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Workflow ID Reuse Policy Examples\nDESCRIPTION: Examples showing different Workflow ID reuse policy configurations\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_62\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow start --workflowidreusepolicy AllowDuplicate\ntctl workflow start --workflowidreusepolicy AllowDuplicateFailedOnly\ntctl workflow start --workflowidreusepolicy RejectDuplicate\n```\n\n----------------------------------------\n\nTITLE: Describing Workflow Execution with tctl (Bash)\nDESCRIPTION: Shows detailed information about a Workflow Execution using `tctl workflow describe`. Requires specifying the Workflow ID (`--workflow_id`). Can optionally specify a Run ID (`--run_id`) to target a specific run, print raw data (`--print_raw`), or show only reset points (`--reset_points_only`). If no Run ID is provided, it describes the latest run for the given Workflow ID.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Example using the required --workflow_id modifier\ntctl workflow describe --workflow_id <id>\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example specifying a Run ID\ntctl workflow describe --run_id <id>\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example printing raw properties\ntctl workflow describe --print_raw\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Example showing only reset points\ntctl workflow describe --reset_points_only\n```\n\n----------------------------------------\n\nTITLE: Running Workflow with Task Queue and Type in Bash\nDESCRIPTION: Example of using the tctl workflow run command with taskqueue and workflow_type modifiers. This starts a new Workflow Execution with the specified Task Queue and Workflow Type.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow run --taskqueue your-task-queue-name --workflow_type YourWorkflowDefinitionName\n```\n\n----------------------------------------\n\nTITLE: Resetting Workflow by Reset Type in Bash\nDESCRIPTION: Example of using the tctl workflow reset command with the reset_type modifier. This allows specifying the event type to which the Workflow Execution should be reset.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/workflow.mdx#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ntctl workflow reset --reset_type <value>\n```\n\n----------------------------------------\n\nTITLE: Updating Retention Period for a Namespace using tctl\nDESCRIPTION: Updates the Retention Period (in days) for closed Workflow Executions within an existing Namespace using the `--retention <value>` modifier with `tctl namespace update`. Requires the target namespace to be specified.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/namespace.mdx#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ntctl namespace update --retention <value>\n```\n\n----------------------------------------\n\nTITLE: Completing a tctl Activity using Run ID (Bash)\nDESCRIPTION: This command shows how to complete a specific Temporal Activity Execution using the deprecated `tctl` tool by specifying the Run ID with the `--run_id` (or `-r`) modifier. Replace `<id>` with the actual Run ID. Requires `tctl` v1.17 or compatible.\nSOURCE: https://github.com/temporalio/documentation/blob/main/docs/tctl-v1/activity.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntctl activity complete --run_id <id>\n```\n\n----------------------------------------\n\nTITLE: MIT License Text\nDESCRIPTION: Standard MIT License text granting permission to use, modify, and distribute software while providing liability protection for the authors. Includes copyright notice for Titus Wormer from 2015.\nSOURCE: https://github.com/temporalio/documentation/blob/main/vale/styles/alex/README.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n(The MIT License)\n\nCopyright (c) 2015 Titus Wormer <tituswormer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n```"
  }
]