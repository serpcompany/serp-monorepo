[
  {
    "owner": "ash-project",
    "repo": "ash",
    "content": "TITLE: Creating and Closing Tickets Example\nDESCRIPTION: Demonstrates creating a ticket and then closing it using the defined actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\nticket = (\n  Helpdesk.Support.Ticket\n  |> Ash.Changeset.for_create(:open, %{subject: \"My mouse won't click!\"})\n  |> Ash.create!()\n)\n\nticket =\n  ticket\n  |> Ash.Changeset.for_update(:close)\n  |> Ash.update!()\n```\n\n----------------------------------------\n\nTITLE: Creating a New Ash Project with Example Code\nDESCRIPTION: Command to create a new project with example code pre-installed using Igniter.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmix igniter.new helpdesk --install ash --extend ets --example\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple and Nested Relationships\nDESCRIPTION: Examples showing advanced relationship loading patterns including loading multiple relationships and nested relationships.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.load(users, [:tweets, :followers])\n```\n\n----------------------------------------\n\nTITLE: Creating a New Ash Project with PostgreSQL\nDESCRIPTION: Command to create a new project with Ash PostgreSQL support pre-installed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmix igniter.new helpdesk --install ash,ash_postgres --example --extend postgres\n```\n\n----------------------------------------\n\nTITLE: Complete Example of an Ash.Reactor Implementation for Customer Subscription Workflow\nDESCRIPTION: A comprehensive example showing a customer subscription workflow using Ash.Reactor. It demonstrates creating a customer, reading a plan, processing a payment, and creating a subscription.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/reactor.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule ExampleReactor do\n  use Ash.Reactor\n\n  ash do\n    default_domain ExampleDomain\n  end\n\n  input :customer_name\n  input :customer_email\n  input :plan_name\n  input :payment_nonce\n\n  create :create_customer, Customer do\n    inputs %{name: input(:customer_name), email: input(:customer_email)}\n  end\n\n  read_one :get_plan, Plan, :get_plan_by_name do\n    inputs %{name: input(:plan_name)}\n    fail_on_not_found? true\n  end\n\n  action :take_payment, PaymentProvider do\n    inputs %{\n      nonce: input(:payment_nonce),\n      amount: result(:get_plan, [:price])\n    }\n  end\n\n  create :subscription, Subscription do\n    inputs %{\n      plan_id: result(:get_plan, [:id]),\n      payment_provider_id: result(:take_payment, :id)\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Actor and Authorization Flag in Changesets\nDESCRIPTION: Example showing how to provide the actor and authorize? option when building a changeset for creation. This is the recommended place to set these options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/actors-and-authorization.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_create(Post, %{title: \"Post Title\"}, actor: current_user, authorize?: true)\n```\n\n----------------------------------------\n\nTITLE: Enhancing Ticket Resource with Additional Attributes\nDESCRIPTION: Elixir code showing how to enhance the Ticket resource with additional attributes and constraints.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/helpdesk/support/ticket.ex\n\nattributes do\n  ...\n  attribute :subject, :string do\n    # Don't allow `nil` values\n    allow_nil? false\n\n    # Allow this attribute to be public. By default, all attributes are private.\n    public? true\n  end\n\n  # status is either `open` or `closed`. We can add more statuses later\n  attribute :status, :atom do\n    # Constraints allow you to provide extra rules for the value.\n    # The available constraints depend on the type\n    # See the documentation for each type to know what constraints are available\n    # Since atoms are generally only used when we know all of the values\n    # it provides a `one_of` constraint, that only allows those values\n    constraints [one_of: [:open, :closed]]\n\n    # The status defaulting to open makes sense\n    default :open\n\n    # We also don't want status to ever be `nil`\n    allow_nil? false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Bulk Ticket Creation and Querying\nDESCRIPTION: Creates multiple tickets and demonstrates querying capabilities using Ash Framework.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\ntickets =\n  for i <- 0..5 do\n    ticket =\n      Helpdesk.Support.Ticket\n      |> Ash.Changeset.for_create(:open, %{subject: \"Issue #{i}\"})\n      |> Ash.create!()\n\n    if rem(i, 2) == 0 do\n      ticket\n      |> Ash.Changeset.for_update(:close)\n      |> Ash.update!()\n    else\n      ticket\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Creating Ticket Resource in Elixir with Ash Framework\nDESCRIPTION: Creates a new ticket resource with a subject. Shows basic resource creation with validation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\nHelpdesk.Support.Ticket\n|> Ash.Changeset.for_create(:open, %{subject: \"My mouse won't click!\"})\n|> Ash.create!()\n```\n\n----------------------------------------\n\nTITLE: Defining Support Domain Module\nDESCRIPTION: Elixir code defining an Ash domain module that registers the Ticket resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/helpdesk/support.ex\n\ndefmodule Helpdesk.Support do\n  use Ash.Domain\n\n  resources do\n    resource Helpdesk.Support.Ticket\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Create Action in Ash Resource\nDESCRIPTION: Demonstrates how to define a basic create action that accepts a title and sets a status attribute.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :open do\n  accept [:title]\n  change set_attribute(:status, :open)\nend\n```\n\n----------------------------------------\n\nTITLE: Many to Many Relationship Example in Ash Resource\nDESCRIPTION: Complete example showing how to set up a many_to_many relationship between Word and Book resources using a BookWord join resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\n# In a resource called `Word`\nmany_to_many :books, Book do\n  through BookWord\n  source_attribute :text\n  source_attribute_on_join_resource :word_text\n  destination_attribute :id\n  destination_attribute_on_join_resource :book_id\nend\n\n# And in `BookWord` (the join resource)\nbelongs_to :book, Book, primary_key?: true, allow_nil?: false\nbelongs_to :word, Word, primary_key?: true, allow_nil?: false\n```\n\n----------------------------------------\n\nTITLE: Defining Ticket Resource Module\nDESCRIPTION: Elixir code defining a basic Ticket resource with read and create actions, and a subject attribute.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/helpdesk/support/ticket.ex\n\ndefmodule Helpdesk.Support.Ticket do\n  # This turns this module into a resource\n  use Ash.Resource, domain: Helpdesk.Support\n\n  actions do\n    # Use the default implementation of the :read action\n    defaults [:read]\n\n    # and a create action, which we'll customize later\n    create :create\n  end\n\n  # Attributes are the simple pieces of data that exist on your resource\n  attributes do\n    # Add an autogenerated UUID primary key called `:id`.\n    uuid_primary_key :id\n\n    # Add a string type attribute called `:subject`\n    attribute :subject, :string\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Ticket with Ash\nDESCRIPTION: Elixir code demonstrating how to create a ticket using Ash.Changeset and Ash.create!.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nHelpdesk.Support.Ticket\n|> Ash.Changeset.for_create(:create)\n|> Ash.create!()\n```\n\n----------------------------------------\n\nTITLE: Creating Representative Resource in Ash Framework - Elixir\nDESCRIPTION: Creates a new representative record using Ash Framework's changeset and create operations. Demonstrates the basic pattern for creating resources with specific attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\nrepresentative = (\n  Helpdesk.Support.Representative\n  |> Ash.Changeset.for_create(:create, %{name: \"Joe Armstrong\"})\n  |> Ash.create!()\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Ash and AshPostgres in Current Project\nDESCRIPTION: This command installs Ash and AshPostgres into the current project using the igniter.install mix task.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/generators.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nmix igniter.install ash ash_postgres\n```\n\n----------------------------------------\n\nTITLE: Bulk Create Operation Example\nDESCRIPTION: Demonstrates how to perform bulk create operations with multiple records.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.bulk_create([%{title: \"Foo\"}, %{title: \"Bar\"}], Ticket, :open)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Domain with Resources in Elixir/Ash\nDESCRIPTION: Shows how to define an Ash domain that groups related resources together. This pattern organizes resources and provides structure to your project.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweets do\n  use Ash.Domain\n\n  resources do\n    resource MyApp.Tweets.Tweet\n    resource MyApp.Tweets.Comment\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Domain Resource Code Interface in Elixir\nDESCRIPTION: Shows how to define a code interface for a Ticket resource in a domain, allowing direct function calls like Helpdesk.Support.open_ticket(subject).\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nresources do\n  resource Ticket do\n    define :open_ticket, args: [:subject], action: :open\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Strict Access Type Policy in Ash\nDESCRIPTION: Shows how to create a strict policy that raises a forbidden error rather than filtering results when the condition is not met.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action(:read_hidden) do\n  access_type :strict\n\n  authorize_if actor_attribute_equals(:is_admin, true)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Attributes in Ash Framework (Elixir)\nDESCRIPTION: A comprehensive example of defining various attributes in an Ash resource, including primary keys, validation constraints, and timestamps.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nattributes do\n  uuid_primary_key :id\n\n  attribute :first_name, :string do\n    allow_nil? false\n  end\n\n  attribute :last_name, :string do\n    allow_nil? false\n  end\n\n  attribute :email, :string do\n    allow_nil? false\n\n    constraints [\n      match: ~r/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$/\n    ]\n  end\n\n  attribute :type, :atom do\n    constraints [\n      one_of: [:admin, :teacher, :student]\n    ]\n  end\n\n  create_timestamp :inserted_at\n  update_timestamp :updated_at\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Join Resource for many_to_many\nDESCRIPTION: Example showing how to define a join resource (TweetHashtag) used to establish a many_to_many relationship between Tweet and Hashtag resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.TweetHashtag do\n  use Ash.Resource,\n    data_layer: your_data_layer\n\n  postgres do\n    table \"tweet_hashtags\"\n    repo MyApp.Repo\n  end\n\n  relationships do\n    belongs_to :tweet, MyApp.Tweet, primary_key?: true, allow_nil?: false\n    belongs_to :hashtag, MyApp.Hashtag, primary_key?: true, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, :destroy, create: :*, update: :*]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Ticket Assignment in Ash Framework - Elixir\nDESCRIPTION: Updates an existing ticket by assigning it to a representative using Ash Framework's changeset and update operations. Shows how to modify existing resources with new relationships.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nticket\n|> Ash.Changeset.for_update(:assign, %{representative_id: representative.id})\n|> Ash.update!()\n```\n\n----------------------------------------\n\nTITLE: Creating New Mix Project with Ash and AshPostgres\nDESCRIPTION: These commands create a new mix project with Ash and AshPostgres installed. It requires the igniter_new archive to be installed first.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/generators.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nmix archive.install hex igniter_new\nmix igniter.new my_project --install ash,ash_postgres\n```\n\n----------------------------------------\n\nTITLE: Built-in Changes Usage in Elixir\nDESCRIPTION: Examples of using built-in changes in Ash resources for relating actors, setting attributes, and implementing optimistic locking.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# set the `owner` to the current actor\nchange relate_actor(:owner)\n\n# set `commited_at` to the current timestamp when the action is called\nchange set_attribute(:committed_at, &DateTime.utc_now/0)\n\n# optimistic lock using the `version` attribute\nchange optimistic_lock(:version)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Destroy Actions in Ash Framework\nDESCRIPTION: Shows how to define simple destroy actions in an Ash resource. The example includes both a standalone destroy action and how to add it with defaults.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy :destroy\n# Can be added with the defaults\ndefaults [:read, :destroy]\n```\n\n----------------------------------------\n\nTITLE: Basic Read Action Call Pattern\nDESCRIPTION: Shows the basic pattern for calling a read action in Ash Framework using Query.for_read and read! functions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/read-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nResource\n|> Ash.Query.for_read(:action_name, %{argument: :value}, ...opts)\n|> Ash.read!()\n```\n\n----------------------------------------\n\nTITLE: Defining Primary Action in Ash\nDESCRIPTION: Shows how to mark an action as primary in an Ash resource, which is used for automated circumstances where an action is not explicitly specified.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nread :action_name do\n  primary? true\nend\n```\n\n----------------------------------------\n\nTITLE: Directory Structure for Ash Applications\nDESCRIPTION: Illustrates the recommended file and directory structure for an Ash application, showing how to organize domains, resources, and supporting modules within an Elixir project.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/project-structure.md#2025-04-11_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nlib/\n├── my_app/                    # Your application's main namespace\n│   ├── accounts.ex            # Accounts domain module\n│   ├── helpdesk.ex            # Helpdesk domain module\n│   │\n│   ├── accounts/               # Accounts context\n│   │   ├── user.ex             # User resource\n│   │   ├── user/               # User resource files\n│   │   ├── token.ex            # Token resource\n│   │   └── password_helper.ex  # Support module\n│   │\n│   └── helpdesk/            # Helpdesk context\n│       ├── ticket.ex        # Ticket resource\n│       ├── notification.ex  # Notification resource\n│       ├── other_file.ex    # Support module\n│       └── ticket/          # Ticket resource files\n│           ├── preparations/\n│           ├── changes/\n│           └── checks/\n```\n\n----------------------------------------\n\nTITLE: Defining a has_many Relationship\nDESCRIPTION: Example showing how to define a has_many relationship from a User resource to Tweet resources. This establishes that a User can have multiple related Tweets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n# on MyApp.User\nhas_many :tweets, MyApp.Tweet\n```\n\n----------------------------------------\n\nTITLE: Blog Post Creation with Transaction Support in Ash.Reactor\nDESCRIPTION: Example demonstrating how to wrap a group of steps inside a data layer transaction. It shows creating a post and updating the author's post count within a transaction.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/reactor.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ninput :blog_title\ninput :blog_body\ninput :author_email\n\nread :get_author, MyBlog.Author, :get_author_by_email do\n  inputs %{email: input(:author_email)}\nend\n\ntransaction :create_post_transaction, [MyBlog.Post, MyBlog.Author] do\n  create :create_post, MyBlog.Post, :create do\n    inputs %{\n      title: input(:blog, [:title]),\n      body: input(:blog, [:body]),\n      author_id: result(:get_author, [:email])\n    }\n  end\n\n  update :author_post_count, MyBlog.Author, :update_post_count do\n    wait_for :create_post\n    initial result(:get_author)\n  end\n\n  return :create_post\nend\n\nreturn :create_post_transaction\n```\n\n----------------------------------------\n\nTITLE: Defining a Domain with Code Interface in Elixir/Ash\nDESCRIPTION: Shows how to define a domain with a custom code interface that provides clearer code, autocomplete, and inline documentation for working with resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweets do\n  use Ash.Domain\n\n  resources do\n    resource MyApp.Tweets.Tweet do\n      # define a function called `tweet` that uses\n      # the `:create` action on MyApp.Tweets.Tweet\n      define :tweet, action: :create, args: [:text]\n    end\n\n    resource MyApp.Tweets.Comment do\n      # define a function called `comment` that uses\n      # the `:create` action on MyApp.Tweets.Comment\n      define :comment, action: :create, args: [:tweet_id, :text]\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating New Phoenix Project with Ash, AshPostgres, and AshPhoenix\nDESCRIPTION: This command creates a new Phoenix project with Ash, AshPostgres, and AshPhoenix installed. It uses the igniter.new mix task with the phx.new option.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/generators.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nmix igniter.new my_project --install ash,ash_postgres,ash_phoenix --with phx.new\n```\n\n----------------------------------------\n\nTITLE: Using Builtin Validations in Ash Resources\nDESCRIPTION: Examples of using Ash's builtin validations including pattern matching, value comparison, and conditional presence validation with custom error messages.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate match(:email, ~r/@/)\n\nvalidate compare(:age, greater_than_or_equal_to: 18) do\n  message \"must be over 18 to sign up\"\nend\n\nvalidate present(:last_name) do\n  where [present(:first_name), present(:middle_name)]\n  message \"must also be supplied if setting first name and middle_name\"\nend\n```\n\n----------------------------------------\n\nTITLE: Bulk Destroying Multiple Records in Ash Framework\nDESCRIPTION: Shows how to destroy multiple records at once by providing an enumerable of records to the bulk_destroy function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.bulk_destroy([%Ticket{}, %Ticket{}], :destroy, %{})\n```\n\n----------------------------------------\n\nTITLE: Executing Create Action with Changeset\nDESCRIPTION: Shows how to execute a create action using Ash.Changeset and create functions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nTicket\n|> Ash.Changeset.for_create(:open, %{title: \"Need help!\"})\n|> Ash.create!()\n```\n\n----------------------------------------\n\nTITLE: Loading Related Data in Queries\nDESCRIPTION: Example showing how to load related data as part of a query using Ash.Query.load/2 when reading resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.load(:tweets)\n|> Ash.read()\n```\n\n----------------------------------------\n\nTITLE: Filtered Access Type Policy in Ash\nDESCRIPTION: Demonstrates a filter policy that determines whether records are filtered from results rather than returning a forbidden error.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action(:read_hidden) do\n  authorize_if actor_attribute_equals(:is_admin, true)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Attribute-Based Multitenancy in Ash Resource\nDESCRIPTION: Example of setting up attribute-based multitenancy in an Ash resource using the organization_id attribute. This configuration ensures that all operations on the resource require a tenant to be specified.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Users do\n  use Ash.Resource, ...\n\n  multitenancy do\n    strategy :attribute\n    attribute :organization_id\n  end\n\n  ...\n\n  relationships do\n    belongs_to :organization, MyApp.Organization\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining has_many Relationship in Elixir\nDESCRIPTION: Documentation and syntax for defining a has_many relationship in an Ash resource. It explains the concept of a has_many relationship and its use in Ash resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nhas_many name, destination\n```\n\n----------------------------------------\n\nTITLE: Using Join Filters in Ash Aggregates in Elixir\nDESCRIPTION: This snippet shows how to use join filters in Ash aggregates. It demonstrates a complex aggregate query that sums the amount of saved money based on redeemed deals with specific conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n  aggregates do\n    sum :saved_money, [:redeems, :deal], :amount do\n      # where any redeem of the deal is redeemed\n      filter expr(redeems.redeemed == true)\n\n      # where the `redeems` are `redeemed`\n      join_filter :redeems, expr(redeemed == true)\n\n      # where the `redeems.deal.active` == `redeems.require_active`\n      join_filter [:redeems, :deal], expr(active == parent(require_active))\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Default Actions Configuration\nDESCRIPTION: Demonstrates the shorthand syntax for setting up basic CRUD actions in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  defaults [:read, :destroy, create: :*, update: :*]\nend\n```\n\n----------------------------------------\n\nTITLE: Using Custom Validation Modules in Resources\nDESCRIPTION: Example of how to use a custom validation module within an Ash resource definition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate {MyApp.Validations.IsPrime, attribute: :foo}\n```\n\n----------------------------------------\n\nTITLE: Executing an Update Action in Ash (Elixir)\nDESCRIPTION: Shows how to execute the previously defined 'close' update action on a ticket using Ash.Changeset and Ash.update!.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nticket\n|> Ash.Changeset.for_update(:close, %{close_reason: \"I figured it out.\"})\n|> Ash.update!()\n```\n\n----------------------------------------\n\nTITLE: Using Filters with Relationships in Ash Queries\nDESCRIPTION: Illustrates how to use filters with relationships in Ash queries. This example filters posts based on their comments' points and associated tags.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Query.filter(Post, comments.points > 10 and comments.tag.name == \"elixir\")\n```\n\n----------------------------------------\n\nTITLE: Rescuing and Counting Errors in Ash Framework (Elixir)\nDESCRIPTION: This snippet shows how to rescue a specific error class (Ash.Error.Invalid) and count the number of underlying errors. It demonstrates the pattern for handling grouped errors in exception handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ntry do\n  AshExample.Representative\n  |> Ash.Changeset.for_create(:create, %{employee_id: \"dabes\"})\n  |> Ash.create!()\nrescue\n  e in Ash.Error.Invalid ->\n    \"Encountered #{Enum.count(e.errors)} errors\"\nend\n\n\"Encountered 2 errors\"\n```\n\n----------------------------------------\n\nTITLE: Using Inline Aggregates in Ash Expressions\nDESCRIPTION: Shows how to use inline aggregates within Ash expressions. This example calculates a grade based on the count of correct and incorrect answers.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :grade, :decimal, expr(\n  count(answers, query: [filter: expr(correct == true)]) /\n  count(answers, query: [filter: expr(correct == false)])\n)\n```\n\n----------------------------------------\n\nTITLE: Accepting Inputs in Action Definition\nDESCRIPTION: Demonstrates how to specify which attributes an action can accept as input using the accept option.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :create do\n  accept [:name, :description]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Read Action in Ash Framework\nDESCRIPTION: Example of defining a read action for a ticket queue with priority filtering and pagination support. Demonstrates argument configuration, pagination settings, and filter expressions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/read-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nread :ticket_queue do\n  argument :priorities, {:array, :atom} do\n    constraints items: [one_of: [:low, :medium, :high]]\n  end\n\n  pagination offset: true, countable: :by_default\n\n  filter expr(status == :open and priority in ^arg(:priorities))\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Join Filter in Ash Aggregates\nDESCRIPTION: Shows how to use a join filter to limit aggregate calculations to only active authors on comments. This example demonstrates filtering related records with a specific condition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_74\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter [:comments, :author], expr(active == true)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Project with Ash, PostgreSQL, and Phoenix\nDESCRIPTION: Commands to create a new project with Ash, PostgreSQL, and Phoenix frameworks pre-installed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmix archive.install hex phx_new\n\nmix igniter.new helpdesk \\\n  --install ash,ash_postgres,ash_phoenix \\\n  --with phx.new \\\n  --extend postgres \\\n  --example\n```\n\n----------------------------------------\n\nTITLE: Using Conditional Validations with Where Clause\nDESCRIPTION: Examples of conditional validations using the 'where' option with different validation types and complexity levels.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate present(:other_number), where: absent(:that_number)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate present(:other_number) do\n  where {MyApp.Validations.IsPrime, attribute: :foo}\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate present(:other_number),\n  where: [\n    numericality(:large_number, greater_than: 100),\n    one_of(:magic_number, [7, 13, 123])\n  ]\n```\n\n----------------------------------------\n\nTITLE: Using Domain-Defined Interface Functions in Elixir/Ash\nDESCRIPTION: Demonstrates how to use the interface functions defined in a domain for creating resources with a cleaner API.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ntweet = MyApp.Tweets.tweet!(\"My first tweet!\", actor: user1)\ncomment = MyApp.Tweets.comment!(tweet.id, \"What a cool tweet!\", actor: user2)\n```\n\n----------------------------------------\n\nTITLE: Blog Post Creation Workflow with Author Reference in Ash.Reactor\nDESCRIPTION: Example showing how to create a blog post with author reference. It demonstrates reading an author by email, creating a post, and updating the author's post count.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/reactor.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ninput :blog_title\ninput :blog_body\ninput :author_email\n\nread :get_author, MyBlog.Author, :get_author_by_email do\n  inputs %{email: input(:author_email)}\nend\n\ncreate :create_post, MyBlog.Post, :create do\n  inputs %{\n    title: input(:blog, [:title]),\n    body: input(:blog, [:body]),\n    author_id: result(:get_author, [:email])\n  }\nend\n\nupdate :author_post_count, MyBlog.Author, :update_post_count do\n  wait_for :create_post\n  initial result(:get_author)\nend\n\nreturn :create_post\n```\n\n----------------------------------------\n\nTITLE: Example Policy with Multiple Checks in Ash\nDESCRIPTION: Demonstrates a policy with multiple authorization checks that are evaluated in sequence until a decision is reached.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:create) do\n  authorize_if IsSuperUser\n  forbid_if Deactivated\n  authorize_if IsAdminUser\n  forbid_if RegularUserCanCreate\n  authorize_if RegularUserAuthorized\nend\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Calling a Generic Action\nDESCRIPTION: Full example showing how to prepare input for a generic action and execute it.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\naction :say_hello, :string do\n  argument :name, :string, allow_nil?: false\n\n  run fn input, _ ->\n    {:ok, \"Hello: #{input.arguments.name}\"}\n  end\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\n{:ok, greeting} = Resource\n|> Ash.ActionInput.for_action(:say_hello, %{name: \"Alice\"})\n|> Ash.run_action()\n\nIO.puts(greeting)  # Output: Hello: Alice\n```\n\n----------------------------------------\n\nTITLE: Defining a belongs_to Relationship in Ash Resource\nDESCRIPTION: Example showing how to define a basic belongs_to relationship from a Tweet resource to a User resource. This establishes that each Tweet belongs to a single owner (User).\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweet do\n  use Ash.Resource,\n    data_layer: my_data_layer\n\n  attributes do\n    uuid_primary_key :id\n    attribute :body, :string\n  end\n\n  relationships do\n    belongs_to :owner, MyApp.User\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Create Action in Ash Framework (Elixir)\nDESCRIPTION: Example of defining a special create action with a manual implementation module that uses Ash.Resource.ManualCreate. The implementation shows handling record creation with success and error cases.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/manual-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :special_create do\n  manual MyApp.DoCreate\nend\n\n# The implementation\ndefmodule MyApp.DoCreate do\n  use Ash.Resource.ManualCreate\n\n  def create(changeset, _, _) do\n    record = create_the_record(changeset)\n    {:ok, record}\n\n    # An `{:error, error}` tuple should be returned if something failed\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Sum Aggregate in Ash\nDESCRIPTION: Demonstrates defining a sum aggregate that calculates the total price of active assigned tickets. The example shows how to apply a filter to include only active tickets in the calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_76\n\nLANGUAGE: elixir\nCODE:\n```\nsum :assigned_ticket_price_sum, :assigned_tickets, :price do\n  filter [active: true]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Resource-Level Code Interface in Elixir\nDESCRIPTION: Demonstrates how to define a code interface directly on a resource using the code_interface block.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ncode_interface do\n  # the action open can be omitted because it matches the functon name\n  define :open, args: [:subject]\nend\n```\n\n----------------------------------------\n\nTITLE: Simplified Atomic Validation for Argument-Only Validations\nDESCRIPTION: Example of a simplified atomic implementation for validations that only operate on arguments and don't need special atomic behavior.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n@impl true\ndef atomic(changeset, opts, context) do\n  validate(changeset, opts, context)\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validation Modules in Ash\nDESCRIPTION: A complete example of implementing a custom validation module in Ash with initialization and validation logic. This example validates if a numeric attribute is a prime number.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Validations.IsPrime do\n  # transform and validate opts\n\n  use Ash.Resource.Validation\n\n  @impl true\n  def init(opts) do\n    if is_atom(opts[:attribute]) do\n      {:ok, opts}\n    else\n      {:error, \"attribute must be an atom!\"}\n    end\n  end\n\n  @impl true\n  def validate(changeset, opts, _context) do\n    value = Ash.Changeset.get_attribute(changeset, opts[:attribute])\n    # this is a function I made up for example\n    if is_nil(value) || Math.is_prime?(value) do\n      :ok\n    else\n      # The returned error will be passed into `Ash.Error.to_ash_error/3`\n      {:error, field: opts[:attribute], message: \"must be prime\"}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Field Policies in Ash Elixir\nDESCRIPTION: Shows how to set up field policies in Ash to authorize access to specific fields based on actor attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nfield_policies do\n  field_policy :role do\n    authorize_if actor_attribute_equals(:role, :supervisor)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Checks in Ash Policy (Elixir)\nDESCRIPTION: This snippet shows how to use inline checks in an Ash policy, demonstrating both attribute-based and argument-based authorization checks.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:read) do\n  # Allow records with the attribute `public` set to true to be read\n  authorize_if expr(public == true)\n\n  # Allow records with the attribute `level` less than the value of the `level`\n  # argument to the action to be read\n  authorize_if expr(level <= ^arg(:level))\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Basic Attribute in Ash Resource (Elixir)\nDESCRIPTION: Syntax for declaring a basic attribute with a name and type in an Ash resource, showing the minimal required parameters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nattribute name, type\n```\n\n----------------------------------------\n\nTITLE: Proper Actor Placement in Query Chains\nDESCRIPTION: Example showing the correct and incorrect ways to set the actor in query chains. The actor should be set when building the query, not when executing it.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/actors-and-authorization.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n# DO THIS\n\nPost\n|> Ash.Query.for_read(:read, %{}, actor: current_user)\n|> Ash.read!()\n\n# DON'T DO THIS\n\nPost\n|> Ash.Query.for_read!(:read)\n|> Ash.read!(actor: current_user)\n```\n\n----------------------------------------\n\nTITLE: Defining an Update Action in Ash (Elixir)\nDESCRIPTION: Demonstrates how to define an update action named 'close' on a ticket resource. The action accepts a 'close_reason' and sets the status to 'closed'.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :close do\n  accept [:close_reason]\n  change set_attribute(:status, :closed)\nend\n```\n\n----------------------------------------\n\nTITLE: Update Action Definition for Ticket Closing\nDESCRIPTION: Defines an update action to close tickets with validation to prevent closing already closed tickets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  ...\n  update :close do\n    accept []\n    validate attribute_does_not_equal(:status, :closed) do\n      message \"Ticket is already closed\"\n    end\n    change set_attribute(:status, :closed)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Join Filter for Max Aggregate in Elixir\nDESCRIPTION: Function to declare a join filter on an aggregate. Takes a relationship path and filter as arguments to apply filtering conditions on aggregated data.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_83\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter relationship_path, filter\n```\n\n----------------------------------------\n\nTITLE: Implementing an Example Notifier\nDESCRIPTION: Shows a basic notifier implementation that logs information about resource creation events, differentiating between authenticated and unauthenticated actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule ExampleNotifier do\n  use Ash.Notifier\n\n  def notify(%Ash.Notifier.Notification{resource: resource, action: %{type: :create}, actor: actor}) do\n    if actor do\n      Logger.info(\"#{actor.id} created a #{resource}\")\n    else\n      Logger.info(\"A non-logged in user created a #{resource}\")\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Type for Artist ID Transformation in Elixir\nDESCRIPTION: Shows how to create a reusable custom type for handling artist or artist ID inputs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Types.ArtistOrId do\n  use Ash.Type.NewType, subtype_of: :union, constraints: [\n    types: [\n      artist: [type: :struct, constraints: [instance_of: Artist]],\n      artist_id: [type: :uuid]\n    ]\n  ]\n\n  def to_artist_id(%Ash.Union{type: :artist, value: artist}), do: artist.id\n  def to_artist_id(%Ash.Union{type: :artist_id, value: artist_id}), do: artist_id\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Domain Logic with Reads and Calculations in Ash Resources\nDESCRIPTION: Demonstrates how to create a custom read action to filter for taxable purchases and a calculation to determine the percentage of tax in an Ash resource. This example shows how to encapsulate domain logic within resource definitions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/project-structure.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  ...\n\n  read :taxable do\n    filter expr(taxable == true)\n  end\nend\n\ncalculations do\n  calculate :percentage_tax, :decimal, expr(\n    sum(line_items, field: :amount, query: [filter: tax == true]) /\n    sum(line_items, field: :amount)\n  )\nend\n```\n\n----------------------------------------\n\nTITLE: Simplified Interface Call for Create Action\nDESCRIPTION: Example of a simplified interface call for creating records.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nSupport.open_ticket!(\"Need help!\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Read Action in Ash Resource\nDESCRIPTION: Defines a read action for an Ash resource. This sets up the basic structure for querying data from the resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_30\n\nLANGUAGE: elixir\nCODE:\n```\nread name\n```\n\n----------------------------------------\n\nTITLE: Implementing Expression Calculation in Ash Resource\nDESCRIPTION: Shows how to define a simple expression-based calculation that concatenates first and last names. Uses the Ash expressions system to compute the value.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/calculations.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ncalculations do\n  calculate :full_name, :string, expr(first_name <> \" \" <> last_name)\nend\n```\n\n----------------------------------------\n\nTITLE: Using Code Interface for Update Actions in Ash (Elixir)\nDESCRIPTION: Demonstrates a more elegant way to call update actions using a custom code interface, allowing for simpler function calls with either a ticket object or its ID.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nSupport.close_ticket!(ticket, \"I figured it out.\")\n# You can also provide an id\nSupport.close_ticket!(ticket.id, \"I figured it out.\")\n```\n\n----------------------------------------\n\nTITLE: Declaring Join Filter for Aggregates in Ash Framework\nDESCRIPTION: Defines a join filter on an aggregate that allows filtering related records through a relationship path. This is a helper function used within aggregate definitions to refine the related records that will be included in the aggregate calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_73\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter relationship_path, filter\n```\n\n----------------------------------------\n\nTITLE: Configuring has_many Relationships in Elixir\nDESCRIPTION: Example of configuring has_many relationships in an Ash resource. It shows how to set up a has_many relationship for posts and composite key posts, specifying the destination attribute.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nrelationships do\n  has_many :posts, MyApp.Post do\n    destination_attribute :author_id\n  end\n\n  has_many :composite_key_posts, MyApp.CompositeKeyPost do\n    destination_attribute :author_id\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Aggregates on an Ash Resource in Elixir\nDESCRIPTION: This snippet demonstrates how to declare an aggregate on an Ash resource. It shows a count aggregate of published posts for a user.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\naggregates do\n  count :count_of_posts, :posts do\n    filter expr(published == true)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Atomic Update Action for Score Increment in Ash (Elixir)\nDESCRIPTION: Shows an atomic version of the score increment update action, which is safe for concurrent operations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :increment_score do\n  change atomic_update(:score, expr(score + 1))\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Calculation Functions in Ash\nDESCRIPTION: Examples of defining calculation functions with different argument configurations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_50\n\nLANGUAGE: elixir\nCODE:\n```\ndefine_calculation :referral_link, args: [:id]\n```\n\nLANGUAGE: elixir\nCODE:\n```\ndefine_calculation :referral_link, args: [{:arg, :id}, {:ref, :id}]\n```\n\n----------------------------------------\n\nTITLE: Identity Example with Multiple Fields\nDESCRIPTION: Example of defining a compound identity constraint using multiple fields (first_name and last_name).\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_55\n\nLANGUAGE: elixir\nCODE:\n```\nidentity :full_name, [:first_name, :last_name]\n```\n\n----------------------------------------\n\nTITLE: Defining has_one Relationship in Elixir\nDESCRIPTION: Documentation and syntax for defining a has_one relationship in an Ash resource. It includes the basic syntax and explains the concept of a has_one relationship in the context of relational databases.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nhas_one name, destination\n```\n\n----------------------------------------\n\nTITLE: Loading Nested Relationships\nDESCRIPTION: Example showing how to load nested relationships with a custom path syntax.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.load(users, followers: [:tweets, :followers])\n```\n\n----------------------------------------\n\nTITLE: Defining Belongs-to Relationships in Ash Resources\nDESCRIPTION: Declares a belongs_to relationship in an Ash resource. This creates a field on the resource with the corresponding name and type, unless define_attribute?: false is provided.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\nbelongs_to name, destination\n```\n\n----------------------------------------\n\nTITLE: Creating Module-Based Calculation in Ash\nDESCRIPTION: Demonstrates implementing a complex calculation using a dedicated module. Includes initialization, loading requirements, and calculation logic with customizable separator argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/calculations.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Concat do\n  # An example concatenation calculation, that accepts the delimiter as an argument,\n  #and the fields to concatenate as options\n  use Ash.Resource.Calculation\n\n  # Optional callback that verifies the passed in options (and optionally transforms them)\n  @impl true\n  def init(opts) do\n    if opts[:keys] && is_list(opts[:keys]) && Enum.all?(opts[:keys], &is_atom/1) do\n      {:ok, opts}\n    else\n      {:error, \"Expected a `keys` option for which keys to concat\"}\n    end\n  end\n\n  @impl true\n  # A callback to tell Ash what keys must be loaded/selected when running this calculation\n  # you can include related data here, but be sure to include the attributes you need from said related data\n  # i.e `posts: [:title, :body]`.\n  def load(_query, opts, _context) do\n    opts[:keys]\n  end\n\n  @impl true\n  def calculate(records, opts, %{arguments: %{separator: separator}}) do\n    Enum.map(records, fn record ->\n      Enum.map_join(opts[:keys], separator, fn key ->\n        to_string(Map.get(record, key))\n      end)\n    end)\n  end\n\n  # You can implement this callback to make this calculation possible in the data layer\n  # *and* in elixir. Ash expressions are already executable in Elixir or in the data layer, but this gives you fine grain control over how it is done\n  # @impl true\n  # def expression(opts, context) do\n  # end\nend\n\n# Usage in a resource\ncalculations do\n  calculate :full_name, :string, {Concat, keys: [:first_name, :last_name]} do\n    # You need to use the [allow_empty?: true, trim?: false] constraints here.\n    # The separator could be an empty string or require a leading or trailing space,\n    # but would be trimmed or even set to `nil` without the constraints shown below.\n    argument :separator, :string do\n      allow_nil? false\n      constraints [allow_empty?: true, trim?: false]\n      default \"\"\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Create Timestamp in Ash Resource (Elixir)\nDESCRIPTION: Example of declaring a create timestamp attribute in an Ash resource, which automatically sets the current time when a record is created.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ncreate_timestamp :inserted_at\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Embedded Resource in Elixir with Ash Framework\nDESCRIPTION: Creates a basic embedded resource Profile with first_name and last_name attributes using the embedded data layer.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Profile do\n  use Ash.Resource,\n    data_layer: :embedded # Use the atom `:embedded` as the data layer.\n\n  attributes do\n    attribute :first_name, :string, public?: true\n    attribute :last_name, :string, public?: true\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Update Timestamp Attribute Configuration in Elixir\nDESCRIPTION: Configuration for update_timestamp attribute that tracks the last update time of a row. Includes both default and update_default values using DateTime.utc_now/0.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/attributes.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :updated_at, :utc_datetime_usec do\n  writable? false\n  default &DateTime.utc_now/0\n  update_default &DateTime.utc_now/0\n  match_other_defaults? true\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Aggregate with StringAgg Implementation in Elixir\nDESCRIPTION: Creates a custom aggregate that concatenates author names from a related authors collection using StringAgg with comma delimiter. This example demonstrates the basic syntax for defining a custom aggregate.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_87\n\nLANGUAGE: elixir\nCODE:\n```\ncustom :author_names, :authors, :string do\n  implementation {StringAgg, delimiter: \",\"}\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Soft Destroy in Ash Framework\nDESCRIPTION: Demonstrates how to configure a soft destroy action which is handled by the update action logic. The example sets an archived_at timestamp when the item is archived.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy :archive do\n  soft? true\n  change set_attribute(:archived_at, &DateTime.utc_now/0)\nend\n```\n\n----------------------------------------\n\nTITLE: Using Code Interface to Call Actions\nDESCRIPTION: Shows how to define and use code interfaces for more convenient calling of generic actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefine :say_hello, args: [:name]\n```\n\nLANGUAGE: elixir\nCODE:\n```\n{:ok, greeting} = Resource.say_hello(\"Alice\")\ngreeting = Resource.say_hello!(\"Alice\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Tracer with Changeset Creation\nDESCRIPTION: Demonstrates how to provide a custom tracer when creating changesets or calling actions in Ash framework.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/monitoring.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nResource\n# better to put it here, as changesets are traced as well. It will be carried over to the domain action\n|> Ash.Changeset.for_create(:create, %{}, tracer: MyApp.Tracer)\n# but you can also pass it here.\n|> Ash.create!(tracer: MyApp.Tracer)\n```\n\n----------------------------------------\n\nTITLE: Defining a many_to_many Relationship\nDESCRIPTION: Example showing how to define a many_to_many relationship between Tweet and Hashtag resources using a join resource. This allows tweets to have multiple hashtags and hashtags to be used in multiple tweets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\n# on MyApp.Tweet\nmany_to_many :hashtags, MyApp.Hashtag do\n  through MyApp.TweetHashtag\n  source_attribute_on_join_resource :tweet_id\n  destination_attribute_on_join_resource :hashtag_id\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Action Definition in Ash Resource\nDESCRIPTION: Demonstrates how to define a custom action with return type and argument configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\naction :top_user_emails, {:array, :string} do\n  argument :limit, :integer, default: 10, allow_nil?: false\n  run fn input, context ->\n    with {:ok, top_users} <- top_users(input.arguments.limit) do\n      {:ok, Enum.map(top_users, &(&1.email))}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring a Create Action in Ash Resource\nDESCRIPTION: Defines a 'create' action for an Ash resource. Create actions are used to insert new records into the data store.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\ncreate name\n```\n\n----------------------------------------\n\nTITLE: Loading Related Data on Records\nDESCRIPTION: Examples showing how to load related data directly on records using Ash.load/3, both for a single record and for a list of records.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n# user = %User{...}\nAsh.load(user, :tweets)\n\n# users = [%User{...}, %User{...}, ....]\nAsh.load(users, :tweets)\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Policies for Ash Resources in Elixir\nDESCRIPTION: Illustrates how to define authorization policies for an Ash resource, including bypass policies and policies for specific action types.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  # Anything you can use in a condition, you can use in a check, and vice-versa\n  # This policy applies if the actor is a super_user\n  # Additionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without\n  # failing the whole request, and that if this check *passes*, the entire request passes.\n  bypass actor_attribute_equals(:super_user, true) do\n    authorize_if always()\n  end\n\n  # This will likely be a common occurrence. Specifically, policies that apply to all read actions\n  policy action_type(:read) do\n    # unless the actor is an active user, forbid their request\n    forbid_unless actor_attribute_equals(:active, true)\n    # if the record is marked as public, authorize the request\n    authorize_if attribute(:public, true)\n    # if the actor is related to the data via that data's `owner` relationship, authorize the request\n    authorize_if relates_to_actor_via(:owner)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Loading Aggregates in Ash Queries and on Records in Elixir\nDESCRIPTION: These examples show how to load aggregates in an Ash query and on existing records. The first query loads the count of posts for a user, and the second loads the count for multiple users.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.load(:count_of_posts)\n|> Map.get(:count_of_posts)\n# => 10\n\nusers\n|> Ash.load!(:count_of_posts)\n|> Enum.map(&(&1.count_of_posts))\n# => [3, 5, 2]\n```\n\n----------------------------------------\n\nTITLE: Using Actor with Code Interface Functions\nDESCRIPTION: Example showing how to provide the actor option when using functions created with the code interface in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/actors-and-authorization.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nMyDomain.create_post!(Post, authorize?: true)\n```\n\n----------------------------------------\n\nTITLE: List Aggregate Definition in Ash Framework\nDESCRIPTION: Declares a named list aggregate that collects all values for a given field across related records. This aggregate returns the actual list of values rather than performing a calculation on them, with options for uniqueness and nil handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_78\n\nLANGUAGE: elixir\nCODE:\n```\nlist name, relationship_path, field\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Input with Transform in Ash\nDESCRIPTION: Example of defining a custom input structure with transformation that converts an artist struct to an artist_id.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_48\n\nLANGUAGE: elixir\nCODE:\n```\ncustom_input :artist, :struct do\n  transform to: :artist_id, using: &(&1.id)\n\n  constraints instance_of: Artist\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Preparation Module in Elixir\nDESCRIPTION: Example of creating a custom preparation module that implements the Top5 functionality with attribute validation and query transformation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Preparations.Top5 do\n  use Ash.Resource.Preparation\n\n  # transform and validate opts\n  @impl true\n  def init(opts) do\n    if is_atom(opts[:attribute]) do\n      {:ok, opts}\n    else\n      {:error, \"attribute must be an atom!\"}\n    end\n  end\n\n  @impl true\n  def prepare(query, opts, _context) do\n    attribute = opts[:attribute]\n\n    query\n    |> Ash.Query.sort([{attribute, :desc}])\n    |> Ash.Query.limit(5)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Specifying Wait Dependencies in Ash Framework\nDESCRIPTION: Shows how to make a reactor step wait for the completion of a step named 'create_user' before proceeding with execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_63\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Configuring has_many Relationship Example in Elixir\nDESCRIPTION: Example of configuring a has_many relationship in an Ash resource. It demonstrates setting up a definitions relationship for a Word resource, specifying source and destination attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\n# In a resource called `Word`\nhas_many :definitions, DictionaryDefinition do\n  source_attribute :text\n  destination_attribute :word_text\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Ash Resource Interface\nDESCRIPTION: Creates a custom interface function for an Ash resource. This allows defining custom named functions to interact with resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefine :get_user_by_id, action: :get_by_id, args: [:id], get?: true\n```\n\n----------------------------------------\n\nTITLE: Stream Processing with Bulk Create\nDESCRIPTION: Example of using streams with bulk create operations for processing results.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ninput_stream()\n|> Ash.bulk_create(Resource, :action, return_stream?: true, return_records?: true)\n|> Stream.map(fn {:ok, result} ->\n  # process results\n  {:error, error} ->\n  # process errors\nend)\n|> Enum.reduce(%{}, fn {:ok, result}, acc ->\n   # process results\n   {:error, error} ->\n   # process errors\nend)\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of Ash.get!\nDESCRIPTION: Demonstrates the underlying implementation equivalent to using Ash.get! function, showing filtering, limit, and error handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/read-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# action can be omitted to use the primary read action \nAsh.get!(Resource, 1, action: :read_action)\n\n# is roughly equivalent to\n\nResource\n|> Ash.Query.filter(id == 1)\n|> Ash.Query.limit(2)\n|> Ash.Query.for_read(:read_action, %{})\n|> Ash.read!()\n|> case do\n  [] -> # raise not found error\n  [result] -> result\n  [_, _] -> # raise too many results error\nend\n```\n\n----------------------------------------\n\nTITLE: Global Validation Examples with Different Conditions\nDESCRIPTION: Multiple examples of global validations with different action targets and conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nvalidations do\n  validate present([:foo, :bar]), on: :update\n  validate present([:foo, :bar, :baz], at_least: 2), on: :create\n  validate present([:foo, :bar, :baz], at_least: 2), where: [action_is([:action1, :action2])]\n  validate absent([:foo, :bar, :baz], exactly: 1), on: [:update, :destroy]\n  validate {MyCustomValidation, [foo: :bar]}, on: :create\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Catch-All Policy for Field Authorization in Ash Elixir\nDESCRIPTION: Demonstrates how to add a catch-all policy to allow access to all fields when using field policies in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  policy always() do\n    authorize_if always()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Fully Atomic Update Action in Ash (Elixir)\nDESCRIPTION: Illustrates a fully atomic update action that adds a string to the 'name' attribute using atomic_update.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :add_to_name do\n  argument :to_add, :string, allow_nil? false\n  change atomic_update(:name, expr(\"#{name}_#{to_add}\"))\nend\n```\n\n----------------------------------------\n\nTITLE: Defining First Aggregate in Ash Resource\nDESCRIPTION: Creates a first aggregate that retrieves the subject of the first assigned ticket that matches the filter criteria. The aggregate is sorted by the subject field and only includes active tickets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_72\n\nLANGUAGE: elixir\nCODE:\n```\nfirst :first_assigned_ticket_subject, :assigned_tickets, :subject do\n  filter [active: true]\n  sort [:subject]\nend\n```\n\n----------------------------------------\n\nTITLE: Using Domain with AshGraphql in Elixir\nDESCRIPTION: Demonstrates how to use a domain with AshGraphql to expose resources through a GraphQL API.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nuse AshGraphql, domains: [MyApp.Tweets]\n```\n\n----------------------------------------\n\nTITLE: Defining Upsert Action\nDESCRIPTION: Shows how to configure an upsert action with identity constraints.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :create_user do\n  accept [:email]\n  upsert? true\n  upsert_identity :unique_email\nend\n```\n\n----------------------------------------\n\nTITLE: Realistic Ash Policy Implementation with Bypass\nDESCRIPTION: Shows a real-world example of Ash policies including a bypass policy for super users and standard read permissions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  # Anything you can use in a condition, you can use in a check, and vice-versa\n  # This policy applies if the actor is a super_user\n  # Additionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without\n  # failing the whole request, and that if this check *passes*, the entire request passes.\n  bypass actor_attribute_equals(:super_user, true) do\n    authorize_if always()\n  end\n\n  # This will likely be a common occurrence. Specifically, policies that apply to all read actions\n  policy action_type(:read) do\n    # unless the actor is an active user, forbid\n    forbid_unless actor_attribute_equals(:active, true)\n    # if the record is marked as public, authorize\n    authorize_if expr(public == true)\n    # if the actor is related to the data via that data's `owner` relationship, authorize\n    authorize_if relates_to_actor_via(:owner)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Filter Check in Ash Resource Policy (Elixir)\nDESCRIPTION: This example demonstrates how to use a filter check module in an Ash resource policy to authorize a read action based on the actor's age.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.User do\n  # ...\n\n  policies do\n    policy action(:of_drinking_age) do\n      authorize_if MyApp.Checks.ActorOverAgeLimit\n    end\n  end\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Post with Ash Reactor DSL in Elixir\nDESCRIPTION: Example of using the create action in Ash Reactor DSL to create a post. It demonstrates the use of inputs, actor, and tenant options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :create_post, MyApp.Post, :create do\n  inputs %{\n    title: input(:post_title),\n    author_id: result(:get_user, [:id])\n  }\n  actor result(:get_user)\n  tenant result(:get_organisation, [:id])\nend\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of Ash.read_one!\nDESCRIPTION: Shows the underlying implementation equivalent to using Ash.read_one! function for single result queries.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/read-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.read_one!(query)\n\n# is roughly equivalent to\n\nquery\n|> Ash.Query.limit(2)\n|> Ash.read!()\n|> case do\n  [] -> nil\n  [result] -> result\n  [_, _] -> # raise too many results error\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Resource Change for External Data Integration\nDESCRIPTION: Demonstrates the recommended approach for integrating external data by creating a custom Ash.Resource.Change module. This module encapsulates the GitHub API call logic that will be used within a resource action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/project-structure.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Ticket.FetchIssueInfo do\n  use Ash.Resource.Change\n\n  def change(changeset, _, _) do\n    Ash.Changeset.before_transaction(changeset, fn changeset ->\n      issue_info = GithubApi.get_issue(changeset.arguments.issue_id)\n\n      Ash.Changeset.force_change_attributes(changeset, %{\n        issue_info: %{\n          title: issue_info.title,\n          body: issue_info.body\n        }\n      })\n    end)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Bulk Update with Atomic Strategy in Ash (Elixir)\nDESCRIPTION: Demonstrates how to perform a bulk update using the atomic strategy in Ash, which updates all matching records in a single operation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nTicket\n|> Ash.Query.filter(status == :open)\n|> Ash.bulk_update!(:close, %{reason: \"Closing all open tickets.\"})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Aggregates in Ash Queries in Elixir\nDESCRIPTION: This example demonstrates how to create a custom aggregate in an Ash query. It counts the number of published posts for a user, allowing for dynamic filtering based on a 'published?' variable.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.aggregate(\n  :count_of_posts,\n  :count,\n  :posts,\n  query: [\n    filter: [published: published?]\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Guard Implementation in Elixir\nDESCRIPTION: Example of implementing a guard for conditional file reading with cache checking. Shows how to control step execution flow.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_45\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Calculation Using Expression in Elixir\nDESCRIPTION: Creates a full_name calculation using expr/1 to concatenate first_name and last_name. This approach allows defining simple calculations directly in the resource without a separate module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_91\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, expr(first_name <> \" \" <> last_name)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Blacklist Policy in Ash Framework (Elixir)\nDESCRIPTION: Demonstrates how to implement a 'blacklist' policy by using forbid_if checks and an authorize_if always() at the end. This ensures that any request not explicitly forbidden is authorized.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:read) do\nforbid_if not_logged_in()\nforbid_if user_is_denylisted()\nforbid_if user_is_in_denylisted_group()\n\nauthorize_if always()\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Guard for Bulk Create Operation in Elixir\nDESCRIPTION: Provides a flexible method for conditionally executing a step or replacing its result in the bulk create operation. It uses a two-arity function that takes step arguments and context.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Configuring Domain with Policies in Elixir/Ash\nDESCRIPTION: Shows how to add authorization policies at the domain level using Ash.Policy.Authorizer to apply rules to all actions within the domain.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweets do\n  use Ash.Domain,\n    extensions: [Ash.Policy.Authorizer]\n\n  resources do\n    resource MyApp.Tweets.Tweet\n    resource MyApp.Tweets.Comment\n  end\n\n  policies do\n    # add a bypass up front to allow administrators to do whatever they want\n    bypass actor_attribute_equals(:is_admin, true) do\n      authorize_if always()\n    end\n\n    # forbid all access from disabled users\n    policy actor_attribute_equals(:disabled, true) do\n      forbid_if always()\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Calling a Generic Action in Ash\nDESCRIPTION: Shows the basic pattern for calling a generic action using ActionInput and run_action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nResource\n|> Ash.ActionInput.for_action(:action_name, %{argument: :value}, ...opts)\n|> Ash.run_action!()\n```\n\n----------------------------------------\n\nTITLE: Using authorize_if in Ash.Policy.Authorizer\nDESCRIPTION: Examples of using the authorize_if check in Ash.Policy.Authorizer to authorize requests based on specific conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_if logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_if actor_attribute_matches_record(:group, :group)\n```\n\n----------------------------------------\n\nTITLE: Defining Identities in Ash Resource\nDESCRIPTION: Example demonstrating how to define different types of identities in an Ash resource module. Shows single-field uniqueness, multi-field uniqueness, and custom error field mapping.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/identities.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.MyResource do\n  use Ash.Resource #, ...\n  # ...\n\n  identities do\n    # If the `email` attribute must be unique across all records\n    identity :unique_email, [:email]\n\n    # If the `username` attribute must be unique for every record with a given `site` value\n    identity :special_usernames, [:username, :site]\n\n    # If the `user_id` field should hold the errors for the uniqueness violation\n    identity :unique_email, [:email], field_names: [:user_id]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Domain with Extensions in Elixir/Ash\nDESCRIPTION: Demonstrates how to use domain extensions to configure extension-specific behavior for all resources within a domain, using AshGraphql as an example.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweets do\n  use Ash.Domain,\n    extensions: [AshGraphql.Domain]\n\n  graphql do\n    # skip authorization for these resources\n    authorize? false\n  end\n\n  resources do\n    resource MyApp.Tweets.Tweet\n    resource MyApp.Tweets.Comment\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an Action Using the Custom Resource Change\nDESCRIPTION: Shows how to define an update action in an Ash resource that uses the custom FetchIssueInfo change. This demonstrates proper encapsulation of domain logic within the resource interface.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/project-structure.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :link_ticket do\n  argument :issue_id, :string, allow_nil?: false\n\n  change MyApp.Ticket.FetchIssueInfo\nend\n```\n\n----------------------------------------\n\nTITLE: Bulk Update with Atomic Batches in Ash (Elixir)\nDESCRIPTION: Illustrates how to perform a bulk update using the atomic batches strategy in Ash, which updates records in batches for better performance.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.bulk_update!(one_hundred_tickets, :close, %{reason: \"Closing all open tickets.\"}, batch_size: 10)\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Changes\nDESCRIPTION: Declares a change to be applied to the changeset during create/update/destroy actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_56\n\nLANGUAGE: elixir\nCODE:\n```\nchange change\n```\n\n----------------------------------------\n\nTITLE: Declaring Resource Calculations in Elixir\nDESCRIPTION: Sets up a calculations block in a resource that defines a full_name calculation using a custom module. This demonstrates the basic pattern for defining named calculations on a resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_89\n\nLANGUAGE: elixir\nCODE:\n```\ncalculations do\n  calculate :full_name, :string, MyApp.MyResource.FullName\nend\n```\n\n----------------------------------------\n\nTITLE: Modifying Queries Before Data Layer Dispatch (Elixir)\nDESCRIPTION: Alternative approach to manual read actions by using the modify_query option. This allows low-level manipulation of the query just before it's dispatched to the data layer while still using resource actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/manual-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nread :read do\n  modify_query {MyApp.ModifyQuery, :modify, []}\nend\n\ndefmodule MyApp.ModifyQuery do\n  def modify(ash_query, data_layer_query) do\n    {:ok, modify_data_layer_query(data_layer_query)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Loading Calculations with Arguments in Ash\nDESCRIPTION: Demonstrates how to load calculations with specific arguments and how to use calculations in filters and sorts.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/calculations.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nload(full_name: [separator: \",\"])\n```\n\nLANGUAGE: elixir\nCODE:\n```\nquery\n|> Ash.Query.filter(full_name(separator: \" \") == \"Zach Daniel\")\n|> Ash.Query.sort(full_name: {%{separator: \" \"}, :asc})\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Calculation Using Module with Options in Elixir\nDESCRIPTION: Defines a full_name calculation using a custom module with keys option, while also specifying fields to load. This pattern is useful when the calculation depends on specific attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_90\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, {MyApp.FullName, keys: [:first_name, :last_name]}, load: [:first_name, :last_name]\n```\n\n----------------------------------------\n\nTITLE: Has Many Filter Examples in Ash Resource\nDESCRIPTION: Example implementations of has_many relationship filters, showing filtering by first_name and combined conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\nfilter expr(first_name == \"fred\")\nfilter expr(last_name == \"weasley\" and magician == true)\n```\n\n----------------------------------------\n\nTITLE: Creating Ash Expressions in Elixir\nDESCRIPTION: Demonstrates how to create Ash expressions using the Ash.Expr.expr/1 macro. These expressions can represent simple arithmetic, variable operations, or string concatenation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Expr.expr(1 + 2)\nAsh.Expr.expr(x + y)\nAsh.Expr.expr(post.title <> \" | \" <> post.subtitle)\n```\n\n----------------------------------------\n\nTITLE: Creating Update Steps in Ash Reactor\nDESCRIPTION: The 'update' DSL component for declaring steps that call update actions on Ash resources. Supports various options including undo behavior, authorization control, and asynchronous execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_50\n\nLANGUAGE: elixir\nCODE:\n```\nupdate name, resource, action \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Check for Ash Policy (Elixir)\nDESCRIPTION: This snippet demonstrates how to create a simple check module for Ash policies, specifically checking if an actor is old enough to perform an action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Checks.ActorIsOldEnough do\n  use Ash.Policy.SimpleCheck\n\n  def describe(_) do\n    \"actor is old enough\"\n  end\n\n  def match?(%MyApp.User{age: age} = _actor, %{resource: MyApp.Beer} = _context, _opts) do\n    age >= 21\n  end\n\n  def match?(_, _, _), do: false\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Callback for Changes in Ash (Elixir)\nDESCRIPTION: Demonstrates how to implement the atomic callback for changes in Ash, using the increment change as an example.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n@impl true\ndef atomic(_changeset, opts, _context) do\n  # Set the requested attribute to its current value (atomic_ref) + the amount\n  {:atomic, %{opts[:attribute] => expr(^atomic_ref(opts[:attribute]) + ^opts[:amount])}}\nend\n```\n\n----------------------------------------\n\nTITLE: Example Destroy Action Implementation\nDESCRIPTION: Demonstrates a complete destroy action setup with actor and tenant configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy :delete_post, MyApp.Post, :destroy do\n  initial input(:post)\n  actor result(:get_user)\n  tenant result(:get_organisation, [:id])\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Bypass Policy in Ash Framework (Elixir)\nDESCRIPTION: Creates a bypass policy that, if passed, will skip all following policies. If failed, authorization moves on to the next policy. Useful for creating exception cases in policy chains.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\nbypass condition \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Defining Calculation Argument with Default Value in Elixir\nDESCRIPTION: Creates a params argument of type map with a default empty map for a calculation. Arguments allow passing dynamic values to calculations during query execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_94\n\nLANGUAGE: elixir\nCODE:\n```\nargument :params, :map do\n  default %{}\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Count Aggregate in Ash Resource\nDESCRIPTION: Defines a count aggregate that counts assigned tickets with an active filter. This creates a virtual field that will contain the count of related records matching the specified criteria.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_69\n\nLANGUAGE: elixir\nCODE:\n```\ncount :assigned_ticket_count, :assigned_tickets do\n  filter [active: true]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Arguments for Destroy Actions in Ash Resources\nDESCRIPTION: Declares arguments that can be provided to destroy actions in Ash resources. Arguments define the input data structure that actions can accept.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_45\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, type\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :password_confirmation, :string\n```\n\n----------------------------------------\n\nTITLE: Defining Update Action in Ash Framework (Elixir)\nDESCRIPTION: Example of defining an update action in Ash framework, setting the 'flag_for_review' field as primary.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_32\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :flag_for_review, primary?: true\n```\n\n----------------------------------------\n\nTITLE: Declaring Update Actions in Ash Framework\nDESCRIPTION: Demonstrates how to declare an update action in Ash Framework. This is the beginning of an update action definition that would contain additional configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_31\n\nLANGUAGE: elixir\nCODE:\n```\nupdate name\n```\n\n----------------------------------------\n\nTITLE: Using authorize_unless in Ash.Policy.Authorizer\nDESCRIPTION: Examples of using the authorize_unless check in Ash.Policy.Authorizer to authorize requests unless specific conditions are met.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless not_logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless actor_attribute_matches_record(:group, :blacklisted_groups)\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Calculations in Elixir\nDESCRIPTION: Shows how to define a full_name calculation with arguments and expose it through the code interface.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ncalculations do\n  calculate :full_name, :string, expr(first_name <> ^arg(:separator) <> last_name) do\n    argument :separator, :string do\n      allow_nil? false\n      default \" \"\n    end\n  end\nend\n\n# in your domain\nresource User do\n  define_calculation :full_name, args: [:first_name, :last_name, {:optional, :separator}]\n  # or if you want to take a record as an argument\n  define_calculation :full_name, args: [:_record]\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Change Usage in Elixir\nDESCRIPTION: Example of using a custom Slugify change in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nchange {MyApp.Changes.Slugify, attribute: :foo}\n```\n\n----------------------------------------\n\nTITLE: Example of List Aggregate in Ash\nDESCRIPTION: Shows how to define a list aggregate that collects all price values from active assigned tickets. This example demonstrates gathering related field values into a list with filtering.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_79\n\nLANGUAGE: elixir\nCODE:\n```\nlist :assigned_ticket_prices, :assigned_tickets, :price do\n  filter [active: true]\nend\n```\n\n----------------------------------------\n\nTITLE: Examples of Change Declaration in Ash\nDESCRIPTION: Shows two ways to declare changes: using a built-in change function (relate_actor) and using a custom change module with parameters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_41\n\nLANGUAGE: elixir\nCODE:\n```\nchange relate_actor(:reporter)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nchange {MyCustomChange, :foo}\n```\n\n----------------------------------------\n\nTITLE: Reading a Single Record with Ash Reactor\nDESCRIPTION: Declares a step that will call a read action on a resource to retrieve a single record. This is useful for fetching specific data that's needed in subsequent workflow steps.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_38\n\nLANGUAGE: elixir\nCODE:\n```\nread_one name, resource, action \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Portable Calculations in Ash\nDESCRIPTION: Examples of portable calculations that can be executed in both Elixir and SQL contexts.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, expr(first_name <> \" \" <> last_name)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.load(:full_name)\n|> Ash.Query.sort(:full_name)\n|> Accounts.read!()\n```\n\nLANGUAGE: elixir\nCODE:\n```\n# data can be loaded in the query like above, or on demand later\nAccounts.load!(user, :full_name, reuse_values?: true)\n```\n\n----------------------------------------\n\nTITLE: Conditional Expressions in Ash Calculations\nDESCRIPTION: Demonstrates the correct usage of conditional logic in Ash calculations using cond instead of case expressions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n# This works - using cond\ncalculations do\n  calculate :user_order, :integer, expr(\n    cond do\n      role == :principal -> 1\n      role == :teacher -> 2\n      role == :student -> 3\n    end\n  )\nend\n\n# This doesn't work - using case\ncalculations do\n  calculate :user_order, :integer, expr(\n    case role do\n      :principal -> 1\n      :teacher -> 2\n      :student -> 3\n    end\n  )\nend\n```\n\n----------------------------------------\n\nTITLE: Atomic Updates in Upsert\nDESCRIPTION: Shows how to implement atomic updates within upsert operations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :create_game do\n  accept [:identifier]\n  upsert? true\n  upsert_identity :identifier\n  change set_attribute(:score, 0)\n  change atomic_update(:score, expr(score + 1))\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring a Destroy Action in Ash Resource\nDESCRIPTION: Defines a destroy action for removing records. Can be configured with various options including soft deletion behavior and primary action designation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_38\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy name\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Attribute with belongs_to\nDESCRIPTION: Example showing how to use a manually defined attribute with a belongs_to relationship by disabling automatic attribute definition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nattributes do\n  attribute :owner_foo, MyApp.CustomType\nend\n\n...\nrelationships do\n  belongs_to :owner, MyApp.User do\n    define_attribute? false\n    source_attribute :owner_foo\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Composing Filters in Ash Queries\nDESCRIPTION: Shows how to compose filters in Ash queries using separate functions. This example demonstrates filtering posts based on comment points and tags, but highlights a potential logical issue in composition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef has_comment_with_more_points_than(query, score) do\n  Ash.Query.filter(query, comments.points > ^score)\nend\n\ndef has_comment_tagged(query, tag) do\n  Ash.Query.filter(query, comments.tag.name == ^tag)\nend\n\nPost\n|> has_comment_with_more_points_than(10)\n|> has_comment_tagged(\"elixir\")\n```\n\n----------------------------------------\n\nTITLE: Using Tenants with Ash Queries and Changesets\nDESCRIPTION: Demonstrates how to set tenants when querying or creating records with Ash. Examples show filtering by organization_id automatically when a tenant is set, and the error when no tenant is provided.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# Error when not setting a tenant\nMyApp.Users\n|> Ash.Query.filter(name == \"fred\")\n|> Ash.read!()\n** (Ash.Error.Invalid)\n\n* \"Queries against the Helpdesk.Accounts.User resource require a tenant to be specified\"\n    (ash 1.22.0) lib/ash/domain/domain.ex:944: Ash.Domain.unwrap_or_raise!/2\n\n# Automatically filtering by `organization_id == 1`\nMyApp.Users\n|> Ash.Query.filter(name == \"fred\")\n|> Ash.Query.set_tenant(1)\n|> Ash.read!()\n\n[...]\n\n# Automatically setting `organization_id` to `1`\nMyApp.Users\n|> Ash.Changeset.for_create(:create, %{name: \"fred\"})\n|> Ash.Changeset.set_tenant(1)\n|> Ash.create!()\n\n%MyApp.User{organization_id: 1}\n\n# Setting tenant with a code interface that exposes `list_all` as a read action\nMyApp.Users.list_all(tenant: 1)\n```\n\n----------------------------------------\n\nTITLE: Anonymous Function Change in Elixir\nDESCRIPTION: Example of using an anonymous function as a change in Ash resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nchange fn changeset, _context ->\n  # put your code here\nend\n```\n\n----------------------------------------\n\nTITLE: Default Accept Configuration\nDESCRIPTION: Shows how to configure default accepted attributes for all actions in a resource, with the ability to override specific actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  default_accept [:name, :description]\n\n  create :create\n  update :update\n\n  update :special_update do\n    accept [:something_else]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Validations\nDESCRIPTION: Declares validations that run prior to performing actions against a resource to ensure data integrity.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_63\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate validation\n```\n\n----------------------------------------\n\nTITLE: Defining Join Filter for Aggregates in Elixir\nDESCRIPTION: Creates a join filter on an aggregate relationship path to filter by active status. Join filters allow restricting which related records are included in an aggregate calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_88\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter [:comments, :author], expr(active == true)\n```\n\n----------------------------------------\n\nTITLE: Exists at Path Filtering in Ash\nDESCRIPTION: Shows how to filter based on related entries matching specific conditions using exists at path syntax.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Query.filter(Post, author.exists(roles, name == :admin) and author.active)\n```\n\n----------------------------------------\n\nTITLE: Configuring Many to Many Relationships in Ash Resource\nDESCRIPTION: Defines a many_to_many relationship configuration that requires a join resource. Shows the relationship declaration with source and destination attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\nmany_to_many name, destination\n```\n\n----------------------------------------\n\nTITLE: Including a Notifier Extension in a Resource\nDESCRIPTION: Shows how to include a notifier that is also an extension in an Ash resource definition using the 'notifiers' key.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyResource do\n  use Ash.Resource,\n    notifiers: [ExampleNotifier]\nend\n```\n\n----------------------------------------\n\nTITLE: Embedded Resource with Calculations\nDESCRIPTION: Demonstrates how to add calculations to embedded resources and configure their loading in the parent resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Profile do\n  use Ash.Resource,\n    data_layer: :embedded # Use the atom `:embedded` as the data layer.\n\n  attributes do\n    attribute :first_name, :string, public?: true\n    attribute :last_name, :string, public?: true\n  end\n\n  calculations do\n    calculate :full_name, :string, concat([:first_name, :last_name], \" \")\n  end\nend\n\ndefmodule MyApp.User do\n  use Ash.Resource,\n    ...\n\n  attributes do\n    attribute :profile, MyApp.Profile do\n      public? true\n      constraints [load: [:full_name]]\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Destroy Action Declaration in Ash\nDESCRIPTION: Shows how to create a primary destroy action, which will be used when no specific action is specified during resource destruction.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_39\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy :destroy do\n  primary? true\nend\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Grouping in Ash Framework (Elixir)\nDESCRIPTION: This snippet demonstrates how multiple validation errors are grouped into a single Invalid Error with multiple underlying errors during a create operation. The example shows an attempt to create a Representative with invalid data.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nAshExample.Representative\n|> Ash.Changeset.for_create(:create, %{employee_id: \"the best\"})\n|> Ash.create!()\n ** (Ash.Error.Invalid) Invalid Error\n * employee_id: must be absent.\n * first_name, last_name: at least 1 must be present.\n```\n\n----------------------------------------\n\nTITLE: Using Simple Check in Ash Resource Policy (Elixir)\nDESCRIPTION: This example shows how to use a simple check module in an Ash resource policy to authorize an action based on the actor's age.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Beer do\n  # ...\n\n  policies do\n    policy action(:drink) do\n      authorize_if MyApp.Checks.ActorIsOldEnough\n    end\n  end\n\n  # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring UUIDv7 Primary Key in Ash Resource (Elixir)\nDESCRIPTION: Example of declaring a UUIDv7 primary key in an Ash resource, which defaults to using Ash.UUIDv7.generate/0 for value generation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nuuid_v7_primary_key :id\n```\n\n----------------------------------------\n\nTITLE: Implementing Guards in Load Operation\nDESCRIPTION: Provides a flexible method for conditionally executing a step or replacing its result based on the result of a guard function. The function takes the step's arguments and context as parameters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_34\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Custom Tracing Implementation in Resource Change\nDESCRIPTION: Example of implementing custom tracing and telemetry spans within a resource change, including before action hooks and custom span creation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/monitoring.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.CustomChange do\n  use Ash.Resource.Change\n\n  require Ash.Tracer\n\n  def change(changeset, _, _) do\n    changeset\n    |> Ash.Changeset.before_action(fn changeset ->\n      Ash.Tracer.span(:custom, \"custom name\", changeset.context[:private][:tracer]) do\n        # optionally set some metadata\n        metadata = %{...}\n        Ash.Tracer.set_metadata(changeset.context[:private][:tracer], :custom, metadata)\n        # will get `:start` and `:stop` suffixed events emitted\n        Ash.Tracer.telemetry_span([:telemetry, :event, :name], metadata) do\n          ## Your logic here\n        end\n      end\n    end)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring an Argument in an Update Action in Ash\nDESCRIPTION: Declares a named argument with a specific type for an update action. Arguments allow accepting additional input data that may not correspond to resource attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_36\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, type\n```\n\n----------------------------------------\n\nTITLE: Filtering Friends with Exists in Ash Elixir\nDESCRIPTION: Demonstrates how to use the 'exists' helper in Ash queries to create more precise filters for related data, avoiding overly restrictive conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\nread :friends_of_ted do\n  filter expr(exists(friends, first_name == \"ted\"))\nend\n\nResource\n|> Ash.Query.for_read(:friends_of_ted)\n|> Ash.Query.filter(exists(friends, last_name == \"dansen\"))\n```\n\n----------------------------------------\n\nTITLE: Guard Function Definition for Conditional Execution\nDESCRIPTION: Example of implementing a guard function for conditional step execution with file reading and caching logic.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_40\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Domain Description\nDESCRIPTION: Defines a domain with a description. This allows setting a description for the domain to provide context about its purpose.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndomain do\n  description \"\"\"\n  Resources related to the flux capacitor.\n  \"\"\"\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Domain with Built-in Options in Elixir/Ash\nDESCRIPTION: Shows how to configure cross-cutting concerns using built-in configuration options in an Ash domain, including execution timeouts and authorization settings.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/domains.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweets do\n  use Ash.Domain\n\n  resources do\n    resource MyApp.Tweets.Tweet\n    resource MyApp.Tweets.Comment\n  end\n\n  execution do\n    # raise the default timeout for all actions in this domain from 30s to 60s\n    timeout :timer.seconds(60)\n  end\n\n  authorization do\n    # disable using the authorize?: false flag when calling actions\n    authorize :always\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using forbid_unless in Ash.Policy.Authorizer\nDESCRIPTION: Examples of using the forbid_unless check in Ash.Policy.Authorizer to forbid requests unless specific conditions are met.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless actor_attribute_matches_record(:group, :group)\n```\n\n----------------------------------------\n\nTITLE: Defining Ash Domain Resources\nDESCRIPTION: Lists resources that belong to a domain. This allows specifying which resources are part of the domain.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nresources do\n  resource MyApp.Tweet\n  resource MyApp.Comment\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Filter Check for Ash Policy (Elixir)\nDESCRIPTION: This code snippet shows how to create a filter check module for Ash policies, specifically filtering users based on an age limit.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Checks.ActorOverAgeLimit do\n  use Ash.Policy.FilterCheck\n\n  def filter(actor, _authorizer, _opts) do\n    expr(age_limit <= ^actor.age)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Actor Reference in Ash Policy Expressions (Elixir)\nDESCRIPTION: This snippet demonstrates how to reference the actor in Ash policy expression checks, specifically authorizing records authored by the current actor.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\n# Authorize records that have an author relationship with the author ID the same as the actor ID\n# ie. records authored by the actor\nauthorize_if expr(author.id == ^actor(:id))\n```\n\n----------------------------------------\n\nTITLE: Integer Primary Key Attribute Configuration in Elixir\nDESCRIPTION: Configuration for integer_primary_key attribute that sets up an auto-incrementing integer primary key. Creates a non-writable, non-nullable, generated primary key.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/attributes.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :id, :integer do\n  writable? false\n  generated? true\n  primary_key? true\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic DSL Extension in Elixir\nDESCRIPTION: Creates a simple DSL extension module called MyApp.Extensions.Base with a single transformer that will add timestamps to resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Extensions.Base do\n  use Spark.Dsl.Extension, transformers: [MyApp.Extensions.Base.AddTimestamps]\nend\n```\n\n----------------------------------------\n\nTITLE: Authorizing Unless Condition in Ash Policy (Elixir)\nDESCRIPTION: Defines an authorize_unless check within a policy. If the specified check is false, the request is authorized; otherwise, remaining checks are executed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless check\n```\n\n----------------------------------------\n\nTITLE: Denylist Style Field Policy Configuration\nDESCRIPTION: Shows how to implement a denylist-style field policy where specific sensitive fields require admin access while all others are publicly accessible.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\n# Example of denylist style\nfield_policies do\n  field_policy [:sensitive, :fields] do\n    authorize_if actor_attribute_equals(:admin, true)\n  end\n\n  field_policy :* do\n    authorize_if always()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Embedded Resource with Primary Key\nDESCRIPTION: Shows how to implement a primary key in an embedded resource for better list management and validation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tag do\n  use Ash.Resource,\n    data_layer: :embedded\n\n  attributes do\n    uuid_primary_key :id\n    attribute :name, :string, public?: true\n    attribute :counter, :integer, public?: true\n  end\n\n  validations do\n    validate {Increasing, field: :counter}, on: :update\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Callback for Validations in Ash (Elixir)\nDESCRIPTION: Shows how to implement the atomic callback for validations in Ash, using the attribute_equals validation as an example.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n@impl true\ndef atomic(_changeset, opts, context) do\n  {:atomic, [opts[:attribute]], expr(^atomic_ref(opts[:attribute]) != ^opts[:value]),\n   expr(\n     error(^InvalidAttribute, %{\n       field: ^opts[:attribute],\n       value: ^atomic_ref(opts[:attribute]),\n       message: ^(context.message || \"must equal %{value}\"),\n       vars: %{field: ^opts[:attribute], value: ^opts[:value]}\n     })\n   )}\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing belongs_to Relationship Attributes\nDESCRIPTION: Examples showing how to customize the attributes used in a belongs_to relationship, including specifying custom attribute names and types.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nbelongs_to :owner, MyApp.User do\n  # defaults to :<relationship_name>_id (i.e. :owner_id)\n  source_attribute :custom_attribute_name\n\n  # defaults to :id\n  destination_attribute :custom_attribute_name\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Base Resource for Standardized Configuration\nDESCRIPTION: Defines a base resource module that enforces timestamps on all resources that use it, providing a way to standardize behavior across resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Resource do\n  defmacro __using__(opts) do\n    quote do\n      use Ash.Resource, unquote(opts)\n\n      attributes do\n        timestamps()\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Read Action in Ash Framework (Elixir)\nDESCRIPTION: Example of defining a manual read action with an implementation that handles both the Ash query and the underlying data layer query. Shows how to create a custom read implementation that can be used with resource actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/manual-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# in the resource\nactions do\n  read :action_name do\n    manual MyApp.ManualRead\n    # or `{MyApp.ManualRead, ...opts}`\n  end\nend\n\n# the implementation\ndefmodule MyApp.ManualRead do\n  use Ash.Resource.ManualRead\n\n  def read(ash_query, ecto_query, _opts, _context) do\n    ...\n    {:ok, query_results} | {:error, error}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Change Implementation in Elixir\nDESCRIPTION: Implementation of a custom Slugify change module that transforms text by replacing spaces with hyphens. Includes initialization and change logic.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Changes.Slugify do\n\n  use Ash.Resource.Change\n\n  # transform and validate opts\n  @impl true\n  def init(opts) do\n    if is_atom(opts[:attribute]) do\n      {:ok, opts}\n    else\n      {:error, \"attribute must be an atom!\"}\n    end\n  end\n\n  @impl true\n  def change(changeset, opts, _context) do\n    case Ash.Changeset.fetch_change(changeset, opts[:attribute]) do\n      {:ok, new_value} ->\n        slug = String.replace(new_value, ~r/\\s+/, \"-\")\n        Ash.Changeset.force_change_attribute(changeset, opts[:attribute], slug)\n      :error ->\n        changeset\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Atomic Upgrade in Elixir for Ash Project\nDESCRIPTION: This snippet demonstrates how to disable atomic upgrades and configure the read action used for atomic upgrades in an Ash project action. It shows the use of `atomic_upgrade?` and `atomic_upgrade_with` options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\natomic_upgrade? false\natomic_upgrade_with :list_all\n```\n\n----------------------------------------\n\nTITLE: Configuring belongs_to and many_to_many Relationships in Elixir\nDESCRIPTION: Example of configuring belongs_to and many_to_many relationships in an Ash resource. It demonstrates setting up a belongs_to relationship with an author and a many_to_many relationship with categories through a join resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nrelationships do\n  belongs_to :author, MyApp.Author\n\n  many_to_many :categories, MyApp.Category do\n    through MyApp.PostCategory\n    destination_attribute_on_join_resource :category_id\n    source_attribute_on_join_resource :post_id\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Validation Example with Builtin Validator\nDESCRIPTION: Example of using a builtin validation to ensure at least one of the specified fields is present.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_66\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate at_least_one_of_present([:first_name, :last_name])\n```\n\n----------------------------------------\n\nTITLE: Filtering for Specific Error Types in Ash Framework (Elixir)\nDESCRIPTION: This snippet demonstrates how to filter for a specific error type within a rescued error. It shows the pattern for finding a particular error class within the grouped errors returned by an Ash operation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ntry do\n  AshExample.Representative\n  |> Ash.Changeset.for_create(:create, %{employee_id: \"dabes\"})\n  |> Ash.create!()\nrescue\n  e in Ash.Error.Invalid ->\n    case Enum.find(e.errors, &(&1.__struct__ == A.Specific.Error)) do\n      nil ->\n        ...handle errors\n      error ->\n        ...handle specific error you found\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Forbidding Unless Condition in Ash Policy (Elixir)\nDESCRIPTION: Defines a forbid_unless check within a policy. If the specified check is false, the request is forbidden; otherwise, remaining checks are executed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless check\n```\n\n----------------------------------------\n\nTITLE: Embedded Resource with Validations\nDESCRIPTION: Shows how to add validations to an embedded resource to ensure at least one required field is present.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Profile do\n  use Ash.Resource,\n    data_layer: :embedded # Use the atom `:embedded` as the data layer.\n\n  attributes do\n    attribute :first_name, :string, public?: true\n    attribute :last_name, :string, public?: true\n  end\n\n  validations do\n    validate present([:first_name, :last_name], at_least: 1)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Multiple Global Changes Example in Elixir\nDESCRIPTION: Comprehensive example showing multiple global changes with different configurations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nchanges do\n  change relate_actor(:owner)\n  change set_attribute(:committed_at, &DateTime.utc_now/0)\n  change optimistic_lock(:version), on: [:create, :update, :destroy]\n  change {Slugify, [attribute: :foo]}, on: :create\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Has Many Filter in Ash Resource\nDESCRIPTION: Demonstrates how to apply filters to has_many relationships in Ash resources. Filters can use arg/1, context/1 and actor/1 templates, with multiple filters being combined with AND logic.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nfilter filter\n```\n\n----------------------------------------\n\nTITLE: Specifying Inputs in Ash Reactor\nDESCRIPTION: Shows how to specify inputs for an action using either map or keyword list syntax. Allows mapping of input sources to named parameters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Adding Validation to Update Action (Elixir)\nDESCRIPTION: Syntax for adding a validation to an update action in Ash framework. It can be a custom function or a predefined validation module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_34\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate validation\n```\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate changing(:email)\n```\n\n----------------------------------------\n\nTITLE: Using atomic_ref in Ash Update Actions (Elixir)\nDESCRIPTION: Demonstrates the use of atomic_ref to refer to the new value of an attribute in atomic updates, changes, or validations. This example uses a postgres function to slugify the name attribute.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nchanges do\n  change atomic_update(:slug, expr(fragment(\"slugify(?)\", ^atomic_ref(:name)))), where: changing(:name), on: [:update]\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Inline Aggregates in Ash Expressions in Elixir\nDESCRIPTION: This example demonstrates how to create inline aggregates within Ash expressions. It calculates a grade based on the ratio of correct to incorrect answers.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :grade, :decimal, expr(\n  count(answers, query: [filter: expr(correct == true)]) /\n  count(answers, query: [filter: expr(correct == false)])\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Changeset with Organization as Tenant\nDESCRIPTION: Example of using the Ash.ToTenant protocol to convert complex objects to tenant values. This allows passing organization entities as tenant values instead of just IDs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_create(..., tenant: %MyApp.Organization{id: id})\n```\n\n----------------------------------------\n\nTITLE: Implementing Guard Functions in Ash Reactor\nDESCRIPTION: Defines a guard function for conditionally executing steps or replacing results. Takes two arguments - step arguments and context, returning either :cont or {:halt, result}.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Identity in Ash Resources\nDESCRIPTION: Defines a unique constraint on a resource using the identity DSL function. Takes a name and a list of keys that form the unique constraint.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_53\n\nLANGUAGE: elixir\nCODE:\n```\nidentity name, keys\n```\n\n----------------------------------------\n\nTITLE: Adding Policy Authorizer to an Ash Resource\nDESCRIPTION: Shows how to add the Ash.Policy.Authorizer extension to an Ash resource, which is required to implement policies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nuse Ash.Resource, authorizers: [Ash.Policy.Authorizer]\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Batch Destroys in Ash Framework\nDESCRIPTION: Demonstrates how to perform bulk destroys in batches using the batch_size option. This approach is used when working with an enumerable of records.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.bulk_destroy!(one_hundred_tickets, :close, %{}, batch_size: 10)\n```\n\n----------------------------------------\n\nTITLE: Adding Ash.Reactor Extension to an Existing Reactor Module in Elixir\nDESCRIPTION: Shows how to add the Ash.Reactor extension to an existing Reactor module using the 'use' directive with extensions option.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/reactor.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyExistingReactor do\n  use Reactor, extensions: [Ash.Reactor]\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Policy in Ash Framework (Elixir)\nDESCRIPTION: Defines a policy with a condition, checks, and options. Policies can be used to authorize or forbid actions based on specified conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\npolicy condition \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Resource Instances\nDESCRIPTION: Example of defining a generic action that returns an array of resource instances.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\naction :list_resources, {:array, :struct} do\n  constraints items: [instance_of: __MODULE__]\n\n  run # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Input Configuration Examples in Reactor\nDESCRIPTION: Examples showing different ways to specify inputs for an action using both map and keyword list syntax.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_29\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Generic Action in Ash\nDESCRIPTION: Example of defining a simple generic action that takes a name argument and returns a greeting string.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\naction :say_hello, :string do\n  argument :name, :string, allow_nil?: false\n\n  run fn input, _ ->\n    {:ok, \"Hello: #{input.arguments.name}\"}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Custom Query Calculation in Ash\nDESCRIPTION: Shows how to use a custom calculation within a query, specifying the calculation type, keys, and separator argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/calculations.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.calculate(:full_name, {Concat, keys: [:first_name, :last_name]}, :string, %{separator: \",\"})\n```\n\n----------------------------------------\n\nTITLE: Defining Manual Relationships in Ash Framework\nDESCRIPTION: Shows how to define a manual relationship in a Representative resource, pointing to a custom implementation module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\nrelationships do\n  has_many :tickets_above_threshold, Helpdesk.Support.Ticket do\n    manual Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Filtering with Exists in Ash Queries\nDESCRIPTION: Demonstrates how to use exists filters for composable queries across to_many relationships.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndef has_comment_with_more_points_than(query, score) do\n  Ash.Query.filter(query, exists(comments, points > ^score))\nend\n\ndef has_comment_tagged(query, tag) do\n  Ash.Query.filter(query, exists(comments.tag, name == ^tag))\nend\n\nPost\n|> has_comment_with_more_points_than(10)\n|> has_comment_tagged(\"elixir\")\n```\n\n----------------------------------------\n\nTITLE: UUID Primary Key Attribute Configuration in Elixir\nDESCRIPTION: Configuration for uuid_primary_key attribute that generates a UUID for new records. Sets up a non-writable, non-nullable primary key with UUID generation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/attributes.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :id, :uuid do\n  writable? false\n  default &Ash.UUID.generate/0\n  primary_key? true\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Transformer for Adding Timestamps\nDESCRIPTION: Implements a transformer that adds inserted_at and updated_at timestamps to Ash resources by modifying the DSL state.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Extensions.Base.AddTimestamps do\n  use Spark.Dsl.Transformer\n  alias Spark.Dsl.Transformer\n\n  def transform(dsl_state) do\n    dsl_state\n    # Ash.Resource.Builder has utilities for extending resources\n    |> Ash.Resource.Builder.add_new_create_timestamp(:inserted_at)\n    |> Ash.Resource.Builder.add_new_update_timestamp(:updated_at)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Timestamp Attribute Configuration in Elixir\nDESCRIPTION: Configuration for create_timestamp attribute that automatically records row creation time using DateTime.utc_now/0. Sets the attribute as non-writable, non-nullable with default timestamp.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/attributes.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :inserted_at, :utc_datetime_usec do\n  writable? false\n  default &DateTime.utc_now/0\n  match_other_defaults? true\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Module-backed Calculations in Elixir\nDESCRIPTION: Demonstrates how to update module-backed calculations to access arguments from the context struct in Ash 3.0.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndef calculate(records, _opts, context) do\n  Enum.map(records, fn record ->\n    record.first_name <> context.delimiter <> record.last_name\n  end)\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\ndef calculate(records, _opts, %{arguments: arguments}) do\n  Enum.map(records, fn record ->\n    record.first_name <> arguments.delimiter <> record.last_name\n  end)\nend\n```\n\n----------------------------------------\n\nTITLE: Authorizing with Condition in Ash Policy (Elixir)\nDESCRIPTION: Defines an authorize_if check within a policy. If the specified check is true, the request is authorized; otherwise, remaining checks are executed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_if check\n```\n\n----------------------------------------\n\nTITLE: Declaring a Change in a Destroy Action\nDESCRIPTION: Adds a change to be applied during the destroy action. Changes can modify the data or perform side effects before the destroy operation completes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_40\n\nLANGUAGE: elixir\nCODE:\n```\nchange change\n```\n\n----------------------------------------\n\nTITLE: Example of Creating a Post Publishing Update Step in Ash Reactor\nDESCRIPTION: A comprehensive example showing how to create an update step that publishes a post, including setting the actor, tenant, and inputs from various sources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_58\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :publish_post, MyApp.Post, :update do\n  initial input(:post)\n  inputs %{\n    published: value(true)\n  }\n  actor result(:get_user)\n  tenant result(:get_organisation, [:id])\nend\n```\n\n----------------------------------------\n\nTITLE: Upsert with Runtime Options\nDESCRIPTION: Example of performing an upsert using runtime options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.create!(changeset, upsert?: true, upsert_identity: :unique_email)\n```\n\n----------------------------------------\n\nTITLE: Specifying Input Parameters for Update Operations in Ash Reactor\nDESCRIPTION: A nested DSL component for defining the inputs for an update action. Accepts a map or keyword list of input values that can reference results from other steps or direct inputs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_54\n\nLANGUAGE: elixir\nCODE:\n```\ninputs template\n```\n\n----------------------------------------\n\nTITLE: Configuring a Notifier for Specific Actions\nDESCRIPTION: Demonstrates how to configure a notifier for a specific action to avoid complexity in implementation by attaching it directly to the create action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :create do\n  notifiers [ExampleNotifier]\nend\n```\n\n----------------------------------------\n\nTITLE: Read Action Examples in Ash Reactor\nDESCRIPTION: Demonstrates different ways to declare read actions on resources, including basic reads and reads with custom inputs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_43\n\nLANGUAGE: elixir\nCODE:\n```\nread :read_posts, MyApp.Post, :read\n```\n\nLANGUAGE: elixir\nCODE:\n```\nread :read_posts_in_range, MyApp.Post, :read_in_range do\n  inputs %{min_date: input(:min_date), max_date: input(:max_date)}\nend\n```\n\n----------------------------------------\n\nTITLE: Waiting for Dependencies in Load Operation\nDESCRIPTION: Specifies that the step should wait for the named step(s) to complete before starting. This is implemented by creating an implicit dependency on the result of the named step.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_37\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Defining Action-Specific Validations in Ash\nDESCRIPTION: Example of adding a validation to a specific create action in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  create :create do\n    validate compare(:age, greater_than_or_equal_to: 18)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Argument for Create Action in Ash Resource\nDESCRIPTION: Defines an argument for a create action in an Ash resource. Specifies the name, type, and optional constraints for the argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_28\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, type\n```\n\n----------------------------------------\n\nTITLE: Adding Pagination Support in Manual Read Actions (Elixir)\nDESCRIPTION: Example of a manual read implementation that returns extra information like full count for pagination. This allows custom implementations to properly support Ash's pagination features.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/manual-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.ManualRead do\n  use Ash.Resource.ManualRead\n\n  def read(ash_query, ecto_query, _opts, _context) do\n    %{\"data\" => data, \"count\" => count} = make_some_api_request(...)\n    if ash_query.page[:count] do\n      {:ok, query_results}\n    else\n      {:ok, query_results, %{full_count: count}} \n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Bulk Create Example\nDESCRIPTION: Demonstrates bulk creation of posts with actor and tenant configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nbulk_create :create_posts, MyApp.Post, :create do\n  initial input(:titles)\n  actor result(:get_user)\n  tenant result(:get_organisation, [:id])\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Explicit Field Dependencies for Calculations in Ash 3.0\nDESCRIPTION: Ash 3.0 requires explicit field selection for relationship dependencies in calculations. This snippet demonstrates how to update the load/3 callback to select specific fields from a relationship.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\ndef load(_, _, _) do\n  [relationship: [:field1, :field2]]\nend\n```\n\n----------------------------------------\n\nTITLE: Identity Configuration in Ash\nDESCRIPTION: Example of defining unique identifiers for a resource using full name and email fields.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_52\n\nLANGUAGE: elixir\nCODE:\n```\nidentities do\n  identity :full_name, [:first_name, :last_name]\n  identity :email, [:email]\nend\n```\n\n----------------------------------------\n\nTITLE: Using Builtin Preparations in Elixir\nDESCRIPTION: Examples of using builtin preparations for sorting and limiting query results using the build/1 preparation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# sort by inserted at descending\nprepare build(sort: [inserted_at: :desc])\n\n# only show the top 5 results\nprepare build(sort: [total_points: :desc], limit: 5)\n```\n\n----------------------------------------\n\nTITLE: Custom Transaction Handling with Notifications\nDESCRIPTION: Demonstrates how to handle notifications manually when working with custom transactions, using the return_notifications option and explicitly notifying after transaction completion.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nresult =\n  Ash.DataLayer.transaction(resource, fn ->\n    {:ok, something, notifications1} = create_something()\n    {:ok, result, notifications2} = create_another_thing(something)\n    {:ok, notifications3} = destroy_something(something)\n\n    {result, Enum.concat([notifications1, notifications2, notifications3])}\n  end)\n\ncase result do\n  {:ok, value, notifications} ->\n     Ash.Notifier.notify(notifications)\n\n     value\n  {:error, error} ->\n    handle_error(error)\nend\n```\n\n----------------------------------------\n\nTITLE: Validations DSL Example\nDESCRIPTION: Example of using the validations DSL to define multiple validations for a resource, including a module-based validation and a builtin validation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_64\n\nLANGUAGE: elixir\nCODE:\n```\nvalidations do\n  validate {Mod, [foo: :bar]}\n  validate at_least_one_of_present([:first_name, :last_name])\nend\n\n```\n\n----------------------------------------\n\nTITLE: Loading Records with Ash Reactor DSL\nDESCRIPTION: Declares a step that will load additional data on a resource. This allows for loading relationships or other data on existing records within a reactor flow.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_31\n\nLANGUAGE: elixir\nCODE:\n```\nload name, records, load\n```\n\n----------------------------------------\n\nTITLE: Bulk Update Operation Definition\nDESCRIPTION: Declares a step for executing bulk updates on a resource with specified action and options. Includes support for undo actions and notification handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nbulk_update name, resource, action \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Preparation in Elixir\nDESCRIPTION: Example of adding a preparation that applies to all read actions within a resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\npreparations do\n  prepare {Top5, attribute: :name}\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Change in Update Action (Elixir)\nDESCRIPTION: Syntax for adding a change to an update action in Ash framework. It can be a custom function or a predefined change module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_33\n\nLANGUAGE: elixir\nCODE:\n```\nchange change\n```\n\nLANGUAGE: elixir\nCODE:\n```\nchange relate_actor(:reporter)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nchange {MyCustomChange, :foo}\n```\n\n----------------------------------------\n\nTITLE: Configuring Allow Forbidden Field Option in Ash (Elixir)\nDESCRIPTION: This snippet shows how to configure the `allow_forbidden_field?` option in Ash to return `Ash.ForbiddenField{}` instead of failing the entire request when a related read action would produce a forbidden error.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :allow_forbidden_field_for_relationships_by_default, true\n```\n\n----------------------------------------\n\nTITLE: Wait For Step Completion\nDESCRIPTION: Configures step dependencies by waiting for named steps to complete before proceeding.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Defining Belongs To Filter in Ash Resource\nDESCRIPTION: Example showing how to apply filters to belongs_to relationships using expressions. Supports argument, context and actor templates with multiple filters combined using AND.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nfilter filter\n```\n\n----------------------------------------\n\nTITLE: Configuring Action-Specific Preparation in Elixir\nDESCRIPTION: Example of adding a preparation to a specific read action within a resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  read :read do\n    prepare {Top5, attribute: :name}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Aggregates\nDESCRIPTION: Declares named aggregates on a resource that can be loaded by name and are available as top-level fields.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_67\n\nLANGUAGE: elixir\nCODE:\n```\ncount name, relationship_path\n```\n\n----------------------------------------\n\nTITLE: Using Tenant-Aware Identities in Ash\nDESCRIPTION: Examples showing how tenant-aware identities work in practice. Demonstrates that duplicate emails are allowed across different tenants, but usernames must be globally unique regardless of tenant.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\n# These are valid because they're in different tenants\nUser\n|> Ash.Changeset.for_create(:create, %{email: \"fred@example.com\"})\n|> Ash.Changeset.set_tenant(1)\n|> Ash.create!()\n\nUser\n|> Ash.Changeset.for_create(:create, %{email: \"fred@example.com\"})\n|> Ash.Changeset.set_tenant(2)\n|> Ash.create!()\n\n# This would fail because usernames are global\nUser\n|> Ash.Changeset.for_create(:create, %{username: \"fred\"})\n|> Ash.Changeset.set_tenant(1)\n|> Ash.create!()\n\nUser\n|> Ash.Changeset.for_create(:create, %{username: \"fred\"})\n|> Ash.Changeset.set_tenant(2)\n|> Ash.create!() # Error: username already taken\n```\n\n----------------------------------------\n\nTITLE: Defining Query Preparations\nDESCRIPTION: Declares preparations that occur on all read actions for a given resource, used to modify queries before execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_60\n\nLANGUAGE: elixir\nCODE:\n```\nprepare preparation\n```\n\n----------------------------------------\n\nTITLE: Identity Example with Single Field\nDESCRIPTION: Example of defining an identity constraint on a single field named 'name'.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_54\n\nLANGUAGE: elixir\nCODE:\n```\nidentity :name, [:name]\n```\n\n----------------------------------------\n\nTITLE: Customizing Relationship Loading Queries\nDESCRIPTION: Example showing how to provide a customized query when loading relationships, including sorting options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nfollowers = Ash.Query.sort(User, follower_count: :asc)\n\nAsh.load(users, followers: followers)\n```\n\n----------------------------------------\n\nTITLE: Conditional Change with Where Clause in Elixir\nDESCRIPTION: Example of implementing a conditional change using the where clause.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nchange {Slugify, attribute: :foo} do\n  where [attribute_equals(:slugify, true)]\nend\n```\n\n----------------------------------------\n\nTITLE: SQL Equivalent of Atomic Batches Bulk Update (SQL)\nDESCRIPTION: Demonstrates the SQL equivalent of the atomic batches bulk update operation, which updates records in batches using IN clauses.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE tickets\nSET status = 'closed',\n    reason = 'Closing all open tickets.'\nWHERE id IN (...ids)\n```\n\n----------------------------------------\n\nTITLE: Configuring Nil Value Handling in Embedded Resource\nDESCRIPTION: Demonstrates how to configure nil value handling in embedded resources using embed_nil_values? option.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule YourEmbed do\n  use Ash.Resource,\n    data_layer: :embedded,\n    embed_nil_values?: false\nend\n```\n\n----------------------------------------\n\nTITLE: Dynamic References in Expressions (New Format)\nDESCRIPTION: Updated syntax for building dynamic references in expressions in Ash 3.0, where the ref function must be pinned with ^ when used inside expressions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nexpr(^ref(some_atom))\n```\n\n----------------------------------------\n\nTITLE: Atomic Change Implementation in Elixir\nDESCRIPTION: Example of implementing atomic changes in a custom change module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Changes.Slugify do\n  # transform and validate opts\n\n  use Ash.Resource.Change\n\n  ...\n\n  def atomic(changeset, opts, context) do\n    {:atomic, %{\n      opts[:attribute] => expr(\n        fragment(\"regexp_replace(?, ?, ?)\", ^ref(opts[:attribute]), ~r/\\s+/, \"-\")\n      )\n    }}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Sorting by Aggregates in Ash Queries in Elixir\nDESCRIPTION: This snippet shows how to sort users based on an aggregate value, specifically sorting users by their post count in ascending order.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nUser\n|> Ash.Query.sort(count_of_posts: :asc)\n|> Ash.read!()\n```\n\n----------------------------------------\n\nTITLE: Aggregates DSL Example\nDESCRIPTION: Example of using the aggregates DSL to define a count aggregate on a relationship with filtering.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_68\n\nLANGUAGE: elixir\nCODE:\n```\naggregates do\n  count :assigned_ticket_count, :reported_tickets do\n    filter [active: true]\n  end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Functions in Ash Resource Code Interface\nDESCRIPTION: Defines custom functions with specific names and arguments that map to resource actions. These functions provide a programmatic interface to interact with the resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_47\n\nLANGUAGE: elixir\nCODE:\n```\ndefine name\n```\n\nLANGUAGE: elixir\nCODE:\n```\ndefine :get_user_by_id, action: :get_by_id, args: [:id], get?: true\n```\n\n----------------------------------------\n\nTITLE: Configuring Tenant-Aware Identities in Ash\nDESCRIPTION: Demonstrates how to configure identities in multitenant resources with both tenant-scoped and global uniqueness constraints. This allows for the same identity values to exist in different tenants while enforcing uniqueness within a tenant.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.User do\n  use Ash.Resource, ...\n\n  multitenancy do\n    strategy :attribute\n    attribute :organization_id\n  end\n\n  identities do\n    # This email must be unique within a tenant\n    identity :tenant_scoped_email, [:email]\n\n    # This username must be unique across all tenants\n    identity :global_username, [:username], all_tenants?: true\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Generic Action with Return Type Constraints\nDESCRIPTION: Example of defining a generic action with constraints on both the return value and arguments.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\naction :priority, :integer do\n  constraints [min: 1, max: 3]\n  argument :status, :atom, constraints: [one_of: [:high, :medium, :low]]\n\n  run fn input, _ ->\n    case input.arguments.status do\n      :high -> {:ok, 3}\n      :medium -> {:ok, 2}\n      :low -> {:ok, 1}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Step Dependency in Ash Reactor DSL in Elixir\nDESCRIPTION: Example of using the wait_for DSL to specify step dependencies. It ensures that the current step waits for the completion of another step.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Defining Wait Dependencies for Reactor Updates in Ash Framework\nDESCRIPTION: Creates a dependency relationship between steps in a reactor flow. Ensures the current step waits for completion of the specified step(s) before starting execution. Internally desugars to an argument specification.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_62\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Forbid If Policy Check in Elixir Ash Framework\nDESCRIPTION: Implements a conditional forbid policy that denies access if the specified check evaluates to true. Accepts a check parameter that can be any value or module implementing Ash.Policy.Check.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if check\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if not_logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if actor_attribute_matches_record(:group, :blacklisted_groups)\n```\n\n----------------------------------------\n\nTITLE: Specifying Timeout for Ash Read Action in Elixir\nDESCRIPTION: This snippet demonstrates how to set a timeout of 30 seconds when calling an Ash read action. This method takes the highest precedence in timeout specification.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/timeouts.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.read!(query, timeout: :timer.seconds(30))\n```\n\n----------------------------------------\n\nTITLE: Wait For Step Configuration\nDESCRIPTION: Example showing how to configure step dependencies using wait_for.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_30\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Example of Validation Declaration in Ash\nDESCRIPTION: Shows how to use the built-in 'changing' validation to verify that an email field is changing during an action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_43\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate changing(:email)\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Calculation with Options in Elixir\nDESCRIPTION: Defines a full_name calculation with additional options like allow_nil? set to false. This allows configuring behavior aspects of the calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_92\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, expr(first_name <> \" \" <> last_name), allow_nil?: false\n```\n\n----------------------------------------\n\nTITLE: Forbidding with Condition in Ash Policy (Elixir)\nDESCRIPTION: Defines a forbid_if check within a policy. If the specified check is true, the request is forbidden; otherwise, remaining checks are executed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if check\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Action Without Return Type\nDESCRIPTION: Example of defining a generic action without specifying a return type, which will return :ok when successful.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\naction :schedule_job do\n  argument :job_name, :string, allow_nil?: false\n  run fn input, _ ->\n    # Schedule the job\n    :ok\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Actor for Bulk Create Operation in Elixir\nDESCRIPTION: Defines the actor for the bulk create operation. The actor can be specified using a source, with an optional transformation function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Setting Actor and Authorization in Direct Function Calls\nDESCRIPTION: Example demonstrating how to provide actor and authorization options when calling functions without using a changeset, query, or input first.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/actors-and-authorization.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.count!(Post, actor: current_user, authorize?: true)\n```\n\n----------------------------------------\n\nTITLE: Wait For Step Example\nDESCRIPTION: Shows how to make a step wait for another step to complete before execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Example of Using 'wait_for' to Establish Step Dependencies\nDESCRIPTION: A simple example showing how to make a step wait for another named step called 'create_user' to complete before executing.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_57\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for :create_user\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Function Preparation in Elixir\nDESCRIPTION: Example of using an anonymous function as a preparation for prototyping purposes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nprepare fn query, _context ->\n  # put your code here\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Calculation with Block-Style Options in Elixir\nDESCRIPTION: Creates a full_name calculation with options specified in a do block, setting allow_nil? to false and public? to true. This style provides a cleaner syntax for multiple options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_93\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, expr(first_name <> \" \" <> last_name) do\n  allow_nil? false\n  public? true\nend\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern Query Building\nDESCRIPTION: Shows an example of how not to implement complex query logic by building queries outside of resource actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef top_tickets(user_id) do\n  Ticket\n  |> Ash.Query.for_read(:read)\n  |> Ash.Query.filter(priority in [:medium, :high])\n  |> Ash.Query.filter(representative_id == ^user_id)\n  |> Ash.Query.filter(status == :open)\n  |> Ash.Query.sort(opened_at: :desc)\n  |> Ash.Query.limit(10)\n  |> Helpdesk.Support.read!()\nend\n\n# in the resource\n\nactions do\n  defaults [:read, ...]\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Tenant Option in Ash\nDESCRIPTION: Example of enabling global tenant access with the global? option, which allows queries to run without specifying a tenant. This requires careful authorization rules to prevent cross-tenant data access.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nmultitenancy do\n  strategy :attribute\n  attribute :organization_id\n  global? true\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Interface for Ash Resources\nDESCRIPTION: Defines functions that will be available on the resource module. The code interface allows for defining custom functions that map to resource actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_46\n\nLANGUAGE: elixir\nCODE:\n```\ncode_interface do\n  define :create_user, action: :create\n  define :get_user_by_id, action: :get_by_id, args: [:id], get?: true\nend\n```\n\n----------------------------------------\n\nTITLE: Targeted Upsert with Conditions\nDESCRIPTION: Demonstrates upsert configuration with conditional filters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :upsert_article_by_slug do\n  upsert? true\n  accept [:slug, :title, :body]\n  upsert_identity :unique_slug\n  upsert_condition expr(user_id == ^actor(:id))\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Anonymous Function Calculations in Elixir for Ash 3.0\nDESCRIPTION: In Ash 3.0, anonymous function calculations now operate on a list of records instead of a single record. This snippet shows how to update the calculation to handle multiple records and return a list of results.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ncalculate :full_name, :string, fn records, _context ->\n  # note, you can also return `{:ok, list}` or `{:error, error}`\n  Enum.map(records, fn record ->\n    record.first_name <> \" \" <> record.last_name\n  end)\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Context for Update Operations in Ash Reactor\nDESCRIPTION: A nested DSL component for specifying the context map to be merged into an update action's context. Supports optional transformation of the context value.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_52\n\nLANGUAGE: elixir\nCODE:\n```\ncontext context\n```\n\n----------------------------------------\n\nTITLE: Controlling Transformer Order with before? and after?\nDESCRIPTION: Example showing how to control the order of execution for transformers using before? and after? callback functions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\n# I go after every transformer\ndef after?(_), do: true\n\n# except I go before `SomeOtherTransformer`\ndef before?(SomeOtherTransformer), do: true\ndef before?(_), do: false\n```\n\n----------------------------------------\n\nTITLE: Example of Using the 'where' Directive in a File Reading Step\nDESCRIPTION: An example demonstrating how to conditionally execute a file reading step based on file existence using the 'where' directive.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_56\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Changes DSL Example\nDESCRIPTION: Example of using the changes DSL to define multiple changes for a resource, including a module-based change and a context-setting change.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_57\n\nLANGUAGE: elixir\nCODE:\n```\nchanges do\n  change {Mod, [foo: :bar]}\n  change set_context(%{some: :context})\nend\n\n```\n\n----------------------------------------\n\nTITLE: Updated NotLoaded Attribute Handling in Elixir\nDESCRIPTION: Demonstrates the new way to handle potentially unselected attributes in Ash 3.0 using pattern matching on Ash.NotLoaded.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_27\n\nLANGUAGE: elixir\nCODE:\n```\ncase record.attribute do\n  %Ash.NotLoaded{} ->\n    handle_not_selected(...)\n  nil ->\n    handle_not_present_attribute(...)\n  value ->\n    handle_present_attribute(...)\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Updates in Ash (Elixir)\nDESCRIPTION: Shows how to use atomic updates in an Ash update action. This example adds a string to the 'name' attribute using an expression.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :add_to_name do\n  argument :to_add, :string, allow_nil? false\n  change atomic_update(:name, expr(\"#{name}_#{to_add}\"))\nend\n```\n\n----------------------------------------\n\nTITLE: Opting Out of Strict Loads for Calculations in Ash 3.0\nDESCRIPTION: To maintain the old behavior of selecting all fields in a relationship load, you can add a strict_loads/0 callback returning false. This snippet shows how to implement this option.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ndef load(_, _, _) do\n  [:relationship]\nend\n\ndef strict_loads, do: false\n```\n\n----------------------------------------\n\nTITLE: Calculation References in Ash Filters\nDESCRIPTION: Examples of referencing calculations in filter expressions with and without arguments.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n# given a `full_name` calculation\n\nAsh.Query.filter(User, full_name == \"Hob Goblin\")\n\n# given a `full_name` calculation that accepts an argument called `delimiter`\n\nAsh.Query.filter(User, full_name(delimiter: \"~\") == \"Hob~Goblin\")\n```\n\n----------------------------------------\n\nTITLE: Defining Exists Aggregate in Ash Resource\nDESCRIPTION: Creates an exists aggregate that checks if a user has any assigned tickets. This aggregate returns a boolean indicating whether any related records exist.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_71\n\nLANGUAGE: elixir\nCODE:\n```\nexists :has_ticket, :assigned_tickets\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Conditional Execution with 'guard' in Reactor DSL\nDESCRIPTION: A flexible DSL component for conditionally executing a step or replacing its result. Takes a function that returns either :cont to proceed or {:halt, result} to skip execution with a preset result.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_53\n\nLANGUAGE: elixir\nCODE:\n```\nguard fun\n```\n\n----------------------------------------\n\nTITLE: Guarding a Step in Ash Reactor DSL in Elixir\nDESCRIPTION: Example of using the guard DSL to conditionally execute a step or replace its result. It shows how to implement caching logic within a guard.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Action-Specific Change in Elixir\nDESCRIPTION: Example of adding a change to a specific create action in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  create :create do\n    change {Slugify, attribute: :name}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Field-Specific Errors to Changeset (Elixir)\nDESCRIPTION: This snippet demonstrates how to add a field-specific error to an Ash changeset using the keyword list format. This creates an InvalidChanges error associated with the age field.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ndef change(changeset, _, _) do\n  if under_21?(changeset) do\n    Ash.Changeset.add_error(changeset, field: :age, message: \"must be 21 or older\")\n  else\n    changeset\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Step Execution with 'where' in Reactor DSL\nDESCRIPTION: A DSL component that conditionally executes a step based on a predicate function. This is a simpler alternative to the 'guard' DSL that provides basic conditional execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_48\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Change Example with Actor Relation\nDESCRIPTION: Example of defining a change that relates the actor to a resource field.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_58\n\nLANGUAGE: elixir\nCODE:\n```\nchange relate_actor(:reporter)\n```\n\n----------------------------------------\n\nTITLE: Nested Policy Groups in Ash\nDESCRIPTION: Shows how to nest policy groups to create complex authorization conditions while maintaining readability.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  policy_group condition do\n    policy_group condition2 do\n       policy condition3 do\n         # This policy applies if condition, condition2, and condition3 are all true\n       end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Filtering Many-to-Many Relationships in Elixir\nDESCRIPTION: Applies a filter to a many-to-many relationship. Supports using ^arg/1, ^context/1, and ^actor/1 templates. Multiple filters are combined with logical AND.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\nfilter filter\n```\n\n----------------------------------------\n\nTITLE: Error Handling Example for NotLoaded Attributes in Elixir\nDESCRIPTION: Shows how to handle unselected attributes in Ash 2.0, which used nil values for unselected attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\nif record.attribute do\n  handle_present_attribute(...)\nelse\n  # unselected attributes would have ended up in this branch\n  handle_not_present_attribute(...)\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Forbidden Fields in Ash Relationships (Elixir)\nDESCRIPTION: This example demonstrates the result of using the `allow_forbidden_field?` option, where a forbidden relationship is represented as `Ash.ForbiddenField{}` instead of causing a request failure.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\n{:ok, %MyApp.Post{author: %Ash.ForbiddenField{}}}\n```\n\n----------------------------------------\n\nTITLE: Sum Aggregate Definition in Ash Framework\nDESCRIPTION: Declares a named sum aggregate on a resource. This function allows calculating the sum of values from a field in related records, with optional filtering. Supports various configuration options like defaults and authorization settings.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_75\n\nLANGUAGE: elixir\nCODE:\n```\nsum name, relationship_path, field\n```\n\n----------------------------------------\n\nTITLE: Configuring Relationship Management Actions in Ash\nDESCRIPTION: Demonstrates how to set up action arguments and changes for managing relationships through changesets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  update :update do\n    argument :add_comment, :map do\n      allow_nil? false\n    end\n\n    argument :tags, {:array, :uuid} do\n      allow_nil? false\n    end\n\n    # First argument is the name of the action argument to use\n    # Second argument is the relationship to be managed\n    # Third argument is options. For more, see `Ash.Changeset.manage_relationship/4`. This accepts the same options.\n    change manage_relationship(:add_comment, :comments, type: :create)\n\n    # Second argument can be omitted, as the argument name is the same as the relationship\n    change manage_relationship(:tags, type: :append_and_remove)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring has_one Relationship Example in Elixir\nDESCRIPTION: Example of configuring a has_one relationship in an Ash resource. It demonstrates setting up a dictionary_entry relationship for a Word resource, specifying source and destination attributes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\n# In a resource called `Word`\nhas_one :dictionary_entry, DictionaryEntry do\n  source_attribute :text\n  destination_attribute :word_text\nend\n```\n\n----------------------------------------\n\nTITLE: Guard Function Example in Reactor\nDESCRIPTION: Example showing how to implement a guard function for conditional step execution with cache checking.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_27\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Where Predicate Example with File Check\nDESCRIPTION: Demonstrates using a where predicate to conditionally execute a file read operation based on file existence.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_41\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution with Where Clause in Elixir\nDESCRIPTION: Shows how to use the where clause to conditionally execute a step based on a predicate function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_47\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing Ash Resource Input\nDESCRIPTION: Defines a custom input for an Ash resource action. This allows transforming input arguments before they are used in the action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ncustom_input :artist, :struct do\n  transform to: :artist_id, using: &(&1.id)\n\n  constraints instance_of: Artist\nend\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Extension in an Ash Resource\nDESCRIPTION: Demonstrates how to include and configure the custom extension in an Ash resource definition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Tweet do\n  use Ash.Resource,\n    extensions: [MyApp.Extensions.Base]\n\n  base do\n    # And you can configure it like so\n    timestamps? false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handlers in Ash Resource Actions (Elixir)\nDESCRIPTION: This example shows how to implement an error_handler in an Ash resource action. The handler transforms a StaleRecord error into an InvalidChanges error with a more user-friendly message about slug uniqueness.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ncreate :upsert_article_by_slug do\n  upsert? true\n  accept [:slug, :title, :body]\n  upsert_identity :unique_slug\n  upsert_condition expr(user_id == ^actor(:id))\n  error_handler fn \n    _changeset, %Ash.Error.Changes.StaleRecord{} ->\n      Ash.Error.Changes.InvalidChanges.exception(field: :slug, message: \"has already been taken\")\n\n    _ changeset, other ->\n      # leave other errors untouched\n      other\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Ash Step Creation\nDESCRIPTION: Demonstrates creating a basic Ash step for post creation with a title argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nash_step :create_post, MyApp.CreatePostStep do\n  argument :title, input(:title)\nend\n```\n\n----------------------------------------\n\nTITLE: Example of Max Aggregate in Ash\nDESCRIPTION: Demonstrates defining a max aggregate that finds the highest severity value among active assigned tickets. This example shows how to find a maximum value with filtering.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_82\n\nLANGUAGE: elixir\nCODE:\n```\nmax :first_assigned_ticket_subject, :assigned_tickets, :severity do\n  filter [active: true]\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Validation in Custom Validation Module\nDESCRIPTION: Example of implementing the atomic callback in a custom validation to make it compatible with database-level validation, using the IsPrime validation as an example.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Validations.IsPrime do\n  # transform and validate opts\n\n  use Ash.Resource.Validation\n\n  ...\n\n  def atomic(changeset, opts, context) do\n    # lets ignore that there is no easy/built-in way to check prime numbers in postgres\n    {:atomic,\n      # the list of attributes that are involved in the validation\n      [opts[:attribute]],\n      # the condition that should cause the error\n      # here we refer to the new value or the current value\n      expr(not(fragment(\"is_prime(?)\", ^atomic_ref(opts[:attribute])))),\n      # the error expression\n      expr(\n        error(^InvalidAttribute, %{\n          field: ^opts[:attribute],\n          # the value that caused the error\n          value: ^atomic_ref(opts[:attribute]),\n          # the message to display\n          message: ^(context.message || \"%{field} must be prime\"),\n          vars: %{field: ^opts[:attribute]}\n        })\n      )\n    }\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Inputs in Ash Reactor DSL in Elixir\nDESCRIPTION: Examples of using the inputs DSL to specify inputs for an action. It shows two different syntaxes for providing inputs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Exception Modules with Changeset (Elixir)\nDESCRIPTION: This snippet shows how to create and add a specific exception type (Ash.Error.Changes.Required) to a changeset. It demonstrates setting field, type, and resource properties on the exception.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ndef change(changeset, _, _) do\n  if under_21?(changeset) do\n    error = Ash.Error.Changes.Required.exception(\n      field: :foo,\n      type: :attribute,\n      resource: changeset.resource\n    )\n\n    Ash.Changeset.add_error(changeset, error)\n  else\n    changeset\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Exception Types in Ash (Elixir)\nDESCRIPTION: This example demonstrates how to create a custom exception module for Ash using Splode.Error. It shows how to define a custom TooYoung exception with an age field and a custom message function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Errors.Invalid.TooYoung do\n  @moduledoc \"Used when a user who is too young is attempted to be created\"\n  use Splode.Error, fields: [:age], class: :invalid\n\n  def message(error) do\n    \"\"\"\n    Must be 21 or older, got: #{error.age}.\n    \"\"\"\n  end\nend\n\ndef change(changeset, _, _) do\n  if under_21?(changeset) do\n    error = MyApp.Errors.Invalid.TooYoung.exception(\n      age: Ash.Changeset.get_attribute(changeset, :age)\n    )\n\n    Ash.Changeset.add_error(changeset, error)\n  else\n    changeset\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Tenant in Load Operation\nDESCRIPTION: Specifies the tenant to be used during a load operation. This is important for multi-tenant applications to ensure operations are scoped to the correct tenant.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_36\n\nLANGUAGE: elixir\nCODE:\n```\ntenant source\n```\n\n----------------------------------------\n\nTITLE: Loading Relationships with Nested Loads\nDESCRIPTION: Example showing how nested loads in queries will be included in the parent load operation when loading relationships.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\nfollowers =\n  User\n  |> Ash.Query.sort(follower_count: :asc)\n  |> Ash.Query.load(:followers)\n\n# Will load followers and followers of those followers\nAsh.load(users, followers: followers)\n```\n\n----------------------------------------\n\nTITLE: Example of Attribute Declaration with Validation (Elixir)\nDESCRIPTION: Example of declaring a non-nil string attribute named 'name' in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :name, :string do\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Creating an Always-Applicable Policy in Ash.Policy.Authorizer\nDESCRIPTION: Demonstrates how to create a policy that always applies, regardless of other conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\npolicy always() do\n...\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Actor for Bulk Update in Elixir\nDESCRIPTION: Defines the actor for a bulk update operation. The 'source' argument specifies where to obtain the actor from, and an optional 'transform' function can be used to modify the actor before passing it to the action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Declaring an Argument in Ash Resource Action\nDESCRIPTION: Declares an argument on an Ash resource action. Arguments can be used to accept input for the action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nargument name, type\n```\n\n----------------------------------------\n\nTITLE: Conditional Step Execution in Ash Reactor DSL in Elixir\nDESCRIPTION: Example of using the where DSL to conditionally execute a step based on a predicate function. It demonstrates checking file existence before reading.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Belongs-to Relationship with Authorization Options (Elixir)\nDESCRIPTION: This code defines a belongs-to relationship in Ash with specific authorization options, including `allow_forbidden_field?` and `authorize_read_with`.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nbelongs_to :author, MyApp.Author do\n  allow_nil? false\n  allow_forbidden_field? true\n  athorize_read_with :error\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Simple String Errors to Changeset (Elixir)\nDESCRIPTION: This example shows how to add a simple string error to an Ash changeset. The string will be wrapped in an UnknownError exception automatically.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/error-handling.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndef change(changeset, _, _) do\n  if under_21?(changeset) do\n    Ash.Changeset.add_error(changeset, \"must be 21 or older\")\n  else\n    changeset\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing a Blacklist Policy in Ash.Policy.Authorizer\nDESCRIPTION: Shows how to implement a blacklist-style policy using Ash.Policy.Authorizer, where specific conditions forbid access and all others are allowed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:read) do\nforbid_if not_logged_in()\nforbid_if user_is_denylisted()\nforbid_if user_is_in_denylisted_group()\n\nauthorize_if always()\nend\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with Where in Load Operation\nDESCRIPTION: Only executes the surrounding step if the predicate function returns true. This is a simpler version of guard with less complexity but also less flexibility.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_35\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Configuring Reactor Read Inputs in Elixir\nDESCRIPTION: Demonstrates how to specify inputs for an action using template maps or keyword lists.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_46\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Bulk Destroys in Ash Framework\nDESCRIPTION: Shows how to perform an atomic bulk destroy operation which uses a single statement to the data layer to destroy all matching records based on a query filter.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nTicket\n|> Ash.Query.filter(status == :open)\n|> Ash.bulk_destroy!(:close, %{})\n```\n\n----------------------------------------\n\nTITLE: Declaring a Validation in a Destroy Action\nDESCRIPTION: Adds a validation to be run during the destroy action process. Validations can prevent the destruction if certain conditions aren't met.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_42\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate validation\n```\n\n----------------------------------------\n\nTITLE: Parent References in Ash Expressions\nDESCRIPTION: Examples of using the parent keyword to reference outer scope values in nested expressions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Query.filter(exists(open_tickets, severity >= parent(severity_threshold)))\n```\n\nLANGUAGE: elixir\nCODE:\n```\nhas_many :relevant_tickets, Ticket do\n  no_attributes? true\n  # this says that there is no matching source_attribute and destination_attribute on this relationship\n  filter expr(status == :open and severity >= parent(severity_threshold))\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\ncount :count_of_relevant_tickets, :open_tickets do\n  filter expr(status == :open and severity >= parent(severity_threshold))\nend\n```\n\n----------------------------------------\n\nTITLE: Adding a Change to Ash Resource Create Action\nDESCRIPTION: Specifies a change to be applied to the changeset during a create action. Changes can modify the data before it is persisted.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\nchange change\n```\n\n----------------------------------------\n\nTITLE: Basic Field Policy Definition in Elixir\nDESCRIPTION: Demonstrates how to define a basic field policy that restricts access to admin users.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\nfield_policies do\n  field_policy :admin_only_field do\n    authorize_if actor_attribute_equals(:admin, true)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Timeout in Ash Resource Preparation\nDESCRIPTION: This code defines a preparation module that sets different timeouts based on a query argument. It sets a 3-minute timeout for full reports and a 1-minute timeout for regular reports.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/timeouts.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# in your resource\ndefmodule MyApp.SetReportTimeout do\n  use Ash.Resource.Preparation\n\n  def prepare(query, _, _) do\n    if Ash.Query.get_argument(query, :full_report) do\n      Ash.Query.timeout(query, :timer.minutes(3))\n    else\n      Ash.Query.timeout(query, :timer.minutes(1))\n    end\n  end\nend\n\nactions do\n  read :report_items do\n    argument :full_report, :boolean, default: false\n\n    prepare MyApp.SetReportTimeout\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Join Filter Example for Aggregates\nDESCRIPTION: Example showing how to apply a join filter to filter active authors in comments.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_84\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter [:comments, :author], expr(active == true)\n```\n\n----------------------------------------\n\nTITLE: Query Reuse Pattern in Ash Manual Relationships\nDESCRIPTION: Shows how to properly handle and modify queries when loading relationships, including handling of query parameters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\ndef load(records, _opts, %{query: query, ..}) do\n  # unset some fields\n  fetch_query = Ash.Query.unset(query, [:limit, :offset])\n\n  # or, to be more safe/explicit, you might make a new query, explicitly setting only a few fields\n  fetch_query = query.resource |> Ash.Query.filter(^query.filter) |> Ash.Query.sort(query.sort)\n\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Destroy Action in Ash Reactor\nDESCRIPTION: Base function for declaring a destroy action step on a resource. Supports different undo modes and various configuration options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\ndestroy name, resource, action \\\\ nil\n```\n\n----------------------------------------\n\nTITLE: Adding Embedded Resource Attributes to Parent Resource\nDESCRIPTION: Shows how to add embedded resource attributes to a parent User resource, including single and array attribute definitions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.User do\n  use Ash.Resource, ...\n\n  attributes do\n    ...\n\n    attribute :profile, MyApp.Profile, public?: true\n    attribute :profiles, {:array, MyApp.Profile}, public?: true # You can also have an array of embeds\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Policy Groups in Ash for Organizing Related Policies\nDESCRIPTION: Demonstrates how to use policy groups to organize policies that share common conditions, reducing duplication.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  policy_group actor_attribute_equals(:role, :owner) do\n    policy action_type(:read) do\n      authorize_if expr(owner_id == ^actor(:id))\n    end\n\n    policy action_type([:update, :destroy]) do\n      authorize_if expr(owner_id == ^actor(:id))\n    end\n\n    policy action_type(:create) do\n      authorize_if relating_to_actor(:owner)\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Non-Atomic Update Action in Ash (Elixir)\nDESCRIPTION: Demonstrates a non-atomic update action that increments a score using an anonymous function, which is not safe for concurrent operations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nupdate :increment_score do\n  change fn changeset, _ ->\n    Ash.Changeset.change_attribute(changeset, :score, changeset.data.score + 1)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Min Aggregate in Elixir\nDESCRIPTION: Function to declare a named minimum aggregate on a resource using relationships and field specifications.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_85\n\nLANGUAGE: elixir\nCODE:\n```\nmin :first_assigned_ticket_subject, :assigned_tickets, :severity do\n  filter [active: true]\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Metadata for Create Action in Ash Resource\nDESCRIPTION: Defines metadata for a create action. Metadata is a special kind of attribute that must be set in a custom change after_action hook using Ash.Resource.put_metadata/3.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_29\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata name, type\n```\n\n----------------------------------------\n\nTITLE: Batch Change Implementation in Elixir\nDESCRIPTION: Example of implementing batch processing in a custom change module.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Changes.Slugify do\n  # transform and validate opts\n\n  use Ash.Resource.Change\n\n  @impl true\n  def init(opts) do\n    if is_atom(opts[:attribute]) do\n      {:ok, opts}\n    else\n      {:error, \"attribute must be an atom!\"}\n    end\n  end\n\n  @impl true\n  def batch_change(changeset, opts, context) do\n    # here we could run queries or do common work required\n    # for a given batch of changesets.\n    # in this example, however, we just return the changesets with\n    # the change logic applied.\n    Enum.map(changesets, &change(&1, opts, context))\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring UUID Primary Key in Ash Resource (Elixir)\nDESCRIPTION: Example of declaring a UUID primary key in an Ash resource, which defaults to using Ash.UUID.generate/0 for value generation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nuuid_primary_key :id\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Relationship Module in Ash\nDESCRIPTION: Implementation of a manual relationship module showing how to load and filter related tickets based on threshold conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold do\n  use Ash.Resource.ManualRelationship\n  require Ash.Query\n\n  def load(records, _opts, %{query: query} = context) do\n    # Use existing records to limit results\n    rep_ids = Enum.map(records, & &1.id)\n\n    {:ok,\n     query\n     |> Ash.Query.filter(representative_id in ^rep_ids)\n     |> Ash.Query.filter(priority > representative.priority_threshold)\n     |> Ash.read!(Ash.Context.to_opts(context))\n     # Return the items grouped by the primary key of the source, i.e representative.id => [...tickets above threshold]\n     |> Enum.group_by(& &1.representative_id)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Strict Loading in Ash Manual Relationships\nDESCRIPTION: Demonstrates how to handle strict loading scenarios in manual relationships, ensuring required attributes are selected.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold do\n  use Ash.Resource.ManualRelationship\n  require Ash.Query\n\n  def load(records, _opts, %{query: query, actor: actor, authorize?: authorize?}) do\n    rep_ids = Enum.map(records, & &1.id)\n\n    {:ok,\n     query\n     |> Ash.Query.ensure_selected([:representative_id])\n     |> Ash.Query.filter(representative_id in ^rep_ids)\n     |> Ash.Query.filter(priority > representative.priority_threshold)\n     |> Helpdesk.Support.read!(actor: actor, authorize?: authorize?)\n     |> Enum.group_by(& &1.representative_id)}\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Examples of Specifying Inputs for Ash Update Actions\nDESCRIPTION: Two examples demonstrating different syntax options for specifying inputs to an Ash update action, using both map and keyword list formats.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_60\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging for Policy Breakdowns in Ash Elixir\nDESCRIPTION: Demonstrates how to set up logging for policy breakdowns in Ash, including both failed and successful authorizations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_26\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :policies, log_policy_breakdowns: :error\n\nconfig :ash, :policies, log_successful_policy_breakdowns: :error\n```\n\n----------------------------------------\n\nTITLE: Expressions with Calculation Arguments (New Format)\nDESCRIPTION: Example showing changes to expressions when passing arguments to calculations. In Ash 3.0, keyword list arguments need to be pinned with ^ when referencing template functions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nfull_name(separator: ^arg(:separator))\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Aggregate in Elixir\nDESCRIPTION: Function to define a custom aggregate that requires data layer specific implementation callbacks.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_86\n\nLANGUAGE: elixir\nCODE:\n```\ncustom name, relationship_path, type\n```\n\n----------------------------------------\n\nTITLE: Validation Example with Module\nDESCRIPTION: Example of defining a validation using a module with options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_65\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate {Mod, [foo: :bar]}\n```\n\n----------------------------------------\n\nTITLE: Transform Examples in Ash Custom Input\nDESCRIPTION: Examples of transform blocks showing how to convert values using different transformation functions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_49\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :artist_id\n  using &(&1.id)\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :points\n  using &try_parse_integer/1\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Primary Key in Ash Resource (Elixir)\nDESCRIPTION: Example of declaring an auto-generated integer primary key in an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ninteger_primary_key :id\n```\n\n----------------------------------------\n\nTITLE: External Data Source Handling in Ash Relationships\nDESCRIPTION: Shows how to handle data from external sources in manual relationships and apply queries in memory.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_20\n\nLANGUAGE: elixir\nCODE:\n```\ndef load(records, _opts, %{query: query, ..}) do\n  # fetch the data from the other source, which is capable of sorting\n  data = get_other_data(data, query.sort)\n\n  query\n  # unset the sort since we already applied that\n  |> Ash.Query.unset([:sort])\n  # apply the query in memory (filtering, distinct, limit, offset)\n  |> Ash.Query.apply_to(data)\nend\n```\n\n----------------------------------------\n\nTITLE: Input Template Examples for Action Configuration\nDESCRIPTION: Shows different ways to specify inputs for an action including using results from previous steps and direct inputs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_42\n\nLANGUAGE: elixir\nCODE:\n```\ninputs %{\n  author: result(:get_user),\n  title: input(:title),\n  body: input(:body)\n}\n```\n\nLANGUAGE: elixir\nCODE:\n```\ninputs(author: result(:get_user))\n```\n\n----------------------------------------\n\nTITLE: Setting Tenant for Bulk Create Operation\nDESCRIPTION: Specifies the tenant for a bulk create action with optional tenant value transformation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\ntenant source\n```\n\n----------------------------------------\n\nTITLE: Simplified Artist Follow Interface Using Custom Type in Elixir\nDESCRIPTION: Demonstrates a simplified version of the artist follow interface using the custom ArtistOrId type.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefine :follow_artist do\n  action :follow\n  args [:artist]\n\n  custom_input :artist, MyApp.Types.ArtistOrId do\n    transform do\n      to :artist_id\n      using &MyApp.Types.ArtistOrId.to_artist_id/1\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating an Always-Run Policy in Ash Framework (Elixir)\nDESCRIPTION: Shows how to create a policy that always runs using the always() check. This is useful for policies that should be applied to all requests regardless of other conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\npolicy always() do\n...\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Input in Ash Calculation\nDESCRIPTION: Basic syntax for defining a custom input with name and type parameters in an Ash calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\ncustom_input name, type\n```\n\n----------------------------------------\n\nTITLE: Setting Actor in Load Operation\nDESCRIPTION: Specifies the actor to be used during a load operation. The actor is the entity performing the action, typically used for authorization purposes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_32\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Defining Multitenancy Configuration Options in Markdown Table\nDESCRIPTION: A markdown table that outlines the configuration options for multitenancy in the Ash project. It includes options for strategy, attribute, global access, and attribute parsing function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_97\n\nLANGUAGE: markdown\nCODE:\n```\n| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`strategy`](#multitenancy-strategy){: #multitenancy-strategy } | `:context \\| :attribute` | `:context` | Determine if multitenancy is performed with attribute filters or using data layer features. |\n| [`attribute`](#multitenancy-attribute){: #multitenancy-attribute } | `atom` |  | If using the `attribute` strategy, the attribute to use, e.g `org_id` |\n| [`global?`](#multitenancy-global?){: #multitenancy-global? } | `boolean` | `false` | Whether or not the data may be accessed without setting a tenant. For example, with attribute multitenancy, this allows accessing without filtering by the tenant attribute. |\n| [`parse_attribute`](#multitenancy-parse_attribute){: #multitenancy-parse_attribute } | `mfa` | `{Ash.Resource.Dsl, :identity, []}` | An mfa ({module, function, args}) pointing to a function that takes a tenant and returns the attribute value |\n```\n\n----------------------------------------\n\nTITLE: Resource Configuration in Ash\nDESCRIPTION: Example of basic resource configuration including description and base filter settings.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_51\n\nLANGUAGE: elixir\nCODE:\n```\nresource do\n  description \"A description of this resource\"\n  base_filter [is_nil: :deleted_at]\nend\n```\n\n----------------------------------------\n\nTITLE: Requiring Original Data Access in Custom Checks and Notifiers for Ash 3.0\nDESCRIPTION: To maintain access to original data in custom checks and notifiers, you need to implement a requires_original_data?/2 function. This snippet demonstrates how to add this function for both custom checks and notifiers.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\n# in custom checks\ndef requires_original_data?(_authorizer, _opts), do: true\n\n# in notifiers\ndef requires_original_data?(_resource, _action), do: true\n```\n\n----------------------------------------\n\nTITLE: Configuring PubSub Notifier in Ash Resource\nDESCRIPTION: Example of configuring the PubSub notifier in an Ash resource to publish update events. The configuration connects to a Phoenix endpoint and publishes to topics with a primary key.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.User do\n  use Ash.Resource,\n    # ...\n    notifiers: [Ash.Notifier.PubSub]\n\n  # ...\n\n  pub_sub do\n    module MyAppWeb.Endpoint\n\n    prefix \"user\"\n    publish :update, [\"updated\", :_pkey]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata on Destroy Actions in Ash Resources\nDESCRIPTION: Defines metadata fields for destroy actions. Metadata represents special attributes that must be set in custom change after_action hooks via Ash.Resource.put_metadata/3.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_44\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata name, type\n```\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata :api_token, :string, allow_nil?: false\n```\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata :operation_id, :string, allow_nil?: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Reactor Read Actor in Elixir\nDESCRIPTION: Specifies the action actor for reactor read operations. Accepts a source parameter that can be various Reactor Template types.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_44\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Example of Argument Declaration in Ash\nDESCRIPTION: Shows how to declare a string password confirmation argument that can be used in validation or processing logic.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_37\n\nLANGUAGE: elixir\nCODE:\n```\nargument :password_confirmation, :string\n```\n\n----------------------------------------\n\nTITLE: Where Condition Example\nDESCRIPTION: Shows how to use a where condition to conditionally execute a step based on a predicate.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Applying Filter to has_one Relationship in Elixir\nDESCRIPTION: Examples of applying filters to a has_one relationship in an Ash resource. It shows how to use expressions to filter relationships based on specific conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nfilter expr(first_name == \"fred\")\nfilter expr(last_name == \"weasley\" and magician == true)\n```\n\n----------------------------------------\n\nTITLE: Adding Load Statements to Update Operations in Ash Reactor\nDESCRIPTION: A nested DSL component for adding Ash load statements to update actions, allowing related data to be loaded as part of the operation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_55\n\nLANGUAGE: elixir\nCODE:\n```\nload source\n```\n\n----------------------------------------\n\nTITLE: Example of Using 'guard' for Conditional Execution with Caching\nDESCRIPTION: An advanced example showing how to use the guard directive to implement a caching strategy for file reading, bypassing the actual read if the content is already cached.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_59\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring No-Attributes Relationship in Elixir Ash\nDESCRIPTION: Demonstrates how to create a custom relationship without attribute matches using no_attributes? flag to filter higher priority tickets.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nhas_many :higher_priority_tickets, __MODULE__ do\n  no_attributes? true\n  # parent/1 in this case puts the expression on this current resource\n  # so this is \"tickets with priority higher than this ticket\"\n  filter expr(priority > parent(priority))\nend\n```\n\n----------------------------------------\n\nTITLE: Global Changes Configuration in Elixir\nDESCRIPTION: Example of configuring global changes that apply to specific action types.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/changes.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nchanges do\n  change {Slugify, attribute: :name} do\n    on [:create]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Complete Resource PubSub Configuration Example\nDESCRIPTION: Full example of PubSub configuration for an Ash resource with multiple publications, showing how to configure different events with custom event names and actions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\npub_sub do\n  module MyEndpoint\n  prefix \"post\"\n\n  publish :destroy, [\"destroyed\", :id]\n  publish :update, [\"updated\", :name], event: \"name_change\"\n  publish_all :create, \"created\"\nend\n\n```\n\n----------------------------------------\n\nTITLE: Filtering on Aggregates in Ash Queries in Elixir\nDESCRIPTION: This example demonstrates how to filter users based on an aggregate value, specifically users with more than 10 posts.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/aggregates.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nrequire Ash.Query\n\nUser\n|> Ash.Query.filter(count_of_posts > 10)\n|> Ash.read!()\n```\n\n----------------------------------------\n\nTITLE: Declaring Update Timestamp in Ash Resource (Elixir)\nDESCRIPTION: Example of declaring an update timestamp attribute in an Ash resource, which automatically updates with the current time when a record is modified.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nupdate_timestamp :updated_at\n```\n\n----------------------------------------\n\nTITLE: Updating the Transformer to Use Configuration\nDESCRIPTION: Updates the transformer to check the extension configuration before adding timestamps, making the feature opt-out.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n  def transform(dsl_state) do\n    # Introspection functions can take a `dsl_state` *or* a module\n    if MyApp.Extensions.Base.Info.base_timestamps?(dsl_state) do\n      dsl_state\n      |> Ash.Resource.Builder.add_new_create_timestamp(:inserted_at)\n      |> Ash.Resource.Builder.add_new_update_timestamp(:updated_at)\n    else\n      {:ok, dsl_state}\n    end\n  end\n```\n\n----------------------------------------\n\nTITLE: Policy with Condition Inside Block in Ash\nDESCRIPTION: Shows an alternative syntax for defining policies where the condition is placed inside the policy block, which can make long condition lists more readable.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  policy do\n    condition always()\n    authorize_if always()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Grouping Policies with policy_group in Ash.Policy.Authorizer\nDESCRIPTION: Demonstrates how to use policy_group to group policies together based on a shared condition, and shows the equivalent flattened policies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\npolicy_group condition1 do\npolicy condition2 do\n...\nend\n\npolicy condition3 do\n...\nend\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\npolicy [condition1, condition2] do\n...\nend\n\npolicy [condition1, condition3] do\n...\nend\n```\n\n----------------------------------------\n\nTITLE: Preparations DSL Example\nDESCRIPTION: Example of using the preparations DSL to define multiple query preparations for a resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_61\n\nLANGUAGE: elixir\nCODE:\n```\npreparations do\n  prepare {Mod, [foo: :bar]}\n  prepare set_context(%{some: :context})\nend\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Ordering with 'wait_for' in Reactor DSL\nDESCRIPTION: A DSL component that establishes execution order by making a step wait for another named step to complete. It's implemented by creating an implicit argument that references the result of the dependency.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_49\n\nLANGUAGE: elixir\nCODE:\n```\nwait_for names\n```\n\n----------------------------------------\n\nTITLE: Using Join Filter in Ash Aggregate\nDESCRIPTION: Declares a join filter on an aggregate to filter based on a related resource. This allows applying conditions to relationships in the aggregate's path.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_70\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter [:comments, :author], expr(active == true)\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata for Update Action (Elixir)\nDESCRIPTION: Syntax for adding metadata to an update action in Ash framework. Metadata is a special kind of attribute that must be set in a custom change after_action hook.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_35\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata name, type\n```\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata :api_token, :string, allow_nil?: false\n```\n\nLANGUAGE: elixir\nCODE:\n```\nmetadata :operation_id, :string, allow_nil?: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Complex Topic Templates with Multiple Options\nDESCRIPTION: Advanced topic template configuration that produces multiple topic variations by using lists of alternatives. This creates topics with different combinations of tenant ID and resource ID.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\npublish :updated, [[:team_id, :_tenant], \"updated\", [:id, nil]]\n```\n\n----------------------------------------\n\nTITLE: Representative Resource Definition\nDESCRIPTION: Defines a Representative resource with attributes and relationships using Ash Framework.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule Helpdesk.Support.Representative do\n  use Ash.Resource,\n    domain: Helpdesk.Support,\n    data_layer: Ash.DataLayer.Ets\n\n  actions do\n    defaults [:read]\n\n    create :create do\n      accept [:name]\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n    attribute :name, :string do\n      public? true\n    end\n  end\n\n  relationships do\n    has_many :tickets, Helpdesk.Support.Ticket\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: SQL Equivalent of Fully Atomic Update (SQL)\nDESCRIPTION: Shows the SQL equivalent of the fully atomic update action, demonstrating how it would be executed in a SQL database.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE table\n  SET name = name || $1,\n  slug = CASE\n    WHEN name = name || $1 THEN\n      slug\n    ELSE\n      slugify(name || $1)\n  END\nWHERE id = $2\n```\n\n----------------------------------------\n\nTITLE: Using Custom Preparation in Resource\nDESCRIPTION: Example of how to use a custom preparation module within a resource definition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/preparations.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nprepare {MyApp.Preparations.Top5, attribute: :foo}\n```\n\n----------------------------------------\n\nTITLE: Returning Resource Instances from Generic Actions\nDESCRIPTION: Shows how to define generic actions that return instances of the resource itself, using the :struct type with instance_of constraint.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\naction :get, :struct do\n  constraints instance_of: __MODULE__\n\n  run # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Forbid Unless Policy Check in Elixir Ash Framework\nDESCRIPTION: Implements a conditional forbid policy that denies access unless the specified check evaluates to true. Accepts a check parameter that can be any value or module implementing Ash.Policy.Check.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless check\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_unless actor_attribute_matches_record(:group, :group)\n```\n\n----------------------------------------\n\nTITLE: Guard Implementation Example\nDESCRIPTION: Demonstrates implementing a guard for conditional step execution with file caching.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file_via_cache do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  guard fn %{path: path}, %{cache: cache} ->\n    case Cache.get(cache, path) do\n      {:ok, content} -> {:halt, {:ok, content}}\n      _ -> :cont\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using Where Predicates in Ash Reactor\nDESCRIPTION: Demonstrates use of where predicate for conditional step execution. A simpler alternative to guard that takes a predicate function returning a boolean.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Private Field Handling in Ash Elixir\nDESCRIPTION: Shows how to configure the handling of private fields in internal functions using field policies in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_23\n\nLANGUAGE: elixir\nCODE:\n```\nfield_policies do\n  private_fields :include\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Global Validations in Ash\nDESCRIPTION: Example of defining global validations that apply to multiple action types with conditional execution.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nvalidations do\n  validate present([:foo, :bar], at_least: 1) do\n    on [:create, :update]\n    where present(:baz)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: After Action Hook Format (New)\nDESCRIPTION: Updated format for defining after_action hooks in Ash 3.0, which now requires a third parameter to accept the context.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nchange after_action(fn changeset, result, context -> ... end)\n```\n\n----------------------------------------\n\nTITLE: Join Filter for List Aggregate in Ash Framework\nDESCRIPTION: Declares a join filter specifically for a list aggregate, allowing more complex filtering on relationship paths used in the list collection.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_80\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter relationship_path, filter\n```\n\n----------------------------------------\n\nTITLE: SQL Equivalent of Atomic Score Increment (SQL)\nDESCRIPTION: Illustrates the SQL equivalent of the atomic score increment update action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_9\n\nLANGUAGE: sql\nCODE:\n```\n\"UPDATE table SET score = score + 1 WHERE id = post_id\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Domain for Embedded Resources in Elixir\nDESCRIPTION: Demonstrates how to specify a domain for embedded resources using the domain constraint in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\nattribute :bio, MyApp.Bio do\n  constraints domain: MyApp.SomeDomain\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Domain for Single Domain Resources in Elixir\nDESCRIPTION: Shows how to specify a domain for resources that are only used with a single domain in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nuse Ash.Resource,\n  domain: MyApp.MyDomain\n```\n\n----------------------------------------\n\nTITLE: Setting Context in Load Operation\nDESCRIPTION: Defines a map to be merged into the action's context during a load operation. This allows for passing additional contextual information to the operation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_33\n\nLANGUAGE: elixir\nCODE:\n```\ncontext context\n```\n\n----------------------------------------\n\nTITLE: Passing Expressions to Calculations Arguments\nDESCRIPTION: Updated syntax for passing expressions to calculation arguments in Ash 3.0. The expr wrapper is no longer needed when expression arguments are allowed.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nfull_name(separator: sep_1 <> sep_2)\n```\n\n----------------------------------------\n\nTITLE: Adding Where Clause to Bulk Create Operation in Elixir\nDESCRIPTION: Specifies a condition for executing the surrounding step in the bulk create operation. It's a simpler version of the guard clause, using a predicate function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nwhere predicate\n```\n\n----------------------------------------\n\nTITLE: Filter Examples for Belongs To Relationships\nDESCRIPTION: Examples demonstrating filter expressions for belongs_to relationships, showing both single condition and multiple conditions combined with AND.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\nfilter expr(first_name == \"fred\")\nfilter expr(last_name == \"weasley\" and magician == true)\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Expressions in Ash\nDESCRIPTION: Demonstrates how to configure custom expressions in Ash. This involves adding the custom expression module to the Ash configuration and recompiling the dependency.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/reference/expressions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :custom_expressions, [\n  MyApp.CustomExpression\n]\n```\n\n----------------------------------------\n\nTITLE: After Action Hook Format (Old)\nDESCRIPTION: Previous format for defining after_action hooks in Ash 2.0, which accepted a function with two parameters: changeset and result.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nchange after_action(fn changeset, result -> ... end)\n```\n\n----------------------------------------\n\nTITLE: Running an Ash.Reactor as a Generic Action in Ash\nDESCRIPTION: Shows how to use an Ash.Reactor module as the implementation for a generic Ash action. This demonstrates the integration between Ash actions and Reactor workflows.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/reactor.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\naction :run_reactor, :struct do\n  constraints instance_of: MyBlog.Post\n\n  argument :blog_title, :string, allow_nil?: false\n  argument :blog_body, :string, allow_nil?: false\n  argument :author_email, :ci_string, allow_nil?: false\n\n  run MyBlog.CreatePostReactor\nend\n```\n\n----------------------------------------\n\nTITLE: Returning Destroyed Records in Ash Framework\nDESCRIPTION: Demonstrates how to use the return_destroyed? option to get back the destroyed record instead of just an :ok atom. Includes examples of the different return values.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n# when a resource is passed, or a query w/ no action, the primary destroy action is used.\nticket = Ash.get!(Ticket, 1)\nAsh.destroy!(ticket)\n# => :ok\nticket = Ash.get!(Ticket, 2)\nAsh.destroy!(ticket, return_destroyed?: true)\n# => {:ok, %Ticket{}}\n```\n\n----------------------------------------\n\nTITLE: Manual Struct Update for Embedded Resource\nDESCRIPTION: Shows how to manually update an embedded resource using struct instances without validation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_update(user, :update, %{profile: %MyApp.Profile{first_name: \"first_name\", last_name: \"last_name\"}})\n```\n\n----------------------------------------\n\nTITLE: Transform Block with Artist ID Example\nDESCRIPTION: Example of a transform block that converts an artist object to its ID.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :artist_id\n  using &(&1.id)\nend\n```\n\n----------------------------------------\n\nTITLE: Transforming Ash Resource Input\nDESCRIPTION: Specifies a transformation for a custom input. This allows modifying the input value before it is used in the action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :artist_id\n  using &(&1.id)\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :points\n  using &try_parse_integer/1\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Updates for Module Changes in Ash 3.0\nDESCRIPTION: To make module changes atomic in Ash 3.0, you need to implement the atomic/3 callback instead of change/3. This snippet demonstrates how to create an atomic update for incrementing a value.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\ndef atomic(changeset, _, _) do\n  {:atomic, %{value: expr(value + 1)}}\nend\n```\n\n----------------------------------------\n\nTITLE: Domain Authorization Configuration\nDESCRIPTION: Example demonstrating how to set up authorization rules for a domain.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nauthorization do\n  authorize :always\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Actor Source in Ash Reactor Read Operation\nDESCRIPTION: Defines an actor source for a read operation in the Ash Reactor framework. Allows specifying who is performing the action with an optional transform function.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_39\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Setting Actor for Update Operations in Ash Reactor\nDESCRIPTION: A nested DSL component for specifying the actor to be used when performing an update action on a resource. Supports optional transformation of the actor value.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_51\n\nLANGUAGE: elixir\nCODE:\n```\nactor source\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Accept for Actions in Elixir\nDESCRIPTION: Demonstrates how to configure the default_accept option for actions in Ash resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nactions do\n  default_accept :*\n  ...\nend\n```\n\n----------------------------------------\n\nTITLE: Domain Execution Configuration\nDESCRIPTION: Example showing how to configure execution settings for a domain with a timeout.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\nexecution do\n  timeout :timer.seconds(30)\nend\n```\n\n----------------------------------------\n\nTITLE: Calling Destroy Actions in Ash Framework\nDESCRIPTION: Shows the basic pattern for calling a destroy action on a record. The pattern involves creating a changeset for the destroy action and then passing it to Ash.destroy!().\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/destroy-actions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nrecord\n|> Ash.Changeset.for_destroy(:action_name, %{argument: :value}, ...opts)\n|> Ash.destroy!()\n```\n\n----------------------------------------\n\nTITLE: Stream Usage Warning Example\nDESCRIPTION: Demonstrates potential issues with stream evaluation in bulk creates.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/create-actions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n[input1, input2, ...] # has 300 things in it\n|> Ash.bulk_create(\n  Resource,\n  :action,\n  return_stream?: true,\n  return_records?: true,\n  batch_size: 100 #  default is 100\n)\n|> Enum.take(150) # stream has 300, but we only take 150\n```\n\n----------------------------------------\n\nTITLE: Defining Read Policy for Ash Resource (Elixir)\nDESCRIPTION: This snippet shows a policy definition for an Ash resource that filters out deactivated authors during read operations.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:read) do\n  access_type :filter # This is the default access type. It is here for example.\n  authorize_if expr(active == false)\nend\n```\n\n----------------------------------------\n\nTITLE: Change Example with Custom Module\nDESCRIPTION: Example of defining a change using a custom module with an argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_59\n\nLANGUAGE: elixir\nCODE:\n```\nchange {MyCustomChange, :foo}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Error in Elixir using Splode\nDESCRIPTION: Demonstrates how to create a custom error using Splode.Error in Elixir, replacing the previous combination of def_ash_error and defimpl Ash.ErrorKind.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyCustomError do\n  use Splode.Error, class: :invalid, fields: [:foo, :bar]\n\n  def message(error) do\n    \"Message: #{error.foo} - #{error.bar}\"\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Transform Block with Integer Parsing\nDESCRIPTION: Example of a transform block that attempts to parse an input as an integer.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\ntransform do\n  to :points\n  using &try_parse_integer/1\nend\n```\n\n----------------------------------------\n\nTITLE: Where Predicate Example in Reactor\nDESCRIPTION: Example demonstrating the use of where predicate for conditional step execution based on file existence.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_28\n\nLANGUAGE: elixir\nCODE:\n```\nstep :read_file do\n  argument :path, input(:path)\n  run &File.read(&1.path)\n  where &File.exists?(&1.path)\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Context for Bulk Update in Elixir\nDESCRIPTION: Specifies a context map to be merged into the action's context for a bulk update operation. The 'context' argument is the map to be merged, and an optional 'transform' function can modify the context before it's passed to the action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ncontext context\n```\n\n----------------------------------------\n\nTITLE: Configuring default_actions_require_atomic in Ash\nDESCRIPTION: Controls whether default generated actions require atomic operations. Setting to true improves safety by making default actions require atomic operations, helping identify actions that cannot safely run asynchronously.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, default_actions_require_atomic?: true\n```\n\n----------------------------------------\n\nTITLE: Configuring ETS Data Layer in Elixir\nDESCRIPTION: This snippet demonstrates how to configure the ETS data layer for an Ash resource. It sets the 'private?' option to true, which is commonly used in testing scenarios.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.DataLayer.Ets.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nets do\n  # Used in testing\n  private? true\nend\n```\n\n----------------------------------------\n\nTITLE: Managing Relationships with Transactions in Ash\nDESCRIPTION: Shows a complex domain call that involves multiple database operations that would be executed in a transaction, with notifications sent after the transaction closes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nPost\n|> Ash.Changeset.for_update(:update, %{})\n|> Ash.Changeset.manage_relationship(:related_posts, [1, 2, 3], type: :append)\n|> Ash.Changeset.manage_relationship(:related_posts, [4, 5], type: :remove)\n|> Ash.Changeset.manage_relationship(:comments, [10], type: :append)\n|> Ash.update!()\n```\n\n----------------------------------------\n\nTITLE: Configuring Formatter for Ash\nDESCRIPTION: Elixir code snippet showing how to configure the formatter to include Ash formatting rules.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n[\n  # ...\n  import_deps: [..., :ash],\n  # ...\n]\n```\n\n----------------------------------------\n\nTITLE: Ash Step with Function Implementation\nDESCRIPTION: Shows how to create an Ash step with an inline function implementation for post creation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nash_step :create_post do\n  argument :title, input(:title)\n\n  run fn %{title: title}, _ ->\n    MyApp.Post.create(title, return_notifications?: true)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Including Simple Notifiers in a Resource\nDESCRIPTION: Shows how to include a notifier that is not an extension to run on all actions, avoiding unnecessary compile-time dependencies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/notifiers.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyResource do\n  use Ash.Resource,\n    simple_notifiers: [ExampleNotifier]\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Mnesia Table in Ash Resource\nDESCRIPTION: Example of configuring a custom table name in the Mnesia data layer section of an Ash resource. This shows how to define a custom table name instead of using the default resource name.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.DataLayer.Mnesia.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nmnesia do\n  table :custom_table\nend\n\n```\n\n----------------------------------------\n\nTITLE: Join Filter for Sum Aggregate in Ash Framework\nDESCRIPTION: Declares a join filter specifically for a sum aggregate. This allows more complex filtering on relationships used in the aggregate calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_77\n\nLANGUAGE: elixir\nCODE:\n```\njoin_filter relationship_path, filter\n```\n\n----------------------------------------\n\nTITLE: Configuring Default belongs_to Attribute Type\nDESCRIPTION: Example showing how to set a global default type for belongs_to relationships in the application configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :default_belongs_to_type, :integer\n```\n\n----------------------------------------\n\nTITLE: Equivalent Function Without Generic Action\nDESCRIPTION: Shows how the same functionality could be implemented as a regular Elixir function instead of a generic action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/generic-actions.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndef say_hello(name), do: \"Hello: #{name}\"\n```\n\n----------------------------------------\n\nTITLE: Max Aggregate Definition in Ash Framework\nDESCRIPTION: Declares a named max aggregate that finds the maximum value of a field across related records. Supports filtering related records but not sorting, as sorting wouldn't affect the maximum value calculation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_81\n\nLANGUAGE: elixir\nCODE:\n```\nmax name, relationship_path, field\n```\n\n----------------------------------------\n\nTITLE: Creating Project Structure for Ash Domain\nDESCRIPTION: Bash commands to create the necessary directories and files for an Ash domain and resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p lib/helpdesk/support && touch $_/ticket.ex\ntouch lib/helpdesk/support.ex\n```\n\n----------------------------------------\n\nTITLE: Creating Topic Templates with User ID\nDESCRIPTION: Example of a topic template that includes the user_id attribute in the topic. This allows for more specific event routing based on the resource data.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nprefix \"user\"\n\npublish :create, [\"created\", :user_id]\n```\n\n----------------------------------------\n\nTITLE: Configuring Formatter DSL Imports in Elixir\nDESCRIPTION: Configuration for .formatter.exs to properly handle Ash DSL formatting by importing dependencies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/development-utilities.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n[\n  # ...\n  import_deps: [..., :ash],\n  # ...\n]\n```\n\n----------------------------------------\n\nTITLE: Making a Configurable Extension with DSL Sections\nDESCRIPTION: Extends the base extension to include a configurable section that allows resources to opt out of automatic timestamp generation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/writing-extensions.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.Extensions.Base do\n  @base %Spark.Dsl.Section{\n    name: :base,\n    describe: \"\"\"\n    Configure the behavior of our base extension.\n    \"\"\",\n    examples: [\n      \"\"\"\n      base do\n        timestamps? false\n      end\n      \"\"\"\n    ],\n    schema: [\n      timestamps?: [\n        type: :boolean,\n        doc: \"Set to false to skip adding timestamps\",\n        default: true\n      ]\n    ]\n  }\n\n\n\n  use Spark.Dsl.Extension,\n    transformers: [MyApp.Extensions.Base.AddTimestamps],\n    sections: [@base]\nend\n\ndefmodule MyApp.Extensions.Base.Info do\n  use Spark.InfoGenerator, extension: MyApp.Extensions.Base, sections: [:base]\n\n  # This will define `base_timestamps?/1`.\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Domain for Multi-Domain Resources in Elixir\nDESCRIPTION: Shows how to include the domain option when constructing a changeset for multi-domain resources in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_12\n\nLANGUAGE: elixir\nCODE:\n```\nMyResource\n|> Ash.Changeset.for_create(:create, input, domain: MyApp.MyDomain)\n```\n\n----------------------------------------\n\nTITLE: Data Loading Example with Value Reuse\nDESCRIPTION: Shows how attribute value reuse behavior changed between versions when loading data.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_28\n\nLANGUAGE: elixir\nCODE:\n```\nuser = %User{first_name: \"fred\", last_name: \"weasley\"}\n\nAsh.update!(user, first_name: \"george\")\n\nuser |> Ash.load!(:full_name)\n# in 2.0 -> fred weasley\n# in 3.0 -> george weasley\n```\n\n----------------------------------------\n\nTITLE: Preparation Example with Sorting\nDESCRIPTION: Example of defining a preparation that adds default sorting to queries.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_62\n\nLANGUAGE: elixir\nCODE:\n```\nprepare build(sort: [:foo, :bar])\n\n```\n\n----------------------------------------\n\nTITLE: Defining Required Calculation Argument in Elixir\nDESCRIPTION: Defines a retries argument of type integer that cannot be nil. This ensures the calculation always receives a valid integer value for this argument.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_95\n\nLANGUAGE: elixir\nCODE:\n```\nargument :retries, :integer do\n  allow_nil? false\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Ash.Policy.Authorizer to a Resource in Elixir\nDESCRIPTION: Demonstrates how to add the Ash.Policy.Authorizer to the list of authorizers for an Ash resource.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nuse Ash.Resource,\n  ...,\n  authorizers: [\n    Ash.Policy.Authorizer\n  ]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Ash Project with Phoenix\nDESCRIPTION: Commands to install Phoenix archive and create a new project with both Phoenix and Ash frameworks.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# install the archive\nmix archive.install hex phx_new\n\n# use the `--with` flag to generate the project with phx.new and add Ash\nmix igniter.new helpdesk --install ash,ash_phoenix --with phx.new && cd helpdesk\n```\n\n----------------------------------------\n\nTITLE: Configuring Resources in an Ash Domain\nDESCRIPTION: Example showing how to specify resources within an Ash domain after the Ash.Registry removal. Resources are now directly declared in the domain definition.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nresources do\n  resource Resource1\n  resource Resource2\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a New Ash Project with Igniter\nDESCRIPTION: Command to create a new project named 'helpdesk' with Ash installed using the Igniter generator.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nmix igniter.new helpdesk --install ash && cd helpdesk\n```\n\n----------------------------------------\n\nTITLE: Declaring Validation for Create Action in Ash Resource\nDESCRIPTION: Declares a validation to be applied to the changeset. It can use built-in validations from Ash.Resource.Validation.Builtins or custom validations implementing Ash.Resource.Validation behavior.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_27\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate validation\n```\n\n----------------------------------------\n\nTITLE: Setting Context for Bulk Create Operation in Elixir\nDESCRIPTION: Specifies a map to be merged into the action's context for the bulk create operation. An optional transformation function can be applied to modify the context.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ncontext context\n```\n\n----------------------------------------\n\nTITLE: Configuring no_filter_static_forbidden_reads in Ash policies\nDESCRIPTION: Controls whether read actions with policies that would statically fail return forbidden errors or filter to empty results. Setting to false makes behavior more consistent by always filtering results.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, policies: [no_filter_static_forbidden_reads?: false]\n```\n\n----------------------------------------\n\nTITLE: Resource Type Definition Example\nDESCRIPTION: Demonstrates how to properly define a resource type with constraints in Ash 3.0.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_29\n\nLANGUAGE: elixir\nCODE:\n```\ncalculation :random_post, :struct do\n  constraints instance_of: Post\n  calculate Calculations.RandomPost\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing Ticket Creation Action\nDESCRIPTION: Elixir code showing how to replace the generic create action with a more specific 'open' action that accepts a subject.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_17\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/helpdesk/support/ticket.ex\n\nactions do\n  ...\n  create :open do\n    accept [:subject]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Using forbid_if in Ash.Policy.Authorizer\nDESCRIPTION: Examples of using the forbid_if check in Ash.Policy.Authorizer to forbid requests based on specific conditions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if not_logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nforbid_if actor_attribute_matches_record(:group, :blacklisted_groups)\n```\n\n----------------------------------------\n\nTITLE: Adding Ash Dependencies to mix.exs\nDESCRIPTION: Elixir code snippet showing how to add Ash and PicoSAT dependencies to a project's mix.exs file.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\ndefp deps do\n  [\n    {:ash, \"~> 3.0\"},\n    {:picosat_elixir, \"~> 0.2\"}\n  ]\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Ash Test Configuration in Elixir\nDESCRIPTION: Essential configuration settings for testing Ash applications, including disabling async operations and ignoring missed notifications.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/testing.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# config/test.exs\nconfig :ash, :disable_async?, true\nconfig :ash, :missed_notifications, :ignore\n```\n\n----------------------------------------\n\nTITLE: Installing Igniter Archive for Ash Project Generation\nDESCRIPTION: Command to install the Igniter archive, which provides tools for generating new Ash projects.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmix archive.install hex igniter_new\n```\n\n----------------------------------------\n\nTITLE: Authorize Unless Policy Check in Elixir Ash Framework\nDESCRIPTION: Implements a conditional authorization policy that grants access unless the specified check evaluates to true. Accepts a check parameter that can be any value or module implementing Ash.Policy.Check.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless check\n```\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless not_logged_in()\n```\n\nLANGUAGE: elixir\nCODE:\n```\nauthorize_unless actor_attribute_matches_record(:group, :blacklisted_groups)\n```\n\n----------------------------------------\n\nTITLE: Argument Configuration Examples\nDESCRIPTION: Shows various ways to configure arguments in Ash steps, including input transformation and value handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nargument :name, input(:name)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :year, input(:date, [:year])\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user, result(:create_user)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :user_id, result(:create_user, [:id])\n```\n\nLANGUAGE: elixir\nCODE:\n```\nargument :three, value(3)\n```\n\n----------------------------------------\n\nTITLE: Configuring keep_read_action_loads_when_loading in Ash\nDESCRIPTION: Controls whether read action loads are applied when using Ash.load. Setting to false ensures only explicitly provided load statements are applied, preventing unexpected data loading.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, keep_read_action_loads_when_loading?: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Actions with Accept Lists in Elixir\nDESCRIPTION: Shows how to configure default actions with accept lists in Ash resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndefaults [:read, :destroy, create: :*, update: :*]\n```\n\n----------------------------------------\n\nTITLE: Loading Data in Bulk Create Operation\nDESCRIPTION: Adds an Ash load statement to the bulk create action with optional source transformation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nload source\n```\n\n----------------------------------------\n\nTITLE: Default Authorization Policy Definition\nDESCRIPTION: Shows how to define a default policy that allows all access when using field policies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Policy.Authorizer.md#2025-04-11_snippet_19\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\npolicy always() do\nauthorize_if always()\nend\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Required Hex Archives\nDESCRIPTION: These commands install the necessary hex archives (igniter_new and phx_new) for using Ash generators and creating new projects.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/generators.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nmix archive.install hex igniter_new\nmix archive.install hex phx_new\n```\n\n----------------------------------------\n\nTITLE: Minimal Ash Resource Formatter Configuration\nDESCRIPTION: Basic configuration for the Spark formatter to handle Ash Resources and Domains, including section ordering and parentheses removal.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/development-utilities.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :spark, :formatter,\n  remove_parens?: true,\n  \"Ash.Domain\": [],\n  \"Ash.Resource\": [\n    section_order: [\n      # any section not in this list is left where it is\n      # but these sections will always appear in this order in a resource\n      :actions,\n      :attributes,\n      :relationships,\n      :identities\n    ]\n  ]\n```\n\n----------------------------------------\n\nTITLE: Enabling Policy Breakdowns in Error Messages for Ash Elixir\nDESCRIPTION: Shows how to configure Ash to include policy breakdowns in error messages for debugging purposes.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_25\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :policies, show_policy_breakdowns?: true\n```\n\n----------------------------------------\n\nTITLE: Confirming Changes in Ash Framework\nDESCRIPTION: Code reference showing proper options usage in `confirm` change functionality.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nconfirm\n```\n\n----------------------------------------\n\nTITLE: Disabling Pagination for GraphQL Queries in Elixir\nDESCRIPTION: Shows how to disable pagination for GraphQL queries connected to default read actions in Ash.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_16\n\nLANGUAGE: elixir\nCODE:\n```\ngraphql do\n  queries do\n    list :list_things, :read, paginate_with: nil\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring belongs_to Attribute Options\nDESCRIPTION: Example demonstrating how to customize the belongs_to relationship attribute by specifying type and writability options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nbelongs_to :owner, MyApp.User do\n  attribute_type :integer\n  attribute_writable? false\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring show_keysets_for_all_actions in Ash\nDESCRIPTION: Controls whether keysets are computed for all actions. Setting to false ensures keysets are only computed when actually performing keyset pagination, improving performance.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, show_keysets_for_all_actions?: false\n```\n\n----------------------------------------\n\nTITLE: Merging select/3 and load/3 Callbacks for Calculations in Ash 3.0\nDESCRIPTION: In Ash 3.0, the select/3 callback is removed, and its functionality is merged into the load/3 callback. This snippet demonstrates how to combine the two callbacks into a single load/3 implementation.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_21\n\nLANGUAGE: elixir\nCODE:\n```\ndef load(_, _, _), do: [:some_attribute, :some_calculation, some_relationship: [:some_field1, :some_field2]]\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Domains\nDESCRIPTION: Elixir configuration code to register domains and set default Ash configuration options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\n# in config/config.exs\nimport Config\n\nconfig :helpdesk, :ash_domains, [Helpdesk.Support]\n\nconfig :ash,\n  include_embedded_source_by_default?: false,\n  default_page_type: :keyset\n\nconfig :ash, :policies,\n  no_filter_static_forbidden_reads?: false\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Read Action in Elixir\nDESCRIPTION: Demonstrates the new default configuration for read actions in Ash 3.0, including pagination options.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\nread :read do\n  primary? true\n  pagination [keyset?: true, offset?: true, countable: true, required?: false]\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling PubSub Debugging in Config\nDESCRIPTION: Configuration option to enable debug mode for PubSub events, which helps troubleshoot issues when events aren't being received as expected.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :pub_sub, debug?: true\n```\n\n----------------------------------------\n\nTITLE: Custom Resource Module Formatter Configuration\nDESCRIPTION: Extended configuration for custom resource modules that use Ash.Resource, including custom extensions and section ordering.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/development-utilities.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :spark, :formatter,\n  [\n    \"Ash.Resource\": [\n      section_order: [\n        :resource,\n        :identities,\n        :attributes,\n        :relationships,\n        ...\n      ]\n    ],\n    # If you use a different module than Ash.Resource\n    \"MyApp.Resource\": [\n      type: Ash.Resource,\n      # What extensions might be added by your base module\n      extensions: [...],\n      section_order: [\n        :resource,\n        :identities,\n        :attributes,\n        :relationships,\n        ...\n      ]\n    ]\n  ]\n```\n\n----------------------------------------\n\nTITLE: Setting Global Private Field Configuration in Ash Elixir\nDESCRIPTION: Demonstrates how to set a global configuration for handling private fields in Ash policies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :policies, private_fields: :include\n```\n\n----------------------------------------\n\nTITLE: Configuring include_embedded_source_by_default in Ash\nDESCRIPTION: Controls whether embedded resources include their source changeset by default. Setting to false improves memory usage with large sets of embedded resources, requiring explicit opt-in via constraints: [include_source?: true].\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, include_embedded_source_by_default?: false\n```\n\n----------------------------------------\n\nTITLE: Defining a has_one Relationship\nDESCRIPTION: Example showing how to define a has_one relationship from a User resource to a Profile resource. This establishes that each User has a single related Profile.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/relationships.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n# on MyApp.User\nhas_one :profile, MyApp.Profile\n```\n\n----------------------------------------\n\nTITLE: Setting Default Timeout in Ash Domain Module\nDESCRIPTION: This snippet shows how to set a default timeout of 30 seconds for all actions in an Ash domain module. The default timeout if not specified is infinity.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/timeouts.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nexecution do\n  timeout :timer.seconds(30) # the default is `:infinity`\nend\n```\n\n----------------------------------------\n\nTITLE: Disabling Async Operations for Ash Tests\nDESCRIPTION: Configuration to disable asynchronous task spawning in Ash, necessary for running transactional tests with AshPostgres.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/testing.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# config/test.exs\nconfig :ash, :disable_async?, true\n```\n\n----------------------------------------\n\nTITLE: Configuring Multitenancy for a Resource in Elixir\nDESCRIPTION: Sets up attribute-based multitenancy using organization_id with global access enabled. This configuration determines how the resource handles data isolation between tenants.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_96\n\nLANGUAGE: elixir\nCODE:\n```\nmultitenancy do\n  strategy :attribute\n  attribute :organization_id\n  global? true\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Domain Authorization to Use Old Behavior in Ash 3.0\nDESCRIPTION: To maintain the previous authorization behavior of :when_requested in Ash 3.0, you can configure your domain with the authorize :when_requested option. This snippet shows how to set this configuration.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_24\n\nLANGUAGE: elixir\nCODE:\n```\nauthorization do\n  authorize :when_requested\nend\n```\n\n----------------------------------------\n\nTITLE: Adding Builtin Changes for Lifecycle Hooks in Elixir\nDESCRIPTION: This code snippet adds builtin changes for lifecycle hooks in the Ash project. It's referenced as an improvement in version 2.6.20.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nAdd builtin changes for lifecycle hooks. (#523)\n```\n\n----------------------------------------\n\nTITLE: Configuring allow_forbidden_field_for_relationships_by_default in Ash\nDESCRIPTION: Configuration setting that changes how forbidden relationships are handled. When set to true, relationships producing a Forbidden error are populated with %Ash.ForbiddenField{} instead of failing the entire request.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, allow_forbidden_field_for_relationships_by_default?: true\n```\n\n----------------------------------------\n\nTITLE: Implementing Ash.ToTenant Protocol for Organization Resource\nDESCRIPTION: Implementation of the Ash.ToTenant protocol to automatically convert organization entities to appropriate tenant values. This handles both attribute and context-based multitenancy strategies.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/multitenancy.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n# in Organization resource\n\ndefimpl Ash.ToTenant do\n  def to_tenant(%{id: id}, resource) do\n    if Ash.Resource.Info.data_layer(resource) == AshPostgres.DataLayer\n      && Ash.Resource.Info.multitenancy_strategy(resource) == :context do\n      \"org_#{id}\"\n    else\n      id\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Display of Sensitive Attributes in Ash Development Environment\nDESCRIPTION: Configuration snippet to enable displaying sensitive attributes in their original form during development. This should only be used in development mode as it exposes sensitive data.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/sensitive-data.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, show_sensitive?: true\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry Format\nDESCRIPTION: Standard format used for documenting version changes, including version number, comparison link, and categorized changes under Features, Bug Fixes, and Improvements sections.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [v2.21.2](https://github.com/ash-project/ash/compare/v2.21.1...v2.21.2) (2024-03-26)\n\n### Bug Fixes:\n\n- don't try to reselect fields when pkeys are missing\n```\n\n----------------------------------------\n\nTITLE: Specifying Tenant for Reactor Update in Ash Framework\nDESCRIPTION: Sets the tenant for an Ash reactor update action. This allows specifying which tenant context should be used when performing the update action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Reactor.md#2025-04-11_snippet_61\n\nLANGUAGE: elixir\nCODE:\n```\ntenant source\n```\n\n----------------------------------------\n\nTITLE: Configuring bulk_actions_default_to_errors in Ash\nDESCRIPTION: Controls default error handling for bulk actions. Setting to true makes bulk actions default to return_errors?: true and stop_on_error?: true, providing more predictable error handling.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, bulk_actions_default_to_errors?: true\n```\n\n----------------------------------------\n\nTITLE: Non-Recommended Approach for External Data in LiveView\nDESCRIPTION: Shows an implementation that places business logic in the UI layer, which is not recommended. This example demonstrates fetching GitHub issue information directly in a LiveView event handler.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/project-structure.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"link_ticket\", %{\"issue_id\" => issue_id}, socket) do\n  issue_info = GithubApi.get_issue(issue_id)\n\n  MyApp.Support.update_ticket(socket.assigns.ticket_id, %{issue_info: %{\n    title: issue_info.title,\n    body: issue_info.body\n  }})\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Missed Notifications in Ash Tests\nDESCRIPTION: Configuration to ignore missed notifications during testing, preventing warning noise when running tests in transactions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/testing.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# config/test.exs\nconfig :ash, :missed_notifications, :ignore\n```\n\n----------------------------------------\n\nTITLE: Idiomatic Action Definition\nDESCRIPTION: Demonstrates the recommended way to implement complex query logic by defining it within a resource action.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/actions.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n# in the resource\n\ncode_interface do\n  define :top, args: [:user_id]\nend\n\nactions do\n  read :top do\n    argument :user_id, :uuid do\n      allow_nil? false\n    end\n\n    prepare build(limit: 10, sort: [opened_at: :desc])\n\n    filter expr(priority in [:medium, :high] and representative_id == ^arg(:user_id) and status == :open)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Expression Syntax Update\nDESCRIPTION: Example showing the new requirement for pinning keyword lists in expressions.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n# Old way\nfilter(expr(config: [key: \"value\"]))\n\n# New way\nconfig = [key: \"value\"]\nfilter(expr(config: ^config))\n```\n\n----------------------------------------\n\nTITLE: Markdown Redirect Notice\nDESCRIPTION: A simple markdown link redirecting users to the new documentation location for upgrade instructions.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/moved/upgrade.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Upgrade\n\nThis document has been [moved](upgrading-to-3-0.html).\n```\n\n----------------------------------------\n\nTITLE: Configuring read_action_after_action_hooks_in_order in Ash\nDESCRIPTION: Controls the execution order of after_action hooks in read actions. Setting to true ensures hooks are executed in the order they were added, consistent with changeset hooks.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, read_action_after_action_hooks_in_order?: true\n```\n\n----------------------------------------\n\nTITLE: Custom Input with Artist Transform Example\nDESCRIPTION: Example showing how to define a custom input for an artist struct with transformation to artist_id.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ncustom_input :artist, :struct do\n  transform to: :artist_id, using: &(&1.id)\n\n  constraints instance_of: Artist\nend\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Function Validations in Ash\nDESCRIPTION: Example of using an anonymous function for validation in Ash resources. This approach is convenient for prototyping but lacks atomicity.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/validations.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nvalidate fn changeset, _context ->\n  # put your code here\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Create Action Policy in Ash (Elixir)\nDESCRIPTION: This example illustrates the correct and incorrect ways to define policies for create actions in Ash, highlighting the limitation of referencing data being created.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_18\n\nLANGUAGE: elixir\nCODE:\n```\npolicy action_type(:create) do\n  # This check is fine, as we only reference the actor\n  authorize_if expr(^actor(:admin) == true)\n  # This check is not, because it contains a reference to a field\n  authorize_if expr(status == :active)\nend\n```\n\n----------------------------------------\n\nTITLE: Action Name Handling in Changeset\nDESCRIPTION: Implementation of action name passing in Ash.Changeset.for_action\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_action\n```\n\n----------------------------------------\n\nTITLE: Simple Always-Allow Policy in Ash\nDESCRIPTION: Implements a basic policy that always authorizes all actions. This is the most permissive policy possible and serves as a starting example.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/security/policies.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\npolicies do\n  policy always() do\n    authorize_if always()\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling Previous Value Notifications in PubSub Notifier for Ash 3.0\nDESCRIPTION: To retain the behavior of publishing both old and new values in PubSub notifications, you can add the previous_values?: true option to your publications. This snippet shows how to implement this feature.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_22\n\nLANGUAGE: elixir\nCODE:\n```\npublish :update, [\"user:updated\", :email], previous_values?: true\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Policy Behavior for Forbidden Reads in Elixir\nDESCRIPTION: Configuration for Ash policies to control the behavior of static forbidden reads. This configuration is recommended for all users and improves how aggregate policies are applied.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :policies, no_filter_static_forbidden_reads?: false\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Domain Usage Example\nDESCRIPTION: Example showing the transition from Ash.Api to Ash.Domain usage pattern.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n# Old way\nMyApi.create(record)\n\n# New way\nAsh.create(record)\n```\n\n----------------------------------------\n\nTITLE: Custom Input Transformation with Union Types in Elixir\nDESCRIPTION: Demonstrates how to define custom input transformations for code interfaces using union types.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/code-interfaces.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\ndefine :follow_artist do\n  action :follow\n\n  # `artist` (from the custom input below) is a positional argument to the function\n  args [:artist]\n\n  # make a custom input called `artist`, that is a union type\n  custom_input :artist, :union do\n    # allow passing either an artist or an artist_id\n    constraints types: [\n      artist: [type: :struct, constraints: [instance_of: Artist]],\n      artist_id: [type: :uuid]\n    ]\n\n    transform do\n      # Pass it to the action as `artist_id`\n      to :artist_id\n\n      # Extracting the value using this function\n      using fn\n        %Ash.Union{type: :artist, value: value} ->\n          value.id\n        %Ash.Union{type: :artist_id, value: value} ->\n          value\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Git Repository for Ash Project\nDESCRIPTION: Commands to initialize a Git repository for the newly created Ash project.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Run in your terminal\ngit init\ngit add -A\ngit commit -m \"first commit\"\ngit branch -M main\n```\n\n----------------------------------------\n\nTITLE: Dynamic References in Expressions (Old Format)\nDESCRIPTION: Previous syntax for building dynamic references in expressions in Ash 2.0, where the ref function did not require pinning.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nexpr(ref(^some_atom))\n```\n\n----------------------------------------\n\nTITLE: SQL Equivalent of Atomic Bulk Update (SQL)\nDESCRIPTION: Shows the SQL equivalent of the atomic bulk update operation, which updates all matching records in a single query.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/actions/update-actions.md#2025-04-11_snippet_13\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE tickets\nSET status = 'closed',\n    reason = 'Closing all open tickets.'\nWHERE status = 'open';\n```\n\n----------------------------------------\n\nTITLE: API Method Return Types\nDESCRIPTION: Implementation adding nil return type to API methods get/3, read_one/2 and read_one!/2\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\nget/3, read_one/2, read_one!/2\n```\n\n----------------------------------------\n\nTITLE: Refactoring Ash.set_* Functions in Elixir\nDESCRIPTION: Shows how to replace the deprecated Ash.set_* functions with explicit parameter passing in Ash.Changeset and Ash.Query calls.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.set_actor(current_user)\nAsh.set_tenant(current_tenant)\n\nAsh.Changeset.for_create!(..\nAsh.Query.for_read(..)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_create!(.., tenant: current_tenant, actor: current_user)\nAsh.Query.for_read(.., tenant: current_tenant, actor: current_user)\n```\n\n----------------------------------------\n\nTITLE: Adding Required Field Indicator in CSS\nDESCRIPTION: A CSS snippet that adds a red asterisk after elements with the class 'spark-required' to indicate required fields.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Resource.md#2025-04-11_snippet_98\n\nLANGUAGE: css\nCODE:\n```\n.spark-required::after { content: \"*\"; color: red !important; }\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Delimiter for Topics\nDESCRIPTION: Configuration to change the default delimiter (colon) used when generating topics, which is useful when working with message brokers like RabbitMQ that use different delimiters.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Notifier.PubSub.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\npub_sub do\n  delimiter \".\"\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Config Directory\nDESCRIPTION: Bash commands to create the config directory and config.exs file for an Ash application.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\nmkdir -p config\ntouch config/config.exs\n```\n\n----------------------------------------\n\nTITLE: Adding Spark Formatter Plugin Configuration\nDESCRIPTION: Configuration to add the Spark formatter plugin to .formatter.exs for consistent resource formatting.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/development-utilities.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n[\n  plugins: [Spark.Formatter], # <- add the plugin here\n  inputs: ...\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Policy Filtering Behavior in Ash\nDESCRIPTION: Configuration to modify how read policies handle authorization, ensuring consistent filtering behavior instead of raising Forbidden errors. This represents a backwards compatibility configuration that will become the default in version 4.0.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :policies,\n  no_filter_static_forbidden_reads?: false\n```\n\n----------------------------------------\n\nTITLE: Displaying Version History in Markdown\nDESCRIPTION: Markdown formatted changelog entries documenting version changes, bug fixes, and improvements for the Ash framework.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n## [v1.49.0](https://github.com/ash-project/ash/compare/v1.48.0-rc.30...v1.49.0) (2021-11-03)\n\n### Bug Fixes:\n\n- don't ask the data layer to sort if no sort is applied\n\n- set tenant at start of query build (#278)\n\n### Improvements:\n\n- still filter in cases w/o a lateral join on load\n```\n\n----------------------------------------\n\nTITLE: Setting default_page_type in Ash\nDESCRIPTION: Determines the default pagination type when only a limit is specified. Setting to :keyset makes Ash return an %Ash.Page.Keyset{} instead of %Ash.Page.Offset{} when pagination type is ambiguous.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/backwards-compatibility-config.md#2025-04-11_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, default_page_type: :keyset\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Page Type in Ash\nDESCRIPTION: Configuration to set the default pagination type to keyset pagination instead of offset pagination. This represents a backwards compatibility configuration that will become the default in version 4.0.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash,\n  default_page_type: :keyset\n```\n\n----------------------------------------\n\nTITLE: Implementing String Join Expression Function in Elixir\nDESCRIPTION: This code snippet implements a string_join expression function in the Ash project. It's listed as an improvement in version 2.6.10.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nImplement string_join expr function (#515)\n```\n\n----------------------------------------\n\nTITLE: Defining Ash Resource Calculation\nDESCRIPTION: Creates a custom calculation function for an Ash resource. This allows defining named functions to compute derived values from resources.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/dsls/DSL-Ash.Domain.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\ndefine_calculation :referral_link, User, args: [:id]\n```\n\nLANGUAGE: elixir\nCODE:\n```\ndefine_calculation :referral_link, User, args: [{:arg, :id}, {:ref, :id}]\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Calculation Context Example\nDESCRIPTION: Example of new calculation context structure usage in resource calculations.\nSOURCE: https://github.com/ash-project/ash/blob/main/CHANGELOG.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\n# Old way\ncalculate do\n  fn record, _context -> record.field end\nend\n\n# New way\ncalculate do\n  fn records, %Ash.Resource.Calculation.Context{} -> \n    Enum.map(records, & &1.field)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Refactoring Domain-specific Function Calls in Elixir\nDESCRIPTION: Demonstrates how to replace domain-specific function calls with generic Ash module calls in Elixir.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/development/upgrading-to-3.0.md#2025-04-11_snippet_11\n\nLANGUAGE: elixir\nCODE:\n```\nMyDomain1.create!(changeset)\nMyDomain2.read!(query)\nMyDomain3.calculate!(...)\n```\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.create!(changeset)\nAsh.read!(query)\nAsh.calculate!(query)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Elixir Project with Mix\nDESCRIPTION: Command to create a new Elixir project with a supervision tree using Mix.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/tutorials/get-started.md#2025-04-11_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# In your terminal\nmix new --sup helpdesk && cd helpdesk\n```\n\n----------------------------------------\n\nTITLE: Map-based Update for Embedded Resource\nDESCRIPTION: Demonstrates how to update an embedded resource using map input instead of structs.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/resources/embedded-resources.md#2025-04-11_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nAsh.Changeset.for_update(user, :update, %{profile: %{first_name: \"first_name\"}})\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Tracer in Ash\nDESCRIPTION: Shows how to configure a global tracer in the application configuration for Ash framework.\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/topics/advanced/monitoring.md#2025-04-11_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nconfig :ash, :tracer, MyApp.Tracer\n```\n\n----------------------------------------\n\nTITLE: Action Validation Implementation\nDESCRIPTION: Built-in validation function for checking action types\nSOURCE: https://github.com/ash-project/ash/blob/main/documentation/2.0-CHANGELOG.md#2025-04-11_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\naction_is/1\n```"
  }
]