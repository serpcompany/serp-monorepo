[
  {
    "owner": "metaplex-foundation",
    "repo": "developer-hub",
    "content": "TITLE: Full NFT Creation Process using Metaplex and Umi in TypeScript\nDESCRIPTION: This is a complete example that demonstrates the entire process of creating an NFT, including setting up Umi, uploading an image to Arweave, creating and uploading metadata, and minting the NFT core asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from '@metaplex-foundation/mpl-core'\nimport {\n  createGenericFile,\n  generateSigner,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\nconst createNft = async () => {\n  //\n  // ** Setting Up Umi **\n  //\n\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplCore())\n    .use(\n      irysUploader({\n        // mainnet address: \"https://node1.irys.xyz\"\n        // devnet address: \"https://devnet.irys.xyz\"\n        address: 'https://devnet.irys.xyz',\n      })\n    )\n\n  const signer = generateSigner(umi)\n\n  umi.use(signerIdentity(signer))\n\n  // Airdrop 1 SOL to the identity\n  // if you end up with a 429 too many requests error, you may have to use\n  // the filesystem wallet method or change rpcs.\n  console.log('Airdropping 1 SOL to identity')\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1))\n\n  //\n  // ** Upload an image to Arweave **\n  //\n\n  // use `fs` to read file via a string path.\n  // You will need to understand the concept of pathing from a computing perspective.\n\n  const imageFile = fs.readFileSync(\n    path.join('./image.png')\n  )\n\n  // Use `createGenericFile` to transform the file into a `GenericFile` type\n  // that umi can understand. Make sure you set the mimi tag type correctly\n  // otherwise Arweave will not know how to display your image.\n\n  const umiImageFile = createGenericFile(imageFile, 'image.png', {\n    tags: [{ name: 'Content-Type', value: 'image/png' }],\n  })\n\n  // Here we upload the image to Arweave via Irys and we get returned a uri\n  // address where the file is located. You can log this out but as the\n  // uploader can takes an array of files it also returns an array of uris.\n  // To get the uri we want we can call index [0] in the array.\n  console.log('Uploading Image...')\n  const imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n    throw new Error(err)\n  })\n\n  console.log('imageUri: ' + imageUri[0])\n\n  //\n  // ** Upload Metadata to Arweave **\n  //\n\n  const metadata = {\n    name: 'My NFT',\n    description: 'This is an NFT on Solana',\n    image: imageUri[0],\n    external_url: 'https://example.com',\n    attributes: [\n      {\n        trait_type: 'trait1',\n        value: 'value1',\n      },\n      {\n        trait_type: 'trait2',\n        value: 'value2',\n      },\n    ],\n    properties: {\n      files: [\n        {\n          uri: imageUri[0],\n          type: 'image/jpeg',\n        },\n      ],\n      category: 'image',\n    },\n  }\n\n  // Call upon umi's `uploadJson` function to upload our metadata to Arweave via Irys.\n\n  console.log('Uploading Metadata...')\n  const metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n    throw new Error(err)\n  })\n\n  //\n  // ** Creating the NFT **\n  //\n\n  // We generate a signer for the NFT\n  const asset = generateSigner(umi)\n\n  console.log('Creating NFT...')\n  const tx = await create(umi, {\n    asset,\n    name: 'My NFT',\n    uri: metadataUri,\n  }).sendAndConfirm(umi)\n\n  // Finally we can deserialize the signature that we can check on chain.\n  const signature = base58.deserialize(tx.signature)[0]\n\n  // Log out the signature and the links to the transaction and the NFT.\n  console.log('\\nNFT Created')\n  console.log('View Transaction on Solana Explorer')\n  console.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`)\n  console.log('\\n')\n  console.log('View NFT on Metaplex Explorer')\n  console.log(`https://core.metaplex.com/explorer/${nftSigner.publicKey}?env=devnet`)\n}\n\ncreateNft()\n```\n\n----------------------------------------\n\nTITLE: Creating Programmable NFT on Solana using Metaplex and Umi\nDESCRIPTION: This code demonstrates the process of creating a programmable NFT on Solana. It includes setting up Umi, uploading an image to Arweave, creating and uploading metadata, and minting the NFT using Metaplex's token metadata program. The script also handles airdropping SOL to the signer and logging transaction details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createProgrammableNft } from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  createGenericFile,\n  generateSigner,\n  percentAmount,\n  publicKey,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\nconst createNft = async () => {\n  //\n  // ** Setting Up Umi **\n  //\n\n  const umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n    .use(mplTokenMetadata())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: \"https://devnet.irys.xyz\",\n    })\n  );\n\n  const signer = generateSigner(umi);\n\n  umi.use(signerIdentity(signer));\n\n  // Airdrop 1 SOL to the identity\n  // if you end up with a 429 too many requests error, you may have to use\n  // the filesystem wallet method or change rpcs.\n  console.log(\"Airdropping 1 SOL to identity\");\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1));\n\n  //\n  // ** Upload an image to Arweave **\n  //\n\n  // use `fs` to read file via a string path.\n  // You will need to understand the concept of pathing from a computing perspective.\n\n  const imageFile = fs.readFileSync(\n    path.join(__dirname, \"../assets/images/0.png\")\n  );\n\n  // Use `createGenericFile` to transform the file into a `GenericFile` type\n  // that umi can understand. Make sure you set the mimi tag type correctly\n  // otherwise Arweave will not know how to display your image.\n\n  const umiImageFile = createGenericFile(imageFile, \"0.png\", {\n    tags: [{ name: \"Content-Type\", value: \"image/png\" }],\n  });\n\n  // Here we upload the image to Arweave via Irys and we get returned a uri\n  // address where the file is located. You can log this out but as the\n  // uploader can takes an array of files it also returns an array of uris.\n  // To get the uri we want we can call index [0] in the array.\n\n  console.log(\"Uploading image...\");\n  const imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n    throw new Error(err);\n  });\n\n  //\n  // ** Upload Metadata to Arweave **\n  //\n\n  const metadata = {\n    name: \"My Nft\",\n    description: \"This is an Nft on Solana\",\n    image: imageUri[0],\n    external_url: \"https://example.com\",\n    attributes: [\n      {\n        trait_type: \"trait1\",\n        value: \"value1\",\n      },\n      {\n        trait_type: \"trait2\",\n        value: \"value2\",\n      },\n    ],\n    properties: {\n      files: [\n        {\n          uri: imageUri[0],\n          type: \"image/jpeg\",\n        },\n      ],\n      category: \"image\",\n    },\n  };\n\n  // Call upon umi's uploadJson function to upload our metadata to Arweave via Irys.\n  console.log(\"Uploading metadata...\");\n  const metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n    throw new Error(err);\n  });\n\n  //\n  // ** Creating the Nft **\n  //\n\n  // We generate a signer for the Nft\n  const nftSigner = generateSigner(umi);\n\n  // Decide on a ruleset for the Nft.\n  // Metaplex ruleset - publicKey(\"eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9\")\n  // Compatability ruleset - publicKey(\"AdH2Utn6Fus15ZhtenW4hZBQnvtLgM1YCW2MfVp7pYS5\")\n  const ruleset = null // or set a publicKey from above\n\n  console.log(\"Creating Nft...\");\n  const tx = await createProgrammableNft(umi, {\n    mint: nftSigner,\n    sellerFeeBasisPoints: percentAmount(5.5),\n    name: metadata.name,\n    uri: metadataUri,\n    ruleSet: ruleset,\n  }).sendAndConfirm(umi);\n\n  // Finally we can deserialize the signature that we can check on chain.\n  const signature = base58.deserialize(tx.signature)[0];\n\n  // Log out the signature and the links to the transaction and the NFT.\n  console.log(\"\\npNFT Created\")\n  console.log(\"View Transaction on Solana Explorer\");\n  console.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`);\n  console.log(\"\\n\");\n  console.log(\"View NFT on Metaplex Explorer\");\n  console.log(`https://explorer.solana.com/address/${nftSigner.publicKey}?cluster=devnet`);\n}\n\ncreatNft()\n```\n\n----------------------------------------\n\nTITLE: Transfer Core Asset using JavaScript/TypeScript\nDESCRIPTION: Demonstrates how to transfer a Core NFT Asset to a new owner using the MPL Core program's transferV1 instruction in JavaScript/TypeScript. Uses the @metaplex-foundation/umi and @metaplex-foundation/mpl-core packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/transfer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { transferV1 } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait transferV1(umi, {\n  asset: asset,\n  newOwner: newOwner.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Mint and Metadata Accounts using Rust Script\nDESCRIPTION: This Rust script showcases the creation of Mint and Metadata accounts using the CreateV1Builder from the mpl_token_metadata crate. It sets up the instruction with various parameters and sends the transaction using an RpcClient.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::\n    instructions::CreateV1Builder,\n    types::{PrintSupply, TokenStandard},\n};\nuse solana_rpc_client::rpc_client::RpcClient;\nuse solana_sdk::\n     message::Message,\n     transaction::Transaction,\n};\n\n// 1. client is a reference to the initialized RpcClient\n// 2. every account is specified by their pubkey\n\nlet client = ...;\n\nlet create_ix = CreateV1Builder::new()\n    .metadata(metadata)\n    .master_edition(Some(master_edition))\n    .mint(mint.pubkey(), true)\n    .authority(payer.pubkey())\n    .payer(payer.pubkey())\n    .update_authority(payer.pubkey(), false)\n    .name(String::from(\"My NFT\"))\n    .uri(uri)\n    .seller_fee_basis_points(550)\n    .token_standard(TokenStandard::NonFungible)\n    .print_supply(PrintSupply::Zero)\n    .instruction();\n\nlet message = Message::new(\n    &[create_ix],\n    Some(&payer.pubkey()),\n);\n\nlet blockhash = client.get_latest_blockhash()?;\nlet mut tx = Transaction::new(&[mint, payer], message, blockhash);\nclient.send_and_confirm_transaction(&tx)?\n```\n\n----------------------------------------\n\nTITLE: Creating a Fungible Token in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Fungible Token using the createFungible helper function from the @metaplex-foundation/mpl-token-metadata library in TypeScript. It combines the Create V1 and Mint V1 instructions for Fungible tokens.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount, generateSigner, some } from '@metaplex-foundation/umi'\nimport { createFungible } from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createFungible(umi, {\n  mint,\n  name: 'My Fungible',\n  uri: 'https://example.com/my-fungible.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  decimals: some(7), // for 0 decimals use some(0)\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Umi Instance with RPC Connection\nDESCRIPTION: TypeScript code for creating a new Umi instance with RPC endpoint configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\n\nconst umi = createUmi('<RPC-Endpoint>', '<Commitment-Level>')\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Machine and Candy Guard accounts\nDESCRIPTION: This code snippet shows how to fetch a Candy Machine account and its associated Candy Guard account using the initialized Umi instance. It demonstrates basic interaction with the Candy Machine SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/getting-started/js.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  fetchCandyMachine,\n  fetchCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachinePublicKey = publicKey('...')\nconst candyMachine = await fetchCandyMachine(umi, candyMachinePublicKey)\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\n```\n\n----------------------------------------\n\nTITLE: Creating a Fungible Asset in TypeScript\nDESCRIPTION: This snippet shows how to create a Fungible Asset using the createFungibleAsset helper function from the @metaplex-foundation/mpl-token-metadata library in TypeScript. It combines the Create V1 and Mint V1 instructions for Fungible Assets.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount, generateSigner, some } from '@metaplex-foundation/umi'\nimport { createFungibleAsset } from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createFungibleAsset(umi, {\n  mint,\n  name: 'My Fungible Asset',\n  uri: 'https://example.com/my-fungible-asset.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  decimals: some(7) // for 0 decimals use some(0)\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of CreateV1Builder Instruction\nDESCRIPTION: An example in Rust of using the CreateV1Builder to construct an instruction for asset creation with specified parameters. It includes setting public keys, asset name, and URI, and finalizing the instruction with the instruction() method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n.       .instruction();\n```\n\n----------------------------------------\n\nTITLE: Inscribe Data for new NFT using the Gateway in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the process of creating and inscribing a new NFT on the Solana blockchain using the Metaplex Inscription program. Dependencies include the umi library for blockchain interactions, mplTokenMetadata, and mplInscription for metadata operations. The snippet initializes an inscription, writes JSON metadata and image data to associated accounts, and handles transaction confirmation. Key parameters include the NFT's mint account, metadata URI, and the buffer holding image bytes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst umi = await createUmi()\numi.use(mplTokenMetadata())\numi.use(mplInscription())\n\n// Create and mint the NFT to be inscribed.\nconst mint = generateSigner(umi)\nconst inscriptionAccount = await findMintInscriptionPda(umi, {\n  mint: mint.publicKey,\n})\nawait createV1(umi, {\n  mint,\n  name: 'My NFT',\n  uri: `https://igw.metaplex.com/devnet/${inscriptionAccount[0]}`,\n  sellerFeeBasisPoints: percentAmount(5.5),\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n\nawait mintV1(umi, {\n  mint: mint.publicKey,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount[0],\n})\n\nlet builder = new TransactionBuilder()\n\n// We initialize the Inscription and create the account where the JSON will be stored.\nbuilder = builder.add(\n  initializeFromMint(umi, {\n    mintAccount: mint.publicKey,\n  })\n)\n\n// And then write the JSON data for the NFT to the Inscription account.\nbuilder = builder.add(\n  writeData(umi, {\n    inscriptionAccount: inscriptionAccount[0],\n    inscriptionMetadataAccount,\n    value: Buffer.from(\n      '{\"description\": \"A bread! But onchain!\", \"external_url\": \"https://breadheads.io\"}'\n    ),\n    associatedTag: null,\n    offset: 0,\n  })\n)\n\n// We then create the associated Inscription that will contain the image.\nconst associatedInscriptionAccount = findAssociatedInscriptionPda(umi, {\n  associated_tag: 'image',\n  inscriptionMetadataAccount,\n})\n\nbuilder = builder.add(\n  initializeAssociatedInscription(umi, {\n    inscriptionMetadataAccount,\n    associatedInscriptionAccount,\n    associationTag: 'image',\n  })\n)\n\nawait builder.sendAndConfirm(umi, { confirm: { commitment: 'finalized' } })\n\n// Open the image file to fetch the raw bytes.\nconst imageBytes: Buffer = await fs.promises.readFile('bread.png')\n\n// And write the image.\nconst chunkSize = 800\nfor (let i = 0; i < imageBytes.length; i += chunkSize) {\n  const chunk = imageBytes.slice(i, i + chunkSize)\n  await writeData(umi, {\n    inscriptionAccount: associatedInscriptionAccount,\n    inscriptionMetadataAccount,\n    value: chunk,\n    associatedTag: 'image',\n    offset: i,\n  }).sendAndConfirm(umi)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Owner in Rust\nDESCRIPTION: This Rust code fetches multiple NFT assets owned by a specific address. It uses the Solana RPC client with filters to get program accounts and then deserializes them into BaseAssetV1 structs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{accounts::BaseAssetV1, types::Key, ID as MPL_CORE_ID};\nuse solana_client::{\n    nonblocking::rpc_client,\n    rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},\n    rpc_filter::{Memcmp, MemcmpEncodedBytes, RpcFilterType},\n};\nuse solana_sdk::pubkey::Pubkey;\n\npub async fn fetch_assets_by_owner() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let owner = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client\n        .get_program_accounts_with_config(\n            &MPL_CORE_ID,\n            RpcProgramAccountsConfig {\n                filters: Some(vec![\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        0,\n                        MemcmpEncodedBytes::Bytes(vec![Key::AssetV1 as u8]),\n                    )),\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        1,\n                        MemcmpEncodedBytes::Base58(owner.to_string()),\n                    )),\n                ]),\n                account_config: RpcAccountInfoConfig {\n                    encoding: None,\n                    data_slice: None,\n                    commitment: None,\n                    min_context_slot: None,\n                },\n                with_context: None,\n            },\n        )\n        .await\n        .unwrap();\n\n    let accounts_iter = rpc_data.into_iter().map(|(_, account)| account);\n\n    let mut assets: Vec<BaseAssetV1> = vec![];\n\n    for account in accounts_iter {\n        let asset = BaseAssetV1::from_bytes(&account.data).unwrap();\n        assets.push(asset);\n    }\n\n    print!(\"{:?}\", assets)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating NFT with Plugins using Metaplex in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an NFT with plugins, specifically the PermanentFreezeDelegate and AppData plugins, using the create() instruction from Metaplex.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = generateSigner(umi)\n\nconst tx = await create(umi, {\n  asset,\n  name: 'My NFT',\n  uri: metadataUri,\n  plugins: [\n    {\n      type: \"PermanentFreezeDelegate\",\n      frozen: true,\n      authority: { type: \"UpdateAuthority\"}\n    },\n    {\n      type: \"AppData\",\n      dataAuthority: { type: \"UpdateAuthority\"},\n      schema: ExternalPluginAdapterSchema.Binary,\n    }           \n  ]\n}).sendAndConfirm(umi)\n\nconst signature = base58.deserialize(tx.signature)[0]\n```\n\n----------------------------------------\n\nTITLE: Creating Asset with Rust CPI\nDESCRIPTION: Shows how to create an asset using Rust Cross-Program Invocation (CPI). Includes builder pattern for constructing the creation instruction with various parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet create_ix = CreateV1CpiBuilder::new()\n        .asset(input.asset.pubkey())\n        .collection(input.collection)\n        .authority(input.authority)\n        .payer(payer)\n        .owner(input.owner)\n        .update_authority(input.update_authority)\n        .system_program(system_program::ID)\n        .data_state(input.data_state.unwrap_or(DataState::AccountState))\n        .name(input.name.unwrap_or(DEFAULT_ASSET_NAME.to_owned()))\n        .uri(input.uri.unwrap_or(DEFAULT_ASSET_URI.to_owned()))\n        .plugins(input.plugins)\n        .invoke();\n```\n\n----------------------------------------\n\nTITLE: Creating a Programmable Non-Fungible Token in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Programmable Non-Fungible Token using the createProgrammableNft helper function from the @metaplex-foundation/mpl-token-metadata library in TypeScript. It combines the Create V1 and Mint V1 instructions for Programmable NFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount, generateSigner } from '@metaplex-foundation/umi'\nimport { createProgrammableNft } from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createProgrammableNft(umi, {\n  mint,\n  name: 'My Programmable NFT',\n  uri: 'https://example.com/my-programmable-nft.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  // optional if you directly want to add to a collection. Need to verify later.\n  // collection: some({ key: collectionMint.publicKey, verified: false }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Full Example of Creating Solana NFT Collection using Metaplex and Umi\nDESCRIPTION: This comprehensive example demonstrates the entire process of creating a Solana NFT collection. It includes setting up Umi, uploading an image to Arweave, creating and uploading metadata, and minting the collection NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  createCollection,\n  mplCore,\n} from '@metaplex-foundation/mpl-core'\nimport {\n  createGenericFile,\n  generateSigner,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\nconst createCollection = async () => {\n  //\n  // ** Setting Up Umi **\n  //\n\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplCore())\n    .use(irysUploader({address: 'https://devnet.irys.xyz'}))\n\n  const signer = generateSigner(umi)\n\n  umi.use(signerIdentity(signer))\n\n  \n  console.log('Airdropping 1 SOL to identity')\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1))\n\n  //\n  // ** Upload an image to Arweave **\n  //\n\n  const imageFile = fs.readFileSync(\n    path.join(__dirname, '..', '/assets/my-image.jpg')\n  )\n\n  const umiImageFile = createGenericFile(imageFile, 'my-image.jpeg', {\n    tags: [{ name: 'Content-Type', value: 'image/jpeg' }],\n  })\n\n  const imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n    throw new Error(err)\n  })\n\n  console.log('imageUri: ' + imageUri[0])\n\n  //\n  // ** Upload Metadata to Arweave **\n  //\n\n  const metadata = {\n    name: 'My Collection',\n    description: 'This is a Collection on Solana',\n    image: imageUri[0],\n    external_url: 'https://example.com',\n    properties: {\n      files: [\n        {\n          uri: imageUri[0],\n          type: 'image/jpeg',\n        },\n      ],\n      category: 'image',\n    },\n  }\n\n  console.log('Uploading Metadata...')\n  const metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n    throw new Error(err)\n  })\n\n  //\n  // ** Creating the Collection **\n  //\n\n  const collection = generateSigner(umi)\n\n  console.log('Creating Collection...')\n  const tx = await createCollection(umi, {\n    collection,\n    name: 'My Collection',\n    uri: metadataUri,\n  }).sendAndConfirm(umi)\n\n  const signature = base58.deserialize(tx.signature)[0]\n\n  console.log('\\Collection Created')\n  console.log('View Transaction on Solana Explorer')\n  console.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`)\n  console.log('\\n')\n  console.log('View NFT on Metaplex Explorer')\n  console.log(`https://core.metaplex.com/explorer/${nftSigner.publicKey}?env=devnet`)\n}\n\ncreateCollection()\n```\n\n----------------------------------------\n\nTITLE: Basic Minting from Candy Machine V2\nDESCRIPTION: Simple example of minting an NFT from an existing Candy Machine V2 without guards. Uses the Metaplex SDK to fetch the Candy Machine account and mint an NFT to a specified recipient.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst candyMachineAccount = await fetchCandyMachine(umi, publicKey(\"CM Address\"));\n\nconst recipient = publicKey('Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV')\nconst nftMint = generateSigner(umi)\nconst mintTx = await transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient }))\n  .add(\n    mintFromCandyMachineV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      mintAuthority: umi.identity,\n      nftOwner: recipient,\n      nftMint,\n      collectionMint: candyMachineAccount.collectionMint,\n      collectionUpdateAuthority: candyMachineAccount.authority,\n    })\n  )\n  .sendAndConfirm(umi, {\n    confirm: { commitment: 'finalized' },\n  })\n```\n\n----------------------------------------\n\nTITLE: Creating and Uploading NFT Metadata\nDESCRIPTION: Process for creating and uploading NFT metadata to Arweave\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst metadata = {\n  \"name\": \"My NFT\",\n  \"description\": \"This is an NFT on Solana\",\n  \"image\": imageUri[0],\n  \"external_url\": \"https://example.com/my-nft.json\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": imageUri[0],\n        \"type\": \"image/png\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n\nconst metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n  throw new Error(err)\n})\n```\n\n----------------------------------------\n\nTITLE: Minting NFT from Candy Machine using Candy Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to mint an NFT from a Candy Machine using the Candy Guard program. It includes setting compute unit limits and handling the minting process with the mintV2 function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/mint.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV2 } from '@metaplex-foundation/mpl-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\nimport { transactionBuilder, generateSigner } from '@metaplex-foundation/umi'\n\nconst nftMint = generateSigner(umi)\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      nftMint,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n      tokenStandard: candyMachine.tokenStandard,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Connecting New Wallet to Umi\nDESCRIPTION: TypeScript code for generating and connecting a new wallet signer to Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { generateSigner, signerIdentity } from '@metaplex-foundation/umi'\n\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// Tell Umi to use the new signer.\numi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Creating Mint and Metadata Accounts using JavaScript Umi\nDESCRIPTION: This snippet demonstrates how to use the createV1 function from the mpl-token-metadata package to create a new NFT with its associated Mint and Metadata accounts. It sets up the mint signer, authority, and various metadata fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport {\n  createV1,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createV1(umi, {\n  mint,\n  authority,\n  name: 'My NFT',\n  uri,\n  sellerFeeBasisPoints: percentAmount(5.5),\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Printing NFT Editions from Master Edition in TypeScript\nDESCRIPTION: Shows how to print new editions from a Master Edition NFT by using the Print instruction. Includes fetching the master edition account and creating a new edition with the next available edition number.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/print.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport {\n  printV1,\n  fetchMasterEditionFromSeeds,\n} from '@metaplex-foundation/mpl-token-metadata'\n\n// (Optional) Fetch the master edition account to mint the next edition number.\nconst masterEdition = await fetchMasterEditionFromSeeds(umi, {\n  mint: masterEditionMint,\n})\n\nconst editionMint = generateSigner(umi)\nawait printV1(umi, {\n  masterTokenAccountOwner: originalOwner,\n  masterEditionMint,\n  editionMint,\n  editionTokenAccountOwner: ownerOfThePrintedEdition,\n  editionNumber: masterEdition.supply + 1n,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Downloading Sugar CLI for Windows\nDESCRIPTION: URL to download the Sugar CLI installation executable for Windows systems.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nhttps://github.com/metaplex-foundation/winstaller/releases/latest/download/winstaller.exe\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for Image NFT in Metaplex Core\nDESCRIPTION: This snippet demonstrates the JSON schema for an image-based NFT in Metaplex Core. It includes basic metadata like name and description, as well as image URL and attributes. The attributes can alternatively be stored on-chain using the Attributes Plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"Number #0001\",\n  \"description\": \"Collection of 10 numbers on the blockchain. This is the number 1/10.\",\n  \"image\": \"https://arweave.net/swS5eZNrKGtuu5ebdqotzPny4OBoM4wHneZ_Ld17ZU8?ext=png\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://arweave.net/swS5eZNrKGtuu5ebdqotzPny4OBoM4wHneZ_Ld17ZU8?ext=png\",\n        \"type\": \"image/png\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Minting NFT with Specific Guard Group in TypeScript\nDESCRIPTION: This code snippet shows how to mint an NFT using a specific guard group with the Candy Machine and Umi SDK. It includes the 'group' parameter in the mintV1 function to specify the desired guard group label.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// Generate the NFT address\nconst nftMint = generateSigner(umi);\n\nawait mintV1(umi, {\n  candyMachine: candyMachine.publicKey,\n  collection: candyMachine.collectionMint,\n  asset: nftMint,\n  candyGuard: candyGuard.publicKey,\n  mintArgs,\n  group: \"group1\",\n}).sendAndConfirm(umi)\n\nconsole.log(`NFT ${nftMint.publicKey} minted!`)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Assets Using JavaScript and UMI\nDESCRIPTION: This example demonstrates how to fetch information about multiple assets using the Metaplex UMI library. It initializes a UMI instance with a DAS API plugin and retrieves details for two different assets using their public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-assets.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst assetIds = [\n  publicKey('GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA'),\n  publicKey('8bFQbnBrzeiYQabEJ1ghy5T7uFpqFzPjUGsVi3SzSMHB')\n];\n\nconst assets = await umi.rpc.getAssets(assetIds);\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Initializing UMI and Setting up Irys Uploader in Typescript\nDESCRIPTION: This snippet initializes the UMI instance with the specified RPC endpoint, mpl-token-metadata plugin, and the irysUploader plugin. It also sets up a signer using generateSigner and sets the signer as the identity for the UMI instance. This allows for signing transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n    .use(mplTokenMetadata())\n    .use(irysUploader())\n\n  const signer = generateSigner(umi)\n\n  umi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Minting Tokens with Token Metadata in Rust (CPI)\nDESCRIPTION: This snippet demonstrates how to mint tokens using the Mint V1 instruction of the Token Metadata program in Rust via Cross-Program Invocation (CPI). It uses the MintV1CpiBuilder to construct and invoke the minting instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::instructions::MintV1CpiBuilder;\n\n// 1. every account is specified by a reference to their AccountInfo\n\nlet mint_cpi = MintV1CpiBuilder::new(token_metadata_program_info)\n    .token(token_info)\n    .token_owner(Some(token_owner_info))\n    .metadata(metadata_info)\n    .master_edition(Some(master_edition_info))\n    .mint(mint_info)\n    .payer(payer_info)\n    .authority(update_authority_info)\n    .system_program(system_program_info)\n    .sysvar_instructions(sysvar_instructions_info)\n    .spl_token_program(spl_token_program_info)\n    .spl_ata_program(spl_ata_program_info)\n    .amount(1);\n\nmint_cpi.invoke();\n```\n\n----------------------------------------\n\nTITLE: Uploading Metadata to Arweave via Irys in Typescript\nDESCRIPTION: This snippet defines metadata for the fungible token, including its name, symbol, description, and the URI of the uploaded image. It then uploads this metadata to Arweave via Irys using the `umi.uploader.uploadJson` method. The URI of the uploaded metadata is then stored in the `metadataUri` variable for later use.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n  // Uploading the tokens metadata to Arweave via Irys\n\n  const metadata = {\n    name: \"The Kitten Coin\",\n    symbol: \"KITTEN\",\n    description: \"The Kitten Coin is a token created on the Solana blockchain\",\n    image: imageUri, // Either use variable or paste in string of the uri.\n  };\n\n  // Call upon umi's uploadJson function to upload our metadata to Arweave via Irys.\n\n  console.log(\"Uploading metadata to Arweave via Irys\");\n  const metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n    throw new Error(err);\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating Asset with JavaScript/TypeScript\nDESCRIPTION: Shows how to create a new asset using the Metaplex Core create instruction with the JavaScript SDK. Includes asset initialization with basic metadata like name and URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi)\n\nconst result = await create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  //owner: publicKey('11111111111111111111111111111111'), //optional to mint into a different wallet\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Solana NFT Collection with Plugins using Metaplex and Umi\nDESCRIPTION: This snippet demonstrates how to create a Solana NFT collection with additional plugins, such as FreezeDelegate and AppData. It uses the createCollection function with the plugins field to add these features during collection creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst collection = generateSigner(umi)\n\nconst tx = await createCollection(umi, {\n  collection: collection,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n  plugins: [\n    {\n      type: \"PermanentFreezeDelegate\",\n      frozen: true,\n      authority: { type: \"UpdateAuthority\"}\n    },\n    {\n      type: \"AppData\",\n      dataAuthority: { type: \"UpdateAuthority\"},\n      schema: ExternalPluginAdapterSchema.Binary,\n    }           \n  ]\n}).sendAndConfirm(umi)\n\nconst signature = base58.deserialize(tx.signature)[0]\n```\n\n----------------------------------------\n\nTITLE: Fetching NftMintCounter Account\nDESCRIPTION: This code snippet demonstrates how to fetch the `NftMintCounter` account associated with the `NftMintLimit` guard. It assumes that the Candy Machine and Candy Guard data are already available. The `findNftMintCounterPda` function generates the PDA for the `NftMintCounter` account, which is then used by `fetchNftMintCounter` to retrieve the account data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  findNftMintCounterPda,\n  fetchNftMintCounter\n } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst pda = findNftMintCounterPda(umi, {\n  id: 1, // The nftMintLimit id you set in your guard config\n  mint: asset.publicKey, // The address of the nft your user owns\n  candyGuard: candyMachine.mintAuthority,\n  candyMachine: candyMachine.publicKey,\n});\n      \nconst nftMintCounter = fetchNftMintCounter(umi, pda)\n```\n\n----------------------------------------\n\nTITLE: Implementing Merkle Tree Token Claimer Smart Contract in Rust\nDESCRIPTION: A comprehensive Solana smart contract that manages token airdrops using Merkle trees for verification. The contract includes functionality to initialize an airdrop, update the Merkle root, and process claims while verifying them against the on-chain Merkle root. After a successful claim, it updates the Merkle root to reflect the claimed status.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{associated_token::AssociatedToken, token::{mint_to, set_authority, transfer, Mint, MintTo, SetAuthority, Token, TokenAccount, Transfer, spl_token::instruction::AuthorityType}};\nuse svm_merkle_tree::{HashingAlgorithm, MerkleProof};\n\ndeclare_id!(\"GTCPuHiGookQVSAgGc7CzBiFYPytjVAq6vdCV3NnZoHa\");\n\n#[program]\npub mod merkle_tree_token_claimer {\n  use super::*;\n\n  pub fn initialize_airdrop_data(\n    ctx: Context<Initialize>, \n    merkle_root: [u8; 32],\n    amount: u64,\n  ) -> Result<()> {\n\n    ctx.accounts.airdrop_state.set_inner(\n      AirdropState {\n        merkle_root,\n        authority: ctx.accounts.authority.key(),\n        mint: ctx.accounts.mint.key(),\n        airdrop_amount: amount,\n        amount_claimed: 0,\n        bump: ctx.bumps.airdrop_state,\n      }\n    );\n\n    mint_to(\n      CpiContext::new(\n        ctx.accounts.token_program.to_account_info(), \n        MintTo {\n          mint: ctx.accounts.mint.to_account_info(),\n          to: ctx.accounts.vault.to_account_info(),\n          authority: ctx.accounts.authority.to_account_info(),\n        }\n      ),\n      amount\n    )?;\n\n    set_authority(\n      CpiContext::new(\n        ctx.accounts.token_program.to_account_info(), \n        SetAuthority {\n          current_authority: ctx.accounts.authority.to_account_info(),\n          account_or_mint: ctx.accounts.mint.to_account_info(),\n        }\n      ), \n      AuthorityType::MintTokens,\n      None\n    )?;\n\n    Ok(())\n  }\n\n  pub fn update_tree(\n    ctx: Context<Update>, \n    new_root: [u8; 32]\n  ) -> Result<()> {\n\n    ctx.accounts.airdrop_state.merkle_root = new_root;\n\n    Ok(())\n  }\n\n  pub fn claim_airdrop(\n    ctx: Context<Claim>,\n    amount: u64,\n    hashes: Vec<u8>,\n    index: u64,\n  ) -> Result<()> {    \n    let airdrop_state = &mut ctx.accounts.airdrop_state;\n\n    // Step 1: Verify that the Signer and Amount are right by computing the original leaf\n    let mut original_leaf = Vec::new();\n    original_leaf.extend_from_slice(&ctx.accounts.signer.key().to_bytes());\n    original_leaf.extend_from_slice(&amount.to_le_bytes());\n    original_leaf.push(0u8); // isClaimed = false\n\n    // Step 2: Verify the Merkle proof against the on-chain root\n    let merkle_proof = MerkleProof::new(\n      HashingAlgorithm::Keccak,\n      32,\n      index as u32,\n      hashes.clone(),\n    );\n  \n    let computed_root = merkle_proof\n      .merklize(&original_leaf)\n      .map_err(|_| AirdropError::InvalidProof)?;\n\n    require!(\n      computed_root.eq(&airdrop_state.merkle_root),\n      AirdropError::InvalidProof\n    );\n\n    // Step 3: Execute the transfer\n    let mint_key = ctx.accounts.mint.key().to_bytes();\n    let signer_seeds = &[\n      b\"merkle_tree\".as_ref(),\n      mint_key.as_ref(),\n      &[airdrop_state.bump],\n    ];\n\n    transfer(\n      CpiContext::new_with_signer(\n        ctx.accounts.token_program.to_account_info(),\n        Transfer {\n          from: ctx.accounts.vault.to_account_info(),\n          to: ctx.accounts.signer_ata.to_account_info(),\n          authority: airdrop_state.to_account_info(),\n        },\n        &[signer_seeds],\n      ),\n      amount,\n    )?;\n  \n    // Step 4: Update the `is_claimed` flag in the leaf\n    let mut updated_leaf = Vec::new();\n    updated_leaf.extend_from_slice(&ctx.accounts.signer.key().to_bytes());\n    updated_leaf.extend_from_slice(&amount.to_le_bytes());\n    updated_leaf.push(1u8); // isClaimed = true\n\n    let updated_root: [u8; 32] = merkle_proof\n      .merklize(&updated_leaf)\n      .map_err(|_| AirdropError::InvalidProof)?\n      .try_into()\n      .map_err(|_| AirdropError::InvalidProof)?;\n\n    // Step 5: Update the Merkle root in the airdrop state\n    airdrop_state.merkle_root = updated_root;\n\n    // Step 6: Update the airdrop state\n    airdrop_state.amount_claimed = airdrop_state\n      .amount_claimed\n      .checked_add(amount)\n      .ok_or(AirdropError::OverFlow)?;\n  \n      Ok(())\n  }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n  #[account(\n    init, \n    seeds = [b\"merkle_tree\".as_ref(), mint.key().to_bytes().as_ref()],\n    bump,\n    payer = authority, \n    space = 8 + 32 + 32 + 32 + 8 + 8 + 1\n  )]\n  pub airdrop_state: Account<'info, AirdropState>,\n  #[account(mut)]\n  pub mint: Account<'info, Mint>,\n  #[account(\n    init_if_needed,\n    payer = authority,\n    associated_token::mint = mint,\n    associated_token::authority = airdrop_state,\n  )]\n  pub vault: Account<'info, TokenAccount>,\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, Token>,\n  pub associated_token_program: Program<'info, AssociatedToken>,\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n  #[account(\n    mut, \n    has_one = authority,\n    seeds = [b\"merkle_tree\".as_ref(), airdrop_state.mint.key().to_bytes().as_ref()],\n    bump = airdrop_state.bump\n  )]\n  pub airdrop_state: Account<'info, AirdropState>,\n  pub authority: Signer<'info>,\n}\n\n#[derive(Accounts)]\npub struct Claim<'info> {\n  #[account(\n    mut,\n    has_one = mint,\n    seeds = [b\"merkle_tree\".as_ref(), mint.key().to_bytes().as_ref()],\n    bump = airdrop_state.bump\n  )]\n  pub airdrop_state: Account<'info, AirdropState>,\n  pub mint: Account<'info, Mint>,\n  #[account(\n    mut,\n    associated_token::mint = mint,\n    associated_token::authority = airdrop_state,\n  )]\n  pub vault: Account<'info, TokenAccount>,\n  #[account(\n    init_if_needed,\n    payer = signer,\n    associated_token::mint = mint,\n    associated_token::authority = signer,\n  )]\n  pub signer_ata: Account<'info, TokenAccount>,\n  #[account(mut)]\n  pub signer: Signer<'info>,\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, Token>,\n  pub associated_token_program: Program<'info, AssociatedToken>,\n}\n\n/// State account holding the merkle tree and airdrop information\n#[account]\npub struct AirdropState {\n  /// The current merkle root\n  pub merkle_root: [u8; 32],\n  /// The authority who can update the merkle root\n  pub authority: Pubkey,\n  /// The mint address of the token being airdropped\n  pub mint: Pubkey,\n  /// Total amount allocated for the airdrop\n  pub airdrop_amount: u64,\n  /// Total amount claimed so far\n  pub amount_claimed: u64,\n  /// PDA bump seed\n  pub bump: u8,\n}\n\n#[error_code]\npub enum AirdropError {\n  #[msg(\"Invalid Merkle proof\")]\n  InvalidProof,\n  #[msg(\"Already claimed\")]\n  AlreadyClaimed,\n  #[msg(\"Amount overflow\")]\n  OverFlow,\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching a Tree Config Account\nDESCRIPTION: This code shows how to fetch a Tree Config account associated with a Merkle Tree. The Tree Config contains Bubblegum-specific data such as the tree creator, delegate, total capacity, number of minted NFTs, and whether the tree is public.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/create-trees.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchTreeConfigFromSeeds } from '@metaplex-foundation/mpl-bubblegum'\n\nconst treeConfig = await fetchTreeConfigFromSeeds(umi, { merkleTree })\n```\n\n----------------------------------------\n\nTITLE: Initializing and Minting from Candy Machine with Guard Groups\nDESCRIPTION: Demonstrates how to create a Candy Machine with multiple guard groups and mint NFTs by selecting a specific group. The example shows configuration of default guards, group-specific guards, and handling of mint settings for third-party signer and NFT payment guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/mint.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a Candy Machine with guards.\nconst thirdPartySigner = generateSigner()\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n    thirdPartySigner: some({ signer: thirdPartySigner.publicKey }),\n    startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n  },\n  groups: [\n    {\n      label: 'nft',\n      guards: {\n        nftPayment: some({ requiredCollection, destination: nftTreasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n      },\n    },\n    {\n      label: 'public',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: solTreasury }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n\n// Mint from the Candy Machine.\nconst nftMint = generateSigner(umi)\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      nftMint,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n      group: some('nft'),\n      mintArgs: {\n        thirdPartySigner: some({ signer: thirdPartySigner }),\n        nftPayment: some({\n          mint: nftFromRequiredCollection.publicKey,\n          destination: nftTreasury,\n          tokenStandard: TokenStandard.NonFungible,\n        }),\n      },\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching a Single Asset in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch a single NFT asset using the fetchAsset function from the Metaplex Core package in JavaScript. It requires the Umi context and the asset's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\nconsole.log(asset)\n```\n\n----------------------------------------\n\nTITLE: Minting Standard NFT\nDESCRIPTION: Process for minting a standard NFT without royalty enforcement\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst nftSigner = generateSigner(umi)\n\nconst tx = await createNft(umi, {\n  mint: nftSigner,\n  sellerFeeBasisPoints: percentAmount(5.5),\n  name: 'My NFT',\n  uri: metadataUri,\n}).sendAndConfirm(umi)\n\nconsole.log(base58.deserialize(tx.signature)[0])\n```\n\n----------------------------------------\n\nTITLE: Creating Token Account and Minting Tokens\nDESCRIPTION: Generating an Associated Token Account (ATA) and minting tokens to the account\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst createTokenIx = createTokenIfMissing(umi, {\n  mint: mintSigner.publicKey,\n  owner: umi.identity.publicKey,\n  ataProgram: getSplAssociatedTokenProgramId(umi),\n})\n\nconst mintTokensIx = mintTokensTo(umi, {\n  mint: mintSigner.publicKey,\n  token: findAssociatedTokenPda(umi, {\n    mint: mintSigner.publicKey,\n    owner: umi.identity.publicKey,\n  }),\n  amount: BigInt(1000),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating MPL-404 Hybrid Escrow with Umi in JavaScript\nDESCRIPTION: This snippet demonstrates how to create an MPL-404 Hybrid Escrow on Solana using the Umi library. It sets up Umi, configures escrow settings, and initializes the escrow with specified parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { publicKey, signerIdentity, generateSigner, sol } from '@metaplex-foundation/umi'\nimport { mplHybrid, MPL_HYBRID_PROGRAM_ID, initEscrowV1 } from '@metaplex-foundation/mpl-hybrid'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport { string, base58, publicKey as publicKeySerializer } from '@metaplex-foundation/umi/serializers'\n\n(async () => {\n  /// Step 1: Setup Umi\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplHybrid())\n    .use(mplTokenMetadata())\n\n  let signer = generateSigner(umi);\n\n  umi.use(signerIdentity(signer)).rpc.airdrop(umi.identity.publicKey, sol(1));\n\n  /// Step 2: Setup the Escrow\n\n  // Escrow Settings - Change these to your needs\n  const name = \"MPL-404 Hybrid Escrow\";                       // The name of the escrow\n  const uri = \"https://arweave.net/manifestId\";               // The base URI of the collection\n  const max = 15;                                             // The max URI\n  const min = 0;                                              // The min URI\n  const path = 0;                                             // 0: Update Nft on Swap, 1: Do not update Nft on Swap\n\n  // Escrow Accounts - Change these to your needs\n  const collection = publicKey('<YOUR-COLLECTION-ADDRESS>');  // The collection we are swapping to/from\n  const token = publicKey('<YOUR-TOKEN-ADDRESS>');            // The token we are swapping to/from\n  const feeLocation = publicKey('<YOUR-FEE-ADDRESS>');        // The address where the fees will be sent\n  const escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: 'variable' }).serialize('escrow'),\n    publicKeySerializer().serialize(collection),\n  ]);                                                         // The derived escrow account\n\n  // Token Swap Settings - Change these to your needs\n  const tokenDecimals = 6;                                    // The decimals of the token\n  const amount = addZeros(100, tokenDecimals);                // The amount the user will receive when swapping\n  const feeAmount = addZeros(1, tokenDecimals);               // The amount the user will pay as fee when swapping to NFT\n  const solFeeAmount = addZeros(0, 9);                        // Additional fee to pay when swapping to NFTs (Sol has 9 decimals)\n\n  /// Step 3: Create the Escrow\n  const initEscrowTx = await initEscrowV1(umi, {\n    name,\n    uri,\n    max,\n    min,\n    path,\n    escrow,\n    collection,\n    token,\n    feeLocation,\n    amount,\n    feeAmount,\n    solFeeAmount,\n  }).sendAndConfirm(umi);\n\n  const signature = base58.deserialize(initEscrowTx.signature)[0]\n  console.log(`Escrow created! https://explorer.solana.com/tx/${signature}?cluster=devnet`)\n})()\n\n// Function that adds zeros to a number, needed for adding the correct amount of decimals\nfunction addZeros(num: number, numZeros: number): number {\n  return num * Math.pow(10, numZeros)\n}\n```\n\n----------------------------------------\n\nTITLE: NFT Metadata JSON Structure\nDESCRIPTION: Example JSON structure for NFT metadata, including name, description, image URI, attributes, and properties. This format is required for each NFT in the collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"My NFT #1\",\n  \"description\": \"My NFT Collection\",\n  \"image\": \"https://arweave.net/26YdhY_eAzv26YdhY1uu9uiA3nmDZYwP8MwZAultcE?ext=jpeg\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://www.arweave.net/abcd5678?ext=png\",\n        \"type\": \"image/png\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Guards in TypeScript\nDESCRIPTION: Demonstrates how to create a Candy Machine with enabled guards using the Umi library. Sets up bot tax, SOL payment, and start date guards while disabling others.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.01), lastInstruction: true }),\n    solPayment: some({ lamports: sol(1.5), destination: treasury }),\n    startDate: some({ date: dateTime('2023-04-04T16:00:00Z') }),\n    // All other guards are disabled...\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting and Transferring cNFTs on Alternative SVMs\nDESCRIPTION: Complete example demonstrating how to mint a compressed NFT and then transfer it to a new owner on any SVM environment, using the getCompressionPrograms helper for program ID resolution.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-interact-with-cnfts-on-other-svms.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchMerkleTree,\n  getCurrentRoot,\n  hashMetadataCreators,\n  hashMetadataData,\n  transfer,\n  getCompressionPrograms,\n  createTree,\n  MetadataArgsArgs,\n  mintV1,\n} from '@metaplex-foundation/mpl-bubblegum'\nimport {\n  generateSigner,\n  none,\n} from '@metaplex-foundation/umi';\n\n// Get leaf index before minting.\nconst leafIndex = Number(\n  (await fetchMerkleTree(umi, merkleTree.publicKey)).tree.activeIndex\n);\n\n// Define Metadata.\nconst metadata: MetadataArgsArgs = {\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n  sellerFeeBasisPoints: 500, // 5%\n  collection: none(),\n  creators: [],\n};\n\n// Mint a cNFT.\nconst originalOwner = generateSigner(umi);\nconst mintTxn = await mintV1(umi, {\n  leafOwner: originalOwner.publicKey,\n  merkleTree: merkleTree.publicKey,\n  metadata,\n  ...(await getCompressionPrograms(umi)),\n}).sendAndConfirm(umi);\n\n// Transfer the cNFT to a new owner.\nconst newOwner = generateSigner(umi);\nconst merkleTreeAccount = await fetchMerkleTree(umi, merkleTree.publicKey);\nconst transferTxn = await transfer(umi, {\n  leafOwner: originalOwner,\n  newLeafOwner: newOwner.publicKey,\n  merkleTree: merkleTree.publicKey,\n  root: getCurrentRoot(merkleTreeAccount.tree),\n  dataHash: hashMetadataData(metadata),\n  creatorHash: hashMetadataCreators(metadata.creators),\n  nonce: leafIndex,\n  index: leafIndex,\n  proof: [],\n  ...(await getCompressionPrograms(umi)),\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Minting NFTs with Guard Groups using Umi Library in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates minting NFTs using the Umi library from a Core Candy Machine configured with guard groups. Dependencies include the Umi library. Key inputs are the candy machine ID, asset details, collection ID, and group label. Outputs include confirmation of minting. Constraints include setting the correct compute unit limit and providing necessary mint arguments for resolved guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/mint.md#2025-04-17_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Create a Core Candy Machine with guards.\\nconst thirdPartySigner = generateSigner()\\nawait create(umi, {\\n  // ...\\n  guards: {\\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\\n    thirdPartySigner: some({ signer: thirdPartySigner.publicKey }),\\n    startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\\n  },\\n  groups: [\\n    {\\n      label: 'nft',\\n      guards: {\\n        nftPayment: some({ requiredCollection, destination: nftTreasury }),\\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\\n      },\\n    },\\n    {\\n      label: 'public',\\n      guards: {\\n        solPayment: some({ lamports: sol(1), destination: solTreasury }),\\n      },\\n    },\\n  ],\\n}).sendAndConfirm(umi)\\n\\n// Mint from the Core Candy Machine.\\n\\nconst candyMachineId = publicKey('11111111111111111111111111111111')\\nconst coreCollection = publicKey('22222222222222222222222222222222')\\nconst asset = generateSigner(umi)\\n\\nawait transactionBuilder()\\n  .add(setComputeUnitLimit(umi, { units: 300_000 }))\\n  .add(\\n    mintV1(umi, {\\n      candyMachine: candyMachineId,\\n      asset,\\n      collection: coreCollection,\\n      group: some('nft'),\\n      mintArgs: {\\n        thirdPartySigner: some({ signer: thirdPartySigner }),\\n        nftPayment: some({\\n          mint: nftFromRequiredCollection.publicKey,\\n          destination: nftTreasury,\\n          tokenStandard: TokenStandard.NonFungible,\\n        }),\\n      },\\n    })\\n  )\\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Uploading Metadata JSON to Arweave using Umi in JavaScript\nDESCRIPTION: This snippet shows how to upload the metadata JSON to Arweave using Umi's uploadJson() function, which automatically converts the JavaScript object to JSON before uploading.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Call upon Umi's `uploadJson()` function to upload our metadata to Arweave via Irys.\nconst metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n  throw new Error(err)\n})\n```\n\n----------------------------------------\n\nTITLE: Minting NFT Core Asset using Metaplex in TypeScript\nDESCRIPTION: This code snippet demonstrates how to mint an NFT core asset using the create function from the @metaplex-foundation/mpl-core package, including generating a signer and sending the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = generateSigner(umi)\n\nconst tx = await create(umi, {\n  asset,\n  name: 'My NFT',\n  uri: metadataUri,\n}).sendAndConfirm(umi)\n\nconst signature = base58.deserialize(tx.signature)[0]\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple MPL Core Collection in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic Metaplex Core collection without any plugins using TypeScript and the Umi library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createCollection } from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\n\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n})\n```\n\n----------------------------------------\n\nTITLE: Minting with Third Party Signer and Mint Limit Guards using Umi\nDESCRIPTION: This snippet demonstrates how to mint from a Core Candy Machine using the Umi library when the Candy Machine has guards such as the Third Party Signer and Mint Limit guards. It involves creating a transaction builder, setting the compute unit limit, and adding the mintV1 instruction with appropriate mintArgs for each guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/mint.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  some,\n  generateSigner,\n  transactionBuilder,\n} from '@metaplex-foundation/umi'\nimport { create, mintV1 } from '@metaplex-foundation/mpl-core-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\n\n// Create a Core Candy Machine with guards.\nconst thirdPartySigner = generateSigner()\nawait create(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signer: thirdPartySigner.publicKey }),\n    mintLimit: some({ id: 1, limit: 3 }),\n  },\n}).sendAndConfirm(umi)\n\n// Mint from the Core Candy Machine.\nconst nftMint = generateSigner(umi)\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 300_000 }))\n  .add(\n    mintV1(umi, {\n      candyMachine: candyMachineId,\n      asset,\n      collection: coreCollection,\n      mintArgs: {\n        thirdPartySigner: some({ signer: thirdPartySigner }),\n        mintLimit: some({ id: 1 }),\n      },\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Writing Data to Inscription Account with JavaScript\nDESCRIPTION: This snippet illustrates how to write data to an Inscription account using the `writeData` method from the Metaplex Foundation's SDK. The function requires an inscribed account's public key, metadata account, authority, and the value to be stored as a Buffer. Expected inputs include the inscription account details and the value in JSON format. The output is the successful writing of data to the account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/write.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { writeData } from '@metaplex-foundation/mpl-inscription';\n\nawait writeData(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n  inscriptionMetadataAccount,\n  authority,\n  value: Buffer.from(\n    '{\"description\": \"A bread! But onchain!\", \"external_url\": \"https://breadheads.io\"}'\n  ),\n  associatedTag: null,\n  offset: 0,\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching All Digital Assets With Token by Mint\nDESCRIPTION: Helper function to fetch all Digital Assets With Token for a given Mint account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetWithTokenByMint } from '@metaplex-foundation/mpl-token-metadata'\n\nconst assets = await fetchAllDigitalAssetWithTokenByMint(umi, mint)\n```\n\n----------------------------------------\n\nTITLE: Initializing NPM Project for Solana cNFT Development\nDESCRIPTION: Command to initialize a new npm project which will serve as the foundation for creating compressed NFTs on Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Complete cNFT Creation Workflow in TypeScript\nDESCRIPTION: This is a comprehensive implementation of the entire cNFT workflow including setting up Umi, creating a Merkle Tree, creating a collection NFT, uploading metadata, minting a cNFT, and fetching the asset. The code demonstrates all the necessary steps from initialization to verification in a production-ready format.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTree,\n  findLeafAssetIdPda,\n  mintToCollectionV1,\n  mplBubblegum,\n  parseLeafFromMintV1Transaction\n} from '@metaplex-foundation/mpl-bubblegum'\nimport {\n  createNft,\n  mplTokenMetadata,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  createGenericFile,\n  generateSigner,\n  keypairIdentity,\n  percentAmount,\n  publicKey\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport fs from 'fs'\n\n// Create the wrapper function\nconst createCnft = async () => {\n  //\n  // ** Set Up Umi **\n  //\n\n  // In this instance we are using a locally stored wallet. This can be replaced\n  // with the code from 'generating a new wallet' if need be but make sure you\n  // airdrop/send at least 7.7 SOL to the new wallet.\n\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplBubblegum())\n    .use(mplTokenMetadata())\n    .use(\n      irysUploader({\n        // mainnet address: \"https://node1.irys.xyz\"\n        // devnet address: \"https://devnet.irys.xyz\"\n        address: 'https://devnet.irys.xyz',\n      })\n    )\n\n  // Generate a new keypair signer.\n  const signer = generateSigner(umi)\n\n  // You will need to us fs and navigate the filesystem to\n  // load the wallet you wish to use via relative pathing.\n  const walletFile = fs.readFileSync('./keypair.json')\n\n  // Convert your walletFile onto a keypair.\n  let keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile))\n\n  // Load the keypair into umi.\n  umi.use(keypairIdentity(keypair))\n\n  //\n  // ** Create a Merkle Tree **\n  //\n\n  const merkleTree = generateSigner(umi)\n\n  console.log(\n    'Merkle Tree Public Key:',\n    merkleTree.publicKey,\n    '\\nStore this address as you will need it later.'\n  )\n\n  //   Create a tree with the following parameters.\n  //   This tree will cost approximately 7.7 SOL to create with a maximum\n  //   capacity of 1,000,000 leaves/nfts. You may have to airdrop some SOL\n  //   to the umi identity account before running this script.\n\n  console.log('Creating Merkle Tree...')\n  const createTreeTx = await createTree(umi, {\n    merkleTree,\n    maxDepth: 20,\n    maxBufferSize: 64,\n    canopyDepth: 14,\n  })\n\n  await createTreeTx.sendAndConfirm(umi)\n\n  //\n  // ** Create Token Metadata Collection NFT (Optional) **\n  //\n\n  //\n  // If you wish to mint a NFT to a collection you must first create a collection NFT.\n  // This step is optional and you can skip it if you do not wish to mint a NFT to a collection\n  // or have previously created a collection NFT.\n  //\n\n  const collectionSigner = generateSigner(umi)\n\n  // Path to image file\n  const collectionImageFile = fs.readFileSync('./collection.png')\n\n  const genericCollectionImageFile = createGenericFile(\n    collectionImageFile,\n    'collection.png'\n  )\n\n  const collectionImageUri = await umi.uploader.upload([\n    genericCollectionImageFile,\n  ])\n\n  const collectionMetadata = {\n    name: 'My cNFT Collection',\n    image: collectionImageUri[0],\n    externalUrl: 'https://www.example.com',\n    properties: {\n      files: [\n        {\n          uri: collectionImageUri[0],\n          type: 'image/png',\n        },\n      ],\n    },\n  }\n\n  console.log('Uploading Collection Metadata...')\n  const collectionMetadataUri = await umi.uploader.uploadJson(\n    collectionMetadata\n  )\n\n  console.log('Creating Collection NFT...')\n  await createNft(umi, {\n    mint: collectionSigner,\n    name: 'My cNFT Collection',\n    uri: 'https://www.example.com/collection.json',\n    isCollection: true,\n    sellerFeeBasisPoints: percentAmount(0),\n  }).sendAndConfirm(umi)\n\n  //\n  //   ** Upload Image and Metadata used for the NFT (Optional) **\n  //\n\n  //   If you already have an image and metadata file uploaded, you can skip this step\n  //   and use the uri of the uploaded files in the mintV1 call.\n\n  //   Path to image file\n  const nftImageFile = fs.readFileSync('./nft.png')\n\n  const genericNftImageFile = createGenericFile(nftImageFile, 'nft.png')\n\n  const nftImageUri = await umi.uploader.upload([genericNftImageFile])\n\n  const nftMetadata = {\n    name: 'My cNFT',\n    image: nftImageUri[0],\n    externalUrl: 'https://www.example.com',\n    attributes: [\n      {\n        trait_type: 'trait1',\n        value: 'value1',\n      },\n      {\n        trait_type: 'trait2',\n        value: 'value2',\n      },\n    ],\n    properties: {\n      files: [\n        {\n          uri: nftImageUri[0],\n          type: 'image/png',\n        },\n      ],\n    },\n  }\n\n  console.log('Uploading cNFT metadata...')\n  const nftMetadataUri = await umi.uploader.uploadJson(nftMetadata)\n\n  //\n  // ** Mint a Compressed NFT to the Merkle Tree **\n  //\n\n  //\n  // If you do not wish to mint a NFT to a collection you can set the collection\n  // field to `none()`.\n  //\n\n  // The owner of the cNFT being minted.\n  const newOwner = publicKey('111111111111111111111111111111')\n\n  console.log('Minting Compressed NFT to Merkle Tree...')\n\nconst { signature } = await mintToCollectionV1(umi, {\n  leafOwner: newOwner,\n  merkleTree: merkleTree.publicKey,\n  collectionMint: collectionSigner.publicKey,\n  metadata: {\n    name: 'My cNFT',\n    uri: nftMetadataUri, // Either use `nftMetadataUri` or a previously uploaded uri.\n    sellerFeeBasisPoints: 500, // 5%\n    collection: { key: collectionSigner.publicKey, verified: false },\n    creators: [\n      {\n        address: umi.identity.publicKey,\n        verified: true,\n        share: 100,\n      },\n    ],\n  },\n}).sendAndConfirm(umi, { send: { commitment: 'finalized' } })\n\n  //\n  // ** Fetching Asset **\n  //\n\n  //\n  // Here we find the asset ID of the compressed NFT using the leaf index of the mint transaction\n  // and then log the asset information.\n  //\n\n  console.log('Finding Asset ID...')\n  const leaf = await parseLeafFromMintV1Transaction(umi, signature)\n  const assetId = findLeafAssetIdPda(umi, {\n    merkleTree: merkleTree.publicKey,\n    leafIndex: leaf.nonce,\n  })\n\n  console.log('Compressed NFT Asset ID:', assetId.toString())\n\n  // Fetch the asset using umi rpc with DAS.\n  const asset = await umi.rpc.getAsset(assetId[0])\n\n  console.log({ asset })\n};\n\n// run the wrapper function\ncreateCnft();\n```\n\n----------------------------------------\n\nTITLE: Adding Metadata to a Solana Token\nDESCRIPTION: Demonstrates how to add metadata to an existing SPL token using Metaplex's createV1 helper method\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Sample Metadata for our Token\nconst tokenMetadata = {\n\tname: \"Solana Gold\",\n\tsymbol: \"GOLDSOL\",\n\turi: \"https://raw.githubusercontent.com/solana-developers/program-examples/new-examples/tokens/tokens/.assets/spl-token.json\",\n};\n\n// Add metadata to an existing SPL token wrapper function\nasync function addMetadata() {\n    const mint = publicKey(\"YOUR_TOKEN_MINT_ADDRESS\");\n\n    // derive the metadata account that will store our metadata data onchain\n\tconst metadataAccountAddress = await findMetadataPda(umi, {\n\t\tmint: mint,\n\t});\n\n   // add metadata to our already initialized token using `createV1` helper \n\tconst tx = await createV1(umi, {\n\t\tmint,\n\t\tauthority: umi.identity,\n\t\tpayer: umi.identity,\n\t\tupdateAuthority: umi.identity,\n\t\tname: tokenMetadata.name,\n\t\tsymbol: tokenMetadata.symbol,\n\t\turi: tokenMetadata.uri,\n\t\tsellerFeeBasisPoints: percentAmount(5.5), // 5.5%\n\t\ttokenStandard: TokenStandard.Fungible,\n\t}).sendAndConfirm(umi);\n\n\tlet txSig = base58.deserialize(tx.signature);\n\tconsole.log(`https://explorer.solana.com/tx/${txSig}?cluster=devnet`);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Token Metadata Imports and Wrapper Function\nDESCRIPTION: Sets up the necessary imports and creates a wrapper function for adding metadata to a Solana token\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n\tcreateV1,\n\tfindMetadataPda,\n\tmplTokenMetadata,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { generateSigner, signerIdentity, sol } from \"@metaplex-foundation/umi\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\n/// \n/// instantiate umi \n///\n\n\n// Add metadata to an existing SPL token wrapper function\nasync function addMetadata() {\n\t///\n\t///\n\t///  code will go in here\n\t///\n\t///\n}\n\n// run the function\naddMetadata();\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Asset With Associated Token\nDESCRIPTION: Helper function to fetch a Digital Asset With Token using Mint and owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchDigitalAssetWithAssociatedToken } from '@metaplex-foundation/mpl-token-metadata'\n\nconst asset = await fetchDigitalAssetWithAssociatedToken(umi, mint, owner)\n```\n\n----------------------------------------\n\nTITLE: Uploading Image and Metadata for Compressed NFT on Solana\nDESCRIPTION: TypeScript code that demonstrates how to upload an image file to decentralized storage, create NFT metadata incorporating the image, and upload the complete metadata JSON for use in minting a compressed NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n//\n//   ** Upload Image and Metadata used for the NFT (Optional) **\n//\n\n//   If you already have an image and metadata file uploaded, you can skip this step\n//   and use the uri of the uploaded files in the mintV1 call.\n\n//   Path to image file\nconst nftImageFile = fs.readFileSync('./nft.png')\n\nconst genericNftImageFile = createGenericFile(nftImageFile, 'nft.png')\n\nconst nftImageUri = await umi.uploader.upload([genericNftImageFile])\n\nconst nftMetadata = {\n  name: 'My cNFT',\n  image: nftImageUri[0],\n  externalUrl: 'https://www.example.com',\n  attributes: [\n    {\n      trait_type: 'trait1',\n      value: 'value1',\n    },\n    {\n      trait_type: 'trait2',\n      value: 'value2',\n    },\n  ],\n  properties: {\n    files: [\n      {\n        uri: nftImageUri[0],\n        type: 'image/png',\n      },\n    ],\n  },\n}\n\nconst nftMetadataUri = await umi.uploader.uploadJson(nftMetadata)\n```\n\n----------------------------------------\n\nTITLE: Fetching an MPL Core Collection in TypeScript\nDESCRIPTION: This snippet demonstrates how to fetch a Metaplex Core collection using TypeScript and the Umi library. It retrieves the collection data using the collection's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchCollectionV1 } from '@metaplex-foundation/mpl-core'\nimport { publicKey } from '@metaplex-foundation/umi'\n\nconst collectionId = publicKey('11111111111111111111111111111111')\n\nconst collection = await fetchCollection(umi, collectionId)\n\nconsole.log(collection)\n```\n\n----------------------------------------\n\nTITLE: Complete Candy Machine V2 Creation and NFT Minting Process in JavaScript\nDESCRIPTION: This comprehensive code example demonstrates the entire process of creating a Candy Machine with a mint limit guard and minting an NFT. It includes setup, creating a collection NFT, creating the Candy Machine, and minting an NFT to a recipient wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  addConfigLines,\n  create,\n  fetchCandyMachine,\n  mintV2,\n  mplCandyMachine,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  percentAmount,\n  publicKey,\n  sol,\n  some,\n  transactionBuilder,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createNft,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { base58 } from \"@metaplex-foundation/umi-serializers\";\nimport {\n  createMintWithAssociatedToken,\n  findAssociatedTokenPda,\n  setComputeUnitLimit,\n} from \"@metaplex-foundation/mpl-toolbox\";\n\n/**\n * This script demonstrates how to create a Candy Machine with a mint limit guard\n * and mint an NFT to a recipient wallet.\n */\n\n// Configuration\nconst RECIPIENT_ADDRESS = \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\";\nconst RPC_ENDPOINT = \"ENDPOINT\";\n\n(async () => {\n  try {\n    // --- Setup ---\n    \n    // Initialize connection to Solana\n    const umi = createUmi(RPC_ENDPOINT).use(mplCandyMachine());\n    const recipient = publicKey(RECIPIENT_ADDRESS);\n\n    // Create and fund a test wallet\n    const walletSigner = generateSigner(umi);\n    umi.use(keypairIdentity(walletSigner));\n    console.log(\"Funding test wallet with devnet SOL...\");\n    await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1), {\n      commitment: \"finalized\",\n    });\n\n    // --- Create Collection NFT ---\n    \n    const collectionMint = generateSigner(umi);\n    console.log(\"Creating collection NFT...\");\n    console.log(\"Collection Address:\", collectionMint.publicKey);\n\n    const createNftTx = await createNft(umi, {\n      mint: collectionMint,\n      authority: umi.identity,\n      name: \"My Collection NFT\",\n      uri: \"https://example.com/path/to/some/json/metadata.json\",\n      sellerFeeBasisPoints: percentAmount(9.99, 2),\n      isCollection: true,\n    }).sendAndConfirm(umi, {\n      confirm: { commitment: \"finalized\" },\n    });\n    console.log(\"Collection Created:\", base58.deserialize(createNftTx.signature)[0]);\n\n    // --- Create Candy Machine ---\n\n    console.log(\"Creating Candy Machine with mint limit guard...\");\n    const candyMachine = generateSigner(umi);\n    \n    const createCandyMachineV2Tx = await (\n      await create(umi, {\n        candyMachine,\n        tokenStandard: TokenStandard.NonFungible,\n        collectionMint: collectionMint.publicKey,\n        collectionUpdateAuthority: umi.identity,\n        itemsAvailable: 2,\n        sellerFeeBasisPoints: percentAmount(1.23),\n        creators: [\n          {\n            address: umi.identity.publicKey,\n            verified: false,\n            percentageShare: 100,\n          },\n        ],\n        guards: {\n          mintLimit: some({\n            id: 1,\n            limit: 2,\n          }),\n        },\n        configLineSettings: some({\n          prefixName: \"My NFT #\",\n          nameLength: 3,\n          prefixUri: \"https://example.com/\",\n          uriLength: 29,\n          isSequential: false,\n        }),\n      })\n    )\n      .add(\n        addConfigLines(umi, {\n          candyMachine: candyMachine.publicKey,\n          index: 0,\n          configLines: [\n            { name: \"1\", uri: \"https://example.com/nft1.json\" },\n            { name: \"2\", uri: \"https://example.com/nft2.json\" },\n          ],\n        })\n      )\n      .sendAndConfirm(umi, { confirm: { commitment: \"finalized\" } });\n      \n    console.log(\"Candy Machine Created:\", base58.deserialize(createCandyMachineV2Tx.signature)[0]);\n\n    // --- Mint NFT ---\n\n    console.log(\"Minting NFT to recipient...\");\n    \n    // Get latest Candy Machine state\n    const candyMachineAccount = await fetchCandyMachine(umi, candyMachine.publicKey);\n\n    // Create mint transaction\n    const nftMint = generateSigner(umi);\n    const mintTx = await transactionBuilder()\n      .add(setComputeUnitLimit(umi, { units: 800_000 }))\n      .add(\n        createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient })\n      )\n      .add(\n        mintV2(umi, {\n          candyMachine: candyMachineAccount.publicKey,\n          nftMint,\n          token: findAssociatedTokenPda(umi, {\n            mint: nftMint.publicKey,\n            owner: recipient,\n          }),\n          collectionMint: candyMachineAccount.collectionMint,\n          collectionUpdateAuthority: candyMachineAccount.authority,\n          tokenStandard: TokenStandard.NonFungible,\n          mintArgs: {\n            mintLimit: some({\n              id: 1,\n            }),\n          },\n        })\n      )\n      .sendAndConfirm(umi, {\n        confirm: { commitment: \"finalized\" },\n      });\n\n    console.log(\"NFT Minted Successfully!\");\n    console.log(\"Mint Transaction:\", base58.deserialize(mintTx.signature)[0]);\n\n  } catch (error) {\n    console.error(\"Failed to execute:\", error);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Uploading Asset Data using Umi Uploader\nDESCRIPTION: Demonstrates how to upload image and JSON metadata for a digital asset using the Umi SDK's uploader plugin system. The code uploads an image file and creates a JSON metadata object with the image URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst [imageUri] = await umi.uploader.upload([imageFile])\nconst uri = await umi.uploader.uploadJson({\n  name: 'My NFT',\n  description: 'This is my NFT',\n  image: imageUri,\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Minting NFT with Guards using Candy Machine V2 in JavaScript\nDESCRIPTION: This code snippet demonstrates how to mint an NFT from a Candy Machine with guards. It creates the necessary Token Account and Associated Token Account for the recipient, allowing them to receive the NFT without signing the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst candyMachineAccount = await fetchCandyMachine(umi, publicKey(\"CM Address\"));\n\nconst recipient = publicKey('Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV')\nconst nftMint = generateSigner(umi)\nconst mintTx = await transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient }))\n  .add(\n    mintFromCandyMachineV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      mintAuthority: umi.identity,\n      nftOwner: recipient,\n      nftMint,\n      collectionMint: candyMachineAccount.collectionMint,\n      collectionUpdateAuthority: candyMachineAccount.authority,\n    })\n  )\n  .sendAndConfirm(umi, {\n    confirm: { commitment: 'finalized' },\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with an Existing Wallet for Core NFT Asset Creation\nDESCRIPTION: Sets up Umi using an existing wallet loaded from a file system. This approach is suitable for production environments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n    .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// You will need to us fs and navigate the filesystem to\n// load the wallet you wish to use via relative pathing.\nconst walletFile = fs.readFileSync('./keypair.json')\n\n\n// Convert your walletFile onto a keypair.\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\n// Load the keypair into umi.\numi.use(keypairIdentity(umiSigner));\n```\n\n----------------------------------------\n\nTITLE: Creating Collection and Minting Asset with Metaplex and UMI in TypeScript\nDESCRIPTION: This snippet demonstrates the process of creating a collection and minting an NFT asset using Metaplex and UMI on Solana's devnet. It includes steps for initializing UMI, generating signers, creating a collection, serializing and deserializing transactions, and minting an asset. The code also handles airdropping SOL to wallets and logging transaction details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, createSignerFromKeypair, signerIdentity, sol, createNoopSigner, transactionBuilder } from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { base58 } from '@metaplex-foundation/umi/serializers';\nimport { createCollection, create, fetchCollection } from '@metaplex-foundation/mpl-core'\n\nconst umi = createUmi(\"https://api.devnet.solana.com\", \"finalized\")\n\nconst collectionAuthority = generateSigner(umi);\numi.use(signerIdentity(collectionAuthority));\n\nconst frontEndSigner = generateSigner(umi);\n\n(async () => {\n  \n  // Airdrop Tokens inside of the wallets\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1));\n  await umi.rpc.airdrop(frontEndSigner.publicKey, sol(1));\n\n  // Generate the Collection KeyPair\n  const collectionAddress = generateSigner(umi)\n  console.log(\"\\nCollection Address: \", collectionAddress.publicKey.toString())\n\n  // Generate the collection\n  let createCollectionTx = await createCollection(umi, {\n    collection: collectionAddress,\n    name: 'My Collection',\n    uri: 'https://example.com/my-collection.json',\n  }).sendAndConfirm(umi)\n\n  const createCollectionSignature = base58.deserialize(createCollectionTx.signature)[0]\n  console.log(`\\nCollection Created: https://solana.fm/tx/${createCollectionSignature}?cluster=devnet-alpha`);\n\n  // Serialize\n  \n  const asset = generateSigner(umi);\n  console.log(\"\\nAsset Address: \", asset.publicKey.toString());\n\n  const collection = await fetchCollection(umi, collectionAddress.publicKey); \n\n  let createAssetIx = await create(umi, {\n    asset: asset,\n    collection: collection,\n    authority: collectionAuthority,\n    payer: createNoopSigner(frontEndSigner.publicKey),\n    owner: frontEndSigner.publicKey,\n    name: 'My NFT',\n    uri: 'https://example.com/my-nft.json',\n  })\n    .useV0()\n    .setBlockhash(await umi.rpc.getLatestBlockhash())\n    .buildAndSign(umi);\n\n\n  const serializedCreateAssetTx = umi.transactions.serialize(createAssetTx)\n  const serializedCreateAssetTxAsString = base64.deserialize(serializedCreateAssetTx)[0];\n\n  // Deserialize\n\n  const deserializedCreateAssetTxAsU8 = base64.serialize(serializedCreateAssetTxAsString);\n  const deserializedCreateAssetTx = umi.transactions.deserialize(deserializedCreateAssetTxAsU8)\n  const signedDeserializedCreateAssetTx = await frontEndSigner.signTransaction(deserializedCreateAssetTx)\n\n  const createAssetSignature = base58.deserialize(await umi.rpc.sendTransaction(signedDeserializedCreateAssetTx))[0]\n  console.log(`\\nAsset Created: https://solana.fm/tx/${createAssetSignature}}?cluster=devnet-alpha`);\n})();\n```\n\n----------------------------------------\n\nTITLE: Making Core Asset Immutable with Rust\nDESCRIPTION: This snippet demonstrates how to make a Core Asset fully immutable using the Metaplex Rust SDK. It sets the update authority to 'None', which removes the ability to update the asset and removes it from any collections.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/update.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::UpdateV1Builder, types::UpdateAuthority};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn update_asset_data_to_immutable() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let update_asset_ix = UpdateV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .new_update_authority(UpdateAuthority::None)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let update_asset_tx = Transaction::new_signed_with_payer(\n        &[update_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&update_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset in a Collection using JavaScript and UMI\nDESCRIPTION: This snippet demonstrates how to create an MPL Core Collection and then add an Asset to it using the Metaplex Foundation's UMI library. It includes steps for generating signers, creating the collection, fetching it, and then creating an asset within that collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport {\n  createCollection,\n  create,\n  fetchCollection,\n} from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\n\n// create collection\n// if you are doing this in a single script you may have\n// to use a sleep function or commitment level of 'finalized'\n// so the collection is fully written to change before fetching it.\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n}).sendAndConfirm(umi)\n\n// fetch the collection\nconst collection = await fetchCollection(umi, collectionSigner.publicKey)\n\n\n// generate assetSigner and then create the asset.\nconst assetSigner = generateSigner(umi)\n\nawait create(umi, {\n  asset: assetSigner,\n  collection: collection,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  //owner: publicKey('11111111111111111111111111111111'), //optional to mint into a different wallet\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Collection NFT using JavaScript/TypeScript\nDESCRIPTION: Demonstrates how to create a Collection NFT using the Metaplex SDK. The code shows initialization of a new collection NFT with a name, URI, seller fee, and the isCollection flag set to true.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/collections.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport { createNft } from '@metaplex-foundation/mpl-token-metadata'\n\nconst collectionMint = generateSigner(umi)\nawait createNft(umi, {\n  mint: collectionMint,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n  sellerFeeBasisPoints: percentAmount(5.5), // 5.5%\n  isCollection: true,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting NFT with Candy Machine Guards in Solana using JavaScript\nDESCRIPTION: This code snippet demonstrates how to mint an NFT using a Candy Machine with guards in Solana. It creates the necessary Token and Associated Token Accounts for the recipient, sets compute unit limits, and handles the minting process with specific guard arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst candyMachineAccount = await fetchCandyMachine(umi, publicKey(\"CM Address\"));\n\nconst recipient = publicKey('Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV')\nconst nftMint = generateSigner(umi)\nconst mintTx = await transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachineAccount.publicKey,\n      nftMint,\n      token: findAssociatedTokenPda(umi, {\n        mint: nftMint.publicKey,\n        owner: recipient,\n      }),\n      collectionMint: candyMachineAccount.collectionMint,\n      collectionUpdateAuthority: candyMachineAccount.authority,\n      tokenStandard: TokenStandard.NonFungible,\n      mintArgs: {\n        mintLimit: some({ // The guards that require mintArgs have to be specified here \n          id: 1,\n        }),\n      },\n    })\n  )\n  .sendAndConfirm(umi, {\n    confirm: { commitment: 'finalized' },\n  })\n```\n\n----------------------------------------\n\nTITLE: Complete Candy Machine with ConfigLineSettings in TypeScript\nDESCRIPTION: Shows a complete example of creating a Core Candy Machine with ConfigLineSettings applied, including prefix configurations and sequential settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from '@metaplex-foundation/mpl-core-candy-machine'\n\nconst candyMachine = generateSigner(umi)\n\nconst coreCollection = publicKey('11111111111111111111111111111111')\n\nconst createIx = await create(umi, {\n  candyMachine,\n  collection: coreCollection,\n  collectionUpdateAuthority: umi.identity,\n  itemsAvailable: 5000,\n  configLineSettings: some({\n    prefixName: 'Example Asset #',\n    nameLength: 15,\n    prefixUri: 'https://example.com/metadata/',\n    uriLength: 29,\n    isSequential: false,\n  }),\n})\n\nawait createIx.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring Basic NFT using Token Metadata\nDESCRIPTION: Simple implementation for transferring a non-fungible token (NFT) using the Token Metadata program. The transfer operation requires the mint address, current owner authority, and destination owner's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/transfer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait transferV1(umi, {\n  mint,\n  authority: currentOwner,\n  tokenOwner: currentOwner.publicKey,\n  destinationOwner: newOwner.publicKey,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Mint Account in Solana using Umi\nDESCRIPTION: This snippet demonstrates how to create a new Mint account using Umi. It generates a signer for the mint and sets up the mint with specified decimals, mint authority, and freeze authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createMint } from '@metaplex-foundation/mpl-toolbox'\n\nconst mint = generateSigner(umi)\n\nawait createMint(umi, {\n  mint,\n  decimals: 0,\n  mintAuthority,\n  freezeAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Asset Account in Rust\nDESCRIPTION: Shows how to deserialize an Asset account using RpcClient in Rust, connecting to Solana devnet and parsing account data into BaseAssetV1 structure.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\nlet asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\nlet account = rpc_client.get_account(&asset).await.unwrap();\n\nlet asset_v1 = BaseAssetV1::from_bytes(&account.data).unwrap();\n\nprintln!(\"assetV1: {:?}\", asset_v1);\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi with DAS API Plugin\nDESCRIPTION: Code snippet showing how to create a Umi instance and register the DAS API plugin. The RPC endpoint should support the Metaplex DAS API specification.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { dasApi } from \"@metaplex-foundation/digital-asset-standard-api\"\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\n\nconst umi = createUmi(\"exampleDasProvider.com\").use(dasApi());\n```\n\n----------------------------------------\n\nTITLE: Creating a Core Candy Machine with Hidden Settings using Metaplex Library in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Core Candy Machine with hidden settings using the 'create' method from the 'mpl-core-candy-machine' library. It requires an instance of UMI, a signer for the candy machine, and details for the NFT collection. The configuration includes setting hidden metadata and a start date guard. Inputs include candy machine configurations and the expected output is a transaction confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { create } from '@metaplex-foundation/mpl-core-candy-machine';\n\nconst candyMachine = generateSigner(umi);\n\nconst res = await create(umi, {\n    candyMachine,\n    collection: collectionMint.publicKey,\n    collectionUpdateAuthority: umi.identity,\n    itemsAvailable: 5,\n    configLineSettings: none(),\n    hiddenSettings: some({\n        name: 'My Hidden NFT Project',\n        uri: 'https://example.com/path/to/teaser.json',\n        hash: hash,\n    }),\n    guards: {\n        startDate: some({ date: dateTime('2024-01-01T16:00:00Z') }),\n    }\n});\nlet tx = await res.sendAndConfirm(umi);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Account Structure for Create Event Instruction in Rust\nDESCRIPTION: This code defines the account structure required for the Create Event instruction using Anchor's derive macro. It includes accounts for the signer, payer, manager, event, system program, and MPL core program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CreateEvent<'info> {\n   pub signer: Signer<'info>,\n   #[account(mut)]\n   pub payer: Signer<'info>,\n   #[account(\n       seeds = [MANAGER_SEEDS.as_bytes()],\n       bump = manager.bump\n   )]\n   pub manager: Account<'info, Manager>,\n   #[account(mut)]\n   pub event: Signer<'info>,\n   pub system_program: Program<'info, System>,\n   #[account(address = MPL_CORE_ID)]\n   /// CHECK: This is checked by the address constraint\n   pub mpl_core_program: UncheckedAccount<'info>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Soulbound Asset with Oracle Plugin in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create a soulbound asset using the Oracle Plugin. It initializes the Umi framework, creates a collection, and then creates a soulbound asset within that collection using a special Oracle account that rejects all transfer attempts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst ORACLE_ACCOUNT = publicKey(\n  \"GxaWxaQVeaNeFHehFQEDeKR65MnT6Nup81AGwh2EEnuq\"\n);\n\nawait create(umi, {\n  asset: assetSigner,\n  collection: collection,\n  name: \"My Soulbound Asset\",\n  uri: \"https://example.com/my-asset.json\",\n  plugins: [\n    {\n      // The Oracle plugin allows us to control transfer permissions\n      type: \"Oracle\",\n      resultsOffset: {\n        type: \"Anchor\",\n      },\n      baseAddress: ORACLE_ACCOUNT,\n      lifecycleChecks: {\n        // Configure the Oracle to reject all transfer attempts\n        transfer: [CheckResult.CAN_REJECT],\n      },\n      baseAddressConfig: undefined,\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Minting Compressed NFT without Collection using TypeScript\nDESCRIPTION: Demonstrates how to mint a compressed NFT without associating it with a collection using the mintV1 instruction. Includes setting metadata like name, URI, and creator details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/mint-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { none } from '@metaplex-foundation/umi'\nimport { mintV1 } from '@metaplex-foundation/mpl-bubblegum'\n\nawait mintV1(umi, {\n  leafOwner,\n  merkleTree,\n  metadata: {\n    name: 'My Compressed NFT',\n    uri: 'https://example.com/my-cnft.json',\n    sellerFeeBasisPoints: 500, // 5%\n    collection: none(),\n    creators: [\n      { address: umi.identity.publicKey, verified: false, share: 100 },\n    ],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting from a Core Candy Machine via Candy Guard in TypeScript\nDESCRIPTION: This code demonstrates how to mint an NFT from a Core Candy Machine through its associated Candy Guard. It uses the mintV1 function, providing the candy machine ID, a generated signer for the asset, and the collection public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/mint.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV1 } from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { setComputeUnitLimit } from \"@metaplex-foundation/mpl-toolbox\";\nimport { generateSigner } from \"@metaplex-foundation/umi\";\n\nconst candyMachineId = publicKey(\"11111111111111111111111111111111\");\nconst coreCollection = publicKey(\"22222222222222222222222222222222\");\nconst asset = generateSigner(umi);\n\nawait mintV1(umi, {\n  candyMachine: candyMachineId,\n  asset,\n  collection: coreCollection,\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Creating Optimized Sol Transfer Transaction with Metaplex Umi\nDESCRIPTION: A complete implementation for creating and sending an optimized SOL transfer transaction. The code includes functions for calculating optimal priority fees and compute unit limits, as well as a step-by-step example of the entire transaction flow from wallet initialization to confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/optimal-transactions-with-compute-units-and-priority-fees.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n  sol,\n  publicKey,\n  Transaction,\n  Umi,\n  generateSigner,\n  keypairIdentity,\n  TransactionBuilder,\n} from \"@metaplex-foundation/umi\";\nimport {\n  transferSol,\n  setComputeUnitLimit,\n  setComputeUnitPrice,\n  mplToolbox,\n} from \"@metaplex-foundation/mpl-toolbox\";\nimport { base58, base64 } from \"@metaplex-foundation/umi/serializers\";\n\n/**\n * Calculates the optimal priority fee based on recent transactions\n * This helps ensure our transaction gets processed quickly by offering an appropriate fee\n * @param umi - The Umi instance\n * @param transaction - The transaction to calculate the fee for\n * @returns The average priority fee in microLamports (1 lamport = 0.000000001 SOL)\n */\nexport const getPriorityFee = async (\n  umi: Umi,\n  transaction: TransactionBuilder\n): Promise<number> => {\n  // Get unique writable accounts involved in the transaction\n  // We only care about writable accounts since they affect priority fees\n  const distinctPublicKeys = new Set<string>();\n  \n  transaction.items.forEach(item => {\n    item.instruction.keys.forEach(key => {\n      if (key.isWritable) {\n        distinctPublicKeys.add(key.pubkey.toString());\n      }\n    });\n  });\n  \n  // Query recent prioritization fees for these accounts from the RPC\n  const response = await fetch(umi.rpc.getEndpoint(), {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"getRecentPrioritizationFees\",\n      params: [Array.from(distinctPublicKeys)],\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch priority fees: ${response.status}`);\n  }\n\n  const data = await response.json() as {\n    result: { prioritizationFee: number; slot: number; }[];\n  };\n\n  // Calculate average of top 100 fees to get a competitive rate\n  const fees = data.result?.map(entry => entry.prioritizationFee) || [];\n  const topFees = fees.sort((a, b) => b - a).slice(0, 100);\n  const averageFee = topFees.length > 0 ? Math.ceil(\n    topFees.reduce((sum, fee) => sum + fee, 0) / topFees.length\n  ) : 0;\n  return averageFee;\n};\n\n/**\n * Estimates the required compute units for a transaction\n * This helps prevent compute unit allocation errors while being cost-efficient\n * @param umi - The Umi instance\n * @param transaction - The transaction to estimate compute units for\n * @returns Estimated compute units needed with 10% safety buffer\n */\nexport const getRequiredCU = async (\n  umi: Umi,\n  transaction: Transaction\n): Promise<number> => {\n  // Default values if estimation fails\n  const DEFAULT_COMPUTE_UNITS = 800_000; // Standard safe value\n  const BUFFER_FACTOR = 1.1; // Add 10% safety margin\n\n  // Simulate the transaction to get actual compute units needed\n  const response = await fetch(umi.rpc.getEndpoint(), {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"simulateTransaction\",\n      params: [\n        base64.deserialize(umi.transactions.serialize(transaction))[0],\n        {\n          encoding: \"base64\",\n          replaceRecentBlockhash: true,\n          sigVerify: false,\n        },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to simulate transaction: ${response.status}`);\n  }\n\n  const data = await response.json();\n  const unitsConsumed = data.result?.value?.unitsConsumed;\n\n  // Fallback to default if simulation doesn't provide compute units\n  if (!unitsConsumed) {\n    console.log(\"Simulation didn't return compute units, using default value\");\n    return DEFAULT_COMPUTE_UNITS;\n  }\n\n  // Add safety buffer to estimated compute units\n  return Math.ceil(unitsConsumed * BUFFER_FACTOR);\n};\n\n/**\n * Example usage: Demonstrates how to send SOL with optimized compute units and priority fees\n * This example shows a complete flow of creating and optimizing a Solana transaction\n */\nconst example = async () => {\n  // Step 1: Initialize Umi with your RPC endpoint\n  const umi = createUmi(\"YOUR-ENDPOINT\").use(mplToolbox());\n  \n  // Step 2: Set up a test wallet\n  const signer = generateSigner(umi);\n  umi.use(keypairIdentity(signer));\n  \n  // Step 3: Fund the wallet (devnet only)\n  console.log(\"Requesting airdrop for testing...\");\n  await umi.rpc.airdrop(signer.publicKey, sol(0.001));\n  await new Promise(resolve => setTimeout(resolve, 15000)); // Wait for airdrop confirmation\n  \n  // Step 4: Set up the basic transfer parameters\n  const destination = publicKey(\"BeeryDvghgcKPTUw3N3bdFDFFWhTWdWHnsLuVebgsGSD\");\n  const transferAmount = sol(0.00001); // 0.00001 SOL\n  \n  // Step 5: Create the base transaction\n  console.log(\"Creating base transfer transaction...\");\n  const baseTransaction = await transferSol(umi, {\n    source: signer,\n    destination,\n    amount: transferAmount,\n  }).setLatestBlockhash(umi);\n\n  // Step 6: Calculate optimal priority fee\n  console.log(\"Calculating optimal priority fee...\");\n  const priorityFee = await getPriorityFee(umi, baseTransaction);\n  \n  // Step 7: Create intermediate transaction for compute unit estimation\n  const withCU = baseTransaction.prepend(\n    setComputeUnitPrice(umi, { microLamports: priorityFee })\n  ).prepend(\n    setComputeUnitLimit(umi, { units: 1400000 })\n  );\n\n  // Step 8: Calculate optimal compute unit limit\n  console.log(\"Estimating required compute units...\");\n  const requiredUnits = await getRequiredCU(umi, withCU.build(umi));\n  \n  // Step 9: Build the final optimized transaction\n  const finalTransaction = baseTransaction.prepend(\n    setComputeUnitPrice(umi, { microLamports: priorityFee })\n  ).prepend(\n    setComputeUnitLimit(umi, { units: requiredUnits })\n  );\n  console.log(`Transaction optimized with Priority Fee: ${priorityFee} microLamports and ${requiredUnits} compute units`);\n\n  // Step 10: Send and confirm the transaction\n  console.log(\"Sending optimized transaction...\");\n  const signature = await finalTransaction.sendAndConfirm(umi);\n  console.log(\"Transaction confirmed! Signature:\", base58.deserialize(signature.signature)[0]);\n};\n\n// Run the example\nexample().catch(console.error);\n\n```\n\n----------------------------------------\n\nTITLE: Setting Collection for Token Metadata\nDESCRIPTION: Examples of setting and clearing collection data for an asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncollection: collectionToggle('Set', [\n  {\n    key: publicKey('11111111111111111111111111111111'),\n    verified: false,\n  },\n])\n```\n\nLANGUAGE: rust\nCODE:\n```\ncollection: Some( Collection {\n  key: PubKey,\n  verified: Boolean,\n}),\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Core Candy Machine in TypeScript\nDESCRIPTION: Demonstrates how to create a basic Core Candy Machine using the Metaplex Foundation's MPL Core Candy Machine library. Sets up a candy machine with collection mint and basic configuration parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create the Candy Machine.\nimport { create } from '@metaplex-foundation/mpl-core-candy-machine'\nimport { generateSigner } from '@metaplex-foundation/umi'\n\nconst candyMachine = generateSigner(umi)\n\nconst createIx = await create(umi, {\n  candyMachine,\n  collection: collectionMint.publicKey,\n  collectionUpdateAuthority: umi.identity,\n  itemsAvailable: 1000,\n  authority: umi.identity.publicKey,\n})\n\nawait createIx.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with Royalties Plugin using Rust\nDESCRIPTION: This Rust code shows how to create an MPL Core Asset with a Royalties plugin. It sets up the CreateV1Builder with plugin details including royalty percentage and creator information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{\n    instructions::CreateV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::Royalties(Royalties {\n                basis_points: 500,\n                creators: vec![Creator {\n                    address: creator,\n                    percentage: 100,\n                }],\n                rule_set: RuleSet::None,\n            }),\n            authority: Some(PluginAuthority::None),\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Allow List Guard Route Instruction in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the 'route' function to call the route instruction of an Allow List guard. It includes creating a Candy Machine with an Allow List guard, preparing the allow list, and verifying the Merkle Proof using the route instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-route.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  route,\n  getMerkleProof,\n  getMerkleRoot,\n} from '@metaplex-foundation/mpl-core-candy-machine'\n\n// Prepare the allow list.\n// Let's assume the first wallet on the list is the Metaplex identity.\nconst allowList = [\n  'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n  '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',\n  'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n]\nconst merkleRoot = getMerkleRoot(allowList)\n\n// Create a Candy Machine with an Allow List guard.\nawait create(umi, {\n  // ...\n  guards: {\n    allowList: some({ merkleRoot }),\n  },\n}).sendAndConfirm(umi)\n\n// If we try to mint now, it will fail because\n// we did not verify our Merkle Proof.\n\n// Verify the Merkle Proof using the route instruction.\nawait route(umi, {\n  candyMachine: candyMachine.publicKey,\n  guard: 'allowList',\n  routeArgs: {\n    path: 'proof',\n    merkleRoot,\n    merkleProof: getMerkleProof(\n      allowList,\n      'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS'\n    ),\n  },\n}).sendAndConfirm(umi)\n\n// If we try to mint now, it will succeed.\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Core NFT Asset Creation\nDESCRIPTION: Installs the necessary npm packages for creating Core NFT Assets, including Umi, Core, and Irys uploader.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/mpl-core\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-uploader-irys;\n```\n\n----------------------------------------\n\nTITLE: Defining Digital Asset Types in TypeScript\nDESCRIPTION: Type definitions for the Digital Asset structure that includes Mint, Metadata and Edition accounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from '@metaplex-foundation/umi'\nimport { Mint } from '@metaplex-foundation/mpl-toolbox'\nimport {\n  Metadata,\n  MasterEdition,\n  Edition,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nexport type DigitalAsset = {\n  publicKey: PublicKey\n  mint: Mint\n  metadata: Metadata\n  edition?:\n    | ({ isOriginal: true } & MasterEdition)\n    | ({ isOriginal: false } & Edition)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset in a Collection using Rust\nDESCRIPTION: This Rust code demonstrates the process of creating an MPL Core Collection and then adding an Asset to it. It uses the MPL Core crate and Solana SDK to build and send transactions for creating both the collection and the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::{CreateCollectionV1Builder, CreateV1Builder};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let signer = Keypair::new(); // Load keypair here.\n\n    let collection = Keypair::new();\n\n    let create_collection_ix = CreateCollectionV1Builder::new()\n        .collection(collection.pubkey())\n        .payer(signer.pubkey())\n        .name(\"My Collection\".into())\n        .uri(\"https://example.com/my-collection.json\".into())\n        .instruction();\n\n    let signers = vec![&collection, &signer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_tx = Transaction::new_signed_with_payer(\n        &[create_collection_ix],\n        Some(&signer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res);\n\n    let asset = Keypair::new();\n\n    let create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .collection(Some(collection.pubkey()))\n        .payer(signer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .instruction();\n\n    let signers = vec![&asset, &signer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_tx = Transaction::new_signed_with_payer(\n        &[create_asset_ix],\n        Some(&signer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Fetching NFT Example\nDESCRIPTION: Demonstrates creating a new NFT with specified parameters and fetching its digital asset data using the Token Metadata SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/js.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport {\n  createNft,\n  fetchDigitalAsset,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createNft(umi, {\n  mint,\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n}).sendAndConfirm(umi)\n\nconst asset = await fetchDigitalAsset(umi, mint.publicKey)\n```\n\n----------------------------------------\n\nTITLE: Full Code Example of SOL Transfer\nDESCRIPTION: This comprehensive example showcases a complete SOL transfer process using Umi and MPL Toolbox. It initializes Umi, generates a signer, airdrops SOL for testing, transfers SOL to a specified destination, and logs the transaction signature, demonstrating an end-to-end Solana transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\n\"import { mplToolbox, transferSol } from '@metaplex-foundation/mpl-toolbox'\\nimport {\\n  generateSigner,\\n  publicKey,\\n  signerIdentity,\\n  sol,\\n} from '@metaplex-foundation/umi'\\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\\nimport { base58 } from '@metaplex-foundation/umi/serializers'\\n\\nconst transfer = async () => {\\n  const umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(mplToolbox())\\n\\n  const signer = generateSigner(umi)\\n\\n  umi.use(signerIdentity(signer))\\n\\n  // Airdrop 1 SOL to the identity\\n  // if you end up with a 429 too many requests error, you may have to use\\n  // the filesystem wallet method or change rpcs.\\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1))\\n\\n  //\\n  // Transfer SOL\\n  //\\n\\n  const res = await transferSol(umi, {\\n    source: umi.identity,\\n    destination: publicKey('111111111111111111111111111111'),\\n    amount: sol(1),\\n  }).sendAndConfirm(umi)\\n\\n  // Log the signature of the transaction\\n  console.log(base58.deserialize(res.signature))\\n}\\n\\ntransfer()\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Merkle Tree for Storing 1 Million cNFTs on Solana\nDESCRIPTION: TypeScript code that generates a new Merkle tree with a capacity for 1 million compressed NFTs on Solana. The tree costs approximately 7.7 SOL to create and uses optimized parameters for depth and canopy.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n//\n// ** Create a Merkle Tree **\n//\n\nconst merkleTree = generateSigner(umi)\n\nconsole.log(\n  'Merkle Tree Public Key:',\n  merkleTree.publicKey,\n  '\\nStore this address as you will need it later.'\n)\n\n//   Create a tree with the following parameters.\n//   This tree will cost approximately 7.7 SOL to create with a maximum\n//   capacity of 1,000,000 leaves/nfts. You may have to airdrop some SOL\n//   to the umi identity account before running this script.\n\nconst createTreeTx = await createTree(umi, {\n  merkleTree,\n  maxDepth: 20,\n  maxBufferSize: 64,\n  canopyDepth: 14,\n})\n\nawait createTreeTx.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Uploading Asset Data with Umi Uploader\nDESCRIPTION: Demonstrates how to upload image files and JSON metadata using Umi's uploader interface. Includes configuration for the Irys plugin for Arweave uploads.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst [imageUri] = await umi.uploader.upload([imageFile])\nconst uri = await umi.uploader.uploadJson({\n  name: 'My NFT',\n  description: 'This is my NFT',\n  image: imageUri,\n  // ...\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\n\numi.use(irysUploader())\n```\n\n----------------------------------------\n\nTITLE: Minting a Compressed NFT to a Merkle Tree in TypeScript\nDESCRIPTION: This code demonstrates how to mint a Compressed NFT to a Merkle Tree using the Metaplex Bubblegum library. It includes setting the owner, specifying metadata like name, URI, seller fee, and creators. The cNFT is minted to a collection and sends the transaction with finalized commitment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n//\n// ** Mint a Compressed NFT to the Merkle Tree **\n//\n\n//\n// If you do not wish to mint a NFT to a collection you can set the collection\n// field to `none()`.\n//\n\n// The owner of the cNFT being minted.\nconst newOwner = publicKey('111111111111111111111111111111')\n\nconsole.log('Minting Compressed NFT to Merkle Tree...')\n\nconst { signature } = await mintToCollectionV1(umi, {\n  leafOwner: newOwner,\n  merkleTree: merkleTree.publicKey,\n  collectionMint: collectionSigner.publicKey,\n  metadata: {\n    name: 'My cNFT',\n    uri: nftMetadataUri, // Either use `nftMetadataUri` or a previously uploaded uri.\n    sellerFeeBasisPoints: 500, // 5%\n    collection: { key: collectionSigner.publicKey, verified: false },\n    creators: [\n      {\n        address: umi.identity.publicKey,\n        verified: true,\n        share: 100,\n      },\n    ],\n  },\n}).sendAndConfirm(umi, { send: { commitment: 'finalized' } })\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Fungible Token Capture in MPL-Hybrid\nDESCRIPTION: Demonstrates how to capture (swap to) non-fungible tokens using the MPL-Hybrid protocol. The code initializes the UMI framework, sets up necessary connections, and executes the capture transaction. It includes handling of collection assets, escrow accounts, and fee management.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/swapping.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport fs from 'fs'\nimport bs58 from 'bs58'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { keypairIdentity, publicKey } from '@metaplex-foundation/umi'\nimport {\n  mplHybrid,\n  MPL_HYBRID_PROGRAM_ID,\n  captureV1,\n} from '@metaplex-foundation/mpl-hybrid'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  string,\n  publicKey as publicKeySerializer,\n} from '@metaplex-foundation/umi/serializers'\nimport { fetchAssetsByCollection } from '@metaplex-foundation/mpl-core'\n\nconst RPC = '<INSERT RPC>'\nconst umi = createUmi(RPC)\n\n// THIS IS USING A LOCAL KEYPAIR\nconst parsed_wallet = JSON.parse(fs.readFileSync('<PATH TO KEYPAIR>', 'utf-8'))\nconst kp_wallet = umi.eddsa.createKeypairFromSecretKey(\n  new Uint8Array(parsed_wallet)\n)\n\numi.use(keypairIdentity(kp_wallet))\numi.use(mplHybrid())\numi.use(mplTokenMetadata())\n\nconst COLLECTION = publicKey('<INSERT COLLECTION ACCOUNT/NFT ADDRESS>')\nconst TOKEN = publicKey('<INSERT TOKEN ADDRESS>') // THE TOKEN TO BE DISPENSED\nconst FEE_WALLET = publicKey('<INSERT FEE WALLET>')\n\nconst ESCROW = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n  string({ size: 'variable' }).serialize('escrow'),\n  publicKeySerializer().serialize(COLLECTION),\n])\n\nconst assetsByCollection = await fetchAssetsByCollection(umi, COLLECTION, {\n  skipDerivePlugins: false,\n})\nconst escrowAssets = assetsByCollection.filter(\n  (a) => a.owner === publicKey(ESCROW)\n)\n\nconst captureData = {\n  owner: umi.identity,\n  payer: umi.identity,\n  escrow: ESCROW,\n  asset: escrowAssets[0].publicKey,\n  collection: COLLECTION,\n  feeProjectAccount: FEE_WALLET,\n  token: TOKEN,\n}\n\nconst captureTx = await captureV1(umi, captureData).sendAndConfirm(umi)\n\nconsole.log(bs58.encode(captureTx.signature))\n```\n\n----------------------------------------\n\nTITLE: Creating a Core Candy Machine with Guards in TypeScript\nDESCRIPTION: Shows how to create a Core Candy Machine with specific guards enabled, such as bot tax, SOL payment, and start date. Guards not provided or set to 'none()' are disabled.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nconst createIx = await create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.01), lastInstruction: true }),\n    solPayment: some({ lamports: sol(1.5), destination: treasury }),\n    startDate: some({ date: dateTime('2023-04-04T16:00:00Z') }),\n    // All other guards are disabled...\n  },\n})\n\nawait createIx.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with MPL-Core Rust SDK\nDESCRIPTION: Example of using the CreateV1Builder to create an asset. This script demonstrates how to set up a transaction, sign it, and send it to the Solana network using the MPL-Core SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/sdk/rust.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::CreateV1Builder;\nuse solana_client::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\npub fn create_asset() {\n\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\nlet keypair_path = \".../my-key.json\"\n    let keypair = solana_sdk::signature::read_keypair_file(keypair_path).unwrap();\n    let asset = Keypair::new();\n\n    let create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(keypair.pubkey())\n        .name(\"My Asset\".into())\n        .uri(\"https://example.com/my-asset.json\".into())\n        .instruction();\n\n    let signers = vec![&asset, &keypair];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_tx = Transaction::new_signed_with_payer(\n        &[create_asset_ix],\n        Some(&keypair.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client.send_and_confirm_transaction(&create_asset_tx).await.unwrap();\n\n    println!(\"Signature: {:?}\", res)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Signing Transactions with Umi in TypeScript\nDESCRIPTION: This snippet shows how to build and sign transactions using the TransactionBuilder methods in Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst transaction = builder.build(umi)\n\nconst transaction = await builder.buildWithLatestBlockhash(umi)\n\nconst signedTransaction = await builder.buildAndSign(umi)\n\nconst signedTransactions = await signAllTransactions(transactionArray);\n```\n\n----------------------------------------\n\nTITLE: Displaying Total Minted Assets from Candy Machine\nDESCRIPTION: Code snippet to create a string showing the total number of assets minted out of the total available. This uses the itemsRedeemed and itemsAvailable properties from the Candy Machine data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mintedString = `${candyMachine.itemsRedeemed} / ${candyMachine.itemsAvailable} Assets minted`\n```\n\n----------------------------------------\n\nTITLE: Write NFT JSON data in chunks using JavaScript\nDESCRIPTION: This JavaScript snippet shows the process of writing NFT JSON data to an Inscription in multiple transactions. This is useful to circumnavigate the 1280-byte transaction size limit on the Solana blockchain. It initializes the inscription and then writes data in segments using offsets to maintain data order. Dependencies include the umi library and methods for writing data. Parameters involve the inscription account and the metadata account for correctly addressing the JSON data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst inscriptionAccount = generateSigner(umi)\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nlet builder = new TransactionBuilder()\n\nbuilder = builder.add(\n  initialize(umi, {\n    inscriptionAccount,\n  })\n)\n\nbuilder = builder.add(\n  writeData(umi, {\n    inscriptionAccount: inscriptionAccount.publicKey,\n    inscriptionMetadataAccount,\n    value: Buffer.from('{\"description\": \"A bread! But onchain!\"'),\n    associatedTag: null,\n    offset: 0,\n  })\n)\n\nbuilder = builder.add(\n  writeData(umi, {\n    inscriptionAccount: inscriptionAccount.publicKey,\n    inscriptionMetadataAccount,\n    value: Buffer.from(', \"external_url\":'),\n    associatedTag: null,\n    offset: '{\"description\": \"A bread! But onchain!\"'.length,\n  })\n)\n\nbuilder = builder.add(\n  writeData(umi, {\n    inscriptionAccount: inscriptionAccount.publicKey,\n    inscriptionMetadataAccount,\n    value: Buffer.from(' \"https://breadheads.io\"}'),\n    associatedTag: null,\n    offset: '{\"description\": \"A bread! But onchain!\", \"external_url\":'.length,\n  })\n)\n\nawait builder.sendAndConfirm(umi, { confirm: { commitment: 'finalized' } })\n```\n\n----------------------------------------\n\nTITLE: Initializing MPL-Hybrid Escrow with TypeScript\nDESCRIPTION: This snippet demonstrates initializing an MPL-Hybrid escrow using the umi library. It sets up the necessary accounts and configurations, such as the collection and token addresses. Dependencies include @metaplex-foundation packages like umi-bundle-defaults, mpl-hybrid, and mpl-token-metadata. It requires specifying the RPC server and the keypair file. The main inputs include ESCROW_NAME, COLLECTION address, TOKEN address, and the BASE_URI. Expected output is a successful transaction signature for creating the escrow.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/escrow.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport fs from 'fs'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { keypairIdentity, publicKey } from '@metaplex-foundation/umi'\nimport {\n  mplHybrid,\n  MPL_HYBRID_PROGRAM_ID,\n  initEscrowV1,\n} from '@metaplex-foundation/mpl-hybrid'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  string,\n  publicKey as publicKeySerializer,\n} from '@metaplex-foundation/umi/serializers'\nimport {\n  findAssociatedTokenPda,\n  SPL_ASSOCIATED_TOKEN_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-toolbox'\n\nconst RPC = '<INSERT RPC>'\nconst umi = createUmi(RPC)\n\n// THIS IS USING A LOCAL KEYPAIR\nconst parsed_wallet = JSON.parse(fs.readFileSync('<PATH TO KEYPAIR>', 'utf-8'))\nconst kp_wallet = umi.eddsa.createKeypairFromSecretKey(\n  new Uint8Array(parsed_wallet)\n)\n\numi.use(keypairIdentity(kp_wallet))\numi.use(mplHybrid())\numi.use(mplTokenMetadata())\n\nconst ESCROW_NAME = '<INSERT ESCROW NAME>'\nconst COLLECTION = publicKey('<INSERT COLLECTION ACCOUNT/NFT ADDRESS>')\nconst TOKEN = publicKey('<INSERT TOKEN ADDRESS>') // THE TOKEN TO BE DISPENSED\n\n// METADATA POOL INFO\n// EX. BASE_URI: https://shdw-drive.genesysgo.net/EjNJ6MKKn3mkVbWJL2NhJTyxne6KKZDTg6EGUtJCnNY3/\nconst BASE_URI = '<INSERT BASE_URI>' // required to support metadata updating on swap\n\n// MIN & MAX DEFINE THE RANGE OF URI METADATA TO PICK BETWEEN\nconst MIN = 0 // I.E. https://shdw-drive.genesysgo.net/.../0.json\nconst MAX = 9999 // I.E. https://shdw-drive.genesysgo.net/.../9999.json\n\n// FEE INFO\nconst FEE_WALLET = publicKey('<INSERT FEE WALLET>')\nconst FEE_ATA = findAssociatedTokenPda(umi, { mint: TOKEN, owner: FEE_WALLET })\n\nconst TOKEN_SWAP_BASE_AMOUNT = 1 // USERS RECEIVE THIS AMOUNT WHEN SWAPPING TO FUNGIBLE TOKENS\nconst TOKEN_SWAP_FEE_AMOUNT = 1 // USERS PAY THIS ADDITIONAL AMOUNT WHEN SWAPPING TO NFTS\nconst TOKEN_SWAP_FEE_DECIMALS = 9 // NUMBER OF DECIMALS IN YOUR TOKEN. DEFAULT ON TOKEN CREATION IS 9.\nconst SOL_SWAP_FEE_AMOUNT = 0 // OPTIONAL ADDITIONAL SOLANA FEE TO PAY WHEN SWAPPING TO NFTS\n\n// CURRENT PATH OPTIONS:\n// 0-- NFT METADATA IS UPDATED ON SWAP\n// 1-- NFT METADATA IS NOT UPDATED ON SWAP\nconst PATH = 0\n\nconst ESCROW = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n  string({ size: 'variable' }).serialize('escrow'),\n  publicKeySerializer().serialize(COLLECTION),\n])\n\nconst addZeros = (num: number, numZeros: number) => {\n  return num * Math.pow(10, numZeros)\n}\n\nconst escrowData = {\n  escrow: ESCROW,\n  collection: COLLECTION,\n  token: TOKEN,\n  feeLocation: FEE_WALLET,\n  name: ESCROW_NAME,\n  uri: BASE_URI,\n  max: MAX,\n  min: MIN,\n  amount: addZeros(TOKEN_SWAP_BASE_AMOUNT, TOKEN_SWAP_FEE_DECIMALS),\n  feeAmount: addZeros(TOKEN_SWAP_FEE_AMOUNT, TOKEN_SWAP_FEE_DECIMALS),\n  solFeeAmount: addZeros(SOL_SWAP_FEE_AMOUNT, 9), // SOL HAS 9 DECIMAL PLACES\n  path: PATH,\n  feeAta: FEE_ATA,\n  associatedTokenProgram: SPL_ASSOCIATED_TOKEN_PROGRAM_ID,\n}\n\nconst initTx = await initEscrowV1(umi, escrowData).sendAndConfirm(umi)\n\nconsole.log(bs58.encode(initTx.signature))\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Fungible Token (NFT) in TypeScript\nDESCRIPTION: This snippet shows how to create a Non-Fungible Token (NFT) using the createNft helper function from the @metaplex-foundation/mpl-token-metadata library in TypeScript. It combines the Create V1 and Mint V1 instructions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount, generateSigner } from '@metaplex-foundation/umi'\nimport { createNft } from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createNft(umi, {\n  mint,\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  // optional if you directly want to add to a collection. Need to verify later.\n  // collection: some({ key: collectionMint.publicKey, verified: false }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting Multiple NFTs in One Transaction with Umi SDK in TypeScript\nDESCRIPTION: This snippet demonstrates how to mint multiple NFTs in a single transaction using the Umi SDK's transaction builders. It creates a transaction builder and adds multiple mintV1 instructions to it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nlet builder = transactionBuilder()\n  .add(mintV1(...))\n  .add(mintV1(...))\n```\n\n----------------------------------------\n\nTITLE: Burning NFT Assets with Anchor and MPL Token Metadata\nDESCRIPTION: Demonstrates NFT burning using Anchor framework with MPL Token Metadata integration. Includes account structure and instruction implementation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n\n#[derive(Accounts)]\npub struct NftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    edition: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}\n\npub fn burn_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftBurnMpl<'info>>,\n) -> Result<()> {\n    let owner = ctx.accounts.owner.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let collection_metadata = ctx.accounts.collection_metadata.as_ref().map(|a| a.to_account_info());\n    let mint = ctx.accounts.mint.to_account_info();\n    let token = ctx.accounts.token.to_account_info();\n    let edition = ctx.accounts.edition.to_account_info();\n    let spl_token = ctx.accounts.spl_token.to_account_info();\n    let metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\n    BurnNftCpiBuilder::new(&metadata_program_id)\n        .metadata(&metadata)\n        // if your NFT is part of a collection you will also need to pass in the collection metadata address.\n        .collection_metadata(collection_metadata.as_ref())\n        .owner(&owner)\n        .mint(&mint)\n        .token_account(&token)\n        .master_edition_account(&edition)\n        .spl_token_program(&spl_token)\n        .invoke()?\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Owner in TypeScript\nDESCRIPTION: This snippet shows how to fetch all assets owned by a specific address using the fetchAssetsByOwner() function. It includes an option to skip deriving plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByOwner = await fetchAssetsByOwner(umi, owner, {\n  skipDerivePlugins: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Gate Guard in JavaScript\nDESCRIPTION: Demonstrates how to mint with a Candy Machine that has the Token Gate guard enabled, passing the mint public key as a mint argument.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-gate.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    tokenGate: some({ mint: tokenMint.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Edition Plugin in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create an MPL Core Asset with the Edition Plugin using TypeScript. It generates a new asset signer and creates an asset with the Edition plugin, specifying the edition number.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { \n    create, \n} from '@metaplex-foundation/mpl-core'\n\nconst asset = generateSigner(umi)\n\nconst result = create(umi, {\n  asset: asset,\n  name: 'My Nft',\n  uri: 'https://example.com/my-nft',\n  collection: collectionSigner.publicKey,\n  plugins: [\n    {\n      type: 'Edition',\n      number: 1,\n    }\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Connecting Existing Wallet from Filesystem\nDESCRIPTION: TypeScript code for loading and connecting an existing wallet from the filesystem to Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { createSignerFromKeypair, signerIdentity } from '@metaplex-foundation/umi'\n\nconst umi = createUmi('https://api.devnet.solana.com')\n\nconst walletFile = fs.readFileSync(\n  path.join(__dirname, './keypair.json')\n)\n\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\nconst signer = createSignerFromKeypair(umi, keypair);\n\numi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Transferring Programmable NFT (pNFT) with Token Metadata\nDESCRIPTION: Comprehensive implementation for transferring a programmable NFT (pNFT) including token account management and authorization rules. The process involves fetching the asset, calculating destination token accounts, and handling authorization rules if present.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/transfer.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMplTokenAuthRulesProgramId } from \"@metaplex-foundation/mpl-candy-machine\";\nimport {\n  fetchDigitalAssetWithAssociatedToken,\n  findTokenRecordPda,\n  TokenStandard,\n  transferV1,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\nimport { publicKey, unwrapOptionRecursively } from \"@metaplex-foundation/umi\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\n// The NFT Asset Mint ID\nconst mintId = publicKey(\"11111111111111111111111111111111\");\n\n// Fetch the pNFT Asset with the Token Account\nconst assetWithToken = await fetchDigitalAssetWithAssociatedToken(\n  umi,\n  mintId,\n  umi.identity.publicKey\n);\n\n// The destination wallet\nconst destinationAddress = publicKey(\n  \"22222222222222222222222222222222\"\n);\n\n// Calculates the destination wallet's Token Account\nconst destinationTokenAccount = findAssociatedTokenPda(umi, {\n  mint: mintId,\n  owner: destinationAddress,\n});\n\n// Calculates the destinations wallet's Token Record Account\nconst destinationTokenRecord = findTokenRecordPda(umi, {\n  mint: mintId,\n  token: destinationTokenAccount[0],\n});\n\n// Transfer the pNFT\nconst { signature } = await transferV1(umi, {\n  mint: mintId,\n  destinationOwner: destinationAddress,\n  destinationTokenRecord: destinationTokenRecord,\n  tokenRecord: assetWithToken.tokenRecord?.publicKey,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  // Check to see if the pNFT asset as auth rules.\n  authorizationRules:\n    unwrapOptionRecursively(assetWithToken.metadata.programmableConfig)\n      ?.ruleSet || undefined,\n  // Auth rules program ID\n  authorizationRulesProgram: getMplTokenAuthRulesProgramId(umi),\n  // Some pNFTs may require authorization data if set.\n  authorizationData: undefined,\n}).sendAndConfirm(umi);\n\nconsole.log(\"Signature: \", base58.deserialize(signature));\n```\n\n----------------------------------------\n\nTITLE: Asset-Level Soulbound Implementation\nDESCRIPTION: Complete implementation showing how to create an individual soulbound asset with the Permanent Freeze Delegate Plugin. Includes wallet setup, collection creation, asset creation, and transfer restriction testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { mplCore } from \"@metaplex-foundation/mpl-core\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  publicKey,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createCollection,\n  create,\n  fetchCollection,\n  transfer,\n  fetchAssetV1,\n} from \"@metaplex-foundation/mpl-core\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\nconst DESTINATION_WALLET = publicKey(\"CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d\");\n\n(async () => {\n  const umi = createUmi(\n    \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\"\n  ).use(mplCore());\n\n  const walletSigner = generateSigner(umi);\n  umi.use(keypairIdentity(walletSigner));\n\n  console.log(\"Funding test wallet with devnet SOL...\");\n  await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1));\n\n  console.log(\"Creating parent collection...\");\n  const collectionSigner = generateSigner(umi);\n  await createCollection(umi, {\n    collection: collectionSigner,\n    name: \"My Collection\",\n    uri: \"https://example.com/my-collection.json\",\n  }).sendAndConfirm(umi);\n  \n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  const collection = await fetchCollection(umi, collectionSigner.publicKey);\n  console.log(\"Collection created successfully:\", collectionSigner.publicKey);\n\n  console.log(\"Creating frozen asset...\");\n  const assetSigner = generateSigner(umi);\n  \n  await create(umi, {\n    asset: assetSigner,\n    collection: collection,\n    name: \"My Frozen Asset\",\n    uri: \"https://example.com/my-asset.json\",\n    plugins: [\n      {\n        type: 'PermanentFreezeDelegate',\n        frozen: true,\n        authority: { type: \"None\" },\n      },\n    ],\n  }).sendAndConfirm(umi);\n  \n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  const asset = await fetchAssetV1(umi, assetSigner.publicKey);\n  console.log(\"Frozen asset created successfully:\", assetSigner.publicKey);\n\n  console.log(\n    \"Testing frozen property by attempting a transfer (this should fail)...\"\n  );\n  \n  const transferResponse = await transfer(umi, {\n    asset: asset,\n    newOwner: DESTINATION_WALLET,\n    collection,\n  }).sendAndConfirm(umi, { send: { skipPreflight: true } });\n\n  console.log(\n    \"Transfer attempt signature:\",\n    base58.deserialize(transferResponse.signature)[0]\n  );\n})();\n```\n\n----------------------------------------\n\nTITLE: Inserting Items into Candy Machine with Umi in TypeScript\nDESCRIPTION: This code snippet shows how to use the Umi library to insert items into a Candy Machine. It demonstrates adding config lines with names and URIs, and appending items to the end of existing items.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/insert-items.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 0,\n  configLines: [\n    { name: 'My NFT #1', uri: 'https://example.com/nft1.json' },\n    { name: 'My NFT #2', uri: 'https://example.com/nft2.json' },\n  ],\n}).sendAndConfirm(umi)\n\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: candyMachine.itemsLoaded,\n  configLines: [\n    { name: 'My NFT #3', uri: 'https://example.com/nft3.json' },\n    { name: 'My NFT #4', uri: 'https://example.com/nft4.json' },\n    { name: 'My NFT #5', uri: 'https://example.com/nft5.json' },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Bubblegum Tree in JavaScript\nDESCRIPTION: This code demonstrates how to create a Bubblegum Tree using the mpl-bubblegum library. It generates a new signer for the Merkle Tree account and configures it with the specified maximum depth and buffer size parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/create-trees.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createTree } from '@metaplex-foundation/mpl-bubblegum'\n\nconst merkleTree = generateSigner(umi)\nconst builder = await createTree(umi, {\n  merkleTree,\n  maxDepth: 14,\n  maxBufferSize: 64,\n})\nawait builder.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Defining MetadataArgs Structure in Rust for Bubblegum cNFTs\nDESCRIPTION: This code defines the metadata structure used when minting compressed NFTs (cNFTs) in Bubblegum. It contains fields for basic NFT properties like name, symbol, and URI, as well as more complex properties like royalty information, collection data, and creator information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/hashed-nft-data.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct MetadataArgs {\n    /// The name of the asset\n    pub name: String,\n    /// The symbol for the asset\n    pub symbol: String,\n    /// URI pointing to JSON representing the asset\n    pub uri: String,\n    /// Royalty basis points that goes to creators in secondary sales (0-10000)\n    pub seller_fee_basis_points: u16,\n    /// Immutable, once flipped, all sales of this metadata are considered secondary.\n    pub primary_sale_happened: bool,\n    /// Whether or not the data struct is mutable, default is not\n    pub is_mutable: bool,\n    /// nonce for easy calculation of editions, if present\n    pub edition_nonce: Option<u8>,\n    /// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.\n    pub token_standard: Option<TokenStandard>,\n    /// Collection\n    pub collection: Option<Collection>,\n    /// Uses\n    pub uses: Option<Uses>,\n    /// Which token program version (currently only `TokenProgramVersion::Original`` is supported).\n    pub token_program_version: TokenProgramVersion,\n    /// The array of creators of the cNFT.\n    pub creators: Vec<Creator>,\n}\n```\n\n----------------------------------------\n\nTITLE: Uploading Files to Arweave Via Irys with Umi in JavaScript\nDESCRIPTION: Code example that demonstrates how to upload files to Arweave via Irys using the Umi framework. This snippet creates a Umi instance with irysUploader plugin and uploads multiple files, returning an array of URIs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/preparing-assets.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\n\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(irysUploader())\n\nconst uriUploadArray = await umi.uploader.upload([myFile1, myFile2])\n\nconsole.log(uriUploadArray)\n```\n\n----------------------------------------\n\nTITLE: Setting Up TypeScript Test Environment for Core Collection Creation\nDESCRIPTION: This code sets up the necessary imports and environment for testing the Core Collection creation using TypeScript and Anchor.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as anchor from \"@coral-xyz/anchor\";\nimport { Program } from \"@coral-xyz/anchor\";\nimport { CreateCoreCollectionExample } from \"../target/types/create_core_collection_example\";\nimport { Keypair, SystemProgram } from \"@solana/web3.js\";\nimport { MPL_CORE_PROGRAM_ID } from \"@metaplex-foundation/mpl-core\";\n\ndescribe(\"create-core-asset-example\", () => {\n  anchor.setProvider(anchor.AnchorProvider.env());\n  const wallet = anchor.Wallet.local();\n  const program = anchor.workspace.CreateCoreCollectionExample as Program<CreateCoreCollectionExample>;\n\n  let collection = Keypair.generate();\n\n  it(\"Create Collection\", async () => {\n\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Adding Asset to Collection\nDESCRIPTION: Implementation for creating a new NFT asset and adding it to an existing collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n   // Generate the Asset KeyPair\n   const asset = generateSigner(umi)\n   console.log(\"\\nAsset Address: \", asset.publicKey.toString())\n\n\n   // Pass and Fetch the Collection\n   const collection = publicKey(\"<collection_pubkey>\")\n   const fetchedCollection = await fetchCollection(umi, collection);\n\n\n   // Generate the Asset\n   const tx = await create(umi, {\n       name: 'My NFT',\n       uri: 'https://example.com/my-nft.json',\n       asset,\n       collection: fetchedCollection,\n   }).sendAndConfirm(umi)\n\n\n   // Deserialize the Signature from the Transaction\n   const signature = base58.deserialize(tx.signature)[0];\n   console.log(`Asset added to the Collection: https://solana.fm/tx/${signature}?cluster=devnet-alpha`);\n})();\n```\n\n----------------------------------------\n\nTITLE: Minting directly from Core Candy Machine program in TypeScript\nDESCRIPTION: This code shows how to mint an NFT directly from the Core Candy Machine program instead of using the Candy Guard. This approach requires the mint authority to sign the transaction and allows specifying an explicit asset owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/mint.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintFromCandyMachineV2 } from '@metaplex-foundation/mpl-core-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\nimport { transactionBuilder, generateSigner } from '@metaplex-foundation/umi'\n\nconst candyMachineId = publicKey('11111111111111111111111111111111')\nconst coreCollection = publicKey('22222222222222222222222222222222')\nconst asset = generateSigner(umi)\n\nawait mintAssetFromCandyMachine(umi, {\n  candyMachine: candyMachineId,\n  mintAuthority: umi.identity,\n  assetOwner: umi.identity.publicKey,\n  asset,\n  collection: coreCollection,\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Mutable Edition Plugin in Rust\nDESCRIPTION: This snippet shows how to create an MPL Core asset with a mutable Edition Plugin using Rust. It initializes the asset with an edition number of 1 and allows for future updates.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/edition.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{\n    instructions::CreateV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n    let authority = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Asset\".into())\n        .uri(\"https://example.com/my-asset.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::Edition(Edition {\n                number: 1,\n            })\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Compressed NFT Metadata with Full Example in TypeScript\nDESCRIPTION: This comprehensive example shows how to update a compressed NFT's metadata. It includes fetching the asset with proof, preparing update arguments, and calling the updateMetadata function with various options including collection mint and custom authority signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/update-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  updateMetadata,\n  UpdateArgsArgs,\n} from '@metaplex-foundation/mpl-bubblegum'\n\n// Use the helper to fetch the asset and proof.\nconst assetWithProof = await getAssetWithProof(umi, assetId, {\n  truncateCanopy: true,\n})\n\n// Then we can use it to update metadata for the NFT.\nconst updateArgs: UpdateArgsArgs = {\n  name: some('New name'),\n  uri: some('https://updated-example.com/my-nft.json'),\n}\nawait updateMetadata(umi, {\n  ...assetWithProof,\n  leafOwner,\n  currentMetadata: assetWithProof.metadata,\n  updateArgs,\n  // Optional param. If your authority is a different signer type \n  // than the current umi identity assign that signer here.\n  authority: <Signer>\n  // Optional param. If cNFT belongs to a collection pass it here.\n  collectionMint: publicKey(\"22222222222222222222222222222222\"),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting an NFT with Candy Machine and Umi SDK in TypeScript\nDESCRIPTION: This code snippet shows how to mint an NFT using the Candy Machine and Umi SDK. It generates a new NFT address, calls the mintV1 function with the necessary parameters, and sends the transaction for confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n// Generate the NFT address\nconst nftMint = generateSigner(umi);\n\nawait mintV1(umi, {\n  candyMachine: candyMachine.publicKey,\n  collection: candyMachine.collectionMint,\n  asset: nftMint,\n  candyGuard: candyGuard.publicKey,\n  mintArgs,\n}).sendAndConfirm(umi)\n\nconsole.log(`NFT ${nftMint.publicKey} minted!`)\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with Royalties Plugin using JavaScript and UMI\nDESCRIPTION: This TypeScript code demonstrates how to create an MPL Core Asset with a Royalties plugin using the Metaplex Foundation's UMI library. It sets up creators and their percentages for royalties distribution.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { create, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst creator1 = publicKey('11111111111111111111111111111111')\nconst creator2 = publicKey('22222222222222222222222222222222')\n\nconst assetSigner = generateSigner(umi)\n\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'Royalties',\n      basisPoints: 500,\n      creators: [\n        {\n          address: creator1,\n          percentage: 20,\n        },\n        {\n          address: creator2,\n          percentage: 80,\n        },\n      ],\n      ruleSet: ruleSet('None'), // Compatibility rule set\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring SPL Tokens to Escrow Account in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to transfer SPL Tokens into an escrow account on the Solana blockchain. It requires 'publicKey', 'findAssociatedTokenPda', and 'transferTokens' functions from a Solana library like 'umi'. The snippet shows how to generate Token Account PDAs for both the source and escrow, ensuring the destination token account exists, and finally transferring the tokens. Inputs include token and escrow addresses, and the amount to transfer. The snippet assumes you're connected to the Solana blockchain, and the wallet has sufficient funds for the transfer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/funding-escrow.md#2025-04-17_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n// Address of your escrow configuration.\nconst escrowConfigurationAddress = publicKey('11111111111111111111111111111111')\n// Address of the SPL token.\nconst tokenMint = publicKey('22222222222222222222222222222222')\n\n// Generate the Token Account PDA from the funding wallet.\nconst sourceTokenAccountPda = findAssociatedTokenPda(umi, {\n  owner: umi.identity.publicKey,\n  mint: tokenMint,\n})\n\n// Generate the Token Account PDA for the escrow destination.\nconst escrowTokenAccountPda = findAssociatedTokenPda(umi, {\n  owner: escrowConfigurationAddress,\n  mint: tokenMint,\n})\n\n// Execute transfer of tokens while also checking if the\n// destination token account exists, if not, create it.\nawait createTokenIfMissing(umi, {\n  mint: tokenMint,\n  owner: escrowConfigurationAddress,\n  token: escrowTokenAccountPda,\n  payer: umi.identity,\n})\n  .add(\n    transferTokens(umi, {\n      source: sourceTokenAccountPda,\n      destination: escrowTokenAccountPda,\n      // amount is calculated in lamports and decimals.\n      amount: 100000,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Updating a Core Candy Machine in TypeScript\nDESCRIPTION: This code demonstrates how to update an existing Core Candy Machine's configuration including changing available items, mutability settings, and other properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/update.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateCandyMachine\n} from '@metaplex-foundation/mpl-core-candy-machine'\n\nconst candyMachine = generateSigner(umi)\n\nawait updateCandyMachine(umi, {\n  candyMachine,\n  data: {\n    itemsAvailable: 3333;\n    isMutable: true;\n    configLineSettings: none();\n    hiddenSettings: none();\n}\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching pNFT Asset Data with Associated Token\nDESCRIPTION: Demonstrates how to fetch all necessary accounts for a pNFT including metadata, token account, and token record using the fetchDigitalAssetWithAssociatedToken function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/pnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetWithToken = await fetchDigitalAssetWithAssociatedToken(\n    // Umi instance\n    umi,\n    // Mint ID\n    publicKey(\"11111111111111111111111111111111\"),\n    // Owner\n    publicKey(\"22222222222222222222222222222222\")\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Turbo SDK File Upload System with Solana Integration\nDESCRIPTION: A comprehensive implementation that handles file uploads using Turbo SDK with Solana blockchain integration. The code includes authentication setup, metadata upload handling, folder size calculations, and lamport cost calculations for uploads. It uses various dependencies including @ardrive/turbo-sdk, bs58, and bignumber.js.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { \n    TurboFactory, \n    TurboAuthenticatedClient, \n    lamportToTokenAmount, \n    TurboUploadFolderResponse \n} from '@ardrive/turbo-sdk';\n\nimport bs58 from 'bs58';\nimport path from 'path';\nimport fs from 'fs';\nimport BigNumber from 'bignumber.js';\n\nimport secretKey from \"/path/to/your/kepypair.json\";\n\nconst imageFolderPath = path.join(__dirname, './assets');\nconst metadataFolderPath = path.join(__dirname, './metadata');\n\n(async () => {\n    try {\n        /// Step 1: Setup Turbo\n        const turbo = TurboFactory.authenticated({\n            privateKey: bs58.encode(Uint8Array.from(secretKey)),\n            token: 'solana',\n            gatewayUrl: `https://api.devnet.solana.com`,\n            paymentServiceConfig: { url: \"https://payment.ardrive.dev\" },\n            uploadServiceConfig: { url: \"https://upload.ardrive.dev\" },\n        });\n\n        /// Step 2: Upload Metadata\n        const metadataUploadResponse = await uploadMetadata(turbo);\n    } catch (error) {\n        console.error(\"Error during execution:\", error);\n    }\n})();\n\nasync function uploadMetadata(turbo: TurboAuthenticatedClient): Promise<TurboUploadFolderResponse> {\n    // Calculate and upload metadata folder\n    const requiredLamportsForMetadata = await calculateRequiredLamportsForUpload(\n        turbo,\n        await calculateFolderSize(metadataFolderPath)\n    );\n\n    // Top up wallet if required\n    await turbo.topUpWithTokens({tokenAmount: lamportToTokenAmount(requiredLamportsForMetadata)});\n\n    // Upload metadata folder\n    const metadataUploadResponse = await turbo.uploadFolder({\n        folderPath: metadataFolderPath,\n        dataItemOpts: { tags: [{ name: 'Content-Type', value: 'application/json' }] },\n    });\n\n    console.log('Metadata Manifest ID:', metadataUploadResponse.manifestResponse?.id);\n    return metadataUploadResponse;\n}\n\nfunction calculateFolderSize(folderPath: string): number {\n  return fs.readdirSync(folderPath).reduce((totalSize, item) => {\n    const fullPath = path.join(folderPath, item);\n    \n    const stats = fs.statSync(fullPath);\n\n    return stats.isFile() \n        ? totalSize + stats.size \n        : totalSize + calculateFolderSize(fullPath);\n  }, 0);\n}\n\nasync function calculateRequiredLamportsForUpload(turbo: TurboAuthenticatedClient, fileSize: number): Promise<number> {\n    /// If the file size is less than 105 KiB, then we don't need to pay for it\n    if (fileSize < 107_520) { return 0; }\n\n    /// Check how many winc does it cost to upload the file\n    const uploadPrice = new BigNumber((await turbo.getUploadCosts({ bytes: [fileSize]}))[0].winc);\n\n    /// Check the current Winc balance\n    const currentBalance = new BigNumber((await turbo.getBalance()).winc);\n\n    /// Calculate how much Winc is required to upload the file\n    const requiredWinc = uploadPrice.isGreaterThan(currentBalance)\n        ? uploadPrice.minus(currentBalance)\n        : new BigNumber(0); // If balance is enough, no Winc is required\n\n    /// If the required Winc is 0, we already have enough to upload the file\n    if (requiredWinc.isEqualTo(0)) { return 0; }\n\n    /// Calculate how much Winc 1 SOL is worth (1 SOL = 1_000_000_000 Lamports)\n    const wincForOneSol = new BigNumber((await turbo.getWincForToken({ tokenAmount: 1_000_000_000 })).winc);\n\n    /// Calculate how much SOL is required to upload the file (return in SOL)\n    const requiredSol = requiredWinc.dividedBy(wincForOneSol).toNumber();\n\n    /// Return the amount of SOL required in Lamports\n    return Math.floor(requiredSol * 1_000_000_000)\n}\n```\n\n----------------------------------------\n\nTITLE: Deserializing Collection Account in Rust\nDESCRIPTION: Demonstrates Collection account deserialization using RpcClient in Rust, connecting to Solana devnet and parsing into CollectionV1 structure.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\nlet collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\nlet account = rpc_client.get_account(&collection).await.unwrap();\n\nlet collection_v1 = CollectionV1::from_bytes(&account.data).unwrap();\n\nprintln!(\"collection_V1: {:?}\", collection_v1);\n```\n\n----------------------------------------\n\nTITLE: Installing Umi and DAS API Client Packages\nDESCRIPTION: Installation commands for the required packages including Umi and the DAS API client. This needs to be run in your project directory to set up the dependencies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm install @metaplex-foundation/umi\nnpm install @metaplex-foundation/umi-bundle-defaults\nnpm install @metaplex-foundation/digital-asset-standard-api\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Core Candy Machine Integration\nDESCRIPTION: Command to install the necessary npm packages for interacting with Core Candy Machine, including Umi, Umi defaults bundle, and the Candy Machine Core module.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnpm i @metaplex-foundation/umi @metaplex-foundation/umi-bundle-defaults @metaplex-foundation/mpl-core-candy-machine\n```\n\n----------------------------------------\n\nTITLE: Defining the Context Interface in Umi\nDESCRIPTION: This code snippet defines the `Context` interface in Umi, which bundles core interfaces for interacting with the Solana blockchain. It includes interfaces for downloading, signing, HTTP requests, identity management, program repository, RPC calls, transaction management, and uploading, serving as a central dependency container.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/interfaces.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Context {\n  downloader: DownloaderInterface;\n  eddsa: EddsaInterface;\n  http: HttpInterface;\n  identity: Signer;\n  payer: Signer;\n  programs: ProgramRepositoryInterface;\n  rpc: RpcInterface;\n  transactions: TransactionFactoryInterface;\n  uploader: UploaderInterface;\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Plugin with Default Authority in Rust\nDESCRIPTION: Shows how to add a plugin to an MPL Core Asset using Rust. Implements the FreezeDelegate plugin type with default authority settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddPluginV1Builder,\n    types::{FreezeDelegate, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_plugin_ix = AddPluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_plugin_tx = Transaction::new_signed_with_payer(\n        &[add_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Asset with Rust Client\nDESCRIPTION: Demonstrates asset creation using Rust with the Solana RPC client. Includes transaction building and signing for creating a new asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::CreateV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\n\npub async fn create_asset() {\n\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_tx = Transaction::new_signed_with_payer(\n        &[create_asset_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client.send_and_confirm_transaction(&create_asset_tx).await.unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Minting Core Collection NFT on Solana using Metaplex and Umi\nDESCRIPTION: This snippet demonstrates how to mint a core collection NFT on Solana using the createCollection function from the @metaplex-foundation/mpl-core package and Umi. It generates a signer, creates the collection, and returns the transaction signature.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst collection = generateSigner(umi)\n\nconst tx = await createCollection(umi, {\n  collection,\n  name: 'My Collection',\n  uri: metadataUri,\n}).sendAndConfirm(umi)\n\nconst signature = base58.deserialize(tx.signature)[0]\n```\n\n----------------------------------------\n\nTITLE: Using an Existing Wallet Stored Locally\nDESCRIPTION: This snippet demonstrates how to load an existing wallet from a local file. It initializes Umi, reads a wallet file from the filesystem, converts it into a keypair, and loads the keypair into Umi for signing transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\n\"const umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\\n  .use(mplToolbox())\\n\\n// You will need to use fs and navigate the filesystem to\\n// load the wallet you wish to use via relative pathing.\\nconst walletFile = const imageFile = fs.readFileSync('./keypair.json')\\n\\n// Convert your walletFile onto a keypair.\\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\\n\\n// Load the keypair into umi.\\numi.use(keypairIdentity(umiSigner));\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Candy Machine and Guard Accounts in TypeScript\nDESCRIPTION: Demonstrates the process of creating a Candy Machine without a guard, creating a separate Candy Guard with specific guards (botTax, solPayment, startDate), and then manually associating and dissociating them using the Umi library. The code shows how to configure NFT collection parameters and implement various guard conditions for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, percentAmount, sol, dateTime } from '@metaplex-foundation/umi'\n\n// Create a Candy Machine without a Candy Guard.\nconst candyMachine = generateSigner(umi)\nawait (await createCandyMachineV2(umi, {\n  candyMachine,\n  tokenStandard: TokenStandard.NonFungible,\n  collectionMint: collectionMint.publicKey,\n  collectionUpdateAuthority: umi.identity,\n  itemsAvailable: 100,\n  sellerFeeBasisPoints: percentAmount(1.23),\n  creators: [\n    { address: umi.identity.publicKey, verified: false, percentageShare: 100 },\n  ],\n  configLineSettings: some({\n    prefixName: 'My NFT #',\n    nameLength: 3,\n    prefixUri: 'https://example.com/',\n    uriLength: 20,\n    isSequential: false,\n  }),\n})).sendAndConfirm(umi)\n\n// Create a Candy Guard.\nconst base = generateSigner(umi)\nconst candyGuard = findCandyGuardPda(umi, { base: base.publicKey })\nawait createCandyGuard(umi, {\n  base,\n  guards: {\n    botTax: { lamports: sol(0.01), lastInstruction: false },\n    solPayment: { lamports: sol(1.5), destination: treasury },\n    startDate: { date: dateTime('2022-10-17T16:00:00Z') },\n  },\n}).sendAndConfirm(umi)\n\n// Associate the Candy Guard with the Candy Machine.\nawait wrap(umi, {\n  candyMachine: candyMachine.publicKey,\n  candyGuard,\n}).sendAndConfirm(umi)\n\n// Dissociate them.\nawait unwrap(umi, {\n  candyMachine: candyMachine.publicKey,\n  candyGuard,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Complete Staking Implementation\nDESCRIPTION: Full implementation of the staking functionality including asset fetching, attribute management, and freezing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n    // Pass the Asset and Collection\n    const asset = publicKey(\"6AWm5uyhmHQXygeJV7iVotjvs2gVZbDXaGUQ8YGVtnJo\");\n    const collection = publicKey(\"CYKbtF2Y56QwQLYHUmpAPeiMJTz1DbBZGvXGgbB6VdNQ\")\n\n    // Fetch the Asset Attributes\n    const fetchedAsset = await fetchAsset(umi, asset);\n    console.log(\"\\nThis is the current state of your Asset Attribute Plugin: \", fetchedAsset.attributes);\n\n    const currentTime = new Date().getTime().toString();\n\n    let tx: Transaction;\n\n    // Check if the Asset has an Attribute Plugin attached to it, if not, add it\n    if (!fetchedAsset.attributes) {\n        tx = await transactionBuilder().add(addPlugin(umi, {\n            asset,\n            collection,\n            plugin: {\n            type: \"Attributes\",\n            attributeList: [\n                { key: \"staked\", value: currentTime },\n                { key: \"stakedTime\", value: \"0\" },\n            ],\n            },\n        })).add(addPlugin(umi, {\n            asset,\n            collection,\n            plugin: {\n                type: \"FreezeDelegate\",\n                frozen: true,\n                authority: { type: \"UpdateAuthority\" }\n            }\n        })).buildAndSign(umi);\n    } else {\n        // If it is, fetch the Asset Attribute Plugin attributeList\n        const assetAttribute = fetchedAsset.attributes.attributeList;\n        // Check if the Asset is already been staked\n        const isInitialized = assetAttribute.some(\n            (attribute) => attribute.key === \"staked\" || attribute.key === \"stakedTime\"\n        );\n\n        // If it is, check if it is already staked and if not update the staked attribute\n        if (isInitialized) {\n            const stakedAttribute = assetAttribute.find(\n                (attr) => attr.key === \"staked\"\n            );\n\n            if (stakedAttribute && stakedAttribute.value !== \"0\") {\n                throw new Error(\"Asset is already staked\");\n            } else {\n                assetAttribute.forEach((attr) => {\n                    if (attr.key === \"staked\") {\n                        attr.value = currentTime;\n                    }\n                });\n            }\n        } else {\n            // If it is not, add the staked & stakedTime attribute\n            assetAttribute.push({ key: \"staked\", value: currentTime });\n            assetAttribute.push({ key: \"stakedTime\", value: \"0\" });\n        }\n\n        // Update the Asset Attribute Plugin and Add the FreezeDelegate Plugin\n        tx = await transactionBuilder().add(updatePlugin(umi, {\n            asset,\n            collection,\n            plugin: {\n            type: \"Attributes\",\n                attributeList: assetAttribute,\n            },\n        })).add(addPlugin(umi, {\n            asset,\n            collection,\n            plugin: {\n                type: \"FreezeDelegate\",\n                frozen: true,\n                authority: { type: \"UpdateAuthority\" }\n            }\n        })).buildAndSign(umi);\n    }\n\n    // Deserialize the Signature from the Transaction\n    console.log(`Asset Staked: https://solana.fm/tx/${base58.deserialize(await umi.rpc.sendTransaction(tx))[0]}?cluster=devnet-alpha`);\n})();\n```\n\n----------------------------------------\n\nTITLE: On-Chain Airdrop Claim Verification and Token Transfer in Rust\nDESCRIPTION: This Rust function implements the on-chain claim process, including Merkle proof verification and token transfer. It reconstructs the Merkle root from user data, verifies it against the stored root, and transfers tokens if verification succeeds.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub fn claim_airdrop(\n  ctx: Context<Claim>,\n  amount: u64,\n  hashes: Vec<u8>,\n  index: u64,\n) -> Result<()> {    \n  let airdrop_state = &mut ctx.accounts.airdrop_state;\n\n  // Step 1: Verify that the Signer and Amount are right by computing the original leaf\n  let mut original_leaf = Vec::new();\n  original_leaf.extend_from_slice(&ctx.accounts.signer.key().to_bytes());\n  original_leaf.extend_from_slice(&amount.to_le_bytes());\n  original_leaf.push(0u8); // isClaimed = false\n\n  // Step 2: Verify the Merkle proof against the on-chain root\n  let merkle_proof = MerkleProof::new(\n    HashingAlgorithm::Keccak,\n    32,\n    index as u32,\n    hashes.clone(),\n  );\n\n  let computed_root = merkle_proof\n    .merklize(&original_leaf)\n    .map_err(|_| AirdropError::InvalidProof)?;\n\n  require!(\n    computed_root.eq(&airdrop_state.merkle_root),\n    AirdropError::InvalidProof\n  );\n\n  // Step 3: Execute the transfer\n  let mint_key = ctx.accounts.mint.key().to_bytes();\n  \n  let signer_seeds = &[\n    b\"merkle_tree\".as_ref(),\n    mint_key.as_ref(),\n    &[airdrop_state.bump],\n  ];\n\n  transfer(\n    CpiContext::new_with_signer(\n      ctx.accounts.token_program.to_account_info(),\n      Transfer {\n        from: ctx.accounts.vault.to_account_info(),\n        to: ctx.accounts.signer_ata.to_account_info(),\n        authority: airdrop_state.to_account_info(),\n      },\n      &[signer_seeds],\n    ),\n    amount,\n  )?;\n\n  Ok(())\n}\n\n#[derive(Accounts)]\npub struct Claim<'info> {\n    #[account(\n        mut,\n        has_one = mint,\n        seeds = [b\"merkle_tree\".as_ref(), mint.key().to_bytes().as_ref()],\n        bump = airdrop_state.bump\n    )]\n    pub airdrop_state: Account<'info, AirdropState>,\n    pub mint: Account<'info, Mint>,\n    #[account(\n        mut,\n        associated_token::mint = mint,\n        associated_token::authority = airdrop_state,\n    )]\n    pub vault: Account<'info, TokenAccount>,\n    #[account(\n        init_if_needed,\n        payer = signer,\n        associated_token::mint = mint,\n        associated_token::authority = signer,\n    )]\n    pub signer_ata: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n}\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions Manually with RPC in Solana\nDESCRIPTION: Demonstrates how to send a signed transaction and confirm it using RPC methods with a blockhash strategy. This approach requires explicit handling of sending and confirmation steps.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst signedTransaction = await builder.buildAndSign(umi)\nconst signature = await umi.rpc.sendTransaction(signedTransaction)\nconst confirmResult = await umi.rpc.confirmTransaction(signature, {\n  strategy: { type: 'blockhash', ...(await umi.rpc.getLatestBlockhash()) },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing RPC Endpoint in TypeScript\nDESCRIPTION: The snippet demonstrates how to create an instance of Umi with an RPC endpoint or a Connection instance from @solana/web3.js, required for interacting with the Solana blockchain. Inputs include an RPC endpoint URL or a Connection object.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { Connection } from '@solana/web3.js';\n\n// Pass in your RPC endpoint.\nconst umi = createUmi(\"https://api.mainnet-beta.solana.com\");\n\n// Or an explicit Connection instance from web3.js.\nconst umi = createUmi(new Connection(\"https://api.mainnet-beta.solana.com\"));\n```\n\n----------------------------------------\n\nTITLE: Updating Core Asset with Rust\nDESCRIPTION: This snippet shows how to update a Core Asset's name and URI using the Metaplex Rust SDK. It includes setting up the RPC client, creating the update instruction, and sending the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/update.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::UpdateV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn update_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    // Optional: If the Asset is in a collection fetch the collection\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let update_asset_ix = UpdateV1Builder::new()\n        .asset(asset)\n        // Optional: Collection is only required if Asset is part of a collection\n        .collection(collection)\n        .payer(authority.pubkey())\n        .new_name(\"My asset\".into())\n        .new_uri(\"https://example.com/my-asset.json\".into())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let update_asset_tx = Transaction::new_signed_with_payer(\n        &[update_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&update_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fusion Parent NFT with Trifle in TypeScript\nDESCRIPTION: This code demonstrates how to create a Fusion Parent NFT with a static URI format that enables dynamic metadata. It includes finding the Trifle PDA (Program Derived Address) and creating an NFT with Metaplex's API.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/fusion/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst findTriflePda = async (mint: PublicKey, authority: PublicKey) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from('trifle'), mint.toBuffer(), authority.toBuffer()],\n    new PublicKey(PROGRAM_ADDRESS)\n  )\n}\n\nconst METAPLEX_BUCKET = 'Jf27xwhv6bH1aaPYtvJxvHvKRHoDe3DyQVqe4CJyxsP'\nlet nftMint = Keypair.generate()\nlet trifleAddress = await findTriflePda(nftMint.publicKey, updateAuthority)\nlet result\nresult = await metaplex!.nfts().create({\n  uri:\n    'https://shdw-drive.genesysgo.net/' +\n    METAPLEX_BUCKET +\n    '/' +\n    trifleAddress[0].toString() +\n    '.json',\n  name: 'Fusion NFT',\n  sellerFeeBasisPoints: 0,\n  useNewMint: nftMint,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Mint and Metadata Accounts using Rust MPL SDK (CPI)\nDESCRIPTION: This Rust code demonstrates how to use the CreateV1CpiBuilder from the mpl_token_metadata crate to create Mint and Metadata accounts via CPI (Cross-Program Invocation). It sets up the builder with various account references and metadata fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::\n    accounts::Metadata,\n    instructions::CreateV1CpiBuilder,\n    types::{PrintSupply, TokenStandard},\n};\n\n// 1. every account is specified by a reference to their AccountInfo\n\nlet create_cpi = CreateV1CpiBuilder::new(token_metadata_program_info)\n    .metadata(metadata_info)\n    .mint(mint_info, true)\n    .authority(payer_info)\n    .payer(payer_info)\n    .update_authority(update_authority_info, false)\n    .master_edition(Some(master_edition_info))\n    .system_program(system_program_info)\n    .sysvar_instructions(sysvar_instructions_info)\n    .spl_token_program(spl_token_program_info)\n    .token_standard(TokenStandard::NonFungible)\n    .name(String::from(\"My NFT\"))\n    .uri(uri)\n    .seller_fee_basis_points(550)\n    .token_standard(TokenStandard::NonFungible)\n    .print_supply(PrintSupply::Zero);\n\ncreate_cpi.invoke();\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Authority for Candy Machine in JavaScript\nDESCRIPTION: Demonstrates how to set a custom authority when creating a new Candy Machine using the Umi identity. It shows how to generate a custom signer and assign it as the authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\n\nconst myCustomAuthority = generateSigner(umi)\nconst candyMachineSettings = {\n  authority: myCustomAuthority,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Sugar via Quick Install Script (Bash)\nDESCRIPTION: This snippet shows how to install Sugar using a quick installation script. It's the easiest method for macOS, Linux, and WSL users.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash <(curl -sSf https://sugar.metaplex.com/install.sh)\n```\n\n----------------------------------------\n\nTITLE: Candy Machine Configuration JSON\nDESCRIPTION: Example configuration file generated by Sugar after the launch process. This file contains all the settings for the Candy Machine including creators, upload method, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tokenStandard\": \"nft\",\n  \"number\": 16,\n  \"symbol\": \"NUMBERS\",\n  \"sellerFeeBasisPoints\": 500,\n  \"isMutable\": true,\n  \"isSequential\": false,\n  \"creators\": [\n    {\n      \"address\": \"B1kwbSHRiXFPYvNbuhCX92ibngzxdmfBzfaJYuy9WYp5\",\n      \"share\": 100\n    }\n  ],\n  \"uploadMethod\": \"bundlr\",\n  \"ruleSet\": null,\n  \"awsConfig\": null,\n  \"sdriveApiKey\": null,\n  \"nftStorageAuthToken\": null,\n  \"shdwStorageAccount\": null,\n  \"pinataConfig\": null,\n  \"hiddenSettings\": null,\n  \"guards\": null,\n  \"maxEditionSupply\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Candy Machine V2 Setup and Minting\nDESCRIPTION: Comprehensive example showing the complete process of creating a Collection NFT, setting up a Candy Machine V2, and minting NFTs. Includes wallet setup, collection creation, Candy Machine configuration, and minting process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  addConfigLines,\n  createCandyMachineV2,\n  fetchCandyMachine,\n  mintFromCandyMachineV2,\n  mplCandyMachine,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  percentAmount,\n  publicKey,\n  sol,\n  some,\n  transactionBuilder,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createNft,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { base58 } from \"@metaplex-foundation/umi-serializers\";\nimport {\n  createMintWithAssociatedToken,\n  setComputeUnitLimit,\n} from \"@metaplex-foundation/mpl-toolbox\";\n\n/**\n * This script demonstrates how to create a basic Candy Machine without guards\n * and mint an NFT to a recipient wallet.\n */\n\n// Configuration\nconst RECIPIENT_ADDRESS = \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\";\nconst RPC_ENDPOINT = \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\";\n\n(async () => {\n  try {\n    // --- Setup ---\n    \n    // Initialize connection to Solana\n    const umi = createUmi(RPC_ENDPOINT).use(mplCandyMachine());\n    const recipient = publicKey(RECIPIENT_ADDRESS);\n\n    // Create and fund a test wallet\n    const walletSigner = generateSigner(umi);\n    umi.use(keypairIdentity(walletSigner));\n    console.log(\"Funding test wallet with devnet SOL...\");\n    await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1), {\n      commitment: \"finalized\",\n    });\n\n    // --- Create Collection NFT ---\n    \n    const collectionMint = generateSigner(umi);\n    console.log(\"Creating collection NFT...\");\n    console.log(\"Collection Address:\", collectionMint.publicKey);\n\n    const createNftTx = await createNft(umi, {\n      mint: collectionMint,\n      authority: umi.identity,\n      name: \"My Collection NFT\",\n      uri: \"https://example.com/path/to/some/json/metadata.json\",\n      sellerFeeBasisPoints: percentAmount(9.99, 2),\n      isCollection: true,\n    }).sendAndConfirm(umi, {\n      confirm: { commitment: \"finalized\" },\n    });\n    console.log(\"Collection Created:\", base58.deserialize(createNftTx.signature)[0]);\n\n    // --- Create Candy Machine ---\n\n    console.log(\"Creating basic Candy Machine...\");\n    const candyMachine = generateSigner(umi);\n    \n    const createCandyMachineV2Tx = await (\n      await createCandyMachineV2(umi, {\n        candyMachine,\n        tokenStandard: TokenStandard.NonFungible,\n        collectionMint: collectionMint.publicKey,\n        collectionUpdateAuthority: umi.identity,\n        itemsAvailable: 2,\n        sellerFeeBasisPoints: percentAmount(1.23),\n        creators: [\n          {\n            address: umi.identity.publicKey,\n            verified: false,\n            percentageShare: 100,\n          },\n        ],\n        configLineSettings: some({\n          prefixName: \"My NFT #\",\n          nameLength: 3,\n          prefixUri: \"https://example.com/\",\n          uriLength: 29,\n          isSequential: false,\n        }),\n      })\n    )\n      .add(\n        addConfigLines(umi, {\n          candyMachine: candyMachine.publicKey,\n          index: 0,\n          configLines: [\n            { name: \"1\", uri: \"https://example.com/nft1.json\" },\n            { name: \"2\", uri: \"https://example.com/nft2.json\" },\n          ],\n        })\n      )\n      .sendAndConfirm(umi, { confirm: { commitment: \"finalized\" } });\n      \n    console.log(\"Candy Machine Created:\", base58.deserialize(createCandyMachineV2Tx.signature)[0]);\n\n    // --- Mint NFT ---\n\n    console.log(\"Minting NFT to recipient...\");\n    \n    // Get latest Candy Machine state\n    const candyMachineAccount = await fetchCandyMachine(umi, candyMachine.publicKey);\n\n    // Create mint transaction\n    const nftMint = generateSigner(umi);\n    const mintTx = await transactionBuilder()\n      .add(setComputeUnitLimit(umi, { units: 800_000 }))\n      .add(\n        createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient })\n      )\n      .add(\n        mintFromCandyMachineV2(umi, {\n          candyMachine: candyMachine.publicKey,\n          mintAuthority: umi.identity,\n          nftOwner: recipient,\n          nftMint,\n          collectionMint: candyMachineAccount.collectionMint,\n          collectionUpdateAuthority: candyMachineAccount.authority,\n        })\n      )\n      .sendAndConfirm(umi, {\n        confirm: { commitment: \"finalized\" },\n      });\n\n    console.log(\"NFT Minted Successfully!\");  \n    console.log(\"Mint Transaction:\", base58.deserialize(mintTx.signature)[0]);\n\n  } catch (error) {\n    console.error(\"Failed to execute:\", error);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Immutable Edition Plugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an MPL Core asset with an immutable Edition Plugin using TypeScript. It sets the edition number to 1 and prevents future updates by setting the authority to 'None'.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/edition.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst asset = generateSigner(umi)\n\nconst result = create(umi, {\n  asset: asset,\n  name: 'My Nft',\n  uri: 'https://example.com/my-nft',\n  plugins: [\n    {\n      type: 'Edition',\n      number: 1,\n      authority: { type: 'None' },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata Object for NFT in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a metadata object for an NFT, including name, description, image URI, external URL, attributes, and properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst metadata = {\n  name: 'My NFT',\n  description: 'This is an NFT on Solana',\n  image: imageUri[0],\n  external_url: 'https://example.com',\n  attributes: [\n    {\n      trait_type: 'trait1',\n      value: 'value1',\n    },\n    {\n      trait_type: 'trait2',\n      value: 'value2',\n    },\n  ],\n  properties: {\n    files: [\n      {\n        uri: imageUri[0],\n        type: 'image/jpeg',\n      },\n    ],\n    category: 'image',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Preflight with Umi's send Method\nDESCRIPTION: Shows how to use the skipPreflight option with Metaplex Umi's send() function to bypass transaction simulation and force registration on-chain. Includes signature conversion and logging for later reference.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/how-to-diagnose-solana-transaction-errors.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst tx = createV1(umi, {\n    ...args\n}).send(umi, {skipPreflight: true})\n\n// Convert signature to string\nconst signature = base58.deserialize(tx);\n\n// Log transaction signature\nconsole.log(signature)\n```\n\n----------------------------------------\n\nTITLE: Candy Machine Data Structure in TypeScript\nDESCRIPTION: This snippet shows the data structure used when updating a Core Candy Machine, documenting all available configuration fields and their types.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/update.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndata =  {\n    itemsAvailable: number | bigint;\n    isMutable: boolean;\n    configLineSettings: OptionOrNullable<ConfigLineSettingsArgs>;\n    hiddenSettings: OptionOrNullable<HiddenSettingsArgs>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Mint and Token Accounts before Minting NFT in TypeScript\nDESCRIPTION: This code snippet shows how to create Mint and Token accounts before minting an NFT from a Candy Machine. It uses the createMintWithAssociatedToken function to set up the accounts before calling mintV2.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/mint.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV2 } from '@metaplex-foundation/mpl-candy-machine'\nimport {\n  createMintWithAssociatedToken,\n  setComputeUnitLimit,\n} from '@metaplex-foundation/mpl-toolbox'\nimport { transactionBuilder, generateSigner } from '@metaplex-foundation/umi'\n\nconst nftMint = generateSigner(umi)\nconst nftOwner = generateSigner(umi).publicKey\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(createMintWithAssociatedToken(umi, { mint: nftMint, owner: nftOwner }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      nftMint: nftMint.publicKey,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Asset-Level Soulbound NFT Implementation with Oracle Plugin\nDESCRIPTION: This code example shows a complete implementation of creating a soulbound NFT at the asset level. It includes steps for initializing Umi, creating a test wallet, creating a collection, creating a soulbound asset, and attempting a transfer to demonstrate the soulbound property.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { mplCore } from \"@metaplex-foundation/mpl-core\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  publicKey,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createCollection,\n  create,\n  fetchCollection,\n  CheckResult,\n  transfer,\n  fetchAssetV1,\n} from \"@metaplex-foundation/mpl-core\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\n// Define the Oracle account that will control transfer permissions\n// This is an Oracle deployed by Metaplex that always rejects tranferring\nconst ORACLE_ACCOUNT = publicKey(\n  \"GxaWxaQVeaNeFHehFQEDeKR65MnT6Nup81AGwh2EEnuq\"\n);\n\n// Define a dummy destination wallet for testing transfer restrictions\nconst DESTINATION_WALLET = publicKey(\"CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d\");\n\n(async () => {\n  // Step 1: Initialize Umi with devnet RPC endpoint\n  const umi = createUmi(\n    \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\"\n  ).use(mplCore());\n\n  // Step 2: Create and fund a test wallet\n  const walletSigner = generateSigner(umi);\n  umi.use(keypairIdentity(walletSigner));\n\n  console.log(\"Funding test wallet with devnet SOL...\");\n  await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1));\n\n  // Step 3: Create a new collection to hold our soulbound asset\n  console.log(\"Creating parent collection...\");\n  const collectionSigner = generateSigner(umi);\n  await createCollection(umi, {\n    collection: collectionSigner,\n    name: \"My Collection\",\n    uri: \"https://example.com/my-collection.json\",\n  }).sendAndConfirm(umi);\n  \n  // Wait for transaction confirmation\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  // Fetch and verify the collection was created\n  const collection = await fetchCollection(umi, collectionSigner.publicKey);\n  console.log(\"Collection created successfully:\", collectionSigner.publicKey);\n\n  // Step 4: Create a soulbound asset within the collection\n  console.log(\"Creating soulbound asset...\");\n  const assetSigner = generateSigner(umi);\n  \n  // Create the asset with transfer restrictions using an Oracle plugin\n  await create(umi, {\n    asset: assetSigner,\n    collection: collection,\n    name: \"My Soulbound Asset\",\n    uri: \"https://example.com/my-asset.json\",\n    plugins: [\n      {\n        // The Oracle plugin allows us to control transfer permissions\n        type: \"Oracle\",\n        resultsOffset: {\n          type: \"Anchor\",\n        },\n        baseAddress: ORACLE_ACCOUNT,\n        lifecycleChecks: {\n          // Configure the Oracle to reject all transfer attempts\n          transfer: [CheckResult.CAN_REJECT],\n        },\n        baseAddressConfig: undefined,\n      },\n    ],\n  }).sendAndConfirm(umi);\n  \n  // Wait for transaction confirmation\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  // Fetch and verify the asset was created\n  const asset = await fetchAssetV1(umi, assetSigner.publicKey);\n  console.log(\"Soulbound asset created successfully:\", assetSigner.publicKey);\n\n  // Step 5: Demonstrate that the asset is truly soulbound\n  console.log(\n    \"Testing soulbound property by attempting a transfer (this should fail)...\"\n  );\n  \n  // Attempt to transfer the asset (this will fail due to Oracle restrictions)\n  const transferResponse = await transfer(umi, {\n    asset: asset,\n    newOwner: DESTINATION_WALLET,\n    collection,\n  }).sendAndConfirm(umi, { send: { skipPreflight: true } });\n\n  // Log the failed transfer attempt signature\n  console.log(\n    \"Transfer attempt signature:\",\n    base58.deserialize(transferResponse.signature)[0]\n  );\n})();\n```\n\n----------------------------------------\n\nTITLE: Collection-Level Soulbound NFT Implementation with Oracle Plugin\nDESCRIPTION: This code example demonstrates how to create a soulbound collection and asset using the Oracle Plugin at the collection level. It includes steps for initializing Umi, creating a test wallet, creating a soulbound collection, creating an asset within the collection, and attempting a transfer to show the soulbound property.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { mplCore } from \"@metaplex-foundation/mpl-core\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  publicKey,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createCollection,\n  create,\n  fetchCollection,\n  CheckResult,\n  transfer,\n  fetchAssetV1,\n} from \"@metaplex-foundation/mpl-core\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\n// Define the Oracle account that will control transfer permissions\n// This is an Oracle deployed by Metaplex that always rejects transferring\nconst ORACLE_ACCOUNT = publicKey(\n  \"GxaWxaQVeaNeFHehFQEDeKR65MnT6Nup81AGwh2EEnuq\"\n);\n\n// Define a dummy destination wallet for testing transfer restrictions\nconst DESTINATION_WALLET = publicKey(\"CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d\");\n\n(async () => {\n  // Step 1: Initialize Umi with devnet RPC endpoint\n  const umi = createUmi(\n    \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\"\n  ).use(mplCore());\n\n  // Step 2: Create and fund a test wallet\n  const walletSigner = generateSigner(umi);\n  umi.use(keypairIdentity(walletSigner));\n\n  console.log(\"Funding test wallet with devnet SOL...\");\n  await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1));\n  \n  // Wait for airdrop confirmation\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  // Step 3: Create a new collection with transfer restrictions\n  console.log(\"Creating soulbound collection...\");\n  const collectionSigner = generateSigner(umi);\n  await createCollection(umi, {\n    collection: collectionSigner,\n    name: \"Soulbound Collection\",\n    uri: \"https://example.com/my-collection.json\",\n    plugins: [\n      {\n        // The Oracle plugin allows us to control transfer permissions\n        type: \"Oracle\",\n        resultsOffset: {\n          type: \"Anchor\",\n        },\n        baseAddress: ORACLE_ACCOUNT,\n        lifecycleChecks: {\n          // Configure the Oracle to reject all transfer attempts\n          transfer: [CheckResult.CAN_REJECT],\n        },\n        baseAddressConfig: undefined,\n      },\n    ],\n  }).sendAndConfirm(umi);\n\n  // Wait for collection creation confirmation\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  // Fetch and verify the collection was created\n  const collection = await fetchCollection(umi, collectionSigner.publicKey);\n  console.log(\"Soulbound collection created successfully:\", collectionSigner.publicKey);\n\n  // Step 4: Create a soulbound asset within the collection\n  console.log(\"Creating soulbound asset...\");\n  const assetSigner = generateSigner(umi);\n  await create(umi, {\n    asset: assetSigner,\n    collection: collection,\n    name: \"Soulbound Asset\",\n    uri: \"https://example.com/my-asset.json\",\n  }).sendAndConfirm(umi);\n\n  // Wait for asset creation confirmation\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  // Fetch and verify the asset was created\n  const asset = await fetchAssetV1(umi, assetSigner.publicKey);\n  console.log(\"Soulbound asset created successfully:\", assetSigner.publicKey);\n\n  // Step 5: Demonstrate that the asset is truly soulbound\n  console.log(\n    \"Testing soulbound property by attempting a transfer (this should fail)...\"\n  );\n  \n  // Attempt to transfer the asset (this will fail due to Oracle restrictions)\n  const transferResponse = await transfer(umi, {\n    asset: asset,\n    newOwner: DESTINATION_WALLET,\n    collection,\n  }).sendAndConfirm(umi, { send: { skipPreflight: true } });\n\n  // Log the failed transfer attempt signature\n  console.log(\n    \"Transfer attempt signature:\",\n    base58.deserialize(transferResponse.signature)[0]\n  );\n})();\n```\n\n----------------------------------------\n\nTITLE: Deserializing Collection Account in JavaScript/TypeScript\nDESCRIPTION: Shows how to deserialize a Collection account using Umi RPC client, retrieving collection metadata including authority, name, URI, and size information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst accountData = await umi.rpc.getAccount(\n  publicKey('11111111111111111111111111111111')\n)\n\nif (!accountData.exists) throw 'Account does not exist'\n\nconst collectionV1 = deserializeCollectionV1(accountData)\n\nconsole.log({ assetData })\n```\n\n----------------------------------------\n\nTITLE: Signing and Verifying Messages in TypeScript\nDESCRIPTION: Demonstrates the use of Signer objects and EdDSA interface for signing and verifying messages. Input is a message to be signed, with outputs being the signature and its verification status. Requires utf8 serializer and EdDSA interface.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myMessage = utf8.serialize('Hello, world!');\nconst mySignature = await mySigner.signMessage(myMessage)\nconst mySignatureIsCorrect = umi.eddsa.verify(myMessage, mySignature, mySigner.publicKey);\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Guard Groups in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with two guard groups using the Umi library. It sets up an 'early' group with a 1 SOL payment and specific start/end dates, and a 'late' group with a 2 SOL payment and a different start date. Both groups include a bot tax guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-groups.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Allow List Guard in JavaScript\nDESCRIPTION: This code demonstrates how to mint from a Candy Machine with an Allow List guard by passing the Merkle root in the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMerkleRoot } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    allowList: some({ merkleRoot: getMerkleRoot(allowList) }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Transferring Ownership of an Asset to Another Asset in JavaScript\nDESCRIPTION: This example demonstrates how to transfer ownership of a Core Asset from one Asset to another using the execute instruction and transfer function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/execute-asset-signing.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  execute,\n  fetchAsset,\n  fetchCollection,\n  findAssetSignerPda,\n  transfer,\n} from '@metaplex-foundation/mpl-core'\nimport { publickey } from '@metaplex-foundation/umi'\n\n// Asset we wish to transfer.\nconst assetId = publickey('11111111111111111111111111111111')\nconst asset = await fetchAsset(assetId)\n\n// Optional - If Asset is part of collection fetch the collection object\nconst collection =\n  asset.updateAuthority.type == 'Collection' && asset.updateAuthority.address\n    ? await fetchCollection(umi, asset.updateAuthority.address)\n    : undefined\n\n// Asset ID that owns the Asset we wish to transfer.\nconst sourceAssetId = publickey('2222222222222222222222222222222222')\n// The source Asset object.\nconst sourceAsset = fetchAsset(umi, sourceAssetId)\n// Asset signer has a balance of 1 SOL in the account.\nconst sourceAssetSignerPda = findAssetSignerPda(umi, { asset: assetId })\n\n// Destination account we wish to transfer the SOL to.\nconst destinationAssetId = publickey('33333333333333333333333333333333')\n// Destination Asset signer we wish to transfer the Asset to.\nconst destinationAssetSignerPda = findAssetSignerPda(umi, {\n  asset: destinationAssetId,\n})\n\nconst transferAssetIx = transfer(umi, {\n  // Asset object via `fetchAsset()`.\n  asset,\n  // Optional - Collection object via `fetchCollection()`\n  collection,\n  // New Owner of the Asset.\n  newOwner: destinationAssetSignerPda,\n}).sendAndConfirm(umi)\n\nconst res = await execute(umi, {\n  // Execute instruction(s) with this asset\n  asset,\n  // If Asset is part of collection pass in collection object via `fetchCollection()`\n  collection,\n  // The transactionBuilder/instruction[] to execute\n  instructions: transferAssetIx,\n}).sendAndConfirm(umi)\n\nconsole.log({ res })\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Collection with Master Edition Plugin in Rust\nDESCRIPTION: This Rust code snippet shows how to create an MPL Core Collection with the Master Edition Plugin. It sets up the RPC client, creates necessary keypairs, builds the instruction, and sends the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/master-edition.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::CreateCollectionV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_collection_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let collection = Keypair::new();\n\n    let create_collection_ix = CreateCollectionV1Builder::new()\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Collection\".into())\n        .uri(\"https://example.com/my-collection.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::MasterEdition(MasterEdition {\n                max_supply: 100,\n                name: \"My Master Edition\"\n                uri: \"https://example.com/my-master-edition.json\",\n            }),\n            authority: Some(PluginAuthority::UpdateAuthority),\n        }])\n        .instruction();\n\n    let signers = vec![&collection, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_tx = Transaction::new_signed_with_payer(\n        &[create_collection_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Core Candy Machine Data using JavaScript\nDESCRIPTION: This code snippet demonstrates how to fetch a Core Candy Machine's data from the Solana blockchain. It uses the Metaplex Foundation's libraries to create a UMI instance, connect to either mainnet or devnet, and retrieve the Candy Machine data using its public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/fetching-a-candy-machine.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchCandyMachine, mplCandyMachine as mplCoreCandyMachine } from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { publicKey } from \"@metaplex-foundation/umi\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\n\nconst mainnet = \"https://mainnet-aura.metaplex.com/<YOUR_API_KEY>\"\nconst devnet = \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\"\n\nconst umi = createUmi(mainnet)\n.use(mplCoreCandyMachine())\n\nconst candyMachineId = \"11111111111111111111111111111111\"\n\nconst candyMachine = await fetchCandyMachine( umi, publicKey(candyMachineId));\n\nconsole.log({ candyMachine });\n```\n\n----------------------------------------\n\nTITLE: Creating Fungible Token Mint and Metadata\nDESCRIPTION: Generating a new token mint with associated metadata using createFungible()\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst mintSigner = generateSigner(umi)\n\nconst createMintIx = await createFungible(umi, {\n  mint: mintSigner,\n  name: 'The Kitten Coin',\n  uri: metadataUri,\n  sellerFeeBasisPoints: percentAmount(0),\n  decimals: 9,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Guard Groups in TypeScript\nDESCRIPTION: This code demonstrates how to create a Candy Machine with two guard groups: 'early' with 1 SOL payment from 4-5pm, and 'late' with 2 SOL payment after 5pm. Both groups include bot tax protection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-groups.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating and Modifying Transaction Builders in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a new transaction builder and add instructions to it using the add and prepend methods.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nlet builder = transactionBuilder()\n  .add(myWrappedInstruction)\n  .add(myOtherWrappedInstruction)\n  .prepend(myFirstWrappedInstruction)\n```\n\n----------------------------------------\n\nTITLE: Minting Soulbound Loyalty Card NFT with Metaplex Core\nDESCRIPTION: Creates a new loyalty card NFT with AppData and FreezeDelegate plugins, setting up proper authorities and collection membership.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/loyalty-card-concept-guide.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nCreateV2CpiBuilder::new(&ctx.accounts.core_program)\n    .asset(&ctx.accounts.loyalty_card)\n    .name(\"Sol Coffee Loyalty Card\".to_owned())\n    .collection(Some(&ctx.accounts.loyalty_card_collection))\n    .uri(\"https://arweave.net/...\".to_owned())\n    .external_plugin_adapters(vec![\n        ExternalPluginAdapterInitInfo::AppData(AppDataInitInfo {\n            data_authority: PluginAuthority::Address { address: ctx.accounts.loyalty_authority.key() },\n            init_plugin_authority: Some(PluginAuthority::Address { address: ctx.accounts.loyalty_authority.key() }),\n            schema: Some(ExternalPluginAdapterSchema::Binary),\n        }),\n    ])\n    .plugins(vec![\n        PluginAuthorityPair {\n            authority: Some(PluginAuthority::Address { address: ctx.accounts.loyalty_authority.key() }),\n            plugin: Plugin::FreezeDelegate(FreezeDelegate { frozen: true }),\n        },\n    ])\n    .owner(Some(&ctx.accounts.signer))\n    .payer(&ctx.accounts.signer)\n    .authority(Some(&ctx.accounts.collection_delegate))\n    .invoke_signed(collection_delegate_seeds)?\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Default Guards and Groups in TypeScript\nDESCRIPTION: Demonstrates how to create a Candy Machine with default bot tax guard and multiple guard groups with different sol payment and date restrictions using the Umi library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-groups.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n  },\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting NFT directly from Candy Machine Core Program in TypeScript\nDESCRIPTION: This example demonstrates how to mint an NFT directly from the Candy Machine Core program using the mintFromCandyMachineV2 function. It requires the mint authority to be provided as a signer and accepts an explicit nftOwner attribute.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/mint.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintFromCandyMachineV2 } from '@metaplex-foundation/mpl-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\nimport { transactionBuilder, generateSigner } from '@metaplex-foundation/umi'\n\nconst nftMint = generateSigner(umi)\nconst nftOwner = generateSigner(umi).publicKey\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(\n    mintFromCandyMachineV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      mintAuthority: umi.identity,\n      nftOwner,\n      nftMint,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Accessing Transaction Metadata and Logs\nDESCRIPTION: Demonstrates how to access the metadata of a fetched transaction, specifically showing how to retrieve transaction logs which are useful for debugging and monitoring.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst transaction = await umi.rpc.getTransaction(signature)\nconst logs: string[] = transaction.meta.logs\n```\n\n----------------------------------------\n\nTITLE: Minting to Another Wallet using TypeScript and mpl-candy-machine\nDESCRIPTION: JavaScript code snippet showing how to mint an NFT to a specific recipient wallet using the mpl-candy-machine library. This example demonstrates creating the mint transaction builder with the necessary operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst candyMachineAccount = await fetchCandyMachine(umi, publicKey(\"CM Address\"));\n\nconst recipient = publicKey('Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV')\nconst nftMint = generateSigner(umi)\nconst mintTx = await transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachineAccount.publicKey,\n      nftMint,\n      token: findAssociatedTokenPda(umi, {\n        mint: nftMint.publicKey,\n        owner: recipient,\n      }),\n      collectionMint: candyMachineAccount.collectionMint,\n      collectionUpdateAuthority: candyMachineAccount.authority,\n      tokenStandard: TokenStandard.NonFungible,\n      mintArgs: {\n        mintLimit: some({ // The guards that require mintArgs have to be specified here \n          id: 1,\n        }),\n      },\n    })\n  )\n  .sendAndConfirm(umi, {\n    confirm: { commitment: 'finalized' },\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Asset Creation Instruction\nDESCRIPTION: Implementation of the create_core_asset instruction using CreateV2CpiBuilder\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_core_asset(ctx: Context<CreateAsset>, args: CreateAssetArgs) -> Result<()> {\n  let collection = match &ctx.accounts.collection {\n    Some(collection) => Some(collection.to_account_info()),\n    None => None,\n  };\n\n  let authority = match &ctx.accounts.authority {\n    Some(authority) => Some(authority.to_account_info()),\n    None => None,\n  };\n\n  let owner = match &ctx.accounts.owner {\n    Some(owner) => Some(owner.to_account_info()),\n    None => None,\n  };\n\n  let update_authority = match &ctx.accounts.update_authority {\n    Some(update_authority) => Some(update_authority.to_account_info()),\n    None => None,\n  };\n  \n  CreateV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(collection.as_ref())\n    .authority(authority.as_ref())\n    .payer(&ctx.accounts.payer.to_account_info())\n    .owner(owner.as_ref())\n    .update_authority(update_authority.as_ref())\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .name(args.name)\n    .uri(args.uri)\n    .invoke()?\n\n  Ok(())\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Programs in TypeScript\nDESCRIPTION: Defines a TypeScript type that represents a Solana program with relevant attributes and methods to resolve errors and check cluster deployment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Program = {\n  name: string;\n  publicKey: PublicKey;\n  getErrorFromCode: (code: number, cause?: Error) => ProgramError | null;\n  getErrorFromName: (name: string, cause?: Error) => ProgramError | null;\n  isOnCluster: (cluster: Cluster) => boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Collection NFT in TypeScript\nDESCRIPTION: Creates a new Candy Machine with an associated Collection NFT using the Umi library. The code first creates a Collection NFT and then uses it to initialize a new Candy Machine with specific parameters like seller fees, available items count, and creator settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createNft,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { create } from '@metaplex-foundation/mpl-candy-machine'\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\n\n// Create the Collection NFT.\nconst collectionMint = generateSigner(umi)\nawait createNft(umi, {\n  mint: collectionMint,\n  authority: umi.identity,\n  name: 'My Collection NFT',\n  uri: 'https://example.com/path/to/some/json/metadata.json',\n  sellerFeeBasisPoints: percentAmount(9.99, 2), // 9.99%\n  isCollection: true,\n}).sendAndConfirm(umi)\n\n// Create the Candy Machine.\nconst candyMachine = generateSigner(umi)\nawait create(umi, {\n  candyMachine,\n  collectionMint: collectionMint.publicKey,\n  collectionUpdateAuthority: umi.identity,\n  tokenStandard: TokenStandard.NonFungible,\n  sellerFeeBasisPoints: percentAmount(9.99, 2), // 9.99%\n  itemsAvailable: 5000,\n  creators: [\n    {\n      address: umi.identity.publicKey,\n      verified: true,\n      percentageShare: 100,\n    },\n  ],\n  configLineSettings: some({\n    prefixName: '',\n    nameLength: 32,\n    prefixUri: '',\n    uriLength: 200,\n    isSequential: false,\n  }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Asset Account in JavaScript/TypeScript\nDESCRIPTION: Demonstrates how to deserialize an Asset account using the Umi RPC client in JavaScript. Returns asset information including owner, update authority, name, and URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst accountData = await umi.rpc.getAccount(\n  publicKey('11111111111111111111111111111111')\n)\n\nif (!accountData.exists) throw 'Account does not exist'\n\nconst assetV1 = deserializeAssetV1(accountData)\n\nconsole.log({ assetData })\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine Guards in TypeScript\nDESCRIPTION: Shows how to update existing guards on a Candy Machine by disabling bot tax and modifying SOL payment amount. Includes fetching current guard settings before update.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, sol } from '@metaplex-foundation/umi'\n\nconst candyGuard = fetchCandyGuard(umi, candyMachine.mintAuthority)\nawait updateCandyGuard(umi, {\n  candyGuard: candyGuard.publicKey,\n  guards: {\n    ...candyGuard.guards,\n    botTax: none(),\n    solPayment: some({ lamports: sol(3), destination: treasury }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating pNFT Asset Metadata using JavaScript and Metaplex Libraries\nDESCRIPTION: This snippet demonstrates how to update a Programmable NFT (pNFT) asset's metadata using JavaScript with Metaplex libraries. It fetches the existing metadata, sets new data, and updates the asset as the update authority. The code handles additional accounts required for pNFTs, including authorization rules.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMplTokenAuthRulesProgramId } from '@metaplex-foundation/mpl-candy-machine'\nimport {\n  collectionToggle,\n  fetchMetadataFromSeeds,\n  TokenStandard,\n  updateAsUpdateAuthorityV2,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { publicKey, unwrapOptionRecursively } from '@metaplex-foundation/umi'\n\n// The Mint ID of the pNFT Asset\nconst mintId = publicKey('1111111111111111111111111111111')\n\n// Fetch the Metadata of the pNFT Asset\nconst metadata = await fetchMetadataFromSeeds(umi, { mint: mintId })\n\n// Set the new Data of the pNFT Asset\nconst data = {\n  name: 'New Name',\n  symbol: 'New Symbol',\n  uri: 'https://newuri.com',\n  sellerFeeBasisPoints: 500,\n  creators: [],\n}\n\n// Update the pNFT as the Update Authority\nconst txRes = await updateAsUpdateAuthorityV2(umi, {\n  mint: mintId,\n  data: data,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  collection: collectionToggle('Clear'),\n  // Check to see if the pNFT asset as auth rules.\n  authorizationRules:\n    unwrapOptionRecursively(metadata.programmableConfig)?.ruleSet || undefined,\n  // Auth rules program ID\n  authorizationRulesProgram: getMplTokenAuthRulesProgramId(umi),\n  // You may have to set authorizationData if required by the authorization rules\n  authorizationData: undefined,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Example JSON Metadata Structure for NFT Asset\nDESCRIPTION: A sample JSON metadata file for an NFT asset that includes name, description, image URI, external URL, attributes, and properties following the Token Standard used by Metaplex.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/preparing-assets.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"My Nft #1\",\n  \"description\": \"This is My Nft Collection\",\n  \"image\": \"https://example.com/1.jpg\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://example.com/1.jpg\",\n        \"type\": \"image/jpg\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Merkle Tree Token Claimer in TypeScript\nDESCRIPTION: A TypeScript test file for the Merkle Tree Token Claimer smart contract. This test initializes the airdrop data with a Merkle root generated from a list of recipient addresses and token amounts, and demonstrates the setup required for testing the contract functionality. The code handles the creation of the Merkle tree and leaf serialization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as anchor from \"@coral-xyz/anchor\";\nimport { Program } from \"@coral-xyz/anchor\";\nimport { MerkleTreeTokenClaimer } from \"../target/types/merkle_tree_token_claimer\";\nimport { expect } from \"chai\";\nimport { Keypair, PublicKey, SystemProgram, LAMPORTS_PER_SOL, Transaction } from \"@solana/web3.js\";\nimport { getAssociatedTokenAddress, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { HashingAlgorithm, MerkleTree } from \"svm-merkle-tree\";\nimport { ASSOCIATED_PROGRAM_ID } from \"@coral-xyz/anchor/dist/cjs/utils/token\";\n\n\ndescribe(\"merkle-tree-token-claimer\", () => {\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n  const wallet = anchor.Wallet.local();\n\n  Keypair.fromSecretKey\n  const program = anchor.workspace.MerkleTreeTokenClaimer as Program<MerkleTreeTokenClaimer>;\n\n  let authority = wallet.payer;\n  let mint = Keypair.generate();\n  let newAddress: Keypair;\n  let airdropState: PublicKey;\n  let merkleTree: MerkleTree;\n  let vault: PublicKey;\n  let newData: AirdropTokenData;\n\n  interface AirdropTokenData {\n    address: PublicKey;\n    amount: number;\n    isClaimed: boolean;\n  }\n  let merkleTreeData: AirdropTokenData[];\n\n  before(async () => {\n    airdropState = PublicKey.findProgramAddressSync([Buffer.from(\"merkle_tree\"), mint.publicKey.toBuffer()], program.programId)[0];\n    vault = await getAssociatedTokenAddress(mint.publicKey, airdropState, true);\n\n    // Airdrop SOL to authority\n    await provider.sendAndConfirm(\n      new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: provider.publicKey,\n          toPubkey: authority.publicKey,\n          lamports: 10 * LAMPORTS_PER_SOL,\n        })\n      ), \n      []\n    );\n\n    // Generate 100 random addresses and amount\n    merkleTreeData = Array.from({ length: 100 }, () => ({\n      address: Keypair.generate().publicKey,\n      amount: Math.floor(Math.random() * 1000),           // Example random amount\n      isClaimed: false,                                   // Default value for isClaimed\n    }));\n    \n    // Create Merkle Tree\n    merkleTree = new MerkleTree(HashingAlgorithm.Keccak, 32);\n    merkleTreeData.forEach((entry) => {\n      // Serialize address, amount, and isClaimed in binary format\n      const entryBytes = Buffer.concat([\n        entry.address.toBuffer(),\n        Buffer.from(new Uint8Array(new anchor.BN(entry.amount).toArray('le', 8))),\n        Buffer.from([entry.isClaimed ? 1 : 0]),\n      ]);\n      merkleTree.add_leaf(entryBytes);\n    });\n    merkleTree.merklize();\n    \n  });\n\n  it(\"Initialize airdrop data\", async () => {\n    const merkleRoot = Array.from(merkleTree.get_merkle_root());\n    const totalAirdropAmount = merkleTreeData.reduce((sum, entry) => sum + entry.amount, 0);\n\n    await program.methods.initializeAirdropData(merkleRoot, new anchor.BN(totalAirdropAmount))\n      .accountsPartial({\n        airdropState,\n        mint: mint.publicKey,\n        vault,\n        authority: authority.publicKey,\n        systemProgram: SystemProgram.programId,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        associatedTokenProgram: ASSOCIATED_PROGRAM_ID,\n      })\n```\n\n----------------------------------------\n\nTITLE: Creating an Account with a PDA in Solana Using Rust\nDESCRIPTION: This snippet provides an example of creating an account using a Program Derived Address (PDA). The `create_account_with_pda` function constructs a create account instruction and invokes it, ensuring controlled access with the PDA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/understanding-pdas.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse solana_program::{\n    pubkey::Pubkey,\n    system_instruction,\n    system_program,\n    sysvar::rent::Rent,\n    program::invoke_signed,\n};\n\nfn create_account_with_pda(\n    program_id: &Pubkey,\n    payer: &Pubkey,\n    seeds: &[&[u8]],\n    lamports: u64,\n    space: u64,\n) -> Result<(), ProgramError> {\n    let (pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);\n\n    let create_account_ix = system_instruction::create_account(\n        payer,\n        &pda,\n        lamports,\n        space,\n        program_id,\n    );\n\n    // Sign the instruction with the PDA\n    let signers_seeds = &[&seeds[..], &[bump_seed]];\n\n    invoke_signed(\n        &create_account_ix,\n        &[payer_account_info, pda_account_info],\n        signers_seeds,\n    )?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fungible Token Mint Instruction in Typescript\nDESCRIPTION: This snippet creates a fungible token mint instruction using the `createFungible` method from `@metaplex-foundation/mpl-token-metadata`. It defines the mint, name, metadata URI, seller fee basis points, and number of decimals for the token. A new signer is generated for the mint authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n  // Creating the mintIx\n\n  const mintSigner = generateSigner(umi);\n\n  const createFungibleIx = createFungible(umi, {\n    mint: mintSigner,\n    name: \"The Kitten Coin\",\n    uri: metadataUri, // we use the `metedataUri` variable we created earlier that is storing our uri.\n    sellerFeeBasisPoints: percentAmount(0),\n    decimals: 0, // set the amount of decimals you want your token to have.\n  });\n```\n\n----------------------------------------\n\nTITLE: Updating pNFT Metadata using Rust with Anchor and mpl-token-metadata\nDESCRIPTION: This Rust code snippet uses the Anchor framework and mpl-token-metadata crate to update a Programmable NFT's metadata. It defines the necessary account structure and provides an instruction to update the NFT's name and URI while preserving other metadata fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse mpl_token_metadata::\n    accounts::Metadata,\n    instructions::UpdateAsUpdateAuthorityV2CpiBuilder, types::Data,\n};\n\n#[derive(Accounts)]\npub struct NftUpdateMpl<'info> {\n    pub mint: AccountInfo<'info>,\n    /// CHECK: Handled by CPI\n    #[account(mut)]\n    pub metadata: AccountInfo<'info>,\n    #[account(mut)]\n    pub update_authority: Signer<'info>,\n    /// CHECK: Handled by CPI\n    pub token_metadata_program: AccountInfo<'info>,\n    // Add additional accounts below if needed\n}\n\npub fn update_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftUpdateMpl<'info>>,\n    new_name: Option<String>,\n    new_uri: Option<String>,\n) -> Result<()> {\n    let mint = ctx.accounts.mint.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let token_metadata_program = ctx.accounts.token_metadata_program.to_account_info();\n\n    // Get the original metadata values\n    let metadata_account = Metadata::try_from(&metadata)?;\n\n    let original_metadata = Data {\n        name: metadata_account.name,\n        symbol: metadata_account.symbol,\n        uri: metadata_account.uri,\n        seller_fee_basis_points: metadata_account.seller_fee_basis_points,\n        creators: metadata_account.creators,\n    };\n\n    let new_metadata = Data {\n        name: new_name.unwrap_or(original_metadata.name),\n        uri: new_uri.unwrap_or(original_metadata.uri),\n        ..original_metadata // Keep the rest of the metadata the same\n    };\n\n    UpdateAsUpdateAuthorityV2CpiBuilder::new(&token_metadata_program)\n        .mint(&mint)\n        .metadata(&metadata)\n        .authority(&ctx.accounts.update_authority)\n        .data(new_metadata)\n        \n        // Add remaining data fields to be adjusted to the CPI if needed\n        // https://docs.rs/mpl-token-metadata/latest/mpl_token_metadata/instructions/struct.UpdateAsUpdateAuthorityV2CpiBuilder.html       \n        //\n        // .authorization_rules(authorization_rules)\n        // .authorization_rules_program(authorization_rules_program)\n        // .token_record(token_record)\n        .invoke()?\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Attribute Plugin in Rust\nDESCRIPTION: This code updates the attribute plugin with new or modified attributes using the UpdatePluginV1CpiBuilder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nUpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::Attributes(Attributes{ attribute_list }))\n    .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Adding Oracle Plugin to Existing Asset - TypeScript\nDESCRIPTION: Adds an Oracle plugin to an existing MPL Core asset using the @metaplex-foundation/mpl-core library. Configures the plugin with Anchor results offset and create lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\naddPlugin(umi, {\n  asset,\n  plugin: {\n    type: 'Oracle',\n    resultsOffset: {\n      type: 'Anchor',\n    },\n    lifecycleChecks: {\n      create: [CheckResult.CAN_REJECT],\n    },\n    baseAddress: oracleAccount,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Generating a New Wallet with Umi\nDESCRIPTION: Setting up Umi with a generated signer and performing an SOL airdrop for testing\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n  .use(mplCore())\n  .use(irysUploader())\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// Tell umi to use the new signer.\numi.use(signerIdentity(signer))\n\n// Airdrop 1 SOL to the identity\nawait umi.rpc.airdrop(umi.identity.publicKey)\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Guard Configuration in TypeScript\nDESCRIPTION: This snippet demonstrates how to modify guard settings on an existing Candy Machine, showing how to disable certain guards and update others while preserving existing configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/update.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none, sol } from '@metaplex-foundation/umi'\n\nconst candyGuard = await fetchCandyGuard(umi, candyGuardId)\nawait updateCandyGuard(umi, {\n  candyGuard: candyGuard.publicKey,\n  guards: {\n    ...candyGuard.guards,\n    botTax: none(),\n    solPayment: some({ lamports: sol(3), destination: treasury }),\n  },\n  groups: [\n    // Either empty, or if you are using groups add the data here\n  ]\n})\n```\n\n----------------------------------------\n\nTITLE: Transferring a Compressed NFT with Delegate Authorization in TypeScript\nDESCRIPTION: This snippet shows how to transfer a Compressed NFT using a delegate's authorization instead of the owner. It uses the same proof fetching approach but specifies the delegate as the authority for the transfer operation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/transfer-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, transfer } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait transfer(umi, {\n  ...assetWithProof,\n  leafDelegate: currentLeafDelegate,\n  newLeafOwner: newLeafOwner.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Plugin using TypeScript/UMI\nDESCRIPTION: Updates a collection plugin's configuration using the Metaplex UMI SDK. Example shows updating royalty settings with new creator and basis points.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updateCollectionPlugin, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst collectionAddress = publicKey('1111111111111111111111111111111')\n\nconst newCreator = publicKey('5555555555555555555555555555555')\n\nawait updateCollectionPlugin(umi, {\n  collection: collectionAddress,\n  plugin: {\n    type: 'Royalties',\n    basisPoints: 400,\n    creators: [{ address: newCreator, percentage: 100 }],\n    ruleSet: ruleSet('None'),\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Transactions with Umi in TypeScript\nDESCRIPTION: This snippet shows how to serialize and deserialize transactions and their messages using Umi's TransactionFactoryInterface.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySerializedTransaction = umi.transactions.serialize(myTransaction)\nconst myTransaction = umi.transactions.deserialize(mySerializedTransaction)\nconst mySerializedMessage = umi.transactions.serializeMessage(myMessage)\nconst myMessage = umi.transactions.deserializeMessage(mySerializedMessage)\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Machine Details using Metaplex Library in TypeScript\nDESCRIPTION: This code snippet shows how to fetch the details of a created candy machine using the 'fetchCandyMachine' method from the 'mpl-core-candy-machine' library. It requires UMI and the public key of the candy machine as inputs. The output is the details of the candy machine, which includes metadata such as owner, lamports, and guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { fetchCandyMachine } from '@metaplex-foundation/mpl-core-candy-machine';\n\nlet candyMachineDetails = await fetchCandyMachine(umi, candyMachine.publicKey);\n\nconsole.log(\"Candy Machine Details: \\n\", candyMachineDetails);\n\n```\n\n----------------------------------------\n\nTITLE: Approving Data Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code example shows how to approve a Data Delegate using the delegateDataV1 function. It sets up a delegate that can update the entire data object of the Metadata account, including creators.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateDataV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateDataV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: dataDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Verifying Creator of Compressed NFT in TypeScript\nDESCRIPTION: This code snippet demonstrates how to verify a creator for a Compressed NFT using the Bubblegum program. It uses the getAssetWithProof and verifyCreator functions from the mpl-bubblegum package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/verify-creators.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  verifyCreator,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait verifyCreator(umi, { ...assetWithProof, creator }).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Burning a Compressed NFT using a delegate in JavaScript with mpl-bubblegum\nDESCRIPTION: This snippet shows how to burn a Compressed NFT using a delegate authority. It uses the burn function from the mpl-bubblegum library, fetching the asset with proof and specifying the leaf delegate instead of the leaf owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/burn-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, burn } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait burn(umi, {\n  ...assetWithProof,\n  leafDelegate: currentLeafDelegate,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Burning pNFT Asset using JavaScript with Umi\nDESCRIPTION: This snippet demonstrates how to burn a programmable NFT (pNFT) using the Umi framework in JavaScript. It fetches the pNFT asset, determines if it's part of a collection, and burns the asset. The code handles additional required accounts such as token account and token record.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  burnV1,\n  fetchDigitalAssetWithAssociatedToken,\n  findMetadataPda,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { publicKey, unwrapOption } from '@metaplex-foundation/umi'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\n\n// The pNFT mint ID\nconst mintId = publicKey('11111111111111111111111111111111')\n\n// Fetch the pNFT Asset with the Token Account\nconst assetWithToken = await fetchDigitalAssetWithAssociatedToken(\n  umi,\n  mintId,\n  umi.identity.publicKey\n)\n\n// Determine if the pNFT Asset is in a collection\nconst collectionMint = unwrapOption(assetWithToken.metadata.collection)\n\n// If there's a collection find the collection metadata PDAs\nconst collectionMetadata = collectionMint\n  ? findMetadataPda(umi, { mint: collectionMint.key })\n  : null\n\n// Burn the pNFT Asset\nconst res = await burnV1(umi, {\n  mint: mintId,\n  collectionMetadata: collectionMetadata || undefined,\n  token: assetWithToken.token.publicKey,\n  tokenRecord: assetWithToken.tokenRecord?.publicKey,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n\nconst signature = base58.deserialize(tx.signature)[0]\nconsole.log('Transaction Signature: ' + signature)\n```\n\n----------------------------------------\n\nTITLE: Updating Loyalty Card Data with Rust on Solana\nDESCRIPTION: Demonstrates handling purchase and reward redemption logic for a loyalty card system. The code checks for point redemption or processes a purchase transaction, updates stamps and timestamps, and writes the updated data back to the AppData plugin. Includes error handling for insufficient points and transaction validation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/loyalty-card-concept-guide.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmatch redeem {\n    true => {\n        if loyalty_card_data.current_stamps < COST_OF_COFFEE_IN_POINTS {\n            return Err(LoyaltyProgramError::NotEnoughPoints.into());\n        }\n        loyalty_card_data.current_stamps -= COST_OF_COFFEE_IN_POINTS;\n    }\n    false => {\n        invoke(\n            &system_instruction::transfer(\n                &ctx.accounts.signer.key(),\n                &ctx.accounts.destination_account.key(),\n                COST_OF_COFFEE_IN_LAMPORTS,\n            ),\n            &[ctx.accounts.signer.to_account_info(), ctx.accounts.destination_account.to_account_info()],\n        )?;\n\n        if loyalty_card_data.current_stamps < MAX_POINTS {\n            loyalty_card_data.current_stamps += 1;\n        }\n        loyalty_card_data.lifetime_stamps += 1;\n    }\n}\n\nloyalty_card_data.last_used = clock::Clock::get().unwrap().unix_timestamp as u64;\n\nlet binary = bincode::serialize(&loyalty_card_data).unwrap();\n\nWriteExternalPluginAdapterDataV1CpiBuilder::new(&ctx.accounts.core_program)\n    .asset(&ctx.accounts.loyalty_card)\n    .key(ExternalPluginAdapterKey::AppData(PluginAuthority::Address { address: ctx.accounts.loyalty_authority.key() }))\n    .data(binary)\n    .invoke_signed(seeds)?\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions with Wallet Adapter\nDESCRIPTION: This TypeScript function sends and confirms transactions using the latest wallet adapter state from the Zustand Umi store, providing the transaction signature as a string. It includes features like setting priority fees and skipping preflight checks for debugging. Required dependencies include metaplex-foundation's libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst sendAndConfirmWalletAdapter = async (\n  tx: TransactionBuilder,\n  settings?: {\n    commitment?: 'processed' | 'confirmed' | 'finalized'\n    skipPreflight?: boolean\n  }\n) => {\n  const umi = useUmiStore.getState().umi\n  const currentSigner = useUmiStore.getState().signer\n  umi.use(signerIdentity(currentSigner!))\n\n  const blockhash = await umi.rpc.getLatestBlockhash({\n    commitment: settings?.commitment || 'confirmed',\n  })\n\n  const transactions = tx\n    .add(setComputeUnitPrice(umi, { microLamports: BigInt(100000) }))\n    .setBlockhash(blockhash)\n\n  const signedTx = await transactions.buildAndSign(umi)\n\n  const signature = await umi.rpc\n    .sendTransaction(signedTx, {\n      preflightCommitment: settings?.commitment || 'confirmed',\n      commitment: settings?.commitment || 'confirmed',\n      skipPreflight: settings?.skipPreflight || false,\n    })\n    .catch((err) => {\n      throw new Error(`Transaction failed: ${err}`)\n    })\n\n  const confirmation = await umi.rpc.confirmTransaction(signature, {\n    strategy: { type: 'blockhash', ...blockhash },\n    commitment: settings?.commitment || 'confirmed',\n  })\n  return {\n    signature: base58.deserialize(signature),\n    confirmation,\n  }\n}\n\nexport default sendAndConfirmWalletAdapter\n```\n\n----------------------------------------\n\nTITLE: Creating Master Edition NFT with Print Supply in TypeScript\nDESCRIPTION: Demonstrates how to create a printable NFT by configuring the Print Supply attribute. Shows setting up a limited or unlimited supply Master Edition NFT using the Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/print.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount, generateSigner } from '@metaplex-foundation/umi'\nimport { createNft, printSupply } from '@metaplex-foundation/mpl-token-metadata'\n\nconst mint = generateSigner(umi)\nawait createNft(umi, {\n  mint,\n  name: 'My Master Edition NFT',\n  uri: 'https://example.com/my-nft.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  printSupply: printSupply('Limited', [100]), // Or printSupply('Unlimited')\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Burning a Standalone Core NFT Asset\nDESCRIPTION: Demonstrates how to burn a Core NFT asset using the Metaplex SDK. The code assumes the executor is the owner of the asset and shows the basic burn operation that returns rent-exempt fees to the owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  burn,\n  fetchAsset,\n  collectionAddress,\n  fetchCollection,\n} from '@metaplex-foundation/mpl-core'\n\nconst assetId = publicKey('11111111111111111111111111111111')\nconst asset = await fetchAsset(umi, assetId)\n\nawait burn(umi, {\n  asset: asset,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::BurnV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn burn_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let burn_asset_ix = BurnV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let burn_asset_tx = Transaction::new_signed_with_payer(\n        &[burn_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&burn_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Update Authority in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch multiple NFT assets by their update authority using the fetchAssetsByUpdateAuthority function from the Metaplex Core package in JavaScript.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { fetchAssetsByUpdateAuthority } from '@metaplex-foundation/mpl-core'\n\nconst updateAuthority = publicKey('11111111111111111111111111111111')\n\nconst assetsByUpdateAuthority = await fetchAssetsByUpdateAuthority(\n  umi,\n  updateAuthority,\n  { skipDerivePlugins: false }\n)\n\nconsole.log(assetsByUpdateAuthority)\n```\n\n----------------------------------------\n\nTITLE: Revoking Delegate Authority for Compressed NFT using Bubblegum in TypeScript\nDESCRIPTION: This code snippet shows how to revoke the delegate authority of a compressed NFT by setting the owner as the new delegate. It uses the Metaplex Bubblegum library to fetch the asset and send a delegate instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/delegate-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, delegate } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait delegate(umi, {\n  ...assetWithProof,\n  leafOwner,\n  previousLeafDelegate: currentDelegate,\n  newLeafDelegate: leafOwner.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Thawing and Removing FreezeDelegate Plugin for NFT Unstaking in Rust\nDESCRIPTION: This snippet demonstrates how to thaw an NFT asset and remove the FreezeDelegate plugin after unstaking, using the Metaplex Core framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nUpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n.asset(&ctx.accounts.asset.to_account_info())\n.collection(Some(&ctx.accounts.collection.to_account_info()))\n.payer(&ctx.accounts.payer.to_account_info())\n.authority(Some(&ctx.accounts.update_authority.to_account_info()))\n.system_program(&ctx.accounts.system_program.to_account_info())\n.plugin(Plugin::FreezeDelegate( FreezeDelegate{ frozen: false } ))\n.invoke()?\n\nRemovePluginV1CpiBuilder::new(&ctx.accounts.core_program)\n.asset(&ctx.accounts.asset.to_account_info())\n.collection(Some(&ctx.accounts.collection.to_account_info()))\n.payer(&ctx.accounts.payer)\n.authority(Some(&ctx.accounts.owner))\n.system_program(&ctx.accounts.system_program)\n.plugin_type(PluginType::FreezeDelegate)\n.invoke()?\n```\n\n----------------------------------------\n\nTITLE: Implementing Fungible Token Release in MPL-Hybrid\nDESCRIPTION: Shows how to release (swap to) fungible tokens using the MPL-Hybrid protocol. The code builds upon the capture implementation to handle the reverse operation, allowing users to swap their NFTs back to tokens.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/swapping.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ... releaseV1 } from '@metaplex-foundation/mpl-hybrid'\n\n... (see above code)\n\nconst ownedAssets = assetsByCollection.filter(a => a.owner === umi.identity.publicKey )\n// TYPICALLY A USER WOULD CHOOSE A SPECIFIC ASSET THE WOULD LIKE TO SWAP TO TOKENS\n\nconst releaseData = {\n  owner: umi.identity,\n  escrow: ESCROW,\n  asset: ownedAssets[0].publicKey,\n  collection: COLLECTION,\n  feeProjectAccount: FEE_WALLET,\n  token: TOKEN\n}\n\nconst releaseTx = await releaseV1(umi, releaseData).sendAndConfirm(umi)\n\nconsole.log(bs58.encode(releaseTx.signature))\n```\n\n----------------------------------------\n\nTITLE: Defining the Umi Interface for Plugin Registration\nDESCRIPTION: This code defines the `Umi` interface, extending the `Context` interface with a `use` method for registering plugins. This enables end-users to extend the functionality of their Umi instance by adding custom logic or integrations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/interfaces.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Umi extends Context {\n  use(plugin: UmiPlugin): Umi;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with MPL-Core\nDESCRIPTION: Example of setting up an Umi instance with MPL-Core integration, including RPC endpoint configuration and package initialization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/sdk/javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplCore } from '@metaplex-foundation/mpl-core'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://api.devenet.solana.com')\n... // additional umi settings, packages, and signers\n.use(mplCore())\n```\n\n----------------------------------------\n\nTITLE: Using Route Instruction with Allow List Guard in JavaScript/TypeScript\nDESCRIPTION: This code demonstrates how to call the route instruction for an Allow List guard using the Umi library. It shows the process of creating a Candy Machine with an Allow List guard, preparing the Merkle Root and Proof, and verifying the wallet's Merkle Proof before minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-route.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  route,\n  getMerkleProof,\n  getMerkleRoot,\n} from '@metaplex-foundation/mpl-candy-machine'\n\n// Prepare the allow list.\n// Let's assume the first wallet on the list is the Metaplex identity.\nconst allowList = [\n  'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n  '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',\n  'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n]\nconst merkleRoot = getMerkleRoot(allowList)\n\n// Create a Candy Machine with an Allow List guard.\nawait create(umi, {\n  // ...\n  guards: {\n    allowList: some({ merkleRoot }),\n  },\n}).sendAndConfirm(umi)\n\n// If we try to mint now, it will fail because\n// we did not verify our Merkle Proof.\n\n// Verify the Merkle Proof using the route instruction.\nawait route(umi, {\n  candyMachine: candyMachine.publicKey,\n  guard: 'allowList',\n  routeArgs: {\n    path: 'proof',\n    merkleRoot,\n    merkleProof: getMerkleProof(\n      allowList,\n      'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS'\n    ),\n  },\n}).sendAndConfirm(umi)\n\n// If we try to mint now, it will succeed.\n```\n\n----------------------------------------\n\nTITLE: Updating NFT Asset with Complete Example\nDESCRIPTION: Complete example showing how to update an NFT asset using the Token Metadata program, including fetching initial metadata and updating multiple attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateV1,\n  fetchMetadataFromSeeds,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst initialMetadata = await fetchMetadataFromSeeds(umi, { mint })\nawait updateV1(umi, {\n  mint,\n  authority: updateAuthority,\n  data: { ...initialMetadata, name: 'Updated Asset' },\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{\n    metadata::{mpl_token_metadata::types::DataV2, update_metadata_accounts_v2, MetadataAccount, UpdateMetadataAccountsV2},\n    token::Mint,\n};\n\n#[derive(Accounts)]\npub struct UpdateNft<'info> {\n    #[account(mut)]\n    pub mint: Account<'info, Mint>,\n    /// CHECK: Handled by CPI\n    #[account(mut)]\n    pub metadata: Account<'info, MetadataAccount>,\n    #[account(mut)]\n    pub update_authority: Signer<'info>,\n    /// CHECK: Handled by CPI\n    pub token_metadata_program: AccountInfo<'info>,\n}\n\npub fn update_nft_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, UpdateNft<'info>>,\n    new_name: Option<String>,\n    new_uri: Option<String>,\n) {\n    let cpi_accounts = UpdateMetadataAccountsV2 {\n        metadata: ctx.accounts.metadata.to_account_info().clone(),\n        update_authority: ctx.accounts.update_authority.to_account_info().clone(),\n    };\n\n    let cpi_ctx = CpiContext::new(\n        ctx.accounts.token_metadata_program.clone(),\n        cpi_accounts,\n    );\n\n    let original_metadata = DataV2 {\n        name: ctx.accounts.metadata.name.clone(),\n        symbol: ctx.accounts.metadata.symbol.clone(),\n        uri: ctx.accounts.metadata.uri.clone(),\n        seller_fee_basis_points: ctx.accounts.metadata.seller_fee_basis_points,\n        creators: ctx.accounts.metadata.creators.clone(),\n        collection: ctx.accounts.metadata.collection.clone(),\n        uses: ctx.accounts.metadata.uses.clone(),\n    };\n\n    let new_metadata = DataV2 {\n        name: new_name.clone().unwrap_or(original_metadata.name),\n        uri: new_uri.clone().unwrap_or(original_metadata.uri),\n        ..original_metadata\n    };\n\n    update_metadata_accounts_v2(\n        cpi_ctx,\n        None, // New update authority\n        Some(new_metadata), // Data\n        None, // Primary sale happened\n        None, // Is mutable\n    ).expect(\"Failed to update NFT metadata\");\n}\n```\n\n----------------------------------------\n\nTITLE: Transaction Serialization Example\nDESCRIPTION: Complete example of creating and serializing a transaction with collection authority and asset signatures\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst collectionAuthority = generateSigner(umi)\numi.use(signerIdentity(collectionAuthority))\n\nconst frontendPubkey = publickey('11111111111111111111111111111111')\nconst frontEndSigner = createNoopSigner(frontendPubkey)\n\nconst asset = generateSigner(umi);\n\nconst collection = await fetchCollection(umi, publickey(`11111111111111111111111111111111`)); \n\nconst createAssetTx = await create(umi, {\n  asset: asset,\n  collection: collection,\n  authority: collectionAuthority,\n  payer: frontEndSigner,\n  owner: frontendPubkey,\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n})\n  .useV0()\n  .setBlockhash(await umi.rpc.getLatestBlockhash())\n  .buildAndSign(umi);\n\nconst serializedCreateAssetTx = umi.transactions.serialize(createAssetTx)\n\nconst serializedCreateAssetTxAsString = base64.deserialize(serializedCreateAssetTx)[0];\n\nreturn serializedCreateAssetTxAsString\n```\n\n----------------------------------------\n\nTITLE: Minting Tokens with Token Metadata in TypeScript\nDESCRIPTION: This snippet demonstrates how to mint tokens using the Mint V1 instruction of the Token Metadata program in TypeScript. It uses the @metaplex-foundation/mpl-token-metadata library to mint a Non-Fungible token.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\n\nawait mintV1(umi, {\n  mint: mint.publicKey,\n  authority,\n  amount: 1,\n  tokenOwner,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Helpers for Data Enums\nDESCRIPTION: Provides functions for working with data enums in Kinobi-generated clients, like creating or checking message variants. The 'message' function generates a new data enum variant, while 'isMessage' checks its type. This enhances the developer experience with enums in generated clients.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nmessage('Quit'); // -> { __kind: 'Quit' }\nmessage('Write', ['Hi']); // -> { __kind: 'Write', fields: ['Hi'] }\nmessage('Move', { x: 5, y: 6 }); // -> { __kind: 'Move', x: 5, y: 6 }\nisMessage('Quit', message('Quit')); // -> true\nisMessage('Write', message('Quit')); // -> false\n```\n\n----------------------------------------\n\nTITLE: Creating Core Asset with Plugins using CreateV2CpiBuilder in Rust\nDESCRIPTION: This snippet demonstrates how to use the CreateV2CpiBuilder to create a Core Asset, including the configuration of plugins and external plugin adapters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nCreateV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n  .asset(&ctx.accounts.asset.to_account_info())\n  .collection(collection.as_ref())\n  .authority(authority.as_ref())\n  .payer(&ctx.accounts.payer.to_account_info())\n  .owner(owner.as_ref())\n  .update_authority(update_authority.as_ref())\n  .system_program(&ctx.accounts.system_program.to_account_info())\n  .name(args.name)\n  .uri(args.uri)\n  .plugins(plugins)\n  .external_plugin_adapters(external_plugin_adapters)    \n  .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Checking Plugin Update Authority in TypeScript\nDESCRIPTION: This function checks if a given public key has update authority over a plugin. It returns a boolean value based on whether the plugin's authority is set to an UpdateAuthority type and matches the provided public key, asset, and optional collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginUpdateAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority,\n  asset: AssetV1,\n  collection?: CollectionV1\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Address Lookup Tables for Transaction Size Reduction\nDESCRIPTION: Shows how to set up address lookup tables to reduce transaction size, which is particularly useful for complex transactions with many different addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst myLut: AddressLookupTableInput = {\n  publicKey: publicKey('...') // The address of the lookup table account.\n  addresses: [ // The addresses registered in the lookup table.\n    publicKey('...'),\n    publicKey('...'),\n    publicKey('...'),\n  ]\n}\n\nbuilder = builder.setAddressLookupTables([myLut]);\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple MPL Core Collection in Rust\nDESCRIPTION: This snippet shows how to create a basic Metaplex Core collection using Rust. It includes setting up the RPC client, creating necessary keypairs, and sending the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::CreateCollectionV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let collection = Keypair::new();\n\n    let create_collection_ix = CreateCollectionV1Builder::new()\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Collection\".into())\n        .uri(\"https://example.com/my-collection.json\".into())\n        .instruction();\n\n    let signers = vec![&collection, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_tx = Transaction::new_signed_with_payer(\n        &[create_collection_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Token Auth Rule Set using TypeScript\nDESCRIPTION: Demonstrates how to create or update a Token Authorization Rule Set using the Metaplex Foundation's token auth rules library. The code shows initialization of rule set parameters, creation of revision data, and submitting the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/create-or-update.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  RuleSetRevisionV2,\n  createOrUpdateV1,\n  findRuleSetPda,\n  programOwnedV2,\n} from '@metaplex-foundation/mpl-token-auth-rules';\n\nconst owner = umi.identity;\nconst program = generateSigner(umi).publicKey;\nconst name = 'transfer_test';\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name,\n  owner: owner.publicKey,\n  operations: {\n    Transfer: programOwnedV2('Destination', program),\n  },\n};\n\n// When we create a new rule set account using this data.\nconst ruleSetPda = findRuleSetPda(umi, { owner: owner.publicKey, name });\nawait createOrUpdateWithBufferV1(umi, {\n  payer: owner,\n  ruleSetPda,\n  ruleSetRevision: some(revision),\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Fetching an MPL Core Collection in Rust\nDESCRIPTION: This snippet shows how to fetch a Metaplex Core collection using Rust. It retrieves the collection data from the RPC client and deserializes it into a Collection struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::Collection;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::pubkey::Pubkey;\n\npub async fn fetch_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let collection_id = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client.get_account_data(&collection_id).await.unwrap();\n\n    let collection = Collection::from_bytes(&rpc_data).unwrap();\n\n    print!(\"{:?}\", collection)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Data using Rust\nDESCRIPTION: Implementation of collection update functionality using Rust and Solana SDK. Creates and sends a transaction to update collection metadata with new name and URI values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\n\nuse mpl_core::instructions::UpdateCollectionV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn update_collection() {\n\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let update_collection_ix = UpdateCollectionV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .new_name(\"My Collection\".into())\n        .new_uri(\"https://example.com/my-collection.json\".into())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let update_collection_tx = Transaction::new_signed_with_payer(\n        &[update_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&update_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking pNFT Asset with Token Metadata\nDESCRIPTION: Demonstrates how to unlock a programmable NFT (pNFT) using the Token Metadata program. Includes fetching associated token accounts and handling token records.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/lock.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    fetchDigitalAssetWithAssociatedToken,\n    TokenStandard,\n    unlockV1\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { publicKey } from \"@metaplex-foundation/umi\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\n// Mint pNFT ID of the Asset\nconst mintId = publicKey(\"11111111111111111111111111111111\");\n\n// Fetch the mint token accounts\nconst assetWithToken = await fetchDigitalAssetWithAssociatedToken(\n  umi,\n  mintId,\n  umi.identity.publicKey\n);\n\n// Send unlock instruction\nconst { signature } = await unlockV1(umi, {\n  // Mint ID of the pNFT Asset\n  mint: mintId,\n  // Update Authority or Delegate Authority\n  authority: umi.identity,\n  // Token Standard\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  // Owner of the pNFT Assets\n  tokenOwner: assetWithToken.token.owner,\n  // Token Account of the pNFT Asset\n  token: assetWithToken.token.publicKey,\n  // Token Record of the pNFT Asset\n  tokenRecord: assetWithToken.tokenRecord?.publicKey,\n}).sendAndConfirm(umi);\n\nconsole.log(\"Signature: \", base58.deserialize(signature));\n```\n\n----------------------------------------\n\nTITLE: Uploading JSON Metadata with NFT.Storage in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the NFT.Storage uploader with Umi to upload JSON metadata for NFTs. It shows setting up the uploader and uploading both asset files and JSON metadata.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/insert-items.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { nftStorage } from '@metaplex-foundation/umi-uploader-nft-storage'\numi.use(nftStorageUploader({ token: 'YOUR_API_TOKEN' }))\n\nimport { createGenericFileFromBrowserFile } from '@metaplex-foundation/umi'\n\n// Upload the asset.\nconst file = await createGenericFileFromBrowserFile(event.target.files[0])\nconst [fileUri] = await umi.uploader.upload([file])\n\n// Upload the JSON metadata.\nconst uri = await umi.uploader.uploadJson({\n  name: 'My NFT #1',\n  description: 'My description',\n  image: fileUri,\n})\n```\n\n----------------------------------------\n\nTITLE: Serializing MsgPack Data\nDESCRIPTION: Implementation of MsgPack data serialization for AppData plugin in TypeScript and Rust\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// This implementation uses `msgpack-lite` for serialization\n\nconst json = {\n  timeStamp: Date.now(),\n  message: 'Hello, World!',\n}\n\nconst data = msgpack.encode(json)\n```\n\nLANGUAGE: rust\nCODE:\n```\n// This uses `serde` and the `rmp-serde` crates.\n\nlet data = MyData {\n    timestamp: 1234567890,\n    message: \"Hello World\".to_string(),\n};\n\nlet data = rmp_serde::to_vec(&data).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Minting Tokens to a Token Account in Typescript\nDESCRIPTION: This snippet creates an instruction to mint tokens to a specific token account using the `mintTokensTo` method from `@metaplex-foundation/mpl-toolbox`. It specifies the mint, the token account PDA (derived using `findAssociatedTokenPda`), and the amount of tokens to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n  // The final instruction (if required) is to mint the tokens to the token account in the previous ix.\n\n  const mintTokensIx = mintTokensTo(umi, {\n    mint: mintSigner.publicKey,\n    token: findAssociatedTokenPda(umi, {\n      mint: mintSigner.publicKey,\n      owner: umi.identity.publicKey,\n    }),\n    amount: BigInt(1000),\n  });\n```\n\n----------------------------------------\n\nTITLE: Uploading Token Image to Arweave\nDESCRIPTION: Process of reading and uploading a token image file using Umi's Irys uploader\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst imageFile = fs.readFileSync('./image.jpg')\n\nconst umiImageFile = createGenericFile(imageFile, 'image.jpeg', {\n  tags: [{ name: 'contentType', value: 'image/jpeg' }],\n})\n\nconst imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n  throw new Error(err)\n})\n\nconsole.log(imageUri[0])\n```\n\n----------------------------------------\n\nTITLE: Updating MPL-Hybrid Escrow using TypeScript\nDESCRIPTION: This snippet details how to update an existing MPL-Hybrid escrow configuration, reusing similar structures from initialization but utilizing the updateEscrowV1 function. Dependencies are similar to those required for initialization, focusing on updating metadata with metamask-foundation tools. It supports input parameters like updated escrowData and ensures the updated transaction is broadcast, expecting a signature in return.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/escrow.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mplHybrid, updateEscrowV1 } from '@metaplex-foundation/mpl-hybrid'\n\n... (SEE ABOVE CODE)\n\nconst updateTx = await updateEscrowV1(umi, escrowData).sendAndConfirm(umi)\n\nconsole.log(bs58.encode(updateTx.signature))\n\n```\n\n----------------------------------------\n\nTITLE: Searching Core Assets with Filters in JavaScript using the DAS API\nDESCRIPTION: This code demonstrates how to search for Core assets using the DAS API with owner and jsonUri filters. The example initializes a UMI instance with the DAS API extension and searches for assets owned by a specific wallet that match a given metadata URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/search-assets.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst asset = await das.searchAssets(umi, {\n    owner: publicKey('AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx'),\n    jsonUri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n});\n\nconsole.log(asset);\n```\n\n----------------------------------------\n\nTITLE: Creating Mint with Associated Token Account in Solana using Umi\nDESCRIPTION: This helper function creates a Mint account and an Associated Token account for the given mint and owner using Umi. It can also mint tokens to the account if an amount greater than zero is provided.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createMintWithAssociatedToken } from '@metaplex-foundation/mpl-toolbox'\n\nconst mint = generateSigner(umi)\n\nawait createMintWithAssociatedToken(umi, {\n  mint,\n  owner,\n  amount: 1,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deleting Candy Machine and Candy Guard accounts using Umi library in TypeScript\nDESCRIPTION: This code snippet demonstrates how to delete a Candy Machine account and its associated Candy Guard account using the Umi library. It uses the deleteCandyMachine and deleteCandyGuard functions from the @metaplex-foundation/mpl-candy-machine package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  deleteCandyMachine,\n  deleteCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nawait deleteCandyMachine(umi, {\n  candyMachine: candyMachine.publicKey,\n}).sendAndConfirm(umi)\n\nawait deleteCandyGuard(umi, {\n  candyGuard: candyMachine.mintAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Default Guards and Guard Groups in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with default guards and multiple guard groups using the Umi library. It sets up a bot tax guard as a default guard and defines two groups with different Sol Payment, Start Date, and End Date guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-groups.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n  },\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Delegated Transfer of Non-Fungible Token in TypeScript\nDESCRIPTION: This snippet illustrates how to perform a delegated transfer of a non-fungible token using the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait transferV1(umi, {\n  mint,\n  authority: standardDelegate,\n  tokenOwner: currentOwner,\n  destinationOwner: newOwner,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Machine Data in TypeScript\nDESCRIPTION: Shows how to fetch an existing Candy Machine and its associated Candy Guard account using their addresses with the Metaplex SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  fetchCandyMachine,\n  fetchCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachine = await fetchCandyMachine(umi, publicKey('...'))\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\n```\n\n----------------------------------------\n\nTITLE: Fetching Attribute Plugin for NFT Asset in Rust\nDESCRIPTION: This snippet demonstrates how to fetch the attribute plugin for an NFT asset using the Metaplex Core framework. It includes error handling for when the attribute plugin is not initialized.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nmatch fetch_plugin::<BaseAssetV1, Attributes>(&ctx.accounts.asset.to_account_info(), mpl_core::types::PluginType::Attributes)\n\nErr(_) => {\n    return Err(StakingError::AttributesNotInitialized.into());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection Asset for NFTs\nDESCRIPTION: Creating a collection asset using the mpl-core library's createCollection method. This includes setting up royalties, multiple creators with different percentages, and setting the NFT details like name and URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCollection, ruleSet } from '@metaplex-foundation/mpl-core';\n\nconst collectionMint = generateSigner(umi);\n\nconst creator1 = generateSigner(umi).publicKey;\nconst creator2 = generateSigner(umi).publicKey;\n\nconsole.log(\"collection update authority: \", collectionUpdateAuthority.publicKey);\nawait createCollection(umi, {\n    collection: collectionMint,\n    name: 'My NFT',\n    uri: 'https://example.com/my-nft.json',\n    plugins: [\n        {\n            type: 'Royalties',\n            basisPoints: 500,\n            creators: [\n            {\n                address: creator1,\n                percentage: 20,\n            },\n            {\n                address: creator2,\n                percentage: 80,\n            },\n        ],\n        ruleSet: ruleSet('None'),\n        },\n    ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Validating Asset Transfer in TypeScript\nDESCRIPTION: This function validates whether a given authority is eligible to transfer an asset. It returns a boolean value based on the provided umi, authority, asset, collection, and recipient.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function validateTransfer(\n  umi,\n  { authority, asset, collection, recipient }\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an MPL Core Collection with Royalties Plugin in Rust\nDESCRIPTION: This snippet shows how to create a Metaplex Core collection with the Royalties plugin attached using Rust. It includes setting up the plugin with creators and rule set.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::CreateCollectionV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_collection_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let collection = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_collection_ix = CreateCollectionV1Builder::new()\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::Royalties(Royalties {\n                basis_points: 500,\n                creators: vec![Creator {\n                    address: creator,\n                    percentage: 100,\n                }],\n                rule_set: RuleSet::None,\n            }),\n            authority: Some(PluginAuthority::None),\n        }])\n        .instruction();\n\n    let signers = vec![&collection, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_tx = Transaction::new_signed_with_payer(\n        &[create_collection_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating MPL Core with Umi in TypeScript\nDESCRIPTION: Demonstrates how to create and configure a Umi instance with the mpl-core package in a TypeScript environment. Key parameters include the RPC endpoint URL. Requires the Umi Framework and mpl-core package installed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/sdk/javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplCandyMachine } from '@metaplex-foundation/mpl-core-candy-machine'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://api.devnet.solana.com')\n... // additional umi settings, packages, and signers\n.use(mplCandyMachine())\n```\n\n----------------------------------------\n\nTITLE: Querying Collection ID for Core Asset in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch a Core Asset and determine if it belongs to a collection using JavaScript. It uses the @metaplex-foundation/mpl-core library to fetch the asset and check its collection status.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/what-is-an-asset.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetchAssetV1 } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAssetV1(umi, assetAddress.publicKey)\nconst collectionId = collectionAddress(asset)\n\nconsole.log({collectionId})\nconsole.log({asset})\n\n// log\ncollection: '2222222222222222222222222222222'\nasset: {\n    key: AssetV1,\n    owner: \"11111111111111111111111111111111\",\n    updateAuthority: {\n      type: 'Collection',\n      address: '2222222222222222222222222222222'\n    },\n    name: \"My Core Asset\",\n    uri: \"https://example.com/metadata.json\",\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Core Collection with External Plugin in TypeScript\nDESCRIPTION: Shows how to create a new Core Collection with an Oracle plugin using TypeScript and Umi framework. Includes collection initialization with name, URI, and plugin configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport { createCollection, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n  plugins: [\n    {\n      type: 'Oracle',\n      resultsOffset: {\n        type: 'Anchor',\n      },\n      lifecycleChecks: {\n        update: [CheckResult.CAN_REJECT],\n      },\n      baseAddress: oracleAccount,\n    },\n    ,\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Update Authority in Rust\nDESCRIPTION: This Rust code fetches multiple NFT assets by their update authority. It uses the Solana RPC client with filters to get program accounts and then deserializes them into BaseAssetV1 structs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub async fn fetch_assets_by_update_authority() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let update_authority = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client\n        .get_program_accounts_with_config(\n            &MPL_CORE_ID,\n            RpcProgramAccountsConfig {\n                filters: Some(vec![\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        0,\n                        MemcmpEncodedBytes::Bytes(vec![Key::AssetV1 as u8]),\n                    )),\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        34,\n                        MemcmpEncodedBytes::Bytes(vec![1 as u8]),\n                    )),\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        35,\n                        MemcmpEncodedBytes::Base58(update_authority.to_string()),\n                    )),\n                ]),\n                account_config: RpcAccountInfoConfig {\n                    encoding: None,\n                    data_slice: None,\n                    commitment: None,\n                    min_context_slot: None,\n                },\n                with_context: None,\n            },\n        )\n        .await\n        .unwrap();\n\n    let accounts_iter = rpc_data.into_iter().map(|(_, account)| account);\n\n    let mut assets: Vec<BaseAssetV1> = vec![];\n\n    for account in accounts_iter {\n        let asset = BaseAssetV1::from_bytes(&account.data).unwrap();\n        assets.push(asset);\n    }\n\n    print!(\"{:?}\", assets)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching MPL Core Collection Data Using DAS API in JavaScript\nDESCRIPTION: This code fetches the information of an MPL Core Collection using the DAS API. It requires the Umi framework from Metaplex Foundation and the collection's public key. The response includes the collection's metadata, owner information, and parsed Plugin data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-collection.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst collectionId = publicKey('<PublicKey>');\n\nconst collection = await das.getCollection(umi, collectionId);\nconsole.log(collection);\n```\n\n----------------------------------------\n\nTITLE: Uploading Files with UploaderInterface in TypeScript\nDESCRIPTION: Shows how to use the UploaderInterface to upload single or multiple files. It also demonstrates configuring the upload process with options like abort signals and progress tracking.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst [myUri, myOtherUri] = await umi.uploader.upload([myFile, myOtherFile]);\n\nconst myUris = await umi.uploader.upload(myFiles, {\n  signal: myAbortSignal,\n  onProgress: (percent) => {\n    console.log(`${percent * 100}% uploaded...`);\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using web3JsRpc Plugin in TypeScript\nDESCRIPTION: This snippet shows how to use the web3JsRpc plugin to set the RPC implementation to use the '@solana/web3.js' library. It adds an alternative method for configuring the RPC endpoint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { web3JsRpc } from '@metaplex-foundation/umi-rpc-web3js';\nimport { Connection } from '@solana/web3.js';\n\numi.use(web3JsRpc(\"https://api.mainnet-beta.solana.com\"));\numi.use(web3JsRpc(new Connection(\"https://api.mainnet-beta.solana.com\")));\n```\n\n----------------------------------------\n\nTITLE: Creating an MPL Core Collection with Royalties Plugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Metaplex Core collection with the Royalties plugin attached using TypeScript and the Umi library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport { createCollection, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\n\nconst creator1 = publicKey('11111111111111111111111111111111')\nconst creator2 = publicKey('22222222222222222222222222222222')\n\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n  plugins: [\n    {\n      type: 'Royalties',\n      basisPoints: 500,\n      creators: [\n        {\n          address: creator1,\n          percentage: 20,\n        },\n        {\n          address: creator2,\n          percentage: 80,\n        },\n      ],\n      ruleSet: ruleSet('None'), // Compatibility rule set\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Removing a Plugin from MPL Core Collection in TypeScript\nDESCRIPTION: This snippet illustrates how to remove a plugin from an MPL Core Collection using TypeScript. It uses the @metaplex-foundation/umi and @metaplex-foundation/mpl-core libraries to remove a 'Royalties' plugin from a specified collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/removing-plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  removeCollectionPluginV1,\n  PluginType,\n} from '@metaplex-foundation/mpl-core'\n\nconst collectionAddress = publicKey('11111111111111111111111111111111')\n\nawait removeCollectionPlugin(umi, {\n  collection: collectionAddress,\n  pluginType: { type: 'Royalties' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Collection Plugin with Authority using Rust and MPL Core\nDESCRIPTION: This snippet shows how to add a collection plugin with an assigned authority using the MPL Core library in Rust. It creates a 'FreezeDelegate' type plugin and assigns an authority address to the plugin. The code also demonstrates how to create and send a transaction on the Solana blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::AddCollectionPluginV1Builder,\n    types::{FreezeDelegate, Plugin, PluginAuthority},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_plugin_to_collection_with_authority() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let plugin_authority = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let add_plugin_to_collection_with_authority_ix = AddCollectionPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n        .init_authority(PluginAuthority::Address {\n            address: plugin_authority,\n        })\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_plugin_to_collection_with_authority_tx = Transaction::new_signed_with_payer(\n        &[add_plugin_to_collection_with_authority_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_plugin_to_collection_with_authority_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Plugin Owner Authority in TypeScript\nDESCRIPTION: This function verifies if a given public key has owner authority over a plugin. It returns a boolean value based on whether the plugin's authority is set to an Owner type and matches the provided public key and asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginOwnerAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority,\n  asset: AssetV1\n)\n```\n\n----------------------------------------\n\nTITLE: Withdrawing a Core Candy Machine using JavaScript\nDESCRIPTION: This code demonstrates how to delete a Core Candy Machine and reclaim its rent using the @metaplex-foundation/mpl-core-candy-machine library. The function receives a Candy Machine ID and returns the on-chain storage rent while deleting the associated data, making the Candy Machine unusable afterward.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/withdrawing-a-candy-machine.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { deleteCandyMachine } from '@metaplex-foundation/mpl-core-candy-machine'\nimport { publicKey } from '@metaplex-foundation/umi'\n\nconst candyMachineId = '11111111111111111111111111111111'\n\nawait deleteCandyMachine(umi, {\n  candyMachine: publicKey(candyMachineId),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Registering Plugins with Umi Instance\nDESCRIPTION: This code snippet demonstrates how to create an Umi instance and register plugins using the `use` method.  It imports necessary modules and registers plugins for wallet adapter identity, AWS uploader, and a custom program repository, showcasing the extensibility of the Umi framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/interfaces.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters';\nimport { awsUploader } from '@metaplex-foundation/umi-uploader-aws';\nimport { myProgramRepository } from '../plugins';\n\nconst umi = createUmi('https://api.mainnet-beta.solana.com')\n  .use(walletAdapterIdentity(...))\n  .use(awsUploader(...))\n  .use(myProgramRepository());\n```\n\n----------------------------------------\n\nTITLE: Locking NFT Asset with Token Metadata\nDESCRIPTION: Demonstrates how to lock a standard NFT asset using the Token Metadata program's lockV1 instruction. Requires mint address, authority, and token standard as parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/lock.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait lockV1(umi, {\n  mint,\n  authority,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Using Mock Storage for Testing in TypeScript\nDESCRIPTION: Demonstrates how to use the mock storage helper for testing purposes. It shows how to register the mock storage plugin and use it for uploading and downloading files in memory.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mockStorage } from '@metaplex-foundation/umi-storage-mock';\n\numi.use(mockStorage());\nconst [myUri] = await umi.uploader.upload([myFile]);\nconst [myDownloadedFile] = await umi.downloader.download([myUri]);\n// myFile and myDownloadedFile are identical.\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Token Gate Guard in JavaScript\nDESCRIPTION: Sets up a Candy Machine with the Token Gate guard, requiring users to hold 300 tokens of the specified mint to be eligible for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    tokenGate: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Core Asset with External Plugin in Rust\nDESCRIPTION: Demonstrates creating a Core Asset with an Oracle plugin using Rust. Includes setup of RPC client, keypair generation, and transaction building with necessary plugin configurations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\\n    instructions::CreateV2Builder,\\n    types::{\\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent, OracleInitInfo,\\n        ValidationResultsOffset,\\n    },\\n};\\nuse solana_client::nonblocking::rpc_client;\\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\\nuse std::str::FromStr;\\n\\npub async fn create_asset_with_oracle_plugin() {\\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\\n\\n    let payer = Keypair::new();\\n    let asset = Keypair::new();\\n\\n    let onchain_oracle_account = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\\n\\n    let create_asset_with_oracle_plugin_ix = CreateV2Builder::new()\\n        .asset(asset.pubkey())\\n        .payer(payer.pubkey())\\n        .name(\"My Nft\".into())\\n        .uri(\"https://example.com/my-nft.json\".into())\\n        .external_plugins_adapters(vec![ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\\n            base_address: onchain_oracle_account,\\n            init_plugin_authority: None,\\n            lifecycle_checks: vec![(\\n                HookableLifecycleEvent::Transfer,\\n                ExternalCheckResult { flags: 4 },\\n            )],\\n            base_address_config: None,\\n            results_offset: Some(ValidationResultsOffset::Anchor),\\n        })])\\n        .instruction();\\n\\n    let signers = vec![&asset, &payer];\\n\\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\\n\\n    let create_asset_with_burn_transfer_delegate_plugin_tx = Transaction::new_signed_with_payer(\\n        &[create_asset_with_burn_transfer_delegate_plugin_ix],\\n        Some(&payer.pubkey()),\\n        &signers,\\n        last_blockhash,\\n    );\\n\\n    let res = rpc_client\\n        .send_and_confirm_transaction(&create_asset_with_burn_transfer_delegate_plugin_tx)\\n        .await\\n        .unwrap();\\n\\n    println!(\"Signature: {:?}\", res)\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Permanent Transfer Plugin in TypeScript\nDESCRIPTION: This code demonstrates how to create an MPL Core Asset with a Permanent Transfer Plugin using TypeScript. It imports necessary modules, generates a signer for the asset, defines a delegate public key, and calls the create function with the required parameters including the plugin configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-transfer-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi)\nconst delegate = publicKey('33333333333333333333333333333')\n\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'PermanentTransferDelegate',\n      authority: { type: 'Address', address: delegate },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Config Line Settings in JavaScript using Umi\nDESCRIPTION: This snippet demonstrates how to configure Config Line Settings for a Candy Machine using the Umi library. It shows how to set name and URI prefixes, lengths, and the sequential minting option.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none } from '@metaplex-foundation/umi'\n\nconst candyMachineSettings = {\n  hiddenSettings: none(),\n  configLineSettings: some({\n    prefixName: 'My NFT Project #$ID+1$',\n    nameLength: 0,\n    prefixUri: 'https://arweave.net/',\n    uriLength: 43,\n    isSequential: false,\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Converting GenericFile Objects in TypeScript\nDESCRIPTION: Demonstrates various methods to create GenericFile objects and convert them to and from browser files and JSON objects. These helper functions facilitate working with files across different environments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a generic file directly.\ncreateGenericFile('some content', 'my-file.txt', { contentType: \"text/plain\" });\n\n// Parse a generic file to and from a browser file.\nawait createGenericFileFromBrowserFile(myBrowserFile);\ncreateBrowserFileFromGenericFile(myGenericFile);\n\n// Parse a generic file to and from a JSON object.\ncreateGenericFileFromJson(myJson);\nparseJsonFromGenericFile(myGenericFile);\n```\n\n----------------------------------------\n\nTITLE: Fetching MPL Core Assets by Owner using DAS API in JavaScript\nDESCRIPTION: This code snippet demonstrates how to retrieve MPL Core assets owned by a specific wallet address using the DAS API. It uses the UMI library and requires replacing placeholder values for the RPC endpoint and owner public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-owner.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst owner = publicKey('<PublicKey>');\n\nconst assets = await das.getAssetsByCollection(umi, { owner });\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Transfer Collection Asset using JavaScript/TypeScript\nDESCRIPTION: Shows how to transfer a Core NFT Asset that belongs to a collection, requiring the additional collection address parameter in JavaScript/TypeScript.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/transfer.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { transferV1 } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait transferV1(umi, {\n  asset: asset.publicKey,\n  newOwner: newOwner.publicKey,\n  collection: colleciton.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Core Candy Machine with Parallel Groups in TypeScript\nDESCRIPTION: This code snippet shows how to create a Core Candy Machine with parallel groups using the Umi library. It sets up default guards for bot tax and start date, and defines two groups with different Sol Payment guards and an NFT Gate for one group.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-groups.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n    startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n  },\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ amount: sol(1), destination: treasury }),\n        nftGate: some({\n          requiredCollection: innocentBirdCollectionNft.publicKey,\n        }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ amount: sol(2), destination: treasury }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring Tokens in Solana using Umi\nDESCRIPTION: This snippet demonstrates how to transfer tokens from one Token account to another using Umi. It requires the source and destination token accounts, the authority (owner or delegate), and the amount to transfer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferTokens } from '@metaplex-foundation/mpl-toolbox'\n\nawait transferTokens(umi, {\n  source: sourceTokenAccount,\n  destination: destinationTokenAccount,\n  authority: ownerOrDelegate,\n  amount: 30,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching a Compressed NFT Asset by ID in TypeScript\nDESCRIPTION: This snippet shows how to retrieve a Compressed NFT after minting by parsing the leaf from the mint transaction, finding the asset ID PDA, and fetching the asset data using RPC with Digital Asset Standard (DAS). It includes logging the asset information for verification.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n//\n// ** Fetching Asset **\n//\n\n//\n// Here we find the asset ID of the compressed NFT using the leaf index of the mint transaction\n// and then log the asset information.\n//\n\nconsole.log('Finding Asset ID...')\nconst leaf = await parseLeafFromMintV1Transaction(umi, signature)\nconst assetId = findLeafAssetIdPda(umi, {\n  merkleTree: merkleTree.publicKey,\n  leafIndex: leaf.nonce,\n})\n\nconsole.log('Compressed NFT Asset ID:', assetId.toString())\n\n// Fetch the asset using umi rpc with DAS.\nconst asset = await umi.rpc.getAsset(assetId[0])\n\nconsole.log({ asset })\n```\n\n----------------------------------------\n\nTITLE: Transferring SOL Using Umi in TypeScript\nDESCRIPTION: This snippet demonstrates how to transfer a specific amount of SOL from one account to another using Umi. The amount is specified in lamports (1/1,000,000 of SOL).\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/transfer-sol.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sol, publicKey } from '@metaplex-foundation/umi'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox'\n\nconst destination = publicKey(`11111111111111111111111`)\n\nawait transferSol(umi, {\n  source: umi.identity,\n  destination,\n  amount: sol(1.3),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Gate Guard in TypeScript\nDESCRIPTION: This snippet shows how to use the Asset Gate guard when minting from a Candy Machine. It includes the required collection and destination in the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    assetGate: some({\n      requiredCollection: publicKey(requiredCollection),\n      destination,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Complete Unstaking Instruction for NFTs in Metaplex\nDESCRIPTION: A full implementation of the unstaking instruction that checks if an asset is staked, updates the staking attributes, thaws the asset, and removes the FreezeDelegate plugin. This provides a complete workflow for unstaking NFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n    // Pass the Asset and Collection\n    const asset = publicKey(\"6AWm5uyhmHQXygeJV7iVotjvs2gVZbDXaGUQ8YGVtnJo\");\n    const collection = publicKey(\"CYKbtF2Y56QwQLYHUmpAPeiMJTz1DbBZGvXGgbB6VdNQ\")\n\n    let tx: Transaction;\n\n    // Fetch the Asset Attributes\n    const fetchedAsset = await fetchAsset(umi, asset);\n    console.log(\"This is the current state of your Asset Attribute Plugin\", fetchedAsset.attributes);\n\n    // If there is no attribute plugin attached to the asset, throw an error\n    if (!fetchedAsset.attributes) {\n      throw new Error(\n        \"Asset has no Attribute Plugin attached to it. Please go through the stake instruction before.\"\n      );\n    }\n    \n    const assetAttribute = fetchedAsset.attributes.attributeList;\n    // Check if the asset has a stakedTime attribute attached to it, if not throw an error\n    const stakedTimeAttribute = assetAttribute.find((attr) => attr.key === \"stakedTime\");\n    if (!stakedTimeAttribute) {\n      throw new Error(\n        \"Asset has no stakedTime attribute attached to it. Please go through the stake instruction before.\"\n      );\n    }\n\n    // Check if the asset has a staked attribute attached to it, if not throw an error\n    const stakedAttribute = assetAttribute.find((attr) => attr.key === \"staked\");\n    if (!stakedAttribute) {\n      throw new Error(\n        \"Asset has no staked attribute attached to it. Please go through the stake instruction before.\"\n      );\n    }\n\n    // Check if the asset is already staked (!0), if not throw an error.\n    if (stakedAttribute.value === \"0\") {\n      throw new Error(\"Asset is not staked\");\n    } else {\n      const stakedTimeValue = parseInt(stakedTimeAttribute.value);\n      const stakedValue = parseInt(stakedAttribute.value);\n      const elapsedTime = new Date().getTime() - stakedValue;\n\n      // Update the stakedTime attribute to the new value and the staked attribute to 0\n      assetAttribute.forEach((attr) => {\n        if (attr.key === \"stakedTime\") {\n          attr.value = (stakedTimeValue + elapsedTime).toString();\n        }\n        if (attr.key === \"staked\") {\n          attr.value = \"0\";\n        }\n      });\n    }\n\n    // Update the Asset Attribute Plugin with the new attributeList\n    // then Update the Asset FreezeDelegate Plugin to thaw the asset\n    // and then Remove the FreezeDelegate Plugin from the asset\n    tx = await transactionBuilder().add(updatePlugin(umi, {\n      asset,\n      collection,\n      plugin: {\n        type: \"Attributes\",\n        attributeList: assetAttribute,\n      },\n    })).add(updatePlugin(umi, {\n      asset,\n      collection,\n      plugin: {\n        type: \"FreezeDelegate\",\n        frozen: false,\n      },\n    })).add(removePlugin(umi, {\n      asset,\n      collection,\n      plugin: {\n        type: \"FreezeDelegate\",\n      },\n    })).buildAndSign(umi);\n\n     // Deserialize the Signature from the Transaction\n     console.log(`Asset Unstaked: https://solana.fm/tx/${base58.deserialize(await umi.rpc.sendTransaction(tx))[0]}?cluster=devnet-alpha`);\n})();\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata with Token-2022 in TypeScript\nDESCRIPTION: Creates metadata for a Token-2022 mint account using the Umi framework. Demonstrates how to specify SPL Token-2022 as the token program when creating metadata for an NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-2022.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  generateSigner,\n  percentAmount,\n  publicKey,\n  PublicKey,\n} from '@metaplex-foundation/umi'\nimport {\n  createV1,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst SPL_TOKEN_2022_PROGRAM_ID: PublicKey = publicKey(\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'\n)\n\nconst mint = generateSigner(umi)\nawait createV1(umi, {\n  mint,\n  authority,\n  name: 'My NFT',\n  uri,\n  sellerFeeBasisPoints: percentAmount(5.5),\n  splTokenProgram: SPL_TOKEN_2022_PROGRAM_ID,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Burning pNFT using Anchor with mpl-token-metadata\nDESCRIPTION: This snippet demonstrates how to burn a programmable NFT (pNFT) using the Anchor framework with mpl-token-metadata in Rust. It defines the necessary account structure and implements the burn instruction using BurnV1CpiBuilder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnV1CpiBuilder;\n\n#[derive(Accounts)]\npub struct PnftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    master_edition: AccountInfo<'info>,\n    #[account(mut)]\n    token_record: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}\n\npub fn burn_pnft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, PnftBurnMpl<'info>>,\n) -> Result<()> {\nlet owner = ctx.accounts.owner.to_account_info();\nlet metadata = ctx.accounts.metadata.to_account_info();\nlet mint = ctx.accounts.mint.to_account_info();\nlet token = ctx.accounts.token.to_account_info();\nlet master_edition = ctx.accounts.master_edition.to_account_info();\nlet collection_metadata = ctx\n    .accounts\n    .collection_metadata\n    .as_ref()\n    .map(|a| a.to_account_info());\nlet spl_token = ctx.accounts.spl_token.to_account_info();\nlet token_record = ctx.accounts.token_record.to_account_info();\nlet metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\nBurnV1CpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    .collection_metadata(collection_metadata.as_ref())\n    .authority(&owner)\n    .mint(&mint)\n    .token(&token)\n    .spl_token_program(&spl_token)\n    .token_record(Some(&token_record))\n    .master_edition(Some(&master_edition)) \n    .invoke()?\n\nOk(())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Royalties Plugin to MPL Core Collection in JavaScript\nDESCRIPTION: This snippet shows how to add the Royalties Plugin to an MPL Core Collection using JavaScript. It sets the royalty percentage, defines creators, and applies a program deny list.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addCollectionPlugin, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst creator1 = publicKey('11111111111111111111111111111111')\nconst creator2 = publicKey('2222222222222222222222222222222')\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'Royalties',\n    basisPoints: 500,\n    creators: [\n      { address: creator1, percentage: 80 },\n      { address: creator2, percentage: 20 },\n    ],\n    ruleSet: ruleSet('ProgramDenyList', [\n      [\n        publicKey('44444444444444444444444444444444'),\n        publicKey('55555555555555555555555555555555'),\n      ],\n    ]),\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Object Serializer in TypeScript\nDESCRIPTION: This example shows how to create a serializer for a custom object type using Umi's built-in serializers. It demonstrates composing serializers for different data types including strings, PublicKeys, and arrays of numbers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PublicKey } from '@metaplex-foundation/umi';\nimport { Serializer, struct, string, publicKey, array, u32 } from '@metaplex-foundation/umi/serializers';\n\ntype MyObject = {\n  name: string;\n  publicKey: PublicKey;\n  numbers: number[];\n};\n\nconst mySerializer: Serializer<MyObject> = struct([\n  ['name', string()],\n  ['publicKey', publicKey()],\n  ['numbers', array(u32())],\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating Core Asset with External Plugin in TypeScript\nDESCRIPTION: Creates a new Core Asset with an Oracle plugin using the Umi framework. The example shows how to initialize an asset with a specific name, URI, and Oracle plugin configuration including lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { create, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = publicKey('11111111111111111111111111111111')\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'Oracle',\n      resultsOffset: {\n        type: 'Anchor',\n      },\n      lifecycleChecks: {\n        update: [CheckResult.CAN_REJECT],\n      },\n      baseAddress: oracleAccount,\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Updating Token Standard of Existing Candy Machine in TypeScript\nDESCRIPTION: Shows how to update the token standard of an existing Candy Machine to Programmable NFTs using the setTokenStandard function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/pnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\nimport { setTokenStandard } from '@metaplex-foundation/mpl-candy-machine'\n\nawait setTokenStandard(umi, {\n  candyMachine: candyMachine.publicKey,\n  collectionMint: candyMachine.collectionMint,\n  collectionUpdateAuthority,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Delegating a Compressed NFT using Bubblegum in TypeScript\nDESCRIPTION: This code snippet demonstrates how to delegate a compressed NFT to a new delegate authority using the Metaplex Bubblegum library. It fetches the asset with proof and sends a delegate instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/delegate-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, delegate } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait delegate(umi, {\n  ...assetWithProof,\n  leafOwner,\n  previousLeafDelegate: leafOwner.publicKey,\n  newLeafDelegate: newDelegate,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with Permanent Burn Delegate Plugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an MPL Core Asset with a Permanent Burn Delegate plugin using TypeScript. It imports necessary functions, generates a signer, sets up a delegate public key, and calls the create function with the appropriate parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-burn-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi)\nconst delegate = publicKey('33333333333333333333333333333')\n\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'PermanentBurnDelegate',\n      authority: { type: 'Address', address: delegate },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection for Compressed NFT using TypeScript\nDESCRIPTION: Shows how to verify a collection for a Compressed NFT using the verifyCollection function from mpl-bubblegum. Requires the collection to be pre-set on the cNFT and uses the Metaplex DAS API to fetch asset proof.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/verify-collections.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  verifyCollection,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait verifyCollection(umi, {\n  ...assetWithProof,\n  collectionMint,\n  collectionAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi RPC URL in zustand store\nDESCRIPTION: This code snippet shows how to configure the RPC URL directly in the `umiStore` using Zustand. This configures the Umi instance with a specific RPC endpoint and a no-op signer for default operations, enabling interaction with the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/mpl-404-hybrid-ui-template.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst useUmiStore = create<UmiState>()((set) => ({\n  // add your own RPC here\n  umi: createUmi('http://api.devnet.solana.com').use(\n    signerIdentity(\n      createNoopSigner(publicKey('11111111111111111111111111111111'))\n    )\n  ),\n  ...\n}))\n```\n\n----------------------------------------\n\nTITLE: Appending Items to Core Candy Machine in JavaScript\nDESCRIPTION: Shows how to append items to the end of currently loaded items in a Core Candy Machine by using the candyMachine.itemsLoaded property as the insertion index.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/insert-items.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: candyMachine.itemsLoaded,\n  configLines: [\n    { name: 'My NFT #3', uri: 'https://example.com/nft3.json' },\n    { name: 'My NFT #4', uri: 'https://example.com/nft4.json' },\n    { name: 'My NFT #5', uri: 'https://example.com/nft5.json' },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Burn Guard in TypeScript\nDESCRIPTION: This code shows how to mint using the NFT Burn guard. It specifies the required collection, the NFT to burn, and its token standard as part of the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-burn.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from \"@metaplex-foundation/mpl-token-metadata\";\n\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    nftBurn: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n      mint: nftToBurn.publicKey,\n      tokenStandard: TokenStandard.NonFungible,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Example of using CreateV1Builder in Rust\nDESCRIPTION: This snippet demonstrates how to use the `CreateV1Builder` to construct a `CreateV1` instruction. It sets the asset, collection, payer, name, and URI for the new asset.  The `.instruction()` method finalizes the builder and returns the Solana instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nlet create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n.       .instruction();\n```\n\n----------------------------------------\n\nTITLE: Implementing Program Owned List Rule in Token Auth Rules\nDESCRIPTION: Shows how to create a rule set that checks if an account is owned by any program from a list of allowed programs. Allows multiple program owners to be specified.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/program-owned.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    list: {\n      type: 'ProgramOwnedList',\n      field: 'Escrow',\n      programs: [\n        publicKey('TSWAPaqyCSx2KABk68Shruf4rp7CxcNi8hAsbdwmHbN'),\n        publicKey('M2mx93ekt1fmXSVkTrUL9xVFHkmME8HTUi5Cyc5aF7K'),\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Core Collection Imports and Wrapper\nDESCRIPTION: Initial setup with necessary imports and wrapper function for creating collections.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  createCollection, \n  mplCore \n} from '@metaplex-foundation/mpl-core'\nimport {\n  createGenericFile,\n  generateSigner,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\n// Create the wrapper function\nconst createCollection = async () => {\n  ///\n  ///\n  ///  all our code will go in here\n  ///\n  ///\n}\n\n// run the wrapper function\ncreateCollection()\n```\n\n----------------------------------------\n\nTITLE: Creating Configurable Umi Plugins in TypeScript\nDESCRIPTION: Shows how to export a plugin function to handle configuration options, allowing the end user to provide arguments upon plugin initialization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const myPlugin = (myPluginOptions?: MyPluginOptions): UmiPlugin => ({\n  install(umi: Umi) {\n    // Do something with the Umi instance.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Irys Uploader Plugin for Umi\nDESCRIPTION: Shows how to install and configure the Irys uploader plugin for interacting with the Arweave network through the Umi SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\n\numi.use(irysUploader())\n```\n\n----------------------------------------\n\nTITLE: Validating Asset Update in TypeScript\nDESCRIPTION: This function verifies if a given authority is eligible to update an asset. It returns a boolean value based on the provided umi, authority, asset, and collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function validateUpdate(\n  umi,\n  { authority, asset, collection }\n)\n```\n\n----------------------------------------\n\nTITLE: Performing a Delegated Update as a Programmable Config Delegate in TypeScript\nDESCRIPTION: Uses a Programmable Config Delegate to update the ruleSet of a PNFT. Requires the mint, token account, delegate authority as a signer, and the new ruleSet configuration using the ruleSetToggle helper.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsAuthorityItemDelegateV2,\n  ruleSetToggle,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { findAssociatedTokenPda } from '@metaplex-foundation/mpl-toolbox'\n\nawait updateAsProgrammableConfigDelegateV2(umi, {\n  mint,\n  token: findAssociatedTokenPda(umi, { mint, owner: assetOwner }),\n  authority: programmableConfigDelegate,\n  ruleSet: ruleSetToggle('Set', [ruleSet]),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Freeze Token Payment guard in JavaScript\nDESCRIPTION: Example of creating a Candy Machine with the Freeze Token Payment guard using JavaScript/TypeScript and Umi. The example configures the guard to charge 300 tokens of a specific mint with the destination set to the Umi identity's associated token account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    freezeTokenPayment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta: findAssociatedTokenPda(umi, {\n        mint: tokenMint.publicKey,\n        owner: umi.identity.publicKey,\n      }),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Unverified Creator to MPL Core Asset\nDESCRIPTION: This code example shows how to add an unverified creator to an MPL Core Asset. It assumes that the umi identity is the update authority of the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\nconst publicKeyToAdd = publicKey(\"abc...\")\n\n// The new autograph that you want to add\nconst newCreator = {\n  address: publicKeyToAdd,\n  verified: false,\n}\n\n// Add the new autograph to the existing signatures array\nconst updatedCreators = [...asset.verifiedCreators.signatures, newCreator]\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n    signatures: updatedCreators,\n  },\n  authority: umi.identity,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Bubblegum Tree with Custom Parameters\nDESCRIPTION: This snippet shows how to create a Bubblegum Tree with a custom tree creator and public access setting. By default, the tree creator is set to the Umi identity and public is set to false, but these can be customized as shown.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/create-trees.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst customTreeCreator = generateSigner(umi)\nconst builder = await createTree(umi, {\n  // ...\n  treeCreator: customTreeCreator,\n  public: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Bot Tax Guard with JavaScript/TypeScript\nDESCRIPTION: Example of creating a Candy Machine with the Bot Tax guard enabled. The guard is configured with a penalty of 0.01 SOL and requires the mint instruction to be the last in the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/bot-tax.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    botTax: some({\n      lamports: sol(0.01),\n      lastInstruction: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Approving Authority Item Delegate in JavaScript\nDESCRIPTION: This TypeScript function approves an authority item delegate with the specified parameters such as mint, authority, and delegate using the Metaplex Foundation's Token Metadata package. The operation requires the `@metaplex-foundation/mpl-token-metadata` library, and it sends the transaction for confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { delegateAuthorityItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateAuthorityItemV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: authorityItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Locking (Freezing) Non-Fungible Token in TypeScript\nDESCRIPTION: This snippet shows how to lock (freeze) a non-fungible token using a Standard Delegate with the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait lockV1(umi, {\n  mint,\n  authority: standardDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Accessing Candy Machine Account Data in TypeScript\nDESCRIPTION: Demonstrates how to access and inspect various attributes of a Candy Machine account including items redeemed, availability, and item details using the Umi library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchCandyMachine,\n  fetchCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachine = await fetchCandyMachine(umi, candyMachineAddress)\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\n\ncandyMachine.publicKey // The public key of the Candy Machine account.\ncandyMachine.mintAuthority // The mint authority of the Candy Machine which, in most cases, is the Candy Guard address.\ncandyMachine.data.itemsAvailable // Total number of NFTs available.\ncandyMachine.itemsRedeemed // Number of NFTs minted.\ncandyMachine.items[0].index // The index of the first loaded item.\ncandyMachine.items[0].name // The name of the first loaded item (with prefix).\ncandyMachine.items[0].uri // The URI of the first loaded item (with prefix).\ncandyMachine.items[0].minted // Whether the first item has been minted.\n```\n\n----------------------------------------\n\nTITLE: Transferring SPL Tokens From Asset Signer in JavaScript\nDESCRIPTION: This example shows how to transfer SPL tokens from an Asset Signer PDA to a destination address using the execute instruction and transferTokens function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/execute-asset-signing.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  execute,\n  findAssetSignerPda,\n  fetchAsset,\n  fetchCollection,\n} from '@metaplex-foundation/mpl-core'\nimport {\n  transferTokens,\n  findAssociatedTokenPda,\n} from '@metaplex-foundation/mpl-toolbox'\nimport { publickey } from '@metaplex-foundation/umi'\n\nconst assetId = publickey('11111111111111111111111111111111')\n\nconst asset = await fetchAsset(umi, assetId)\n\n// Optional - If Asset is part of collection fetch the collection object\nconst collection =\n  asset.updateAuthority.type == 'Collection' && asset.updateAuthority.address\n    ? await fetchCollection(umi, asset.updateAuthority.address)\n    : undefined\n\nconst splTokenMint = publickey('2222222222222222222222222222222222')\n\n// Asset signer has a balance of tokens.\nconst assetSignerPda = findAssetSignerPda(umi, { asset: assetId })\n\n// Destination wallet we wish to transfer the SOL to.\nconst destinationWallet = publickey('3333333333333333333333333333333')\n\n// A standard `transferTokens()` transactionBuilder.\nconst transferTokensIx = transferTokens(umi, {\n  // Source is the `assetSignerPda` derived Token Account\n  source: findAssociatedTokenPda(umi, {\n    mint: splTokenMint,\n    owner: assetSignerPda,\n  }),\n  // Destination is the `destinationWallet` derived Token Account\n  destination: findAssociatedTokenPda(umi, {\n    mint: splTokenMint,\n    owner: destinationWallet,\n  }),\n  // Amount to send in lamports.\n  amount: 5000,\n})\n\n// Call the `execute` instruction and send to the chain.\nconst res = await execute(umi, {\n  // Execute instruction(s) with this asset\n  asset,\n  // If Asset is part of collection pass in collection object via `fetchCollection()`\n  collection,\n  // The transactionBuilder/instruction[] to execute\n  instructions: transferTokensIx,\n}).sendAndConfirm(umi)\n\nconsole.log({ res })\n```\n\n----------------------------------------\n\nTITLE: Managing Transfer Delegates for Programmable NFTs in TypeScript\nDESCRIPTION: Shows how to approve a transfer delegate, revoke it, and perform a delegated transfer. Unlike sale delegates, when a transfer delegate is set, the owner can still transfer and burn the PNFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateTransferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateTransferV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: transferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeTransferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeTransferV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: transferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait transferV1(umi, {\n  mint,\n  authority: transferDelegate,\n  tokenOwner: currentOwner,\n  destinationOwner: newOwner,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Capturing NFTs with Token Swap in MPL-Hybrid\nDESCRIPTION: Demonstrates how to execute a token-to-NFT swap (capture) operation using the MPL-Hybrid program. The function requires various parameters including owner identity, escrow configuration, asset details, collection information, and token account addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/swapping-tokens-to-nfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait captureV1(umi, {\n  // The owner of the asset being swapped.\n  owner: umi.identity,\n  // The escrow configuration address.\n  escrow: publicKey('11111111111111111111111111111111'),\n  // The Asset that will be swapped for SPL Tokens.\n  asset: publicKey('22222222222222222222222222222222'),\n  // The collection assigned to the escrow configuration.\n  collection: publicKey('33333333333333333333333333333333'),\n  // The fee wallet address.\n  feeProjectAccount: publicKey('44444444444444444444444444444444'),\n  // The Token Account of the Wallet.\n  token: publicKey('55555555555555555555555555555555'),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Using Redeemed Amount Guard with Groups in Core Candy Machine\nDESCRIPTION: This example shows how to set up a Core Candy Machine with two guard groups using the Redeemed Amount guard. The first 300 assets can be minted for 1 SOL, while the last 200 require 2 SOL to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  itemsAvailable: 500,\n  groups: [\n    {\n      label: \"early\",\n      guards: {\n        redeemedAmount: some({ maximum: 300 }),\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n      },\n    },\n    {\n      label: \"late\",\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n      },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Update Delegate Plugin to MPL Core Asset in TypeScript\nDESCRIPTION: This snippet demonstrates how to add an Update Delegate Plugin to an MPL Core Asset using TypeScript. It imports necessary functions, defines asset and delegate addresses, and calls the addPlugin function with appropriate parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/update-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\nconst delegate = publicKey('22222222222222222222222222222222')\n\nawait addPlugin(umi, {\n  asset: assetAddress,\n  plugin: {\n    type: 'UpdateDelegate',\n    authority: { type: 'Address', address: delegate },\n    additionalDelegates: [],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Address Gate Guard in JavaScript\nDESCRIPTION: This code demonstrates how to create a Candy Machine with the Address Gate guard in JavaScript/TypeScript. The guard is configured with a specific wallet address that will be the only one allowed to mint from the Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/address-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    addressGate: some({ address: someWallet.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Config Lines to Core Candy Machine in JavaScript\nDESCRIPTION: Demonstrates how to use the addConfigLines function to insert NFT items into a Core Candy Machine. The function requires specifying the config lines to add and the index at which to insert them.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/insert-items.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 0,\n  configLines: [\n    { name: 'My NFT #1', uri: 'https://example.com/nft1.json' },\n    { name: 'My NFT #2', uri: 'https://example.com/nft2.json' },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Asset Burn Multi Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the Asset Burn Multi guard. It sets the required collection and the number of assets to burn.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-burn-multi.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetBurnMulti: some({\n      requiredCollection: requiredCollection.publicKey,\n      num: 2,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with Permanent Burn Delegate Plugin in Rust\nDESCRIPTION: This snippet shows how to create an MPL Core Asset with a Permanent Burn Delegate plugin using Rust. It sets up the RPC client, creates necessary keypairs, builds the instruction, constructs and signs the transaction, and sends it to the network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-burn-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::CreateV1Builder,\n    types::{PermanentBurnDelegate, Plugin, PluginAuthority, PluginAuthorityPair},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_permanent_burn_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let create_asset_with_permanent_burn_delegate_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::PermanentBurnDelegate(PermanentBurnDelegate {}),\n            authority: Some(PluginAuthority::None),\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_permanent_burn_delegate_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_permanent_burn_delegate_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_permanent_burn_delegate_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting DAS Collections to Core Collections in JavaScript\nDESCRIPTION: This code shows the process of fetching DAS Collections, filtering for only Core Collections, and converting them to Core Collection types. Similar to the Asset conversion, it uses the dasAssetsToCoreAssets method but filters for the 'MplCoreCollection' interface.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/convert-das-asset-to-core.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// ... standard setup for @metaplex-foundation/digital-asset-standard-api\n\nconst dasAssets = await umi.rpc.getAssetsByOwner({ owner: publicKey('<pubkey>') });\n\n// filter out only core assets\nconst dasCoreAssets = assets.items.filter((a) => a.interface === 'MplCoreCollection')\n\n// convert them to AssetV1 type (actually AssetResult type which will also have the content field populated from DAS)\nconst coreAssets = await das.dasAssetsToCoreAssets(umi, dasCoreAssets)\n```\n\n----------------------------------------\n\nTITLE: Implementing Create Ticket Function in Rust using Metaplex Core\nDESCRIPTION: This function implements the Create Ticket instruction. It creates a ticket asset using Metaplex Core V2, adding attributes for ticket details, setting up necessary plugins including permanent freeze, burn, and transfer delegates, and incorporating an external AppData plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_ticket(ctx: Context<CreateTicket>, args: CreateTicketArgs) -> Result<()> {\n    // Check that the maximum number of tickets has not been reached yet\n    let (_, collection_attribute_list, _) = fetch_plugin::<BaseCollectionV1, Attributes>(\n            &ctx.accounts.event.to_account_info(), \n            PluginType::Attributes\n        )?\n\n    // Search for the Capacity attribute\n    let capacity_attribute = collection_attribute_list\n        .attribute_list\n        .iter()\n        .find(|attr| attr.key == \"Capacity\")\n        .ok_or(TicketError::MissingAttribute)?\n\n    // Unwrap the Capacity attribute value\n    let capacity = capacity_attribute\n        .value\n        .parse::<u32>()\n        .map_err(|_| TicketError::NumericalOverflow)?\n\n    require!(\n        ctx.accounts.event.num_minted < capacity, \n        TicketError::MaximumTicketsReached\n    )\n\n    // Add an Attribute Plugin that will hold the ticket details\n    let mut ticket_plugin: Vec<PluginAuthorityPair> = vec![]\n    \n    let attribute_list: Vec<Attribute> = vec![\n    Attribute { \n        key: \"Ticket Number\".to_string(), \n        value: ctx.accounts.event.num_minted.checked_add(1).ok_or(TicketError::NumericalOverflow)?.to_string()\n    },\n    Attribute { \n        key: \"Hall\".to_string(), \n        value: args.hall \n    },\n    Attribute { \n        key: \"Section\".to_string(), \n        value: args.section \n    },\n    Attribute { \n        key: \"Row\".to_string(), \n        value: args.row \n    },\n    Attribute { \n        key: \"Seat\".to_string(), \n        value: args.seat \n    },\n    Attribute { \n        key: \"Price\".to_string(), \n        value: args.price.to_string() \n    }\n    ]\n    \n    ticket_plugin.push(\n        PluginAuthorityPair { \n            plugin: Plugin::Attributes(Attributes { attribute_list }), \n            authority: Some(PluginAuthority::UpdateAuthority) \n        }\n    )\n    \n    ticket_plugin.push(\n        PluginAuthorityPair { \n            plugin: Plugin::PermanentFreezeDelegate(PermanentFreezeDelegate { frozen: false }), \n            authority: Some(PluginAuthority::UpdateAuthority) \n        }\n    )\n    \n    ticket_plugin.push(\n        PluginAuthorityPair { \n            plugin: Plugin::PermanentBurnDelegate(PermanentBurnDelegate {}), \n            authority: Some(PluginAuthority::UpdateAuthority) \n        }\n    )\n    \n    ticket_plugin.push(\n        PluginAuthorityPair { \n            plugin: Plugin::PermanentTransferDelegate(PermanentTransferDelegate {}), \n            authority: Some(PluginAuthority::UpdateAuthority) \n        }\n    )\n\n    let mut ticket_external_plugin: Vec<ExternalPluginAdapterInitInfo> = vec![]\n    \n    ticket_external_plugin.push(ExternalPluginAdapterInitInfo::AppData(\n        AppDataInitInfo {\n            init_plugin_authority: Some(PluginAuthority::UpdateAuthority),\n            data_authority: PluginAuthority::Address{ address: args.venue_authority },\n            schema: Some(ExternalPluginAdapterSchema::Binary),\n        }\n    ))\n\n    let signer_seeds = &[b\"manager\".as_ref(), &[ctx.accounts.manager.bump]]\n\n    // Create the Ticket\n    CreateV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n    .asset(&ctx.accounts.ticket.to_account_info())\n    .collection(Some(&ctx.accounts.event.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.manager.to_account_info()))\n    .owner(Some(&ctx.accounts.signer.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .name(args.name)\n    .uri(args.uri)\n    .plugins(ticket_plugin)\n    .external_plugin_adapters(ticket_external_plugin)\n    .invoke_signed(&[signer_seeds])?\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Decompressing a Redeemed NFT using Bubblegum SDK\nDESCRIPTION: Demonstrates how to finalize the decompression process by transforming a redeemed Voucher into a regular NFT using the Metaplex Bubblegum SDK. This creates the Mint, Metadata, and Master Edition accounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/decompress-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  findVoucherPda,\n  decompressV1,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId)\nawait decompressV1(umi, {\n  ...assetWithProof,\n  leafOwner: currentLeafOwner,\n  mint: assetId,\n  voucher: findVoucherPda(umi, assetWithProof),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Making Core Asset Immutable with JavaScript\nDESCRIPTION: This snippet shows how to make a Core Asset fully immutable using the Metaplex JavaScript SDK. It sets the update authority to 'None', which removes the ability to update the asset and removes it from any collections.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/update.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { update, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst assetId = publicKey('11111111111111111111111111111111')\nconst asset = await fetchAsset(umi, asset)\n\nawait update(umi, {\n  asset: asset,\n  newUpdateAuthority: updateAuthority('None'),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Using the Helper Method for Sending and Confirming Transactions\nDESCRIPTION: Simplifies the transaction sending process by using the built-in sendAndConfirm helper method, which handles building, signing, sending, and confirming in one function call.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst confirmResult = await builder.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Transfer Delegate Plugin - TypeScript Implementation\nDESCRIPTION: Demonstrates how to add a Transfer Delegate plugin to an MPL Core Asset using TypeScript. The code shows initialization of the plugin with an asset address and delegate authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/transfer-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\nconst delegate = publicKey('22222222222222222222222222222222')\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'TransferDelegate',\n    authority: { type: 'Address', address: delegate },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Collection with Master Edition Plugin in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create an MPL Core Collection with the Master Edition Plugin using TypeScript. It sets up a collection signer, defines creators, and configures the collection with Master Edition and Royalties plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport {\n  createCollection,\n  ruleSet,\n} from '@metaplex-foundation/core'\n\nconst collectionSigner = generateSigner(umi)\n\nconst creator1 = publicKey('11111111111111111111111111111111')\nconst creator2 = publicKey('22222222222222222222222222222222')\n\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: \"Master Edition\",\n  uri: \"https://example.com/master-edition.json\",\n  plugins: [\n    {\n      type: \"MasterEdition\",\n        maxSupply: 100,\n        //name and uri are not needed if you want them to be similar to the parent collection\n        name: undefined,\n        uri: undefined,\n    },\n    {\n      type: \"Royalties\",\n      basisPoints: 500,\n      creators: [\n        { address: creator1, percentage: 50 }, \n        { address: creator2, percentage: 50 }\n      ],\n      ruleSet: ruleSet(\"None\"),\n    }\n    ]\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Configuring Shankjs IDL Generator\nDESCRIPTION: Configuration setup for Shankjs to generate IDL for custom Candy Guard deployment. Sets program name, ID and directories.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ngenerateIdl({\n  generator: \"anchor\",\n  programName: \"candy_guard\",\n  programId: \"Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g\", // Your custom Candy Guard deployed program key.\n  idlDir,\n  binaryInstallDir,\n  programDir: path.join(programDir, \"candy-guard\", \"program\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Minting from Candy Machine with Programmable NFTs in TypeScript\nDESCRIPTION: Shows how to mint Programmable NFTs from a Candy Machine using the mintV2 function, which requires additional accounts compared to the deprecated mint function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/pnfts.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV2 } from '@metaplex-foundation/mpl-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\nimport { transactionBuilder, generateSigner } from '@metaplex-foundation/umi'\n\nconst nftMint = generateSigner(umi)\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      nftMint,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Plugins in Rust\nDESCRIPTION: Demonstrates how to deserialize specific plugins from Asset and Collection accounts in Rust, avoiding stack overflow by selective deserialization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// Example of using the AccountInfo of Core Asset account to deserialize an Attributes plugin stored on the asset.\nlet attributes_plugin =\n    fetch_plugin::<BaseAssetV1, Attributes>(&account_info, PluginType::Attributes).unwrap();\n\n// // Example of using the AccountInfo of Core Collection account to deserialize an Attributes plugin stored on the asset.\nlet royalties_plugin =\n    fetch_plugin::<BaseCollectionV1, Royalties>(&account_info, PluginType::Royalties).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Parallel Groups in TypeScript\nDESCRIPTION: Shows how to create a Candy Machine with parallel guard groups that enable different pricing based on NFT ownership, along with default start date and bot tax guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-groups.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  guards: {\n    botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n    startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n  },\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ amount: sol(1), destination: treasury }),\n        nftGate: some({\n          requiredCollection: innocentBirdCollectionNft.publicKey,\n        }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ amount: sol(2), destination: treasury }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Mint Limit Guard in JavaScript\nDESCRIPTION: This code snippet shows how to mint with the NFT Mint Limit guard by passing the mint settings using the mintArgs argument.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-mint-limit.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    nftMintLimit: some({ id: 1, mint: nftToVerify.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initialize Freeze Escrow using JavaScript/TypeScript\nDESCRIPTION: Initializes a Freeze Escrow account with a 15-day freeze period using the Umi identity as both the destination and Candy Guard authority. The route instruction uses the 'freezeSolPayment' guard with the 'initialize' path.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'initialize',\n    destination: umi.identity.publicKey,\n    period: 15 * 24 * 60 * 60, // 15 days.\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Core Collection Test Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a test function for creating a Core Collection, including setting up arguments and calling the program method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"Create Collection\", async () => {\n\n  let createCollectionArgs = {\n    name: 'My Collection',\n    uri: 'https://example.com/my-collection.json',\n  };\n\n  const createCollectionTx = await program.methods.createCoreCollection(createCollectionArgs)\n    .accountsPartial({\n      collection: collection.publicKey,\n      payer: wallet.publicKey,\n      updateAuthority: null,\n      systemProgram: SystemProgram.programId,\n      mplCoreProgram: MPL_CORE_PROGRAM_ID\n    })\n    .signers([collection, wallet.payer])\n    .rpc();\n\n  console.log(createCollectionTx);\n});\n```\n\n----------------------------------------\n\nTITLE: Calculating Remaining Available Assets in Candy Machine\nDESCRIPTION: Code to calculate and display the number of assets still available for minting. This subtracts the number of redeemed items from the total available items in the Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst availableString = `${candyMachine.itemsAvailable - candyMachine.itemsRedeemed} available`;\n```\n\n----------------------------------------\n\nTITLE: Checking Asset Update Authority in TypeScript\nDESCRIPTION: This function verifies if a given public key holds update authority over an asset. It returns a boolean value based on the provided public key, asset, and optional collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasAssetUpdateAuthority(\n  pubkey: string | PublicKey,\n  asset: AssetV1,\n  collection?: CollectionV1\n)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Module Augmentation for Umi\nDESCRIPTION: Demonstrates using TypeScript's module augmentation to extend the `Umi` type. This ensures that added properties in plugins like `guards` or custom RPC interfaces are recognized by TypeScript.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\ndeclare module '@metaplex-foundation/umi' {\n  interface Umi {\n    guards: GuardRepository;\n  }\n}\n\nexport const myRpcWithAddedMethods = (): UmiPlugin => ({\n  install(umi) {\n    umi.rpc = new MyRpcWithAddedMethods(umi.rpc);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Core Collection with External Plugin in Rust\nDESCRIPTION: Demonstrates creating a Core Collection with an Oracle plugin using Rust. Includes RPC client setup, keypair generation, and transaction building with plugin configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\\n    instructions::CreateCollectionV2Builder,\\n    types::{\\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent, OracleInitInfo,\\n        ValidationResultsOffset,\\n    },\\n};\\nuse solana_client::nonblocking::rpc_client;\\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\\nuse std::str::FromStr;\\n\\npub async fn create_collection_with_oracle_plugin() {\\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\\n\\n    let payer = Keypair::new();\\n    let collection = Keypair::new();\\n\\n    let onchain_oracle_plugin = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\\n\\n    let create_collection_with_oracle_plugin_ix = CreateCollectionV2Builder::new()\\n        .collection(collection.pubkey())\\n        .payer(payer.pubkey())\\n        .name(\"My Collection\".into())\\n        .uri(\"https://example.com/my-nft.json\".into())\\n        .external_plugins_adapters(vec![ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\\n            base_address: onchain_oracle_plugin,\\n            init_plugin_authority: None,\\n            lifecycle_checks: vec![(\\n                HookableLifecycleEvent::Transfer,\\n                ExternalCheckResult { flags: 4 },\\n            )],\\n            base_address_config: None,\\n            results_offset: Some(ValidationResultsOffset::Anchor),\\n        })])\\n        .instruction();\\n\\n    let signers = vec![&collection, &payer];\\n\\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\\n\\n    let create_collection_with_oracle_plugin_tx = Transaction::new_signed_with_payer(\\n        &[create_collection_with_oracle_plugin_ix],\\n        Some(&payer.pubkey()),\\n        &signers,\\n        last_blockhash,\\n    );\\n\\n    let res = rpc_client\\n        .send_and_confirm_transaction(&create_collection_with_oracle_plugin_tx)\\n        .await\\n        .unwrap();\\n\\n    println!(\"Signature: {:?}\", res)\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oracle Account Structure in Rust (Anchor)\nDESCRIPTION: This code snippet defines the on-chain account structure for an Oracle Account using Anchor. It includes the Validation struct, OracleValidation enum, and ExternalValidationResult enum.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[account]\npub struct Validation {\n    pub validation: OracleValidation,\n}\n\nimpl Validation {\n    pub fn size() -> usize {\n        8 // anchor discriminator\n        + 5 // validation\n    }\n}\n\npub enum OracleValidation {\n    Uninitialized,\n    V1 {\n        create: ExternalValidationResult,\n        transfer: ExternalValidationResult,\n        burn: ExternalValidationResult,\n        update: ExternalValidationResult,\n    },\n}\n\npub enum ExternalValidationResult {\n    Approved,\n    Rejected,\n    Pass,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Verified Creators Plugin to MPL Core Asset\nDESCRIPTION: This snippet demonstrates how to add the Verified Creators Plugin to an MPL Core Asset. It assumes that the umi identity is the update authority of the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n    signatures: [\n      {\n        address: umi.identity.publicKey,\n        verified: true,\n      },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Master Edition Collection with MPL Core\nDESCRIPTION: This code creates a Collection with the Master Edition Plugin, setting the maximum supply for Editions. It also adds the Royalty Plugin for handling creator royalties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst collectionSigner = generateSigner(umi);\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: \"Master Edition\",\n  uri: \"https://example.com/master-edition.json\",\n  plugins: [\n    {\n      type: \"MasterEdition\",\n        maxSupply: 100,\n        //name and uri are not needed if you want them to be similar to the parent collection\n        name: undefined,\n        uri: undefined,\n    },\n    {\n      type: \"Royalties\",\n      basisPoints: 500,\n      creators: [{ address: umi.identity.publicKey, percentage: 100 }],\n      ruleSet: ruleSet(\"None\"),\n    }\n    ]\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Initializing Freeze Escrow Account with TypeScript\nDESCRIPTION: Initializes a Freeze Escrow account with a 15-day freeze period. The account keeps track of minted Frozen Assets and when the first one was minted to determine the Freeze Period duration. This example uses the current identity as both the destination and Candy Guard authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'initialize',\n    destination: umi.identity.publicKey,\n    period: 15 * 24 * 60 * 60, // 15 days.\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Creator using JavaScript and DAS API\nDESCRIPTION: This code demonstrates how to fetch assets belonging to a specific creator using the Digital Asset Standard API in JavaScript. It initializes the Umi framework with DAS API, sets a creator public key, and retrieves assets with filtering for verified assets and a limit of 10 items.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-creator.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst creator = publicKey('D3XrkNZz6wx6cofot7Zohsf2KSsu2ArngNk8VqU9cTY3');\n\nconst assets = await umi.rpc.getAssetsByCreator({\n    creator,\n    onlyVerified: true,\n    limit: 10,\n});\nconsole.log(assets.items.length > 0);\n```\n\n----------------------------------------\n\nTITLE: Account Helper Methods\nDESCRIPTION: Illustrates helper methods for fetching and deserializing accounts in Kinobi-generated clients. It includes functions for metadata operations such as deserialization, fetching accounts by public key, and building program accounts. This provides a high-level API for managing account data in Solana programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Deserialize a raw account into a parsed account.\ndeserializeMetadata(rawAccount); // -> Metadata\n\n// Fetch an deserialized account from its public key.\nawait fetchMetadata(umi, publicKey); // -> Metadata or fail\nawait safeFetchMetadata(umi, publicKey); // -> Metadata or null\n\n// Fetch all deserialized accounts by public key.\nawait fetchAllMetadata(umi, publicKeys); // -> Metadata[], fails if any account is missing\nawait safeFetchAllMetadata(umi, publicKeys) // -> Metadata[], filters out missing accounts\n\n// Create a getProgramAccount builder for the account.\nawait getMetadataGpaBuilder()\n  .whereField('updateAuthority', updateAuthority)\n  .selectField('mint')\n  .getDataAsPublicKeys() // -> PublicKey[]\n\n// Get the size of the account data in bytes, if it has a fixed size.\ngetMetadataSize() // -> number\n\n// Find the PDA address of the account from its seeds.\nfindMetadataPda(umi, seeds) // -> Pda\n```\n\n----------------------------------------\n\nTITLE: Executing Release Operation in MPL-404 Hybrid Escrow using JavaScript\nDESCRIPTION: This snippet shows how to execute a Release operation in the MPL-404 Hybrid Escrow, swapping an NFT for fungible tokens. It uses the releaseV1 function from the mpl-hybrid library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\n// Release an NFT and receive fungible tokens\nconst releaseTx = await releaseV1(umi, {\n  owner: umi.payer,\n  escrow,\n  asset,\n  collection,\n  token,\n  feeProjectAccount,\n}).sendAndConfirm(umi);\n\nconst signature = base58.deserialize(releaseTx.signature)[0];\nconsole.log(`Released! Check it out: https://explorer.solana.com/tx/${signature}?cluster=devnet`);\n```\n\n----------------------------------------\n\nTITLE: Testing Token Claim by Whitelisted Address in Solana Airdrop Program\nDESCRIPTION: Tests the ability for a whitelisted address to claim tokens from the airdrop. This test adds a new address to the Merkle tree, updates the on-chain Merkle root, generates a proof for the address, funds the new address with SOL, and then attempts to claim tokens using the proof. It validates the core claiming functionality of the airdrop program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nit(\"Perform claim with whitelisted address\", async () => {\n    newAddress = Keypair.generate();\n    newData = {\n      address: newAddress.publicKey,\n      amount: Math.floor(Math.random() * 1000),           // Example random amount\n      isClaimed: false,                                   // Default value for isClaimed\n    }\n    merkleTreeData.push(newData); \n    const entryBytes = Buffer.concat([\n      newData.address.toBuffer(), // PublicKey as bytes\n      Buffer.from(new Uint8Array(new anchor.BN(newData.amount).toArray('le', 8))), // Amount as little-endian\n      Buffer.from([newData.isClaimed ? 1 : 0]), // isClaimed as 1 byte\n    ]);\n    merkleTree.add_leaf(entryBytes);\n    merkleTree.merklize();\n  \n    const newMerkleRoot = Array.from(merkleTree.get_merkle_root());\n  \n    await program.methods.updateTree(newMerkleRoot)\n      .accountsPartial({\n        airdropState: airdropState,\n        authority: authority.publicKey,\n      })\n      .signers([authority])\n      .rpc();\n  \n    const index = merkleTreeData.findIndex(data => data.address.equals(newAddress.publicKey));\n    if (index === -1) {\n      throw new Error(\"Address not found in Merkle tree data\");\n    }\n\n    const proof = merkleTree.merkle_proof_index(index);\n    const proofArray = Buffer.from(proof.get_pairing_hashes());\n\n    await provider.sendAndConfirm(\n      new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: provider.publicKey,\n          toPubkey: newAddress.publicKey,\n          lamports: 10 * LAMPORTS_PER_SOL,\n        })\n      ), \n      []\n    );\n  \n    try {\n      await program.methods.claimAirdrop(new anchor.BN(newData.amount), proofArray, new anchor.BN(index))\n        .accountsPartial({\n          airdropState,\n          mint: mint.publicKey,\n          vault,\n          signerAta: await getAssociatedTokenAddress(mint.publicKey, newAddress.publicKey),\n          signer: newAddress.publicKey,\n          systemProgram: SystemProgram.programId,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          associatedTokenProgram: ASSOCIATED_PROGRAM_ID,\n        })\n        .signers([newAddress])\n        .rpc();\n      console.log(\"Action performed successfully for whitelisted address\");\n    } catch (error) {\n      console.error(\"Error performing action:\", error);\n      throw error;\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Collection with Master Edition Plugin in Rust\nDESCRIPTION: This code snippet shows how to create an MPL Core Collection with the Master Edition Plugin using Rust. It sets up an RPC client, generates keypairs, and creates a collection with the Master Edition plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::CreateCollectionV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_collection_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let collection = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_collection_ix = CreateCollectionV1Builder::new()\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::MasterEdition(MasterEdition {\n                max_supply: 100,\n                name: \"My Master Edition\"\n                uri: \"https://example.com/my-master-edition\",\n            }),\n            authority: Some(PluginAuthority::UpdateAuthority),\n        }])\n        .instruction();\n\n    let signers = vec![&collection, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_tx = Transaction::new_signed_with_payer(\n        &[create_collection_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Authority for Token or Mint Account in Solana using Umi\nDESCRIPTION: This snippet shows how to change the authority on a Token or Mint account using Umi. It specifies the account to be modified, the current owner, the type of authority to change, and the new authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setAuthority, AuthorityType } from '@metaplex-foundation/mpl-toolbox'\n\nawait setAuthority(umi, {\n  owned: tokenAccount,\n  owner,\n  authorityType: AuthorityType.CloseAccount,\n  newAuthority: newCloseAuthority.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Selecting Assets for Capture in MPL-404 Hybrid Escrow using JavaScript\nDESCRIPTION: This snippet demonstrates how to select a random asset owned by the escrow for the Capture operation in the MPL-404 Hybrid Escrow. It fetches assets by collection and filters for those owned by the escrow.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\n// Fetch all the assets in the collection\nconst assetsListByCollection = await fetchAssetsByCollection(umi, collection, {\n    skipDerivePlugins: false,\n})\n\n// Find the assets owned by the escrow\nconst asset = assetsListByCollection.filter(\n    (a) => a.owner === publicKey(escrow)\n)[0].publicKey\n```\n\n----------------------------------------\n\nTITLE: Approving Data Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code example demonstrates how to approve a Data Item Delegate using the delegateDataItemV1 function. It sets up a delegate that can update the data object of an individual asset, including creators.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateDataItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateDataItemV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: dataItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Transfer Delegate Plugin - Rust Implementation\nDESCRIPTION: Shows the Rust implementation for adding a Transfer Delegate plugin to an MPL Core Asset. Includes RPC client setup, transaction building, and signature confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/transfer-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::AddPluginV1Builder,\n    types::{Plugin, TransferDelegate},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_transfer_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_plugin_ix = AddPluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::TransferDelegate(TransferDelegate {}))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_plugin_tx = Transaction::new_signed_with_payer(\n        &[add_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Full example of creating and sending a transaction using CreateV1Builder in Rust\nDESCRIPTION: This is a complete example demonstrating how to create a `CreateV1` instruction using the `CreateV1Builder`, build a Solana transaction, sign it, and send it to the Solana network. It utilizes crates like `mpl_core`, `solana_client`, and `solana_sdk` for building the transaction. The code initializes a payer and asset keypair, uses the `CreateV1Builder` to create the instruction, signs the transaction, gets the latest blockhash, and sends the transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse mpl_core::instructions::CreateV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_tx = Transaction::new_signed_with_payer(\n        &[create_asset_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client.send_and_confirm_transaction(&create_asset_tx).await.unwrap();\n\n    println!(\"Signature: {:?}\", res)\n```\n\n----------------------------------------\n\nTITLE: Fetching MPL Core Assets by Collection using DAS API in JavaScript\nDESCRIPTION: This code demonstrates how to retrieve all MPL Core assets within a specified collection using the DAS API. It creates a UMI instance with your RPC endpoint, initializes the DAS API, and then calls the getAssetsByCollection method with a collection public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-collection.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst collection = publicKey('<PublicKey>');\n\nconst assets = await das.getAssetsByCollection(umi, { collection });\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Setting up Redeemed Amount Guard in Sugar Config\nDESCRIPTION: This JSON snippet shows how to add the Redeemed Amount guard to a Candy Machine configuration file when using Sugar. The guard sets a maximum number of NFTs that can be minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"redeemedAmount\" : {\n    \"maximum\": number,\n}\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL in TypeScript\nDESCRIPTION: The code demonstrates how to airdrop SOL using a specific cluster that supports airdrops. It sends SOL to an account and waits for transaction confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Send 1.5 SOL to \"myPublicKey\" and wait for the transaction to be confirmed.\nawait umi.rpc.airdrop(myPublicKey, sol(1.5));\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi with Existing Wallet\nDESCRIPTION: Setup Umi instance using an existing wallet from filesystem\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n\nconst walletFile = fs.readFileSync(\n  path.join(__dirname, './keypair.json')\n)\n\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\nconst signer = createSignerFromKeypair(umi, keyair);\n\numi.use(signerIdentity(walletFile))\n```\n\n----------------------------------------\n\nTITLE: Managing Utility Delegates for Programmable NFTs in TypeScript\nDESCRIPTION: Shows how to work with utility delegates, which can lock PNFTs and burn them. When a PNFT is locked by a utility delegate, the owner cannot transfer it, burn it, or revoke the delegate until it's unlocked.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateUtilityV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateUtilityV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: utilityDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeUtilityV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeUtilityV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: utilityDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { burnV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait burnV1(umi, {\n  mint,\n  authority: utilityDelegate,\n  tokenOwner: currentOwner,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait lockV1(umi, {\n  mint,\n  authority: utilityDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unlockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unlockV1(umi, {\n  mint,\n  authority: utilityDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Thawing Frozen Asset in JavaScript\nDESCRIPTION: This example demonstrates how to thaw a frozen asset in a Candy Machine utilizing the Freeze Token Payment guard. It requires parameters such as the mint account, destination token address, asset mint, and asset owner. The purpose is to make frozen tokens transferable again once the thawing conditions are met.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: \"freezeTokenPayment\",\n  routeArgs: {\n    path: \"thaw\",\n    mint: tokenMint.publicKey,\n    destinationAta,\n    AssetMint: AssetMint.publicKey,\n    AssetOwner: umi.identity.publicKey,\n    AssetTokenStandard: candyMachine.tokenStandard,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Freezing Asset\nDESCRIPTION: Freezes the asset to prevent trading while staked by adding a FreezeDelegate plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ntx = await transactionBuilder().add(\n    [...]\n).add(addPlugin(umi, {\n    asset,\n    collection,\n    plugin: {\n        type: \"FreezeDelegate\",\n        frozen: true,\n        authority: { type: \"UpdateAuthority\" }\n    }\n})).buildAndSign(umi);\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Collection in TypeScript\nDESCRIPTION: This code demonstrates how to fetch all assets belonging to a specific collection using the fetchAssetsByCollection() function. It includes an option to skip deriving plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByCollection = await fetchAssetsByCollection(umi, collection, {\n  skipDerivePlugins: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Guard Data with Metaplex\nDESCRIPTION: This snippet fetches Candy Guard data using the `safeFetchCandyGuard` function from the `@metaplex-foundation/mpl-core-candy-machine` library. It requires the `umi` instance and the `candyMachine.mintAuthority` (Candy Guard's public key). The fetched Candy Guard data contains information about the conditions required for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { safeFetchCandyGuard } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst candyGuard = await safeFetchCandyGuard(umi, candyMachine.mintAuthority);\n```\n\n----------------------------------------\n\nTITLE: Creating a Merkle Tree on Alternative SVMs with Manual Program IDs\nDESCRIPTION: Example showing how to create a Merkle tree for compressed NFTs by manually specifying the logWrapper and compressionProgram values for the target SVM.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-interact-with-cnfts-on-other-svms.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTree,\n  MPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  MPL_NOOP_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-bubblegum'\nimport {\n  generateSigner,\n  publicKey,\n} from '@metaplex-foundation/umi';\n\n// Create a Merkle tree specifying the correct `logWrapper` and\n// `compressionProgram` for the SVM.\nconst merkleTree = generateSigner(umi);\nconst createTreeTx = await createTree(umi, {\n  merkleTree,\n  maxDepth: 3,\n  maxBufferSize: 8,\n  canopyDepth: 0,\n  logWrapper: MPL_NOOP_PROGRAM_ID,\n  compressionProgram: MPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n});\n\nawait createTreeTx.sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Inserting Items with Prefixes in Candy Machine using TypeScript\nDESCRIPTION: This code shows how to insert items into a Candy Machine that uses name and URI prefixes. It demonstrates adding config lines with only the unique part of the name and URI, excluding the prefix.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/insert-items.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: candyMachine.itemsLoaded,\n  configLines: [\n    { name: '1', uri: '1.json' },\n    { name: '2', uri: '2.json' },\n    { name: '3', uri: '3.json' },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Dependency for Rust SDK\nDESCRIPTION: This snippet demonstrates how to add the 'mpl-token-metadata' dependency to a Rust project using the Cargo package manager. This is essential for using the Token Metadata SDK features.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-token-metadata\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Address Lookup Tables with mpl-toolbox\nDESCRIPTION: Demonstrates how to create a lookup table using the mpl-toolbox package and later apply it to a transaction builder. This helps optimize transaction size for transactions with repeated addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLut } from '@metaplex-foundation/mpl-toolbox'\n\n// Create a lookup table.\nconst [lutBuilder, lut] = createLut(umi, {\n  recentSlot: await umi.rpc.getSlot({ commitment: 'finalized' }),\n  addresses: [myAddressA, myAddressB, myAddressC],\n})\nawait lutBuilder.sendAndConfirm(umi)\n\n// Later on, use the created lookup table.\nmyBuilder = myBuilder.setAddressLookupTables([lut])\n```\n\n----------------------------------------\n\nTITLE: Updating Edition Plugin on MPL Core Asset in TypeScript\nDESCRIPTION: This snippet demonstrates how to update the Edition Plugin on an existing MPL Core asset using TypeScript. It changes the edition number to 2, assuming the plugin is mutable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/edition.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\n  await updatePlugin(umi, {\n    asset: assetAccount.publicKey,\n    plugin: { type: 'Edition', number: 2 },\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Full Example of Sending Transaction with CreateV1Builder\nDESCRIPTION: This full Rust example demonstrates creating a transaction using a Metaplex CreateV1Builder, signing it with the necessary keys, and sending it through a Solana RPC client. It highlights the process from building the instruction to receiving confirmation of the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::CreateV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};\n\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let create_asset_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_tx = Transaction::new_signed_with_payer(\n        &[create_asset_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client.send_and_confirm_transaction(&create_asset_tx).await.unwrap();\n\n    println!(\"Signature: {:?}\", res)\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Collection with Master Edition Plugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an MPL Core Collection with the Master Edition Plugin using TypeScript. It imports necessary functions, generates a signer, and calls the createCollection function with specified parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/master-edition.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport { createCollection } from '@metaplex-foundation/core'\n\nconst collectionSigner = generateSigner(umi)\n\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: 'My NFT',\n  uri: 'https://example.com/my-nft.json',\n  plugins: [\n    {\n      type: 'MasterEdition',\n      maxSupply: 100,\n      name: 'My Master Edition',\n      uri: 'https://example.com/my-master-edition.json',\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Connecting to an SVM with Umi for cNFT Operations\nDESCRIPTION: Code snippet showing how to create a Umi instance connected to a specific SVM endpoint and configured with the necessary plugins for Bubblegum operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-interact-with-cnfts-on-other-svms.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\n\nconst umi = createUmi('<RPC endpoint for the SVM>')\n  .use(mplBubblegum())\n  .use(mplTokenMetadata())\n  ...\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Permanent Freeze Plugin - TypeScript\nDESCRIPTION: Updates the freeze state of an existing collection's permanent freeze delegate plugin. Requires the signing wallet to be the plugin authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-freeze-delegate.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updateCollectionPlugin } from '@metaplex-foundation/mpl-core'\n\nconst updateCollectionResponse =  await updateCollectionPlugin(umi, {\n  collection: collectionSigner.publicKey,\n  plugin: {\n      type: \"PermanentFreezeDelegate\",\n      frozen: false,\n    },\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Approving a Programmable Config Delegate for PNFTs in TypeScript\nDESCRIPTION: Creates a Programmable Config Delegate that can update the ruleSet of a PNFT. This delegate can also update items in a collection if the PNFT is a Collection NFT. Requires the mint, update authority, delegate address, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateProgrammableConfigV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateProgrammableConfigV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: programmableConfigDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Uploading Image to Arweave via Irys in Typescript\nDESCRIPTION: This snippet reads an image file from the local file system, transforms it into a `GenericFile` type using `createGenericFile`, and then uploads it to Arweave via Irys using the `umi.uploader.upload` method. The content type is set to `image/png` to ensure proper display. The URI of the uploaded image is then logged to the console.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n  // use `fs` to read file via a string path.\n  \n  const imageFile = fs.readFileSync(\"./image.jpg\");\n\n  // Use `createGenericFile` to transform the file into a `GenericFile` type\n  // that umi can understand. Make sure you set the mimi tag type correctly\n  // otherwise Arweave will not know how to display your image.\n\n  const umiImageFile = createGenericFile(imageFile, \"image.png\", {\n    tags: [{ name: \"Content-Type\", value: \"image/png\" }],\n  });\n\n  // Here we upload the image to Arweave via Irys and we get returned a uri\n  // address where the file is located. You can log this out but as the\n  // uploader can takes an array of files it also returns an array of uris.\n  // To get the uri we want we can call index [0] in the array.\n\n  console.log(\"Uploading image to Arweave via Irys\");\n  const imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n    throw new Error(err);\n  });\n\n  console.log(imageUri[0]);\n```\n\n----------------------------------------\n\nTITLE: Sending Transaction and Confirming Token Creation\nDESCRIPTION: Chaining token creation instructions and sending the transaction\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst tx = await createFungibleIx\n  .add(createTokenIx)\n  .add(createTokenAccountIfMissing)\n  .add(mintTokensIx)\n  .sendAndConfirm(umi)\n\nconsole.log(base58.deserialize(tx.signature)[0])\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Assets by Owner\nDESCRIPTION: Helper function to fetch all Digital Assets by owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetByOwner } from '@metaplex-foundation/mpl-token-metadata'\n\nconst assets = await fetchAllDigitalAssetByOwner(umi, owner)\n```\n\n----------------------------------------\n\nTITLE: Distributing Funds with Token Model\nDESCRIPTION: Illustrates distributing funds in a Hydra wallet using the Token membership model by specifying SPL token and making a transaction through the distribute method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst membershiptMint\n.\npublicKey = \"SPL-Token-PublicKey\";\n\nlet distributeToMember1 = await fanoutSdk.distributeTokenMemberInstructions(\n  {\n    distributeForMint: false,\n    membershipMint: membershipMint.publicKey,\n    fanout: fanout,\n    member: member1.publicKey,\n    payer: distributionBot.publicKey,\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Transfer Collection Asset using Rust\nDESCRIPTION: Demonstrates transferring a Core NFT Asset that belongs to a collection in Rust, including collection address handling and transaction building.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/transfer.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::TransferV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn transfer_asset_in_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let collection = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let new_owner = Pubkey::from_str(\"33333333333333333333333333333333\").unwrap();\n\n    let transfer_asset_in_collection_ix = TransferV1Builder::new()\n        .asset(asset)\n        .collection(Some(collection))\n        .payer(authority.pubkey())\n        .new_owner(new_owner)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let transfer_asset_in_collection_tx = Transaction::new_signed_with_payer(\n        &[transfer_asset_in_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&transfer_asset_in_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Mint Inscription with Associated Image Data\nDESCRIPTION: Retrieve mint inscription and associated image data using multiple functions from the Metaplex Inscription library. Involves fetching mint inscription, metadata account, and associated inscription image.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/fetch.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchInscription, safeFetchMintInscriptionFromSeeds, safeFetchInscriptionMetadataFromSeeds } from '@metaplex-foundation/mpl-inscription'\n\nconst mintInscription = await safeFetchMintInscriptionFromSeeds(umi, {\n  mint,\n})\n\nconst inscriptionMetadataAccount = await safeFetchInscriptionMetadataFromSeeds(\n  umi,\n  {\n    inscriptionAccount: inscriptionAccount.publicKey,\n  }\n)\n\nconst associatedInscriptionAccount = findAssociatedInscriptionPda(umi, {\n  associated_tag: inscriptionMetadataAccount.associatedInscriptions[0].tag,\n  inscriptionMetadataAccount.publicKey,\n})\nconst imageData = await fetchInscription(umi, associatedInscriptionAccount[0])\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Mint Limit Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine with the Mint Limit guard using TypeScript. It specifies an ID of 1 and a limit of 5 mints per wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/mint-limit.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    mintLimit: some({ id: 1, limit: 5 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Revoking Collection Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code snippet shows how to revoke a Collection Delegate using the revokeCollectionV1 function. It removes the delegate's authority to perform collection-related actions on the specified NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeCollectionV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeCollectionV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: collectionDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Asset with Permanent Freeze Plugin - Rust\nDESCRIPTION: Implements asset creation with a permanent freeze delegate plugin using Rust. Demonstrates the setup process including RPC client initialization and transaction handling.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-freeze-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{\n    instructions::CreateV1Builder,\n    types::{PermanentFreezeDelegate, Plugin, PluginAuthority, PluginAuthorityPair},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_permanent_freeze_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let delegate = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_permanent_freeze_delegate_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::PermanentFreezeDelegate(PermanentFreezeDelegate { frozen: true }),\n            authority: Some(PluginAuthority::Address { address: delegate }),\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_permanent_freeze_delegate_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_permanent_freeze_delegate_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_permanent_freeze_delegate_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with Existing Local Wallet for Solana\nDESCRIPTION: TypeScript code that initializes the Umi framework with necessary plugins and configures it to use an existing wallet from a local keypair file for authentication.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplBubblegum())\n  .use(mplTokenMetadata())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// You will need to us fs and navigate the filesystem to\n// load the wallet you wish to use via relative pathing.\nconst walletFile = fs.readFileSync('./keypair.json')\n\n// Convert your walletFile onto a keypair.\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile))\n\n// Load the keypair into umi.\numi.use(keypairIdentity(keypair))\n```\n\n----------------------------------------\n\nTITLE: Creating Collection with Permanent Freeze Plugin - TypeScript\nDESCRIPTION: Creates a new collection with a permanent freeze delegate plugin. Sets up the collection with freeze capability and assigns the update authority as the plugin authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-freeze-delegate.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createCollection } from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\nawait createCollection(umi, {\n  collection: collectionSigner,\n  name: \"Frozen Collection\",\n  uri: \"https://example.com/my-collection.json\",\n  plugins: [\n      {\n        type: 'PermanentFreezeDelegate',\n        frozen: true,\n        authority: { type: \"UpdateAuthority\"}, // The update authority can unfreeze it\n      },\n    ],\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Deserializing Asset Account in Anchor\nDESCRIPTION: Demonstrates Asset account deserialization within an Anchor context, accessing account data and converting it to BaseAssetV1 structure.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet asset = ctx.accounts.asset;\n\nlet data = asset.try_borrow_data()?;\n\nlet asset_v1 = BaseAssetV1::from_bytes(&data.as_ref())?;\n\nprintln!(\"assetV1: {:?}\", asset_v1);\n```\n\n----------------------------------------\n\nTITLE: ConfigLineSettings Implementation in TypeScript\nDESCRIPTION: Demonstrates the structure for ConfigLineSettings object which provides advanced options for Asset data storage optimization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nConfigLineSettings = {\n    prefixName: string;\n    nameLength: number;\n    prefixUri: string;\n    uriLength: number;\n    isSequential: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating as Collection Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet illustrates how a Collection Item Delegate can update the collection attribute of an asset using the updateAsCollectionItemDelegateV2 function. It demonstrates setting a new collection for the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updateAsCollectionItemDelegateV2 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait updateAsCollectionItemDelegateV2(umi, {\n  mint,\n  authority: collectionItemDelegate,\n  collection: collectionToggle('Set', [\n    { key: collectionMint, verified: false },\n  ]),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Vanity Mint Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with a Vanity Mint guard that requires the mint address to start and end with 'mplx'. The guard uses a regular expression to validate the mint address format.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/vanity-mint.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    vanityMint: some({\n      regex: \"^mplx*mplx$\",\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Permanent Transfer Plugin in Rust\nDESCRIPTION: This Rust code snippet shows how to create an MPL Core Asset with a Permanent Transfer Plugin. It sets up an RPC client, generates keypairs for the payer and asset, defines a delegate public key, builds the create instruction with the plugin configuration, and sends the transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-transfer-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::CreateV1Builder,\n    types::{PermanentBurnDelegate, Plugin, PluginAuthority, PluginAuthorityPair},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_asset_with_permanent_burn_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let delegate = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_burn_transfer_delegate_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::PermanentBurnDelegate(PermanentBurnDelegate {}),\n            authority: Some(PluginAuthority::Address { address: delegate }),\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_burn_transfer_delegate_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_burn_transfer_delegate_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_burn_transfer_delegate_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Program Accounts with Filters\nDESCRIPTION: Demonstrates various ways to fetch program accounts including all accounts, sliced data, and filtered results.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch all accounts from a program.\nconst allProgramAccounts = await umi.rpc.getProgramAccounts(myProgramId);\n\n// Fetch a slice of all accounts from a program.\nconst slicedProgramAccounts = await umi.rpc.getProgramAccounts(myProgramId, {\n  dataSlice: { offset: 32, length: 8 },\n});\n\n// Fetch some accounts from a program that matches a given set of filters.\nconst filteredProgramAccounts = await umi.rpc.getProgramAccounts(myProgramId, {\n  filters: [\n    { dataSize: 42 },\n    { memcmp: { offset: 0, bytes: new Uint8Array([1, 2, 3]) } },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Removing Autograph from Asset\nDESCRIPTION: Example showing how to remove a specific autograph from an asset by filtering out the signature with the matching public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/autograph.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\n// The Publickey of the autograph that you want to remove \nconst publicKeyToRemove = publicKey(\"abc...\")\n\nconst autographsToKeep = asset.autograph.signatures.filter(\n  (autograph) => autograph.address !== publicKeyToRemove\n);\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'Autograph',\n    // This should contain all Autographs that you do not want to remove\n    signatures: autographsToKeep,\n  },\n  authority: umi.identity, // Should be the owner of the asset\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring SOL using mpl-toolbox\nDESCRIPTION: This code utilizes the `transferSol` helper function from the `mpl-toolbox` package to initiate a SOL transfer on the Solana blockchain. It defines the source (UMI's identity), destination (a hardcoded public key), and the amount of SOL to transfer, then sends and confirms the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\n\"// Here we call the transferSol() function and send it to the chain.\\n\\nconst res = await transferSol(umi, {\\n  source: umi.identity,\\n  destination: publicKey('111111111111111111111111111111'),\\n  amount: sol(1),\\n}).sendAndConfirm(umi)\"\n```\n\n----------------------------------------\n\nTITLE: Minting with Freeze Sol Payment Guard using JavaScript\nDESCRIPTION: Code example showing how to mint an NFT using the Freeze Sol Payment guard by providing the required mint arguments, specifically the destination address for the payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    freezeSolPayment: some({ destination: umi.identity.publicKey }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Collection-Level Soulbound Implementation\nDESCRIPTION: Complete implementation showing how to create a soulbound collection where all assets are non-transferrable. Includes collection creation with freeze plugin, asset creation, and transfer restriction testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { mplCore } from \"@metaplex-foundation/mpl-core\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  publicKey,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createCollection,\n  create,\n  fetchCollection,\n  transfer,\n  fetchAssetV1,\n} from \"@metaplex-foundation/mpl-core\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\nconst DESTINATION_WALLET = publicKey(\"CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d\");\n\n(async () => {\n  const umi = createUmi(\n    \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\"\n  ).use(mplCore());\n\n  const walletSigner = generateSigner(umi);\n  umi.use(keypairIdentity(walletSigner));\n\n  console.log(\"Funding test wallet with devnet SOL...\");\n  await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1));\n  \n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  console.log(\"Creating frozen collection...\");\n  const collectionSigner = generateSigner(umi);\n  await createCollection(umi, {\n    collection: collectionSigner,\n    name: \"Frozen Collection\",\n    uri: \"https://example.com/my-collection.json\",\n    plugins: [\n      {\n        type: 'PermanentFreezeDelegate',\n        frozen: true,\n        authority: { type: \"None\" },\n      },\n    ],\n  }).sendAndConfirm(umi);\n\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  const collection = await fetchCollection(umi, collectionSigner.publicKey);\n  console.log(\"Frozen collection created successfully:\", collectionSigner.publicKey);\n\n  console.log(\"Creating asset in frozen collection...\");\n  const assetSigner = generateSigner(umi);\n  await create(umi, {\n    asset: assetSigner,\n    collection: collection,\n    name: \"Frozen Asset\",\n    uri: \"https://example.com/my-asset.json\",\n  }).sendAndConfirm(umi);\n\n  await new Promise(resolve => setTimeout(resolve, 15000));\n\n  const asset = await fetchAssetV1(umi, assetSigner.publicKey);\n  console.log(\"Asset created successfully in frozen collection:\", assetSigner.publicKey);\n\n  console.log(\n    \"Testing frozen property by attempting a transfer (this should fail)...\"\n  );\n  \n  const transferResponse = await transfer(umi, {\n    asset: asset,\n    newOwner: DESTINATION_WALLET,\n    collection,\n  }).sendAndConfirm(umi, { send: { skipPreflight: true } });\n\n  console.log(\n    \"Transfer attempt signature:\",\n    base58.deserialize(transferResponse.signature)[0]\n  );\n})();\n```\n\n----------------------------------------\n\nTITLE: Implementing Payer-Authority Pattern with Anchor in Rust\nDESCRIPTION: An Anchor implementation of the Payer-Authority pattern for creating a new account. The code defines an account struct with initialization parameters, payer, optional authority, and system program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/payer-authority-pattern.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    /// Create a new account.\n    #[derive(Accounts)]\n    pub struct CreateAccount<'info> {\n        /// The address of the new account\n        #[account(init, payer = player_one, space = 8 + NewAccount::MAXIMUM_SIZE)]\n        pub account: Account<'info, NewAccount>,\n        \n        /// The account paying for the storage fees\n        #[account(mut)]\n        pub payer: Signer<'info>,\n        \n        /// The authority signing for the account creation\n        pub authority: Option<Signer<'info>>,\n        \n        // The system program\n        pub system_program: Program<'info, System>\n    }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Owner using cURL with DAS API\nDESCRIPTION: This example shows how to make a direct JSON-RPC call to the DAS API using cURL to retrieve assets owned by a specific wallet address. It specifies the owner address, limits the results to 10 items, and requests the first page of results.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-owner.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetsByOwner\",\n    \"params\": {\n        \"ownerAddress\": \"N4f6zftYsuu4yT7icsjLwh4i6pB1zvvKbseHj2NmSQw\",\n        \"limit\": 10,\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds in Candy Machine (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to unlock funds from the Freeze Escrow account using the current identity as the Candy Guard authority. It specifies the route instruction and the necessary arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeTokenPayment',\n  routeArgs: {\n    path: 'unlockFunds',\n    destination,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Owner using JavaScript with DAS API\nDESCRIPTION: This example demonstrates how to retrieve assets owned by a specific wallet address using JavaScript and the Digital Asset Standard API. It imports necessary packages, creates a UMI instance, specifies an owner address, and retrieves up to 10 assets owned by that address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-owner.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst owner = publicKey('N4f6zftYsuu4yT7icsjLwh4i6pB1zvvKbseHj2NmSQw');\n\nconst assets = await umi.rpc.getAssetsByOwner({\n    owner,\n    limit: 10\n});\nconsole.log(assets.items.length > 0);\n```\n\n----------------------------------------\n\nTITLE: Creating an MPL Core Collection in JavaScript\nDESCRIPTION: Code snippet demonstrating how to create a Core Collection using the mpl-core package. This collection will be used to group all assets that users purchase from a Core Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/preparing-assets.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, umi } from '@metaplex-foundation/umi'\nimport { createCollectionV1 } from '@metaplex-foundation/mpl-core'\n\nconst mainnet = 'https://api.mainnet-beta.solana.com'\nconst devnet = 'https://api.devnet.solana.com'\n\nconst keypair = // assign keypair\n\nconst umi = createUmi(mainnet)\n.use(keypairIdentity(keypair)) // Assign identity signer of your choice.\n.use(mplCore())\n\nconst collectionSigner = generateSigner(umi)\n\nawait createCollectionV1(umi, {\n  collection: collectionSigner,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Making Plugin Data Immutable in Rust\nDESCRIPTION: This Rust code snippet shows how to make plugin data immutable using the MPL Core library. It creates an instruction to set the 'FreezeDelegate' plugin authority to 'None' for a specific asset, effectively making the plugin data immutable, and sends the transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::ApprovePluginAuthorityV1Builder,\n    types::{PluginAuthority, PluginType},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn make_plugin_data_immutable() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let make_plugin_data_immutable_ix = ApprovePluginAuthorityV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin_type(PluginType::FreezeDelegate)\n        .new_authority(PluginAuthority::None)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let make_plugin_data_immutable_tx = Transaction::new_signed_with_payer(\n        &[make_plugin_data_immutable_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&make_plugin_data_immutable_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Creator from MPL Core Asset\nDESCRIPTION: This snippet demonstrates how to remove a creator from an MPL Core Asset. It assumes that umi.identity is the update authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\n// The Publickey of the creator that you want to remove \nconst publicKeyToRemove = publicKey(\"abc...\")\n\n\nconst creatorsToKeep = asset.verifiedCreators.signatures.filter(\n  (creator) => creator.address !== publicKeyToRemove\n);\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n    signatures: creatorsToKeep,\n  },\n  authority: umi.identity, // Should be the update authority\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Burn Multi Guard in TypeScript\nDESCRIPTION: This code snippet shows how to mint with the Asset Burn Multi guard. It specifies the required collection and the addresses of the assets to burn during the minting process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-burn-multi.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    assetBurnMulti: some({\n      requiredCollection: requiredCollection.publicKey,\n      assets: [assetToBurn1.publicKey, assetToBurn2.publicKey],\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with NFT Payment Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the NFT Payment Guard in TypeScript. It specifies the required collection and destination for the NFT payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftPayment: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Making Plugin Data Immutable in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to make plugin data immutable using the MPL Core library. It uses the approvePluginAuthority function to set the 'FreezeDelegate' plugin authority to 'None', effectively making the plugin data immutable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  approvePluginAuthority\n} from '@metaplex-foundation/mpl-core'\n\nawait approvePluginAuthority(umi, {\n  asset: asset.publicKey,\n  plugin: { type: 'FreezeDelegate' },\n  newAuthority: { type: 'None' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Unverifying a Collection NFT with JavaScript SDK\nDESCRIPTION: This snippet provides functionality to unverify a Collection NFT in a collection. Similar to the verification process, it requires the same parameters and uses the unverify instruction. The expected inputs are the same as the verification process, and the outcome is that the NFT will no longer be verified in the context of the Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/collections.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from \"@metaplex-foundation/umi\";\nimport { unverifyCollectionV1, findMetadataPda } from '@metaplex-foundation/mpl-token-metadata'\n\n// first find the metadata PDA to use later\nconst metadata = findMetadataPda(umi, { \n  mint: publicKey(\"...\")\n});\n\nawait unverifyCollectionV1(umi, {\n  metadata,\n  collectionMint,\n  authority: collectionAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Generating a New Wallet with Umi\nDESCRIPTION: This code snippet sets up Umi with a `generatedSigner()`, creating a new wallet/private key for testing. It initializes Umi with a Devnet RPC endpoint, uses `mplCore()` and `irysUploader()`, generates a new keypair signer, and configures Umi to use this signer, then airdrops SOL for testing purposes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n\"const umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\\n  .use(mplCore())\\n  .use(irysUploader())\\n\\n// Generate a new keypair signer.\\nconst signer = generateSigner(umi)\\n\\n// Tell Umi to use the new signer.\\numi.use(signerIdentity(signer))\\n\\n// This will airdrop SOL on devnet only for testing.\\nawait umi.rpc.airdrop(umi.identity.publickey)\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi Store with RPC\nDESCRIPTION: This TypeScript code snippet uses Zustand to create a global state management solution for the Umi instance, specifying the RPC URL directly. It allows integration with Solana by using a default signer. This block is essential for ensuring that the app communicates correctly with the blockchain network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst useUmiStore = create<UmiState>()((set) => ({\n  umi: createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(\n    signerIdentity(\n      createNoopSigner(publicKey('11111111111111111111111111111111'))\n    )\n  ),\n  ...\n}))\n```\n\n----------------------------------------\n\nTITLE: Freezing an Asset\nDESCRIPTION: Illustrates how to freeze an MPL Core Asset, preventing transfers and burns. This is commonly used for escrowless staking or marketplace listings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { freezeAsset, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\nconst assetAccount = await fetchAsset(umi, assetAddress)\n\nconst delegateSigner = generateSigner(umi)\n\nawait freezeAsset(umi, {\n    asset: assetAccount,\n    delegate: delegateSigner.publicKey,\n    authority: delegateSigner,\n  }).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nUpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: true }))\n    .invoke()?;\n```\n\n----------------------------------------\n\nTITLE: Fetching All Digital Assets With Token by Owner\nDESCRIPTION: Helper function to fetch all Digital Assets With Token for a given owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetWithTokenByOwner } from '@metaplex-foundation/mpl-token-metadata'\n\nconst assets = await fetchAllDigitalAssetWithTokenByOwner(umi, owner)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Allocation Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with the Allocation guard using TypeScript. It sets the guard's ID to 1 and the limit to 5 mints.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allocation.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    allocation: some({ id: 1, limit: 5 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting Token-2022 Tokens in TypeScript\nDESCRIPTION: Mints a Token-2022 token using the Umi framework. Shows how to find the associated token PDA and mint a non-fungible token using the Token-2022 program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-2022.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\nimport { findAssociatedTokenPda } from '@metaplex-foundation/mpl-toolbox'\n\nconst SPL_TOKEN_2022_PROGRAM_ID: PublicKey = publicKey(\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'\n)\n\nconst token = findAssociatedTokenPda(umi, {\n  mint: mint.publicKey,\n  owner: umi.identity.publicKey,\n  tokenProgramId: SPL_TOKEN_2022_PROGRAM_ID,\n})\n\nawait mintV1(umi, {\n  mint: mint.publicKey,\n  token,\n  authority,\n  amount: 1,\n  tokenOwner,\n  splTokenProgram: SPL_TOKEN_2022_PROGRAM_ID,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Attributes Plugin to Asset\nDESCRIPTION: Demonstrates how to add the Attributes plugin to an MPL Core Asset using both TypeScript and Rust implementations. Includes initialization of the asset and plugin configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/attribute.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'Attributes',\n    attributeList: [\n      { key: 'key0', value: 'value0' },\n      { key: 'key1', value: 'value1' },\n    ],\n  },\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddPluginV1Builder,\n    types::{Attribute, Attributes, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_attributes_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_attribute_plugin_ix = AddPluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::Attributes(Attributes {\n            attribute_list: vec![\n                Attribute {\n                    key: \"color\".to_string(),\n                    value: \"blue\".to_string(),\n                },\n                Attribute {\n                    key: \"access_type\".to_string(),\n                    value: \"prestige\".to_string(),\n                },\n            ],\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_attribute_plugin_tx = Transaction::new_signed_with_payer(\n        &[add_attribute_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_attribute_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up End Date Guard in JavaScript for Core Candy Machine\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with the End Date guard using JavaScript. It imports the dateTime function from the Metaplex Foundation UMI library and sets the end date for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/end-date.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dateTime } from \"@metaplex-foundation/umi\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    endDate: some({ date: dateTime(\"2022-01-24T15:30:00.000Z\") }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying a Collection NFT with JavaScript SDK\nDESCRIPTION: This snippet demonstrates how to verify a Collection NFT using the JavaScript SDK provided by Metaplex. It finds the metadata PDA for the NFT and then sends a Verify instruction. Dependencies include '@metaplex-foundation/umi' and '@metaplex-foundation/mpl-token-metadata'. The code takes in a mint address, a collection mint address, and an authority address as parameters. It expects to confirm the verification of the NFT in the blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/collections.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from \"@metaplex-foundation/umi\";\nimport { verifyCollectionV1, findMetadataPda } from '@metaplex-foundation/mpl-token-metadata'\n\n// first find the metadata PDA to use later\nconst metadata = findMetadataPda(umi, { \n  mint: publicKey(\"...\")\n});\n\nawait verifyCollectionV1(umi, {\n  metadata,\n  collectionMint,\n  authority: collectionAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Defining Loyalty Card Data Structure in Rust\nDESCRIPTION: Defines the core data structure for storing loyalty card information including stamps, usage history, and timestamps. Implements a constructor for new cards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/loyalty-card-concept-guide.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct LoyaltyCardData {\n    pub current_stamps: u8,\n    pub lifetime_stamps: u64,\n    pub last_used: u64,\n    pub issue_date: u64,\n}\n\nimpl LoyaltyCardData {\n    pub fn new_card() -> Self {\n        let timestamp = clock::Clock::get().unwrap().unix_timestamp as u64;\n        LoyaltyCardData {\n            current_stamps: 0,\n            lifetime_stamps: 0,\n            last_used: 0,\n            issue_date: timestamp,\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Instructions Module in Metaplex SDK\nDESCRIPTION: This Rust snippet shows how to access the instructions module of the mpl-core crate, which contains various instruction variants for creating and working with instructions in Metaplex programs. It streamlines the development process by reducing boilerplate code.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmpl_core::instructions\n```\n\n----------------------------------------\n\nTITLE: Adding an Oracle Plugin to a Collection in Rust\nDESCRIPTION: Shows how to add an Oracle plugin to an existing MPL Core collection in Rust. The plugin is configured to validate transfer operations. Uses the mpl_core crate and Solana SDK to build and submit the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::AddCollectionExternalPluginAdapterV1Builder,\n    types::\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent,\n        OracleInitInfo, ValidationResultsOffset,\n    },\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_oracle_plugin_to_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let oracle_plugin = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let add_oracle_plugin_to_collection_ix = AddCollectionExternalPluginAdapterV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .init_info(ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\n            base_address: oracle_plugin,\n            results_offset: Some(ValidationResultsOffset::Anchor),\n            lifecycle_checks: vec![(\n                HookableLifecycleEvent::Transfer,\n                ExternalCheckResult { flags: 4 },\n            )],\n            base_address_config: None,\n            init_plugin_authority: None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_oracle_plugin_to_collection_tx = Transaction::new_signed_with_payer(\n        &[add_oracle_plugin_to_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_oracle_plugin_to_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Core Asset in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a Core Asset using the Metaplex Foundation's UMI library. It generates a new asset address and sends a transaction to create the asset with a name and URI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/tm-differences.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = generateSigner(umi)\n\nconst result = createV1(umi, {\n  asset: assetAddress,\n  name: 'My Nft',\n  uri: 'https://example.com/my-nft',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Asset with Permanent Freeze Plugin - TypeScript\nDESCRIPTION: Creates a new asset with a permanent freeze delegate plugin using the MPL Core library. The example demonstrates setting up an asset with freeze capability and assigning a delegate authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-freeze-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi)\nconst delegate = publicKey('33333333333333333333333333333')\n\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My NFT',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'PermanentFreezeDelegate',\n      frozen: true,\n      authority: { type: 'Address', address: delegate },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Metaplex Local Validator Directory\nDESCRIPTION: Bash command to create a directory for storing Metaplex program data for local validator setup.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmkdir ~/.local/share/metaplex-local-validator\n```\n\n----------------------------------------\n\nTITLE: Updating Compressed NFT Metadata with Collection Authority in JavaScript/TypeScript\nDESCRIPTION: This snippet demonstrates how to update a compressed NFT's metadata when it belongs to a collection. It uses the updateMetadata function from the mpl-bubblegum package, passing the collection mint as an argument.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/update-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nawait updateMetadata(umi, {\n  ...\n  collectionMint: publicKey(\"11111111111111111111111111111111\"),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Converting Keypair from Umi to Web3.js\nDESCRIPTION: TypeScript code demonstrating how to convert a Keypair from Umi format to Web3.js format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { toWeb3JsKeypair } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// Generate a new keypair\nconst umiKeypair = generateSigner(umi)\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsKeypair = toWeb3JsKeypair(umiKeypair);\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Collection in Rust\nDESCRIPTION: This Rust code fetches multiple NFT assets belonging to a specific collection. It uses the Solana RPC client with filters to get program accounts and then deserializes them into BaseAssetV1 structs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{accounts::BaseAssetV1, types::Key, ID as MPL_CORE_ID};\nuse solana_client::{\n    nonblocking::rpc_client,\n    rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},\n    rpc_filter::{Memcmp, MemcmpEncodedBytes, RpcFilterType},\n};\nuse solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\n\npub async fn fetch_assets_by_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client\n        .get_program_accounts_with_config(\n            &MPL_CORE_ID,\n            RpcProgramAccountsConfig {\n                filters: Some(vec![\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        0,\n                        MemcmpEncodedBytes::Bytes(vec![Key::AssetV1 as u8]),\n                    )),\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        34,\n                        MemcmpEncodedBytes::Bytes(vec![2 as u8]),\n                    )),\n                    RpcFilterType::Memcmp(Memcmp::new(\n                        35,\n                        MemcmpEncodedBytes::Base58(collection.to_string()),\n                    )),\n                ]),\n                account_config: RpcAccountInfoConfig {\n                    encoding: None,\n                    data_slice: None,\n                    commitment: None,\n                    min_context_slot: None,\n                },\n                with_context: None,\n            },\n        )\n        .await\n        .unwrap();\n\n    let accounts_iter = rpc_data.into_iter().map(|(_, account)| account);\n\n    let mut assets: Vec<BaseAssetV1> = vec![];\n\n    for account in accounts_iter {\n        let asset = BaseAssetV1::from_bytes(&account.data).unwrap();\n        assets.push(asset);\n    }\n\n    print!(\"{:?}\", assets)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Umi with Current Wallet Adapter State\nDESCRIPTION: This function fetches the current Umi state with the latest wallet adapter state using Zustand. It facilitates initiating operations that require the user's wallet identity and is usable in both TypeScript and TypeScript JSX files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst umiWithCurrentWalletAdapter = () => {\n  const umi = useUmiStore.getState().umi\n  const currentWallet = useUmiStore.getState().signer\n  if (!currentWallet) throw new Error('No wallet selected')\n  return umi.use(signerIdentity(currentWallet))\n}\nexport default umiWithCurrentWalletAdapter\n```\n\n----------------------------------------\n\nTITLE: Setting Number of Items for Candy Machine in JavaScript\nDESCRIPTION: Demonstrates how to set the number of available items when creating a new Candy Machine, which defines the maximum amount of NFTs that can be minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst candyMachineSettings = {\n  itemsAvailable: 500,\n}\n```\n\n----------------------------------------\n\nTITLE: Sending POST Form Request with Data\nDESCRIPTION: Illustrates how to send a POST request with form data using Umi's HTTP request builder, including a payload with user information\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/http-requests.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = { name: 'John Doe', email: 'john.doe@example.com' };\nawait umi.http.send(request().post('https://example.com/users').asForm().withData(data));\n```\n\n----------------------------------------\n\nTITLE: Getting Asset Proof using Metaplex Umi in JavaScript\nDESCRIPTION: This snippet demonstrates how to retrieve the merkle tree proof for a compressed asset using the DAS API with the Metaplex Umi framework. It imports necessary dependencies, creates a Umi instance with the DAS API plugin, then fetches and logs the proof for a specific asset ID.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-proof.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst assetId = publicKey('Ez6ezCMkRaUkWS5v6WVcP7uuCWiKadr3W2dHFkoZmteW');\n\nconst proof = await umi.rpc.getAssetProof(assetId);\nconsole.log(proof);\n```\n\n----------------------------------------\n\nTITLE: Deriving and Managing PDAs in TypeScript\nDESCRIPTION: Defines PDA type and demonstrates deriving new PDAs using the findPda method. Dependencies include EdDSA interface and serializers. Inputs are program IDs and seed arrays, producing a tuple of derived public key and bump number.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// In short:\ntype Pda = [PublicKey, number];\n\n// In reality:\nexport type Pda<\n  TAddress extends string = string,\n  TBump extends number = number\n> = [PublicKey<TAddress>, TBump] & { readonly __pda: unique symbol };\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst pda = umi.eddsa.findPda(programId, seeds);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { publicKey as publicKeySerializer, string } from '@metaplex-foundation/umi/serializers';\n\nconst tokenMetadataProgramId = publicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\nconst metadata = umi.eddsa.findPda(tokenMetadataProgramId, [\n  string({ size: 'variable' }).serialize('metadata'),\n  publicKeySerializer().serialize(tokenMetadataProgramId),\n  publicKeySerializer().serialize(mint),\n]);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findMetadataPda } from '@metaplex-foundation/mpl-token-metadata';\n\nconst metadata = findMetadataPda(umi, { mint });\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if the provided value is a Pda.\nisPda(myPda);\n\n// Check if the provided public key is on the EdDSA elliptic curve.\numi.eddsa.isOnCurve(myPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Revoking Data Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet demonstrates how to revoke a Data Delegate using the revokeDataV1 function. It removes the delegate's authority to update the data object of the Metadata account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeDataV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeDataV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: dataDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Removing a Plugin from MPL Core Asset in Rust\nDESCRIPTION: This snippet demonstrates how to remove a plugin from an MPL Core Asset using Rust. It uses the mpl_core, solana_client, and solana_sdk crates to remove a 'FreezeDelegate' plugin from a specified asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/removing-plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::RemovePluginV1Builder, types::PluginType};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn remove_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let remove_plugin_ix = RemovePluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin_type(PluginType::FreezeDelegate)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let remove_plugin_tx = Transaction::new_signed_with_payer(\n        &[remove_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&remove_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Core Candy Machine with Prefixes in JavaScript\nDESCRIPTION: Demonstrates setting up config line settings with name and URI prefixes to optimize the amount of data that needs to be stored per item, which allows more items to fit in a single transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/insert-items.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait create(umi, {\n  // ...\n  configLineSettings: some({\n    prefixName: 'My Asset #',\n    nameLength: 4,\n    prefixUri: 'https://example.com/nft',\n    uriLength: 9,\n    isSequential: false,\n  }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Allow List Guard in TypeScript\nDESCRIPTION: This code shows how to mint with the Allow List guard using the 'mintV2' function. It passes the Merkle root as part of the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allow-list.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMerkleRoot } from \"@metaplex-foundation/mpl-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    allowList: some({ merkleRoot: getMerkleRoot(allowList) }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering by Group when Calling Route Instructions in TypeScript\nDESCRIPTION: This code shows how to call the route instruction when using guard groups, specifically with multiple Allow List guards. It demonstrates creating a Candy Machine with two different Allow List guards in separate groups and verifying the Merkle Proof by specifying which group to use.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-route.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  route,\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { base58PublicKey, some } from \"@metaplex-foundation/umi\";\n\n// Prepare the allow lists.\nconst allowListA = [...];\nconst allowListB = [...];\n\n// Create a Candy Machine with two Allow List guards.\nawait create(umi, {\n  // ...\n  groups: [\n    {\n      label: \"listA\",\n      guards: {\n        allowList: some({ merkleRoot: getMerkleRoot(allowListA) }),\n      },\n    },\n    {\n      label: \"listB\",\n      guards: {\n        allowList: some({ merkleRoot: getMerkleRoot(allowListB) }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi);\n\n// Verify the Merkle Proof by specifying which group to select.\nawait route(umi, {\n  candyMachine: candyMachine.publicKey,\n  guard: 'allowList',\n  group: some('listA'), // <- We are veryfing using \"allowListA\".\n  routeArgs: {\n    path: 'proof',\n    merkleRoot: getMerkleRoot(allowListA),\n    merkleProof: getMerkleProof(\n      allowListA,\n      base58PublicKey(umi.identity),\n    ),\n  },\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Remove External Plugin from Asset - Rust\nDESCRIPTION: Shows how to remove an external plugin adapter from an asset using the RemoveExternalPluginAdapterV1Builder in Rust. Includes complete transaction building and submission logic.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/removing-external-plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::RemoveExternalPluginAdapterV1Builder, types::ExternalPluginAdapterKey};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn remove_external_plugin_adapter_from_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let oracle_account = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let remove_external_plugin_adapter_from_asset_ix = RemoveExternalPluginAdapterV1Builder::new()\n        .asset(asset)\n        .key(ExternalPluginAdapterKey::Oracle(oracle_account))\n        .payer(authority.pubkey())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let remove_external_plugin_adapter_from_asset_tx = Transaction::new_signed_with_payer(\n        &[remove_external_plugin_adapter_from_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&remove_external_plugin_adapter_from_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Uploading Image for Core NFT Asset Metadata\nDESCRIPTION: Demonstrates how to upload an image file to Arweave using Irys uploader plugin for Umi. This process is necessary for creating the metadata URI for the Core NFT Asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport fs from 'fs'\nimport path from 'path'\n\n// Create Umi and tell it to use Irys\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(irysUploader())\n\n// use `fs` to read file via a string path.\n// You will need to understand the concept of pathing from a computing perspective.\nconst imageFile = fs.readFileSync(\n  path.join(__dirname, '..', '/assets/my-image.jpg')\n)\n\n// Use `createGenericFile` to transform the file into a `GenericFile` type\n// that umi can understand. Make sure you set the mimi tag type correctly\n// otherwise Arweave will not know how to display your image.\nconst umiImageFile = createGenericFile(imageFile, 'my-image.jpeg', {\n  tags: [{ name: 'Content-Type', value: 'image/jpeg' }],\n})\n\n// Here we upload the image to Arweave via Irys and we get returned a uri\n// address where the file is located. You can log this out but as the\n// uploader can takes an array of files it also returns an array of uris.\n// To get the uri we want we can call index [0] in the array.\nconst imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n  throw new Error(err)\n})\n\nconsole.log(imageUri[0])\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Authority Using JavaScript and UMI\nDESCRIPTION: Demonstrates how to retrieve assets owned by a specific authority address using JavaScript with the Metaplex UMI framework and Digital Asset Standard API. The example shows how to create a UMI instance, specify the authority public key, and make an RPC call with optional filtering parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-authority.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst authority = publicKey('mRdta4rc2RtsxEUDYuvKLamMZAdW6qHcwuq866Skxxv');\n\nconst assets = await umi.rpc.getAssetsByAuthority(\n  { \n    authority,\n    sortBy, // optional\n    limit, // optional\n    page, // optional\n    before, // optional\n    after, // optional\n  }\n);\nconsole.log(assets.items.length > 0);\n```\n\n----------------------------------------\n\nTITLE: Uploading JSON Metadata for Solana NFT Collection using Umi\nDESCRIPTION: This snippet shows how to upload the metadata JSON file using Umi's uploadJson() function. It uploads the metadata to Arweave via Irys and returns the URI of the uploaded JSON file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Call upon Umi's `uploadJson()` function to upload our metadata to Arweave via Irys.\nconst metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n  throw new Error(err)\n})\n```\n\n----------------------------------------\n\nTITLE: Minting with Freeze Sol Payment Guard in JavaScript\nDESCRIPTION: This TypeScript snippet demonstrates how to mint with the Freeze Sol Payment Guard using the mintV2 function. It specifies the destination for payments in the mintArgs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    freezeSolPayment: some({ destination: umi.identity.publicKey }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds using JavaScript\nDESCRIPTION: Implementation for unlocking funds from the Freeze Escrow account using the route function. Requires destination address and candy guard authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'unlockFunds',\n    destination,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Transferring SPL Tokens with Metaplex Umi\nDESCRIPTION: Defines a function `transferSplTokens` in TypeScript that performs SPL Token transfer using the Metaplex Umi client and MPL Toolbox. It sets up necessary imports, initializes the Umi client, imports wallet keys, and executes a token transfer. Required parameters include source and destination public keys and the token amount.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-spl-tokens-on-solana.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  findAssociatedTokenPda,\n  mplToolbox,\n  transferTokens,\n} from '@metaplex-foundation/mpl-toolbox'\nimport { keypairIdentity, publicKey } from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\nconst transferSplTokens = async () => {\n  const umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(mplToolbox())\n\n  // import a wallet that has the SPL Token you want to transfer\n  const walletFile = fs.readFileSync('./keypair.json')\n\n  // Convert your walletFile onto a keypair.\n  let keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile))\n\n  // Load the keypair into umi.\n  umi.use(keypairIdentity(keypair))\n\n//\n  // Key Accounts\n  //\n\n  // The address of the Token you want to transfer.\n  const splToken = publicKey(\"111111111111111111111111111111\");\n\n  // The address of the wallet you want to transfer the Token to.\n  const destinationWallet = publicKey(\"22222222222222222222222222222222\");\n\n  // Find the associated token account for the SPL Token on the senders wallet.\n  const sourceTokenAccount = findAssociatedTokenPda(umi, {\n    mint: splToken,\n    owner: umi.identity.publicKey,\n  });\n\n  // Find the associated token account for the SPL Token on the receivers wallet.\n  const destinationTokenAccount = findAssociatedTokenPda(umi, {\n    mint: splToken,\n    owner: destinationWallet,\n  });\n\n  //\n  // Transfer SPL Token\n  //\n\n  const res = await transferTokens(umi, {\n    source: sourceTokenAccount,\n    destination: destinationTokenAccount,\n    amount: 10000, // amount of tokens to transfer*\n  }).sendAndConfirm(umi);\n\n  // Finally we can deserialize the signature that we can check on chain.\n  const signature = base58.deserialize(res.signature)[0];\n\n  // Log out the signature and the links to the transaction and the NFT.\n  console.log(\"\\nTransfer Complete\")\n  console.log(\"View Transaction on SolanaFM\");\n  console.log(`https://solana.fm/tx/${signature}?cluster=devnet-alpha`);\n}\n\ntransferSplTokens()\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine Guard Groups in TypeScript\nDESCRIPTION: This code snippet shows how to update existing guard groups for a Candy Machine using the Umi library. It fetches the current candy guard data, then updates the 'late' group to charge 3 SOL instead of 2 SOL while keeping the 'early' group unchanged.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-groups.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\nawait updateCandyGuard(umi, {\n  candyGuard: candyGuard.publicKey,\n  guards: candyGuard.guards,\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(3), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Removing Candy Machine Guards\nDESCRIPTION: Command to remove guards from a Candy Machine, allowing direct minting afterward. Note that this doesn't close the Candy Guard account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/guard.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar guard remove\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Data using TypeScript/UMI\nDESCRIPTION: Updates a Core Collection's metadata including name and URI using the Metaplex UMI SDK. Requires collection address and new metadata values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updateCollection } from '@metaplex-foundation/mpl-core'\n\nconst collectionAddress = publicKey('1111111111111111111111111111111')\n\nawait updateCollection(umi, {\n  collection: collectionAddress,\n  name: 'my-nft',\n  uri: 'https://exmaple.com/new-uri',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Invoking TransferV1Cpi Instruction with Builder Pattern\nDESCRIPTION: Demonstrates using the TransferV1CpiBuilder companion struct for the construction of the instruction, streamlining the creation process through method chaining.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// creates the instruction\nlet cpi_transfer = TransferV1CpiBuilder::new(metadata_program_info)\n    .token(owner_token_info)\n    .token_owner(owner_info)\n    .destination_token(destination_token_info)\n    .destination_owner(destination_info)\n    .mint(mint_info)\n    .metadata(metadata_info)\n    .edition(edition_info)\n    .authority(vault_info)\n    .payer(payer_info)\n    .system_program(system_program_info)\n    .sysvar_instructions(sysvar_instructions_info)\n    .spl_token_program(spl_token_program_info)\n    .spl_ata_program(spl_ata_program_info)\n    .amount(amount);\n\n// performs the CPI\ncpi_transfer.invoke_signed(&[&signer_seeds])\n```\n\n----------------------------------------\n\nTITLE: Fetching a Merkle Tree Account\nDESCRIPTION: This code demonstrates how to fetch a Merkle Tree account using the mpl-bubblegum library. This retrieves various information about the tree such as its header, change logs, sequence number, and canopy data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/create-trees.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchMerkleTree } from '@metaplex-foundation/mpl-bubblegum'\n\nconst merkleTreeAccount = await fetchMerkleTree(umi, merkleTree)\n```\n\n----------------------------------------\n\nTITLE: Accessing Types Module in Metaplex SDK\nDESCRIPTION: This Rust snippet illustrates how to access the types module of the mpl-core crate, which provides essential extra types not covered in the account module structures. This module supports developers in working with various data types required by Metaplex programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmpl_core::types\n```\n\n----------------------------------------\n\nTITLE: Burning NFT Assets with JavaScript Umi\nDESCRIPTION: Demonstrates how to burn a Non-Fungible Token using the Umi JavaScript SDK. Includes support for collection NFTs by passing the collection metadata address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { burnV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait burnV1(umi, {\n  mint,\n  authority: owner,\n  tokenOwner: owner.publicKey,\n  tokenStandard: TokenStandard.NonFungible,\n  // if your NFT is part of a collection you will also need to pass in the collection metadata address.\n  collectionMetadata: findMetadataPda( umi, { mint: collectionMintAddress })\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Oracle Plugin - Rust\nDESCRIPTION: Creates a new MPL Core asset with an Oracle plugin using the mpl_core Rust library. Configures the plugin with Anchor validation results offset and transfer lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::CreateV2Builder,\n    types::{\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent, OracleInitInfo,\n        ValidationResultsOffset\n    },\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_asset_with_oracle_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n\n    let oracle_plugin = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_oracle_plugin_ix = CreateV2Builder::new()\n    .asset(asset.pubkey())\n    .payer(payer.pubkey())\n    .name(\"My Asset\".into())\n    .uri(\"https://example.com/my-asset.json\".into())\n    .external_plugin_adapters(vec![ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\n        base_address: oracle_plugin,\n        init_plugin_authority: None,\n        lifecycle_checks: vec![\n            (\n                HookableLifecycleEvent::Transfer,\n                ExternalCheckResult { flags: 4 },\n            ),\n        ],\n        base_address_config: None,\n        results_offset: Some(ValidationResultsOffset::Anchor),\n    })])\n    .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_oracle_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_oracle_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_oracle_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Transaction with Umi in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a version 0 transaction with a single instruction using Umi's TransactionFactoryInterface.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst transaction = umi.transactions.create({\n  version: 0,\n  blockhash: (await umi.rpc.getLatestBlockhash()).blockhash,\n  instructions: [myInstruction],\n  payer: umi.payer.publicKey,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Edition Guard for MPL Core\nDESCRIPTION: This snippet creates a Candy Machine using hidden settings and the edition guard. It sets up the metadata for Editions and configures the Candy Machine to mint Editions with increasing numbers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// The Name and off chain Metadata of your Editions\nconst editionData = {\n  name: \"Edition Name\",\n  uri: \"https://example.com/edition-asset.json\",\n};\n\n// This creates a hash that editions do not \n// use but the Candy Machine requires  \nconst string = JSON.stringify(editionData);\nconst hash = crypto.createHash(\"sha256\").update(string).digest();\n\nconst candyMachine = generateSigner(umi);\nconst createIx = await create(umi, {\n  candyMachine,\n  collection: collectionSigner.publicKey,\n  collectionUpdateAuthority: umi.identity,\n  itemsAvailable: 100,\n  hiddenSettings: {\n    name: editionData.name,\n    uri: editionData.uri,\n    hash,\n  },\n  guards: {\n    edition: { editionStartOffset: 0 },\n    // ... additional Guards\n  },\n})\n\nawait createIx.sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Cloning Metaplex Next.js Tailwind Shadcn Template\nDESCRIPTION: This shell command clones the Metaplex Next.js Tailwind Shadcn template repository from GitHub. It requires Git to be installed on your local machine. The command downloads the template into the current directory.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/metaplex-nextjs-tailwind-shadcn-template.git\n```\n\n----------------------------------------\n\nTITLE: Data Enum Serialization in TypeScript\nDESCRIPTION: Complex example of data enum serialization with empty, tuple, and struct variants\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ntype Message = \n  | { __kind: 'Quit' } // Empty variant.\n  | { __kind: 'Write'; fields: [string] } // Tuple variant.\n  | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst messageSerializer = dataEnum<Message>([\n  // Empty variant.\n  ['Quit', unit()],\n  // Tuple variant.\n  ['Write', struct<{ fields: [string] }>([\n    ['fields', tuple([string()])]\n  ])],\n  // Struct variant.\n  ['Move', struct<{ x: number; y: number }>([\n    ['x', i32()],\n    ['y', i32()]\n  ])],\n]);\n```\n\n----------------------------------------\n\nTITLE: Executing Reveal Command in Sugar CLI\nDESCRIPTION: The command retrieves all NFTs minted from the Candy Machine, matches them with values in the cache file by NFT number, and updates NFT data. It skips NFTs whose URIs already match the cache file, allowing for selective updates of new or failed NFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/reveal.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar reveal\n```\n\n----------------------------------------\n\nTITLE: Creating NFT Collection with Oracle Plugin in TypeScript\nDESCRIPTION: Creates an NFT collection that implements the Oracle plugin for market hour-based trading restrictions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst collection = generateSigner(umi)\nconsole.log(\"Collection Address: \\n\", collection.publicKey.toString())\n\nconst oracleAccount = publicKey(\"...\")\n\nconst collectionTx = await createCollection(umi, {  \n    collection: collection,\n    name: 'My Collection',\n    uri: 'https://example.com/my-collection.json',\n    plugins: [\n        {\n            type: \"Oracle\",\n            resultsOffset: {\n                type: 'Anchor',\n            },\n            baseAddress: oracleAccount,\n            authority: {\n                type: 'UpdateAuthority',\n            },\n            lifecycleChecks: {\n                transfer: [CheckResult.CAN_REJECT],\n            },\n            baseAddressConfig: undefined,\n        }\n    ]\n}).sendAndConfirm(umi)\n\nlet signature = base58.deserialize(collectinTx.signature)[0];  \nconsole.log(signature);  \n```\n\n----------------------------------------\n\nTITLE: Withdrawing Funds from All Associated Candy Machines\nDESCRIPTION: Command to withdraw funds from all Candy Machines associated with the current keypair.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/withdraw.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar withdraw\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Token Payment Guard in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with a Token Payment guard using Metaplex JavaScript SDK. It configures the guard to charge 300 tokens from a specified mint, sending them to the associated token account of the current identity.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\ncreate(umi, {\n  // ...\n  guards: {\n    tokenPayment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta: findAssociatedTokenPda(umi, {\n        mint: tokenMint.publicKey,\n        owner: umi.identity.publicKey,\n      }),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Payment Guard in JavaScript\nDESCRIPTION: This snippet shows how to mint an NFT with the Token Payment guard using Metaplex JavaScript SDK. It demonstrates providing the required mint settings including the token mint and destination address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    tokenPayment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Registering DAS API with Umi\nDESCRIPTION: Code to register the Digital Asset Standard API library with a Umi instance\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\numi.use(dasApi());\n```\n\n----------------------------------------\n\nTITLE: Remove External Plugin from Collection - TypeScript\nDESCRIPTION: Shows how to remove an external plugin adapter from a collection using the removeCollectionPlugin() function in TypeScript. Requires the Umi framework and MPL Core package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/removing-external-plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { removeCollectionPlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('1111111111111111111111111111111')\nconst oracleAccount = publicKey('2222222222222222222222222222222')\n\nremoveCollectionPlugin(umi, {\n  collection,\n  plugin: {\n    type: 'Oracle',\n    baseAddress: publicKey(oracleAccount),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Bot Tax Guard in JavaScript for Core Candy Machine\nDESCRIPTION: This code snippet demonstrates how to set up a Candy Machine with Bot Tax guard in JavaScript. It configures a small SOL penalty (0.01 SOL) for invalid transactions and enables the lastInstruction setting to ensure mint is the final instruction in the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/bot-tax.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    botTax: some({\n      lamports: sol(0.01),\n      lastInstruction: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Constructing Payload for NFT Transfer in Rust\nDESCRIPTION: Demonstrates how to build a payload HashMap for NFT transfer operations in Token Metadata. The payload includes transfer amount, authority, source, and destination as key-value pairs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/validate.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Transfer Amount\nauth_data\n    .payload\n    .insert(\"Amount\", PayloadType::Number(amount));\n\n// Transfer Authority\nauth_data.payload.insert(\n    \"Authority\",\n    PayloadType::Pubkey(*authority_info.key),\n);\n\n// Transfer Source\nauth_data.payload.insert(\n    \"Source\",\n    PayloadType::Pubkey(*source_info.key),\n);\n\n// Transfer Destination\nauth_data.payload.insert(\n    \"Destination\",\n    PayloadType::Pubkey(*destination_info.key),\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Staking State\nDESCRIPTION: Updates the staking state of an asset if it's not already staked.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nif (isInitialized) {\n    const stakedAttribute = assetAttribute.find(\n        (attr) => attr.key === \"staked\"\n    );\n\n    if (stakedAttribute && stakedAttribute.value !== \"0\") {\n        throw new Error(\"Asset is already staked\");\n    } else {\n        assetAttribute.forEach((attr) => {\n            if (attr.key === \"staked\") {\n                attr.value = currentTime;\n            }\n        });\n    }\n} else {\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Edition Plugin in Rust\nDESCRIPTION: This code snippet shows how to create an MPL Core Asset with the Edition Plugin using Rust. It sets up an RPC client, generates keypairs, and creates an asset with the Edition plugin, specifying the edition number.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::\n    instructions::CreateV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n    let authority = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::Edition(Edition {\n                number: 1,\n            })\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Autograph Plugin to Collection\nDESCRIPTION: Example demonstrating how to add the autograph plugin to a Metaplex Core collection with an initial signature.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/autograph.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCollectionPlugin } from '@metaplex-foundation/mpl-core'\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'Autograph',\n        signatures: [\n      {\n        address: umi.identity.publicKey,\n        message: 'Your Message',\n      },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with Allocation Guard in JavaScript\nDESCRIPTION: Sets up a Candy Machine with an Allocation guard that limits minting to 5 NFTs for guard group with ID 1.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allocation.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    allocation: some({ id: 1, limit: 5 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Metaplex Packages for Token Creation\nDESCRIPTION: Installation of required Metaplex packages for Solana token development, including Umi client, token metadata, and toolbox\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-token-metadata\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-uploader-irys\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-toolbox\n```\n\n----------------------------------------\n\nTITLE: Adding Autograph Plugin to MPL Core Asset\nDESCRIPTION: Example showing how to add the autograph plugin to a Metaplex Core asset with an initial signature and message. Uses the addPlugin function from mpl-core.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/autograph.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'Autograph',\n    signatures: [\n      {\n        address: umi.identity.publicKey,\n        message: 'Your Message',\n      },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Remove External Plugin from Asset - TypeScript\nDESCRIPTION: Demonstrates how to remove an external plugin adapter from an asset using the removePlugin() function in TypeScript. Requires the Umi framework and MPL Core package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/removing-external-plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {publicKey } from '@metaplex-foundation/umi'\nimport { removePlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('1111111111111111111111111111111')\nconst oracleAccount = publicKey('2222222222222222222222222222222')\n\nawait removePlugin(umi, {\n  asset,\n  plugin: {\n    type: 'Oracle',\n    baseAddress: oracleAccount,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up a Candy Machine with NFT Burn Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the NFT Burn guard enabled, specifying the required collection NFT that users must own to be eligible for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftBurn: some({ requiredCollection: requiredCollectionNft.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Clearing Collection on Item as Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code example shows how a Collection Delegate can clear the collection attribute from an item using the updateAsCollectionDelegateV2 function with the 'Clear' option.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsCollectionDelegateV2,\n  collectionToggle,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nawait updateAsCollectionDelegateV2(umi, {\n  mint,\n  delegateMint: collectionMint,\n  authority: collectionDelegate,\n  collection: collectionToggle('Clear'),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Managing Locked Transfer Delegates for Programmable NFTs in TypeScript\nDESCRIPTION: Demonstrates how to work with locked transfer delegates, which can lock a PNFT preventing the owner from transferring, burning, or revoking the delegate until it's unlocked. The delegate can also transfer the PNFT, which revokes the authority and unlocks the token.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateLockedTransferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateLockedTransferV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: lockedTransferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeLockedTransferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeLockedTransferV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: lockedTransferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait transferV1(umi, {\n  mint,\n  authority: lockedTransferDelegate,\n  tokenOwner: currentOwner,\n  destinationOwner: newOwner,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait lockV1(umi, {\n  mint,\n  authority: lockedTransferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unlockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unlockV1(umi, {\n  mint,\n  authority: lockedTransferDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Single NFT Signing by Mint Address\nDESCRIPTION: Signs a specific NFT using its mint address, recommended approach to avoid inefficient getProgramAccounts calls.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/sign.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar sign -m <MINT_ADDRESS>\n```\n\n----------------------------------------\n\nTITLE: Generating Merkle Proof for User Verification in TypeScript\nDESCRIPTION: This snippet demonstrates how to generate a Merkle proof by finding the user's address in the Merkle tree data and extracting the proof with its pairing hashes. This proof will be submitted to the on-chain program for verification.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst index = merkleTreeData.findIndex(data => data.address.equals(newAddress.publicKey));\n\nif (index === -1) {\n  throw new Error(\"Address not found in Merkle tree data\");\n}\n\nconst proof = merkleTree.merkle_proof_index(index);\nconst proofArray = Buffer.from(proof.get_pairing_hashes());\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Asset With Token by Mint\nDESCRIPTION: Helper function to fetch a single Digital Asset With Token using its Mint account public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchDigitalAssetWithTokenByMint } from '@metaplex-foundation/mpl-token-metadata'\n\nconst asset = await fetchDigitalAssetWithTokenByMint(umi, mint)\n```\n\n----------------------------------------\n\nTITLE: Adding Oracle Plugin to Existing Asset - Rust\nDESCRIPTION: Adds an Oracle plugin to an existing MPL Core asset using the mpl_core Rust library. Configures the plugin with Anchor validation results offset and transfer lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddExternalPluginAdapterV1Builder,\n    types::{\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent,\n        OracleInitInfo, ValidationResultsOffset,\n    },\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_oracle_plugin_to_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let oracle_plugin = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let add_oracle_plugin_to_asset_ix = AddExternalPluginAdapterV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .init_info(ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\n            base_address: oracle_plugin,\n            results_offset: Some(ValidationResultsOffset::Anchor),\n            lifecycle_checks: vec![(              \n                HookableLifecycleEvent::Transfer,\n                ExternalCheckResult { flags: 4 },\n            )],\n            base_address_config: None,\n            init_plugin_authority: None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_oracle_plugin_to_asset_tx = Transaction::new_signed_with_payer(\n        &[add_oracle_plugin_to_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_oracle_plugin_to_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Token2022 Payment Guard in JSON\nDESCRIPTION: JSON configuration for Token2022 Payment guard in the config.json file, specifying amount in basis points, mint public key, and destination ATA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token2022-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"token2022Payment\" : {\n    \"amount\": \"number in basis points (e.g. 1000 for 1 Token that has 3 decimals)\",\n    \"mint\": \"<PUBKEY>\",\n    \"destinationAta\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Sol Fixed Fee Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the Sol Fixed Fee guard. It configures the guard with a 1.5 SOL fee and sets the destination to the current identity's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/sol-fixed-fee.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    solFixedFee: some({\n      lamports: sol(1.5),\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Calculating Compute Units for Solana Transactions with Umi\nDESCRIPTION: Function to determine optimal compute unit limits by simulating the transaction and measuring actual usage. Includes a 10% safety buffer and fallback to default values if simulation fails.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/optimal-transactions-with-compute-units-and-priority-fees.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const getRequiredCU = async (\n  umi: Umi,\n  transaction: Transaction // Step 1: pass the transaction\n): Promise<number> => {\n  // Default values if estimation fails\n  const DEFAULT_COMPUTE_UNITS = 800_000; // Standard safe value\n  const BUFFER_FACTOR = 1.1; // Add 10% safety margin\n\n  // Step 2: Simulate the transaction to get actual compute units needed\n  const response = await fetch(umi.rpc.getEndpoint(), {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"simulateTransaction\",\n      params: [\n        base64.deserialize(umi.transactions.serialize(transaction))[0],\n        {\n          encoding: \"base64\",\n          replaceRecentBlockhash: true,\n          sigVerify: false,\n        },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to simulate transaction: ${response.status}`);\n  }\n\n  const data = await response.json();\n  const unitsConsumed = data.result?.value?.unitsConsumed;\n\n  // Fallback to default if simulation doesn't provide compute units\n  if (!unitsConsumed) {\n    console.log(\"Simulation didn't return compute units, using default value\");\n    return DEFAULT_COMPUTE_UNITS;\n  }\n\n  // Add safety buffer to estimated compute units\n  return Math.ceil(unitsConsumed * BUFFER_FACTOR); // Step 3: use the buffer\n};\n\n\n  const withCU = baseTransaction.prepend(\n    setComputeUnitPrice(umi, { microLamports: priorityFee })\n  ).prepend(\n    setComputeUnitLimit(umi, { units: 1400000 })\n  );\n\n  // Step 8: Calculate optimal compute unit limit\n  console.log(\"Estimating required compute units...\");\n  const requiredUnits = await getRequiredCU(umi, withCU.build(umi));\n```\n\n----------------------------------------\n\nTITLE: Installing MPL Core Candy Machine SDK using npm\nDESCRIPTION: Shows how to install the MPL Core Candy Machine SDK using npm. Requires a JavaScript package manager like npm is installed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/sdk/javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @metaplex-foundation/mpl-core-candy-machine\n```\n\n----------------------------------------\n\nTITLE: Adding External Plugin to Core Asset in Rust\nDESCRIPTION: Shows how to add an Oracle plugin to an existing Core Asset using Rust. Includes RPC client setup and transaction building with plugin authority configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\\n    instructions::AddExternalPluginAdapterV1Builder,\\n    types::{\\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent,\\n        OracleInitInfo, ValidationResultsOffset,\\n    },\\n};\\nuse solana_client::nonblocking::rpc_client;\\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\\nuse std::str::FromStr;\\n\\npub async fn add_oracle_plugin_to_asset() {\\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\\n\\n    let authority = Keypair::new();\\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\\n    let oracle_plugin = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\\n\\n    let add_oracle_plugin_to_asset_ix = AddExternalPluginAdapterV1Builder::new()\\n        .asset(asset)\\n        .payer(authority.pubkey())\\n        .init_info(ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\\n            base_address: oracle_plugin,\\n            results_offset: Some(ValidationResultsOffset::Anchor),\\n            lifecycle_checks: vec![(\\n                HookableLifecycleEvent::Transfer,\\n                ExternalCheckResult { flags: 4 },\\n            )],\\n            base_address_config: None,\\n            init_plugin_authority: None,\\n        }))\\n        .instruction();\\n\\n    let signers = vec![&authority];\\n\\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\\n\\n    let add_oracle_plugin_to_asset_tx = Transaction::new_signed_with_payer(\\n        &[add_oracle_plugin_to_asset_ix],\\n        Some(&authority.pubkey()),\\n        &signers,\\n        last_blockhash,\\n    );\\n\\n    let res = rpc_client\\n        .send_and_confirm_transaction(&add_oracle_plugin_to_asset_tx)\\n        .await\\n        .unwrap();\\n\\n    println!(\"Signature: {:?}\", res)\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Allow List Guard for Candy Machine in TypeScript\nDESCRIPTION: This code snippet shows how to set up the Allow List guard on a Candy Machine using the computed Merkle root. It uses the 'create' function from the Umi library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allow-list.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMerkleRoot } from \"@metaplex-foundation/mpl-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\ncreate(umi, {\n  // ...\n  guards: {\n    allowList: some({ merkleRoot: getMerkleRoot(allowList) }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching NFTs by Collection\nDESCRIPTION: RPC call to fetch all compressed NFTs belonging to a specific collection\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcAssetList = await umi.rpc.getAssetsByGroup({\n  groupKey: 'collection',\n  groupValue: collectionMint,\n})\n```\n\n----------------------------------------\n\nTITLE: SOL Payment Guard Configuration\nDESCRIPTION: JSON snippet to add a SOL payment guard to the Candy Machine configuration, allowing users to mint NFTs by paying a specified amount of SOL to a destination address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n\"guards\": {\n    \"default\": {\n        \"solPayment\": {\n            \"value\": 1,\n            \"destination\": \"11111111111111111111111111111111\"\n        }\n    }\n},\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with NFT Mint Limit Guard in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the NFT Mint Limit guard. It sets the guard's ID, limit, and required collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-mint-limit.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftMintLimit: some({\n      id: 1,\n      limit: 5,\n      requiredCollection: requiredCollectionNft.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching a Single Compressed NFT\nDESCRIPTION: RPC call to fetch a single compressed NFT using its asset ID\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcAsset = await umi.rpc.getAsset(assetId)\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Burn Guard in JavaScript\nDESCRIPTION: This snippet illustrates how to mint with the Token Burn guard using JavaScript. It shows how to pass the mint settings, specifically the mint account address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-burn.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    tokenBurn: some({ mint: tokenMint.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Burn Guard in TypeScript\nDESCRIPTION: This code shows how to mint with the Asset Burn guard. It specifies the required collection and the asset to burn as part of the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-burn.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    assetBurn: some({\n      requiredCollection: requiredCollection.publicKey,\n      asset: assetToBurn.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Program and Error Handling Helpers\nDESCRIPTION: Details error handling and program management utilities generated by Kinobi for each defined program. This includes program setup in the repository, handling program errors, and program-specific error retrieval using code or name, adding robust error management support for Solana programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// The program's public key as a constant variable.\nMPL_TOKEN_METADATA_PROGRAM_ID; // -> PublicKey\n\n// Create a program object that can be registered in the program repository.\ncreateMplTokenMetadataProgram(); // -> Program\n\n// Get the program object from the program repository.\ngetMplTokenMetadataProgram(umi); // -> Program\n\n// Get the program's public key from the program repository.\ngetMplTokenMetadataProgramId(umi); // -> PublicKey\n\n// Example of error handling generation.\nexport class UpdateAuthorityIncorrectError extends ProgramError {\n  readonly name: string = 'UpdateAuthorityIncorrect';\n\n  readonly code: number = 0x7; // 7\n\n  constructor(program: Program, cause?: Error) {\n    super('Update Authority given does not match', program, cause);\n  }\n}\n\n// Error retrieval via maps.\ngetMplTokenMetadataErrorFromCode(0x7, program); // -> UpdateAuthorityIncorrectError\ngetMplTokenMetadataErrorFromName('UpdateAuthorityIncorrect', program); // -> UpdateAuthorityIncorrectError\n```\n\n----------------------------------------\n\nTITLE: Fetching Allow List Proof Account to Verify Validation\nDESCRIPTION: This code demonstrates how to check if a wallet has been pre-validated by fetching the Allow List Proof account associated with the Candy Machine, Candy Guard, Merkle root, and user.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  safeFetchAllowListProofFromSeeds,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allowlist = [\n  \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\"\n];\n\nconst allowListProof = await safeFetchAllowListProofFromSeeds(umi, {\n  candyMachine: candyMachine.publicKey,\n  // or candyMachine: publicKey(\"Address\") with your CM Address\n  candyGuard: candyMachine.mintAuthority,\n  // or candyGuard: publicKey(\"Address\") with your candyGuard Address\n  merkleRoot: getMerkleRoot(allowlist),\n  user: umi.identity.publicKey,\n  // or publicKey of the \"minting\" account\n});\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Gate Guard in TypeScript\nDESCRIPTION: Executes minting through a Token Gate guard by providing the mint settings, specifically the token mint public key. This allows the guard to verify the minter has the required token balance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    tokenGate: some({ mint: tokenMint.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Account with Umi\nDESCRIPTION: This snippet demonstrates how to create a new uninitialized account on Solana using Umi. It specifies the account's size and the program that will own it, and manually fetches the rent exemption.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/create-account.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createAccount } from '@metaplex-foundation/mpl-toolbox'\n\nconst newAccount = generateSigner(umi)\nconst space = 42\n\nawait createAccount(umi, {\n  newAccount,\n  payer: umi.payer\n  lamports: await umi.rpc.getRent(space),\n  space,\n  programId: umi.programs.get('myProgramName').publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Thawing and Removing FreezeDelegate Plugin in Metaplex\nDESCRIPTION: Thaws the asset by setting the FreezeDelegate plugin's frozen status to false and then removes the plugin completely, freeing the asset from control by the update authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ntx = await transactionBuilder().add(\n    [...]\n).add(updatePlugin(umi, {\n    asset,\n    collection,\n    plugin: {\n    type: \"FreezeDelegate\",\n    frozen: false,\n    },\n})).add(removePlugin(umi, {\n    asset,\n    collection,\n    plugin: {\n    type: \"FreezeDelegate\",\n    },\n})).buildAndSign(umi);\n```\n\n----------------------------------------\n\nTITLE: Fetch Helper Functions Implementation\nDESCRIPTION: Collection of helper functions for fetching assets with optional plugin derivation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/core-js-sdk-v1-0.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByOwner = await fetchAssetsByOwner(umi, owner, {\n  skipDerivePlugins: false,\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByCollection = await fetchAssetsByCollection(umi, collection, {\n  skipDerivePlugins: false,\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByUpdateAuthority = await fetchAssetsByUpdateAuthority(\n  umi,\n  updateAuthority,\n  { skipDerivePlugins: false }\n)\n```\n\n----------------------------------------\n\nTITLE: Adding mpl-inscription dependency using Cargo\nDESCRIPTION: This command adds the latest version of the `mpl-inscription` crate to your Rust project's dependencies. It allows you to interact with the Token Metadata program using Metaplex's Rust client SDK.  Run this command from the root directory of your Rust project.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/rust.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n\"cargo add mpl-inscription\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection NFT using Token Metadata on Solana\nDESCRIPTION: TypeScript code that creates a traditional non-compressed NFT to serve as a collection for cNFTs. The process includes uploading an image to decentralized storage, creating metadata, and minting the collection NFT using Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n//\n// ** Create Token Metadata Collection NFT **\n//\n\n//\n// If you wish to mint a NFT to a collection you must first create a collection NFT.\n// This step is optional and you can skip it if you do not wish to mint a NFT to a collection\n// or have previously created a collection NFT.\n//\n\nconst collectionSigner = generateSigner(umi)\n\n// Path to image file\nconst collectionImageFile = fs.readFileSync('./collection.png')\n\nconst genericCollectionImageFile = createGenericFile(\n  collectionImageFile,\n  'collection.png'\n)\n\nconst collectionImageUri = await umi.uploader.upload([\n  genericCollectionImageFile,\n])\n\nconst collectionMetadata = {\n  name: 'My cNFT Collection',\n  image: collectionImageUri[0],\n  externalUrl: 'https://www.example.com',\n  properties: {\n    files: [\n      {\n        uri: collectionImageUri[0],\n        type: 'image/png',\n      },\n    ],\n  },\n}\n\nconst collectionMetadataUri = await umi.uploader.uploadJson(collectionMetadata)\n\nawait createNft(umi, {\n  mint: collectionSigner.publicKey,\n  name: 'My cNFT Collection',\n  uri: 'https://www.example.com/collection.json',\n  isCollection: true,\n  sellerFeeBasisPoints: percentAmount(0),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Managing Signers in Umi TypeScript\nDESCRIPTION: Introduces the Signer interface and demonstrates managing signers using various helper methods and plugins. Prerequisites include the Umi interfaces page and EdDSA interface. Inputs comprise Signer objects, with outputs being their modified or verified state.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Signer {\n  publicKey: PublicKey;\n  signMessage(message: Uint8Array): Promise<Uint8Array>;\n  signTransaction(transaction: Transaction): Promise<Transaction>;\n  signAllTransactions(transactions: Transaction[]): Promise<Transaction[]>;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySigner = generateSigner(umi);\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if the provided value is a Signer.\nisSigner(mySigner);\n\n// Deduplicate an array of signers by public key.\nuniqueSigners(mySigners);\n```\n\nLANGUAGE: typescript\nCODE:\n```\numi.use(signerIdentity(mySigner));\n// Is equivalent to:\numi.identity = mySigner;\numi.payer = mySigner;\n\numi.use(signerIdentity(mySigner, false));\n// Is equivalent to:\numi.identity = mySigner;\n\numi.use(signerPayer(mySigner));\n// Is equivalent to:\numi.payer = mySigner;\n```\n\nLANGUAGE: typescript\nCODE:\n```\numi.use(generatedSignerIdentity());\numi.use(generatedSignerPayer());\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySigner = createNoopSigner(myPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Using Redeemed Amount Guard with Groups in JavaScript\nDESCRIPTION: This example demonstrates using the Redeemed Amount guard with Guard Groups in JavaScript to create tiered pricing. The first 300 NFTs can be minted for 1 SOL, while the remaining 200 NFTs will cost 2 SOL.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  itemsAvailable: 500,\n  groups: [\n    {\n      label: \"early\",\n      guards: {\n        redeemedAmount: some({ maximum: 300 }),\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n      },\n    },\n    {\n      label: \"late\",\n      guards: {\n        solPayment: some({ lamports: sol(2), destination: treasury }),\n      },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Searching Assets using JavaScript with UMI\nDESCRIPTION: Uses the @metaplex-foundation/umi libraries to search for assets by owner address and JSON URI. This example demonstrates how to set up the UMI instance with the DAS API plugin and execute a search query.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/search-assets.md#2025-04-17_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst assets = await umi.rpc.searchAssets({\n    owner: publicKey('N4f6zftYsuu4yT7icsjLwh4i6pB1zvvKbseHj2NmSQw'),\n    jsonUri: 'https://arweave.net/c9aGs5fOk7gD4wWnSvmzeqgtfxAGRgtI1jYzvl8-IVs/chiaki-violet-azure-common.json',\n});\nconsole.log(assets.items.length == 1);\n```\n\n----------------------------------------\n\nTITLE: Changing Core Asset Collection with JavaScript\nDESCRIPTION: This snippet demonstrates how to change the collection of a Core Asset using the Metaplex JavaScript SDK. It includes fetching the asset, old collection, and updating the asset with a new collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/update.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from \"@metaplex-foundation/umi\";\nimport {\n  update,\n  fetchAsset,\n  fetchCollection,\n  updateAuthority,\n} from \"@metaplex-foundation/mpl-core\";\n\nconst assetId = publicKey(\"11111111111111111111111111111111\");\nconst asset = await fetchAsset(umi, assetId);\nconst oldCollectionId = publicKey(\"22222222222222222222222222222222\");\nconst collection = await fetchCollection(umi, oldCollectionId);\nconst newCollectionId = publicKey(\"33333333333333333333333333333333\");\n\nconst updateTx = await update(umi, {\n  asset,\n  name: \"Updated Asset\",\n  collection,\n  newUpdateAuthority: updateAuthority(\"Collection\", [newCollectionId]),\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Deriving a PDA in Solana Using Rust\nDESCRIPTION: This snippet demonstrates how to derive a Program Derived Address (PDA) using a specified program ID and seed values. The `derive_pda` function utilizes `Pubkey::find_program_address` to ensure the generated PDA is valid.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/understanding-pdas.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse solana_program::{\n    pubkey::Pubkey,\n    system_instruction,\n    system_program,\n    sysvar::rent::Rent,\n    program::invoke_signed,\n};\n\n// Function to derive a PDA\nfn derive_pda(program_id: &Pubkey, seeds: &[&[u8]]) -> (Pubkey, u8) {\n    Pubkey::find_program_address(seeds, program_id)\n}\n\n// Example usage\nfn example_usage(program_id: &Pubkey) {\n    // Define seeds\n    let seed1 = b\"seed1\";\n    let seed2 = b\"seed2\";\n\n    // Derive PDA\n    let (pda, bump_seed) = derive_pda(program_id, &[seed1, seed2]);\n\n    // Print PDA\n    println!(\"Derived PDA: {}\", pda);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a new PNFT Candy Machine in TypeScript\nDESCRIPTION: Demonstrates how to create a new Candy Machine that mints Programmable NFTs using the create function from the mpl-candy-machine package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/pnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\nimport { create } from '@metaplex-foundation/mpl-candy-machine'\nimport { generateSigner } from '@metaplex-foundation/umi'\n\nawait create(umi, {\n  // ...\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Updating Attribute Plugin\nDESCRIPTION: Updates the attribute plugin with modified or new staking attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntx = await transactionBuilder().add(updatePlugin(umi, {\n    asset,\n    collection,\n    plugin: {\n    type: \"Attributes\",\n        attributeList: assetAttribute,\n    },\n})).add(\n    [...]\n)\n```\n\n----------------------------------------\n\nTITLE: Fetching MPL Core Asset Data with UMI and DAS API in JavaScript\nDESCRIPTION: This code snippet demonstrates how to retrieve MPL Core asset information using the UMI framework and DAS API. It requires specifying an RPC endpoint and the public key of the NFT to fetch. The snippet imports necessary modules, creates a UMI instance with the DAS API plugin, and calls the getAsset method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-asset.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst assetId = publicKey('<PublicKey>');\n\nconst asset = await das.getAsset(umi, assetId);\nconsole.log(asset);\n```\n\n----------------------------------------\n\nTITLE: Converting DAS Assets to Core Assets in JavaScript\nDESCRIPTION: This code demonstrates how to fetch Digital Asset Standard (DAS) Assets using the standard DAS API package, filter for only Core Assets, and then convert them to the AssetV1 type. The conversion process uses the dasAssetsToCoreAssets method from the DAS package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/convert-das-asset-to-core.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// ... standard setup for @metaplex-foundation/digital-asset-standard-api\n\nconst dasAssets = await umi.rpc.getAssetsByOwner({ owner: publicKey('<pubkey>') });\n\n// filter out only core assets\nconst dasCoreAssets = assets.items.filter((a) => a.interface === 'MplCoreAsset')\n\n// convert them to AssetV1 type (actually AssetResult type which will also have the content field populated from DAS)\nconst coreAssets = await das.dasAssetsToCoreAssets(umi, dasCoreAssets)\n```\n\n----------------------------------------\n\nTITLE: Implementing Options and Nullables in TypeScript\nDESCRIPTION: Examples of using option() and nullable() serializers with different configurations including prefix and fixed size options\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n// Options.\noption(publicKey()) // Option<PublicKey> with a u8 prefix.\noption(publicKey(), { prefix: u16() }) // Option<PublicKey> with a u16 prefix.\noption(publicKey(), { fixed: true }) // Option<PublicKey> with a fixed size.\n\n// Nullables.\nnullable(publicKey()) // Nullable<PublicKey> with a u8 prefix.\nnullable(publicKey(), { prefix: u16() }) // Nullable<PublicKey> with a u16 prefix.\nnullable(publicKey(), { fixed: true }) // Nullable<PublicKey> with a fixed size.\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Redeemed NFT Decompression using Bubblegum SDK\nDESCRIPTION: Shows how to cancel the decompression process by adding the leaf back to the Bubblegum tree and closing the Voucher account. This is only possible before the full decompression is completed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/decompress-cnfts.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  findVoucherPda,\n  cancelRedeem,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId)\nawait cancelRedeem(umi, {\n  ...assetWithProof,\n  leafOwner: currentLeafOwner,\n  voucher: findVoucherPda(umi, assetWithProof),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Payment Guard in TypeScript\nDESCRIPTION: This code shows how to mint an NFT when using the Token Payment guard. It passes the required mint settings including the token mint address and destination Associated Token Account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    tokenPayment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Immutable Edition Plugin in Rust\nDESCRIPTION: This snippet shows how to create an MPL Core asset with an immutable Edition Plugin using Rust. It sets the edition number to 1 and prevents future updates by setting the authority to None.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/edition.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{\n    instructions::CreateV1Builder,\n    types::{Creator, Plugin, PluginAuthority, PluginAuthorityPair, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn create_asset_with_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let asset = Keypair::new();\n    let authority = Keypair::new();\n\n    let creator = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_asset_with_plugin_ix = CreateV1Builder::new()\n        .asset(asset.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Nft\".into())\n        .uri(\"https://example.com/my-nft.json\".into())\n        .plugins(vec![PluginAuthorityPair {\n            plugin: Plugin::Edition(Edition {\n                number: 1,\n            }),\n            authority: None,\n        }])\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_asset_with_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_asset_with_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_asset_with_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Core Asset with JavaScript\nDESCRIPTION: This snippet demonstrates how to update a Core Asset's name and URI using the Metaplex JavaScript SDK. It includes fetching the asset and optionally the collection if the asset is part of one.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/update.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { update, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst assetId = publicKey('11111111111111111111111111111111')\nconst asset = await fetchAsset(umi, assetId)\n\n// Optional: If the Asset is in a collection fetch the collection\nconst collectionId = publicKey('2222222222222222222222222222222')\nconst collection = await fetchCollection(umi, collectionId)\n\nawait update(umi, {\n  asset,\n  // Optional: Collection is only required if Asset is part of a collection\n  collection,\n  name: 'New Nft Name',\n  uri: 'https://example.com/new-uri',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Candy Machine with Token Gate Guard in TypeScript\nDESCRIPTION: Creates a Candy Machine with a Token Gate guard configuration. This requires specifying the amount of tokens needed and the token mint public key to restrict minting to holders of that specific token.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    tokenGate: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Asset Mint Limit Guard in Core Candy Machine using JavaScript\nDESCRIPTION: Creates a Candy Machine with Asset Mint Limit guard configured with an ID, a limit of 5 mints per asset, and a required collection reference.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-mint-limit.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetMintLimit: some({\n      id: 1,\n      limit: 5,\n      requiredCollection: requiredCollection.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Approving Collection Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet shows how to approve a Collection Item Delegate using the delegateCollectionItemV1 function. It sets up a delegate that can update the collection attribute of an individual asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateCollectionItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateCollectionItemV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: collectionItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Candy Machine with Start Date Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Core Candy Machine with the Start Date guard. The Start Date guard prevents minting until after the specified date and time.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/start-date.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dateTime } from \"@metaplex-foundation/umi\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    startDate: some({ date: dateTime(\"2022-01-24T15:30:00.000Z\") }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Delegating Freeze Authority\nDESCRIPTION: Shows how to delegate freeze authority to a different address while maintaining ownership. This allows the delegate to freeze and thaw the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { approvePluginAuthority } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\nconst delegateAddress = publicKey('22222222222222222222222222222222')\n\nawait approvePluginAuthority(umi, {\n  asset: asset.publicKey,\n  plugin: { type: 'FreezeDelegate' },\n  newAuthority: { type: 'Address', address: delegateAddress },\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nApprovePluginAuthorityV1CpiBuilder::new(ctx.accounts.mpl_core_program)\n    .asset(ctx.accounts.asset)\n    .collection(Some(ctx.accounts.collection))\n    .authority(Some(ctx.accounts.authority))\n    .payer(ctx.accounts.payer)\n    .plugin_type(PluginType::FreezeDelegate)\n    .new_authority(PluginAuthority::Address { address: ctx.accounts.new_authority.key() })\n    .invoke()?;\n```\n\n----------------------------------------\n\nTITLE: Generic Account Type Definition in TypeScript\nDESCRIPTION: Defines a generic Account type that includes deserialized data along with public key and header information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype Account<T extends object> = T & {\n  publicKey: PublicKey;\n  header: AccountHeader;\n};\n```\n\n----------------------------------------\n\nTITLE: Example Response from DAS API Search\nDESCRIPTION: Sample JSON response from the DAS API searchAssets method, showing the detailed structure of a Core Collection asset. The response includes the asset's public key, metadata, ownership information, and content details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/search-collections.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Manually Managing Candy Guard Associations in TypeScript\nDESCRIPTION: This comprehensive example shows the complete workflow for creating separate Candy Machine and Candy Guard accounts and manually associating or dissociating them when needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/update.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  some,\n  percentAmount,\n  sol,\n  dateTime\n} from '@metaplex-foundation/umi'\nimport {\n  createCandyMachine,\n  createCandyGuard,\n  findCandyGuardPda,\n  wrap,\n  unwrap\n} from '@metaplex-foundation/mpl-core-candy-machine'\n\n// Create a Candy Machine without a Candy Guard.\nconst candyMachine = generateSigner(umi)\nawait createCandyMachine({\n  candyMachine,\n  tokenStandard: TokenStandard.NonFungible,\n  collectionMint: collectionMint.publicKey,\n  collectionUpdateAuthority: umi.identity,\n  itemsAvailable: 100,\n  sellerFeeBasisPoints: percentAmount(1.23),\n  creators: [\n    {\n      address: umi.identity.publicKey,\n      verified: false,\n      percentageShare: 100\n    },\n  ],\n  configLineSettings: some({\n    prefixName: 'My NFT #',\n    nameLength: 3,\n    prefixUri: 'https://example.com/',\n    uriLength: 20,\n    isSequential: false,\n  }),\n}).sendAndConfirm(umi)\n\n// Create a Candy Guard.\nconst base = generateSigner(umi)\nconst candyGuard = findCandyGuardPda(umi, { base: base.publicKey })\nawait createCandyGuard({\n  base,\n  guards: {\n    botTax: { lamports: sol(0.01), lastInstruction: false },\n    solPayment: { lamports: sol(1.5), destination: treasury },\n    startDate: { date: dateTime('2022-10-17T16:00:00Z') },\n  },\n}).sendAndConfirm(umi)\n\n// Associate the Candy Guard with the Candy Machine.\nawait wrap({\n  candyMachine: candyMachine.publicKey,\n  candyGuard,\n}).sendAndConfirm(umi)\n\n// Dissociate them.\nawait unwrap({\n  candyMachine: candyMachine.publicKey,\n  candyGuard,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Displaying All-Product Grid in Markdown\nDESCRIPTION: This snippet renders a grid of all available products in the Metaplex Developer Hub. It uses a custom shortcode or component to generate the product grid.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/404.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% all-product-grid /%}\n```\n\n----------------------------------------\n\nTITLE: Pre-Validating a Wallet for Allow List in TypeScript\nDESCRIPTION: This snippet demonstrates how to pre-validate a wallet for the Allow List guard using the route instruction. It computes the Merkle root and proof for the allow list.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allow-list.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { publicKey } from \"@metaplex-foundation/umi\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nawait route(umi, {\n  // ...\n  guard: \"allowList\",\n  routeArgs: {\n    path: \"proof\",\n    merkleRoot: getMerkleRoot(allowList),\n    merkleProof: getMerkleProof(allowList, publicKey(umi.identity)),\n  },\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Fetching a Core Collection in JavaScript\nDESCRIPTION: This snippet shows how to fetch a Core Collection using the fetchCollection function from the Metaplex Core package in JavaScript. It requires the Umi context and the collection's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchCollection } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchCollection(umi, collection.publicKey, {\n  skipDerivePlugins: false,\n})\n\nconsole.log(asset)\n```\n\n----------------------------------------\n\nTITLE: Checking Collection Update Authority in TypeScript\nDESCRIPTION: This function checks if a given public key holds update authority over a collection. It returns a boolean value based on the provided public key and collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasCollectionUpdateAuthority(\n  pubkey: string | PublicKey,\n  collection: CollectionV1\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Metadata Reroll Path\nDESCRIPTION: Demonstrates how to enable or disable metadata rerolling functionality.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Reroll metadata on swap 0 = true, 1 = false\npath: 0,\n```\n\n----------------------------------------\n\nTITLE: Managing Sale Delegates for Programmable NFTs in TypeScript\nDESCRIPTION: Demonstrates how to approve a sale delegate, revoke it, and perform a delegated transfer using the mpl-token-metadata library. A sale delegate can transfer PNFTs but places the token in a 'Listed' state where the owner cannot transfer or burn it while the delegate is active.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateSaleV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateSaleV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: saleDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeSaleV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeSaleV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: saleDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait transferV1(umi, {\n  mint,\n  authority: saleDelegate,\n  tokenOwner: currentOwner,\n  destinationOwner: newOwner,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Testing Core Asset Creation in TypeScript\nDESCRIPTION: This code demonstrates how to create a test function for Core Asset creation, including setting up arguments and calling the createCoreAsset method with necessary accounts and signers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"Create Asset\", async () => {\n\n  let createAssetArgs = {\n    name: 'My Asset',\n    uri: 'https://example.com/my-asset.json',\n  };\n\n  const createAssetTx = await program.methods.createCoreAsset(createAssetArgs)\n    .accountsPartial({\n      asset: asset.publicKey,\n      collection: null,\n      authority: null,\n      payer: wallet.publicKey,\n      owner: null,\n      updateAuthority: null,\n      systemProgram: SystemProgram.programId,\n      mplCoreProgram: MPL_CORE_PROGRAM_ID\n    })\n    .signers([asset, wallet.payer])\n    .rpc();\n\n  console.log(createAssetTx);\n});\n```\n\n----------------------------------------\n\nTITLE: Converting Transactions from Umi to Web3.js\nDESCRIPTION: TypeScript code demonstrating how to convert both Legacy and Versioned Transactions from Umi format to Web3.js format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox';\nimport { toWeb3JsLegacyTransaction, toWeb3JsTransaction } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new Legacy Transaction\nconst umiTransaction = transferSol(umi, {...TransferParams}).useLegacyVersion();\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsTransaction = toWeb3JsTransaction(umiTransaction);\n\n/// Versioned Transactions ///\n\n// Create a new Versioned Transaction\nconst umiVersionedTransaction = transferSol(umi, {...TransferParams}).useV0().build(umi)\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsVersionedTransaction = toWeb3JsTransaction(umiVersionedTransaction);\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema for Audio NFT in Metaplex Core\nDESCRIPTION: This example demonstrates the JSON schema for an audio NFT in Metaplex Core. It includes an image URL for the cover art and an animation URL pointing to the audio file. The category is set to 'audio' and both files are listed in the properties section.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Audio Asset\",\n    \"image\": \"https://arweave.net/bc5-O7d81hO6F54wFkQHFlCxMQJy9azsWcAL63uYZpg?ext=png\",\n    \"animation_url\": \"https://arweave.net/Ymlb5ONszJKIH405I2ZqgLJec-J5Wf1UjJs4K8LPz5M?ext=wav\",\n    \"description\": \"This is a audio NFT to test how explorers and wallets handle this NFT type. It has an image and the animation url is linked to an MP3. The metadata category is set to audio.\",\n    \"external_url\": \"https://example.com\",\n    \"properties\": {\n        \"files\": [\n            {\n                \"uri\": \"https://arweave.net/bc5-O7d81hO6F54wFkQHFlCxMQJy9azsWcAL63uYZpg?ext=png\",\n                \"type\": \"image/png\"\n            },\n            {\n                \"uri\": \"https://arweave.net/Ymlb5ONszJKIH405I2ZqgLJec-J5Wf1UjJs4K8LPz5M?ext=wav\",\n                \"type\": \"video/wav\"\n            }\n        ],\n        \"category\": \"audio\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Asset Signer PDA in TypeScript\nDESCRIPTION: This snippet demonstrates how to find the Asset Signer PDA for a given asset ID using the findAssetSignerPda function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/execute-asset-signing.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetId = publickey('11111111111111111111111111111111')\n\nconst assetSignerPda = findAssetSignerPda(umi, { asset: assetId })\n```\n\n----------------------------------------\n\nTITLE: Minting Programmable NFT (pNFT)\nDESCRIPTION: Process for minting a programmable NFT with royalty enforcement\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst nftSigner = generateSigner(umi)\n\nconst ruleset = null // or set a publicKey from above\n\nconst tx = await createProgrammableNft(umi, {\n  mint: nftSigner,\n  sellerFeeBasisPoints: percentAmount(5.5),\n  name: 'My NFT',\n  uri: metadataUri,\n  ruleSet: ruleset,\n}).sendAndConfirm(umi)\n\nconsole.log(base58.deserialize(tx.signature)[0])\n```\n\n----------------------------------------\n\nTITLE: Querying Update Authority for Core Asset in JavaScript\nDESCRIPTION: This snippet shows how to fetch a Core Asset and determine its update authority when it's not part of a collection using JavaScript. It uses the @metaplex-foundation/mpl-core library to fetch the asset and display its update authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/what-is-an-asset.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetchAssetV1 } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAssetV1(umi, assetAddress.publicKey)\nconst collectionId = collectionAddress(asset)\n\nconsole.log({collectionId})\nconsole.log({asset})\n\n// log\ncollectionId: undefined\nasset: {\n    key: AssetV1,\n    owner: \"11111111111111111111111111111111\",\n    updateAuthority: {\n      type: 'Address',\n      address: '2222222222222222222222222222222'\n    }\n    name: \"My Core Asset\",\n    uri: \"https://example.com/metadata.json\",\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Address Lookup Table with Initial Addresses in Umi\nDESCRIPTION: This helper method simplifies the process of creating a LUT with initial addresses. It combines the creation of an empty LUT and extending it with given addresses into a single transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLut } from '@metaplex-foundation/mpl-toolbox'\n\nconst recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' })\n\nawait createLut(umi, {\n  authority,\n  recentSlot,\n  addresses: [addressA, addressB],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Revoking Collection Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to revoke a Collection Item Delegate using the revokeCollectionItemV1 function. It removes the delegate's authority to update the collection attribute of an individual asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeCollectionItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeCollectionItemV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: collectionItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi Instance with Inscription Plugin\nDESCRIPTION: This code snippet demonstrates how to create a Umi instance and install the `mplInscription` plugin. It imports the necessary modules and initializes Umi with a specified RPC endpoint, enabling interaction with the Inscription program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/js.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplInscription } from '@metaplex-foundation/mpl-inscription'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://127.0.0.1:8899').use(mplInscription())\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with CPI in Rust\nDESCRIPTION: This Rust code snippet shows how to create an MPL Core Asset using Cross-Program Invocation (CPI). It demonstrates setting up the CreateV1CpiBuilder with various parameters including collection, authority, and plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/create-asset.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet create_ix = CreateV1CpiBuilder::new(input.program)\n    .asset(input.asset.pubkey())\n    .collection(Some(input.collection))\n    .authority(Some(input.authority))\n    .payer(input.payer)\n    .owner(Some(input.owner))\n    .update_authority(Some(input.update_authority))\n    .system_program(system_program::ID)\n    .data_state(input.data_state.unwrap_or(DataState::AccountState))\n    .name(input.name)\n    .uri(input.uri)\n    .plugins(input.plugins)\n    .invoke();\n```\n\n----------------------------------------\n\nTITLE: Minting Compressed NFT to Collection\nDESCRIPTION: Shows how to mint a compressed NFT and associate it with a collection using mintToCollectionV1 instruction. Includes collection authority configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/mint-cnfts.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { none } from '@metaplex-foundation/umi'\nimport { mintToCollectionV1 } from '@metaplex-foundation/mpl-bubblegum'\n\nawait mintToCollectionV1(umi, {\n  leafOwner,\n  merkleTree,\n  collectionMint,\n  metadata: {\n    name: 'My Compressed NFT',\n    uri: 'https://example.com/my-cnft.json',\n    sellerFeeBasisPoints: 500, // 5%\n    collection: { key: collectionMint, verified: false },\n    creators: [\n      { address: umi.identity.publicKey, verified: false, share: 100 },\n    ],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Defining Oracle Adapter Structure in Rust\nDESCRIPTION: This code snippet defines the on-chain structure for the Oracle Adapter. It includes fields for the base address, base address configuration, and results offset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct Oracle {\n    /// The address of the oracle, or if using the `pda` option,\n    /// a program ID from which to derive a PDA.\n    pub base_address: Pubkey,\n    /// Optional account specification (PDA derived from `base_address` or other\n    /// available account specifications).  Note that even when this\n    /// configuration is used there is still only one\n    /// Oracle account specified by the adapter.\n    pub base_address_config: Option<ExtraAccount>,\n    /// Validation results offset in the Oracle account.\n    /// Default is `ValidationResultsOffset::NoOffset`\n    pub results_offset: ValidationResultsOffset,\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching AppData Raw Data in Rust\nDESCRIPTION: This snippet shows how to fetch raw data from an AppData plugin in Rust. It retrieves the plugin based on the authority, calculates data offset and length, and extracts the raw bytes from the account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet plugin_authority = ctx.accounts.authority.key();\n\nlet asset = BaseAssetV1::from_bytes(&data).unwrap();\n\n// Fetches the `AppData` plugin based on the Authority of the plugin.\nlet plugin_key = ExternalPluginAdapterKey::AppData(PluginAuthority::Address {\n    address: plugin_authority });\n\nlet app_data_plugin = fetch_external_plugin_adapter::<BaseAssetV1, AppData>(\n        &account_info,\n        Some(&base_asset),\n        &plugin_key,\n    )\n    .unwrap();\n\nlet (data_offset, data_length) =\n        fetch_external_plugin_adapter_data_info(&account_info, Some(&asset), &plugin_key)\n            .unwrap();\n\n// grab app_data data from account_info\nlet data = account_info.data.borrow()[data_offset..data_offset + data_length].to_vec();\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming a Transaction in Typescript\nDESCRIPTION: This snippet constructs a transaction by adding the `createFungibleIx`, `createTokenIx`, and `mintTokensIx` instructions. It then sends the transaction to the Solana network and confirms it using the `sendAndConfirm` method. Finally, it deserializes the signature from the transaction response and logs the transaction details and token account URL to the console.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n  // The last step is to send the ix's off in a transaction to the chain.\n  // Ix's here can be omitted and added as needed during the transaction chain.\n  // If for example you just want to create the Token without minting\n  // any tokens then you may only want to submit the `createToken` ix.\n\n  console.log(\"Sending transaction\")\n  const tx = await createFungibleIx\n    .add(createTokenIx)\n    .add(mintTokensIx)\n    .sendAndConfirm(umi);\n\n  // finally we can deserialize the signature that we can check on chain.\n  const signature = base58.deserialize(tx.signature)[0];\n\n  // Log out the signature and the links to the transaction and the NFT.\n  // Explorer links are for the devnet chain, you can change the clusters to mainnet.\n  console.log('\\nTransaction Complete')\n  console.log('View Transaction on Solana Explorer')\n  console.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`)\n  console.log('View Token on Solana Explorer')\n  console.log(`https://explorer.solana.com/address/${mintSigner.publicKey}?cluster=devnet`)\n```\n\n----------------------------------------\n\nTITLE: Example Off-Chain Metadata JSON for Core Asset\nDESCRIPTION: This JSON snippet demonstrates the structure of off-chain metadata for a Core Asset. It includes fields for name, description, image, animation URL, external URL, attributes, and file properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/what-is-an-asset.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"SolanaArtProject #1\",\n  \"description\": \"Generative art on Solana.\",\n  \"image\": \"https://arweave.net/26YdhY_eAzv26YdhY1uu9uiA3nmDZYwP8MwZAultcE?ext=jpeg\",\n  \"animation_url\": \"https://arweave.net/ZAultcE_eAzv26YdhY1uu9uiA3nmDZYwP8MwuiA3nm?ext=glb\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://www.arweave.net/abcd5678?ext=png\",\n        \"type\": \"image/png\"\n      },\n      {\n        \"uri\": \"https://watch.videodelivery.net/9876jkl\",\n        \"type\": \"unknown\",\n        \"cdn\": true\n      },\n      {\n        \"uri\": \"https://www.arweave.net/efgh1234?ext=mp4\",\n        \"type\": \"video/mp4\"\n      }\n    ],\n    \"category\": \"video\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding External Plugin to Core Asset in TypeScript\nDESCRIPTION: Demonstrates adding an Oracle plugin to an existing Core Asset using TypeScript and the Umi framework. Configures plugin with lifecycle checks and Anchor results offset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\naddPlugin(umi, {\n  asset,\n  plugin: {\n    type: 'Oracle',\n    resultsOffset: {\n      type: 'Anchor',\n    },\n    lifecycleChecks: {\n      create: [CheckResult.CAN_REJECT],\n    },\n    baseAddress: oracleAccount,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationResultsOffset in JavaScript\nDESCRIPTION: This JavaScript code defines the ValidationResultsOffset type, which is used to specify the location of the OracleValidation struct within the Oracle account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst resultsOffset: ValidationResultsOffset =\n  | { type: 'NoOffset' }\n  | { type: 'Anchor' }\n  | { type: 'Custom'; offset: bigint };\n```\n\n----------------------------------------\n\nTITLE: Calculating Rent Exemption in TypeScript\nDESCRIPTION: This snippet calculates storage fees for account data using the getRent method. It shows handling account header sizes to obtain a precise rent-exemption fee.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst rent = await umi.rpc.getRent(100);\n\nconst rent = await umi.rpc.getRent((ACCOUNT_HEADER_SIZE + 100) * 3, {\n  includesHeaderBytes: true\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching AssetMintCounter Account\nDESCRIPTION: This code snippet demonstrates how to fetch the `AssetMintCounter` account associated with the `AssetMintLimit` guard. It assumes that the Candy Machine data is already available. The `findAssetMintCounterPda` function generates the PDA for the `AssetMintCounter` account, which is then used by `fetchAssetMintCounter` to retrieve the account data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  findAssetMintCounterPda,\n  fetchAssetMintCounter\n } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst pda = findAssetMintCounterPda(umi, {\n  id: 1, // The assetMintLimit id you set in your guard config\n  asset: asset.publicKey, // The address of the core nft your user owns\n  candyGuard: candyMachine.mintAuthority,\n  candyMachine: candyMachine.publicKey,\n});\n\nconst assetMintCounter = fetchAssetMintCounter(umi, pda);\n```\n\n----------------------------------------\n\nTITLE: Configuring NFT Payment Guard in Sugar JSON\nDESCRIPTION: This JSON snippet shows how to configure the NFT Payment guard in the Sugar config.json file. It specifies the required collection and destination public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"nftPayment\" : {\n    \"requiredCollection\": \"<PUBKEY>\",\n    \"destination\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Solana NFT Collection Creation Details\nDESCRIPTION: This snippet shows how to log the details of the created Solana NFT collection, including the transaction signature and links to view the transaction and NFT on Solana and Metaplex explorers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Log out the signature and the links to the transaction and the NFT.\nconsole.log('\\nCollection Created')\nconsole.log('View Transaction on Solana Explorer')\nconsole.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`)\nconsole.log('\\n')\nconsole.log('View Collection on Metaplex Explorer')\nconsole.log(`https://core.metaplex.com/explorer/${collection.publicKey}?env=devnet`)\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata with Token-2022 in Rust\nDESCRIPTION: Creates metadata for a Token-2022 mint account using Rust. Demonstrates building and sending a transaction to create metadata with Token-2022 program specified.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-2022.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::{\n    instructions::CreateV1Builder,\n    types::{PrintSupply, TokenStandard},\n};\nuse solana_rpc_client::rpc_client::RpcClient;\nuse solana_sdk::{\n     message::Message,\n     transaction::Transaction,\n};\n\n// 1. client is a reference to the initialized RpcClient\n// 2. every account is specified by their pubkey\n\nlet client = ...;\n\nlet create_ix = CreateV1Builder::new()\n    .metadata(metadata)\n    .master_edition(Some(master_edition))\n    .mint(mint.pubkey(), true)\n    .authority(payer.pubkey())\n    .payer(payer.pubkey())\n    .update_authority(payer.pubkey(), false)\n    .spl_token_program(spl_token_2022::id())\n    .name(String::from(\"My NFT\"))\n    .uri(uri)\n    .seller_fee_basis_points(550)\n    .token_standard(TokenStandard::NonFungible)\n    .print_supply(PrintSupply::Zero)\n    .instruction();\n\nlet message = Message::new(\n    &[create_ix],\n    Some(&payer.pubkey()),\n);\n\nlet blockhash = client.get_latest_blockhash()?;\nlet mut tx = Transaction::new(&[mint, payer], message, blockhash);\nclient.send_and_confirm_transaction(&tx)?\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Turbo SDK\nDESCRIPTION: Command to install the Turbo SDK package required for Arweave uploads.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @ardrive/turbo-sdk\n```\n\n----------------------------------------\n\nTITLE: Setting up Address Gate Guard in JavaScript for Core Candy Machine\nDESCRIPTION: This code snippet demonstrates how to set up a Core Candy Machine using the Address Gate guard in JavaScript. It uses the 'create' function and specifies the address for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/address-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    addressGate: some({ address: someWallet.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating as Data Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code snippet illustrates how a Data Delegate can update the data object of an asset using the updateAsDataDelegateV2 function. It demonstrates updating the name of the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsDataDelegateV2,\n  fetchMetadataFromSeeds,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst initialMetadata = await fetchMetadataFromSeeds(umi, { mint })\nawait updateAsDataDelegateV2(umi, {\n  mint,\n  authority: dataDelegate,\n  data: { ...initialMetadata, name: 'Updated Name' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Uploading Collection Image with Irys\nDESCRIPTION: Process of uploading collection image to Arweave using Irys uploader with local file system.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport fs from 'fs'\nimport path from 'path'\n\n// Create Umi and tell it to use Irys\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(irysUploader())\n\n// use `fs` to read file via a string path.\n// You will need to understand the concept of pathing from a computing perspective.\nconst imageFile = fs.readFileSync(\n  path.join(__dirname, '..', '/assets/my-image.jpg')\n)\n\n// Use `createGenericFile` to transform the file into a `GenericFile` type\n// that umi can understand. Make sure you set the mimi tag type correctly\n// otherwise Arweave will not know how to display your image.\nconst umiImageFile = createGenericFile(imageFile, 'my-image.jpeg', {\n  tags: [{ name: 'Content-Type', value: 'image/jpeg' }],\n})\n\n// Here we upload the image to Arweave via Irys and we get returned a uri\n// address where the file is located. You can log this out but as the\n// uploader can takes an array of files it also returns an array of uris.\n// To get the uri we want we can call index [0] in the array.\nconst imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n  throw new Error(err)\n})\n\nconsole.log(imageUri[0])\n```\n\n----------------------------------------\n\nTITLE: Creating Plugin Bundles\nDESCRIPTION: Explains creating bundles of plugins that can be installed together in Umi. Demonstrates the `defaultPlugins` bundle which installs a set of common plugins to extend Umi functionality.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const defaultPlugins = (\n  endpoint: string,\n  rpcOptions?: Web3JsRpcOptions\n): UmiPlugin => ({\n  install(umi) {\n    umi.use(dataViewSerializer());\n    umi.use(defaultProgramRepository());\n    umi.use(fetchHttp());\n    umi.use(httpDownloader());\n    umi.use(web3JsEddsa());\n    umi.use(web3JsRpc(endpoint, rpcOptions));\n    umi.use(web3JsTransactionFactory());\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Revoking Authority Item Delegate in JavaScript\nDESCRIPTION: This TypeScript function revokes an existing authority item delegate in the Token Metadata using the `revokeAuthorityItemV1` function from the @metaplex-foundation/mpl-token-metadata library. It can be self-revoked by passing the delegate authority as a signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { revokeAuthorityItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeAuthorityItemV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: authorityItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Mutable Edition Plugin in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an MPL Core asset with a mutable Edition Plugin using TypeScript. It sets the edition number to 1 and allows for future updates.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/edition.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { create } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi)\n\nconst result = create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      type: 'Edition',\n      number: 1\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Freeze Sol Payment Guard in JavaScript\nDESCRIPTION: Code snippet demonstrating how to create a Candy Machine with the Freeze Sol Payment guard using JavaScript. The guard is configured with a price of 1.5 SOL and sets the destination to the user's wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    freezeSolPayment: some({\n      lamports: sol(1.5),\n      destination: umi.identity.publicKey,\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Markdown Tables for Ecosystem Support Status\nDESCRIPTION: Structured tables showing integration status of various platforms and services with Metaplex Core, organized by category including marketplaces, wallets, explorers, RPC providers, no-code tooling, and other services.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/ecosystem-support.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Project                                   | Status   |\n| ----------------------------------------- | -------- |\n| [Tensor](https://www.tensor.trade/)       | Complete |\n| [Magic Eden](https://magiceden.io/solana) | Complete |\n| [Sniper](https://www.sniper.xyz/)         | Complete |\n| [OKX](https://www.okx.com/)               | Complete |\n| [Mallow](https://www.mallow.art/)         | Complete |\n\n| Project                           | Status   |\n| --------------------------------- | -------- |\n| [Solflare](https://solflare.com/) | Complete |\n| [Phantom](https://phantom.app/)   | Complete |\n| [Backpack](https://backpack.app/) | Complete |\n\n| Project                        | Status   |\n| ------------------------------ | -------- |\n| [SolanaFM](https://solana.fm/) | Complete |\n| [Solscan](https://solscan.io/) | Complete |\n\n| Project                                 | Status   |\n| --------------------------------------- | -------- |\n| [ExtrNode](https://extrnode.com/)       | Complete |\n| [Helius](https://www.helius.dev/)       | Complete |\n| [Quicknode](https://www.quicknode.com/) | Complete |\n| [Shyft](https://shyft.to/)              | Complete |\n| [Triton](https://triton.one/)           | Complete |\n\n| Project                                       | Status   |\n| --------------------------------------------- | -------- |\n| [Truffle](https://truffle.wtf)                | Complete |\n| [Underdog](https://www.underdogprotocol.com/) | Complete |\n\n| Project                        | Status   |\n| ------------------------------ | -------- |\n| [dReader](https://dreader.io/) | Complete |\n| [Matrica](https://matrica.io/) | Complete |\n```\n\n----------------------------------------\n\nTITLE: Fetching Total Inscription Count\nDESCRIPTION: Retrieve the total number of Metaplex Inscriptions by iterating through inscription shards and calculating the current inscription count.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/fetch.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchAllInscriptionShard,\n  findInscriptionShardPda,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst shardKeys: Pda[]\nfor (let shardNumber = 0; shardNumber < 32; shardNumber += 1) {\n  shardKeys.push(findInscriptionShardPda(umi, { shardNumber }))\n}\n\nconst shards = await fetchAllInscriptionShard(umi, shardKeys)\nlet numInscriptions = 0\nshards.forEach((shard) => {\n  const rank = 32 * Number(shard.count) + shard.shardNumber\n  numInscriptions = Math.max(numInscriptions, rank)\n})\n\nconsole.log(`Currently there are ${numInscriptions} Metaplex Inscriptions`)\n```\n\n----------------------------------------\n\nTITLE: Implementing Asset Capture in MPL Hybrid (JavaScript)\nDESCRIPTION: This code demonstrates how to perform a Capture operation in MPL Hybrid to swap from fungible tokens to a non-fungible asset. It sets up Umi, defines the necessary accounts, fetches collection assets, and executes the capture transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { generateSigner, signerIdentity, publicKey, sol } from '@metaplex-foundation/umi'\nimport { mplHybrid, MPL_HYBRID_PROGRAM_ID, captureV1 } from '@metaplex-foundation/mpl-hybrid'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport { base58, string, publicKey as publicKeySerializer } from '@metaplex-foundation/umi/serializers'\nimport { fetchAssetsByCollection } from '@metaplex-foundation/mpl-core'\n\n(async () => {\n  /// Step 1: Setup Umi\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplHybrid())\n    .use(mplTokenMetadata())\n\n  let signer = generateSigner(umi);\n\n  umi.use(signerIdentity(signer)).rpc.airdrop(umi.identity.publicKey, sol(1));\n\n  // Step 2: Escrow Accounts - Change these to your needs\n  const collection = publicKey('<YOUR-COLLECTION-ADDRESS>');  // The collection we are swapping to/from\n  const token = publicKey('<YOUR-TOKEN-ADDRESS>');            // The token we are swapping to/from\n  const feeProjectAccount = publicKey('<YOUR-FEE-ADDRESS>');  // The address where the fees will be sent\n  const escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: 'variable' }).serialize('escrow'),\n    publicKeySerializer().serialize(collection),\n  ]);                    \n\n  // Fetch all the assets in the collection\n  const assetsListByCollection = await fetchAssetsByCollection(umi, collection, {\n    skipDerivePlugins: false,\n  })\n\n  // Find the assets owned by the escrow\n  const asset = assetsListByCollection.filter(\n    (a) => a.owner === publicKey(escrow)\n  )[0].publicKey\n\n  /// Step 3: \"Capture\" (Swap from Fungible to Non-Fungible) the Asset\n  const captureTx = await captureV1(umi, {\n    owner: umi.payer,\n    escrow,\n    asset,\n    collection,\n    token,\n    feeProjectAccount,\n  }).sendAndConfirm(umi)\n  const signature = base58.deserialize(captureTx.signature)[0]\n  console.log(`Captured! https://explorer.solana.com/tx/${signature}?cluster=devnet`)})()\n```\n\n----------------------------------------\n\nTITLE: Fetching AllocationTracker Account\nDESCRIPTION: This code snippet demonstrates how to fetch the `AllocationTracker` account associated with the `Allocation` guard. It assumes that the Candy Machine data is already available. The `safeFetchAllocationTrackerFromSeeds` function is used to retrieve the allocation tracker data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  safeFetchAllocationTrackerFromSeeds,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allocationTracker = await safeFetchAllocationTrackerFromSeeds(umi, {\n  id: 1, // The allocation id you set in your guard config\n  candyMachine: candyMachine.publicKey,\n  candyGuard: candyMachine.mintAuthority,\n});\n```\n\n----------------------------------------\n\nTITLE: Update Shared NFT Data\nDESCRIPTION: Demonstrates updating shared NFT data such as seller fee basis points, symbol, and creators. These updates are only possible before the first NFT is minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { percentAmount } from '@metaplex-foundation/umi'\nimport {\n  updateCandyMachine,\n  fetchCandyMachine,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachine = await fetchCandyMachine(umi, candyMachineAddress)\nawait updateCandyMachine(umi, {\n  candyMachine: candyMachine.publicKey,\n  data: {\n    ...candyMachine.data,\n    symbol: 'NEW',\n    sellerFeeBasisPoints: percentAmount(5.5, 2),\n    creators: [{ address: newCreator, verified: false, percentageShare: 100 }],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Update Delegate Plugin to MPL Core Asset in Rust\nDESCRIPTION: This snippet shows how to add an Update Delegate Plugin to an MPL Core Asset using Rust. It imports required crates, sets up RPC client and keypairs, creates the instruction, and sends the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/update-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddPluginV1Builder,\n    types::{Plugin, UpdateDelegate},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_update_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_update_delegate_plugin_ix = AddPluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::UpdateDelegate(UpdateDelegate {}))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_update_delegate_plugin_tx = Transaction::new_signed_with_payer(\n        &[add_update_delegate_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_update_delegate_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Payment Guard in TypeScript\nDESCRIPTION: This code shows how to use the NFT Payment guard when minting. It includes specifying the destination, mint address, and token standard of the NFT used for payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from \"@metaplex-foundation/mpl-token-metadata\";\n\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    nftPayment: some({\n      destination,\n      mint: nftToPayWith.publicKey,\n      tokenStandard: TokenStandard.NonFungible,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching AppData Raw Data in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch the raw data from an AppData plugin in JavaScript. It retrieves an asset by ID, filters for a specific AppData plugin based on authority, and extracts both the data and its schema.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst assetId = publicKey('11111111111111111111111111111111')\nconst dataAuthority = publicKey('33333333333333333333333333333333')\n\nconst asset = await fetchAsset(umi, assetId)\n\nlet appDataPlugin = asset.appDatas?.filter(\n  (appData) => (appData.authority.address = dataAuthority)\n)\n\nlet data\nlet schema\n\n// Check if `AppData` plugin with the given authority exists\nif (appDataPlugin && appDataPlugin.length > 0) {\n  // Save plugin data to `data`\n  data = appDataPlugin[0].data\n\n  // Save plugin schema to `schema`\n  schema = appDataPlugin[0].schema\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Assets to the Escrow using transfer in JavaScript\nDESCRIPTION: This snippet demonstrates how to send an NFT asset to the escrow account. It uses the `@metaplex-foundation/umi` and `@metaplex-foundation/mpl-core` libraries. It loads wallet information, derives the escrow address, and then transfers the specified NFT asset to the escrow account using the `transfer` function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\n\"import { keypairIdentity, publicKey } from \\\"@metaplex-foundation/umi\\\";\nimport {\n  MPL_HYBRID_PROGRAM_ID,\n  mplHybrid,\n} from \\\"@metaplex-foundation/mpl-hybrid\\\";\nimport { readFileSync } from \\\"fs\\\";\nimport { mplTokenMetadata } from \\\"@metaplex-foundation/mpl-token-metadata\\\";\nimport { createUmi } from \\\"@metaplex-foundation/umi-bundle-defaults\\\";\nimport {\n  string,\n  publicKey as publicKeySerializer,\n} from \\\"@metaplex-foundation/umi/serializers\\\";\nimport { transfer } from \\\"@metaplex-foundation/mpl-core\\\";\n\n(async () => {\n  const collection = publicKey(\\\"<COLLECTION>\\\"); // The collection we are swapping to/from\n  const asset = publicKey(\\\"<NFT MINT>\\\"); // Mint Address of the NFT you want to send\n\n  const umi = createUmi(\\\"<ENDPOINT>\\\").use(mplHybrid()).use(mplTokenMetadata());\n\n  const wallet = \\\"<path to wallet>\\\"; // The path to your filesystem Wallet\n  const secretKey = JSON.parse(readFileSync(wallet, \\\"utf-8\\\"));\n\n  // Create a keypair from your private key\n  const keypair = umi.eddsa.createKeypairFromSecretKey(\n    new Uint8Array(secretKey)\n  );\n  umi.use(keypairIdentity(keypair));\n\n  // Derive the Escrow\n  const escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: \\\"variable\\\" }).serialize(\\\"escrow\\\"),\n    publicKeySerializer().serialize(collection),\n  ])[0];\n\n  // Transfer Asset to it\n  const transferAssetTx = await transfer(umi, {\n    asset,\n    collection,\n    newOwner: escrow,\n  }).sendAndConfirm(umi);\n})();\n\"\n```\n\n----------------------------------------\n\nTITLE: JSON Metadata Structure Example\nDESCRIPTION: Example structure of off-chain JSON metadata that follows the Token Metadata standard, including fields for name, description, image, animated URL, and attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/index.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Name\": \"\",\n  \"Description\": \"\",\n  \"Image\": \"\",\n  \"Animated URL\": \"\",\n  \"Attributes\": [],\n  \"...\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing update_tree Instruction in Rust\nDESCRIPTION: Implements the update_tree instruction to allow the authority to update the Merkle root on-chain, including necessary account validations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub fn update_tree(\n  ctx: Context<Update>, \n  new_root: [u8; 32]\n) -> Result<()> {\n\n  ctx.accounts.airdrop_state.merkle_root = new_root;\n\n  Ok(())\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n  #[account(\n    mut, \n    has_one = authority,\n    seeds = [b\"merkle_tree\".as_ref(), airdrop_state.mint.key().to_bytes().as_ref()],\n    bump = airdrop_state.bump\n  )]\n  pub airdrop_state: Account<'info, AirdropState>,\n  pub authority: Signer<'info>,\n}\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Payment Guard in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to mint using the NFT Payment guard. It specifies the destination, mint, and token standard for the NFT payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from \"@metaplex-foundation/mpl-token-metadata\";\n\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    nftPayment: some({\n      destination,\n      mint: nftToPayWith.publicKey,\n      tokenStandard: TokenStandard.NonFungible,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Required Package: Umi\nDESCRIPTION: This snippet shows the command to install the @metaplex-foundation/umi package using npm, which is necessary for interacting with the MPL-Hybrid framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\n----------------------------------------\n\nTITLE: Setting up Freeze Sol Payment Guard in JavaScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the Freeze Sol Payment guard in JavaScript. It specifies the amount in SOL to charge and the destination wallet for payments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    freezeSolPayment: some({\n      lamports: sol(1.5),\n      destination: umi.identity.publicKey,\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Gate Guard in Sugar config.json\nDESCRIPTION: JSON configuration for the Token Gate guard in Sugar, specifying the required token amount in basis points and the mint public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"tokenGate\" : {\n    \"amount\": number in basis points (e.g. 1000 for 1 Token that has 3 decimals),\n    \"mint\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds from Freeze Escrow using JavaScript in Metaplex\nDESCRIPTION: This code snippet demonstrates how to unlock funds from the Freeze Escrow account using the current identity as the Candy Guard authority in a Metaplex Candy Machine implementation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeTokenPayment',\n  routeArgs: {\n    path: 'unlockFunds',\n    destination,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Sending Custom RPC Requests in TypeScript\nDESCRIPTION: Illustrates how to use the call method to send custom RPC requests, accepting a method name and optional parameters to handle endpoint-specific custom methods.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcResult = await umi.rpc.call(\"myCustomMethod\", [myFirstParam, mySecondParam]);\n```\n\n----------------------------------------\n\nTITLE: Adding Freeze Delegate Plugin to Asset\nDESCRIPTION: Demonstrates how to add the Freeze Delegate Plugin to an MPL Core Asset. The plugin is initialized with a boolean frozen state and requires an asset address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\n\nawait addPlugin(umi, {\n  asset: assetAddress,\n  plugin: { type: 'FreezeDelegate', data: { frozen: true } },\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nAddPluginV1CpiBuilder::new(ctx.accounts.mpl_core_program)\n    .asset(ctx.accounts.asset)\n    .collection(Some(ctx.accounts.collection))\n    .authority(Some(ctx.accounts.authority))\n    .payer(ctx.accounts.payer)\n    .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n    .invoke();\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with NFT Gate Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to set up a Candy Machine using the NFT Gate guard. It specifies the required collection NFT address in the guard settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftGate: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Update Candy Machine Mint Authority\nDESCRIPTION: Shows how to update the mint authority of a Candy Machine. This operation requires both the current authority and new mint authority as signers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { setMintAuthority } from '@metaplex-foundation/mpl-candy-machine'\n\nconst newMintAuthority = generateSigner(umi)\nawait setMintAuthority(umi, {\n  candyMachine: candyMachine.publicKey,\n  authority: currentAuthority,\n  mintAuthority: newMintAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Revoking Standard Delegate in TypeScript\nDESCRIPTION: This code snippet shows how to revoke a Standard Delegate for a non-fungible token using the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeStandardV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeStandardV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: standardDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Executing Airdrop using Sugar CLI\nDESCRIPTION: Command to execute an airdrop to multiple wallets using the Sugar CLI airdrop command and a specified Candy Machine address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar airdrop --candy-machine 11111111111111111111111111111111\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets By Owner using DAS API\nDESCRIPTION: This code snippet demonstrates how to fetch assets (tokens and NFTs) owned by a wallet using the Digital Asset Standard (DAS) API. It requires setting up Umi with the DAS API plugin and then calling `getAssetsByOwner` to retrieve the assets.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\n// When defining the umi instance somewhere before you can already\n// add `.use(dasApi());` so there is no need to define umi again.\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst assets = await umi.rpc.getAssetsByOwner({\n    umi.identity.publicKey\n});\n\n```\n\n----------------------------------------\n\nTITLE: Adding Burn Delegate Plugin to MPL Core Asset in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a Burn Delegate Plugin to an MPL Core Asset using TypeScript. It imports necessary functions and types, defines the asset public key, and sends a transaction to add the plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/burn-delegate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait addPlugin(umi, {\n  asset: asset,\n  plugin: { type: 'BurnDelegate' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting Primary Sale Status\nDESCRIPTION: Code showing how to update the primary sale status of an asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nprimarySaleHappened: true\n```\n\nLANGUAGE: rust\nCODE:\n```\nprimary_sale_happened: Option<bool>,\n```\n\n----------------------------------------\n\nTITLE: Validating Asset Burn in TypeScript\nDESCRIPTION: This function checks if a given authority can burn an asset. It returns a boolean value based on the provided umi, authority, asset, and collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport async function validateBurn(umi, { authority, asset, collection })\n```\n\n----------------------------------------\n\nTITLE: Defining and Creating Public Keys in TypeScript\nDESCRIPTION: Defines TypeScript types for public keys and demonstrates creating new valid public keys using various inputs. Dependencies include the EdDSA interface and Umi typedoc library. Inputs are base58 strings, 32-byte buffers, or existing PublicKey/Signer types with outputs being validated public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// In short:\ntype PublicKey = string;\n\n// In reality:\ntype PublicKey<TAddress extends string = string> = TAddress & { __publicKey: unique symbol };\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// From a base58 string.\npublicKey('LorisCg1FTs89a32VSrFskYDgiRbNQzct1WxyZb7nuA');\n\n// From a 32-byte buffer.\npublicKey(new Uint8Array(32));\n\n// From a PublicKey or Signer type.\npublicKey(someWallet as PublicKey | Signer);\n```\n\nLANGUAGE: typescript\nCODE:\n```\npublicKeyBytes(myPublicKey);\n// -> Uint8Array(32)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if the provided value is a valid public key.\nisPublicKey(myPublicKey);\n\n// Assert the provided value is a valid public key and fail otherwise.\nassertPublicKey(myPublicKey);\n\n// Deduplicate an array of public keys.\nuniquePublicKeys(myPublicKeys);\n\n// Create the default public key which is a 32-bytes array of zeros.\ndefaultPublicKey();\n```\n\n----------------------------------------\n\nTITLE: Importing Adapters from umi-web3js-adapters\nDESCRIPTION: TypeScript code snippet showing the import of various adapter functions from the umi-web3js-adapters package for converting between Umi and Web3.js types.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { \n  // Keypairs\n  fromWeb3JsKeypair, toWeb3JsKeypair,\n  // Publickey\n  fromWeb3JsPublicKey, toWeb3JsPublicKey,\n  // Instructions\n  fromWeb3JsInstruction, toWeb3JsInstruction,\n  // Legacy Transactions\n  fromWeb3JsLegacyTransaction, toWeb3JsLegacyTransaction,\n  // Versioned Transactions\n  fromWeb3JsTransaction, toWeb3JsTransaction, \n  // Messages\n  fromWeb3JsMessage, toWeb3JsMessage, toWeb3JsMessageFromInput\n} from '@metaplex-foundation/umi-web3js-adapters';\n```\n\n----------------------------------------\n\nTITLE: Adding Freeze Plugin to Core Asset in JavaScript\nDESCRIPTION: This code adds a Freeze Delegate plugin to a Core Asset, assigns it to a delegated authority, and sets the initial frozen state. It demonstrates Core's plugin system for managing asset features.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/tm-differences.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: createPlugin('FreezeDelegate', { frozen: true }),\n  initAuthority: pluginAuthority('Address', { address: delegate.publicKey }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching a Single Asset in Rust\nDESCRIPTION: This code fetches a single NFT asset using Rust. It uses the Solana RPC client to get account data for a specific asset ID and then deserializes it into an Asset struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::Asset;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::pubkey::Pubkey;\n\npub async fn fetch_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let asset_id = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client.get_account_data(&asset_id).await.unwrap();\n\n    let asset = Asset::from_bytes(&rpc_data).unwrap();\n\n    print!(\"{:?}\", asset)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Compute Unit Price (Priority Fees) in Umi Transactions\nDESCRIPTION: This snippet shows how to set a custom price per Compute Unit for a transaction using the setComputeUnitPrice function from the mpl-toolbox package. It sets the price to 1 micro-lamport per Compute Unit.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/priority-fees-and-compute-managment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transactionBuilder } from '@metaplex-foundation/umi'\nimport { setComputeUnitPrice } from '@metaplex-foundation/mpl-toolbox'\n\nawait transactionBuilder()\n  .add(setComputeUnitPrice(umi, { microLamports: 1 })) // Set the price per Compute Unit in micro-lamports.\n  .add(...) // Any instruction(s) here.\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Candy Machine with Program Gate Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Core Candy Machine with the Program Gate guard. It allows specifying additional program addresses that are permitted to include instructions in the mint transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/program-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    programGate: some({ additional: [<PUBKEY 1>, <PUBKEY 2>, ..., <PUBKEY 5>] }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Collection Delegate PDA in Rust\nDESCRIPTION: Generates a Program Derived Address (PDA) for collection-level authority delegation using specific seeds.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/loyalty-card-concept-guide.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet seeds = &[b\"collection_delegate\"];\nlet (collection_delegate, bump) = Pubkey::find_program_address(seeds, &program_id);\n```\n\n----------------------------------------\n\nTITLE: Converting Transaction Signature from Uint8Array to Base58 String\nDESCRIPTION: Shows how to convert a transaction signature from Uint8Array format to a human-readable base58 string, useful for displaying in explorers or for user interfaces.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n// example to receive a sent transaction signature\nconst { signature } = await builder.send(umi)\n\n// Deserializing it\nconst serializedSignature = base58.deserialize(signature)[0];\nconsole.log(\n        `View Transaction on Explorer: https://explorer.solana.com/tx/${serializedSignature}`\n      );\n```\n\n----------------------------------------\n\nTITLE: Initializing Inscriptions from NFT Mint in JavaScript\nDESCRIPTION: This snippet shows how to initialize a tradable inscription derived from an NFT using the Metaplex framework in JavaScript. This requires you to be the update authority of the NFT. Dependencies include '@metaplex-foundation/mpl-inscription' and `umi`, the environment object. Key parameters are `mintAccount` and `inscriptionShardAccount`. The function outputs an initialized inscription shard, assumed to be confirmed and sent within Metaplex.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/initialize.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  findInscriptionShardPda,\n  initializeFromMint,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionShardAccount = await findInscriptionShardPda(umi, {\n  shardNumber: 0, //random number between 0 and 31\n})\nawait initializeFromMint(umi, {\n  mintAccount: mint.publicKey,\n  inscriptionShardAccount,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Oracle Plugin to Collection using JavaScript and Umi\nDESCRIPTION: This snippet demonstrates how to add an Oracle plugin to a collection using the Metaplex Foundation's Umi library in TypeScript. It configures the plugin with specific parameters such as collection and oracle account public keys, result offset type, and lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addCollectionPlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('11111111111111111111111111111111')\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\nawait addCollectionPlugin(umi, {\n  collection: collection,\n  plugin: {\n    type: 'Oracle',\n    resultsOffset: {\n      type: 'Anchor',\n    },\n    lifecycleChecks: {\n      update: [CheckResult.CAN_REJECT],\n    },\n    baseAddress: oracleAccount,\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Funding MPL-Hybrid Escrow using TypeScript\nDESCRIPTION: This snippet provides code for funding an MPL-Hybrid escrow by transferring tokens using umi, ensuring that the escrow is sufficiently backed. It utilizes the @metaplex-foundation tags for token metadata and involves setting up a keypair and specifying transfer parameters. Inputs include the TOKEN address, the token owner's publicKey, and the destination (ESCROW). The snippet expects the transfer to complete and return the transaction signature upon success.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/escrow.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\nimport { keypairIdentity, publicKey, createSignerFromKeypair } from '@metaplex-foundation/umi'\n\n... (SEE ABOVE CODE)\n\n// THIS IS USING A LOCAL KEYPAIR\nconst parsed_wallet = JSON.parse(fs.readFileSync('< PATH TO KEYPAIR >', 'utf-8'))\nconst kp_wallet = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(parsed_wallet))\nconst token_owner = createSignerFromKeypair(umi, kp_wallet)\n\nconst TOKEN_TRANSFER_AMOUNT = 10000\nconst TOKEN_DECIMALS = 9\n\nconst transferData = {\n  mint: TOKEN,\n  amount: addZeros(TOKEN_TRANSFER_AMOUNT, TOKEN_DECIMALS),\n  authority: token_owner,\n  tokenOwner: kp_wallet.publicKey,\n  destinationOwner: ESCROW,\n  tokenStandard: TokenStandard.NonFungible,\n}\n\nconst transferIx = await transferV1(umi, transferData).sendAndConfirm(umi)\n\nconsole.log(bs58.encode(transferIx.signature))\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Associated Token Account in Solana using Umi\nDESCRIPTION: This snippet demonstrates how to create an Associated Token Account using Umi. It creates a deterministic Token account derived from the owner's and mint's public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAssociatedToken } from '@metaplex-foundation/mpl-toolbox'\n\nawait createAssociatedToken(umi, { mint, owner }).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Gatekeeper Guard in JavaScript\nDESCRIPTION: This code shows how to pass the required mint settings when minting with a Candy Machine that uses the Gatekeeper guard. It specifies the Gatekeeper Network and expireOnUse parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/gatekeeper.md#2025-04-17_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    gatekeeper: some({\n      network: publicKey(\"ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6\"),\n      expireOnUse: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Core Candy Machine with Hidden Settings in TypeScript\nDESCRIPTION: Illustrates the process of creating a Core Candy Machine with hidden settings, including generating a hash for reveal data and configuring the Candy Machine properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create } from '@metaplex-foundation/mpl-core-candy-machine'\nimport crypto from \"crypto\";\n\nconst candyMachine = generateSigner(umi)\n\nconst revealData = [\n  { name: 'Nft #1', uri: 'http://example.com/1.json' },\n  { name: 'Nft #2', uri: 'http://example.com/2.json' },\n  { name: 'Nft #3', uri: 'http://example.com/3.json' },\n]\n\nconst string = JSON.stringify(revealData)\nconst hash = crypto.createHash('sha256').update(string).digest()\n\nconst createIx = await create(umi, {\n  candyMachine,\n  collectionMint: collectionMint.publicKey,\n  collectionUpdateAuthority,\n  sellerFeeBasisPoints: percentAmount(10),\n  itemsAvailable: 5000,\n  hiddenSettings: {\n    name: \"Hidden Asset\",\n    uri: \"https://example.com/hidden-asset.json\",\n    hash,\n  }\n})\n\nawait createIx.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Authority Configuration in TypeScript\nDESCRIPTION: Demonstrates the authority field configuration which sets the wallet/publicKey as authority over the Core Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nauthority: string\n```\n\n----------------------------------------\n\nTITLE: Adding Verified Creators Plugin to MPL Core Collection\nDESCRIPTION: This code example shows how to add the Verified Creators Plugin to an MPL Core Collection. It assumes that umi.identity is the update authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addCollectionPlugin } from '@metaplex-foundation/mpl-core'\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n        signatures: [\n      {\n        address: umi.identity.publicKey,\n        verified: true,\n      },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Mint Limit Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to mint an NFT with the Mint Limit guard using TypeScript. It provides the required ID in the mintArgs parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/mint-limit.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    mintLimit: some({ id: 1 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping Preflight with Solana Web3.js\nDESCRIPTION: Demonstrates how to use the skipPreflight option with Solana Web3.js when sending transactions. Creates a Connection object, builds a transaction, and sends it with preflight checking disabled to register failing transactions on-chain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/how-to-diagnose-solana-transaction-errors.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Create Connection\nconst connection = new Connection(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\", \"confirmed\",);\n\n// Create your transaction\nconst transaction = new VersionedTransaction()\n\n// Add skipPreflight to the sendTransaction() function\nconst res = await connection.sendTransaction(transaction, [...signers], {skipPreflight: true})\n\n// Log out the transaction signature\nconsole.log(res)\n```\n\n----------------------------------------\n\nTITLE: Defining Escrow Settings in JavaScript\nDESCRIPTION: This snippet defines the general settings for the escrow contract, including the name, URI, maximum and minimum values, and path.  These parameters are used during the escrow initialization process.  The path parameter determines whether NFT metadata is updated on swap.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n\"// Escrow Settings - Change these to your needs\nconst name = \\\"MPL-404 Hybrid Escrow\\\";                       \nconst uri = \\\"https://arweave.net/manifestId\\\";               \nconst max = 15;                                             \nconst min = 0;                                              \nconst path = 0;                                             \"\n```\n\n----------------------------------------\n\nTITLE: Fetching Escrow Configuration Using TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `fetchEscrowV1` function to retrieve an escrow configuration account using a public key. The required prerequisite is the availability of the `umi` instance and the specific escrow address to fetch. The expected output is the escrow configuration object containing various details such as publicKey, header information, collection, authority, and fee details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/fetch-escrow.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst escrowAddress = publicKey('11111111111111111111111111111111')\n\nconst escrow = await fetchEscrowV1(umi, escrowAddress)\n```\n\n----------------------------------------\n\nTITLE: Fetching Asset Data for Unstaking in Metaplex\nDESCRIPTION: Retrieves the asset information using the fetchAsset function before proceeding with unstaking operations. This is necessary to check the current state of the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchedAsset = await fetchAsset(umi, asset);\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Freeze Token Payment guard in JavaScript/TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the Freeze Token Payment guard configured. It sets the payment amount, token mint, and destination associated token account using Umi's identity as the destination wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    freezeTokenPayment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta: findAssociatedTokenPda(umi, {\n        mint: tokenMint.publicKey,\n        owner: umi.identity.publicKey,\n      }),\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minting to a Single Recipient with Sugar CLI\nDESCRIPTION: Command to mint 3 NFTs to a specific wallet address using the Sugar CLI. The --receiver parameter specifies the recipient wallet and -n specifies the number of NFTs to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsugar mint --receiver Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV -n 3 --candy-machine 11111111111111111111111111111111\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Accounts with Umi\nDESCRIPTION: Shows how to fetch multiple accounts simultaneously using getAccounts method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAccounts = await umi.rpc.getAccounts(myPublicKeys);\n```\n\n----------------------------------------\n\nTITLE: Performing CPI with MPL-Core Rust SDK\nDESCRIPTION: Example of using CreateV1CpiBuilder for Cross Program Invocation. This demonstrates how to set up a CPI instruction to create an asset from within another Solana program using the MPL-Core SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/sdk/rust.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1CpiBuilder::new()\n        .asset(context.accounts.asset)\n        .collection(context.accounts.collection)\n        .authority(context.accounts.authority)\n        .payer(context.accounts.payer)\n        .owner(context.accounts.owner)\n        .update_authority(context.accounts.update_authority)\n        .system_program(context.acccounts.system_program)\n        .data_state(input.data_state.unwrap_or(DataState::AccountState))\n        .name(args.asset_name)\n        .uri(args.asset_uri)\n        .plugins(args.plugins)\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Updating Asset Permanent Freeze Plugin - TypeScript\nDESCRIPTION: Updates the freeze state of an existing asset's permanent freeze delegate plugin. Requires the signing wallet to be the plugin authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/permanent-freeze-delegate.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updatePlugin } from '@metaplex-foundation/mpl-core'\n\nconst updateAssetResponse = await updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: \"PermanentFreezeDelegate\",\n    frozen: false,\n  },\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Configuring Amman Validator for Bubblegum Program\nDESCRIPTION: Configuration setup for testing and working with Metaplex Bubblegum. Includes necessary program accounts like Token Metadata, Token Auth Rules, and SPL programs. Sets up validator, relay, and storage configurations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/pre-made-configs.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\nconst { LOCALHOST, tmpLedgerDir } = require(\"@metaplex-foundation/amman\");\n\nmodule.exports = {\n  validator: {\n    killRunningValidators: true,\n    accountsCluster: \"https://api.metaplex.solana.com\",\n    accounts: [\n       {\n        label: \"Bubblegum\",\n        accountId: \"BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY\",\n        executable: true,\n      },\n      {\n        label: \"Token Metadata Program\",\n        accountId: \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\",\n        executable: true,\n      },\n      {\n        label: \"Token Auth Rules\",\n        accountId: \"auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg\",\n        executable: true,\n      },\n      {\n        label: \"Spl ATA Program\",\n        accountId: \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\",\n        executable: true,\n      },\n      {\n        label: \"SPL Token Program\",\n        accountId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\",\n        executable: true,\n      },\n      {\n        label: \"SPL Account Compression\",\n        accountId: \"cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK\",\n        executable: true\n      },\n      {\n        label: \"SPL Noop Program\",\n        accountId: \"noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV\",\n        executable: true\n      },\n\n    ],\n    jsonRpcUrl: LOCALHOST,\n    websocketUrl: \"\",\n    commitment: \"confirmed\",\n    ledgerDir: tmpLedgerDir(),\n    resetLedger: true,\n    verifyFees: false,\n    detached: process.env.CI != null,\n  },\n  relay: {\n    enabled: process.env.CI == null,\n    killRunningRelay: true,\n  },\n  storage: {\n    enabled: process.env.CI == null,\n    storageId: \"mock-storage\",\n    clearOnStart: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Verifying Collection on Item as Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet demonstrates how a Collection Delegate can verify a collection on an item using the verifyCollectionV1 function. It sets the verified status of the collection for the specified NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  verifyCollectionV1,\n  findMetadataPda,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nawait verifyCollectionV1(umi, {\n  metadata: findMetadataPda(umi, { mint }),\n  collectionMint,\n  authority: collectionDelegate,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Collection with Plugins using CreateCollectionV2CpiBuilder in Rust\nDESCRIPTION: This snippet shows how to use the CreateCollectionV2CpiBuilder to create a collection with plugins and external plugin adapters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nCreateCollectionV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n  .collection(&ctx.accounts.collection.to_account_info())\n  .payer(&ctx.accounts.payer.to_account_info())\n  .update_authority(update_authority.as_ref())\n  .system_program(&ctx.accounts.system_program.to_account_info())\n  .name(args.name)\n  .uri(args.uri)\n  .plugins(plugins)\n  .external_plugin_adapters(external_plugin_adapters)    \n  .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Installing Gumdrop CLI from GitHub Repository\nDESCRIPTION: Commands to clone the Gumdrop repository and install its dependencies using yarn. This is required to use the Gumdrop CLI for creating and managing token airdrops.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/spl-token-claim-airdrop-using-gumdrop.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/gumdrop\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Setting Up Mint Limit Guard in Core Candy Machine TypeScript\nDESCRIPTION: The code snippet provides an example of how to set up a Core Candy Machine with a Mint Limit guard in TypeScript. The `create` function is used to configure guards, specifying the mint limit id and the maximum number of mints allowed per wallet. This setup requires the Metaplex TypeScript SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/mint-limit.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    mintLimit: some({ id: 1, limit: 5 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Owner in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch multiple NFT assets owned by a specific address using the fetchAssetsByOwner function from the Metaplex Core package in JavaScript.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { fetchAssetsByOwner } from '@metaplex-foundation/mpl-core'\n\nconst owner = publicKey('11111111111111111111111111111111')\n\nconst assetsByOwner = await fetchAssetsByOwner(umi, owner, {\n  skipDerivePlugins: false,\n})\n\nconsole.log(assetsByOwner)\n```\n\n----------------------------------------\n\nTITLE: Defining Creators Array in Rust for Royalties Plugin\nDESCRIPTION: This snippet shows how to create a vector of creators for the Royalties Plugin using Rust. It defines two creators with their respective public keys and percentage shares.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::Creator;\nuse solana_sdk::pubkey::Pubkey\nuse std::str::FromStr;\n\nlet creators = vec![\n        Creator {\n            address: Pubkey::from_str(\"11111111111111111111111111111111\").unwrap(),\n            percentage: 80,\n        },\n        Creator {\n            address: Pubkey::from_str(\"22222222222222222222222222222222\").unwrap(),\n            percentage: 20,\n        }\n    ];\n```\n\n----------------------------------------\n\nTITLE: Minting with Third Party Signer Guard in TypeScript\nDESCRIPTION: This code snippet shows how to mint an NFT when the Third Party Signer guard is active. The transaction must include the specified signer, and that signer must also sign the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/third-party-signer.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signer: myConfiguredSigner }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Plugin Lifecycle Validation Table - Burn\nDESCRIPTION: Table showing plugin validation rules for asset burn lifecycle event\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/index.md#2025-04-17_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Plugin                    | Action      | Conditions  |\n| ------------------------- | ----------- | ----------- |\n| Freeze Delegate           | Can Reject  | isFrozen    |\n| Burn Delegate             | Can Reject  | isAuthority |\n| Permanent Freeze Delegate | Can Reject  | isFrozen    |\n| Permanent Burn Delegate   | Can Approve | isAuthority |\n```\n\n----------------------------------------\n\nTITLE: Skipping Preflight with Umi's sendAndConfirm Method\nDESCRIPTION: Demonstrates how to use the skipPreflight option with Metaplex Umi's sendAndConfirm() function to force a failed transaction to be registered on-chain for debugging purposes. It also shows how to convert and log the transaction signature.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/how-to-diagnose-solana-transaction-errors.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst tx = createV1(umi, {\n    ...args\n}).sendAndConfirm(umi, {send: { skipPreflight: true}})\n\n// Convert signature to string\nconst signature = base58.deserialize(tx.signature);\n\n// Log transaction signature\nconsole.log(signature)\n```\n\n----------------------------------------\n\nTITLE: Adding Required Dependencies\nDESCRIPTION: Command to add mpl-core crate with Anchor features enabled\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo add mpl-core --features anchor\n```\n\n----------------------------------------\n\nTITLE: Setting and Verifying Collection for Compressed NFT using TypeScript\nDESCRIPTION: Demonstrates how to both set and verify a collection in one operation for a Compressed NFT using setAndVerifyCollection from mpl-bubblegum. Requires tree creator or delegate authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/verify-collections.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  setAndVerifyCollection,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait setAndVerifyCollection(umi, {\n  ...assetWithProof,\n  treeCreatorOrDelegate,\n  collectionMint,\n  collectionAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding AppData Plugin to Asset\nDESCRIPTION: Implementation examples for adding the AppData plugin to an MPL Core Asset in both TypeScript and Rust\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin, ExternalPluginAdapterSchema } from '@metaplex-foundation/mpl-core'\n\nconst assetSigner = generateSigner(umi);\nconst dataAuthority = publicKey('11111111111111111111111111111111')\n\nawait create(umi, {\n  asset: asset.publicKey,\n  name: \"My Asset\",\n  uri: \"https://example.com/my-assets.json\"\n  plugins: [\n        {\n            type: 'AppData',\n            dataAuthority,\n            schema: ExternalPluginAdapterSchema.Json,\n        },\n    ],\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddExternalPluginAdapterV1Builder,\n    types::{Attribute, Attributes, Plugin,\n    ExternalPluginAdapterInitInfo, AppDataInitInfo,\n    PluginAuthority},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_app_data_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_external_plugin_app_data_ix = AddExternalPluginAdapterV1Builder::new()\n        .asset(asset)\n        .payer(authority.publicKey())\n        .init_info(ExternalPluginAdapterInitInfo::AppData(AppDataInitInfo {\n            init_plugin_authority: Some(PluginAuthority::UpdateAuthority),\n            data_authority: PluginAuthority::Address {address: app_data_authority.key()},\n            schema: None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_data_plugin_tx = Transaction::new_signed_with_payer(\n        &[add_external_plugin_app_data_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_data_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic NFT Minting with Sugar CLI\nDESCRIPTION: Basic command to mint NFTs using the default cache.json file from a Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/mint.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint\n```\n\n----------------------------------------\n\nTITLE: Approving Collection Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet demonstrates how to approve a Collection Delegate using the delegateCollectionV1 function from the mpl-token-metadata package. It sets up a delegate that can update the collection attribute and perform actions on items within the collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateCollectionV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateCollectionV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: collectionDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Allow List Guard in JavaScript\nDESCRIPTION: This code shows how to create a Candy Machine with the Allow List guard enabled, using the computed Merkle root from a list of allowed wallet addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getMerkleRoot } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\ncreate(umi, {\n  // ...\n  guards: {\n    allowList: some({ merkleRoot: getMerkleRoot(allowList) }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Burning NFT Assets with Rust MPL SDK\nDESCRIPTION: Shows how to burn an NFT using the Rust MPL SDK via CPI (Cross-Program Invocation). Handles metadata, collection, and token account management.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n\n BurnNftCpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    // if your NFT is part of a collection you will need to pass in the collection metadata address.\n    .collection_metadata(collection_metadata.as_ref())\n    .owner(&owner)\n    .mint(&mint)\n    .token_account(&token)\n    .master_edition_account(&edition)\n    .spl_token_program(&spl_token)\n    .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Unlocking NFT Asset with Token Metadata\nDESCRIPTION: Shows how to unlock a standard NFT asset using the Token Metadata program's unlockV1 instruction. Uses the same parameters as the lock instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/lock.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unlockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unlockV1(umi, {\n  mint,\n  authority,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Solana Cluster and Fetching Balance\nDESCRIPTION: This snippet demonstrates how to connect to the Solana mainnet-beta cluster using the @solana/web3.js library. It includes an asynchronous function to fetch and display the balance of a specified account based on its public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rpcs-and-das.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst solanaWeb3 = require('@solana/web3.js');\n\n// Connect to the Solana cluster\nconst connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('mainnet-beta'), 'confirmed');\n\n// Fetch the balance of an account\nasync function getBalance(publicKey) {\n  const balance = await connection.getBalance(publicKey);\n  console.log(`Balance: ${balance} lamports`);\n}\n\n// Example public key\nconst publicKey = new solanaWeb3.PublicKey('ExamplePublicKeyHere');\n\n// Get balance\ngetBalance(publicKey);\n```\n\n----------------------------------------\n\nTITLE: TransferV1CpiBuilder new() function in Rust\nDESCRIPTION: Defines the new function for TransferV1CpiBuilder, which initializes an instruction with required accounts for the CPI call to the Core program. It handles the setup of necessary parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n//new() function for TransferV1CpiBuilder\n\npub fn new(program: &'b solana_program::account_info::AccountInfo<'a>) -> Self {\n        let instruction = Box::new(TransferV1CpiBuilderInstruction {\n            __program: program,\n            asset: None,\n            collection: None,\n            payer: None,\n            authority: None,\n            new_owner: None,\n            system_program: None,\n            log_wrapper: None,\n            compression_proof: None,\n            __remaining_accounts: Vec::new(),\n        });\n        Self { instruction }\n    }\n```\n\n----------------------------------------\n\nTITLE: Updating as Data Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code snippet shows how a Data Item Delegate can update the data object of an asset using the updateAsDataItemDelegateV2 function. It demonstrates updating the name of the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsDataItemDelegateV2,\n  fetchMetadataFromSeeds,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst initialMetadata = await fetchMetadataFromSeeds(umi, { mint })\nawait updateAsDataItemDelegateV2(umi, {\n  mint,\n  authority: dataItemDelegate,\n  data: { ...initialMetadata, name: 'Updated Name' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Incrementing Value in Solana Account with Rust\nDESCRIPTION: This Rust code defines a Solana program that increments a value stored in an account. It retrieves the account, checks its ownership, deserializes the increment amount from the instruction data, increments the account's data, and prints the updated value. The program uses the `solana_program` crate for interacting with the Solana runtime.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/solana-programs.md#2025-04-17_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    pubkey::Pubkey,\n    msg,\n    program_error::ProgramError,\n};\n\nentrypoint!(process_instruction);\n\nfn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n    let account = next_account_info(accounts_iter)?;\n\n    // Ensure account is owned by the program\n    if account.owner != program_id {\n        msg!(\"Account is not owned by the program\");\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    // Deserialize instruction data (increment value)\n    let increment_amount = instruction_data[0];\n\n    // Increment the value\n    let mut data = account.try_borrow_mut_data()?;\n    data[0] = data[0].wrapping_add(increment_amount);\n\n    msg!(\"Value after increment: {}\", data[0]);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Assets with Plugins - Old vs New Syntax\nDESCRIPTION: Demonstrates the difference between auto-generated Kinobi functions and the new JS SDK v1.0 syntax for creating assets with plugins. The new syntax simplifies plugin definition by removing constructor functions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/core-js-sdk-v1-0.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait createV1(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    {\n      plugin: createPluginV2({\n        type: 'Attributes',\n        attributeList: [{ key: 'key', value: 'value' }],\n      }),\n      authority: pluginAuthority('UpdateAuthority'),\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait create(umi, {\n  asset: assetSigner,\n  name: 'My Asset',\n  uri: 'https://example.com/my-asset.json',\n  plugins: [\n    { type: 'Attributes', attributeList: [{ key: 'key', value: 'value' }] },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Candy Machine with Token2022 Payment Guard in JavaScript\nDESCRIPTION: Creates a new Candy Machine with Token2022 Payment guard configuration. The code sets the amount of tokens to charge (300), specifies the token mint address, and configures the destination associated token account using the current identity as the receiving wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token2022-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAssociatedTokenPda } from '@metaplex-foundation/mpl-toolbox'\ncreate(umi, {\n  // ...\n  guards: {\n    token2022Payment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta: findAssociatedTokenPda(umi, {\n        mint: tokenMint.publicKey,\n        owner: umi.identity.publicKey,\n      })[0],\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Capture Operation in MPL-404 Hybrid Escrow using JavaScript\nDESCRIPTION: This snippet demonstrates how to execute a Capture operation in the MPL-404 Hybrid Escrow, swapping fungible tokens for an NFT. It uses the captureV1 function from the mpl-hybrid library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\n// Capture an NFT by swapping fungible tokens\nconst captureTx = await captureV1(umi, {\n  owner: umi.identity.publicKey,\n  escrow,\n  asset,\n  collection,\n  token,\n  feeProjectAccount,\n  amount,\n}).sendAndConfirm(umi);\n\nconst signature = base58.deserialize(captureTx.signature)[0];\nconsole.log(`Captured! Check it out: https://explorer.solana.com/tx/${signature}?cluster=devnet`);\n```\n\n----------------------------------------\n\nTITLE: Defining Leaf Schema Structure for Bubblegum Merkle Trees\nDESCRIPTION: This enum defines the leaf schema structure that represents a compressed NFT in a Bubblegum Merkle tree. It contains fields for the asset ID, owner, delegate, nonce, data hash, and creator hash. The V1 variant suggests the protocol supports versioning for future changes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/hashed-nft-data.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Debug, Clone)]\npub enum LeafSchema {\n    V1 {\n        id: Pubkey,\n        owner: Pubkey,\n        delegate: Pubkey,\n        nonce: u64,\n        data_hash: [u8; 32],\n        creator_hash: [u8; 32],\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ImmutableMetadata Plugin to MPL Core Asset using JavaScript\nDESCRIPTION: This code snippet demonstrates how to add the ImmutableMetadata plugin to an MPL Core Asset using the Metaplex Core library in JavaScript. It uses the addPlugin function to make the metadata immutable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/immutableMetadata.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'ImmutableMetadata',\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Burn Delegate Plugin to MPL Core Asset in Rust\nDESCRIPTION: This snippet shows how to add a Burn Delegate Plugin to an MPL Core Asset using Rust. It includes necessary imports, sets up the RPC client and keypair, creates the instruction, and sends the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/burn-delegate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddPluginV1Builder,\n    types::{BurnDelegate, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_burn_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_burn_delegate_plugin_ix = AddPluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::BurnDelegate(BurnDelegate {}))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_burn_delegate_plugin_ix_tx = Transaction::new_signed_with_payer(\n        &[add_burn_delegate_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_burn_delegate_plugin_ix_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Allocation Tracker Account in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to fetch the Allocation Tracker Account for validation purposes using the safeFetchAllocationTrackerFromSeeds function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allocation.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  safeFetchAllocationTrackerFromSeeds,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allocationTracker = await safeFetchAllocationTrackerFromSeeds(umi, {\n  id: 1, // The allocation id you set in your guard config\n  candyMachine: candyMachine.publicKey,\n  // or candyMachine: publicKey(\"Address\") with your CM Address\n  candyGuard: candyMachine.mintAuthority,\n  // or candyGuard: publicKey(\"Address\") with your candyGuard Address\n});\n```\n\n----------------------------------------\n\nTITLE: Minting with Sol Payment Guard in TypeScript\nDESCRIPTION: This snippet shows how to mint from a Candy Machine with the Sol Payment guard. It specifies the destination wallet for the payment using the mintArgs parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/sol-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    solPayment: some({ destination: treasury }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up a Candy Machine with Token Burn Guard in TypeScript\nDESCRIPTION: This code demonstrates how to create a Candy Machine with the Token Burn guard enabled. The guard is configured to burn 300 tokens from a specified mint account when minting occurs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    tokenBurn: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Transaction Deserialization Example\nDESCRIPTION: Process of deserializing and signing a transaction received from another environment\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst deserializedCreateAssetTxAsU8 = base64.serialize(serializedCreateAssetTxAsString);\n\nconst deserializedCreateAssetTx = umi.transactions.deserialize(deserializedCreateAssetTxAsU8)\n\nconst signedDeserializedCreateAssetTx = await umi.identity.signTransaction(deserializedCreateAssetTx)\n\nawait umi.rpc.sendTransaction(signedDeserializedCreateAssetTx)\n```\n\n----------------------------------------\n\nTITLE: Delegated Burn of Non-Fungible Token in TypeScript\nDESCRIPTION: This code example demonstrates how to perform a delegated burn of a non-fungible token using the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nimport { burnV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait burnV1(umi, {\n  mint,\n  authority: standardDelegate,\n  tokenOwner: currentOwner,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Installing Amman via NPM\nDESCRIPTION: Command to install the Metaplex Amman package using npm. This is the first step after setting up prerequisites.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/amman\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata Object for Solana NFT Collection in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a metadata object for a Solana NFT collection. It includes fields for name, description, image URI, external URL, and properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst metadata = {\n  name: 'My Collection',\n  description: 'This is a Collection on Solana',\n  image: imageUri[0],\n  external_url: 'https://example.com',\n  properties: {\n    files: [\n      {\n        uri: imageUri[0],\n        type: 'image/jpeg',\n      },\n    ],\n    category: 'image',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Plugin using Rust\nDESCRIPTION: Rust implementation for updating collection plugin settings. Demonstrates updating royalty configuration with new creator and basis points using Solana SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/collections.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::{\n    instructions::UpdateCollectionPluginV1Builder,\n    types::{Creator, Plugin, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\n\npub async fn update_collection_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let new_creator = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let update_collection_plugin_ix = UpdateCollectionPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .plugin(Plugin::Royalties(Royalties {\n            basis_points: 500,\n            creators: vec![Creator {\n                address: new_creator,\n                percentage: 100,\n            }],\n            rule_set: RuleSet::None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let update_collection_plugin_tx = Transaction::new_signed_with_payer(\n        &[update_collection_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&update_collection_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Token Burn Guard in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with the Token Burn guard using JavaScript. It specifies the amount of tokens to burn and the mint account address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    tokenBurn: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Validating MintLimit Guard\nDESCRIPTION: This code snippet demonstrates how to validate the `mintLimit` guard. It fetches the mint counter for the user and checks if the mint limit has been reached. If the limit has been reached, the mint is not allowed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapOption } from '@metaplex-foundation/umi';\nimport { \n  safeFetchMintCounterFromSeeds,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst mintLimit = unwrapOption(candyGuard.guards.mintLimit);\nif (mintLimit){\n      const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n      id: mintLimit.id,\n      user: umi.identity.publicKey,\n      candyMachine: candyMachine.publicKey,\n      candyGuard: candyMachine.mintAuthority,\n    });\n\n    // mintCounter PDA exists (not the first mint)\n    if (mintCounter && mintLimit.limit >= mintCounter.count\n    ) {\n      allowed = false;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Core Candy Guards Rust SDK\nDESCRIPTION: Command to add the mpl-core-candy-guard crate to your Rust project using Cargo. This SDK allows for creating and managing Core Candy Guards that can be wrapped over a Core Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/sdk/rust.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-core-candy-guard\n```\n\n----------------------------------------\n\nTITLE: Converting Messages from Umi to Web3.js for Solana Transactions in TypeScript\nDESCRIPTION: This snippet shows how to convert a message from Umi format to Web3.js format using an adapter function. It includes creating a Umi instance and a versioned transaction message. It requires the @metaplex-foundation/umi-bundle-defaults and @metaplex-foundation/umi-web3js-adapters packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { toWeb3JMessage } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new Versioned Transaction\nconst umiMessage = umi.transactions.create({...createParams}).message;\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsMessage = toWeb3JMessage(umiMessage);\n```\n\n----------------------------------------\n\nTITLE: Creating Instruction for CreateV1\nDESCRIPTION: Shows how to create an instruction for CreateV1 using the instruction fields and an instruction arguments struct. The resulting instruction can then be added to a Solana transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// instruction args\nlet args = CreateV1InstructionArgs {\n    name: String::from(\"My pNFT\"),\n    symbol: String::from(\"MY\"),\n    uri: String::from(\"https://my.pnft\"),\n    seller_fee_basis_points: 500,\n    primary_sale_happened: false,\n    is_mutable: true,\n    token_standard: TokenStandard::ProgrammableNonFungible,\n    collection: None,\n    uses: None,\n    collection_details: None,\n    creators: None,\n    rule_set: None,\n    decimals: Some(0),\n    print_supply: Some(PrintSupply::Zero),\n};\n\n// instruction accounts\nlet create_ix = CreateV1 {\n    metadata,\n    master_edition: Some(master_edition),\n    mint: (mint_pubkey, true),\n    authority: payer_pubkey,\n    payer: payer_pubkey,\n    update_authority: (payer_pubkey, true),\n    system_program: system_program::ID,\n    sysvar_instructions: solana_program::sysvar::instructions::ID,\n    spl_token_program: spl_token::ID,\n};\n\n// creates the instruction\nlet create_ix = create_ix.instruction(args);\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Assets by Creator\nDESCRIPTION: Helper function to fetch all Digital Assets by creator, with optional position specification.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetByCreator } from '@metaplex-foundation/mpl-token-metadata'\n\n// Assets such that the creator is first in the Creator array.\nconst assetsA = await fetchAllDigitalAssetByCreator(umi, creator)\n\n// Assets such that the creator is second in the Creator array.\nconst assetsB = await fetchAllDigitalAssetByCreator(umi, creator, {\n  position: 2,\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Royalties Plugin to MPL Core Asset in JavaScript\nDESCRIPTION: This snippet demonstrates how to add the Royalties Plugin to an MPL Core Asset using JavaScript. It sets the royalty percentage, defines creators, and applies a program deny list.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst creator1 = publicKey('11111111111111111111111111111111')\nconst creator2 = publicKey('2222222222222222222222222222222')\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'Royalties',\n    basisPoints: 500,\n    creators: [\n      { address: creator1, percentage: 80 },\n      { address: creator2, percentage: 20 },\n    ],\n    ruleSet: ruleSet('ProgramDenyList', [\n      [\n        publicKey('44444444444444444444444444444444'),\n        publicKey('55555555555555555555555555555555'),\n      ],\n    ]),\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Token2022 Payment Guard in TypeScript\nDESCRIPTION: Implementation of minting process with Token2022 Payment guard using mintV2 function, including mint and destination token account settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token2022-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    token2022Payment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Payer Configuration in TypeScript\nDESCRIPTION: Shows how to configure the payer field which specifies the wallet that pays for transaction and rent costs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\npayer: publicKey\n```\n\n----------------------------------------\n\nTITLE: Adding Plugin with Default Authority in TypeScript\nDESCRIPTION: Demonstrates how to add a plugin to an MPL Core Asset using the default authority type. Uses the addPlugin helper with the Attributes plugin type.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addPlugin } from '@metaplex-foundation/mpl-core'\n\nconst assetId = publicKey('11111111111111111111111111111111')\n\nawait addPlugin(umi, {\n  asset: assetId,\n  plugin: {\n    type: 'Attributes',\n    attributeList: [{ key: 'key', value: 'value' }],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Soulbound Asset with Permanent Freeze Plugin\nDESCRIPTION: Demonstrates the basic configuration for creating a soulbound asset using the Permanent Freeze Delegate Plugin. Shows the essential plugin options for making an asset non-transferrable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/create-soulbound-nft-asset.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nawait create(umi, {\n  asset: assetSigner,\n  collection: collection,\n  name: \"My Frozen Asset\",\n  uri: \"https://example.com/my-asset.json\",\n  plugins: [\n    {\n      type: 'PermanentFreezeDelegate',\n      frozen: true,\n      authority: { type: \"None\" },\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Filling out TransferV1CpiBuilder in Rust\nDESCRIPTION: Demonstrates how to fill out the parameters in the TransferV1CpiBuilder for executing a CPI call, ensuring that all necessary accounts and data are provided.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new()\n        .asset(ctx.accounts.asset)\n        .collection(context.accounts.collection)\n        .payer(context.accounts.payer)\n        .authority(context.accounts.authority)\n        .new_owner(context.accounts.new_owner)\n        .system_program(context.accounts.system_program)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with NFT Burn Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with the NFT Burn guard enabled. It sets the required collection for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftBurn: some({ requiredCollection: requiredCollectionNft.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Token Standard for Minted Assets\nDESCRIPTION: This command changes the token standard of assets minted through the Candy Machine. It allows setting the type to either 'NFT' or 'pNFT' and specifying a rule set for minted pNFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/config.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsugar config set -t \"pnft\" --rule-set <PUBLIC KEY>\n```\n\n----------------------------------------\n\nTITLE: Fetching AllowListProof Account\nDESCRIPTION: This code snippet demonstrates how to fetch the Allowlist proof account associated with the Allowlist guard. It assumes that the Candy Machine data is already available.  It uses `safeFetchAllowListProofFromSeeds` to retrieve the allowlist proof.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  safeFetchAllowListProofFromSeeds,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allowlist = [\n  \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\"\n];\n\nconst allowListProof = await safeFetchAllowListProofFromSeeds(umi, {\n  candyGuard: candyMachine.mintAuthority,\n  candyMachine: candyMachine.publicKey,\n  merkleRoot: getMerkleRoot(allowlist),\n  user: umi.identity.publicKey,\n});\n```\n\n----------------------------------------\n\nTITLE: Delegating a Bubblegum Tree using JavaScript\nDESCRIPTION: This code demonstrates how to set a tree delegate for a Bubblegum Merkle Tree. It requires the merkleTree address, treeCreator signer, and newTreeDelegate address as parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/delegate-trees.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setTreeDelegate } from '@metaplex-foundation/mpl-bubblegum'\n\nawait setTreeDelegate(umi, {\n  merkleTree,\n  treeCreator,\n  newTreeDelegate,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Sample Response from MPL Core Asset Query in JSON Format\nDESCRIPTION: This JSON response shows the structure of data returned when querying an MPL Core asset. It includes the asset's public key, header information, plugin details, royalty configuration, metadata such as name and URI, and ownership information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-asset.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Asset Release in MPL Hybrid (JavaScript)\nDESCRIPTION: This code demonstrates how to perform a Release operation in MPL Hybrid to swap from a non-fungible asset back to fungible tokens. It configures Umi, initializes required accounts, finds a user-owned asset, and executes the release transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { generateSigner, signerIdentity, publicKey, sol } from '@metaplex-foundation/umi'\nimport { mplHybrid, MPL_HYBRID_PROGRAM_ID, releaseV1 } from '@metaplex-foundation/mpl-hybrid'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport { base58, string, publicKey as publicKeySerializer } from '@metaplex-foundation/umi/serializers'\nimport { fetchAssetsByCollection } from '@metaplex-foundation/mpl-core'\n\nimport walletFile from \"/Users/leo/.config/solana/id.json\";\n\n(async () => {\n  /// Step 1: Setup Umi\n  const umi = createUmi('https://api.devnet.solana.com')\n    .use(mplHybrid())\n    .use(mplTokenMetadata())\n\n  let signer = generateSigner(umi);\n\n  umi.use(signerIdentity(signer)).rpc.airdrop(umi.identity.publicKey, sol(1));\n\n  // Step 2: Escrow Accounts - Change these to your needs\n  const collection = publicKey('<YOUR-COLLECTION-ADDRESS>');  // The collection we are swapping to/from\n  const token = publicKey('<YOUR-TOKEN-ADDRESS>');            // The token we are swapping to/from\n  const feeProjectAccount = publicKey('<YOUR-FEE-ADDRESS>');  // The address where the fees will be sent\n  const escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: 'variable' }).serialize('escrow'),\n    publicKeySerializer().serialize(collection),\n  ]);                  \n\n  // Fetch all the assets in the collection\n  const assetsListByCollection = await fetchAssetsByCollection(umi, collection, {\n    skipDerivePlugins: false,\n  })\n\n  // Usually the user choose what to exchange\n  const asset = assetsListByCollection.filter(\n    (a) => a.owner === umi.identity.publicKey\n  )[0].publicKey\n\n  /// Step 3: \"Capture\" (Swap from Fungible to Non-Fungible) the Asset\n  const releaseTx = await releaseV1(umi, {\n    owner: umi.payer,\n    escrow,\n    asset,\n    collection,\n    token,\n    feeProjectAccount,\n  }).sendAndConfirm(umi)\n  \n  const signature = base58.deserialize(releaseTx.signature)[0]\n  console.log(`Released! https://explorer.solana.com/tx/${signature}?cluster=devnet`)\n})()\n```\n\n----------------------------------------\n\nTITLE: Thawing Frozen NFT using JavaScript in Candy Machine\nDESCRIPTION: This code snippet demonstrates how to thaw a frozen NFT that belongs to the current identity using the route function in JavaScript. It specifies the guard as 'freezeTokenPayment' and provides necessary route arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: \"freezeTokenPayment\",\n  routeArgs: {\n    path: \"thaw\",\n    mint: tokenMint.publicKey,\n    destinationAta,\n    nftMint: nftMint.publicKey,\n    nftOwner: umi.identity.publicKey,\n    nftTokenStandard: candyMachine.tokenStandard,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Unit Serializers in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of unit serializers for handling undefined values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nunit().serialize(undefined); // -> new Uint8Array([])\nunit().deserialize(new Uint8Array([42])); // -> [undefined, 0]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Asset Proofs with DAS API using cURL\nDESCRIPTION: This snippet uses cURL to send a POST request to the DAS API endpoint to retrieve merkle tree proofs for specified asset IDs. The required setup includes providing the endpoint URL and asset identifiers within the JSON request body. The input is a list of asset IDs in JSON-RPC format, and the expected response is the proofs data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-proofs.md#2025-04-17_snippet_1\n\nLANGUAGE: cURL\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\\n    \"jsonrpc\": \"2.0\",\\n    \"method\": \"getAssetProofs\",\\n    \"params\": [\\n      [\\n        \"GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA\",\\n        \"ELDjRRs5Wb478K4h3B5bMPEhqFD8FvoET5ctHku5uiYi\"\\n      ]\\n    ],\\n    \"id\": 0\\n}'\n```\n\n----------------------------------------\n\nTITLE: Retrieving Asset Proofs with DAS API in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the DAS API to retrieve merkle tree proofs for a list of asset IDs. The code initializes a Umi instance configured with the DAS API and retrieves the proofs using asset IDs. Prerequisites include '@metaplex-foundation/umi', '@metaplex-foundation/umi-bundle-defaults', and '@metaplex-foundation/digital-asset-standard-api'. The input is an array of asset public keys, and the output is the asset proof logs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-proofs.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\\n\\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\\nconst assetIds = [\\n  publicKey('GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA'),\\n  publicKey('ELDjRRs5Wb478K4h3B5bMPEhqFD8FvoET5ctHku5uiYi')\\n];\\n\\nconst assets = await umi.rpc.getAssetProofs(assetIds);\\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Builders in TypeScript\nDESCRIPTION: This snippet demonstrates various methods to configure transaction builders, including setters and getters for different properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Setters.\nbuilder = builder.setVersion(myTransactionVersion) // Sets the transaction version.\nbuilder = builder.useLegacyVersion() // Sets the transaction version to \"legacy\".\nbuilder = builder.useV0() // Sets the transaction version to 0 (default).\nbuilder = builder.empty() // Removes all instructions from the builder but keeps the configurations.\nbuilder = builder.setItems(myWrappedInstructions) // Overwrite the wrapped instructions with the given ones.\nbuilder = builder.setAddressLookupTables(myLuts) // Set the address lookup tables, only for version 0 transactions.\nbuilder = builder.setFeePayer(myPayer) // Set a custom fee payer.\nbuilder = builder.setBlockhash(myBlockhash) // Set the blockhash to use for the transaction.\nbuilder = await builder.setLatestBlockhash(umi) // Fetch the latest blockhash and use it for the transaction.\n\n// Getters.\nconst transactionSize = builder.getTransactionSize(umi) // Return the size in bytes of the built transaction.\nconst isSmallEnough = builder.fitsInOneTransaction(umi) // Whether the built transaction would fit in one transaction.\nconst transactionRequired = builder.minimumTransactionsRequired(umi) // Return the minimum number of transactions required to send all instructions.\nconst blockhash = builder.getBlockhash() // Return the configured blockhash if any.\nconst feePayer = builder.getFeePayer(umi) // Return the configured fee payer or uses `umi.payer` if none is configured.\nconst instructions = builder.getInstructions(umi) // Return all unwrapped instructions.\nconst signers = builder.getSigners(umi) // Return all deduplicated signers, including the fee payer.\nconst bytes = builder.getBytesCreatedOnChain() // Return the total number of bytes that would be created on chain.\nconst solAmount = await builder.getRentCreatedOnChain(umi) // Return the total number of bytes that would be created on chain.\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Sol Payment Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the Sol Payment guard. It configures the guard to charge 1.5 SOL and sets the destination to the current identity's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/sol-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    solPayment: some({\n      lamports: sol(1.5),\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Any Rule with Multiple Additional Signers in Token Auth Rules\nDESCRIPTION: Example showing how to create a Rule Set using the Any rule to check for multiple possible signers. The rule evaluates to true if any one of the specified public keys signs the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/composite-rules/any.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will evaluate to true if one of the Public Keys sign the transaction.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    deposit: {\n      type: 'Any',\n      rules: [\n        {\n          type: 'AdditionalSigner',\n          publicKey: publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n        },\n        {\n          type: 'AdditionalSigner',\n          publicKey: publicKey('6twkdkDaF3xANuvpUQvENSLhtNmPxzYAEu8qUKcVkWwy'),\n        },\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Converting PublicKey from Umi to Web3.js\nDESCRIPTION: TypeScript code showing how to convert a PublicKey from Umi format to Web3.js format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { toWeb3JsPublicKey } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Publickey\nconst umiPublicKey = publicKey(\"11111111111111111111111111111111\");\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsPublickey = toWeb3JsPublicKey(umiPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Group using cURL\nDESCRIPTION: This snippet shows how to query the DAS API directly using cURL. It sends a POST request to the endpoint with JSON parameters specifying the group key, group value, and pagination options to retrieve assets from a specific collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-group.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetsByGroup\",\n    \"params\": {\n        \"groupKey\": \"collection\",\n        \"groupValue\": \"J2ZfLdQsaZ3GCmbucJef3cPnPwGcgjDW1SSYtMdq3L9p\",\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Setting up Start Date Guard with JavaScript in Candy Machine\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with a Start Date guard using JavaScript/TypeScript. The startDate guard is configured with a specific date and time after which minting will be allowed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/start-date.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dateTime } from \"@metaplex-foundation/umi\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    startDate: some({ date: dateTime(\"2022-01-24T15:30:00.000Z\") }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Compute Unit Limit in Umi Transactions\nDESCRIPTION: This snippet demonstrates how to set a custom Compute Unit limit for a transaction using the setComputeUnitLimit function from the mpl-toolbox package. It sets the limit to 600,000 units.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/priority-fees-and-compute-managment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transactionBuilder } from '@metaplex-foundation/umi'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\n\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 600_000 })) // Set the Compute Unit limit.\n  .add(...) // Any instruction(s) here.\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Mint Limit Guard in JavaScript\nDESCRIPTION: Executes a mint operation using the Asset Mint Limit guard by providing the required mint arguments including the guard ID and asset reference.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-mint-limit.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    nftMintLimit: some({ id: 1, asset: assetToVerify.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Inscribe Data for new NFT using the Gateway in Bash\nDESCRIPTION: This Bash snippet demonstrates using the CLI tool to inscribe data for a new NFT on the Solana blockchain via the Metaplex Inscription gateway. The command requires the RPC endpoint, the keypair file for authentication, and the NFT address to proceed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\npnpm cli inscribe -r <RPC_ENDPOINT> -k <KEYPAIR_FILE> -m <NFT_ADDRESS>\n\n```\n\n----------------------------------------\n\nTITLE: Freezing Asset in Rust\nDESCRIPTION: This snippet demonstrates how to freeze an asset using the AddPluginV1CpiBuilder to prevent trading after staking.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nAddPluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n.asset(&ctx.accounts.asset.to_account_info())\n.collection(Some(&ctx.accounts.collection.to_account_info()))\n.payer(&ctx.accounts.payer.to_account_info())\n.authority(Some(&ctx.accounts.owner.to_account_info()))\n.system_program(&ctx.accounts.system_program.to_account_info())\n.plugin(Plugin::FreezeDelegate( FreezeDelegate{ frozen: true } ))\n.init_authority(PluginAuthority::UpdateAuthority)\n.invoke()?\n```\n\n----------------------------------------\n\nTITLE: Registering Program Clients\nDESCRIPTION: TypeScript examples showing how to register program clients with Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\n\nconst umi = createUmi('https://api.mainnet-beta.solana.com')\n  .use(mplTokenMetadata())\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\nimport { mplCandyMachine } from '@metaplex-foundation/mpl-candy-machine'\n\nconst umi = createUmi('https://api.mainnet-beta.solana.com')\n  .use(mplTokenMetadata())\n  .use(mplCandyMachine())\n```\n\n----------------------------------------\n\nTITLE: Minting with Sol Payment Guard in JavaScript\nDESCRIPTION: Executes a mint operation with the Sol Payment guard using the mintV2 function, providing the destination treasury wallet for the SOL payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/sol-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    solPayment: some({ destination: treasury }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Clear Inscription Data with JavaScript\nDESCRIPTION: This code snippet demonstrates how to clear inscription data using the `@metaplex-foundation/mpl-inscription` library. It imports the `clearData` and `findInscriptionMetadataPda` functions, finds the inscription metadata account, and then calls `clearData` to clear the inscription's data. The `associatedTag` parameter must match the tag used during inscription creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/clear.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { clearData, findInscriptionMetadataPda } from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nawait clearData(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n  inscriptionMetadataAccount,\n  associatedTag: null, //use the same tag here as you used on creation\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Collection NFT for Candy Machine in JavaScript\nDESCRIPTION: Illustrates the process of creating a Collection NFT and setting it up for a Candy Machine, including creating the NFT and passing its address and authority to the Candy Machine settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport { createNft } from '@metaplex-foundation/mpl-token-metadata'\n\n// Create the Collection NFT.\nconst collectionUpdateAuthority = generateSigner(umi)\nconst collectionMint = generateSigner(umi)\nawait createNft(umi, {\n  mint: collectionMint,\n  authority: collectionUpdateAuthority,\n  name: 'My Collection NFT',\n  uri: 'https://example.com/path/to/some/json/metadata.json',\n  sellerFeeBasisPoints: percentAmount(9.99, 2), // 9.99%\n  isCollection: true,\n}).sendAndConfirm(umi)\n\n// Pass the collection address and its authority in the settings.\nconst candyMachineSettings = {\n  collectionMint: collectionMint.publicKey,\n  collectionUpdateAuthority,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Collection Creation Instruction\nDESCRIPTION: Main instruction implementation that handles the CPI call to create a Core Collection using the CreateCollectionV2CpiBuilder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_core_collection(ctx: Context<CreateCollection>, args: CreateCollectionArgs) -> Result<()> {\n  let update_authority = match &ctx.accounts.update_authority {\n      Some(update_authority) => Some(update_authority.to_account_info()),\n      None => None,\n  };\n  \n  CreateCollectionV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n      .collection(&ctx.accounts.collection.to_account_info())\n      .payer(&ctx.accounts.payer.to_account_info())\n      .update_authority(update_authority.as_ref())\n      .system_program(&ctx.accounts.system_program.to_account_info())\n      .name(args.name)\n      .uri(args.uri)\n      .invoke()?;\n\n  Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Revoking Data Item Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet illustrates how to revoke a Data Item Delegate using the revokeDataItemV1 function. It removes the delegate's authority to update the data object of an individual asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeDataItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeDataItemV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: dataItemDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON Schema in Rust\nDESCRIPTION: This code demonstrates how to deserialize JSON schema data in Rust using the serde and serde_json crates. It defines a struct with Serialize and Deserialize traits and uses serde_json to convert raw bytes into the struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// For the `JSON` schema you will need to use the `serde` and `serde_json` crates.\n\n// You will need to add `Serialize` and `Deserialize` to your `derive` macro\n// on your struct.\n#[derive(Debug, Serialize, Deserialize)]\npub struct MyData {\n    pub timestamp: u64,\n    pub message: String,\n}\n\nlet my_data: MyData = serde_json::from_slice(&data).unwrap();\nprintln!(\"{:?}\", my_data);\n```\n\n----------------------------------------\n\nTITLE: Structuring JSON Schema for VR NFT in Metaplex Core\nDESCRIPTION: This snippet shows the JSON schema for a VR NFT in Metaplex Core. It includes both an image URL for a fallback image and an animation URL pointing to a .glb file. The category is set to 'vr' and both files are listed in the properties section.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"VR Asset\",\n    \"image\": \"https://arweave.net/2MZgcwIbuSRndVW2jz6M85RgAbNBP2r52PM4vkaE4vA\",\n    \"animation_url\": \"https://arweave.net/x-aTcZDaSIUGHkyee3j7Z158754oQijs2bStmbjOi1g\",\n    \"description\": \"This is a VR Asset. It has an image and the animation url is linked to a glb file. The metadata category is set to vr.\",\n    \"external_url\": \"https://example.com\",\n    \"properties\": {\n        \"files\": [\n            {\n                \"uri\": \"https://arweave.net/2MZgcwIbuSRndVW2jz6M85RgAbNBP2r52PM4vkaE4vA\",\n                \"type\": \"image/png\"\n            },\n            {\n                \"uri\": \"https://arweave.net/x-aTcZDaSIUGHkyee3j7Z158754oQijs2bStmbjOi1g\",\n                \"type\": \"video/undefined\"\n            }\n        ],\n        \"category\": \"vr\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenericFile Type in TypeScript\nDESCRIPTION: Defines the GenericFile type used by Umi to represent files consistently across different environments. It includes properties for the file content, various names, content type, and tags.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype GenericFile = {\n  readonly buffer: Uint8Array;\n  readonly fileName: string;\n  readonly displayName: string;\n  readonly uniqueName: string;\n  readonly contentType: string | null;\n  readonly extension: string | null;\n  readonly tags: GenericFileTag[];\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Not Rule in Token Auth Rules with JavaScript\nDESCRIPTION: Demonstrates how to create a Rule Set that uses the Not operator to negate an AdditionalSigner rule. The example shows a deposit operation that will only succeed if a specific public key does NOT sign the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/composite-rules/not.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will only evaluate to true if the Public Key does NOT sign the transaction.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    deposit: {\n      type: 'Not',\n      rules: [\n        {\n          type: 'AdditionalSigner',\n          publicKey: publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n        },\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: Installation commands for required Metaplex and Umi packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/mpl-core\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-uploader-irys;\n```\n\n----------------------------------------\n\nTITLE: Fetching Mint Counter Account with Metaplex\nDESCRIPTION: This snippet fetches the MintCounter account using the `safeFetchMintCounterFromSeeds` function from the `@metaplex-foundation/mpl-core-candy-machine` library. It requires the `umi` instance, the `mintLimit` id set in the guard config, the user's public key, the Candy Machine's public key, and the Candy Guard's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { safeFetchMintCounterFromSeeds } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n  id: 1, // The mintLimit id you set in your guard config\n  user: umi.identity.publicKey,\n  candyMachine: candyMachine.publicKey,\n  candyGuard: candyMachine.mintAuthority,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Messages in Umi for Solana Transactions in TypeScript\nDESCRIPTION: This snippet shows how to create a message for a versioned transaction using the Umi library. It includes creating a Umi instance, getting the latest blockhash, and creating a versioned transaction with instructions. It requires the @metaplex-foundation/umi-bundle-defaults and @metaplex-foundation/mpl-core packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { transfer, mplCore } from '@metaplex-foundation/mpl-core'\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new Umi Message\nconst blockhash = await umi.rpc.getLatestBlockhash()\n\nconst instructions = transfer(umi, {...TransferParams}).getInstructions()\n\nconst umiVersionedTransaction = umi.transactions.create({\n  version: 0,\n  payer: frontEndSigner.publicKey,\n  instructions,\n  blockhash: blockhash.blockhash,\n});\n\nconst umiMessage = umiVersionedTransaction.message\n```\n\n----------------------------------------\n\nTITLE: Example Response from DAS API Core Asset Search\nDESCRIPTION: The JSON response returned from the DAS API when searching for Core assets. It includes detailed information about each asset including public key, owner, royalties, content information, and more.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/search-assets.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Updating Item as Data Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet shows how a Data Delegate can update the data object of an item within a collection using the updateAsDataDelegateV2 function. It demonstrates updating the name of an item in the collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsDataDelegateV2,\n  fetchMetadataFromSeeds,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nconst initialMetadata = await fetchMetadataFromSeeds(umi, { mint })\nawait updateAsDataDelegateV2(umi, {\n  mint,\n  delegateMint: collectionMint,\n  authority: dataDelegate,\n  data: { ...initialMetadata, name: 'Updated Name' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Removing a Plugin from MPL Core Collection in Rust\nDESCRIPTION: This snippet shows how to remove a plugin from an MPL Core Collection using Rust. It uses the mpl_core, solana_client, and solana_sdk crates to remove a 'FreezeDelegate' plugin from a specified collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/removing-plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::RemoveCollectionPluginV1Builder, types::PluginType};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn remove_collection_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let remove_collection_plugin_ix = RemoveCollectionPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .plugin_type(PluginType::FreezeDelegate)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let remove_collection_plugin_tx = Transaction::new_signed_with_payer(\n        &[remove_collection_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&remove_collection_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Gate Guard in TypeScript\nDESCRIPTION: This code snippet shows how to mint using the NFT Gate guard. It provides the mint address of the NFT to use as proof of ownership in the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    nftGate: some({ mint: nftToBurn.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Computing Total Metaplex Inscriptions in JavaScript\nDESCRIPTION: Demonstrates how to calculate the total number of Metaplex Inscriptions on Solana by fetching and aggregating data from all inscription shards\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  fetchAllInscriptionShard,\n  findInscriptionShardPda,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst shardKeys = []\nfor (let shardNumber = 0; shardNumber < 32; shardNumber += 1) {\n  k.push(findInscriptionShardPda(umi, { shardNumber }))\n}\n\nconst shards = await fetchAllInscriptionShard(umi, shardKeys)\nlet numInscriptions = 0\nshards.forEach((shard) => {\n  const rank = 32 * Number(shard.count) + shard.shardNumber\n  numInscriptions = Math.max(numInscriptions, rank)\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Update Authority in TypeScript\nDESCRIPTION: This snippet illustrates how to fetch all assets associated with a specific update authority using the fetchAssetsByUpdateAuthority() function. It includes an option to skip deriving plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetsByUpdateAuthority = await fetchAssetsByUpdateAuthority(\n  umi,\n  updateAuthority,\n  { skipDerivePlugins: false }\n)\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Authority Using cURL\nDESCRIPTION: Shows how to directly query the DAS API using a cURL command to retrieve assets by authority address. The example demonstrates the JSON-RPC payload structure with the required authorityAddress parameter and an optional page parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-authority.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetsByAuthority\",\n    \"params\": {\n        \"authorityAddress\": \"mRdta4rc2RtsxEUDYuvKLamMZAdW6qHcwuq866Skxxv\",\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Sending and Confirming Transactions in TypeScript\nDESCRIPTION: Illustrates methods for sending, confirming, and fetching transactions using the Umi instance. The main prerequisite is having a valid transaction to send, returning signature or transaction data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst signature = await umi.rpc.sendTransaction(myTransaction);\nconst confirmResult = await umi.rpc.confirmTransaction(signature, { strategy });\nconst transaction = await umi.rpc.getTransaction(signature);\n```\n\n----------------------------------------\n\nTITLE: Burning a Collection-based Core NFT Asset\nDESCRIPTION: Shows how to burn a Core NFT asset that belongs to a collection. The code includes additional collection-related operations and verification steps.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/burn.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { burnV1, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  burn,\n  fetchAsset,\n  collectionAddress,\n  fetchCollection,\n} from '@metaplex-foundation/mpl-core'\n\nconst assetId = publicKey('11111111111111111111111111111111')\nconst asset = await fetchAsset(umi, assetId)\n\nconst collectionId = collectionAddress(asset)\n\nlet collection = undefined\n\nif (collectionId) {\n  collection = await fetchCollection(umi, collection)\n}\n\nawait burn(umi, {\n  asset: asset,\n  collection: collection,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::BurnV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn burn_asset_in_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let collection = Pubkey::from_str(\"2222222222222222222222222222222\").unwrap();\n\n    let burn_asset_in_collection_ix = BurnV1Builder::new()\n        .asset(asset)\n        .collection(Some(collection))\n        .payer(authority.pubkey())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let burn_asset_in_collection_tx = Transaction::new_signed_with_payer(\n        &[burn_asset_in_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&burn_asset_in_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Accounts Module in Metaplex SDK\nDESCRIPTION: This Rust snippet demonstrates how to access the accounts module of the mpl-core crate, which represents the on-chain account structure and can be deserialized using various methods. The module is vital for interacting with program accounts within the Metaplex SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nmpl_core::accounts\n```\n\n----------------------------------------\n\nTITLE: Invoking TransferV1Cpi Instruction\nDESCRIPTION: Shows how to invoke the TransferV1Cpi instruction, including creating the instruction with the necessary accounts and arguments, and performing the Cross Program Invocation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n// creates the instruction\nlet cpi_transfer = TransferV1Cpi::new(\n    metadata_program_info,\n    TransferV1CpiAccounts {\n        token: owner_token_info,\n        token_owner: owner_info,\n        destination_token: destination_token_info,\n        destination_owner: destination_info,\n        mint: mint_info,\n        metadata: metadata_info,\n        authority: vault_info,\n        payer: payer_info,\n        system_program: system_program_info,\n        sysvar_instructions: sysvar_instructions_info,\n        spl_token_program: spl_token_program_info,\n        spl_ata_program: spl_ata_program_info,\n        edition: edition_info,\n        token_record: None,\n        destination_token_record: None,\n        authorization_rules: None,\n        authorization_rules_program: None,\n    },\n    TransferV1InstructionArgs {\n        amount,\n        authorization_data: None,\n    },\n);\n\n// performs the CPI\ncpi_transfer.invoke_signed(&[&signer_seeds])\n```\n\n----------------------------------------\n\nTITLE: Creating Transaction Builders\nDESCRIPTION: Shows how to create transaction builders for instructions using functions generated by Kinobi. This allows developers to construct transactions with multiple instructions combined. Inputs include instruction details, and outputs are transaction builders ready to be sent and confirmed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nawait transfer(umi, { from, to, amount }).sendAndConfirm();\n\n// Combine multiple transactions.\nawait transfer(umi, { from, to: destinationA, amount })\n  .add(transfer(umi, { from, to: destinationB, amount }))\n  .add(transfer(umi, { from, to: destinationC, amount }))\n  .sendAndConfirm();\n```\n\n----------------------------------------\n\nTITLE: Importing Required Modules\nDESCRIPTION: Essential imports from Metaplex packages including Umi framework and Core SDK functions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSignerFromKeypair, signerIdentity, publicKey, transactionBuilder, Transaction } from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { addPlugin, updatePlugin, fetchAsset, removePlugin } from '@metaplex-foundation/mpl-core'\nimport { base58 } from '@metaplex-foundation/umi/serializers';\n```\n\n----------------------------------------\n\nTITLE: Downloading Files and JSON with DownloaderInterface in TypeScript\nDESCRIPTION: Illustrates how to use the DownloaderInterface to download single or multiple files, as well as JSON data. It also shows how to use an abort signal for cancellation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Download one or several files.\nconst [myFile, myOtherFile] = await umi.downloader.download([myUri, myOtherUri]);\n\n// Download using an abort signal.\nconst myFiles = await umi.downloader.download(myUris, { signal: myAbortSignal });\n\n// Download a JSON file.\ntype Person = { name: string; age: number; };\nconst myJsonObject = await umi.downloader.downloadJson<Person>(myUri);\n```\n\n----------------------------------------\n\nTITLE: Initializing Anchor Project\nDESCRIPTION: Command to create a new Anchor project for Core NFT Asset creation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nanchor init create-core-asset-example\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Creator using cURL and DAS API\nDESCRIPTION: This example shows how to fetch assets by creator using a direct cURL request to the DAS API endpoint. It sends a JSON-RPC request specifying the creator address, verification flag, pagination limit, and page number as parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-creator.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetsByCreator\",\n    \"params\": {\n        \"creatorAddress\": \"D3XrkNZz6wx6cofot7Zohsf2KSsu2ArngNk8VqU9cTY3\",\n        \"onlyVerified\": false,\n        \"limit\": 10,\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Fetching a Core Collection in Rust\nDESCRIPTION: This Rust code fetches a Core Collection. It uses the Solana RPC client to get account data for a specific collection ID and then deserializes it into a Collection struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::str::FromStr;\nuse mpl_core::Collection;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::pubkey::Pubkey;\n\npub async fn fetch_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let collection_id = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let rpc_data = rpc_client.get_account_data(&collection_id).await.unwrap();\n\n    let collection = Collection::from_bytes(&rpc_data).unwrap();\n\n    print!(\"{:?}\", collection)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Guard Implementation Template\nDESCRIPTION: TypeScript template for implementing a custom guard with necessary types, serializer, and mint parser configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from '@metaplex-foundation/umi'\nimport {\n  getCustomGuardSerializer,\n  CustomGuard,\n  CustomGuardArgs,\n} from '../generated'\nimport { GuardManifest, noopParser } from '../guards'\n\nexport const customGuardManifest: GuardManifest<\n  CustomGuardArgs,\n  CustomGuard,\n  CustomGuardMintArgs\n> = {\n  name: 'customGuard',\n  serializer: getCustomGuardSerializer,\n  mintParser: (context, mintContext, args) => {\n    const { publicKeyArg1, arg1 } = args\n    return {\n      data: new Uint8Array(),\n      remainingAccounts: [\n        { publicKey: publicKeyArg1, isWritable: true },\n        { publicKey: publicKeyArg2, isWritable: false },\n      ],\n    }\n  },\n  routeParser: noopParser,\n}\n\nexport type CustomGuardMintArgs = {\n  publicKeyArg1: PublicKey\n  publicKeyArg2: PublicKey\n  arg3: Number\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Creator Using Token Metadata SDK\nDESCRIPTION: Demonstrates how to verify a creator for an asset using the verifyCreatorV1 function from the mpl-token-metadata package. Requires metadata account address and creator authority as a signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/creators.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { verifyCreatorV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait verifyCreatorV1(umi, {\n  metadata,\n  authority: creator,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Thawing Frozen NFT using JavaScript\nDESCRIPTION: Implementation of thawing a frozen NFT using the route function. Requires the NFT mint address, owner's public key, and token standard from the candy machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'thaw',\n    destination,\n    nftMint: nftMint.publicKey,\n    nftOwner: umi.identity.publicKey,\n    nftTokenStandard: candyMachine.tokenStandard,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Turbo SDK with Solana Integration\nDESCRIPTION: Configures the Turbo SDK to use Solana as the payment token for Arweave uploads. Includes authentication with a private key and configuring endpoints for devnet usage.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { TurboFactory } from '@ardrive/turbo-sdk';\n\n// Import here the keypair.json file that you're going\n// to use to pay for the upload\nimport secretKey from \"/path/to/your/kepypair.json\";\n\nconst turbo = TurboFactory.authenticated({\n  privateKey: bs58.encode(Uint8Array.from(secretKey)),\n  token: 'solana',\n  gatewayUrl: `https://devnet-aura.metaplex.com/<YOUR_API_KEY>`,\n  paymentServiceConfig: { url: \"https://payment.ardrive.dev\" },\n  uploadServiceConfig: { url: \"https://upload.ardrive.dev\" },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Master Edition Plugin in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to update the Master Edition Plugin for an existing asset. It imports necessary functions and calls the updatePlugin function with updated parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/master-edition.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePluginV1, createPlugin } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait updatePlugin(umi, {\n  asset: asset,\n  plugin: {\n    type: 'MasterEdition',\n    maxSupply: 110,\n    name: 'My Master Edition',\n    uri: 'https://example.com/my-master-edition',\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Querying Core Asset with No Update Authority in JavaScript\nDESCRIPTION: This snippet demonstrates how to fetch a Core Asset that has no update authority set using JavaScript. It uses the @metaplex-foundation/mpl-core library to fetch the asset and display its properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/what-is-an-asset.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetchAssetV1 } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAssetV1(umi, assetAddress.publicKey)\nconst collectionId = collectionAddress(asset)\n\nconsole.log({collectionId})\nconsole.log({asset})\n\n// log\ncollectionId: undefined\nasset: {\n    key: AssetV1,\n    owner: \"11111111111111111111111111111111\",\n    updateAuthority: {\n      type: 'None',\n    },\n    name: \"My Core Asset\",\n    uri: \"https://example.com/metadata.json\",\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Existing Items in Core Candy Machine\nDESCRIPTION: Demonstrates how to insert items at specific positions and update items that have already been inserted by specifying the index to insert at and the new config lines.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/insert-items.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 0,\n  configLines: [\n    { name: 'My Asset #1', uri: 'https://example.com/nft1.json' },\n    { name: 'My Asset #2', uri: 'https://example.com/nft2.json' },\n    { name: 'My Asset #3', uri: 'https://example.com/nft3.json' },\n  ],\n}).sendAndConfirm(umi)\n\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 1,\n  configLines: [{ name: 'My Asset #X', uri: 'https://example.com/nftX.json' }],\n}).sendAndConfirm(umi)\n\ncandyMachine = await fetchCandyMachine(candyMachine.publicKey)\ncandyMachine.items[0].name // \"My Asset #1\"\ncandyMachine.items[1].name // \"My Asset #X\"\ncandyMachine.items[2].name // \"My Asset #3\"\n```\n\n----------------------------------------\n\nTITLE: Revoking a Programmable Config Delegate for PNFTs in TypeScript\nDESCRIPTION: Revokes a previously approved Programmable Config Delegate. This can be done by the update authority or by the delegate itself for self-revocation. Requires the mint, authority, delegate address, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeProgrammableConfigV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeProgrammableConfigV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: programmableConfigDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deactivating Address Lookup Table in Umi\nDESCRIPTION: This instruction puts a LUT in a \"deactivation\" period before it can be closed. Deactivated LUTs can't be used in new transactions but still maintain their data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAddressLookupTablePda, deactivateLut } from '@metaplex-foundation/mpl-toolbox'\n\n// The authority and slot used to create the LUT.\nconst lutAddress = findAddressLookupTablePda(umi, { authority, recentSlot })\n\nawait deactivateLut(umi, {\n  authority,\n  address: lutAddress,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing MsgPack Schema in Rust\nDESCRIPTION: This code shows how to deserialize MsgPack schema data in Rust using the serde and rmp_serde crates. It defines a struct with Serialize and Deserialize traits and uses rmp_serde to convert raw bytes into the struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n// For the `MsgPack` schema you will need to use the `serde` and `rmp_serde` crates.\n\n// You will need to add `Serialize` and `Deserialize` to your `derive` macro\n// on your struct.\n#[derive(Debug, Serialize, Deserialize)]\npub struct MyData {\n    pub timestamp: u64,\n    pub message: String,\n}\n\n\nlet my_data: MyData = rmp_serde::decode::from_slice(&data).unwrap();\nprintln!(\"{:?}\", my_data);\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Payment Guard in Sugar Config JSON\nDESCRIPTION: This snippet shows how to configure the Token Payment guard in the Sugar tool's config.json file. It specifies the amount in basis points, the token mint address, and the destination address for receiving the tokens.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"tokenPayment\" : {\n    \"amount\": number in basis points (e.g. 1000 for 1 Token that has 3 decimals),\n    \"mint\": \"<PUBKEY>\",\n    \"destinationAta\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Associated Inscription in JavaScript\nDESCRIPTION: This snippet demonstrates initializing associated inscriptions in JavaScript. Each associated inscription is linked to an Inscription account via an `associationTag`. The main dependencies include '@metaplex-foundation/mpl-inscription' and the `umi` object. This process outputs multiple Associated Inscription Accounts, pointed to in the `inscriptionMetadata`.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/initialize.md#2025-04-17_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  findInscriptionMetadataPda,\n  initializeAssociatedInscription,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nawait initializeAssociatedInscription(umi, {\n  inscriptionMetadataAccount,\n  associationTag: 'image/png',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Authority Helper Functions Implementation\nDESCRIPTION: Collection of helper functions for checking various types of authorities over assets and plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/core-js-sdk-v1-0.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginAddressAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginOwnerAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority,\n  asset: AssetV1\n)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginUpdateAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority,\n  asset: AssetV1,\n  collection?: CollectionV1\n)\n```\n\n----------------------------------------\n\nTITLE: Adding an Oracle Plugin to a Collection in TypeScript\nDESCRIPTION: Demonstrates how to add an Oracle plugin to an existing MPL Core collection using TypeScript. The plugin is configured to validate update operations. Uses the @metaplex-foundation/umi and @metaplex-foundation/mpl-core libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addCollectionPlugin, CheckResult } from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('11111111111111111111111111111111')\nconst oracleAccount = publicKey('22222222222222222222222222222222')\n\nawait addCollectionPlugin(umi, {\n  collection: collection,\n  plugin: {\n    type: 'Oracle',\n    resultsOffset: {\n      type: 'Anchor',\n    },\n    lifecycleChecks: {\n      update: [CheckResult.CAN_REJECT],\n    },\n    baseAddress: oracleAccount,\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Freeze Escrow with Freeze Token Payment in JavaScript\nDESCRIPTION: This snippet initializes the Freeze Escrow account using the Freeze Token Payment guard, allowing a defined freeze period. The parameters require the mint account address, destination token address, and Candy Guard authority as a signer. The period is set for 15 days in this example.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: \"freezeTokenPayment\",\n  routeArgs: {\n    path: \"initialize\",\n    mint: tokenMint.publicKey,\n    destinationAta,\n    period: 15 * 24 * 60 * 60, // 15 days.\n    candyGuardAuthority: umi.identity,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Staking Delegates for Programmable NFTs in TypeScript\nDESCRIPTION: Demonstrates working with staking delegates, which can lock PNFTs to prevent transfers, burns, or delegate revocation until they're unlocked. This delegate type is designed for staking functionalities where assets need to be temporarily locked.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateStakingV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateStakingV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: stakingDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeStakingV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeStakingV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: stakingDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait lockV1(umi, {\n  mint,\n  authority: stakingDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unlockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unlockV1(umi, {\n  mint,\n  authority: stakingDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Downloading Metaplex Program Data\nDESCRIPTION: Bash commands to download specific Metaplex program binaries like Token Metadata, Bubblegum, and Core programs for local validator setup.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsolana program dump -u m metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s ~/.local/share/metaplex-local-validator/mpl-token-metadata.so\nsolana program dump -u m BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY ~/.local/share/metaplex-local-validator/mpl-bubblegum.so\nsolana program dump -u m CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d ~/.local/share/metaplex-local-validator/mpl-core.so\n```\n\n----------------------------------------\n\nTITLE: Creating Soulbound Asset using Token Metadata and Token22\nDESCRIPTION: Implementation example showing how to create a soulbound (non-transferrable) asset using Token Metadata with Token22 as the base SPL token. The code demonstrates account creation, initialization of non-transferrable extension, mint initialization, and token metadata creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/faq.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createV1 } from \"@metaplex-foundation/mpl-token-metadata\";\nimport { createAccount } from '@metaplex-foundation/mpl-toolbox';\nimport {\n  ExtensionType,\n  createInitializeMintInstruction,\n  getMintLen,\n  createInitializeNonTransferableMintInstruction,\n} from '@solana/spl-token';\nimport {\n  fromWeb3JsInstruction,\n  toWeb3JsPublicKey,\n} from '@metaplex-foundation/umi-web3js-adapters';\n\nconst SPL_TOKEN_2022_PROGRAM_ID: PublicKey = publicKey(\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'\n);\n\nconst umi = await createUmi();\nconst mint = generateSigner(umi);\n\nconst extensions = [ExtensionType.NonTransferable];\nconst space = getMintLen(extensions);\nconst lamports = await umi.rpc.getRent(space);\n\nconst createAccountIx = createAccount(umi, {\n  payer: umi.identity,\n  newAccount: mint,\n  lamports,\n  space,\n  programId: SPL_TOKEN_2022_PROGRAM_ID,\n}).getInstructions();\n\nconst createInitNonTransferableMintIx =\n  createInitializeNonTransferableMintInstruction(\n    toWeb3JsPublicKey(mint.publicKey),\n    toWeb3JsPublicKey(SPL_TOKEN_2022_PROGRAM_ID)\n  );\n\nconst createInitMintIx = createInitializeMintInstruction(\n  toWeb3JsPublicKey(mint.publicKey),\n  0,\n  toWeb3JsPublicKey(umi.identity.publicKey),\n  toWeb3JsPublicKey(umi.identity.publicKey),\n  toWeb3JsPublicKey(SPL_TOKEN_2022_PROGRAM_ID)\n);\n\nconst blockhash = await umi.rpc.getLatestBlockhash();\nconst tx = umi.transactions.create({\n  version: 0,\n  instructions: [\n    ...createAccountIx,\n    fromWeb3JsInstruction(createInitNonTransferableMintIx),\n    fromWeb3JsInstruction(createInitMintIx),\n  ],\n  payer: umi.identity.publicKey,\n  blockhash: blockhash.blockhash,\n});\n\nlet signedTx = await mint.signTransaction(tx);\nsignedTx = await umi.identity.signTransaction(signedTx);\nconst signature = await umi.rpc.sendTransaction(signedTx);\nawait umi.rpc.confirmTransaction(signature, {\n  strategy: { type: 'blockhash', ...blockhash },\n  commitment: 'confirmed',\n});\n\nawait createV1(umi, {\n  mint,\n  name: 'My Programmable NFT',\n  uri: 'https://example.com/my-programmable-nft.json',\n  sellerFeeBasisPoints: percentAmount(5.5),\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  splTokenProgram: SPL_TOKEN_2022_PROGRAM_ID,\n}).sendAndConfirm(umi);\n\nconst token = findAssociatedTokenPda(umi, {\n  mint: mint.publicKey,\n  owner: umi.identity.publicKey,\n  tokenProgramId: SPL_TOKEN_2022_PROGRAM_ID,\n});\n\nawait mintV1(umi, {\n  mint: mint.publicKey,\n  token,\n  tokenOwner: umi.identity.publicKey,\n  amount: 1,\n  splTokenProgram: SPL_TOKEN_2022_PROGRAM_ID,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Fetching Accounts in TypeScript\nDESCRIPTION: Demonstrates methods for checking account existence and fetching accounts via the Umi RpcInterface, which are essential operations for interacting with on-chain data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst accountExists = await umi.rpc.accountExists(myPublicKey);\nconst maybeAccount = await umi.rpc.getAccount(myPublicKey);\nconst maybeAccounts = await umi.rpc.getAccounts(myPublicKeys);\nconst accounts = await umi.rpc.getProgramAccounts(myProgramId, { filters });\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet DenyList in JavaScript for Royalties Plugin\nDESCRIPTION: This snippet demonstrates how to create a RuleSet DenyList in JavaScript for the Royalties Plugin. It defines a list of program public keys that are not allowed to interact with the MPL Core Asset/Collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst ruleSet = ruleSet('ProgramDenyList', [\n    [\n\t\tpublicKey(\"11111111111111111111111111111111\")\n\t\tpublicKey(\"22222222222222222222222222222222\")\n    ]\n])\n```\n\n----------------------------------------\n\nTITLE: Manual Dependency Configuration in Cargo.toml\nDESCRIPTION: Adding mpl-core dependency manually to the project's cargo.toml file\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n[dependencies]\nmpl-core = \"x.x.x\"\n```\n\n----------------------------------------\n\nTITLE: Defining Account Structure for Create Ticket Instruction in Rust\nDESCRIPTION: This code defines the account structure required for the Create Ticket instruction using Anchor's derive macro. It includes accounts for the signer, payer, manager, event, ticket, system program, and MPL core program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CreateTicket<'info> {\n   pub signer: Signer<'info>,\n   #[account(mut)]\n   pub payer: Signer<'info>,\n   #[account(\n       seeds = [MANAGER_SEEDS.as_bytes()],\n       bump = manager.bump\n   )]\n   pub manager: Account<'info, Manager>,\n   #[account(\n       mut,\n       constraint = event.update_authority == manager.key(),\n   )]\n   pub event: Account<'info, BaseCollectionV1>,\n   #[account(mut)]\n   pub ticket: Signer<'info>,\n   pub system_program: Program<'info, System>,\n   #[account(address = MPL_CORE_ID)]\n   /// CHECK: This is checked by the address constraint\n   pub mpl_core_program: UncheckedAccount<'info>\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Candy Machine Creation and NFT Minting in Solana using JavaScript\nDESCRIPTION: This comprehensive code example demonstrates the entire process of creating a Candy Machine with a mint limit guard and minting an NFT in Solana. It includes setup, collection NFT creation, Candy Machine creation with guards, and NFT minting to a recipient wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  addConfigLines,\n  create,\n  fetchCandyMachine,\n  mintV2,\n  mplCandyMachine,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  percentAmount,\n  publicKey,\n  sol,\n  some,\n  transactionBuilder,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createNft,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { base58 } from \"@metaplex-foundation/umi-serializers\";\nimport {\n  createMintWithAssociatedToken,\n  findAssociatedTokenPda,\n  setComputeUnitLimit,\n} from \"@metaplex-foundation/mpl-toolbox\";\n\n/**\n * This script demonstrates how to create a Candy Machine with a mint limit guard\n * and mint an NFT to a recipient wallet.\n */\n\n// Configuration\nconst RECIPIENT_ADDRESS = \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\";\nconst RPC_ENDPOINT = \"ENDPOINT\";\n\n(async () => {\n  try {\n    // --- Setup ---\n    \n    // Initialize connection to Solana\n    const umi = createUmi(RPC_ENDPOINT).use(mplCandyMachine());\n    const recipient = publicKey(RECIPIENT_ADDRESS);\n\n    // Create and fund a test wallet\n    const walletSigner = generateSigner(umi);\n    umi.use(keypairIdentity(walletSigner));\n    console.log(\"Funding test wallet with devnet SOL...\");\n    await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1), {\n      commitment: \"finalized\",\n    });\n\n    // --- Create Collection NFT ---\n    \n    const collectionMint = generateSigner(umi);\n    console.log(\"Creating collection NFT...\");\n    console.log(\"Collection Address:\", collectionMint.publicKey);\n\n    const createNftTx = await createNft(umi, {\n      mint: collectionMint,\n      authority: umi.identity,\n      name: \"My Collection NFT\",\n      uri: \"https://example.com/path/to/some/json/metadata.json\",\n      sellerFeeBasisPoints: percentAmount(9.99, 2),\n      isCollection: true,\n    }).sendAndConfirm(umi, {\n      confirm: { commitment: \"finalized\" },\n    });\n    console.log(\"Collection Created:\", base58.deserialize(createNftTx.signature)[0]);\n\n    // --- Create Candy Machine ---\n\n    console.log(\"Creating Candy Machine with mint limit guard...\");\n    const candyMachine = generateSigner(umi);\n    \n    const createCandyMachineV2Tx = await (\n      await create(umi, {\n        candyMachine,\n        tokenStandard: TokenStandard.NonFungible,\n        collectionMint: collectionMint.publicKey,\n        collectionUpdateAuthority: umi.identity,\n        itemsAvailable: 2,\n        sellerFeeBasisPoints: percentAmount(1.23),\n        creators: [\n          {\n            address: umi.identity.publicKey,\n            verified: false,\n            percentageShare: 100,\n          },\n        ],\n        guards: {\n          mintLimit: some({\n            id: 1,\n            limit: 2,\n          }),\n        },\n        configLineSettings: some({\n          prefixName: \"My NFT #\",\n          nameLength: 3,\n          prefixUri: \"https://example.com/\",\n          uriLength: 29,\n          isSequential: false,\n        }),\n      })\n    )\n      .add(\n        addConfigLines(umi, {\n          candyMachine: candyMachine.publicKey,\n          index: 0,\n          configLines: [\n            { name: \"1\", uri: \"https://example.com/nft1.json\" },\n            { name: \"2\", uri: \"https://example.com/nft2.json\" },\n          ],\n        })\n      )\n      .sendAndConfirm(umi, { confirm: { commitment: \"finalized\" } });\n      \n    console.log(\"Candy Machine Created:\", base58.deserialize(createCandyMachineV2Tx.signature)[0]);\n\n    // --- Mint NFT ---\n\n    console.log(\"Minting NFT to recipient...\");\n    \n    // Get latest Candy Machine state\n    const candyMachineAccount = await fetchCandyMachine(umi, candyMachine.publicKey);\n\n    // Create mint transaction\n    const nftMint = generateSigner(umi);\n    const mintTx = await transactionBuilder()\n      .add(setComputeUnitLimit(umi, { units: 800_000 }))\n      .add(\n        createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient })\n      )\n      .add(\n        mintV2(umi, {\n          candyMachine: candyMachineAccount.publicKey,\n          nftMint,\n          token: findAssociatedTokenPda(umi, {\n            mint: nftMint.publicKey,\n            owner: recipient,\n          }),\n          collectionMint: candyMachineAccount.collectionMint,\n          collectionUpdateAuthority: candyMachineAccount.authority,\n          tokenStandard: TokenStandard.NonFungible,\n          mintArgs: {\n            mintLimit: some({\n              id: 1,\n            }),\n          },\n        })\n      )\n      .sendAndConfirm(umi, {\n        confirm: { commitment: \"finalized\" },\n      });\n\n    console.log(\"NFT Minted Successfully!\");\n    console.log(\"Mint Transaction:\", base58.deserialize(mintTx.signature)[0]);\n\n  } catch (error) {\n    console.error(\"Failed to execute:\", error);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Getting Asset Information - cURL\nDESCRIPTION: This snippet shows how to retrieve asset information using a cURL command. It sends a POST request to the DAS API endpoint with the necessary parameters including the asset ID and specifies the method 'getAsset'. The content type is set to JSON to ensure proper formatting of the request. Expected input is the asset ID, and the output will be the asset information returned by the API.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset.md#2025-04-17_snippet_1\n\nLANGUAGE: cURL\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAsset\",\n    \"params\": [\n      \"8vw7tdLGE3FBjaetsJrZAarwsbc8UESsegiLyvWXxs5A\"\n    ],\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Validating Assets with Sugar CLI\nDESCRIPTION: This command checks that all files in the assets folder are in the correct format. It can be run with default settings or with a specified assets folder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/validate.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar validate\n```\n\nLANGUAGE: bash\nCODE:\n```\nsugar validate <ASSETS FOLDER>\n```\n\n----------------------------------------\n\nTITLE: Checking Bundlr Network Balance with Sugar CLI\nDESCRIPTION: This command retrieves the balance of the current keypair on the Bundlr Network. It can be used to verify remaining funds after uploads.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/bundlr.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar bundlr balance\n```\n\n----------------------------------------\n\nTITLE: Minting with Sol Fixed Fee Guard in TypeScript\nDESCRIPTION: This snippet shows how to mint with the Sol Fixed Fee Guard by providing the necessary mint arguments. It specifies the destination for the fee payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/sol-fixed-fee.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    solFixedFee: some({ destination: treasury }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Burning pNFT using Rust MPL SDK (CPI)\nDESCRIPTION: This snippet shows how to burn a programmable NFT (pNFT) using the Metaplex Program Library (MPL) SDK in Rust via Cross-Program Invocation (CPI). It demonstrates the use of BurnNftCpiBuilder to construct and invoke the burn instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n\nBurnNftCpiBuilder::new(metadata_program_id.account_info())\n        .metadata(metadata.account_info())\n        .collection_metadata(Some(collection_metadata.account_info()))\n        .owner(owner.account_info())\n        .mint(mint.account_info())\n        .token_account(token.account_info())\n        .master_edition_account(edition.account_info())\n        .spl_token_program(spl_token.account_info())\n        .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Retrieving Assets by Group using JavaScript and Umi\nDESCRIPTION: This snippet demonstrates how to fetch assets by group using the DAS API with JavaScript. It imports necessary modules from Metaplex, creates a Umi instance, and calls the getAssetsByGroup method to retrieve assets that belong to a specific collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-by-group.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst assets = await umi.rpc.getAssetsByGroup({\n    groupKey: 'collection',\n    groupValue: 'J2ZfLdQsaZ3GCmbucJef3cPnPwGcgjDW1SSYtMdq3L9p',\n});\nconsole.log(assets.items.length > 0);\n```\n\n----------------------------------------\n\nTITLE: Minting with Token Burn Guard in TypeScript\nDESCRIPTION: This code shows how to mint from a Candy Machine that uses the Token Burn guard. The mint instruction needs to specify the token mint address in the mintArgs parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-burn.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    tokenBurn: some({ mint: tokenMint.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Asset by Mint\nDESCRIPTION: Helper function to fetch a single Digital Asset using its Mint account public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchDigitalAsset } from '@metaplex-foundation/mpl-token-metadata'\n\nconst asset = await fetchDigitalAsset(umi, mint)\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet Allowlist in JavaScript for Royalties Plugin\nDESCRIPTION: This snippet demonstrates how to create a RuleSet Allowlist in JavaScript for the Royalties Plugin. It defines a list of program public keys that are allowed to interact with the MPL Core Asset/Collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst ruleSet = ruleSet('ProgramAllowList', [\n    [\n\t\tpublicKey(\"11111111111111111111111111111111\")\n\t\tpublicKey(\"22222222222222222222222222222222\")\n    ]\n])\n```\n\n----------------------------------------\n\nTITLE: Defining Creators Array in JavaScript for Royalties Plugin\nDESCRIPTION: This snippet demonstrates how to create an array of creators for the Royalties Plugin using JavaScript. It defines two creators with their respective public keys and percentage shares.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\n\nconst creators = [\n    { address: publicKey(\"11111111111111111111111111111111\"), percentage: 80 }\n    { address: publicKey(\"22222222222222222222222222222222\"), percentage: 20 }\n]\n```\n\n----------------------------------------\n\nTITLE: Converting Messages from Web3.js to Umi for Solana Transactions in TypeScript\nDESCRIPTION: This snippet demonstrates how to convert a message from Web3.js format to Umi format using an adapter function. It includes creating a versioned transaction message in Web3.js. It requires the @solana/web3.js and @metaplex-foundation/umi-web3js-adapters packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TransactionMessage } from '@solana/web3.js';\nimport { fromWeb3JMessage } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Create a new Versioned Transaction\nconst Web3JsMessage = new TransactionMessage({...createMessageParams}).compileToV0Message();\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiMessage = fromWeb3JMessage(Web3JsMessage);\n```\n\n----------------------------------------\n\nTITLE: Adding Config Lines with Prefixes in JavaScript\nDESCRIPTION: Shows how to insert items when using name and URI prefixes, where only the part after the prefix needs to be provided, saving transaction space and allowing more items per transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/insert-items.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: candyMachine.itemsLoaded,\n  configLines: [\n    { name: '1', uri: '1.json' },\n    { name: '2', uri: '2.json' },\n    { name: '3', uri: '3.json' },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Tuple Serialization in TypeScript\nDESCRIPTION: Examples of using the tuple serializer with various data types\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\ntuple([bool()]); // Serializer<[bool]>\ntuple([string(), u8()]); // Serializer<[string, number]>\ntuple([publicKey(), u64()]); // Serializer<[PublicKey, number | bigint], [PublicKey, bigint]>\n```\n\n----------------------------------------\n\nTITLE: Defining Account Structure\nDESCRIPTION: Account structure definition with required accounts and constraints for Core NFT Asset creation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CreateAsset<'info> {\n    #[account(mut)]\n    pub asset: Signer<'info>,\n    #[account(mut)]\n    pub collection: Option<Account<'info, BaseCollectionV1>>,\n    pub authority: Option<Signer<'info>>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    /// CHECK: this account will be checked by the mpl_core program\n    pub owner: Option<UncheckedAccount<'info>>,\n    /// CHECK: this account will be checked by the mpl_core program\n    pub update_authority: Option<UncheckedAccount<'info>>,\n    pub system_program: Program<'info, System>,\n    #[account(address = MPL_CORE_ID)]\n    /// CHECK: this account is checked by the address constraint\n    pub mpl_core_program: UncheckedAccount<'info>,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Freeze Sol Payment Guard in Sugar JSON\nDESCRIPTION: This JSON snippet shows how to configure the Freeze Sol Payment guard in the Sugar config.json file. It specifies the SOL value and destination public key for payments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"freezeSolPayment\" : {\n    \"value\": SOL value,\n    \"destination\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Transaction Signature Manually in TypeScript\nDESCRIPTION: Demonstrates how to use the addTransactionSignature helper function to manually add a signature to a transaction. This is useful when implementing a custom Signer's signTransaction method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = addTransactionSignature(myTransaction, mySignature, myPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Config Line Settings in TypeScript\nDESCRIPTION: This snippet demonstrates creating a Candy Machine with specific config line settings, including name and URI prefixes and lengths. It showcases how to set up the configuration for inserting items with prefixes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/insert-items.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait create(umi, {\n  // ...\n  configLineSettings: some({\n    prefixName: 'My NFT #',\n    nameLength: 4,\n    prefixUri: 'https://example.com/nft',\n    uriLength: 9,\n    isSequential: false,\n  }),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Project Dependencies\nDESCRIPTION: Required npm dependencies for implementing the staking system using Metaplex Core SDK and Umi framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"dependencies\": {\n        \"@metaplex-foundation/mpl-core\": \"1.1.0-alpha.0\",\n        \"@metaplex-foundation/mpl-token-metadata\": \"^3.2.1\",\n        \"@metaplex-foundation/umi-bundle-defaults\": \"^0.9.1\",\n        \"bs58\": \"^5.0.0\",\n        \"typescript\": \"^5.4.5\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection with an Oracle Plugin in TypeScript\nDESCRIPTION: Demonstrates how to create a new MPL Core collection with an Oracle plugin that can validate and potentially reject update operations. Uses the @metaplex-foundation/umi and @metaplex-foundation/mpl-core libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport {\n  create,\n  CheckResult\n  } from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\nconst oracleAccount = publicKey('11111111111111111111111111111111')\n\nconst collection = await createCollection(umi, {\n    ... CreateCollectionArgs,\n    plugins: [\n        {\n        type: 'Oracle',\n        resultsOffset: {\n          type: 'Anchor',\n        },\n        baseAddress: oracleAccount,\n        lifecycleChecks: {\n          update: [CheckResult.CAN_REJECT],\n        },\n        baseAddressConfig: undefined,\n      },\n    ],\n  });.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Getting Leaf Schema from Mint Transaction\nDESCRIPTION: Shows how to retrieve the leaf schema and asset ID from a mintV1 transaction using parseLeafFromMintV1Transaction helper after transaction finalization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/mint-cnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    findLeafAssetIdPda,\n    mintV1,\n    parseLeafFromMintV1Transaction\n} from \"@metaplex-foundation/mpl-bubblegum\";\n\nconst { signature } = await mintV1(umi, {\n  leafOwner,\n  merkleTree,\n  metadata,\n}).sendAndConfirm(umi, { confirm: { commitment: \"confirmed\" } });\n\nconst leaf: LeafSchema = await parseLeafFromMintV1Transaction(umi, signature);\nconst assetId = findLeafAssetIdPda(umi, { merkleTree, leafIndex: leaf.nonce });\n// or const assetId = leaf.id;\n```\n\n----------------------------------------\n\nTITLE: Updating Collection as Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This snippet illustrates how a Collection Delegate can update the collection attribute of an asset using the updateAsCollectionDelegateV2 function. It demonstrates setting a new collection for the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsCollectionDelegateV2,\n  collectionToggle,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nawait updateAsCollectionDelegateV2(umi, {\n  mint,\n  authority: collectionDelegate,\n  collection: collectionToggle('Set', [\n    { key: collectionMint, verified: false },\n  ]),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Rendering Kinobi Tree in JavaScript\nDESCRIPTION: Creates a Kinobi instance using IDL files and renders a Umi-compatible library using the RenderJavaScriptVisitor. The Kinobi tree is updated via visitors to tailor it before rendering the JavaScript. Dependencies include Kinobi and the path to IDL files. It outputs generated JavaScript libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFromIdls, RenderJavaScriptVisitor } from \"@metaplex-foundation/kinobi\";\n\n// Instantiate Kinobi.\nconst kinobi = createFromIdls([\n  path.join(__dirname, \"idls\", \"my_idl.json\"),\n  path.join(__dirname, \"idls\", \"my_other_idl.json\"),\n]);\n\n// Update the Kinobi tree using visitors...\n\n// Render JavaScript.\nconst jsDir = path.join(__dirname, \"clients\", \"js\", \"src\", \"generated\");\nkinobi.accept(new RenderJavaScriptVisitor(jsDir));\n```\n\n----------------------------------------\n\nTITLE: Implementing initialize_airdrop_data Instruction in Rust\nDESCRIPTION: Implements the initialize_airdrop_data instruction to populate the AirdropState, mint tokens to the vault, and revoke mint authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub fn initialize_airdrop_data(\n  ctx: Context<Initialize>, \n  merkle_root: [u8; 32],\n  amount: u64,\n) -> Result<()> {\n\n  ctx.accounts.airdrop_state.set_inner(\n    AirdropState {\n      merkle_root,\n      authority: ctx.accounts.authority.key(),\n      mint: ctx.accounts.mint.key(),\n      airdrop_amount: amount,\n      amount_claimed: 0,\n      bump: ctx.bumps.airdrop_state,\n    }\n  );\n\n  mint_to(\n    CpiContext::new(\n      ctx.accounts.token_program.to_account_info(), \n      MintTo {\n          mint: ctx.accounts.mint.to_account_info(),\n          to: ctx.accounts.vault.to_account_info(),\n          authority: ctx.accounts.authority.to_account_info(),\n      }\n    ),\n    amount\n  )?;\n\n  set_authority(\n    CpiContext::new(\n      ctx.accounts.token_program.to_account_info(), \n      SetAuthority {\n          current_authority: ctx.accounts.authority.to_account_info(),\n          account_or_mint: ctx.accounts.mint.to_account_info(),\n      }\n    ), \n    AuthorityType::MintTokens,\n    None\n  )?;\n\n  Ok(())\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n  #[account(\n    init, \n    seeds = [b\"merkle_tree\".as_ref(), mint.key().to_bytes().as_ref()],\n    bump,\n    payer = authority, \n    space = 8 + 32 + 32 + 32 + 8 + 8 + 1\n  )]\n  pub airdrop_state: Account<'info, AirdropState>,\n  #[account(mut)]\n  pub mint: Account<'info, Mint>,\n  #[account(\n    init_if_needed,\n    payer = authority,\n    associated_token::mint = mint,\n    associated_token::authority = airdrop_state,\n  )]\n  pub vault: Account<'info, TokenAccount>,\n  #[account(mut)]\n  pub authority: Signer<'info>,\n  pub system_program: Program<'info, System>,\n  pub token_program: Program<'info, Token>,\n  pub associated_token_program: Program<'info, AssociatedToken>,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Create Ticket Arguments Structure in Rust\nDESCRIPTION: This code defines the structure for the arguments passed to the Create Ticket instruction. It includes fields for ticket details such as name, URI, hall, section, row, seat, price, and venue authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateTicketArgs {\n   pub name: String,\n   pub uri: String,\n   pub hall: String,\n   pub section: String,\n   pub row: String,\n   pub seat: String,\n   pub price: u64,\n   pub venue_authority: Pubkey,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Validator with Relay and Storage in JavaScript\nDESCRIPTION: Example configuration for Amman validator with relay and storage settings. Includes default values and program deployment configuration. The relay is automatically launched with the validator except in CI environments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/configuration.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { LOCALHOST, tmpLedgerDir } from '@metaplex-foundation/amman'\n\nmodule.exports = {\n  validator: {\n    killRunningValidators: true,\n    programs: [\n      {\n        label: 'Token Metadata Program',\n        programId: programIds.metadata,\n        deployPath: localDeployPath('mpl_token_metadata'),\n      },\n    ],\n    jsonRpcUrl: LOCALHOST,\n    websocketUrl: '',\n    commitment: 'confirmed',\n    ledgerDir: tmpLedgerDir(),\n    resetLedger: true,\n    verifyFees: false,\n    detached: process.env.CI != null,\n  },\n  relay: {\n    enabled: process.env.CI == null,\n    killRunningRelay: true,\n  },\n  storage: {\n    enabled: process.env.CI == null,\n    storageId: 'mock-storage',\n    clearOnStart: true,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Transaction on Solana\nDESCRIPTION: This snippet shows how to send a transaction to the Solana blockchain using the @solana/web3.js library. It includes an asynchronous function that sends a transaction and logs the resulting signature.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rpcs-and-das.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nasync function sendTransaction(transaction, payer) {\n  const signature = await solanaWeb3.sendAndConfirmTransaction(connection, transaction, [payer]);\n  console.log(`Transaction signature: ${signature}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Ticket Data using Digital Asset Standard\nDESCRIPTION: Demonstrates how to retrieve ticket-related data from a digital asset using the DAS API.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst ticketData = await fetchAsset(umi, ticket);\nconsole.log(\"\\nThis are all the ticket-related data: \", ticketData.attributes);\n```\n\n----------------------------------------\n\nTITLE: Thawing an MPL Core Asset using Rust CPI\nDESCRIPTION: This snippet shows how to thaw a frozen asset using Rust CPI (Cross-Program Invocation). It uses the UpdatePluginV1CpiBuilder to set the FreezeDelegate plugin to 'frozen: false', effectively thawing the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nUpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    // Set the FreezeDelegate plugin to `frozen: false`\n    .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n    .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine Configuration with Sugar CLI\nDESCRIPTION: This command starts an interactive process to create a Candy Machine configuration file. It prompts for various configuration options and saves the result to a file (default: config.json).\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/config.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar config create\n```\n\n----------------------------------------\n\nTITLE: Fetching Mint and Token Accounts in Solana using Umi\nDESCRIPTION: These functions demonstrate how to fetch information about Mint and Token accounts using Umi. It includes fetching individual Mint and Token accounts, Associated Token accounts, and fetching all tokens or mints by owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchMint,\n  fetchToken,\n  findAssociatedTokenPda,\n  fetchAllTokenByOwner,\n  fetchAllMintByOwner,\n  fetchAllMintPublicKeyByOwner,\n} from '@metaplex-foundation/mpl-toolbox'\n\n// Fetch Mint account.\nconst mintAccount = await fetchMint(umi, mint)\n\n// Fetch Token account.\nconst tokenAccount = await fetchToken(umi, token)\n\n// Fetch Associated Token account.\nconst [associatedToken] = findAssociatedTokenPda(umi, { owner, mint })\nconst associatedTokenAccount = await fetchToken(umi, associatedToken)\n\n// Fetch by owner.\nconst tokensFromOwner = await fetchAllTokenByOwner(umi, owner)\nconst mintsFromOwner = await fetchAllMintByOwner(umi, owner)\nconst mintKeysFromOwner = await fetchAllMintPublicKeyByOwner(umi, owner)\n```\n\n----------------------------------------\n\nTITLE: Defining Data Object for Token Metadata Update\nDESCRIPTION: Structure definition for the Data object that contains basic metadata like name, symbol, URI, fees and creators that can be updated.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst data = {\n  name: 'New Name',\n  symbol: 'New Symbol',\n  uri: 'https://newuri.com',\n  sellerFeeBasisPoints: 500,\n  creators: [],\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub struct DataV2 {\n    pub name: String,\n    pub symbol: String,\n    pub uri: String,\n    pub seller_fee_basis_points: u16,\n    pub creators: Option<Vec<Creator>>,\n    pub collection: Option<Collection>,\n    pub uses: Option<Uses>,\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds from Freeze Escrow using Sugar CLI in Metaplex\nDESCRIPTION: This shell command shows how to unlock funds from the Freeze Escrow Account using the Sugar CLI tool in a Metaplex Candy Machine implementation. It includes various optional parameters for configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nsugar freeze unlock-funds\n```\n\n----------------------------------------\n\nTITLE: Checking Sugar CLI Version\nDESCRIPTION: Verifies the installed version of Sugar CLI on the system. Expected output shows version number like 'sugar-cli 2.5.0'.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar --version\n```\n\n----------------------------------------\n\nTITLE: Unverifying Creator of Compressed NFT in TypeScript\nDESCRIPTION: This code snippet shows how to unverify a creator for a Compressed NFT using the Bubblegum program. It uses the getAssetWithProof and unverifyCreator functions from the mpl-bubblegum package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/verify-creators.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  unverifyCreator,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait unverifyCreator(umi, { ...assetWithProof, creator }).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Unverifying Creator Using Token Metadata SDK\nDESCRIPTION: Shows how to unverify a creator for an asset using the unverifyCreatorV1 function from the mpl-token-metadata package. Takes the same parameters as verification - metadata account address and creator authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/creators.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unverifyCreatorV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unverifyCreatorV1(umi, {\n  metadata,\n  authority: creator,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Asset Burn Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a Candy Machine with the Asset Burn guard. It sets the required collection for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-burn.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetBurn: some({ requiredCollection: requiredCollection.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Transferring All SOL Using Umi in TypeScript\nDESCRIPTION: This snippet shows how to transfer all SOL from one account to another using Umi. This is useful for draining an account while still using it to pay for the transaction, avoiding manual balance calculations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/transfer-sol.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { transferAllSol } from '@metaplex-foundation/mpl-toolbox'\n\nconst destination = publicKey(`11111111111111111111111`)\n\nawait transferAllSol(umi, {\n  source: umi.identity,\n  destination,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Adding Collection Plugin with Authority using JavaScript and UMI\nDESCRIPTION: This snippet demonstrates how to add a collection plugin with an assigned authority using the Metaplex Foundation's UMI library in JavaScript. It creates an 'Attributes' type plugin with a specified key-value pair and assigns an authority address to the plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport {\n  addCollectionPlugin,\n  ruleSet,\n} from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('11111111111111111111111111111111')\nconst delegate = publicKey('22222222222222222222222222222222')\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'Attributes',\n    attributeList: [{ key: 'key', value: 'value' }],\n    authority: {\n      type: 'Address',\n      address: delegate,\n    },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring SOL From Asset Signer in JavaScript\nDESCRIPTION: This example demonstrates how to transfer SOL from an Asset Signer PDA to a destination address using the execute instruction and transferSol function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/execute-asset-signing.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  execute,\n  findAssetSignerPda,\n  fetchAsset,\n  fetchCollection,\n} from '@metaplex-foundation/mpl-core'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox'\nimport { publickey, createNoopSigner, sol } from '@metaplex-foundation/umi'\n\nconst assetId = publickey('11111111111111111111111111111111')\n\nconst asset = await fetchAsset(umi, assetId)\n\n// Optional - If Asset is part of collection fetch the collection object\nconst collection =\n  asset.updateAuthority.type == 'Collection' && asset.updateAuthority.address\n    ? await fetchCollection(umi, asset.updateAuthority.address)\n    : undefined\n\n// Asset signer has a balance of 1 SOL in the account.\nconst assetSignerPda = findAssetSignerPda(umi, { asset: assetId })\n\n// Destination account we wish to transfer the SOL to.\nconst destination = publickey('2222222222222222222222222222222222')\n\n// A standard `transferSol()` transactionBuilder.\nconst transferSolIx = transferSol(umi, {\n  // Create a noopSigner as the assetSigner will sign later during CPI\n  source: createNoopSigner(publicKey(assetSigner)),\n  // Destination address\n  destination,\n  // Amount you wish to transfer\n  amount: sol(0.5),\n})\n\n// Call the `execute` instruction and send to the chain.\nconst res = await execute(umi, {\n  // Execute instruction(s) with this asset\n  asset,\n  // If Asset is part of collection pass in collection object via `fetchCollection()`\n  collection,\n  // The transactionBuilder/instruction[] to execute\n  instructions: transferSolIx,\n}).sendAndConfirm(umi)\n\nconsole.log({ res })\n```\n\n----------------------------------------\n\nTITLE: Setting up a Candy Machine with Sol Payment Guard in JavaScript\nDESCRIPTION: Creates a Candy Machine with a Sol Payment guard configured to charge 1.5 SOL and send the payment to the current identity's wallet address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/sol-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    solPayment: some({\n      lamports: sol(1.5),\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Guard Groups in a Candy Machine in TypeScript\nDESCRIPTION: This code demonstrates how to update an existing Candy Machine's guard groups. It fetches the current guard data and updates the 'late' group to charge 3 SOL instead of 2 SOL while preserving other settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guard-groups.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, sol, dateTime } from '@metaplex-foundation/umi'\n\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\nawait updateCandyGuard(umi, {\n  candyGuard: candyGuard.publicKey,\n  guards: candyGuard.guards,\n  groups: [\n    {\n      label: 'early',\n      guards: {\n        solPayment: some({ lamports: sol(1), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T16:00:00Z') }),\n        endDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n    {\n      label: 'late',\n      guards: {\n        solPayment: some({ lamports: sol(3), destination: treasury }),\n        startDate: some({ date: dateTime('2022-10-18T17:00:00Z') }),\n        botTax: some({ lamports: sol(0.001), lastInstruction: true }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Allocation Guard in JavaScript\nDESCRIPTION: Mints an NFT from a Candy Machine with Allocation guard by providing the required ID in the mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allocation.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    allocation: some({ id: 1 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching MPL Core Asset Data with DAS API in JSON\nDESCRIPTION: This JSON snippet demonstrates the structure and content of a response when fetching an MPL Core Asset using the Digital Asset Standard (DAS) API. It includes detailed information about the asset such as authorities, compression status, content metadata, creators, grouping, ownership, plugins, and royalty information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"authorities\": [\n      {\n        \"address\": \"Gi47RpRmg3wGsRRzFvcmyXHkELHznpx6DxEELGWBRWoC\",\n        \"scopes\": [\"full\"]\n      }\n    ],\n    \"burnt\": false,\n    \"compression\": {\n      \"asset_hash\": \"\",\n      \"compressed\": false,\n      \"creator_hash\": \"\",\n      \"data_hash\": \"\",\n      \"eligible\": false,\n      \"leaf_id\": 0,\n      \"seq\": 0,\n      \"tree\": \"\"\n    },\n    \"content\": {\n      \"$schema\": \"https://schema.metaplex.com/nft1.0.json\",\n      \"files\": [],\n      \"json_uri\": \"https://example.com/asset\",\n      \"links\": {},\n      \"metadata\": {\n        \"name\": \"Test Asset\",\n        \"symbol\": \"\"\n      }\n    },\n    \"creators\": [],\n    \"grouping\": [\n      {\n        \"group_key\": \"collection\",\n        \"group_value\": \"8MPNmg4nyMGKdStSxbo2r2aoQGWz1pdjtYnQEt1kA2V7\"\n      }\n    ],\n    \"id\": \"99A5ZcoaRSTGRigMpeu1u4wdgQsv6NgTDs5DR2Ug9TCQ\",\n    \"interface\": \"MplCore\",\n    \"mutable\": true,\n    \"ownership\": {\n      \"delegate\": null,\n      \"delegated\": false,\n      \"frozen\": false,\n      \"owner\": \"Gi47RpRmg3wGsRRzFvcmyXHkELHznpx6DxEELGWBRWoC\",\n      \"ownership_model\": \"single\"\n    },\n    \"plugins\": {\n      \"FreezeDelegate\": {\n        \"authority\": {\n          \"Pubkey\": {\n            \"address\": \"Gi47RpRmg3wGsRRzFvcmyXHkELHznpx6DxEELGWBRWoC\"\n          }\n        },\n        \"data\": {\n          \"frozen\": false\n        },\n        \"index\": 0,\n        \"offset\": 119\n      }\n    },\n    \"royalty\": {\n      \"basis_points\": 0,\n      \"locked\": false,\n      \"percent\": 0,\n      \"primary_sale_happened\": false,\n      \"royalty_model\": \"creators\",\n      \"target\": null\n    },\n    \"supply\": null,\n    \"unknown_plugins\": [\n      {\n        \"authority\": {\n          \"Pubkey\": {\n            \"address\": \"Gi47RpRmg3wGsRRzFvcmyXHkELHznpx6DxEELGWBRWoC\"\n          }\n        },\n        \"data\": \"CQA=\",\n        \"index\": 1,\n        \"offset\": 121,\n        \"type\": 9\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Metaplex Core Types in Rust\nDESCRIPTION: This snippet shows the necessary imports from the mpl_core crate to use plugins and external plugin adapters when creating a Core Asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::\n    Plugin, FreezeDelegate, PluginAuthority,\n    ExternalPluginAdapterInitInfo, AppDataInitInfo, \n    ExternalPluginAdapterSchema;\n```\n\n----------------------------------------\n\nTITLE: Configuring NFT Burn Guard in Sugar's config.json\nDESCRIPTION: This JSON configuration shows how to add the NFT Burn guard to a Candy Machine using Sugar. It requires specifying the public key of the collection NFT that will be eligible for burning during minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-burn.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"nftBurn\" : {\n    \"requiredCollection\": \"<PUBKEY>\",\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Multiple Transactions with Multiple Signers in TypeScript\nDESCRIPTION: Illustrates the use of the signAllTransactions function to sign multiple transactions, each with one or more signers. This method optimizes the signing process when a signer needs to sign multiple transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// In this example, mySigner2 will sign both transactions\n// using the signAllTransactions method.\nconst mySignedTransactions = await signAllTransactions([\n  { transaction: myFirstTransaction, signers: [mySigner1, mySigner2] },\n  { transaction: mySecondTransaction, signers: [mySigner2, mySigner3] }\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining ScanTicket Accounts Structure in Rust\nDESCRIPTION: This struct defines the necessary accounts for the Scan Ticket instruction, ensuring all required accounts for the transaction are included and checked. It specifies constraints on the ticket and event accounts to maintain security and integrity over asset ownership and authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct ScanTicket<'info> {\n   pub owner: Signer<'info>,\n   pub signer: Signer<'info>,\n   #[account(mut)]\n   pub payer: Signer<'info>,\n   #[account(\n       seeds = [MANAGER_SEEDS.as_bytes()],\n       bump = manager.bump\n   )]\n   pub manager: Account<'info, Manager>,\n   #[account(\n       mut,\n       constraint = ticket.owner == owner.key(),\n       constraint = ticket.update_authority == UpdateAuthority::Collection(event.key()),\n   )]\n   pub ticket: Account<'info, BaseAssetV1>,\n   #[account(\n       mut,\n       constraint = event.update_authority == manager.key(),\n   )]\n   pub event: Account<'info, BaseCollectionV1>,\n   pub system_program: Program<'info, System>,\n   #[account(address = MPL_CORE_ID)]\n   /// CHECK: This is checked by the address constraint\n   pub mpl_core_program: UncheckedAccount<'info>,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Plugins for Core Asset Creation in Rust\nDESCRIPTION: This code sets up vectors for plugins and external plugin adapters, demonstrating how to add the FreezeDelegate plugin and AppData external plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet mut plugins: Vec<PluginAuthorityPair> = vec![];\n\nplugins.push(\n  PluginAuthorityPair { \n      plugin: Plugin::FreezeDelegate(FreezeDelegate {frozen: true}), \n      authority: Some(PluginAuthority::UpdateAuthority) \n  }\n);\n\nlet mut external_plugin_adapters: Vec<ExternalPluginAdapterInitInfo> = vec![];\n    \nexternal_plugin_adapters.push(\n  ExternalPluginAdapterInitInfo::AppData(\n    AppDataInitInfo {\n      init_plugin_authority: Some(PluginAuthority::UpdateAuthority),\n      data_authority: PluginAuthority::Address{ address: data_authority },\n      schema: Some(ExternalPluginAdapterSchema::Binary),\n    }\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Create Event Function in Rust using Metaplex Core\nDESCRIPTION: This function implements the Create Event instruction. It creates a collection asset using Metaplex Core, adding attributes for event details and setting up the necessary plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_event(ctx: Context<CreateEvent>, args: CreateEventArgs) -> Result<()> {\n    // Add an Attribute Plugin that will hold the event details\n    let mut collection_plugin: Vec<PluginAuthorityPair> = vec![];\n\n    let attribute_list: Vec<Attribute> = vec![\n        Attribute { \n            key: \"City\".to_string(), \n            value: args.city \n        },\n        Attribute { \n            key: \"Venue\".to_string(), \n            value: args.venue \n        },\n        Attribute { \n            key: \"Artist\".to_string(), \n            value: args.artist \n        },\n        Attribute { \n            key: \"Date\".to_string(), \n            value: args.date \n        },\n        Attribute { \n            key: \"Time\".to_string(), \n            value: args.time \n        },\n        Attribute { \n            key: \"Capacity\".to_string(), \n            value: args.capacity.to_string() \n        }\n    ];\n    \n    collection_plugin.push(\n        PluginAuthorityPair { \n            plugin: Plugin::Attributes(Attributes { attribute_list }), \n            authority: Some(PluginAuthority::UpdateAuthority) \n        }\n    );\n    \n    // Create the Collection that will hold the tickets\n    CreateCollectionV2CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n    .collection(&ctx.accounts.event.to_account_info())\n    .update_authority(Some(&ctx.accounts.manager.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .name(args.name)\n    .uri(args.uri)\n    .plugins(collection_plugin)\n    .invoke()?\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a new npm project\nDESCRIPTION: This command initializes a new Node.js project using npm. It creates a `package.json` file that contains metadata about the project and its dependencies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n\"npm init\"\n```\n\n----------------------------------------\n\nTITLE: Invoking a CPI call with invoke() in Rust\nDESCRIPTION: Demonstrates how to execute a CPI call using the invoke() method, which does not involve any PDA signer seeds, highlighting its simplicity for certain transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1CpiBuilder::new()\n        .asset(context.accounts.asset)\n        ...\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Writing Data to AppData Plugin\nDESCRIPTION: Examples showing how to write data to the AppData plugin using both TypeScript and Rust implementations\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nawait writeData(umi, {\n  key: {\n    type: 'AppData',\n    dataAuthority,\n  },\n  authority: dataAuthoritySigner,\n  data: data,\n  asset: asset.publicKey,\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet write_to_app_data_plugin_ix = WriteExternalPluginAdapterDataV1CpiBuilder::new()\n    .asset(asset)\n    .collection(collection)\n    .payer(payer)\n    .authority(authority)\n    .buffer(None)\n    .system_program(system_program)\n    .log_wrapper(None)\n    .key(ExternalPluginAdapterKey::AppData(PluginAuthority::Address {address: plugin_authority.key()}))\n    .data(data)\n    .instruction()\n```\n\n----------------------------------------\n\nTITLE: Getting Account Balance in TypeScript\nDESCRIPTION: Shows how to retrieve the SOL balance of any account using the Umi RpcInterface, returning a SolAmount object. Key input is the account's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst balance = await umi.rpc.getBalance(myPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Minting with Freeze Token Payment Guard in JavaScript/TypeScript\nDESCRIPTION: This code snippet shows how to provide the necessary mint arguments when minting an NFT with a Freeze Token Payment guard. It passes the token mint and destination token account as mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    freezeTokenPayment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Converting Leaf Schema to Merkle Tree Node in Bubblegum\nDESCRIPTION: This implementation for LeafSchema converts a leaf schema into a 32-byte Merkle tree node. It hashes all fields of the schema using keccak-256 to produce the final node value that will be stored in the Merkle tree. The method handles versioning through pattern matching.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/hashed-nft-data.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl LeafSchema {\n    pub fn to_node(&self) -> Node {\n        let hashed_leaf = match self {\n            LeafSchema::V1 {\n                id,\n                owner,\n                delegate,\n                nonce,\n                data_hash,\n                creator_hash,\n            } => keccak::hashv(&[\n                &[self.version().to_bytes()],\n                id.as_ref(),\n                owner.as_ref(),\n                delegate.as_ref(),\n                nonce.to_le_bytes().as_ref(),\n                data_hash.as_ref(),\n                creator_hash.as_ref(),\n            ])\n            .to_bytes(),\n        };\n        hashed_leaf\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using an Existing Local Wallet\nDESCRIPTION: Demonstrates how to load an existing wallet from a local JSON file and configure it with Umi\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://api.devnet.solana.com\")\n\t.use(mplTokenMetadata())\n\t.use(mplToolbox());\n\n// You will need to us fs and navigate the filesystem to\n// load the wallet you wish to use via relative pathing.\nconst walletFile = const imageFile = fs.readFileSync('./keypair.json')\n\n// Convert your walletFile onto a keypair.\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\n// Load the keypair into umi.\numi.use(keypairIdentity(umiSigner));\n```\n\n----------------------------------------\n\nTITLE: Uploading Metadata Folder to Arweave via Turbo\nDESCRIPTION: Uploads a folder of JSON metadata files to Arweave using Turbo SDK, setting the appropriate MIME type and creating a path manifest for deterministic access.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Upload image folder\nconst metadataUploadResponse = await turbo.uploadFolder({\n    folderPath: metadataFolderPath,\n    dataItemOpts: { tags: [{ name: 'Content-Type', value: 'application/json' }] },\n});\n```\n\n----------------------------------------\n\nTITLE: Deserializing Binary Schema in Rust\nDESCRIPTION: This code demonstrates how to deserialize binary schema data in Rust using the bincode crate. It defines a struct and uses bincode to deserialize the raw bytes into the struct.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Serialize, Deserialize)]\npub struct MyData {\n    pub timestamp: u64,\n    pub message: String,\n}\n\n// In the below example we'll look at deserialization \n// using the `bincode` crate to a struct.\nlet my_data: MyData = bincode::deserialize(&data).unwrap();\nprintln!(\"{:?}\", my_data);\n```\n\n----------------------------------------\n\nTITLE: Using Umi Plugins in TypeScript\nDESCRIPTION: Illustrates the use of the `use` method to install plugins on Umi instances. Libraries often provide functions that return plugins, allowing arguments for configuration. The imported plugins are used to extend the Umi instance functionality.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { somePlugin } from 'some-umi-library';\nimport { myLocalPlugin } from '../plugins';\n\numi.use(somePlugin).use(myLocalPlugin);\n```\n\n----------------------------------------\n\nTITLE: Setting Solana CLI Configuration\nDESCRIPTION: Updates Solana CLI configuration with custom RPC URL and keypair file path. Used to configure connection settings for Sugar CLI operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsolana config set --url <rpc url> --keypair <path to keypair file>\n```\n\n----------------------------------------\n\nTITLE: Minting an Inscription with JSON Data\nDESCRIPTION: This code shows how to mint an inscription with JSON data. It uses Umi to find the PDA accounts, initialize from the mint, write the data, and then confirm the transaction. Finally, the code fetches the inscription metadata and prints the inscription rank.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/js.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Step 1: Mint an NFT or pNFT\n// See https://developers.metaplex.com/token-metadata/mint\n\n// Step 2: Inscribe JSON\n\nconst inscriptionAccount = await findMintInscriptionPda(umi, {\n  mint: mint.publicKey,\n})\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount[0],\n})\n\nawait initializeFromMint(umi, {\n  mintAccount: mint.publicKey,\n})\n  .add(\n    writeData(umi, {\n      inscriptionAccount,\n      inscriptionMetadataAccount,\n      value: Buffer.from(\n        JSON.stringify(metadata) // your NFT's JSON to be inscribed\n      ),\n      associatedTag: null,\n      offset: 0,\n    })\n  )\n  .sendAndConfirm(umi)\n\nconst inscriptionMetadata = await fetchInscriptionMetadata(\n  umi,\n  inscriptionMetadataAccount\n)\nconsole.log(\n  'Inscription number: ',\n  inscriptionMetadata.inscriptionRank.toString()\n)\n```\n\n----------------------------------------\n\nTITLE: Updating as Authority Item Delegate in JavaScript\nDESCRIPTION: This TypeScript function updates metadata fields of an asset as its authority item delegate using the `updateAsAuthorityItemDelegateV2` function from the @metaplex-foundation/mpl-token-metadata library. It updates properties like `newUpdateAuthority` and `isMutable`, and requires the asset's mint and authority details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { updateAsAuthorityItemDelegateV2 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait updateAsAuthorityItemDelegateV2(umi, {\n  mint,\n  authority: authorityItemDelegate,\n  newUpdateAuthority,\n  isMutable: false,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Transferring a Compressed NFT with Owner Authorization in TypeScript\nDESCRIPTION: This snippet demonstrates how to transfer a Compressed NFT using the owner's authorization. It fetches the asset with proof data (with truncated canopy to reduce transaction size) and executes the transfer operation to a new owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/transfer-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, transfer } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait transfer(umi, {\n  ...assetWithProof,\n  leafOwner: currentLeafOwner,\n  newLeafOwner: newLeafOwner.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fungible Asset Token JSON Schema Example\nDESCRIPTION: Example JSON schema for semi-fungible tokens used for gaming items with extensive metadata and supply >= 0.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-standard.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"SolanaGame Steel Sword\",\n  \"symbol\": \"SG-SS-1\",\n  \"description\": \"SolanaGame steel sword available after Level 4\",\n  \"image\": \"<https://arweave.net/26YdhY_eAzv26YdhY1uu9uiA3nmDZYwP8MwZAultcE?ext=jpeg>\",\n  \"animation_url\": \"<https://arweave.net/ZAultcE_eAzv26YdhY1uu9uiA3nmDZYwP8MwuiA3nm?ext=glb>\",\n  \"external_url\": \"<https://SolanaGame.io>\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"attack\",\n      \"value\": \"4\"\n    },\n    {\n      \"trait_type\": \"defense\",\n      \"value\": \"3\"\n    },\n    {\n      \"trait_type\": \"durability\",\n      \"value\": \"47\"\n    },\n    {\n      \"trait_type\": \"components\",\n      \"value\": \"iron: 10; carbon: 1; wood: 2\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching MintCounter Account in JavaScript\nDESCRIPTION: Demonstrates the process of fetching the MintCounter account using `safeFetchMintCounterFromSeeds` in JavaScript. This retrieves the current mint count for the specified wallet, Candy Machine, and id. The Metaplex JavaScript SDK is needed to perform this operation and it provides a console log of the minted amount.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/mint-limit.md#2025-04-17_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { safeFetchMintCounterFromSeeds } from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { umi } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n  id: 1, // The mintLimit id you set in your guard config\n  user: umi.identity.publicKey,\n  candyMachine: candyMachine.publicKey, \n  // or candyMachine: publicKey(\"Address\") with your CM Address\n  candyGuard: candyMachine.mintAuthority, \n  // or candyGuard: publicKey(\"Address\") with your candyGuard Address\n});\n\n// Amount already minted\nconsole.log(mintCounter.count)\n```\n\n----------------------------------------\n\nTITLE: Configuring Allow List Guard in Sugar JSON Configuration\nDESCRIPTION: This JSON snippet shows how to configure the Allow List guard in a Sugar configuration file by specifying the Merkle root hash.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"allowList\" : {\n    \"merkleRoot\": \"<HASH>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Sending GET JSON Request with Umi\nDESCRIPTION: Demonstrates sending a simple GET request to retrieve JSON data from a specified URL using Umi's HTTP request builder\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/http-requests.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait umi.http.send(request().get('https://example.com/users/1').asJson());\n```\n\n----------------------------------------\n\nTITLE: Updating MPL Hybrid 404 Escrow Configuration\nDESCRIPTION: Demonstrates how to fetch and update an existing escrow configuration using the updateEscrowV1 plugin. Uses spread operator to maintain existing values while updating specific fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst escrowConfigurationAddress = publicKey(\"11111111111111111111111111111111\");\n\n// Fetch the escrow configuration account.\nconst escrowConfigurationData = await fetchEscrowV1(umi, escrowConfigurationAddress);\n\n// Use the spread operator `...` to spread the `escrowConfigurationData` fields into the object\n// and adjust any fields you wish to update.\nconst res = await updateEscrowV1(umi, {\n    ...escrowConfigurationData,\n    // your escrow configuration address.\n    escrow: escrowConfigurationAddress,\n    authority: umi.identity,\n    // add any fields below that you wish to change and update.\n    feeAmount: 100000,\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Thawing Frozen NFT using Sugar CLI\nDESCRIPTION: Command line interface for thawing frozen NFTs using Sugar CLI. Supports thawing individual NFTs or all NFTs in a candy machine with various configuration options.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nsugar freeze thaw\n```\n\n----------------------------------------\n\nTITLE: Defining a Fusion Render Schema in JSON\nDESCRIPTION: This JSON schema defines how Fusion should render layered attributes. It specifies the layer order for rendering attributes and default metadata to use as a baseline when combining the Fusion Parent's metadata.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/fusion/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"layering\",\n  \"layers\": [\"base\", \"neck\", \"mouth\", \"nose\"],\n  \"defaults\": {\n    \"metadata\": \"https://shdw-drive.genesysgo.net/G6yhKwkApJr1YCCmrusFibbsvrXZa4Q3GRThSHFiRJQW/default.json\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Function to Calculate Folder Size\nDESCRIPTION: Recursively traverses a folder structure to calculate the total size in bytes of all files, which is needed to determine upload costs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calculateFolderSize(folderPath: string): number {\n  return fs.readdirSync(folderPath).reduce((totalSize, item) => {\n    const fullPath = path.join(folderPath, item);\n    \n    const stats = fs.statSync(fullPath);\n\n    return stats.isFile() \n        ? totalSize + stats.size \n        : totalSize + calculateFolderSize(fullPath);\n  }, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Required Package: MPL-Hybrid\nDESCRIPTION: This snippet shows the command to install the @metaplex-foundation/mpl-hybrid package, which is crucial for working with hybrid collections in the MPL framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/mpl-hybrid\n```\n\n----------------------------------------\n\nTITLE: Initializing Allocation Tracker PDA for Specific Guard Group\nDESCRIPTION: Routes to the Allocation guard to initialize the Allocation Tracker PDA for a specific guard group named 'GROUPA'.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allocation.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'allocation',\n  routeArgs: {\n    id: 1,\n    candyGuardAuthority: umi.identity,\n  },\n  group: some('GROUPA'),\n})\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Gate Guard in JavaScript\nDESCRIPTION: This code snippet shows how to mint an NFT when the NFT Gate guard is active using the Umi library. It provides the mint address of an NFT owned by the user as proof of collection ownership.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-gate.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    nftGate: some({ mint: nftToBurn.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Asset Payment Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to set up a Candy Machine using the Asset Payment guard. It specifies the required collection and destination for the asset payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetPayment: some({\n      requiredCollection: requiredCollection.publicKey,\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Collection NFT in Candy Machine using Sugar CLI\nDESCRIPTION: Command to set a pre-existing collection NFT for a Candy Machine. This operation must be performed before any NFTs are minted from the Candy Machine. The command requires the collection NFT's mint account public key as a parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/collection.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar collection set <COLLECTION MINT>\n```\n\n----------------------------------------\n\nTITLE: Updating Attribute Plugin for NFT Unstaking in Rust\nDESCRIPTION: This code updates the attribute plugin of an NFT with new or modified attributes during the unstaking process using the Metaplex Core framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nUpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n.asset(&ctx.accounts.asset.to_account_info())\n.collection(Some(&ctx.accounts.collection.to_account_info()))\n.payer(&ctx.accounts.payer.to_account_info())\n.authority(Some(&ctx.accounts.update_authority.to_account_info()))\n.system_program(&ctx.accounts.system_program.to_account_info())\n.plugin(Plugin::Attributes(Attributes{ attribute_list }))\n.invoke()?\n```\n\n----------------------------------------\n\nTITLE: Merkle Tree Node Hashing Example\nDESCRIPTION: Demonstrates the hierarchical hashing structure of a Merkle tree, showing how leaf nodes are combined to create parent nodes and ultimately the root hash.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nHash(A), Hash(B), Hash(C), Hash(D)\nParent1 = Hash(Hash(A) + Hash(B))\nParent2 = Hash(Hash(C) + Hash(D))\nRoot = Hash(Parent1 + Parent2)\n```\n\n----------------------------------------\n\nTITLE: Minting with Third Party Signer Guard in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to mint an NFT using the Third Party Signer guard with the Umi library. It includes the signer in the guard configuration and reminds to sign the transaction with the configured signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/third-party-signer.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signer: myConfiguredSigner }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing TransferV1CpiBuilder in Rust\nDESCRIPTION: This snippet demonstrates how to initialize a TransferV1CpiBuilder by calling the new function with the appropriate program AccountInfo. This is essential for executing a CPI call to the Core program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new(ctx.accounts.mpl_core_program);\n```\n\n----------------------------------------\n\nTITLE: Creating a Token Account in Solana using Umi\nDESCRIPTION: This snippet shows how to create a new Token account using Umi. It generates a signer for the token account and creates it with specified mint and owner.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createToken } from '@metaplex-foundation/mpl-toolbox'\n\nconst token = generateSigner(umi)\n\nawait createToken(umi, { token, mint, owner }).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Working with Keypairs in TypeScript\nDESCRIPTION: Outlines Keypair and KeypairSigner types, demonstrating creation and management of keypairs. Dependencies include EdDSA interface and Umi library. Inputs include seeds or secret keys with outputs being Keypair objects.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype KeypairSigner = Signer & Keypair;\ntype Keypair = {\n  publicKey: PublicKey;\n  secretKey: Uint8Array;\n};\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Generate a new random keypair.\nconst myKeypair = umi.eddsa.generateKeypair();\n\n// Restore a keypair using a seed.\nconst myKeypair = umi.eddsa.createKeypairFromSeed(mySeed);\n\n// Restore a keypair using its secret key.\nconst myKeypair = umi.eddsa.createKeypairFromSecretKey(mySecretKey);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst myKeypair = umi.eddsa.generateKeypair();\nconst myKeypairSigner = createSignerFromKeypair(umi, myKeypair);\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if the provided signer is a KeypairSigner object.\nisKeypairSigner(mySigner);\n\n// Register a new keypair as the identity and payer.\numi.use(keypairIdentity(myKeypair));\n\n// Register a new keypair as the payer only.\numi.use(keypairPayer(myKeypair));\n```\n\n----------------------------------------\n\nTITLE: Implementing create_oracle Instruction in Rust\nDESCRIPTION: Instruction to initialize the Oracle account with validation states based on US market hours.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub fn create_oracle(ctx: Context<CreateOracle>) -> Result<()> {\n    match is_us_market_open(Clock::get()?.unix_timestamp) {\n        true => {\n            ctx.accounts.oracle.set_inner(\n                Oracle {\n                    validation: OracleValidation::V1 {\n                        transfer: ExternalValidationResult::Approved,\n                        create: ExternalValidationResult::Pass,\n                        update: ExternalValidationResult::Pass,\n                        burn: ExternalValidationResult::Pass,\n                    },\n                    bump: ctx.bumps.oracle,\n                    vault_bump: ctx.bumps.reward_vault,\n                }\n            );\n        }\n        false => {\n            ctx.accounts.oracle.set_inner(\n                Oracle {\n                    validation: OracleValidation::V1 {\n                        transfer: ExternalValidationResult::Rejected,\n                        create: ExternalValidationResult::Pass,\n                        update: ExternalValidationResult::Pass,\n                        burn: ExternalValidationResult::Pass,\n                    },\n                    bump: ctx.bumps.oracle,\n                    vault_bump: ctx.bumps.reward_vault,\n                }\n            );\n        }\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Guard Export Configuration\nDESCRIPTION: Export configuration for the custom guard in the default guards index file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from './tokenGate';\nexport * from './tokenPayment';\nexport * from './token2022Payment';\nexport * from './customGuard';\n```\n\n----------------------------------------\n\nTITLE: Calling the Create and Mint Tokens Function in Typescript\nDESCRIPTION: This line calls the `createAndMintTokens` function, initiating the process of creating and minting fungible tokens as defined within the function's scope.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ncreateAndMintTokens()\n```\n\n----------------------------------------\n\nTITLE: Closing Address Lookup Table in Umi\nDESCRIPTION: This instruction permanently closes an LUT account after it has been deactivated for a certain period. It uses the findAddressLookupTablePda function to locate the LUT and the closeLut function to close it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAddressLookupTablePda, closeLut } from '@metaplex-foundation/mpl-toolbox'\n\n// The authority and slot used to create the LUT.\nconst lutAddress = findAddressLookupTablePda(umi, { authority, recentSlot })\n\nawait closeLut(umi, {\n  authority,\n  address: lutAddress,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Builder for CreateV1 Instruction in Rust\nDESCRIPTION: This Rust snippet demonstrates initializing a builder for the CreateV1 instruction using the Metaplex SDK. The builder pattern simplifies the instruction preparation with optional parameters, default values, and streamlined setup for transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1Builder::new();\n```\n\n----------------------------------------\n\nTITLE: Client-Side Implementation of Payer-Authority Pattern Using Umi in TypeScript\nDESCRIPTION: A TypeScript definition for client-side implementation of the Payer-Authority pattern using Umi. The type definition includes the account structure with required and optional parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/payer-authority-pattern.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n    // Accounts.\n    export type CreateAccountV1InstructionAccounts = {\n        /** The address of the new account */\n        account: Signer;\n        /** The account paying for the storage fees */\n        payer: Signer;\n        /** The authority of the new asset */\n        authority?: Signer | Pda;\n        /** The system program */\n        systemProgram?: PublicKey | Pda;\n    };\n```\n\n----------------------------------------\n\nTITLE: Changing to Sugar Directory (Bash)\nDESCRIPTION: This command changes the current directory to the newly cloned Sugar repository.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd sugar\n```\n\n----------------------------------------\n\nTITLE: Building Mint Arguments for Candy Machine Guards in TypeScript\nDESCRIPTION: This snippet demonstrates how to build mint arguments for Candy Machine guards, specifically for SolPayment and mintLimit guards. It checks if the guards are present and constructs the corresponding mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, unwrapOption } from '@metaplex-foundation/umi';\nimport {\n  DefaultGuardSetMintArgs\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nlet mintArgs: Partial<DefaultGuardSetMintArgs> = {};\n\n// add solPayment mintArgs\nconst solPayment = unwrapOption(candyGuard.guards.solPayment)\nif (solPayment) {\n  mintArgs.solPayment = some({\n    destination: solPayment.destination,\n  });\n}\n\n// add mintLimit mintArgs\nconst mintLimit = unwrapOption(candyGuard.guards.mintLimit)\nif (mintLimit) {\n  mintArgs.mintLimit = some({ id: mintLimit.id });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tree Configuration Using CPI\nDESCRIPTION: Example of creating a tree configuration using Cross Program Invocation (CPI) with CreateTreeConfigCpiBuilder. This code shows how to build and invoke a CPI instruction from within another program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/rust.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nCreateTreeConfigCpiBuilder::new()\n        .merkle_tree(context.accounts.merkle_tree)\n        .tree_config(context.accounts.tree_config)\n        .payer(context.accounts.payer)\n        .tree_creator(context.accounts.tree_creator)\n        .log_wrapper(SPL_NOOP_ID)\n        .compression_program(context.accounts.compression_program)\n        .system_program(context.acccounts.system_program)\n        .max_depth(20)\n        .max_bufferisz(1024)\n        .public(false)\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Fetching Standalone Inscription Data\nDESCRIPTION: Retrieve inscription data not attached to NFTs using the fetchInscription function from the Metaplex Inscription library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/fetch.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fetchInscription } from '@metaplex-foundation/mpl-inscription'\n\nconst inscription = fetchInscription(umi, inscriptionAddress)\n```\n\n----------------------------------------\n\nTITLE: Creating Transactions in Umi\nDESCRIPTION: TypeScript code demonstrating how to create both Legacy and Versioned Transactions using Metaplex Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox';\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new Umi Legacy Transaction\nconst umiTransaction = transferSol(umi, {...TransferParams}).useLegacyVersion();\n\n// Create a new Umi Versioned Transaction\nconst umiVersionedTransaction = transferSol(umi, {...TransferParams}).useV0().build(umi)\n```\n\n----------------------------------------\n\nTITLE: Computing Merkle Root and Proof in TypeScript\nDESCRIPTION: This snippet demonstrates how to use helper methods from the Umi library to compute the Merkle root and proof for an allow list. It shows both valid and invalid proof generation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allow-list.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nconst merkleRoot = getMerkleRoot(allowList);\nconst validMerkleProof = getMerkleProof(\n  allowList,\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\"\n);\nconst invalidMerkleProof = getMerkleProof(allowList, \"invalid-address\");\n```\n\n----------------------------------------\n\nTITLE: Setting up Gatekeeper Guard in JavaScript\nDESCRIPTION: This code snippet demonstrates how to set up a Core Candy Machine using the Gatekeeper guard in JavaScript. It specifies the Gatekeeper Network and whether to expire the token on use.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/gatekeeper.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    gatekeeper: some({\n      network: publicKey(\"ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6\"),\n      expireOnUse: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Address Lookup Table in Umi\nDESCRIPTION: This snippet demonstrates how to create an empty Address Lookup Table (LUT) account using Umi. It requires the recent slot and authority, and uses the createEmptyLut function from the mpl-toolbox package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEmptyLut } from '@metaplex-foundation/mpl-toolbox'\n\nconst recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' })\n\nawait createEmptyLut(umi, {\n  recentSlot,\n  authority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Implementing Program Owned Tree Rule in Token Auth Rules\nDESCRIPTION: Demonstrates implementation of a merkle tree-based program ownership verification. Uses merkle proofs to verify program ownership against a root hash.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/program-owned.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    list: {\n      type: 'ProgramOwnedTree',\n      pubkeyField: \"Escrow\",\n      proofField: \"EscrowProof\",\n      root: [229, 0, 134, 58, 163, 244, 192, 254, 190, 193, 110, 212, 193, 145, 147, 18, 171, 160, 213, 18, 52, 155, 8, 51, 44, 55, 25, 245, 3, 47, 172, 111],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Uploading JSON and Getting Upload Price in TypeScript\nDESCRIPTION: Demonstrates uploading JSON data and retrieving the upload price using the UploaderInterface. These methods are useful for handling structured data and estimating storage costs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/storage.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst myUri = await umi.uploader.uploadJson({ name: 'John', age: 42 });\n\nconst price = await umi.uploader.getUploadPrice(myFiles);\n```\n\n----------------------------------------\n\nTITLE: Generating Keypair in Web3.js\nDESCRIPTION: TypeScript code showing how to generate a Keypair using Solana Web3.js, including creating a new keypair and loading from an existing secret key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Keypair } from '@solana/web3.js';\n\n// Generate a new Web3Js keypair\nconst web3jsKeypair = Keypair.generate();\n\n// Or use an existing one\nconst web3jsKeypair = Keypair.fromSecretKey(new Uint8Array(walletFile));\n```\n\n----------------------------------------\n\nTITLE: Connecting to Solana Devnet API Endpoint\nDESCRIPTION: The default public API endpoint URL for connecting to Solana's Devnet cluster. This endpoint is rate-limited and provided by Solana for development purposes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/rpc-providers.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttps://api.devnet.solana.com\n```\n\n----------------------------------------\n\nTITLE: Pre-Validating a Wallet with Allow List Guard Route Instruction\nDESCRIPTION: This snippet shows how to pre-validate a wallet using the 'proof' route instruction of the Allow List guard, providing the Merkle root and proof to authorize the wallet for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { publicKey } from \"@metaplex-foundation/umi\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nawait route(umi, {\n  // ...\n  guard: \"allowList\",\n  routeArgs: {\n    path: \"proof\",\n    merkleRoot: getMerkleRoot(allowList),\n    merkleProof: getMerkleProof(allowList, publicKey(umi.identity)),\n  },\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Minting with Gatekeeper Guard in JavaScript\nDESCRIPTION: This code example illustrates how to mint with the Gatekeeper guard using JavaScript. It shows how to pass the Gatekeeper mint settings as arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/gatekeeper.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    gatekeeper: some({\n      network: publicKey(\"ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6\"),\n      expireOnUse: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Merkle Root Update in Solana Airdrop Program\nDESCRIPTION: Tests the functionality to update the Merkle root in the airdrop state account. The test adds a new entry to the Merkle tree data, generates a new Merkle root, and updates the on-chain state. It then verifies that the account's Merkle root has been properly updated.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nit(\"Update root\", async () => {\n    const newData = {\n      address: Keypair.generate().publicKey,\n      amount: Math.floor(Math.random() * 1000),           // Example random amount\n      isClaimed: false,                                   // Default value for isClaimed\n    };\n    merkleTreeData.push(newData); \n    const entryBytes = Buffer.concat([\n      newData.address.toBuffer(), // PublicKey as bytes\n      Buffer.from(new Uint8Array(new anchor.BN(newData.amount).toArray('le', 8))), // Amount as little-endian\n      Buffer.from([newData.isClaimed ? 1 : 0]), // isClaimed as 1 byte\n    ]);\n    merkleTree.add_leaf(entryBytes);\n    merkleTree.merklize();\n\n    const newMerkleRoot = Array.from(merkleTree.get_merkle_root());\n\n    await program.methods.updateTree(newMerkleRoot)\n      .accountsPartial({\n        airdropState: airdropState,\n        authority: authority.publicKey,\n      })\n      .signers([authority])\n      .rpc();\n\n    const account = await program.account.airdropState.fetch(airdropState);\n    expect(account.merkleRoot).to.deep.equal(newMerkleRoot);\n  });\n```\n\n----------------------------------------\n\nTITLE: Verifying Staking Status of NFT Asset in Rust\nDESCRIPTION: This code checks if an NFT asset has gone through the staking process by examining its attribute plugin. It verifies the presence of staking-related attributes and their values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfor attribute in fetched_attribute_list.attribute_list.iter() {\n    if attribute.key == \"staked\" {\n        require!(attribute.value != \"0\", StakingError::NotStaked);\n        [...]\n        is_initialized = true;\n    } else {\n        [...]\n    }\n}\n\n[...]\n\nrequire!(is_initialized, StakingError::StakingNotInitialized);\n```\n\n----------------------------------------\n\nTITLE: Partial Item Upload Example\nDESCRIPTION: Example of a cache file item entry where only metadata needs to be uploaded since the image is already present.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/cache.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"0\": {\n      \"name\": \"My First NFT #1\",\n      \"image_hash\": \"209a200ebea39be9e9e7882da2bc5e652fb690e612abecb094dc13e06db84e54\",\n      \"image_link\": \"https://arweave.net/-qSoAFO7GWTm_js1eHDyoljgB3D_vszlXspVXBM7HyA?ext=png\",\n      \"metadata_hash\": \"cfc45ba94da81c8d21f763ce8bb6bbb845ad598e23e44d5c8db1590672b7653f\",\n      \"metadata_link\": \"\",\n      \"onChain\": false\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi instance with Candy Machine plugin\nDESCRIPTION: This code snippet demonstrates how to create a Umi instance and install the mplCandyMachine plugin. It sets up the necessary configuration to interact with Candy Machines.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/getting-started/js.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplCandyMachine } from '@metaplex-foundation/mpl-candy-machine'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://127.0.0.1:8899').use(mplCandyMachine())\n```\n\n----------------------------------------\n\nTITLE: Performing Signer Constraint Checks for Payer-Authority Pattern in Rust\nDESCRIPTION: Implementation of constraint checks to verify signers in the Payer-Authority pattern. The code confirms that the payer has signed the transaction and handles the optional authority signer with fallback logic.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/payer-authority-pattern.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n    // Check that the payer has signed the transaction and consented to paying storage fees.\n    assert_signer(ctx.accounts.payer)?;\n\n    // If the authority is present, check that they're a signer. Otherwise treat \n    // the payer as the one authorizing the transaction.\n    let authority = match ctx.accounts.authority {\n        Some(authority) => {\n            assert_signer(authority)?;\n            authority\n        }\n        None => ctx.accounts.payer,\n    };\n```\n\n----------------------------------------\n\nTITLE: Extending Umi Instance with Custom Properties\nDESCRIPTION: Illustrates extending the Umi instance by adding custom properties or interfaces through plugins. The example shows adding a `guards` property to the Umi instance and storing candy guards in it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const mplCandyMachine = (): UmiPlugin => ({\n  install(umi) {\n    umi.guards = new DefaultGuardRepository(umi);\n    umi.guards.add(botTaxGuardManifest);\n    umi.guards.add(solPaymentGuardManifest);\n    umi.guards.add(tokenPaymentGuardManifest);\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi Plugins in TypeScript\nDESCRIPTION: Shows how to configure plugins using options during their initialization. Plugins are initialized with configurable options, allowing flexibility in behavior and setup.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { somePlugin } from 'some-umi-library';\nimport { myLocalPlugin } from '../plugins';\n\numi.use(somePlugin(somePluginOptions))\n  .use(myLocalPlugin(myLocalPluginOptions));\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Candy Machine with Token Payment Guard in TypeScript\nDESCRIPTION: This code demonstrates how to create a Core Candy Machine with the Token Payment guard. It configures the guard to charge 300 tokens from a specified mint and sends them to an Associated Token Account of the current identity.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\ncreate(umi, {\n  // ...\n  guards: {\n    tokenPayment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta: findAssociatedTokenPda(umi, {\n        mint: tokenMint.publicKey,\n        owner: umi.identity.publicKey,\n      })[0],\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Feature Deactivation in JavaScript\nDESCRIPTION: Examples showing how to match features with specific clusters or explicitly disable features in the test validator. Used to simulate cluster-specific behavior locally.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/configuration.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  validator: {\n    ...\n    matchFeatures: 'mainnet-beta',\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  validator: {\n    ...\n   deactivateFeatures: ['21AWDosvp3pBamFW91KB35pNoaoZVTM7ess8nr2nt53B'],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initiating Metadata Upload Process\nDESCRIPTION: Calls the helper function to handle the metadata upload workflow, which includes calculating costs, topping up the wallet if needed, and performing the upload.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst metadataUploadResponse = await uploadMetadata(turbo);\n```\n\n----------------------------------------\n\nTITLE: Hashing NFT Metadata with Keccak-256 in Bubblegum\nDESCRIPTION: This function computes the hash of NFT metadata using the keccak-256 algorithm. It first hashes the metadata bytes, then hashes the result with the seller fee basis points to create a final data hash. This approach enables marketplaces to more efficiently validate seller fees.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/hashed-nft-data.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// Computes the hash of the metadata.\n///\n/// The hash is computed as the keccak256 hash of the metadata bytes, which is\n/// then hashed with the `seller_fee_basis_points`.\npub fn hash_metadata(metadata: &MetadataArgs) -> Result<[u8; 32]> {\n    let hash = keccak::hashv(&[metadata.try_to_vec()?.as_slice()]);\n    // Calculate new data hash.\n    Ok(keccak::hashv(&[\n        &hash.to_bytes(),\n        &metadata.seller_fee_basis_points.to_le_bytes(),\n    ])\n    .to_bytes())\n}\n```\n\n----------------------------------------\n\nTITLE: Complete TransferV1 CPI Example\nDESCRIPTION: Full example of configuring and invoking a TransferV1 CPI call.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new()\n        .asset(ctx.accounts.asset)\n        .collection(context.accounts.collection)\n        .payer(context.accounts.payer)\n        .authority(context.accounts.authority)\n        .new_owner(context.accounts.new_owner)\n        .system_program(context.accounts.system_program)\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Minting with Token2022 Payment Guard in JavaScript\nDESCRIPTION: Executes a mint operation with Token2022 Payment guard mint arguments. The code specifies the token mint and destination associated token account needed to process the token payment during minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/token2022-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    tokenPayment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Sugar Update Command\nDESCRIPTION: This command updates the Candy Machine configuration using the default config and cache files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/update.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar update\n```\n\n----------------------------------------\n\nTITLE: Updating Attributes Plugin on Asset\nDESCRIPTION: Shows how to update existing attributes on an asset using both TypeScript and Rust implementations. Includes complete transaction setup and execution process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/attribute.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\n\nawait updatePlugin(umi, {\n  asset: assetAddress,\n  plugin: {\n    type: 'Attributes',\n    attributeList: [\n      { key: 'key0', value: 'value0' },\n      { key: 'key1', value: 'value1' },\n    ],\n  },\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nuse mpl_core::{\n    instructions::UpdatePluginV1Builder,\n    types::{Attribute, Attributes, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn update_attributes_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let update_attributes_plugin_ix = UpdatePluginV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin(Plugin::Attributes(Attributes {\n            attribute_list: vec![\n                Attribute {\n                    key: \"color\".to_string(),\n                    value: \"new value\".to_string(),\n                },\n                Attribute {\n                    key: \"access_type\".to_string(),\n                    value: \"new value\".to_string(),\n                },\n                Attribute {\n                    key: \"additional_attribute\".to_string(),\n                    value: \"additional_value\".to_string(),\n                },\n            ],\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let update_attributes_plugin_tx = Transaction::new_signed_with_payer(\n        &[update_attributes_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&update_attributes_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Per-Card Authority PDA in Rust\nDESCRIPTION: Creates a unique Program Derived Address (PDA) for individual loyalty card authority management using the card's public key as a seed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/loyalty-card-concept-guide.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet seeds = &[loyalty_card.key().as_ref()];\nlet (loyalty_authority, bump) = Pubkey::find_program_address(seeds, &program_id);\n```\n\n----------------------------------------\n\nTITLE: Batch Minting of Multiple Compressed NFTs in TypeScript\nDESCRIPTION: This code demonstrates a loop approach for minting multiple cNFTs to a Merkle Tree. It iterates through an array of addresses, creating incrementally numbered cNFTs with unique metadata URIs for each recipient. The example shows how to scale cNFT minting to utilize the full capacity of a Merkle Tree.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n  const addresses = [\n    \"11111111111111111111111111111111\",\n    \"22222222222222222222222222222222\",\n    \"33333333333333333333333333333333\",\n    ...\n  ];\n\n  let index = 0;\n\n  for await (const address in addresses) {\n    const newOwner = publicKey(address);\n\n    console.log(\"Minting Compressed NFT to Merkle Tree...\");\n\n    const { signature } = await mintV1(umi, {\n      leafOwner: newOwner,\n      merkleTree: merkleTree.publicKey,\n      metadata: {\n        name: `My Compressed NFT #${index}`,\n        uri: `https://example.com/${index}.json`, //either use metadataUri or the uri of the uploaded metadata file\n        sellerFeeBasisPoints: 500, // 5%\n        collection: { key: collectionSigner.publicKey, verified: false },\n        creators: [\n          { address: umi.identity.publicKey, verified: true, share: 100 },\n        ],\n      },\n    }).sendAndConfirm(umi, { send: { commitment: \"finalized\" } });\n\n    index++;\n  }\n```\n\n----------------------------------------\n\nTITLE: Deploying Candy Machine using Sugar CLI on Solana\nDESCRIPTION: This command deploys the Candy Machine to Solana using the information from the cache file. It writes the data to the Candy Machine account onchain and returns the onchain ID (Public Key) for querying purposes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/deploy.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar deploy\n```\n\n----------------------------------------\n\nTITLE: Minting with Mint Limit Guard in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to mint assets using a Mint Limit guard in Core Candy Machine. By specifying `mintArgs` with the `mintLimit` id, developers can perform controlled minting operations. It requires use of the Metaplex JavaScript SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/mint-limit.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    mintLimit: some({ id: 1 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining AttributeList Structure\nDESCRIPTION: Shows how to define the attribute list structure containing key-value pairs in both TypeScript and Rust. The attribute list is an array of objects with key and value string pairs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/attribute.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst attributeList = [\n  { key: 'key0', value: 'value0' },\n  { key: 'key1', value: 'value1' },\n]\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::{Attributes, Attribute}\n\nlet attributes = Attributes {\n    attribute_list: vec![\n        Attribute {\n            key: \"color\".to_string(),\n            value: \"blue\".to_string(),\n        },\n        Attribute {\n            key: \"access_type\".to_string(),\n            value: \"prestige\".to_string(),\n        },\n    ],\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Single Account with Umi RPC\nDESCRIPTION: Shows how to fetch a single account and check for its existence using Umi's RPC interface.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst myAccount = await umi.rpc.getAccount(myPublicKey);\nassertAccountExists(myAccount);\n```\n\n----------------------------------------\n\nTITLE: Extending Address Lookup Table in Umi\nDESCRIPTION: This code shows how to add new addresses to an existing LUT account. It uses the findAddressLookupTablePda function to locate the LUT and the extendLut function to add new addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAddressLookupTablePda, extendLut } from '@metaplex-foundation/mpl-toolbox'\n\n// The authority and slot used to create the LUT.\nconst lutAddress = findAddressLookupTablePda(umi, { authority, recentSlot })\n\nawait extendLut(umi, {\n  authority,\n  address: lutAddress, // The address of the LUT.\n  addresses: [addressA, addressB], // The addresses to add to the LUT.\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Custom Cache File\nDESCRIPTION: Command to mint NFTs using a specified cache file instead of the default cache.json.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/mint.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint --cache <CACHE>\n```\n\n----------------------------------------\n\nTITLE: Compress Images - Bash\nDESCRIPTION: Compresses images before inscribing to reduce costs. The command allows for adjustments on quality, size, and format for optimization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npnpm cli compress images -q <QUALITY> -s <SIZE> -e <EXTENSION>\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies - Bash\nDESCRIPTION: Installs the necessary dependencies for the Inscriptions CLI using pnpm. This step must be completed before running any CLI commands.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Computing Merkle Root and Proof in JavaScript for Allow List\nDESCRIPTION: This snippet demonstrates how to compute a Merkle root and proof for an allow list of wallet addresses using helper functions from the mpl-core-candy-machine library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allow-list.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst allowList = [\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\",\n  \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n  \"AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy\",\n];\n\nconst merkleRoot = getMerkleRoot(allowList);\nconst validMerkleProof = getMerkleProof(\n  allowList,\n  \"Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB\"\n);\nconst invalidMerkleProof = getMerkleProof(allowList, \"invalid-address\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Freeze Escrow using JavaScript/TypeScript\nDESCRIPTION: Demonstrates how to initialize a Freeze Escrow account using the Umi SDK with a 15-day freeze period. The code sets up the route instruction with necessary parameters including token mint, destination ATA, and authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: \"freezeTokenPayment\",\n  routeArgs: {\n    path: \"initialize\",\n    mint: tokenMint.publicKey,\n    destinationAta,\n    period: 15 * 24 * 60 * 60, // 15 days.\n    candyGuardAuthority: umi.identity,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Removing a Plugin from MPL Core Asset in TypeScript\nDESCRIPTION: This snippet shows how to remove a plugin from an MPL Core Asset using TypeScript. It uses the @metaplex-foundation/umi and @metaplex-foundation/mpl-core libraries to remove an 'Attributes' plugin from a specified asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/removing-plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { removePlugin } from '@metaplex-foundation/mpl-core'\n\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait removePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: { type: 'Attributes' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Updating Merkle Root After Claiming in Rust\nDESCRIPTION: This code extends the claiming function to update the Merkle root after a successful claim by modifying the user's leaf to mark it as claimed. This approach handles concurrency by locking the account during updates.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n// Step 4: Update the `is_claimed` flag in the leaf\nlet mut updated_leaf = Vec::new();\nupdated_leaf.extend_from_slice(&ctx.accounts.signer.key().to_bytes());\nupdated_leaf.extend_from_slice(&amount.to_le_bytes());\nupdated_leaf.push(1u8); // isClaimed = true\n\nlet updated_root: [u8; 32] = merkle_proof\n  .merklize(&updated_leaf)\n  .map_err(|_| AirdropError::InvalidProof)?\n  .try_into()\n  .map_err(|_| AirdropError::InvalidProof)?;\n\n// Step 5: Update the Merkle root in the airdrop state\nairdrop_state.merkle_root = updated_root;\n\n// Step 6: Update the airdrop state\nairdrop_state.amount_claimed = airdrop_state\n  .amount_claimed\n  .checked_add(amount)\n  .ok_or(AirdropError::OverFlow)?;\n```\n\n----------------------------------------\n\nTITLE: Implementing CrankOracle Account Structure in Rust\nDESCRIPTION: Defines the account structure for updating the Oracle state with mutable accounts for oracle and reward vault.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CrankOracle<'info> {\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(\n        mut,\n        seeds = [b\"oracle\"],\n        bump = oracle.bump,\n    )]\n    pub oracle: Account<'info, Oracle>,\n    #[account(\n        mut, \n        seeds = [b\"reward_vault\", oracle.key().as_ref()],\n        bump = oracle.vault_bump,\n    )]\n    pub reward_vault: SystemAccount<'info>,\n    pub system_program: Program<'info, System>,\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi Instance with Token Metadata Plugin\nDESCRIPTION: Create and configure a Umi instance with the mplTokenMetadata plugin using a specified RPC endpoint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/js.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://127.0.0.1:8899').use(mplTokenMetadata())\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Schema for HTML NFT in Metaplex Core\nDESCRIPTION: This example illustrates the JSON schema for an HTML NFT in Metaplex Core. It includes both an image URL for a fallback image and an animation URL pointing to an HTML file. The category is set to 'html' and both files are listed in the properties section. Note that HTML assets may not be supported by all wallets due to security concerns.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"HTML Asset\",\n    \"image\": \"https://arweave.net/UV74zleArOaBkmIamruFZDrRWru3wEfwmdOJFgOSKIE\",\n    \"animation_url\": \"https://arweave.net/b0Ww2l2Qq62WwH6nRwwn2784a9RJWLBi21HVLELvpVQ\",\n    \"description\": \"This is a html NFT showing a clock. It has an image and the animation url is linked to a html file.\",\n    \"external_url\": \"https://example.com\",\n    \"properties\": {\n        \"files\": [\n            {\n                \"uri\": \"https://arweave.net/UV74zleArOaBkmIamruFZDrRWru3wEfwmdOJFgOSKIE\",\n                \"type\": \"image/png\"\n            },\n            {\n                \"uri\": \"https://arweave.net/b0Ww2l2Qq62WwH6nRwwn2784a9RJWLBi21HVLELvpVQ\",\n                \"type\": \"video/html\"\n            }\n        ],\n        \"category\": \"html\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Prepare Trait in Rust\nDESCRIPTION: Defines the Prepare trait for custom upload methods. This trait is used to prepare the method for uploading specified media/metadata files, such as checking size limits or storage space.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/bring-your-own-uploader.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nasync fn prepare(\n    &self,\n    sugar_config: &SugarConfig,\n    asset_pairs: &HashMap<isize, AssetPair>,\n    asset_indices: Vec<(DataType, &[isize])>,\n) -> Result<()>;\n```\n\n----------------------------------------\n\nTITLE: Delegating Plugin Authority in JavaScript\nDESCRIPTION: This code snippet demonstrates how to delegate a plugin authority to another address using the MPL Core library in JavaScript. It uses the approvePluginAuthority function to delegate the 'Attributes' plugin to a specified address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { approvePluginAuthority } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\nconst delegate = publicKey('33333333333333333333333333333')\n\nawait approvePluginAuthority(umi, {\n  asset: assetAddress,\n  plugin: { type: 'Attributes' },\n  newAuthority: { type: 'Address', address: delegate },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Token Metadata JSON\nDESCRIPTION: Preparing and uploading token metadata to Arweave using Umi\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst metadata = {\n  name: 'The Kitten Coin',\n  symbol: 'KITTEN',\n  description: 'The Kitten Coin is a token created on the Solana blockchain',\n  image: imageUri,\n}\n\nconst metadataUri = await umi.uploader.uploadJson(metadata).catch((err) => {\n  throw new Error(err)\n})\n```\n\n----------------------------------------\n\nTITLE: Minting NFTs with Sugar\nDESCRIPTION: Executes the minting process for NFTs from the deployed Candy Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint\n```\n\n----------------------------------------\n\nTITLE: Umi Plugin Initialization with Examples in TypeScript\nDESCRIPTION: Demonstrates using a consistent initialization pattern for Umi plugins, even when no arguments are needed. The examples show initializing plugins utilizing web3, mock storage, and HTTP downloaders.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { web3JsRpc } from '@metaplex-foundation/umi-rpc-web3js';\nimport { mockStorage } from '@metaplex-foundation/umi-storage-mock';\nimport { httpDownloader } from '@metaplex-foundation/umi-downloader-http';\n\numi.use(web3JsRpc('https://api.mainnet-beta.solana.com'))\n  .use(mockStorage())\n  .use(httpDownloader());\n```\n\n----------------------------------------\n\nTITLE: Getting Asset Information - JavaScript\nDESCRIPTION: This snippet demonstrates how to retrieve asset information from the DAS API using JavaScript. It imports necessary modules, establishes a Umi instance, and fetches asset details using the provided asset ID. Dependencies include '@metaplex-foundation/umi', '@metaplex-foundation/umi-bundle-defaults', and '@metaplex-foundation/digital-asset-standard-api'. Expected input is an asset ID in publicKey format, and the output is the asset details logged to the console.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst assetId = publicKey('8TrvJBRa6Pzb9BDadqroHhWTHxaxK8Ws8r91oZ2jxaVV');\n\nconst asset = await umi.rpc.getAsset(assetId);\nconsole.log(asset);\n```\n\n----------------------------------------\n\nTITLE: Creating a Merkle Tree on Any SVM with Automatic Program Resolution\nDESCRIPTION: Recommended approach for creating a Merkle tree using the getCompressionPrograms helper function, which automatically resolves the correct program IDs for any SVM environment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-interact-with-cnfts-on-other-svms.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getCompressionPrograms,\n  createTree,\n} from '@metaplex-foundation/mpl-bubblegum'\nimport {\n  generateSigner,\n  publicKey,\n} from '@metaplex-foundation/umi';\n\n// Create a Merkle tree using the `getCompressionPrograms` helper function.\nconst merkleTree = generateSigner(umi);\nconst createTreeTx = await createTree(umi, {\n  merkleTree,\n  maxDepth: 3,\n  maxBufferSize: 8,\n  canopyDepth: 0,\n  ...(await getCompressionPrograms(umi)),\n});\n\nawait createTreeTx.sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Accounts and Programs in JavaScript\nDESCRIPTION: Configuration example showing how to pull accounts and programs from remote clusters for local testing. Demonstrates account configuration with different clusters and executable flags.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/configuration.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  validator: {\n    accountsCluster: 'https://api.metaplex.solana.com',\n    accounts: [\n      {\n        label: 'Token Metadata Program',\n        accountId: 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n        executable: true,\n      },\n      {\n        label: 'Random other account',\n        accountId: '4VLgNs1jXgdciSidxcaLKfrR9WjATkj6vmTm5yCwNwui',\n        cluster: 'https://metaplex.devnet.rpcpool.com',\n      },\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with Local Validator\nDESCRIPTION: TypeScript code demonstrating how to initialize the Umi framework with a local Solana validator, enabling local blockchain interactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\n\nconst umi = createUmi(\"http://127.0.0.1:8899\")\n```\n\n----------------------------------------\n\nTITLE: Serializing JSON Data\nDESCRIPTION: Examples of JSON data serialization for the AppData plugin using TypeScript and Rust\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst json = {\n  timeStamp: Date.now(),\n  message: 'Hello, World!',\n}\n\nconst data = new TextEncoder().encode(JSON.stringify(json))\n```\n\nLANGUAGE: rust\nCODE:\n```\n// This uses `serde` and the `serde_json` crates.\n\n\nlet struct_data = MyData {\n    timestamp: 1234567890,\n    message: \"Hello World\".to_string(),\n};\n\nlet data = serde_json::to_vec(&struct_data).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine with Custom Config and Cache Files\nDESCRIPTION: This command allows updating the Candy Machine configuration using custom config and cache files specified with the '--config' and '--cache' options.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/update.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar update -c <CONFIG> --cache <CACHE>\n```\n\n----------------------------------------\n\nTITLE: Configuring Amman Validator for Candy Machine Program\nDESCRIPTION: Configuration setup for testing and working with Metaplex Candy Machine v3. Includes necessary program accounts like Candy Guard, Token Metadata, and SPL programs. Sets up validator, relay, and storage configurations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/pre-made-configs.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\nconst { LOCALHOST, tmpLedgerDir } = require(\"@metaplex-foundation/amman\");\n\nmodule.exports = {\n  validator: {\n    killRunningValidators: true,\n    accountsCluster: \"https://api.metaplex.solana.com\",\n    accounts: [\n       {\n        label: \"Candy Machine v3\",\n        accountId: \"CndyV3LdqHUfDLmE5naZjVN8rBZz4tqhdefbAnjHG3JR\",\n        executable: true,\n      },\n      {\n        label: \"Candy Guard\",\n        accountId: \"Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g\",\n        executable: true,\n      },\n      {\n        label: \"Token Metadata Program\",\n        accountId: \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\",\n        executable: true,\n      },\n      {\n        label: \"Token Auth Rules\",\n        accountId: \"auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg\",\n        executable: true,\n      },\n      {\n        label: \"Spl ATA Program\",\n        accountId: \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\",\n        executable: true,\n      },\n      {\n        label: \"SPL Token Program\",\n        accountId: \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\",\n        executable: true,\n      },\n    ],\n    jsonRpcUrl: LOCALHOST,\n    websocketUrl: \"\",\n    commitment: \"confirmed\",\n    ledgerDir: tmpLedgerDir(),\n    resetLedger: true,\n    verifyFees: false,\n    detached: process.env.CI != null,\n  },\n  relay: {\n    enabled: process.env.CI == null,\n    killRunningRelay: true,\n  },\n  storage: {\n    enabled: process.env.CI == null,\n    storageId: \"mock-storage\",\n    clearOnStart: true,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Converting Keypair from Web3.js to Umi\nDESCRIPTION: TypeScript code showing how to convert a Keypair from Web3.js format to Umi format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Keypair } from '@solana/web3.js';\nimport { fromWeb3JsKeypair } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new keypair\nconst web3jsKeypair = Keypair.generate();\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiKeypair = fromWeb3JsKeypair(web3jsKeypair);\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Types\nDESCRIPTION: Demonstrates how to serialize and deserialize a type using Kinobi-generated serializers in TypeScript. The example shows the usage for a type 'MyType' with the serializer object handling both conversion functions. Inputs include typed objects, and outputs include serialized buffers or deserialized objects.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst serializer: Serializer<MyTypeArgs, MyType> = getMyTypeSerializer();\nserializer.serialize(myType);\nserializer.deserialize(myBuffer);\n```\n\n----------------------------------------\n\nTITLE: Implementing Metaplex Foundation Rule Set JSON Configuration\nDESCRIPTION: Defines the rule set configuration for enforcing creator royalties on pNFTs. Currently configured to allow all operations as there are no programs bypassing creator royalties. Includes various transfer and delegation permissions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/mplx-rule-sets.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"libVersion\": 1,\n  \"owner\": \"ELskdHjzTQ6F4bBibhk4iqy63gSPs8ELec9HbfAaSDJk\",\n  \"ruleSetName\": \"Metaplex Foundation Rule Set\",\n  \"operations\": {\n    \"Transfer:WalletToWallet\": \"Pass\",\n    \"Transfer:Owner\": \"Pass\",\n    \"Transfer:MigrationDelegate\": \"Pass\",\n    \"Transfer:SaleDelegate\": \"Pass\",\n    \"Transfer:TransferDelegate\": \"Pass\",\n    \"Delegate:LockedTransfer\": \"Pass\",\n    \"Delegate:Update\": \"Pass\",\n    \"Delegate:Transfer\": \"Pass\",\n    \"Delegate:Utility\": \"Pass\",\n    \"Delegate:Staking\": \"Pass\",\n    \"Delegate:Authority\": \"Pass\",\n    \"Delegate:Collection\": \"Pass\",\n    \"Delegate:Use\": \"Pass\",\n    \"Delegate:Sale\": \"Pass\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Revoking Plugin Authority in Rust\nDESCRIPTION: This Rust code snippet shows how to revoke a plugin authority using the MPL Core library. It creates an instruction to revoke the 'FreezeDelegate' plugin authority for a specific asset and sends the transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::RevokePluginAuthorityV1Builder, types::PluginType};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn revoke_plugin_authority() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let revoke_plugin_authority_ix = RevokePluginAuthorityV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin_type(PluginType::FreezeDelegate)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let revoke_plugin_authority_tx = Transaction::new_signed_with_payer(\n        &[revoke_plugin_authority_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&revoke_plugin_authority_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection using CPI Builder\nDESCRIPTION: Example of using CreateCollectionV2CpiBuilder to create a collection via CPI\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nCreateCollectionV2CpiBuilder::new(&ctx.accounts.core_program)\n    .collection(&ctx.accounts.collection)\n    .payer(&ctx.accounts.payer)\n    .system_program(&ctx.accounts.system_program)\n    .name(\"Test Collection\".to_string())\n    .uri(\"https://test.com\".to_string())\n    .invoke()?\n```\n\n----------------------------------------\n\nTITLE: Setting up a Candy Machine with Asset Payment Multi Guard in JavaScript\nDESCRIPTION: This code demonstrates how to configure a Candy Machine with the Asset Payment Multi guard during creation. The guard is set to require 2 assets from a specified collection to be transferred to the destination wallet during minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-payment-multi.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetPaymentMulti: some({\n      requiredCollection: requiredCollection.publicKey,\n      destination: umi.identity.publicKey,\n      num: 2\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Validate Instruction in Rust\nDESCRIPTION: Shows how to construct and invoke a validate instruction using ValidateBuilder. Includes setting up rule set PDA, mint, operation details, and handling additional rule accounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/validate.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet validate_ix = ValidateBuilder::new()\n    .rule_set_pda(*ruleset.key)\n    .mint(*mint_info.key)\n    .additional_rule_accounts(account_metas)\n    .build(ValidateArgs::V1 {\n        operation: operation.to_string(),\n        payload: auth_data.payload.clone(),\n        update_rule_state: false,\n        rule_set_revision,\n    })\n    .map_err(|_error| ErrorCode::InvalidAuthorizationRules)?\n    .instruction();\n\nlet mut account_infos = vec![ruleset.clone(), mint_info.clone()];\naccount_infos.extend(additional_rule_accounts.into_iter().cloned());\ninvoke_signed(&validate_ix, account_infos.as_slice(), &[])\n```\n\n----------------------------------------\n\nTITLE: New Candy Machine Deployment Configuration\nDESCRIPTION: Example of modified cache file for deploying a new Candy Machine with existing items, showing empty Candy Machine and Candy Guard addresses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/cache.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"program\": {\n    \"candyMachine\": \"\",\n    \"candyGuard\": \"\",\n    \"candyMachineCreator\": \"6DwuXCUnGEE2NktwQub22Ejt2EQUexGmGADZURN1RF6J\",\n    \"collectionMint\": \"5TM8a74oX6HgyAtVnKaUaGuwu44hxMhWF5QT5i7PkuZY\"\n  },\n  \"items\": {\n    \"-1\": {\n      \"name\": \"My Collection\",\n      \"image_hash\": \"6500707cb13044b7d133abb5ad68e0af660b154499229af49419c86a251a2b4d\",\n      \"image_link\": \"https://arweave.net/KplI7R59EE24-mavSgai7WVJmkfvYQKhtTnqxXPlPdE?ext=png\",\n      \"metadata_hash\": \"2009eda578d1196356abcfdfbba252ec3318fc6ffe42cc764a624b0c791d8471\",\n      \"metadata_link\": \"https://arweave.net/K75J8IG1HcTYJyr1eC0KksYfpxuFMkPONJMpUNDmCuA\",\n      \"onChain\": true\n    },\n    \"0\": {\n      \"name\": \"My First NFT #1\",\n      \"image_hash\": \"209a200ebea39be9e9e7882da2bc5e652fb690e612abecb094dc13e06db84e54\",\n      \"image_link\": \"https://arweave.net/-qSoAFO7GWTm_js1eHDyoljgB3D_vszlXspVXBM7HyA?ext=png\",\n      \"metadata_hash\": \"cfc45ba94da81c8d21f763ce8bb6bbb845ad598e23e44d5c8db1590672b7653f\",\n      \"metadata_link\": \"https://arweave.net/6DRibEPNjLQKA90v3qa-JsYPPT5a6--VsgKumUnX3_0\",\n      \"onChain\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Airdrop List JSON Format for Sugar CLI\nDESCRIPTION: Example JSON format for specifying multiple recipient wallets and their respective NFT quantities for the Sugar CLI airdrop command.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"11111111111111111111111111111111\": 3,\n  \"22222222222222222222222222222222\": 1\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS Credentials\nDESCRIPTION: Example configuration for AWS credentials file located at ~/.aws/credentials. Required for using AWS S3 storage with Sugar upload method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/configuration.md#2025-04-17_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[default]\naws_access_key_id=<ACCESS KEY ID>\naws_secret_access_key=<SECRET ACCESS KEY>\nregion=<REGION>\n```\n\n----------------------------------------\n\nTITLE: Installing Metaplex Token Metadata Dependencies\nDESCRIPTION: Install required npm packages including Umi framework, Token Metadata library, and Solana web3.js.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/js.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install \\\n  @metaplex-foundation/umi \\\n  @metaplex-foundation/umi-bundle-defaults \\\n  @solana/web3.js@1 \\\n  @metaplex-foundation/mpl-token-metadata\n```\n\n----------------------------------------\n\nTITLE: Initializing Number Serializers in TypeScript\nDESCRIPTION: This snippet demonstrates the creation of various number serializers for unsigned integers, signed integers, and floating-point numbers. It also shows how to configure endianness for serializers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Unsigned integers.\nu8(); // -> Serializer<number>\nu16(); // -> Serializer<number>\nu32(); // -> Serializer<number>\nu64(); // -> Serializer<number | bigint, bigint>\nu128(); // -> Serializer<number | bigint, bigint>\n\n// Signed integers.\ni8(); // -> Serializer<number>\ni16(); // -> Serializer<number>\ni32(); // -> Serializer<number>\ni64(); // -> Serializer<number | bigint, bigint>\ni128(); // -> Serializer<number | bigint, bigint>\n\n// Floating point numbers.\nf32(); // -> Serializer<number>\nf64(); // -> Serializer<number>\n\nu64(); // Little-endian.\nu64({ endian: Endian.Little }); // Little-endian.\nu64({ endian: Endian.Big }); // Big-endian.\n```\n\n----------------------------------------\n\nTITLE: Defining AirdropState Account Structure in Rust\nDESCRIPTION: Defines the AirdropState account structure to manage and track the state of the airdrop, including merkle root, authority, mint, and other relevant information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[account]\npub struct AirdropState {\n    /// The current merkle root\n    pub merkle_root: [u8; 32],\n    /// The authority who can update the merkle root\n    pub authority: Pubkey,\n    /// The mint address of the token being airdropped\n    pub mint: Pubkey,\n    /// Total amount allocated for the airdrop\n    pub airdrop_amount: u64,\n    /// Total amount claimed so far\n    pub amount_claimed: u64,\n    /// PDA bump seed\n    pub bump: u8,\n}\n```\n\n----------------------------------------\n\nTITLE: Shankjs Configuration with Anchor 28 Fallback\nDESCRIPTION: Extended Shankjs configuration that includes fallback to Anchor 27 for compatibility with missing crates.io crate in Anchor 28.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ngenerateIdl({\n  generator: \"anchor\",\n  programName: \"candy_guard\",\n  programId: \"Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g\", // Your custom Candy Guard deployed program key.\n  idlDir,\n  binaryInstallDir,\n  programDir: path.join(programDir, \"candy-guard\", \"program\"),\n  rustbin: {\n    locked: true,\n    versionRangeFallback: \"0.27.0\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Searching Assets using cURL\nDESCRIPTION: Makes a direct JSON-RPC request to the DAS API endpoint to search for assets by owner address and JSON URI. This example shows how to structure the request payload with pagination parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/search-assets.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"searchAssets\",\n    \"params\": {\n        \"ownerAddress\": \"N4f6zftYsuu4yT7icsjLwh4i6pB1zvvKbseHj2NmSQw\",\n        \"jsonUri\": \"https://arweave.net/c9aGs5fOk7gD4wWnSvmzeqgtfxAGRgtI1jYzvl8-IVs/chiaki-violet-azure-common.json\",\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Approving Standard Delegate in TypeScript\nDESCRIPTION: This snippet demonstrates how to approve a Standard Delegate for a non-fungible token using the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateStandardV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateStandardV1(umi, {\n  mint,\n  tokenOwner: owner.publicKey,\n  authority: owner,\n  delegate: standardDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Plugins in JavaScript/TypeScript\nDESCRIPTION: Shows how to access specific plugin data from a deserialized asset in JavaScript, specifically for Attributes and Royalties plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/deserialization.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetV1 = await fetchAsset(\n  umi,\n  publicKey('11111111111111111111111111111111')\n)\n\n// Example of saving just the deserialized data of the Attributes Plugin\nlet attributes_plugin = assetV1.attributes\n\n// Example of saving just the deserialized data of the Royalties Plugin\nlet royalties_plugin = assetV1.royalties\n```\n\n----------------------------------------\n\nTITLE: Defining ExtraAccount Options in Rust\nDESCRIPTION: This code snippet defines the ExtraAccount enum, which provides various options for specifying additional accounts or PDAs for the Oracle Plugin Adapter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub enum ExtraAccount {\n    /// Program-based PDA with seeds [\"mpl-core\"]\n    PreconfiguredProgram {\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// Collection-based PDA with seeds [\"mpl-core\", collection_pubkey]\n    PreconfiguredCollection {\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// Owner-based PDA with seeds [\"mpl-core\", owner_pubkey]\n    PreconfiguredOwner {\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// Recipient-based PDA with seeds [\"mpl-core\", recipient_pubkey]\n    /// If the lifecycle event has no recipient the derivation will fail.\n    PreconfiguredRecipient {\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// Asset-based PDA with seeds [\"mpl-core\", asset_pubkey]\n    PreconfiguredAsset {\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// PDA based on user-specified seeds.\n    CustomPda {\n        /// Seeds used to derive the PDA.\n        seeds: Vec<Seed>,\n        /// Program ID if not the base address/program ID for the external plugin.\n        custom_program_id: Option<Pubkey>,\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n    /// Directly-specified address.\n    Address {\n        /// Address.\n        address: Pubkey,\n        /// Account is a signer\n        is_signer: bool,\n        /// Account is writable.\n        is_writable: bool,\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Programs by Name or Public Key in TypeScript\nDESCRIPTION: Demonstrates how to retrieve a registered program from the repository using its name or public key through the get method while considering cluster restrictions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch a program by its name.\nconst myProgram = umi.programs.get('myProgram');\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch a program by its public key.\nconst myProgram = umi.programs.get(publicKey('...'));\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch a program on a specific cluster.\numi.programs.get('myProgram', 'mainnet-beta');\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Fetch a program on any cluster.\numi.programs.get('myProgram', 'all');\n```\n\nLANGUAGE: typescript\nCODE:\n```\numi.programs.get<CandyGuardProgram>('mplCandyGuard');\n```\n\n----------------------------------------\n\nTITLE: Calculating Lamports Required for Turbo Upload\nDESCRIPTION: Determines how many lamports are needed to cover the Winc cost for uploading files of a specified size, accounting for current wallet balance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nasync function calculateRequiredLamportsForUpload(turbo: TurboAuthenticatedClient, fileSize: number): Promise<number> {\n    /// If the file size is less than 105 KiB, then we don't need to pay for it\n    if (fileSize < 107_520) { return 0; }\n\n    /// Check how many winc does it cost to upload the file\n    const uploadPrice = new BigNumber((await turbo.getUploadCosts({ bytes: [fileSize]}))[0].winc);\n\n    /// Check the current Winc balance\n    const currentBalance = new BigNumber((await turbo.getBalance()).winc);\n\n    /// Calculate how much Winc is required to upload the file\n    const requiredWinc = uploadPrice.isGreaterThan(currentBalance)\n        ? uploadPrice.minus(currentBalance)\n        : new BigNumber(0); // If balance is enough, no Winc is required\n\n    /// If the required Winc is 0, we already have enough to upload the file\n    if (requiredWinc.isEqualTo(0)) { return 0; }\n\n    /// Calculate how much Winc 1 SOL is worth (1 SOL = 1_000_000_000 Lamports)\n    const wincForOneSol = new BigNumber((await turbo.getWincForToken({ tokenAmount: 1_000_000_000 })).winc);\n\n    /// Calculate how much SOL is required to upload the file (return in SOL)\n    const requiredSol = requiredWinc.dividedBy(wincForOneSol).toNumber();\n\n    /// Return the amount of SOL required in Lamports\n    return Math.floor(requiredSol * 1_000_000_000)\n}\n```\n\n----------------------------------------\n\nTITLE: Distributing Funds with NFT Model\nDESCRIPTION: Demonstrates distributing funds using the NFT membership model by specifying the member's public key and associated NFT mint in the distribute method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst member1\n.\nmint = \"NFT Mint for Member 1\";\n\nlet distributeToMember1 = await fanoutSdk.distributeNftMemberInstructions(\n  {\n    distributeForMint: false,\n    member: member1.publicKey,\n    membershipKey: member1.mint,\n    fanout: fanout,\n    payer: distributionBot.publicKey,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: CreateV1 CPI Builder Constructor Implementation\nDESCRIPTION: Internal implementation of the CreateV1 CPI Builder's new() function showing required accounts and data fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub fn new(program: &'b solana_program::account_info::AccountInfo<'a>) -> Self {\n        let instruction = Box::new(CreateV1CpiBuilderInstruction {\n            __program: program,\n            asset: None,\n            collection: None,\n            authority: None,\n            payer: None,\n            owner: None,\n            update_authority: None,\n            system_program: None,\n            log_wrapper: None,\n            data_state: None,\n            name: None,\n            uri: None,\n            plugins: None,\n            __remaining_accounts: Vec::new(),\n        });\n        Self { instruction }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Asset Creation Arguments\nDESCRIPTION: Structure defining required arguments for Core NFT Asset creation including name and URI\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateAssetArgs {\n    name: String,\n    uri: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Asset Signatures Using JavaScript and UMI\nDESCRIPTION: This snippet demonstrates how to use the UMI framework to retrieve transaction signatures associated with a compressed asset. It imports necessary modules, creates a UMI instance with DAS API, and queries asset signatures by asset ID.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-signatures.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst assets = await umi.rpc.getAssetSignatures({\n  assetId: publicKey('GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA'),\n  // Optional parameters\n  // limit: 10,\n  // page: 1,\n  // sortDirection: 'desc',\n});\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Loading Programs in Local Validator\nDESCRIPTION: CLI command to load downloaded programs into the local test validator, with optional reset flag to ensure a clean testing environment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsolana-test-validator --bpf-program <address to load the program to> <path to program file> --reset\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine Authority\nDESCRIPTION: This command updates the Candy Machine authority (the public key controlling the Candy Machine) using the '-n' option followed by the new public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/config.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar config update -n <NEW PUBLIC KEY>\n```\n\n----------------------------------------\n\nTITLE: Example Response for MPL Core Collection Query in JSON\nDESCRIPTION: This is an example response from the das.getCollection method, showing the structure of a collection object. It includes the collection's public key, URI, name, content data, header with owner information, royalties configuration, and collection statistics.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-collection.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  publicKey: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav',\n  uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n  name: 'Number Collection',\n  content: {\n    '$schema': 'https://schema.metaplex.com/nft1.0.json',\n    json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    files: [ [Object] ],\n    metadata: {\n      attributes: [Array],\n      description: 'Collection of 10 numbers on the blockchain. This is the number 1/10.',\n      name: 'Number Collection',\n      symbol: ''\n    },\n    links: {\n      image: 'https://arweave.net/swS5eZNrKGtuu5ebdqotzPny4OBoM4wHneZ_Ld17ZU8?ext=png'\n    }\n  },\n  header: {\n    executable: false,\n    owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n    lamports: { basisPoints: 2268960n, identifier: 'SOL', decimals: 9 },\n    rentEpoch: 18446744073709551616n,\n    exists: true\n  },\n  royalties: {\n    authority: { type: 'UpdateAuthority' },\n    basisPoints: 500,\n    creators: [ [Object] ],\n    ruleSet: { __kind: 'None', type: 'None' },\n    offset: 138n\n  },\n  key: 5,\n  updateAuthority: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n  numMinted: 1,\n  currentSize: 1\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Candy Guard Details\nDESCRIPTION: Command to show the current Candy Guard details in the terminal, including rules and settings for minting access.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nsugar guard show\n```\n\n----------------------------------------\n\nTITLE: Adding Members with Wallet Model\nDESCRIPTION: This snippet shows how to add members to a Hydra wallet using the Wallet membership model, where each member's public address and share are specified.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst member = new Keypair();\n\nconst { membershipAccount } = await fanoutSdk.addMemberWallet({\n  fanout: init.fanout,\n  fanoutNativeAccount: init.nativeAccount,\n  membershipKey: member.publicKey,\n  shares: 10\n});\n\n// Add members until sum of shares = totalShares\n...\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with Asset Gate Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the Asset Gate guard. It specifies the required collection for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    assetGate: some({\n      requiredCollection: requiredCollection.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Program Gate guard in JavaScript/TypeScript\nDESCRIPTION: Code snippet demonstrating how to create a Candy Machine with the Program Gate guard in TypeScript. The guard accepts a list of additional program public keys (up to 5) that are allowed to include instructions in the mint transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/program-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    programGate: some({ additional: [<PUBKEY 1>, <PUBKEY 2>, ..., <PUBKEY 5>] }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Gatekeeper Guard in Sugar CLI\nDESCRIPTION: This JSON snippet shows how to configure the Gatekeeper guard in the Sugar CLI's config.json file. It includes the Gatekeeper Network public key and the expireOnUse flag.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/gatekeeper.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"gatekeeper\" : {\n    \"gatekeeperNetwork\": \"<PUBKEY>\",\n    \"expireOnUse\": boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Third Party Signer Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the Third Party Signer guard. It configures a signer that will be required for all mint transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/third-party-signer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myConfiguredSigner = generateSigner(umi);\n\ncreate(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signerKey: myConfiguredSigner.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Executing NFT to Token Swap in MPL-Hybrid\nDESCRIPTION: Demonstrates how to call the releaseV1 function to swap an NFT for SPL Tokens. The function requires the owner's identity, escrow configuration, asset details, collection information, fee wallet, and token account details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/swapping-nfts-to-tokens.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait releaseV1(umi, {\n    // The owner of the asset being swapped.\n    owner: umi.identity,\n    // The escrow configuration address.\n    escrow: publicKey(\"11111111111111111111111111111111\"),\n    // The Asset that will be swapped for SPL Tokens.\n    asset: publicKey(\"22222222222222222222222222222222\"),\n    // The collection assigned to the escrow configuration.\n    collection: publicKey(\"33333333333333333333333333333333\"),\n    // The fee wallet address.\n    feeProjectAccount: publicKey(\"44444444444444444444444444444444\"),\n    // The Token Account of the Wallet.\n    token: publicKey(\"55555555555555555555555555555555\"),\n  }).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Verifying On-chain Items with Sugar CLI\nDESCRIPTION: Basic command to verify that all items in the default cache.json file have been successfully written to the blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/verify.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar verify\n```\n\n----------------------------------------\n\nTITLE: Converting Transactions from Web3.js to Umi in TypeScript\nDESCRIPTION: This snippet demonstrates how to create legacy and versioned transactions in Web3.js and convert them to Umi format using adapter functions. It requires the @solana/web3.js and @metaplex-foundation/umi-web3js-adapters packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transaction, VersionedTransaction, TransactionMessage, Connection, clusterApiUrl, SystemProgram } from '@solana/web3.js';\nimport { fromWeb3JsLegacyTransaction, fromWeb3JsTransaction } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Create a new Legacy Transaction\nconst web3jsTransaction = new Transaction().add(SystemProgram.transfer({...TransferParams}));\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiTransaction = fromWeb3JsLegacyTransaction(web3jsTransaction);\n\n/// Versioned Transactions ///\n\n// Create a new Versioned Transaction\nconst web3jsVersionedTransaction = new VersionedTransaction(...messageV0Params);\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiVersionedTransaction = fromWeb3JsTransaction(web3jsVersionedTransaction);\n```\n\n----------------------------------------\n\nTITLE: Loading Accounts in Local Validator\nDESCRIPTION: CLI command to load downloaded accounts into the local test validator, with optional reset flag to ensure a clean testing environment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsolana-test-validator --account <address to load the account to> <path to account file> --reset\n```\n\n----------------------------------------\n\nTITLE: Minting Tokens in Solana using Umi\nDESCRIPTION: This snippet shows how to mint new tokens to a specified Token account using Umi. It requires the mint authority, mint, token account, and the amount to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mintTokensTo } from '@metaplex-foundation/mpl-toolbox'\n\nawait mintTokensTo(umi, {\n  mintAuthority,\n  mint,\n  token,\n  amount: 42,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Mapping Serializers to Loosen Type Constraints in TypeScript\nDESCRIPTION: This example demonstrates using mapSerializer to loosen type constraints of a serializer. It transforms a serializer with a required age field to one where age is optional.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Person = { name: string, age: number };\ntype PersonWithOptionalAge = { name: string, age?: number };\n\nconst serializerA: Serializer<Person> = ...;\nconst serializerB: Serializer<PersonWithOptionalAge, Person> = mapSerializer(\n  serializerA,\n  (value: PersonWithOptionalAge): Person => ({\n    name: value.name,\n    age: value.age ?? 42,\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Revoking a Delegate Authority for a Bubblegum Tree using JavaScript\nDESCRIPTION: This code shows how to revoke an existing delegate authority by setting the tree creator as the new delegate. It requires the merkleTree address, treeCreator signer, and uses the treeCreator's public key as the new delegate.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/delegate-trees.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setTreeDelegate } from '@metaplex-foundation/mpl-bubblegum'\n\nawait setTreeDelegate(umi, {\n  merkleTree,\n  treeCreator,\n  newTreeDelegate: treeCreator.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Group Using JavaScript and DAS API\nDESCRIPTION: This JavaScript code snippet demonstrates how to use the DAS API to fetch NFT assets by a specified collection address. The code initializes the Umi SDK, sets the RPC endpoint, and retrieves available assets linked with the given collection, handling the results asynchronously.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/get-by-collection.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst endpoint = '<ENDPOINT>';\nconst collection = 'J2ZfLdQsaZ3GCmbucJef3cPnPwGcgjDW1SSYtMdq3L9p'\n\nconst umi = createUmi(endpoint).use(dasApi());\n\nconst assets = await umi.rpc.getAssetsByGroup({\n    groupKey: 'collection',\n    groupValue: collection,\n});\nconsole.log(assets.items.length > 0);\n```\n\n----------------------------------------\n\nTITLE: Configuring Program Gate guard in Sugar JSON config\nDESCRIPTION: JSON configuration for the Program Gate guard when using Sugar CLI. The configuration allows specifying up to 5 additional program public keys that are permitted to include instructions in the mint transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/program-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"programGate\" : {\n    \"additional\": [\"<PUBKEY 1>\", \"<PUBKEY 2>\", ..., \"<PUBKEY 5>\"],\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Metadata JSON Structure\nDESCRIPTION: Example JSON structure for collection metadata, which is similar to NFT metadata but represents the entire collection. This file should be named collection.json in the assets folder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"My Collection\",\n  \"description\": \"This is My Nft Collection\",\n  \"image\": \"collection.jpg\",\n  \"external_url\": \"https://example.com\",\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://example.com/1.jpg\",\n        \"type\": \"image/jpg\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Compatibility Rule Set JSON Configuration\nDESCRIPTION: Defines the rule set configuration that mimics standard NFT transfer restrictions. This configuration allows all operations to maintain compatibility with traditional NFT behavior.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/mplx-rule-sets.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"libVersion\": 1,\n  \"owner\": \"ELskdHjzTQ6F4bBibhk4iqy63gSPs8ELec9HbfAaSDJk\",\n  \"ruleSetName\": \"Compatibility Rule Set\",\n  \"operations\": {\n    \"Transfer:WalletToWallet\": \"Pass\",\n    \"Transfer:Owner\": \"Pass\",\n    \"Transfer:MigrationDelegate\": \"Pass\",\n    \"Transfer:SaleDelegate\": \"Pass\",\n    \"Transfer:TransferDelegate\": \"Pass\",\n    \"Delegate:LockedTransfer\": \"Pass\",\n    \"Delegate:Update\": \"Pass\",\n    \"Delegate:Transfer\": \"Pass\",\n    \"Delegate:Utility\": \"Pass\",\n    \"Delegate:Staking\": \"Pass\",\n    \"Delegate:Authority\": \"Pass\",\n    \"Delegate:Collection\": \"Pass\",\n    \"Delegate:Use\": \"Pass\",\n    \"Delegate:Sale\": \"Pass\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Anchor SPL Dependencies\nDESCRIPTION: Command to add the anchor-spl dependency for interacting with the Solana Token Program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo add anchor-spl\n```\n\n----------------------------------------\n\nTITLE: Non-Fungible Token JSON Schema Example\nDESCRIPTION: Example JSON schema for standard NFTs with Metadata PDA and Master Edition PDA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-standard.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"SolanaArtProject #1\",\n  \"description\": \"Generative art on Solana.\",\n  \"image\": \"https://arweave.net/26YdhY_eAzv26YdhY1uu9uiA3nmDZYwP8MwZAultcE?ext=jpeg\",\n  \"animation_url\": \"https://arweave.net/ZAultcE_eAzv26YdhY1uu9uiA3nmDZYwP8MwuiA3nm?ext=glb\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://www.arweave.net/abcd5678?ext=png\",\n        \"type\": \"image/png\"\n      },\n      {\n        \"uri\": \"https://watch.videodelivery.net/9876jkl\",\n        \"type\": \"unknown\",\n        \"cdn\": true\n      },\n      {\n        \"uri\": \"https://www.arweave.net/efgh1234?ext=mp4\",\n        \"type\": \"video/mp4\"\n      }\n    ],\n    \"category\": \"video\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching RPC Endpoint and Cluster in TypeScript\nDESCRIPTION: This snippet provides methods to fetch the RPC's endpoint and cluster information after setting an RPC implementation, showcasing a critical Umi RpcInterface feature.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst endpoint = umi.rpc.getEndpoint();\nconst cluster = umi.rpc.getCluster();\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Machine Data from Solana Blockchain\nDESCRIPTION: Code to initialize Umi with the Metaplex Aura Devnet endpoint and fetch Candy Machine data. This retrieves information such as available items, redeemed items, and mint authority from a specific Candy Machine identified by its ID.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  mplCandyMachine,\n  fetchCandyMachine,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\n\n// The next two lines are only required if you did not set up umi before\n// We will be using Solana Devnet from Aura data network as endpoint\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n            .use(mplCandyMachine());\n\nconst candyMachineId = \"Ct5CWicvmjETYXarcUVJenfz3CCh2hcrCM3CMiB8x3k9\";\nconst candyMachine = await fetchCandyMachine(umi, publicKey(candyMachineId));\nconsole.log(candyMachine)\n```\n\n----------------------------------------\n\nTITLE: Creating a Token Account Instruction in Typescript\nDESCRIPTION: This snippet creates a token account instruction using the `createTokenIfMissing` method from `@metaplex-foundation/mpl-toolbox`. This instruction creates a new token account if one doesn't exist, otherwise it skips the creation. It specifies the mint, owner, and the associated token program ID.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n  // This instruction will create a new Token Account if required, if one is found then it skips.\n\n  const createTokenIx = createTokenIfMissing(umi, {\n    mint: mintSigner.publicKey,\n    owner: umi.identity.publicKey,\n    ataProgram: getSplAssociatedTokenProgramId(umi),\n  });\n```\n\n----------------------------------------\n\nTITLE: Initializing Allocation Tracker PDA in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to initialize the Allocation Tracker PDA for default guards and for a specific group using the route function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allocation.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'allocation',\n  routeArgs: {\n    id: 1,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'allocation',\n  routeArgs: {\n    id: 1,\n    candyGuardAuthority: umi.identity,\n  },\n  group: some('GROUPA'),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring TransferV1 CPI Builder\nDESCRIPTION: Example of configuring all required accounts for a TransferV1 CPI call.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new()\n        .asset(ctx.accounts.asset)\n        .collection(context.accounts.collection)\n        .payer(context.accounts.payer)\n        .authority(context.accounts.authority)\n        .new_owner(context.accounts.new_owner)\n        .system_program(context.accounts.system_program)\n```\n\n----------------------------------------\n\nTITLE: Signing Single and Multiple Transactions in TypeScript\nDESCRIPTION: Demonstrates how to sign a single transaction and multiple transactions using a Signer instance. The signTransaction method is used for single transactions, while signAllTransactions is used for multiple transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = await mySigner.signTransaction(myTransaction);\nconst mySignedTransactions = await mySigner.signAllTransactions(myTransactions);\n```\n\n----------------------------------------\n\nTITLE: Computing Hash and Updating Config in Sugar CLI\nDESCRIPTION: This command computes a hash of the cache file and updates the hash value in the config file. It's used when hidden settings are enabled in Metaplex NFT projects.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/hash.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar hash\n```\n\n----------------------------------------\n\nTITLE: Configuring Candy Machine Settings in JSON for Sugar\nDESCRIPTION: This JSON snippet demonstrates a basic configuration file for Sugar, including Candy Machine settings, upload methods, and guard configurations. It covers token standards, asset details, creator information, and various guard groups for minting access control.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/configuration.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tokenStandard\": \"pnft\",\n  \"number\": 10,\n  \"symbol\": \"TEST\",\n  \"sellerFeeBasisPoints\": 500,\n  \"isMutable\": true,\n  \"isSequential\": false,\n  \"ruleSet\": \"eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9\",\n  \"creators\": [\n    {\n      \"address\": \"PanbgtcTiZ2PveV96t2FHSffiLHXXjMuhvoabUUKKm8\",\n      \"share\": 50\n    },\n    {\n      \"address\": \"PanbgtcTiZ2PveV96t2FHSffiLHXXjMuhvoabUUKKm8\",\n      \"share\": 50\n    }\n  ],\n  \"hiddenSettings\": null,\n  \"uploadMethod\": \"bundlr\",\n  \"awsConfig\": null,\n  \"nftStorageAuthToken\": null,\n  \"shdwStorageAccount\": null,\n  \"pinataConfig\": null,\n  \"sdriveApiKey\": null,\n  \"guards\": {\n    \"default\": {\n      \"botTax\": {\n        \"value\": 0.01,\n        \"lastInstruction\": true\n      }\n    },\n    \"groups\": [\n      {\n        \"label\": \"OGs\",\n        \"guards\": {\n          \"startDate\": {\n            \"date\": \"2022-10-20 12:00:00 +0000\"\n          },\n          \"tokenGate\": {\n            \"amount\": 1,\n            \"mint\": \"7nE1GmnMmDKiycFkpHF7mKtxt356FQzVonZqBWsTWZNf\"\n          },\n          \"solPayment\": {\n            \"value\": 1,\n            \"destination\": \"PanbgtcTiZ2PveV96t2FHSffiLHXXjMuhvoabUUKKm8\"\n          }\n        }\n      },\n      {\n        \"label\": \"Public\",\n        \"guards\": {\n          \"startDate\": {\n            \"date\": \"2022-10-20 18:00:00 +0000\"\n          },\n          \"solPayment\": {\n            \"value\": 2,\n            \"destination\": \"PanbgtcTiZ2PveV96t2FHSffiLHXXjMuhvoabUUKKm8\"\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds in Sugar CLI\nDESCRIPTION: Unlocks the funds after all NFTs have been thawed. This command should be used once all assets are no longer frozen.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/freeze.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar freeze unlock-funds\n```\n\n----------------------------------------\n\nTITLE: Installing Core Candy Machine Rust SDK\nDESCRIPTION: Command to add the mpl-core-candy-machine-core crate to your Rust project using Cargo. This SDK can be used in scripts, desktop/mobile applications, or Solana on-chain programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/sdk/rust.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-core-candy-machine-core\n```\n\n----------------------------------------\n\nTITLE: Installing Umi Core Package for Solana Development\nDESCRIPTION: Command to install the Metaplex Umi core package which provides essential functionality for interacting with the Solana blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\n----------------------------------------\n\nTITLE: Update Candy Machine Collection\nDESCRIPTION: Demonstrates how to update the Collection NFT associated with a Candy Machine. This requires the collection's update authority as a signer and can only be done before the first NFT is minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nawait setCollectionV2(umi, {\n  candyMachine: candyMachine.publicKey,\n  collectionMint: candyMachine.collectionMint,\n  collectionUpdateAuthority: collectionUpdateAuthority.publicKey,\n  newCollectionMint: newCollectionMint.publicKey,\n  newCollectionUpdateAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Defining Collection Creation Arguments\nDESCRIPTION: Struct definition for collection creation arguments containing name and URI fields with Anchor serialization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateCollectionArgs {\n    name: String,\n    uri: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with Wallet Adapter for Core NFT Asset Creation\nDESCRIPTION: Sets up Umi using the Solana Wallet Adapter. This approach is suitable for web applications using React.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'\nimport { useWallet } from '@solana/wallet-adapter-react'\n\nconst wallet = useWallet()\n\nconst umi = createUmi('https://api.devnet.solana.com')\n.use(mplCore())\n// Register Wallet Adapter to Umi\n.use(walletAdapterIdentity(wallet))\n```\n\n----------------------------------------\n\nTITLE: Creating a Collection with an Oracle Plugin in Rust\nDESCRIPTION: Shows how to create an MPL Core collection with an Oracle plugin in Rust that can validate transfer operations. Uses the mpl_core crate and Solana SDK to build and submit the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::CreateCollectionV2Builder,\n    types::\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent, OracleInitInfo,\n        ValidationResultsOffset,\n    },\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn create_collection_with_oracle_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let payer = Keypair::new();\n    let collection = Keypair::new();\n\n    let onchain_oracle_plugin = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let create_collection_with_oracle_plugin_ix = CreateCollectionV2Builder::new()\n        .collection(collection.pubkey())\n        .payer(payer.pubkey())\n        .name(\"My Collection\".into())\n        .uri(\"https://example.com/my-collection.json\".into())\n        .external_plugin_adapters(vec![ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\n            base_address: onchain_oracle_plugin,\n            init_plugin_authority: None,\n            lifecycle_checks: vec![(\n                HookableLifecycleEvent::Transfer,\n                ExternalCheckResult { flags: 4 },\n            )],\n            base_address_config: None,\n            results_offset: Some(ValidationResultsOffset::Anchor),\n        })])\n        .instruction();\n\n    let signers = vec![&collection, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let create_collection_with_oracle_plugin_tx = Transaction::new_signed_with_payer(\n        &[create_collection_with_oracle_plugin_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&create_collection_with_oracle_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Token2022 Payment Guard in TypeScript\nDESCRIPTION: Example showing how to create a Candy Machine with Token2022 Payment guard using the Umi framework. The code sets up payment requirements including amount, mint address, and destination token account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token2022-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAssociatedTokenPda } from \"@metaplex-foundation/mpl-toolbox\";\ncreate(umi, {\n  // ...\n  guards: {\n    token2022Payment: some({\n      amount: 300,\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Generating PublicKey in Web3.js\nDESCRIPTION: TypeScript code showing how to generate a PublicKey using Solana Web3.js.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from '@solana/web3.js';\n\n// Generate a new Web3Js Publickey\nconst web3jsPublickey = new PublicKey(\"1111111111111111111111111111111111111111\");\n```\n\n----------------------------------------\n\nTITLE: Using find_pda Method for Off-chain Clients in Rust\nDESCRIPTION: This snippet demonstrates how to use the `find_pda` method in off-chain clients to find the metadata PDA for a given mint address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet (metadata_pubkey, _) = Metadata::find_pda(mint);\n```\n\n----------------------------------------\n\nTITLE: Invoking a CPI call with invoke_signed() in Rust\nDESCRIPTION: Illustrates how to use invoke_signed() for CPI calls that require a PDA signer, including passing signer seeds for proper transaction processing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet signers = &[&[b\"escrow\", ctx.accounts.asset.key(), &[ctx.bumps.pda_escrow]]]\n\nCreateV1CpiBuilder::new()\n        .asset(context.accounts.asset)\n        ...\n        .invoke(signers)\n```\n\n----------------------------------------\n\nTITLE: Updating Signer with Wallet Adapter in umiProvider\nDESCRIPTION: This code snippet shows how to update the signer in the Umi store when the wallet's public key changes. It uses a React hook to accomplish this. Dependencies include Zustand for state management and a wallet adapter supporting Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nuseEffect(() => {\n  if (!wallet.publicKey) return\n  umiStore.updateSigner(wallet as unknown as WalletAdapter)\n}, [wallet, umiStore])\n```\n\n----------------------------------------\n\nTITLE: Using Serializer Options in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the optional 'options' argument in serializers to provide custom descriptions. It shows the default description and how to override it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { string } from '@metaplex-foundation/umi/serializers';\n\nstring().description; // -> 'string(utf8; u32(le))'.\nstring({ description: 'My custom string description' });\n```\n\n----------------------------------------\n\nTITLE: Implementing PDA Helper Methods for Metadata in Rust\nDESCRIPTION: This snippet shows the implementation of `find_pda` and `create_pda` methods for the `Metadata` struct. These methods are used to find or create Program Derived Addresses (PDAs) for metadata accounts associated with a given mint address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl Metadata {\n    pub fn find_pda(mint: Pubkey) -> (Pubkey, u8) {\n        Pubkey::find_program_address(\n            &[\n                \"metadata\".as_bytes(),\n                crate::MPL_TOKEN_METADATA_ID.as_ref(),\n                mint.as_ref(),\n            ],\n            &crate::MPL_TOKEN_METADATA_ID,\n        )\n    }\n\n    pub fn create_pda(\n        mint: Pubkey,\n        bump: u8,\n    ) -> Result<Pubkey, PubkeyError> {\n        Pubkey::create_program_address(\n            &[\n                \"metadata\".as_bytes(),\n                crate::MPL_TOKEN_METADATA_ID.as_ref(),\n                mint.as_ref(),\n                &[bump],\n            ],\n            &crate::MPL_TOKEN_METADATA_ID,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Redeemed Amount Guard with Groups in Sugar Config\nDESCRIPTION: This JSON configuration shows how to implement Guard Groups with the Redeemed Amount guard using Sugar. The setup creates two pricing tiers where early minters (first 300) pay 1 SOL and late minters pay 2 SOL.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n    \"groups\": [\n      {\n        \"label\": \"early\",\n        \"guards\": {\n          \"redeemedAmount\": {\n            \"maximum\": 300,\n          },\n          \"solPayment\": {\n            \"value\": 1,\n            \"destination\": \"<PUBKEY>\"\n          }\n        }\n      },\n      {\n        \"label\": \"late\",\n        \"guards\": {\n          \"solPayment\": {\n            \"value\": 2,\n            \"destination\": \"<PUBKEY>\"\n          }\n        }\n      }\n    ]\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule Set with Pass in JavaScript\nDESCRIPTION: This code snippet demonstrates how to create a RuleSetRevisionV2 that uses the 'Pass' rule for the deposit operation.  The 'Pass' rule always evaluates to true, effectively allowing any deposit operation.  The snippet includes the required properties such as libVersion, name, owner, and operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/pass.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will always evaluate to true.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    deposit: {\n      type: 'Pass',\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing US Market Open Check Helper Function in Rust\nDESCRIPTION: This helper function checks if the US market is open based on a given Unix timestamp, considering weekdays and market hours.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn is_us_market_open(unix_timestamp: i64) -> bool {\n    let seconds_since_midnight = unix_timestamp % SECONDS_IN_A_DAY;\n    let weekday = (unix_timestamp / SECONDS_IN_A_DAY + 4) % 7;\n\n    // Check if it's a weekday (Monday = 0, ..., Friday = 4)\n    if weekday >= 5 {\n        return false;\n    }\n\n    // Check if current time is within market hours\n    seconds_since_midnight >= MARKET_OPEN_TIME && seconds_since_midnight < MARKET_CLOSE_TIME\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Collection Address for an Asset in TypeScript\nDESCRIPTION: This function finds the collection address for a given asset if it is part of a collection. It returns either a publicKey or undefined.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nexport function collectionAddress(asset: AssetV1)\n```\n\n----------------------------------------\n\nTITLE: Authorization Data Structure\nDESCRIPTION: Example of the authorization data structure used for rule validation in pNFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/pnfts.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst = authorizationData: { payload: ... },\n```\n\n----------------------------------------\n\nTITLE: Preparing Reveal Data with Hash Generation for Hidden Settings\nDESCRIPTION: Creating and hashing reveal data that will be used during the NFT reveal process. The example includes metadata for 5 NFTs with their names and URIs, along with generating a SHA-256 hash of this data for validation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport crypto from 'crypto';\n\n// Reveal data of our assets, to be used during the reveal process\nconst revealData = [\n      { name: 'Nft #1', uri: 'http://example.com/1.json' },\n      { name: 'Nft #2', uri: 'http://example.com/2.json' },\n      { name: 'Nft #3', uri: 'http://example.com/3.json' },\n      { name: 'Nft #4', uri: 'http://example.com/4.json' },\n      { name: 'Nft #5', uri: 'http://example.com/5.json' },\n    ]\n\nlet string = JSON.stringify(revealData)\nlet hash = crypto.createHash('sha256').update(string).digest()\n```\n\n----------------------------------------\n\nTITLE: Verifying Creator in MPL Core Asset\nDESCRIPTION: This snippet demonstrates how a creator can verify themselves using the updatePlugin function. It assumes that the umi identity is the Creator.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\nconst publicKeyToVerify = publicKey(\"abc...\")\n\n// The creator that you want to verify\nconst updatedCreators = asset.verifiedCreators.signatures.map(creator => {\n  if (creator.address === publicKeyToVerify) {\n    return { ...creator, verified: true };\n  }\n  return creator;\n});\n\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n    signatures: updatedCreators,\n  },\n  authority: umi.identity,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Deriving Asset Plugins in TypeScript\nDESCRIPTION: This function derives asset plugins from the asset and collection. Plugins on the asset take precedence over plugins on the collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexport function deriveAssetPlugins(asset: AssetV1, collection?: CollectionV1)\n```\n\n----------------------------------------\n\nTITLE: Converting Base58 Transaction Signature to Uint8Array Format\nDESCRIPTION: Demonstrates converting a base58-encoded transaction signature to Uint8Array format, which is necessary when working with signatures from external sources like explorers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\nconst signature = \"4NJhR8zm3G7hU1uhPZaBiTMBCERh4CWp2cF1x2Ly9yCvenrY6oS9hF2PAGfT26odWvb49BktkWkoBPGoXMYUVqkY\";\n\nconst transaction: Uint8Array = base58.serialize(signature)\n```\n\n----------------------------------------\n\nTITLE: Initializing Freeze Escrow using Sugar CLI\nDESCRIPTION: Shows how to initialize a Freeze Escrow account using the Sugar CLI tool. Includes the basic command and all available configuration parameters for customizing the initialization process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsugar freeze initialize\n```\n\nLANGUAGE: text\nCODE:\n```\n    -c, --config <CONFIG>\n            Path to the config file [default: config.json]\n\n        --cache <CACHE>\n            Path to the cache file, defaults to \"cache.json\" [default: cache.json]\n\n        --candy-guard <CANDY_GUARD>\n            Address of candy guard to update [defaults to cache value]\n\n        --candy-machine <CANDY_MACHINE>\n            Address of candy machine to update [defaults to cache value]\n\n        --destination <DESTINATION>\n            Address of the destination (treasury) account\n\n    -h, --help\n            Print help information\n\n    -k, --keypair <KEYPAIR>\n            Path to the keypair file, uses Sol config or defaults to \"~/.config/solana/id.json\"\n\n    -l, --log-level <LOG_LEVEL>\n            Log level: trace, debug, info, warn, error, off\n\n        --label <LABEL>\n            Candy guard group label\n\n    -r, --rpc-url <RPC_URL>\n            RPC Url\n```\n\n----------------------------------------\n\nTITLE: Escrow Configuration Response Format\nDESCRIPTION: This snippet illustrates the structure of the object returned from the `fetchEscrowV1` function. It outlines the various fields included in the response such as publicKey, header, discriminator, collection details, and transaction-specific parameters. The response is designed to provide comprehensive escrow information for further processing or display purposes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/fetch-escrow.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    publicKey: '11111111111111111111111111111111',\n    header: {\n      executable: false,\n      owner: 'MPL4o4wMzndgh8T1NVDxELQCj5UQfYTYEkabX3wNKtb',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    discriminator: [\n       26,  90, 193, 218,\n      188, 251, 139, 211\n    ],\n    collection: '11111111111111111111111111111111',\n    authority: '11111111111111111111111111111111',\n    token: '11111111111111111111111111111111',\n    feeLocation: '11111111111111111111111111111111',\n    name: 'My Escrow',\n    uri: 'https://mybaseuri.net/',\n    max: 100n,\n    min: 0n,\n    amount: 1000000000n,\n    feeAmount: 2n,\n    solFeeAmount: 0n,\n    count: 1n,\n    path: 0,\n    bump: 255\n  }\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple Candy Machine Setup Commands\nDESCRIPTION: The launch command executes five consecutive commands (create-config, validate, upload, deploy, verify) to automate the complete Candy Machine setup process from a project folder containing assets.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/launch.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `create-config`\n- `validate`\n- `upload`\n- `deploy`\n- `verify`\n```\n\n----------------------------------------\n\nTITLE: Deserializing MsgPack Schema in JavaScript\nDESCRIPTION: This snippet explains that in the JavaScript SDK, deserialization for the MsgPack schema is handled automatically, similar to JSON. The deserialized data can be accessed directly from the raw location.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n// Due to the JS SDK, the deserialization for the MsgPack schema is automatic and deserialized\n// data can be accessed at the RAW location example above.\n```\n\n----------------------------------------\n\nTITLE: Setting Up Required Imports and Wrapper Function for cNFT Creation\nDESCRIPTION: TypeScript code that imports all necessary packages and defines a wrapper function structure for creating compressed NFTs on Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTree,\n  findLeafAssetIdPda,\n  getAssetWithProof,\n  mintV1,\n  mplBubblegum,\n  parseLeafFromMintV1Transaction,\n} from '@metaplex-foundation/mpl-bubblegum'\nimport {\n  createNft,\n  mplTokenMetadata,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  createGenericFile,\n  generateSigner,\n  percentAmount,\n  publicKey,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { Network, Wallet, umiInstance } from '../scripts/umi'\n\nimport fs from 'fs'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\n\n// Create the wrapper function\nconst createCnft = async () => {\n  ///\n  ///\n  ///  all our code will go in here\n  ///\n  ///\n}\n\n// run the wrapper function\ncreateCnft()\n```\n\n----------------------------------------\n\nTITLE: Plugin Lifecycle Validation Table - Create\nDESCRIPTION: Table showing plugin validation rules for asset creation lifecycle event\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Plugin    | Action     | Conditions |\n| --------- | ---------- | ---------- |\n| Royalties | Can Reject | Ruleset    |\n```\n\n----------------------------------------\n\nTITLE: Using Interfaces in Umi Plugins\nDESCRIPTION: Shows how plugins can use existing Umi interfaces. The example demonstrates registering a new program to the program repository interface and setting the `override` argument to prevent duplicates.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const mplTokenMetadata = (): UmiPlugin => ({\n  install(umi) {\n    umi.programs.add(createMplTokenMetadataProgram(), false);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Assets Using cURL\nDESCRIPTION: This example shows how to make a direct JSON-RPC request to the DAS API using cURL. It sends a POST request with an array of asset IDs to retrieve their information via the getAssets method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-assets.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssets\",\n    \"params\": [\n      [\n        \"GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA\",\n        \"8bFQbnBrzeiYQabEJ1ghy5T7uFpqFzPjUGsVi3SzSMHB\"\n      ]\n    ],\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Using Kinobi-Generated Library for Account Deserialization\nDESCRIPTION: Demonstrates account deserialization using a Kinobi-generated library with various helper methods.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Metadata, deserializeMetadata, fetchMetadata, safeFetchMetadata } from '@metaplex-foundation/mpl-token-metadata';\n\n// Deserializes a metadata account.\nconst metadata: Metadata = deserializeMetadata(umi, unparsedMetadataAccount);\n\n// Fetch and deserialize a metadata account, fail if the account does not exist.\nconst metadata: Metadata = await fetchMetadata(umi, metadataPublicKey);\n\n// Fetch and deserialize a metadata account, return null if the account does not exist.\nconst metadata: Metadata | null = await safeFetchMetadata(umi, metadataPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Importing Metaplex Libraries and Creating Wrapper Function\nDESCRIPTION: Importing necessary Metaplex libraries and creating a wrapper function for token creation process\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createFungible,\n  mplTokenMetadata,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport {\n  createTokenIfMissing,\n  findAssociatedTokenPda,\n  getSplAssociatedTokenProgramId,\n  mintTokensTo,\n} from '@metaplex-foundation/mpl-toolbox'\nimport {\n  generateSigner,\n  percentAmount,\n  createGenericFile,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\n// Create the wrapper function\nconst createAndMintTokens = async () => {\n  ///\n  ///\n  ///  all our code will go in here\n  ///\n  ///\n}\n\n// run the wrapper function\ncreateAndMintTokens()\n```\n\n----------------------------------------\n\nTITLE: Adding Memos to Transactions using Umi in TypeScript\nDESCRIPTION: This code snippet demonstrates how to add a memo to a transaction using the transactionBuilder from Umi and the addMemo function from the mpl-toolbox. It allows attaching a text note to a transaction before sending and confirming it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/transaction-memo.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transactionBuilder } from '@metaplex-foundation/umi'\nimport { addMemo } from '@metaplex-foundation/mpl-toolbox'\n\nawait transactionBuilder()\n  .add(...) // Any instruction(s) here.\n  .add(addMemo(umi, { memo: 'Hello world!' })) // Add a memo to the transaction.\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Implementing PDA Match Rule in Token Auth Rules\nDESCRIPTION: Example of configuring a Rule Set with PDA Match operation that validates if a derived PDA matches the provided address. The rule uses program ID, PDA field, and seeds field to perform the validation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/pda-match.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will only evaluate to true the derived PDA from the provided seeds matches the provided PDA.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    list: {\n      type: 'PdaMatch',\n      pdaField: \"Escrow\",\n      program: publicKey(\"TSWAPaqyCSx2KABk68Shruf4rp7CxcNi8hAsbdwmHbN\"),\n      seedsField: \"EscrowSeeds\",\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ImmutableMetadata Plugin to MPL Core Collection using JavaScript\nDESCRIPTION: This code snippet shows how to add the ImmutableMetadata plugin to an MPL Core Collection using the Metaplex Core library in JavaScript. It uses the addCollectionPlugin function to make the collection's metadata immutable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/immutableMetadata.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addCollectionPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'ImmutableMetadata',\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Amount Creation Helper Functions\nDESCRIPTION: Examples of helper functions for creating different types of amounts including USD, SOL, and percentage values\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Creates an amount from basis points.\ncreateAmount(123, 'USD', 2); // -> Amount for \"USD 1.23\"\n\n// Creates an amount from a decimal number.\ncreateAmountFromDecimals(1.23, 'USD', 2); // -> Amount for \"USD 1.23\"\n\n// Helper functions to create USD amounts.\nusd(1.23) // -> Amount for \"USD 1.23\"\n\n// Helper functions to handle SOL amounts.\nsol(1.23) // -> Amount for \"1.23 SOL\"\nlamports(1_230_000_000) // -> Amount for \"1.23 SOL\"\n\n// Helper function to create percent amounts.\npercentAmount(50.42); // -> Amount for \"50.42%\"\npercentAmount(50.42, 2); // -> Amount for \"50.42%\"\npercentAmount(50.42, 0); // -> Amount for \"50%\"\n\n// Helper function to create token amounts.\ntokenAmount(123); // -> Amount for \"123 Tokens\"\ntokenAmount(123, 'splToken.BONK'); // -> Amount for \"123 BONK\"\ntokenAmount(123.45, 'splToken.BONK', 2); // -> Amount for \"123.45 BONK\"\n```\n\n----------------------------------------\n\nTITLE: Delegating Plugin Authority in Rust\nDESCRIPTION: This Rust code snippet shows how to delegate a plugin authority using the MPL Core library. It creates an instruction to delegate the 'FreezeDelegate' plugin to a specified address and sends the transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::ApprovePluginAuthorityV1Builder,\n    types::{PluginAuthority, PluginType},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn delegate_plugin_authority() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let delegate_authority = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let delegate_plugin_authority_ix = ApprovePluginAuthorityV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .plugin_type(PluginType::FreezeDelegate)\n        .new_authority(PluginAuthority::Address {\n            address: delegate_authority,\n        })\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let delegate_plugin_authority_tx = Transaction::new_signed_with_payer(\n        &[delegate_plugin_authority_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&delegate_plugin_authority_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating pNFT Metadata using Rust with Anchor and anchor-spl\nDESCRIPTION: This Rust snippet uses the Anchor framework with anchor-spl 0.31.0 to update a Programmable NFT's metadata. It defines the account structure and provides an instruction to update the NFT's name and URI, handling additional accounts for Token Authorization Rules if needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/update.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::\n    metadata::\n        mpl_token_metadata::types::DataV2, update_metadata_accounts_v2, MetadataAccount,\n        UpdateMetadataAccountsV2,\n    },\n    token::Mint,\n};\n\n#[derive(Accounts)]\npub struct UpdatePnft<'info> {\n    #[account(mut)]\n    pub mint: Account<'info, Mint>,\n    /// CHECK: Handled by CPI\n    #[account(mut)]\n    pub metadata: Account<'info, MetadataAccount>,\n    #[account(mut)]\n    pub update_authority: Signer<'info>,\n    /// CHECK: Handled by CPI\n    pub token_metadata_program: AccountInfo<'info>,\n    /// CHECK: Optional collection metadata\n    #[account(mut)]\n    pub collection_metadata: Option<AccountInfo<'info>>,\n}\n\npub fn update_pnft_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, UpdatePnft<'info>>,\n    new_name: Option<String>,\n    new_uri: Option<String>,\n) {\n    let cpi_accounts = UpdateMetadataAccountsV2 {\n        metadata: ctx.accounts.metadata.to_account_info().clone(),\n        update_authority: ctx.accounts.update_authority.to_account_info().clone(),\n    };\n\n    let remaining_accounts: Vec<AccountInfo> = ctx\n        .remaining_accounts\n        .iter()\n        .map(|a| (*a).clone())\n        .collect();\n\n    // Create CPI context\n    let cpi_ctx = CpiContext::new(ctx.accounts.token_metadata_program.clone(), cpi_accounts)\n        // The two remaining accounts to include (if Token Authorization Rules are used) are:\n        // Token Authorization Rules Program\n        // Token Authorization Rules account\n        .with_remaining_accounts(remaining_accounts);\n\n    let original_metadata = DataV2 {\n        name: ctx.accounts.metadata.name.clone(),\n        symbol: ctx.accounts.metadata.symbol.clone(),\n        uri: ctx.accounts.metadata.uri.clone(),\n        seller_fee_basis_points: ctx.accounts.metadata.seller_fee_basis_points,\n        creators: ctx.accounts.metadata.creators.clone(),\n        collection: ctx.accounts.metadata.collection.clone(),\n        uses: ctx.accounts.metadata.uses.clone(),\n    };\n\n    let new_metadata = DataV2 {\n        name: new_name.clone().unwrap_or(original_metadata.name),\n        uri: new_uri.clone().unwrap_or(original_metadata.uri),\n        ..original_metadata\n    };\n\n    // Update metadata for the NFT - correct parameter order\n    update_metadata_accounts_v2(\n        cpi_ctx,\n        None,               // New update authority\n        Some(new_metadata), // Data\n        None,               // Primary sale happened\n        None,               // Is mutable\n    )\n    .expect(\"Failed to update PNFT metadata\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Address Lookup Table for Transaction Builder in Umi\nDESCRIPTION: This helper method creates LUTs specifically for a given transaction builder. It involves getting LUT builders and accounts, creating the LUTs, and then using them in the base transaction builder.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createLutForTransactionBuilder } from '@metaplex-foundation/mpl-toolbox'\n\n// 1. Get the LUT builders and the LUT accounts for a given transaction builder.\nconst recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' })\n\nconst [createLutBuilders, lutAccounts] = createLutForTransactionBuilder(\n  umi,\n  baseBuilder,\n  recentSlot\n)\n\n// 2. Create the LUTs.\nfor (const createLutBuilder of createLutBuilders) {\n  await createLutBuilder.sendAndConfirm(umi)\n}\n\n// 3. Use the LUTs in the base transaction builder.\nawait baseBuilder.setAddressLookupTables(lutAccounts).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Candy Guard Data Structure in JSON\nDESCRIPTION: This JSON represents the structure of Candy Guard data, including its publicKey, header, discriminator, base, bump, authority, guards, and groups. The `guards` object contains the default guards that are always applied, while `guards.groups` contains different Guard Groups.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"publicKey\": \"ACJCHhsWCKw9Euu9nLdyxajqitvmwrXQMRWe2mrmva8u\",\n    \"header\": {\n        \"executable\": false,\n        \"owner\": \"CMAGAKJ67e9hRZgfC5SFTbZH8MgEmtqazKXjmkaJjWTJ\",\n        \"lamports\": {\n            \"basisPoints\": \"2561280\",\n            \"identifier\": \"SOL\",\n            \"decimals\": 9\n        },\n        \"rentEpoch\": \"18446744073709551616\",\n        \"exists\": true\n    },\n    \"discriminator\": [\n        44,\n        207,\n        199,\n        184,\n        112,\n        103,\n        34,\n        181\n    ],\n    \"base\": \"Ct5CWicvmjETYXarcUVJenfz3CCh2hcrCM3CMiB8x3k9\",\n    \"bump\": 255,\n    \"authority\": \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\",\n    \"guards\": {\n        \"botTax\": {\n            \"__option\": \"None\"\n        },\n        \"solPayment\": {\n            \"__option\": \"None\"\n        },\n        \"tokenPayment\": {\n            \"__option\": \"None\"\n        },\n        \"startDate\": {\n            \"__option\": \"None\"\n        },\n        \"thirdPartySigner\": {\n            \"__option\": \"None\"\n        },\n        \"tokenGate\": {\n            \"__option\": \"None\"\n        },\n        \"gatekeeper\": {\n            \"__option\": \"None\"\n        },\n        \"endDate\": {\n            \"__option\": \"None\"\n        },\n        \"allowList\": {\n            \"__option\": \"None\"\n        },\n        \"mintLimit\": {\n            \"__option\": \"None\"\n        },\n        \"nftPayment\": {\n            \"__option\": \"None\"\n        },\n        \"redeemedAmount\": {\n            \"__option\": \"None\"\n        },\n        \"addressGate\": {\n            \"__option\": \"None\"\n        },\n        \"nftGate\": {\n            \"__option\": \"None\"\n        },\n        \"nftBurn\": {\n            \"__option\": \"None\"\n        },\n        \"tokenBurn\": {\n            \"__option\": \"None\"\n        },\n        \"freezeSolPayment\": {\n            \"__option\": \"None\"\n        },\n        \"freezeTokenPayment\": {\n            \"__option\": \"None\"\n        },\n        \"programGate\": {\n            \"__option\": \"None\"\n        },\n        \"allocation\": {\n            \"__option\": \"None\"\n        },\n        \"token2022Payment\": {\n            \"__option\": \"None\"\n        },\n        \"solFixedFee\": {\n            \"__option\": \"None\"\n        },\n        \"nftMintLimit\": {\n            \"__option\": \"None\"\n        },\n        \"edition\": {\n            \"__option\": \"None\"\n        },\n        \"assetPayment\": {\n            \"__option\": \"None\"\n        },\n        \"assetBurn\": {\n            \"__option\": \"None\"\n        },\n        \"assetMintLimit\": {\n            \"__option\": \"None\"\n        },\n        \"assetBurnMulti\": {\n            \"__option\": \"None\"\n        },\n        \"assetPaymentMulti\": {\n            \"__option\": \"None\"\n        },\n        \"assetGate\": {\n            \"__option\": \"None\"\n        },\n        \"vanityMint\": {\n            \"__option\": \"None\"\n        }\n    },\n    \"groups\": [\n        {\n            \"label\": \"group1\",\n            \"guards\": {\n                \"botTax\": {\n                    \"__option\": \"Some\",\n                    \"value\": {\n                        \"lamports\": {\n                            \"basisPoints\": \"10000000\",\n                            \"identifier\": \"SOL\",\n                            \"decimals\": 9\n                        },\n                        \"lastInstruction\": false\n                    }\n                },\n                \"solPayment\": {\n                    \"__option\": \"Some\",\n                    \"value\": {\n                        \"lamports\": {\n                            \"basisPoints\": \"100000000\",\n                            \"identifier\": \"SOL\",\n                            \"decimals\": 9\n                        },\n                        \"destination\": \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\"\n                    }\n                },\n                \"tokenPayment\": {\n                    \"__option\": \"None\"\n                },\n                \"startDate\": {\n                    \"__option\": \"Some\",\n                    \"value\": {\n                        \"date\": \"1723996800\"\n                    }\n                },\n                \"thirdPartySigner\": {\n                    \"__option\": \"None\"\n                },\n                \"tokenGate\": {\n                    \"__option\": \"None\"\n                },\n                \"gatekeeper\": {\n                    \"__option\": \"None\"\n                },\n                \"endDate\": {\n                    \"__option\": \"Some\",\n                    \"value\": {\n                        \"date\": \"1729270800\"\n                    }\n                },\n                \"allowList\": {\n                    \"__option\": \"None\"\n                },\n                \"mintLimit\": {\n                    \"__option\": \"Some\",\n                    \"value\": {\n                        \"id\": 1,\n                        \"limit\": 5\n                    }\n                },\n                \"nftPayment\": {\n                    \"__option\": \"None\"\n                },\n                \"redeemedAmount\": {\n                    \"__option\": \"None\"\n                },\n                \"addressGate\": {\n                    \"__option\": \"None\"\n                },\n                \"nftGate\": {\n                    \"__option\": \"None\"\n                },\n                \"nftBurn\": {\n                    \"__option\": \"None\"\n                },\n                \"tokenBurn\": {\n                    \"__option\": \"None\"\n                },\n                \"freezeSolPayment\": {\n                    \"__option\": \"None\"\n                },\n                \"freezeTokenPayment\": {\n                    \"__option\": \"None\"\n                },\n                \"programGate\": {\n                    \"__option\": \"None\"\n                },\n                \"allocation\": {\n                    \"__option\": \"None\"\n                },\n                \"token2022Payment\": {\n                    \"__option\": \"None\"\n                },\n                \"solFixedFee\": {\n                    \"__option\": \"None\"\n                },\n                \"nftMintLimit\": {\n                    \"__option\": \"None\"\n                },\n                \"edition\": {\n                    \"__option\": \"None\"\n                },\n                \"assetPayment\": {\n                    \"__option\": \"None\"\n                },\n                \"assetBurn\": {\n                    \"__option\": \"None\"\n                },\n                \"assetMintLimit\": {\n                    \"__option\": \"None\"\n                },\n                \"assetBurnMulti\": {\n                    \"__option\": \"None\"\n                },\n                \"assetPaymentMulti\": {\n                    \"__option\": \"None\"\n                },\n                \"assetGate\": {\n                    \"__option\": \"None\"\n                },\n                \"vanityMint\": {\n                    \"__option\": \"None\"\n                }\n            }\n        },\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Messages in Web3.js for Solana Transactions in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a message for a versioned transaction using the Web3.js library. It includes establishing a connection, getting the latest blockhash, and creating a transaction message. It requires the @solana/web3.js package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TransactionMessage, Connection, clusterApiUrl, SystemProgram } from '@solana/web3.js';\n\n// Create a new Web3Js Message\nconst connection = new Connection(clusterApiUrl(\"devnet\"));\nconst minRent = await connection.getMinimumBalanceForRentExemption(0);\nconst blockhash = await connection.getLatestBlockhash().then(res => res.blockhash);\n\nconst instructions = [SystemProgram.transfer({...TransferParams})];\n\nconst Web3JsMessage = new TransactionMessage({\n  payerKey: payer.publicKey,\n  recentBlockhash: blockhash,\n  instructions,\n}).compileToV0Message();\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Sugar from Source (Bash)\nDESCRIPTION: This command builds Sugar from source and installs the binary to ~/.cargo/bin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --path ./\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Project with npm\nDESCRIPTION: This snippet demonstrates how to initialize a new JavaScript project using npm, setting up the basic configurations required for a new project.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Asset Account Deserialization Using from_bytes()\nDESCRIPTION: Manual deserialization of a BaseAssetV1 account using from_bytes() method\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet data = ctx.accounts.asset.try_borrow_data()?;\nlet base_asset: BaseAssetV1 = BaseAssetV1::from_bytes(&data.as_ref())?\n```\n\n----------------------------------------\n\nTITLE: Installing MPL-Core Package\nDESCRIPTION: Command to install the MPL-Core JavaScript library using npm package manager.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/sdk/javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @metaplex-foundation/mpl-core\n```\n\n----------------------------------------\n\nTITLE: Calculating Hash for Hidden Settings in TypeScript\nDESCRIPTION: This code snippet shows how to calculate the hash of reveal data for Hidden Settings using the crypto module in TypeScript. It creates a SHA-256 hash of a JSON string containing NFT names and URIs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport crypto from 'crypto'\n\nconst revealData = [\n  { name: 'Nft #1', uri: 'http://example.com/1.json' },\n  { name: 'Nft #2', uri: 'http://example.com/2.json' },\n  { name: 'Nft #3', uri: 'http://example.com/3.json' },\n]\n\nconst string = JSON.stringify(revealData)\nconst hash = crypto.createHash('sha256').update(string).digest()\n\nconsole.log(hash)\n```\n\n----------------------------------------\n\nTITLE: Transfer Core Asset using Rust\nDESCRIPTION: Shows how to transfer a Core NFT Asset to a new owner using the MPL Core program's TransferV1Builder in Rust. Includes RPC client setup, transaction building, and signature confirmation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/transfer.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::instructions::TransferV1Builder;\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn transfer_asset() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let new_owner = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let transfer_asset_ix = TransferV1Builder::new()\n        .asset(asset)\n        .payer(authority.pubkey())\n        .new_owner(new_owner)\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let transfer_asset_tx = Transaction::new_signed_with_payer(\n        &[transfer_asset_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&transfer_asset_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Fungible Tokens to the Escrow using transferTokens in JavaScript\nDESCRIPTION: This snippet shows how to send fungible tokens to the escrow account. It uses libraries like `@metaplex-foundation/umi`, `@metaplex-foundation/mpl-toolbox`, and `@metaplex-foundation/mpl-hybrid`. It first creates the associated token account (ATA) for the escrow if it doesn't exist, and then transfers the specified amount of tokens to the escrow's ATA using `transferTokens`.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n\"import {\n  keypairIdentity,\n  publicKey,\n  transactionBuilder,\n} from \\\"@metaplex-foundation/umi\\\";\nimport {\n  createTokenIfMissing,\n  findAssociatedTokenPda,\n  transferTokens,\n} from \\\"@metaplex-foundation/mpl-toolbox\\\";\nimport {\n  MPL_HYBRID_PROGRAM_ID,\n  mplHybrid,\n} from \\\"@metaplex-foundation/mpl-hybrid\\\";\nimport { readFileSync } from \\\"fs\\\";\nimport { mplTokenMetadata } from \\\"@metaplex-foundation/mpl-token-metadata\\\";\nimport { createUmi } from \\\"@metaplex-foundation/umi-bundle-defaults\\\";\nimport {\n  string,\n  publicKey as publicKeySerializer,\n} from \\\"@metaplex-foundation/umi/serializers\\\";\n\n(async () => {\n  const collection = publicKey(\\\"<COLLECTION>\\\"); // The collection we are swapping to/from\n  const token = publicKey(\\\"<TOKEN MINT>\\\"); // The token we are swapping to/from\n\n  const umi = createUmi(\\\"<ENDPOINT>\\\").use(mplHybrid()).use(mplTokenMetadata());\n\n  const wallet = \\\"<path to wallet>\\\"; // The path to your filesystem Wallet\n  const secretKey = JSON.parse(readFileSync(wallet, \\\"utf-8\\\"));\n\n  // Create a keypair from your private key\n  const keypair = umi.eddsa.createKeypairFromSecretKey(\n    new Uint8Array(secretKey)\n  );\n  umi.use(keypairIdentity(keypair));\n\n  // Derive the Escrow\n  const escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: \\\"variable\\\" }).serialize(\\\"escrow\\\"),\n    publicKeySerializer().serialize(collection),\n  ])[0];\n\n  // Transfer Fungible Tokens to it (after creating the ATA if needed)\n  const transferTokenTx = await transactionBuilder()\n    .add(\n      createTokenIfMissing(umi, {\n        mint: token,\n        owner: escrow,\n      })\n    )\n    .add(\n      transferTokens(umi, {\n        source: findAssociatedTokenPda(umi, {\n          mint: token,\n          owner: umi.identity.publicKey,\n        }),\n        destination: findAssociatedTokenPda(umi, {\n          mint: token,\n          owner: escrow,\n        }),\n        amount: 300000000,\n      })\n    )\n    .sendAndConfirm(umi);\n})();\n\"\n```\n\n----------------------------------------\n\nTITLE: GpaBuilder Usage Examples\nDESCRIPTION: Examples of using GpaBuilder for handling program account queries with various filters and transformations\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Get all accounts for a program.\nawait gpaBuilder(umi, programId).get();\n\n// Get the first 32 bytes of accounts that are 500 bytes long.\nawait gpaBuilder(umi, programId)\n  .slice(0, 32)\n  .whereSize(500)\n  .get();\n\n// Get the public keys of accounts that have a given public key at offset 32.\nawait gpaBuilder(umi, programId)\n  .withoutData()\n  .where(32, myPublicKey)\n  .getPublicKey();\n\n// Get the first 32 bytes of the account data as public keys.\nawait gpaBuilder(umi, programId)\n  .slice(0, 32)\n  .getDataAsPublicKey();\n\n// Get the second byte of the account data and multiply it by 2.\nawait gpaBuilder(umi, programId)\n  .slice(1, 1)\n  .getAndMap((n) => n * 2);\n```\n\n----------------------------------------\n\nTITLE: Optimizing Transaction Size with truncateCanopy Option\nDESCRIPTION: Example showing how to optimize transaction size using the truncateCanopy option when fetching asset proofs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/faq.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst assetWithProof = await getAssetWithProof(umi, assetId, \n    { truncateCanopy: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Describing MPL-Hybrid NFT Data Structure in Rust\nDESCRIPTION: The code snippet outlines the structure of an MPL-Hybrid NFT data account on-chain. This structure is crucial for initializing and operating within MPL-Hybrid, specifying various parameters such as 'authority', 'token', and 'fee_amount'. Key fields include a combination of public keys, strings, and unsigned integers, each serving different roles within the NFT economy. Required dependencies: Rust programming environment, appropriate Solana libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/initializeNFTData.md#2025-04-17_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n| Name           | Type   | Size | Description                                      |     |\n| -------------- | ------ | ---- | ------------------------------------------------ | --- |\n| authority      | Pubkey | 32   | The Authority of the Escrow                      |     |\n| token          | Pubkey | 32   | The token to be dispensed                        |     |\n| fee_location   | Pubkey | 32   | The account to send token fees to                |     |\n| name           | String | 4    | The NFT name                                     |     |\n| uri            | String | 8    | The base uri for the NFT metadata                |     |\n| max            | u64    | 8    | The max index of NFTs that append to the uri     |     |\n| min            | u64    | 8    | The minimum index of NFTs that append to the uri |     |\n| amount         | u64    | 8    | The token cost to swap                           |     |\n| fee_amount     | u64    | 8    | The token fee for capturing the NFT              |     |\n| sol_fee_amount | u64    | 8    | The sol fee for capturing the NFT                |     |\n| count          | u64    | 8    | The total number of swaps                        |     |\n| path           | u16    | 1    | The onchain/off-chain metadata update path       |     |\n| bump           | u8     | 1    | The escrow bump                                  |     |\n```\n\n----------------------------------------\n\nTITLE: Sugar Airdrop with Custom List File\nDESCRIPTION: Command to specify a custom airdrop list file instead of using the default airdrop_list.json.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/airdrop.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar airdrop --airdrop-list <AIRDROP_LIST>\n```\n\n----------------------------------------\n\nTITLE: Importing Umi modules and creating wrapper function\nDESCRIPTION: This snippet imports necessary modules from `@metaplex-foundation/mpl-toolbox` and `@metaplex-foundation/umi` for Solana interaction. It defines a wrapper function `transferSolana` to encapsulate the SOL transfer logic, preparing for asynchronous execution.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n\"import { mplToolbox, transferSol } from '@metaplex-foundation/mpl-toolbox'\\nimport {\\n  generateSigner,\\n  publicKey,\\n  signerIdentity,\\n  sol,\\n} from '@metaplex-foundation/umi'\\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\\nimport { base58 } from '@metaplex-foundation/umi/serializers'\\n\\n// Create the wrapper function\\nconst transferSolana = async () => {\\n  ///\\n  ///\\n  ///  all our code will go in here\\n  ///\\n  ///\\n}\\n\\n// run the wrapper function\\ntransferSolana()\"\n```\n\n----------------------------------------\n\nTITLE: Installing MPL-Bubblegum SDK Using npm\nDESCRIPTION: Command to install the MPL-Bubblegum JavaScript SDK package using npm. This can also be executed with other package managers like yarn or bun.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @metaplex-foundation/mpl-bubblegum\n```\n\n----------------------------------------\n\nTITLE: Adding Collection Plugin with Default Authority in Rust\nDESCRIPTION: Demonstrates adding a plugin to an MPL Core Collection using Rust. Implements the FreezeDelegate plugin type with default authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddCollectionPluginV1Builder,\n    types::{FreezeDelegate, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_plugin_to_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let add_plugin_to_collection_ix = AddCollectionPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_plugin_to_collection_tx = Transaction::new_signed_with_payer(\n        &[add_plugin_to_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_plugin_to_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Freeze Guard in Sugar CLI\nDESCRIPTION: Initializes the freeze guard for a Candy Machine. The '--period' parameter sets the freeze duration in seconds. For non-default groups, '--label' must be specified.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/freeze.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar freeze initialize --period <SECONDS>\n```\n\n----------------------------------------\n\nTITLE: Creating Token If Missing in Solana using Umi\nDESCRIPTION: This snippet demonstrates how to create a new Token account only if it doesn't already exist using Umi. It's useful when a subsequent instruction requires a Token account, but you're unsure whether it already exists. The instruction ensures the Token account's existence without needing to fetch it on the client side.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/token-managment.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transactionBuilder } from '@metaplex-foundation/umi'\nimport { createTokenIfMissing } from '@metaplex-foundation/mpl-toolbox'\n\n// If the token account is an associated token account.\nawait transactionBuilder()\n  .add(createTokenIfMissing(umi, { mint, owner }))\n  .add(...) // Subsequent instructions can be sure the Associated Token account exists.\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Default Guard Set Configuration\nDESCRIPTION: Updates to default guard set configuration files to include the new custom guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { customGuardManifest } from \"./defaultGuards\"\n\numi.guards.add(\n  customGuardManifest\n)\n```\n\n----------------------------------------\n\nTITLE: Composing Transaction Builders with Program Libraries in TypeScript\nDESCRIPTION: This snippet shows how to compose transaction builders using helper methods from program libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transferSol, addMemo } from '@metaplex-foundation/mpl-toolbox';\nimport { createNft } from '@metaplex-foundation/mpl-token-metadata';\n\nlet builder = transactionBuilder()\n  .add(addMemo(umi, { ... }))\n  .add(createNft(umi, { ... }))\n  .add(transferSol(umi, { ... }))\n```\n\n----------------------------------------\n\nTITLE: Initializing the Escrow using initEscrowV1 in JavaScript\nDESCRIPTION: This snippet initializes the escrow using the `initEscrowV1()` method, passing in all the parameters and variables defined earlier. It then sends and confirms the transaction using `sendAndConfirm(umi)`.  The resulting transaction signature is logged to the console, providing a link to the transaction on the Solana explorer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n\"const initEscrowTx = await initEscrowV1(umi, {\n  name,\n  uri,\n  max,\n  min,\n  path,\n  escrow,\n  collection,\n  token,\n  feeLocation,\n  amount,\n  feeAmount,\n  solFeeAmount,\n}).sendAndConfirm(umi);\n\nconst signature = base58.deserialize(initEscrowTx.signature)[0]\nconsole.log(`Escrow created! https://explorer.solana.com/tx/${signature}?cluster=devnet`)\"\n```\n\n----------------------------------------\n\nTITLE: Metadata Structure Implementation in Rust\nDESCRIPTION: Reference to the metadata structure implementation in the Bubblegum program's metaplex adapter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/concurrent-merkle-trees.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nmetaplex_adapter.rs#L81\n```\n\n----------------------------------------\n\nTITLE: Minting with Third Party Signer and Mint Limit Guards using Umi\nDESCRIPTION: Example showing how to create a Candy Machine with guards and mint NFTs using the Third Party Signer and Mint Limit guards. The code demonstrates setting up guard configurations and providing the required mint settings during the minting process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/mint.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  some,\n  generateSigner,\n  transactionBuilder,\n} from '@metaplex-foundation/umi'\nimport { create, mintV2 } from '@metaplex-foundation/mpl-candy-machine'\nimport { setComputeUnitLimit } from '@metaplex-foundation/mpl-toolbox'\n\n// Create a Candy Machine with guards.\nconst thirdPartySigner = generateSigner()\nawait create(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signer: thirdPartySigner.publicKey }),\n    mintLimit: some({ id: 1, limit: 3 }),\n  },\n}).sendAndConfirm(umi)\n\n// Mint from the Candy Machine.\nconst nftMint = generateSigner(umi)\nawait transactionBuilder()\n  .add(setComputeUnitLimit(umi, { units: 800_000 }))\n  .add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      nftMint,\n      collectionMint: collectionNft.publicKey,\n      collectionUpdateAuthority: collectionNft.metadata.updateAuthority,\n      mintArgs: {\n        thirdPartySigner: some({ signer: thirdPartySigner }),\n        mintLimit: some({ id: 1 }),\n      },\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Specific Amount Type Definitions\nDESCRIPTION: Type definitions for specific Amount variants including SOL, USD, and percentage amounts\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype SolAmount = Amount<'SOL', 9>;\ntype UsdAmount = Amount<'USD', 2>;\ntype PercentAmount<D extends AmountDecimals> = Amount<'%', D>;\n```\n\n----------------------------------------\n\nTITLE: Revoking a Programmable Config Item Delegate for PNFTs in TypeScript\nDESCRIPTION: Revokes a previously approved Programmable Config Item Delegate. This can be done by the update authority or by the delegate itself for self-revocation. Requires the mint, authority, delegate address, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport { revokeProgrammableConfigItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait revokeProgrammableConfigItemV1(umi, {\n  mint,\n  authority: updateAuthority, // Or pass the delegate authority as a Signer to self-revoke.\n  delegate: programmableConfigItemDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Calculating Priority Fees for Solana Transactions with Umi\nDESCRIPTION: Function to calculate optimal priority fees by analyzing recent fees paid for writable accounts in a transaction. It queries the getRecentPrioritizationFees RPC endpoint and calculates an average from the top 100 fees to determine a competitive rate.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/optimal-transactions-with-compute-units-and-priority-fees.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  TransactionBuilder,\n  Umi,\n} from \"@metaplex-foundation/umi\";\n\nexport const getPriorityFee = async (\n  umi: Umi,\n  transaction: TransactionBuilder\n): Promise<number> => {\n  // Step 1: Get unique writable accounts involved in the transaction\n  // We only care about writable accounts since they affect priority fees\n  const distinctPublicKeys = new Set<string>();\n  \n  transaction.items.forEach(item => {\n    item.instruction.keys.forEach(key => {\n      if (key.isWritable) {\n        distinctPublicKeys.add(key.pubkey.toString());\n      }\n    });\n  });\n  \n  // Step 2: Query recent prioritization fees for these accounts from the RPC\n  const response = await fetch(umi.rpc.getEndpoint(), {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"getRecentPrioritizationFees\",\n      params: [Array.from(distinctPublicKeys)],\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch priority fees: ${response.status}`);\n  }\n\n  const data = await response.json() as {\n    result: { prioritizationFee: number; slot: number; }[];\n  };\n\n  // Step 3: Calculate average of top 100 fees to get a competitive rate\n  const fees = data.result?.map(entry => entry.prioritizationFee) || [];\n  const topFees = fees.sort((a, b) => b - a).slice(0, 100);\n  const averageFee = topFees.length > 0 ? Math.ceil(\n    topFees.reduce((sum, fee) => sum + fee, 0) / topFees.length\n  ) : 0;\n  return averageFee;\n};\n```\n\n----------------------------------------\n\nTITLE: Initialize Freeze Escrow using Sugar CLI\nDESCRIPTION: Command-line interface for initializing a Freeze Escrow account using the Sugar CLI tool. Includes optional parameters for configuration, cache file paths, candy guard address, and other settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsugar freeze initialize\n```\n\nLANGUAGE: shell\nCODE:\n```\n    -c, --config <CONFIG>\n            Path to the config file [default: config.json]\n\n        --cache <CACHE>\n            Path to the cache file, defaults to \"cache.json\" [default: cache.json]\n\n        --candy-guard <CANDY_GUARD>\n            Address of candy guard to update [defaults to cache value]\n\n        --candy-machine <CANDY_MACHINE>\n            Address of candy machine to update [defaults to cache value]\n\n        --destination <DESTINATION>\n            Address of the destination (treasury) account\n\n    -h, --help\n            Print help information\n\n    -k, --keypair <KEYPAIR>\n            Path to the keypair file, uses Sol config or defaults to \"~/.config/solana/id.json\"\n\n    -l, --log-level <LOG_LEVEL>\n            Log level: trace, debug, info, warn, error, off\n\n        --label <LABEL>\n            Candy guard group label\n\n    -r, --rpc-url <RPC_URL>\n            RPC Url\n```\n\n----------------------------------------\n\nTITLE: Minting Multiple NFTs\nDESCRIPTION: Command to mint a specific number of NFTs at once using the -n option.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/mint.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint -n 10\n```\n\n----------------------------------------\n\nTITLE: Approving a Programmable Config Item Delegate for PNFTs in TypeScript\nDESCRIPTION: Creates a Programmable Config Item Delegate that can update the ruleSet of an individual PNFT only. Unlike the Programmable Config Delegate, this delegate cannot update items in a collection. Requires the mint, update authority, delegate address, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { delegateProgrammableConfigItemV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait delegateProgrammableConfigItemV1(umi, {\n  mint,\n  authority: updateAuthority,\n  delegate: programmableConfigItemDelegate,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Multiple Recipient Airdrop with Sugar CLI\nDESCRIPTION: Command to execute an airdrop to multiple wallets using the Sugar CLI. This uses the airdrop_list.json file to determine recipients and quantities.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nsugar airdrop --candy-machine 11111111111111111111111111111111\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine Without Guard in TypeScript\nDESCRIPTION: Creates a Candy Machine without an associated Candy Guard account using the createCandyMachineV2 method from the Metaplex SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createCandyMachineV2 } from '@metaplex-foundation/mpl-candy-machine'\n\nawait createCandyMachineV2(umi, {\n  // ...\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Verifying Rust Installation (Bash)\nDESCRIPTION: This command checks if Rust is correctly installed by printing the version of the Rust compiler.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrustc --version\n```\n\n----------------------------------------\n\nTITLE: Using String Encoding Serializers in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of various string encoding serializers and how to create custom base serializers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nutf8.serialize('Hello World!');\nbase10.serialize('42');\nbase16.serialize('ff002a');\nbase58.serialize('LorisCg1FTs89a32VSrFskYDgiRbNQzct1WxyZb7nuA');\nbase64.serialize('SGVsbG8gV29ybGQhCg==');\n\nconst base58: Serializer<string> = baseX(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n```\n\n----------------------------------------\n\nTITLE: Checking Plugin Authorities in TypeScript\nDESCRIPTION: This function checks the authority for given plugin types on an asset. It takes an object with authority, pluginTypes, asset, and collection as parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexport function checkPluginAuthorities({\n  authority,\n  pluginTypes,\n  asset,\n  collection,\n})\n```\n\n----------------------------------------\n\nTITLE: Converting Instructions from Web3.js to Umi\nDESCRIPTION: TypeScript code showing how to convert instructions from Web3.js format to Umi format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SystemProgram } from '@solana/web3.js';\nimport { fromWeb3JsInstruction } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// Create a new instruction (like a lamport transfer)\nconst web3jsInstruction = SystemProgram.transfer({...TransferParams})\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiInstruction = fromWeb3JsInstruction(web3jsInstruction);\n```\n\n----------------------------------------\n\nTITLE: Collection Account Deserialization Using from_bytes()\nDESCRIPTION: Manual deserialization of a BaseCollectionV1 account using from_bytes() method\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet data = ctx.accounts.collectino.try_borrow_data()?;\nlet base_collection: BaseCollectionV1 = BaseCollectionV1::from_bytes(&data.as_ref())?\n```\n\n----------------------------------------\n\nTITLE: Implementing ParallelUploader Trait in Rust\nDESCRIPTION: Defines the ParallelUploader trait for custom upload methods that support parallel uploads. It simplifies the implementation by focusing on uploading a single asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/bring-your-own-uploader.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn upload_asset(\n    &self,\n    asset: AssetInfo\n) -> JoinHandle<Result<(String, String)>>;\n```\n\n----------------------------------------\n\nTITLE: Fetching Assets by Collection in JavaScript\nDESCRIPTION: This snippet shows how to fetch multiple NFT assets belonging to a specific collection using the fetchAssetsByCollection function from the Metaplex Core package in JavaScript.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/fetch.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { fetchAssetsByCollection } from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('11111111111111111111111111111111')\n\nconst assetsByCollection = await fetchAssetsByCollection(umi, collection, {\n  skipDerivePlugins: false,\n})\n\nconsole.log(assetsByCollection)\n```\n\n----------------------------------------\n\nTITLE: Library Author Peer Dependency Installation\nDESCRIPTION: Installation command for library authors to add Umi as a peer dependency.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi --save-peer\n```\n\n----------------------------------------\n\nTITLE: Adding Programs to the Repository in TypeScript\nDESCRIPTION: Shows how to register a new program in the ProgramRepositoryInterface using the add method, with an option to override existing programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\numi.programs.add(myProgram);\n```\n\nLANGUAGE: typescript\nCODE:\n```\numi.programs.add(myProgram, false);\n```\n\n----------------------------------------\n\nTITLE: Implementing Account Structure for Collection Creation\nDESCRIPTION: Account struct implementation defining required accounts and their constraints for the collection creation instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CreateCollection<'info> {\n    #[account(mut)]\n    pub collection: Signer<'info>,\n    /// CHECK: this account will be checked by the mpl_core program\n    pub update_authority: Option<UncheckedAccount<'info>>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n    #[account(address = MPL_CORE_ID)]\n    /// CHECK: this account is checked by the address constraint\n    pub mpl_core_program: UncheckedAccount<'info>,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring End Date Guard in TypeScript\nDESCRIPTION: Sets up a Candy Machine with an End Date guard using the Metaplex Foundation UMI library. The guard prevents minting after the specified date.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/end-date.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dateTime } from \"@metaplex-foundation/umi\";\n\ncreate(umi, {\n  // ...\n  guards: {\n    endDate: some({ date: dateTime(\"2022-01-24T15:30:00.000Z\") }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Thawing an MPL Core Asset in Rust\nDESCRIPTION: This snippet demonstrates how to thaw a frozen asset using Rust. It creates a new RPC client, sets up the necessary accounts, and uses the UpdatePluginV1Builder to create an instruction for thawing the asset. The instruction is then sent as a transaction to the Solana network.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    instructions::UpdatePluginV1Builder,\n    types::{FreezeDelegate, Plugin},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn thaw_freeze_delegate_plugin() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let asset = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let collection = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let thaw_freeze_delegate_plugin_ix = UpdatePluginV1Builder::new()\n        .asset(asset)\n        // Pass in Collection if Asset is part of collection\n        .collection(Some(collection))\n        .payer(authority.pubkey())\n        // Set the FreezeDelegate plugin to `frozen: false`\n        .plugin(Plugin::FreezeDelegate(FreezeDelegate { frozen: false }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let thaw_freeze_delegate_plugin_tx = Transaction::new_signed_with_payer(\n        &[thaw_freeze_delegate_plugin_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&thaw_freeze_delegate_plugin_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Account with Rent using Umi\nDESCRIPTION: This snippet shows how to create a new account on Solana using Umi without manually fetching the rent exemption. It uses the 'Rent' sysvar within the program to compute the rent exemption based on the provided space. This method is limited to creating accounts up to 10KB in size.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/create-account.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport { createAccountWithRent } from '@metaplex-foundation/mpl-toolbox'\n\nconst newAccount = generateSigner(umi)\nconst space = 42\n\nawait createAccountWithRent(umi, {\n  newAccount,\n  payer: umi.payer,\n  space,\n  programId: umi.programs.get('myProgramName').publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with Wallet Adapter\nDESCRIPTION: This TypeScript snippet demonstrates how to set up the Umi framework using the wallet adapter, integrating a wallet into the application context with the help of the @solana/wallet-adapter-react library.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'\nimport { useWallet } from '@solana/wallet-adapter-react'\n\nconst wallet = useWallet()\n\nconst umi = createUmi('https://api.devnet.solana.com')\n// Register Wallet Adapter to Umi\n.use(walletAdapterIdentity(wallet))\n```\n\n----------------------------------------\n\nTITLE: Fetching Multiple Digital Assets by Mint List\nDESCRIPTION: Helper function to fetch multiple Digital Assets using an array of Mint public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAsset } from '@metaplex-foundation/mpl-token-metadata'\n\nconst [assetA, assetB] = await fetchAllDigitalAsset(umi, [mintA, mintB])\n```\n\n----------------------------------------\n\nTITLE: Adding Attribute Plugin\nDESCRIPTION: Adds the attribute plugin to an asset if it doesn't exist, initializing staking-related attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nif (!fetchedAsset.attributes) {\n    tx = await transactionBuilder().add(addPlugin(umi, {\n        asset,\n        collection,\n        plugin: {\n        type: \"Attributes\",\n        attributeList: [\n            { key: \"staked\", value: currentTime },\n            { key: \"stakedTime\", value: \"0\" },\n        ],\n        },\n    })).add(\n        [...]\n    )\n} else {\n```\n\n----------------------------------------\n\nTITLE: Distributing SPL Tokens in TypeScript\nDESCRIPTION: This snippet demonstrates how to distribute SPL tokens to a member's wallet by using the Fanout SDK's distributeWalletMemberInstructions function. It requires the public key of the token to be distributed and the public key of the member to receive the token. The function returns the instructions needed for the transfer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst mint\n.publicKey = \"SPL-Token-To-Distribute-PublicKey\";\n\nlet distributeToMember1 = await fanoutSdk.distributeWalletMemberInstructions(\n  {\n    distributeForMint: true,\n    member: member1.publicKey,\n    fanout: builtFanout.fanout,\n    payer: distributionBot.publicKey,\n    fanoutMint: mint.publicKey\n  },\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating MPL Core Asset with Oracle Plugin - TypeScript\nDESCRIPTION: Creates a new MPL Core asset with an Oracle plugin using the @metaplex-foundation/umi library. The plugin is configured with Anchor results offset and specific lifecycle checks for updates.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, publicKey } from '@metaplex-foundation/umi'\nimport {\n  create,\n  CheckResult\n} from '@metaplex-foundation/mpl-core'\n\nconst collectionSigner = generateSigner(umi)\n\nconst oracleAccount = publicKey('11111111111111111111111111111111')\n\nconst asset = await create(umi, {\n    ... CreateAssetArgs,\n    plugins: [\n        {\n        type: 'Oracle',\n        resultsOffset: {\n          type: 'Anchor',\n        },\n        baseAddress: oracleAccount,\n        lifecycleChecks: {\n          update: [CheckResult.CAN_REJECT],\n        },\n        baseAddressConfig: undefined,\n      },\n    ],\n  });.sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching a Single Asset in TypeScript\nDESCRIPTION: This snippet demonstrates how to fetch a single asset using the fetchAsset() function. It allows the option to skip deriving plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Programmable Non-Fungible Token JSON Schema Example\nDESCRIPTION: Example JSON schema for Programmable NFTs that enforce custom authorization rules through the Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-standard.md#2025-04-17_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"SolanaArtProject #1\",\n  \"description\": \"Generative art on Solana.\",\n  \"image\": \"https://arweave.net/26YdhY_eAzv26YdhY1uu9uiA3nmDZYwP8MwZAultcE?ext=jpeg\",\n  \"animation_url\": \"https://arweave.net/ZAultcE_eAzv26YdhY1uu9uiA3nmDZYwP8MwuiA3nm?ext=glb\",\n  \"external_url\": \"https://example.com\",\n  \"attributes\": [\n    {\n      \"trait_type\": \"trait1\",\n      \"value\": \"value1\"\n    },\n    {\n      \"trait_type\": \"trait2\",\n      \"value\": \"value2\"\n    }\n  ],\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://www.arweave.net/abcd5678?ext=png\",\n        \"type\": \"image/png\"\n      },\n      {\n        \"uri\": \"https://watch.videodelivery.net/9876jkl\",\n        \"type\": \"unknown\",\n        \"cdn\": true\n      },\n      {\n        \"uri\": \"https://www.arweave.net/efgh1234?ext=mp4\",\n        \"type\": \"video/mp4\"\n      }\n    ],\n    \"category\": \"video\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bit Array Serialization in TypeScript\nDESCRIPTION: Example of serializing boolean arrays into bit arrays with configurable size\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst booleans = [true, false, true, false, true, false, true, false];\nbitArray(1).serialize(booleans); // -> Uint8Array.from([0b10101010]);\nbitArray(1).deserialize(Uint8Array.from([0b10101010])); // -> [booleans, 1];\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with New Wallet\nDESCRIPTION: Setup for Umi instance with a newly generated wallet signer for devnet\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n  .use(mplTokenMetadata())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: \"https://devnet.irys.xyz\",\n    })\n  );\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// Tell umit to use the new signer.\numi.use(signerIdentity(signer))\n\n// This will airdrop SOL on devnet only for testing.\nawait umi.rpc.airdrop(umi.identity.publickey)\n```\n\n----------------------------------------\n\nTITLE: Quick Links Template Structure in Markdown\nDESCRIPTION: Markdown template structure using custom quick-links components to create a navigation section for different programming language options.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% quick-links %}\n\n{% quick-link title=\"JavaScript\" icon=\"JavaScript\" href=\"/token-metadata/getting-started/js\" description=\"Get started with our JavaScript library based on the Umi framework.\" /%}\n\n{% quick-link title=\"Rust\" icon=\"Rust\" href=\"/token-metadata/getting-started/rust\" description=\"Get started using our Rust crate.\" /%}\n\n{% /quick-links %}\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet Allowlist in Rust for Royalties Plugin\nDESCRIPTION: This snippet shows how to create a RuleSet Allowlist in Rust for the Royalties Plugin. It defines a vector of program public keys that are allowed to interact with the MPL Core Asset/Collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::RuleSet;\nuse solana_sdk::pubkey::Pubkey\nuse std::str::FromStr;\n\nlet rule_set = RuleSet::ProgramAllowList(\n    vec![\n        Pubkey::from_str(\"11111111111111111111111111111111\").unwrap(),\n        Pubkey::from_str(\"22222222222222222222222222222222\").unwrap()\n    ]\n);\n```\n\n----------------------------------------\n\nTITLE: Performing a Delegated Update as a Programmable Config Item Delegate in TypeScript\nDESCRIPTION: Uses a Programmable Config Item Delegate to update the ruleSet of an individual PNFT. Requires the mint, token account, delegate authority as a signer, and the new ruleSet configuration using the ruleSetToggle helper.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsProgrammableConfigItemDelegateV2,\n  ruleSetToggle,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { findAssociatedTokenPda } from '@metaplex-foundation/mpl-toolbox'\n\nawait updateAsProgrammableConfigItemDelegateV2(umi, {\n  mint,\n  token: findAssociatedTokenPda(umi, { mint, owner: assetOwner }),\n  authority: programmableConfigItemDelegate,\n  ruleSet: ruleSetToggle('Set', [ruleSet]),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Implementing Additional Signer Rule in Token Auth Rules\nDESCRIPTION: Example of creating a Rule Set that requires a specific public key to sign the transaction. The rule evaluates to true only when the specified public key is included as a transaction signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/additional-signer.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will only evaluate to true if the Public Key signs the transaction.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    deposit: {\n      type: 'AdditionalSigner',\n      publicKey: publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Data Authority in TypeScript and Rust\nDESCRIPTION: Examples showing how to set up the data authority for the AppData plugin using both TypeScript and Rust implementations\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst dataAuthority = {\n  type: 'Address',\n  address: publicKey('11111111111111111111111111111111'),\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::{PluginAuthority}\n\nlet data_authority = Some(PluginAuthority::Address {address: authority.key()})\n```\n\n----------------------------------------\n\nTITLE: Configuring Bytes Serializers in TypeScript\nDESCRIPTION: This snippet demonstrates various configurations for bytes serializers, including different size strategies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Default behaviour: variable size.\nbytes().serialize(new Uint8Array([42])); // -> 0x2a\n\n// Custom size: u16 (little-endian) size.\nbytes({ size: u16() }).serialize(new Uint8Array([42])); // -> 0x01002a\n\n// Custom size: 5 bytes.\nbytes({ size: 5 }).serialize(new Uint8Array([42])); // -> 0x2a00000000\n```\n\n----------------------------------------\n\nTITLE: Adding addBlocker Plugin to MPL Core Asset\nDESCRIPTION: Demonstrates how to add the addBlocker plugin to a Metaplex Core Asset using the addPlugin function. This prevents future authority managed plugins from being added to the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/addBlocker.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addPlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'addBlocker',\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with an Existing Wallet\nDESCRIPTION: This TypeScript snippet illustrates how to set up the Umi framework with an existing wallet by reading the wallet's keypair from a filesystem path.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// You will need to us fs and navigate the filesystem to\n// load the wallet you wish to use via relative pathing.\nconst walletFile = fs.readFileSync('./keypair.json')\n  \n// Convert your walletFile onto a keypair.\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\n// Load the keypair into umi.\numi.use(keypairIdentity(keypair));\n```\n\n----------------------------------------\n\nTITLE: Plugin Lifecycle Validation Table - Remove Plugin\nDESCRIPTION: Table showing plugin validation rules for removing plugins\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/index.md#2025-04-17_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Plugin          | Action      | Conditions  |\n| --------------- | ----------- | ----------- |\n| Royalties       | Can Reject  | Ruleset     |\n| Update Delegate | Can Approve | isAuthority |\n```\n\n----------------------------------------\n\nTITLE: Getting Public Key of a Program in TypeScript\nDESCRIPTION: Illustrates how to obtain a program's public key using the getPublicKey method, with an option for a fallback value if the program does not exist.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Get the public key of a program.\numi.programs.getPublicKey('myProgram');\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Get the public key of a program with a fallback.\nconst fallback = publicKey('...');\numi.programs.getPublicKey('myProgram', fallback);\n```\n\n----------------------------------------\n\nTITLE: Overriding Existing Items in Candy Machine with TypeScript\nDESCRIPTION: This snippet illustrates how to override existing items in a Candy Machine using the Umi library. It shows inserting initial items and then updating a specific item at a given index.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/insert-items.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 0,\n  configLines: [\n    { name: 'My NFT #1', uri: 'https://example.com/nft1.json' },\n    { name: 'My NFT #2', uri: 'https://example.com/nft2.json' },\n    { name: 'My NFT #3', uri: 'https://example.com/nft3.json' },\n  ],\n}).sendAndConfirm(umi)\n\nawait addConfigLines(umi, {\n  candyMachine: candyMachine.publicKey,\n  index: 1,\n  configLines: [{ name: 'My NFT #X', uri: 'https://example.com/nftX.json' }],\n}).sendAndConfirm(umi)\n\ncandyMachine = await fetchCandyMachine(candyMachine.publicKey)\ncandyMachine.items[0].name // \"My NFT #1\"\ncandyMachine.items[1].name // \"My NFT #X\"\ncandyMachine.items[2].name // \"My NFT #3\"\n```\n\n----------------------------------------\n\nTITLE: Uploading NFT Image\nDESCRIPTION: Process for uploading an NFT image to Arweave via Irys\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst imageFile = fs.readFileSync(\n  path.join(__dirname, '..', '/assets/my-image.jpg')\n)\n\nconst umiImageFile = createGenericFile(imageFile, 'my-image.jpeg', {\n  tags: [{ name: 'Content-Type', value: 'image/jpeg' }],\n})\n\nconst imageUri = await umi.uploader.upload([umiImageFile]).catch((err) => {\n  throw new Error(err)\n})\n\nconsole.log(imageUri[0])\n```\n\n----------------------------------------\n\nTITLE: Defining Serializer Type in TypeScript\nDESCRIPTION: This snippet defines the Serializer type, which is the central piece of Umi's serialization framework. It includes methods for serialization and deserialization, as well as metadata about the serializer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Serializer<From, To extends From = From> = {\n  /** A description for the serializer. */\n  description: string;\n  /** The fixed size of the serialized value in bytes, or `null` if it is variable. */\n  fixedSize: number | null;\n  /** The maximum size a serialized value can be in bytes, or `null` if it is variable. */\n  maxSize: number | null;\n  /** The function that serializes a value into bytes. */\n  serialize: (value: From) => Uint8Array;\n  /**\n   * The function that deserializes a value from bytes.\n   * It returns the deserialized value and the number of bytes read.\n   */\n  deserialize: (buffer: Uint8Array, offset?: number) => [To, number];\n};\n```\n\n----------------------------------------\n\nTITLE: Hashing Reveal Data for Hidden Settings in JavaScript\nDESCRIPTION: Demonstrates how to create a cryptographic hash of reveal data for hidden settings validation. This ensures the integrity of revealed NFT data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport crypto from 'crypto'\n\nconst revealData = [\n  { name: 'Nft #1', uri: 'http://example.com/1.json' },\n  { name: 'Nft #2', uri: 'http://example.com/2.json' },\n  { name: 'Nft #3', uri: 'http://example.com/3.json' },\n]\n\nconst string = JSON.stringify(revealData)\nconst hash = crypto.createHash('sha256').update(string).digest()\n\nconsole.log(hash)\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Schema for Animated GIF NFT in Metaplex Core\nDESCRIPTION: This example shows the JSON schema for an animated GIF NFT in Metaplex Core. It includes the basic metadata and specifies the image URL pointing to a GIF file. The properties section indicates the file type and category.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"Number #0001\",\n  \"description\": \"Collection of 10 numbers on the blockchain. This is the number 1/10.\",\n  \"image\": \"https://nftstorage.link/ipfs/bafybeihh2fcxwvm5qj555hfeywikptip5olyizdbkwkoxspt63332x2tpe/5307.gif?ext=gif\",\n  \"external_url\": \"https://example.com\",\n  \"properties\": {\n    \"files\": [\n      {\n        \"uri\": \"https://nftstorage.link/ipfs/bafybeihh2fcxwvm5qj555hfeywikptip5olyizdbkwkoxspt63332x2tpe/5307.gif?ext=gif\",\n        \"type\": \"image/gif\"\n      }\n    ],\n    \"category\": \"image\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Allow List Guard Route Instruction with Groups in TypeScript\nDESCRIPTION: This code snippet shows how to use the 'route' function to call the route instruction of an Allow List guard when using guard groups. It demonstrates creating a Candy Machine with two Allow List guards in different groups and verifying the Merkle Proof for a specific group.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guard-route.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  route,\n  getMerkleProof,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { base58PublicKey, some } from \"@metaplex-foundation/umi\";\n\n// Prepare the allow lists.\nconst allowListA = [...];\nconst allowListB = [...];\n\n// Create a Candy Machine with two Allow List guards.\nawait create(umi, {\n  // ...\n  groups: [\n    {\n      label: \"listA\",\n      guards: {\n        allowList: some({ merkleRoot: getMerkleRoot(allowListA) }),\n      },\n    },\n    {\n      label: \"listB\",\n      guards: {\n        allowList: some({ merkleRoot: getMerkleRoot(allowListB) }),\n      },\n    },\n  ],\n}).sendAndConfirm(umi);\n\n// Verify the Merkle Proof by specifying which group to select.\nawait route(umi, {\n  candyMachine: candyMachine.publicKey,\n  guard: 'allowList',\n  group: some('listA'), // <- We are verifying using \"allowListA\".\n  routeArgs: {\n    path: 'proof',\n    merkleRoot: getMerkleRoot(allowListA),\n    merkleProof: getMerkleProof(\n      allowListA,\n      base58PublicKey(umi.identity),\n    ),\n  },\n}).sendAndConfirm(umi);\n```\n\n----------------------------------------\n\nTITLE: Manual Plugin Derivation Using Metaplex Core SDK\nDESCRIPTION: This snippet shows how to manually derive plugins for assets after fetching a collection. It demonstrates importing necessary dependencies, creating a UMI instance, fetching a collection and assets, and then manually applying plugin derivation to each asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/plugin-derivation.md#2025-04-17_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { deriveAssetPlugins } from '@metaplex-foundation/mpl-core'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\nconst collectionId = publicKey('<PublicKey>');\n//...\n\nconst collection = await das.getCollection(umi, collectionId);\nconst assetsByCollection = await das.getAssetsByCollection(umi, {\n  collection: collection.publicKey,\n  skipDerivePlugins: true,\n});\n\nconst derivedAssets = assetsByCollection.map((asset) => deriveAssetPlugins(asset, collection))\n```\n\n----------------------------------------\n\nTITLE: Using PublicKey Serializers in TypeScript\nDESCRIPTION: This snippet shows how to use public key serializers for serializing and deserializing public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { publicKey as publicKeySerializer } from '@metaplex-foundation/umi/serializers';\n\nconst myPublicKey = publicKey('...');\nconst buffer = publicKeySerializer().serialize(myPublicKey);\nconst [myDeserializedPublicKey, offset] = publicKeySerializer().deserialize(buffer);\nmyPublicKey === myDeserializedPublicKey; // -> true\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with a New Wallet\nDESCRIPTION: This TypeScript snippet demonstrates how to set up the Umi framework using a newly generated signer not pre-associated with any existing wallet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n\nconst signer = generateSigner(umi)\n\numi.use(signerIdentity(signer))\n\n// This will airdrop SOL on devnet only for testing.\nconsole.log('Airdropping 1 SOL to identity')\numi.rpc.airdrop(umi.identity.publicKey, sol(1));\n```\n\n----------------------------------------\n\nTITLE: Installing Rust via rustup (Bash)\nDESCRIPTION: This command installs Rust using rustup, which is recommended for building Sugar from source or installing from crates.io.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Implementing SOL Transfer with Umi and Wallet Adapter in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to transfer SOL from the current wallet to a destination account using the Metaplex Umi library. It leverages the `transferSol` function for building transactions and `sendAndConfirmWithWalletAdapter` for transaction signing and sending. Dependencies include the @metaplex-foundation/mpl-toolbox and @metaplex-foundation/umi packages. The function requires a destination public key and amount of SOL to transfer. Outputs include the transaction confirmation response. This example assumes a zustand store setup for global state management.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Example of a function that transfers SOL from one account to another pulling umi\n// from the useUmiStore in a ts file which is not a React component.\n\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox'\nimport umiWithCurrentWalletAdapter from './umi/umiWithCurrentWalletAdapter'\nimport { publicKey, sol } from '@metaplex-foundation/umi'\nimport sendAndConfirmWalletAdapter from './umi/sendAndConfirmWithWalletAdapter'\n\n// This function transfers SOL from the current wallet to a destination account and is callable\n// from any tsx/ts or component file in the project because of the zustand global store setup.\n\nconst transferSolToDestination = async ({\n  destination,\n  amount,\n}: {\n  destination: string\n  amount: number\n}) => {\n  // Import Umi from `umiWithCurrentWalletAdapter`.\n  const umi = umiWithCurrentWalletAdapter()\n\n  // Create a transactionBuilder using the `transferSol` function from the mpl-toolbox.\n  // Umi by default will use the current signer (walletAdapter) to also set the `from` account.\n  const tx = transferSol(umi, {\n    destination: publicKey(destination),\n    amount: sol(amount),\n  })\n\n  // Use the sendAndConfirmWithWalletAdapter method to send the transaction.\n  // We do not need to pass the umi stance or wallet adapter as an argument because a\n  // fresh instance is fetched from the `umiStore` in the `sendAndConfirmWithWalletAdapter` function.\n  const res = await sendAndConfirmWalletAdapter(tx)\n}\n\nexport default transferSolToDestination\n\n```\n\n----------------------------------------\n\nTITLE: Adding Royalties Plugin to MPL Core Collection in Rust\nDESCRIPTION: This snippet demonstrates how to add the Royalties Plugin to an MPL Core Collection using Rust. It sets up the necessary structures, creates the instruction, and sends the transaction to add the plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddCollectionPluginV1Builder,\n    types::{Creator, Plugin, Royalties, RuleSet},\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_royalties_pluging_to_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n\n    let creator1 = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n    let creator2 = Pubkey::from_str(\"33333333333333333333333333333333\").unwrap();\n\n    let add_royalties_plugin_to_collection_ix = AddCollectionPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .plugin(Plugin::Royalties(Royalties {\n            basis_points: 500,\n            creators: vec![\n                Creator {\n                    address: creator1,\n                    percentage: 80,\n                },\n                Creator {\n                    address: creator2,\n                    percentage: 20,\n                },\n            ],\n            rule_set: RuleSet::None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_royalties_pluging_to_collection_tx = Transaction::new_signed_with_payer(\n        &[add_royalties_plugin_to_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_royalties_pluging_to_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Binary Data\nDESCRIPTION: Examples of binary data serialization for the AppData plugin in both TypeScript and Rust\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// The below example is just creating bytes that are considered `true` or `false`.\nconst data = new Uint8Array([1, 0, 0, 1, 0])\n```\n\nLANGUAGE: rust\nCODE:\n```\n// This example shows how to serialize a Rust struct with `bincode`.\n\nlet data = MyData {\n    timestamp: 1234567890,\n    message: \"Hello World\".to_string(),\n};\n\nlet data = bincode::serialize(&data).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Signing NFT Metadata as Creator in TypeScript\nDESCRIPTION: This snippet illustrates how to sign NFT metadata as a creator using the Hydra Wallet. It includes setting up royalties for the NFT and preparing the instructions needed to sign the NFT metadata, leveraging the Fanout SDK. The instructions will be sent to the Solana blockchain to complete the transaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Create Hydra as above.\n\n// Set Royalties\nconst allCreators = [\n  { creator: authorityWallet.publicKey, share: 0 },\n  {\n    creator: init.fanout,\n    publicKey,\n    share: 100,\n  },\n]\n\n// CREATE NFT Code Adding allCreators as Creator for the NFT\n\nconst instructions: TransactionInstruction[] = []\ninstructions.push(\n  /// Create NFT Instructions\n  /// Sign the nft\n  ...fanoutSdk.signMetadataInstructions({\n    metadata: metadataAccount,\n    holdingAccount: init.nativeAccount,\n    fanout: init.fanout,\n  }).instructions\n)\n\n///....send instructions to solana\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Array, Set, and Map Serializers in TypeScript\nDESCRIPTION: This snippet shows how to create and configure serializers for arrays, sets, and maps with various size strategies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n// Arrays.\narray(u8()) // Array of u8 items with a u32 size prefix.\narray(u8(), { size: 5 }) // Array of 5 u8 items.\narray(u8(), { size: 'remainder' }) // Array of u8 items with a variable size.\n\n// Sets.\nset(u8()) // Set of u8 items with a u32 size prefix.\nset(u8(), { size: 5 }) // Set of 5 u8 items.\nset(u8(), { size: 'remainder' }) // Set of u8 items with a variable size.\n\n// Maps.\nmap(u8(), u8()) // Map of (u8, u8) entries with a u32 size prefix.\nmap(u8(), u8(), { size: 5 }) // Map of 5 (u8, u8) entries.\nmap(u8(), u8(), { size: 'remainder' }) // Map of (u8, u8) entries with a variable size.\n```\n\n----------------------------------------\n\nTITLE: Installing MPL-Hybrid Package\nDESCRIPTION: Command to install the MPL-Hybrid package using npm package manager.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/sdk/javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @metaplex-foundation/mpl-hybrid\n```\n\n----------------------------------------\n\nTITLE: Cloning the Metaplex MPL-404 Hybrid UI Template\nDESCRIPTION: This command clones the GitHub repository containing the Metaplex MPL-404 Hybrid UI Template. It provides the initial codebase for developers to start building their UI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/mpl-404-hybrid-ui-template.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/mpl-hybrid-404-ui-template-nextjs-tailwind-shadcn.git\n```\n\n----------------------------------------\n\nTITLE: Initializing Hydra Wallet with Solana Connection\nDESCRIPTION: Set up a Hydra wallet using Solana connection, generate authority wallet, and initialize fanout with wallet membership model\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/quick-start.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = new Connection(\"devnet\", \"confirmed\");\nconst authorityWallet = Keypair.generate();\n\nawait airdrop(connection, authorityWallet.publicKey, LAMPORTS_PER_SOL * 2);\n\nconst fanoutSdk = new FanoutClient(\n  connection,\n  new NodeWallet(new Account(authorityWallet.secretKey))\n);\n\nconst { fanout, nativeAccount } = await fanoutSdk.initializeFanout({\n  totalShares: 100,\n  name: `Your Globally Unique Wallet Name`,\n  membershipModel: MembershipModel.Wallet,\n});\n```\n\n----------------------------------------\n\nTITLE: Thawing a Frozen Asset with TypeScript\nDESCRIPTION: Thaws a Frozen Asset belonging to the current identity. Frozen Assets can be thawed when the Candy Machine mints out, is deleted, or when the Freeze Period has passed. This function requires the destination, the NFT mint address, owner address, and token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'thaw',\n    destination,\n    nftMint: nftMint.publicKey,\n    nftOwner: umi.identity.publicKey,\n    nftTokenStandard: candyMachine.tokenStandard,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Logging NFT Creation Details in TypeScript\nDESCRIPTION: This snippet shows how to log the details of the created NFT, including the transaction signature and links to view the NFT on Solana Explorer and Metaplex Explorer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Log out the signature and the links to the transaction and the NFT.\nconsole.log('\\nNFT Created')\nconsole.log('View Transaction on Solana Explorer')\nconsole.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`)\nconsole.log('\\n')\nconsole.log('View NFT on Metaplex Explorer')\nconsole.log(`https://core.metaplex.com/explorer/${nftSigner.publicKey}?env=devnet`)\n```\n\n----------------------------------------\n\nTITLE: Uploading Assets from Custom Directory with Sugar CLI (Bash)\nDESCRIPTION: This command allows specifying a custom asset directory for uploading files to the Candy Machine storage.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/upload.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar upload <ASSETS DIR>\n```\n\n----------------------------------------\n\nTITLE: Configuring Gatekeeper Guard in JavaScript\nDESCRIPTION: This code demonstrates how to set up a Candy Machine with the Gatekeeper guard in JavaScript. It configures the guard with the Civic Captcha Pass network and sets the Gateway Token to expire after use.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/gatekeeper.md#2025-04-17_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    gatekeeper: some({\n      network: publicKey(\"ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6\"),\n      expireOnUse: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Account Existence Assertion in TypeScript\nDESCRIPTION: Demonstrates how to assert that an account exists using the assertAccountExists helper method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nassertAccountExists(myMaybeAccount);\n// From now on, we know myMaybeAccount is an RpcAccount.\n```\n\n----------------------------------------\n\nTITLE: Setting Up Program Structure\nDESCRIPTION: Initial program setup with imports and basic structure for Core NFT Asset creation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\nuse mpl_core::{\n    ID as MPL_CORE_ID,\n    accounts::BaseCollectionV1, \n    instructions::CreateV2CpiBuilder, \n};\n\ndeclare_id!(\"C9PLf3qMCVqtUCJtEBy8NCcseNp3KTZwFJxAtDdN1bto\");\n\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateAssetArgs {\n\n}\n\n#[program]\npub mod create_core_asset_example {\n    use super::*;\n\n    pub fn create_core_asset(ctx: Context<CreateAsset>, args: CreateAssetArgs) -> Result<()> {\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateAsset<'info> {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Merkle Tree Canopy Cost Comparison Table\nDESCRIPTION: A markdown table comparing different canopy depths and their associated costs for minting 1,000,000 cNFTs, including storage costs and proof bytes requirements.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/merkle-tree-canopy.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Canopy Depth     | Proof Bytes   | Storage Cost | Mint cost (3 mint/tx w/ LUT) | Total cost |\n| ---------------- | ------------- | ------------ | -----------------------------| ---------- |\n| 0                | 640           | 0.3091       | 1.6667                       | 1.9758     |\n| 14               | 192           | 7.6067       | 1.6667                       | 9.2734     |\n| 17               | 96            | 58.6933      | 1.6667                       | 60.36      |\n```\n\n----------------------------------------\n\nTITLE: Configuring Freeze Token Payment guard in Sugar config.json\nDESCRIPTION: JSON configuration for the Freeze Token Payment guard in a Sugar config.json file. Sets the amount, mint address, and destination ATA for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"freezeTokenPayment\" : {\n    \"amount\": number in basis points (e.g. 1000 for 1 Token that has 3 decimals),\n    \"mint\": \"<PUBKEY>\",\n    \"destinationAta\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Searching MPL Core Collections with DAS API in JavaScript\nDESCRIPTION: This code demonstrates how to search for Core assets using the DAS API with specific filters for owner and jsonUri. It uses the Metaplex Foundation's UMI library to create a connection and perform the search query.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/search-collections.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst asset = await das.searchAssets(umi, {\n    owner: publicKey('AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx'),\n    jsonUri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n});\n\nconsole.log(asset);\n```\n\n----------------------------------------\n\nTITLE: Fetching Transaction Details from the Blockchain\nDESCRIPTION: Shows how to retrieve transaction data from the blockchain using the transaction signature. This allows accessing transaction details after it has been processed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst transaction = await umi.rpc.getTransaction(signature)\n```\n\n----------------------------------------\n\nTITLE: Withdrawing Candy Guard Account\nDESCRIPTION: Command to close the Candy Guard account and retrieve the rent fee after guards have been removed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/guard.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsugar guard withdraw\n```\n\n----------------------------------------\n\nTITLE: Displaying Candy Machine Details\nDESCRIPTION: Command to show the current Candy Machine details in the terminal, including configuration and status information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nsugar show\n```\n\n----------------------------------------\n\nTITLE: Thawing Frozen NFTs using Sugar CLI in Candy Machine\nDESCRIPTION: This code snippet shows how to use the Sugar CLI to thaw frozen NFTs in a Candy Machine project. It includes the basic command and lists available options for customization.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_6\n\nLANGUAGE: shellscript\nCODE:\n```\nsugar freeze thaw\n```\n\nLANGUAGE: shellscript\nCODE:\n```\nARGS:\n    <NFT_MINT>    Address of the NFT to thaw\n\nOPTIONS:\n        --all\n            Unthaw all NFTs in the candy machine\n\n    -c, --config <CONFIG>\n            Path to the config file [default: config.json]\n\n        --cache <CACHE>\n            Path to the cache file, defaults to \"cache.json\" [default: cache.json]\n\n        --candy-guard <CANDY_GUARD>\n            Address of candy guard to update [defaults to cache value]\n\n        --candy-machine <CANDY_MACHINE>\n            Address of candy machine to update [defaults to cache value]\n\n        --destination <DESTINATION>\n            Address of the destination (treaury) account\n\n    -h, --help\n            Print help information\n\n    -k, --keypair <KEYPAIR>\n            Path to the keypair file, uses Sol config or defaults to \"~/.config/solana/id.json\"\n\n    -l, --log-level <LOG_LEVEL>\n            Log level: trace, debug, info, warn, error, off\n\n        --label <LABEL>\n            Candy guard group label\n\n    -r, --rpc-url <RPC_URL>\n            RPC Url\n\n    -t, --timeout <TIMEOUT>\n            RPC timeout to retrieve the mint list (in seconds)\n\n        --use-cache\n            Indicates to create/use a cache file for mint list\n```\n\n----------------------------------------\n\nTITLE: Complete Staking Instruction Implementation in Rust\nDESCRIPTION: This is the full implementation of the staking instruction, including attribute plugin management, staking status updates, and asset freezing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub fn stake(ctx: Context<Stake>) -> Result<()> {  \n    // Check if the asset has the attribute plugin already on\n    match fetch_plugin::<BaseAssetV1, Attributes>(&ctx.accounts.asset.to_account_info(), mpl_core::types::PluginType::Attributes) {\n        Ok((_, fetched_attribute_list, _)) => {\n            // If yes, check if the asset is already staked, and if the staking attribute are already initialized\n            let mut attribute_list: Vec<Attribute> = Vec::new();\n            let mut is_initialized: bool = false;\n\n            for attribute in fetched_attribute_list.attribute_list {\n                if attribute.key == \"staked\" {\n                    require!(attribute.value == \"0\", StakingError::AlreadyStaked);\n                    attribute_list.push(Attribute { \n                        key: \"staked\".to_string(), \n                        value: Clock::get()?.unix_timestamp.to_string() \n                    });\n                    is_initialized = true;\n                } else {\n                    attribute_list.push(attribute);\n                } \n            }\n\n            if !is_initialized {\n                attribute_list.push(Attribute { \n                    key: \"staked\".to_string(), \n                    value: Clock::get()?.unix_timestamp.to_string() \n                });\n                attribute_list.push(Attribute { \n                    key: \"staked_time\".to_string(), \n                    value: 0.to_string() \n                });\n            }\n\n            UpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n            .asset(&ctx.accounts.asset.to_account_info())\n            .collection(Some(&ctx.accounts.collection.to_account_info()))\n            .payer(&ctx.accounts.payer.to_account_info())\n            .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n            .system_program(&ctx.accounts.system_program.to_account_info())\n            .plugin(Plugin::Attributes(Attributes{ attribute_list }))\n            .invoke()?;\n        }\n        Err(_) => {\n            // If not, add the attribute plugin to the asset\n            AddPluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n            .asset(&ctx.accounts.asset.to_account_info())\n            .collection(Some(&ctx.accounts.collection.to_account_info()))\n            .payer(&ctx.accounts.payer.to_account_info())\n            .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n            .system_program(&ctx.accounts.system_program.to_account_info())\n            .plugin(Plugin::Attributes(\n                Attributes{ \n                    attribute_list: vec![\n                        Attribute { \n                            key: \"staked\".to_string(), \n                            value: Clock::get()?.unix_timestamp.to_string() \n                        },\n                        Attribute { \n                            key: \"staked_time\".to_string(), \n                            value: 0.to_string() \n                        },\n                    ] \n                }\n            ))\n            .init_authority(PluginAuthority::UpdateAuthority)\n            .invoke()?;\n        }\n    }\n\n    // Freeze the asset  \n    AddPluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.owner.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::FreezeDelegate( FreezeDelegate{ frozen: true } ))\n    .init_authority(PluginAuthority::UpdateAuthority)\n    .invoke()?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Leaf Schema from Collection Mint Transaction\nDESCRIPTION: Shows how to retrieve the leaf schema and asset ID from a mintToCollectionV1 transaction using parseLeafFromMintToCollectionV1Transaction helper.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/mint-cnfts.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n    findLeafAssetIdPda,\n    mintV1,\n    parseLeafFromMintToCollectionV1Transaction\n} from \"@metaplex-foundation/mpl-bubblegum\";\n\nconst { signature } = await mintToCollectionV1(umi, {\n  leafOwner,\n  merkleTree,\n  metadata,\n  collectionMint: collectionMint.publicKey,\n}).sendAndConfirm(umi);\n\nconst leaf: LeafSchema = await parseLeafFromMintToCollectionV1Transaction(umi, signature);\nconst assetId = findLeafAssetIdPda(umi, { merkleTree, leafIndex: leaf.nonce });\n// or const assetId = leaf.id;\n```\n\n----------------------------------------\n\nTITLE: Creating Plugins and External Plugin Adapters in Rust\nDESCRIPTION: This code demonstrates how to create vectors for plugins and external plugin adapters, including the FreezeDelegate plugin and AppData external plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet mut plugins: Vec<PluginAuthorityPair> = vec![];\n\nplugins.push(\n  PluginAuthorityPair { \n      plugin: Plugin::FreezeDelegate(FreezeDelegate {frozen: true}), \n      authority: Some(PluginAuthority::UpdateAuthority) \n  }\n);\n\nlet mut external_plugin_adapters: Vec<ExternalPluginAdapterInitInfo> = vec![];\n    \nexternal_plugin_adapters.push(\n  ExternalPluginAdapterInitInfo::AppData(\n    AppDataInitInfo {\n      init_plugin_authority: Some(PluginAuthority::UpdateAuthority),\n      data_authority: PluginAuthority::Address{ address: data_authority },\n      schema: Some(ExternalPluginAdapterSchema::Binary),\n    }\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Example Response from getAssetsByCollection API Call\nDESCRIPTION: This JSON example shows a typical response from the getAssetsByCollection method. It contains detailed information about a single Core asset including its public key, header, plugin data, royalty information, metadata, and ownership details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-collection.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Generating Token Record PDA Address\nDESCRIPTION: Shows how to generate the PDA address for a token record account using the mint ID and token account address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/pnfts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst tokenRecordPda = findTokenRecordPda(umi, {\n    // pNFT mint ID\n    mint: publicKey(\"11111111111111111111111111111111\")s,\n    // Token Account\n    token: publicKey(\"22222222222222222222222222222222\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Oracle Plugin to Collection using Rust\nDESCRIPTION: This snippet shows how to add an Oracle plugin to a collection using Rust with the Metaplex Foundation's mpl-core library. It creates a transaction to add the plugin, configuring parameters such as collection and oracle plugin public keys, result offset type, and lifecycle checks.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/adding-external-plugins.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{\n    instructions::AddCollectionExternalPluginV1Builder,\n    types::{\n        ExternalCheckResult, ExternalPluginAdapterInitInfo, HookableLifecycleEvent,\n        OracleInitInfo, ValidationResultsOffset,\n    },\n};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn add_oracle_plugin_to_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let oracle_plugin = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let add_oracle_plugin_to_collection_ix = AddCollectionExternalPluginV1Builder::new()\n        .collection(collection)\n        .payer(authority.pubkey())\n        .init_info(ExternalPluginAdapterInitInfo::Oracle(OracleInitInfo {\n            base_address: oracle_plugin,\n            results_offset: Some(ValidationResultsOffset::Anchor),\n            lifecycle_checks: vec![(HookableLifecycleEvent::Transfer, ExternalCheckResult { flags: 4 })],\n            base_address_config: None,\n            init_plugin_authority: None,\n        }))\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let add_oracle_plugin_to_collection_tx = Transaction::new_signed_with_payer(\n        &[add_oracle_plugin_to_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&add_oracle_plugin_to_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Metadata Account Structure Example\nDESCRIPTION: Illustrates the structure of a Metadata Account in the Token Metadata program, showing various fields like Update Authority, Mint, Name, Symbol, and other configuration options.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/index.md#2025-04-17_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nKey = MetadataV1\nUpdate Authority\nMint\nName\nSymbol\nURI\nSeller Fee Basis Points\nCreators\nPrimary Sale Happened\nIs Mutable\nEdition Nonce\nToken Standard\nCollection\nUses\nCollection Details\nProgrammable Configs\n```\n\n----------------------------------------\n\nTITLE: Setting up Hidden Settings in JavaScript using Umi\nDESCRIPTION: This snippet demonstrates how to configure Hidden Settings for a Candy Machine using the Umi library. It shows how to set the hidden name, URI, and hash for a hide-and-reveal NFT drop.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { some, none } from '@metaplex-foundation/umi'\n\nconst candyMachineSettings = {\n  configLineSettings: none(),\n  hiddenSettings: some({\n    name: 'My NFT Project #$ID+1$',\n    uri: 'https://example.com/path/to/teaser.json',\n    hash: hashOfTheFileThatMapsUris,\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Asset Plugin Deserialization\nDESCRIPTION: Accessing plugin data from an Asset account using fetch_plugin()\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet (_, attribute_list, _) = fetch_plugin::<BaseAssetV1, Attributes>(&ctx.accounts.asset.to_account_info(), mpl_core::types::PluginType::Attributes)?\n```\n\n----------------------------------------\n\nTITLE: Allocating Space for Data in Inscription Account with JavaScript\nDESCRIPTION: This code snippet demonstrates how to allocate space in an associated Inscription account using the `allocate` method from the Metaplex Foundation's SDK. It reads image data from a file, calculates the necessary resizes, and allocates the required space accordingly. The inputs include the associated inscription account and the image's byte length, while the output confirms the allocation of space for the data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/write.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { allocate } from '@metaplex-foundation/mpl-inscription';\nconst fs = require('fs');\n\n// Open the image file to fetch the raw bytes.\nconst imageBytes: Buffer = await fs.promises.readFile('test/large_bread.png')\nconst resizes = Math.floor(imageBytes.length / 10240) + 1\nfor (let i = 0; i < resizes; i += 1) {\n  await allocate(umi, {\n    inscriptionAccount: associatedInscriptionAccount,\n    inscriptionMetadataAccount,\n    associatedTag: 'image/png',\n    targetSize: imageBytes.length,\n  }).sendAndConfirm(umi)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding New Autograph to Existing Asset\nDESCRIPTION: Example demonstrating how to add a new autograph to an asset that already has the autograph plugin. Includes fetching existing autographs and updating with a new one.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/autograph.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\n// The new autograph that you want to add\nconst newAutograph = {\n  address: umi.identity.publicKey,\n  message: \"your message\"\n}\n\n// Add the new autograph to the existing signatures array\nconst updatedAutographs = [...asset.autograph.signatures, newAutograph]\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'Autograph',\n    // This should contain all autographs that you do not want to remove\n    signatures: updatedAutographs,\n  },\n  authority: umi.identity,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating Instructions in Umi\nDESCRIPTION: TypeScript code demonstrating how to create instructions using Metaplex Umi, including creating a Umi instance and generating instructions for a SOL transfer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new instruction (like a core nft transfer)\n// get instructions will give you an Array of instructions\nconst umiInstructions = transferSol(umi, {...TransferParams}).getInstructions();\n```\n\n----------------------------------------\n\nTITLE: Adding Members with Token Model\nDESCRIPTION: This snippet illustrates adding members using the Token model, where membership is linked to staked SPL tokens. It also includes staking instructions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst membershipMintPublicKey = 'SPL-TokenPublicKey'\n\nconst { fanout } = await fanoutSdk.initializeFanout({\n  totalShares: 0,\n  name: `Test${Date.now()}`,\n  membershipModel: MembershipModel.Token,\n  mint: membershipMintPublicKey,\n})\n\n// Staking tokens\n\nconst ixs = await fanoutSdk.stakeTokenMemberInstructions({\n  shares: supply * 0.1,\n  fanout: fanout,\n  membershipMintTokenAccount: tokenAcctMember,\n  membershipMint: membershipMint.publicKey,\n  member: member.publicKey,\n  payer: member.publicKey,\n})\n\nconst tx = await fanoutSdk.sendInstructions(\n  ixs.instructions,\n  [member],\n  member.publicKey\n)\nif (!!tx.RpcResponseAndContext.value.err) {\n  const txdetails = await connection.getConfirmedTransaction(\n    tx.TransactionSignature\n  )\n  console.log(txdetails, tx.RpcResponseAndContext.value.err)\n}\n\nconst stake = await membershipMint.getAccountInfo(ixs.output.stakeAccount)\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with a New Wallet for Core NFT Asset Creation\nDESCRIPTION: Sets up Umi with a newly generated signer for testing purposes. Includes airdropping SOL on devnet.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\nconst signer = generateSigner(umi)\n\numi.use(signerIdentity(signer))\n\n// This will airdrop SOL on devnet only for testing.\nconsole.log('Airdropping 1 SOL to identity')\nawait umi.rpc.airdrop(umi.identity.publickey)\n```\n\n----------------------------------------\n\nTITLE: Cargo Dependencies for MPL Core\nDESCRIPTION: Specifies the required MPL Core dependency with anchor feature enabled.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nmpl-core = { version = \"x.x.x\", features = [\"anchor\"] }\n```\n\n----------------------------------------\n\nTITLE: Fungible Token JSON Schema Example\nDESCRIPTION: Example JSON schema for simple SPL tokens like USDC with limited metadata and supply >= 0.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-standard.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"USD Coin\",\n  \"symbol\": \"USDC\",\n  \"description\": \"Fully reserved fiat-backed stablecoin created by Circle.\",\n  \"image\": \"https://www.circle.com/hs-fs/hubfs/sundaes/USDC.png?width=540&height=540&name=USDC.png\"\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Existing Wallet in Umi\nDESCRIPTION: Method for loading an existing local wallet keypair into Umi\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n  .use(mplTokenMetadata())\n  .use(mplToolbox())\n  .use(irysUploader())\n\n// Load wallet from local file\nconst walletFile = fs.readFileSync('./keypair.json')\n\n// Convert wallet file to keypair\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile))\n\n// Load keypair into umi\numi.use(keypairIdentity(umiSigner))\n```\n\n----------------------------------------\n\nTITLE: Authority PDA Example in TypeScript\nDESCRIPTION: Shows the structure for setting authorityPda field which is used to verify minted Assets to the collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nauthorityPda: string\n```\n\n----------------------------------------\n\nTITLE: Configuring End Date Guard in Sugar Config JSON\nDESCRIPTION: Defines the End Date guard configuration in a Sugar config.json file, specifying when minting should end.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/end-date.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"endDate\" : {\n    \"date\": \"string\",\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Collection NFT\nDESCRIPTION: Demonstrates how to create a new Collection NFT using the mpl-token-metadata library, which can be used as a parent collection for compressed NFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/mint-cnfts.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, percentAmount } from '@metaplex-foundation/umi'\nimport { createNft } from '@metaplex-foundation/mpl-token-metadata'\n\nconst collectionMint = generateSigner(umi)\nawait createNft(umi, {\n  mint: collectionMint,\n  name: 'My Collection',\n  uri: 'https://example.com/my-collection.json',\n  sellerFeeBasisPoints: percentAmount(5.5), // 5.5%\n  isCollection: true,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Providing Mint Settings for Freeze Token Payment guard using mintV2\nDESCRIPTION: Example of how to pass the Mint Settings when minting with the Freeze Token Payment guard using the mintV2 function. Specifies the token mint and destination ATA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-token-payment.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    freezeTokenPayment: some({\n      mint: tokenMint.publicKey,\n      destinationAta,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Inscription with NPM\nDESCRIPTION: This command installs the required dependencies for using Metaplex Inscriptions, including the Umi framework, umi-bundle-defaults, solana/web3.js, and the mpl-inscription library. It ensures that all the necessary packages are available for interacting with Inscriptions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/js.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install \\\n  @metaplex-foundation/umi \\\n  @metaplex-foundation/umi-bundle-defaults \\\n  @solana/web3.js@1 \\\n  @metaplex-foundation/mpl-inscription\n```\n\n----------------------------------------\n\nTITLE: Customizing Transaction Sending and Confirmation Options\nDESCRIPTION: Shows how to provide custom options when sending and confirming transactions, including preflight settings and using alternative confirmation strategies like durableNonce.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst confirmResult = await builder.sendAndConfirm(umi, {\n  // Send options.\n  send: {\n    skipPreflight: true,\n  },\n\n  // Confirm options.\n  confirm: {\n    strategy: {\n      type: 'durableNonce',\n      minContextSlot,\n      nonceAccountPubkey,\n      nonceValue,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Unverifying Collection for Compressed NFT using TypeScript\nDESCRIPTION: Shows how to unverify a collection for a Compressed NFT using unverifyCollection from mpl-bubblegum. Requires the collection to be previously set and verified on the cNFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/verify-collections.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getAssetWithProof,\n  unverifyCollection,\n} from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait unverifyCollection(umi, {\n  ...assetWithProof,\n  collectionMint,\n  collectionAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Uploading Assets with Sugar CLI (Bash)\nDESCRIPTION: This command uploads assets to the specified storage and creates the cache file for the Candy Machine using the default asset folder location.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/upload.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar upload\n```\n\n----------------------------------------\n\nTITLE: Withdrawing Funds from Bundlr Network with Sugar CLI\nDESCRIPTION: This command withdraws any remaining balance from the Bundlr Network and transfers it to the associated Solana address. It's useful for reclaiming unused funds after uploads.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/bundlr.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar bundlr withdraw\n```\n\n----------------------------------------\n\nTITLE: Using cURL to Get Assets by Group\nDESCRIPTION: This shell command snippet utilizes cURL to make a POST request to the DAS API, allowing a user to retrieve asset data grouped by a specific collection. It outlines the necessary JSON-RPC parameters for the request.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/get-by-collection.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetsByGroup\",\n    \"params\": {\n        \"groupKey\": \"collection\",\n        \"groupValue\": \"<GROUPVALUE>\",\n        \"page\": 1\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Validating Attribute Plugin for Unstaking in Metaplex\nDESCRIPTION: Performs validation checks to ensure the asset has gone through the staking instruction by verifying the presence of the Attribute plugin and the required staking attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nif (!fetchedAsset.attributes) {\n    throw new Error(\n        \"Asset has no Attribute Plugin attached to it. Please go through the stake instruction before.\"\n    );\n}\n\nconst assetAttribute = fetchedAsset.attributes.attributeList;\nconst stakedTimeAttribute = assetAttribute.find((attr) => attr.key === \"stakedTime\");\nif (!stakedTimeAttribute) {\n    throw new Error(\n        \"Asset has no stakedTime attribute attached to it. Please go through the stake instruction before.\"\n    );\n}\n\nconst stakedAttribute = assetAttribute.find((attr) => attr.key === \"staked\");\nif (!stakedAttribute) {\n    throw new Error(\n        \"Asset has no staked attribute attached to it. Please go through the stake instruction before.\"\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Anchor Features in Cargo.toml\nDESCRIPTION: Configuration to enable anchor-specific features in mpl-core\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n[dependencies]\nmpl-core = { version = \"x.x.x\", features = [ \"anchor\" ] }\n```\n\n----------------------------------------\n\nTITLE: Unlocking (Thawing) Non-Fungible Token in TypeScript\nDESCRIPTION: This code example illustrates how to unlock (thaw) a non-fungible token using a Standard Delegate with the Metaplex Token Metadata program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unlockV1 } from '@metaplex-foundation/mpl-token-metadata'\n\nawait unlockV1(umi, {\n  mint,\n  authority: standardDelegate,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Example Response for MPL Core Assets by Authority Query\nDESCRIPTION: This shows the structure of the response returned when querying Core assets by authority. The response is an array of asset objects containing details such as public key, header information, royalties, metadata, content, and ownership details. For authorities with multiple assets, the array will contain multiple entries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-authority.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine with NFT Gate Guard in JavaScript\nDESCRIPTION: This code snippet demonstrates how to set up a Candy Machine with the NFT Gate guard using the Umi library. It configures the guard to require ownership of an NFT from a specified collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-gate.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftGate: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Digital Asset With Token Types\nDESCRIPTION: Type definitions extending Digital Asset to include Token and TokenRecord accounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Token } from '@metaplex-foundation/mpl-toolbox'\nimport {\n  DigitalAsset,\n  TokenRecord,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nexport type DigitalAssetWithToken = DigitalAsset & {\n  token: Token\n  tokenRecord?: TokenRecord\n}\n```\n\n----------------------------------------\n\nTITLE: Generating PublicKey in Umi\nDESCRIPTION: TypeScript code demonstrating how to generate a PublicKey using Metaplex Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi';\n\n// Generate a new Umi Publickey\nconst umiPublicKey = publicKey(\"11111111111111111111111111111111\");\n```\n\n----------------------------------------\n\nTITLE: Launching Sugar to Create Candy Machine\nDESCRIPTION: Command to start the Sugar launch process, which guides users through creating a Candy Machine for their NFT collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nsugar launch\n```\n\n----------------------------------------\n\nTITLE: TransferV1 CPI Builder Constructor Implementation\nDESCRIPTION: Internal implementation of the TransferV1 CPI Builder's new() function showing required account fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn new(program: &'b solana_program::account_info::AccountInfo<'a>) -> Self {\n        let instruction = Box::new(TransferV1CpiBuilderInstruction {\n            __program: program,\n            asset: None,\n            collection: None,\n            payer: None,\n            authority: None,\n            new_owner: None,\n            system_program: None,\n            log_wrapper: None,\n            compression_proof: None,\n            __remaining_accounts: Vec::new(),\n        });\n        Self { instruction }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Signer Validation using All Rule in Token Auth Rules\nDESCRIPTION: Demonstrates how to create a Rule Set that requires multiple signers to approve a deposit operation. The All rule combines two AdditionalSigner rules, requiring both specified public keys to sign the transaction for it to be valid.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/composite-rules/all.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will only evaluate to true if both Public Keys sign the transaction.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    deposit: {\n      type: 'All',\n      rules: [\n        {\n          type: 'AdditionalSigner',\n          publicKey: publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n        },\n        {\n          type: 'AdditionalSigner',\n          publicKey: publicKey('6twkdkDaF3xANuvpUQvENSLhtNmPxzYAEu8qUKcVkWwy'),\n        },\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Serializers with Different From and To Types in TypeScript\nDESCRIPTION: This snippet shows how to use mapSerializer with serializers that have different From and To types. It transforms a string serializer to a number serializer, handling null values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst serializerA: Serializer<string | null, string> = ...;\nconst serializerB: Serializer<number | null, number> = mapSerializer(\n  serializerA,\n  (value: number | null): string | null => value === null ? null : 'x'.repeat(value),\n  (value: string): number => value.length,\n);\n```\n\n----------------------------------------\n\nTITLE: Withdrawing and Closing Candy Machine\nDESCRIPTION: Closes the Candy Machine and reclaims account rent. Warning: This will close the Candy Machine even if not all NFTs are minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsugar withdraw\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine Collection in TypeScript\nDESCRIPTION: Demonstrates how to update the collection of a Candy Machine using the setCollectionV2 function, which supports both Programmable NFTs and regular NFTs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/pnfts.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setCollectionV2 } from '@metaplex-foundation/mpl-candy-machine'\n\nawait setCollectionV2(umi, {\n  candyMachine: candyMachine.publicKey,\n  collectionMint: candyMachine.collectionMint,\n  collectionUpdateAuthority: collectionUpdateAuthority.publicKey,\n  newCollectionMint: newCollectionMint.publicKey,\n  newCollectionUpdateAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Public Key Match Rule in Token Auth Rules\nDESCRIPTION: Demonstrates how to configure a rule set that validates a transfer operation against a single public key. The rule only allows transfers to a specific destination address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/pubkey-match.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    transfer: {\n      type: 'PubkeyMatch',\n      field: 'Destination',\n      publicKey: publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Sugar CLI on Mac/Linux\nDESCRIPTION: Command to install the Sugar CLI on Mac or Linux systems using a curl-based installer script.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbash <(curl -sSf https://sugar.metaplex.com/install.sh)\n```\n\n----------------------------------------\n\nTITLE: Defining Oracle Account Structure in Rust (Shank)\nDESCRIPTION: This code snippet defines the on-chain account structure for an Oracle Account using Shank. It includes the Validation struct, OracleValidation enum, and ExternalValidationResult enum.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[account]\npub struct Validation {\n    pub validation: OracleValidation,\n}\n\nimpl Validation {\n    pub fn size() -> usize {\n        1 // shank discriminator\n        + 5 // validation\n    }\n}\n\npub enum OracleValidation {\n    V1 {\n        create: ExternalValidationResult,\n        transfer: ExternalValidationResult,\n        burn: ExternalValidationResult,\n        update: ExternalValidationResult,\n    },\n}\n\npub enum ExternalValidationResult {\n    Approved,\n    Rejected,\n    Pass,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Third Party Signer Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine with the Third Party Signer guard using the Umi library in TypeScript. It configures the guard with a signer key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/third-party-signer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myConfiguredSigner = generateSigner(umi);\n\ncreate(umi, {\n  // ...\n  guards: {\n    thirdPartySigner: some({ signerKey: myConfiguredSigner.publicKey }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Anchor Project\nDESCRIPTION: Command to create a new Anchor project for the token claimer implementation using the Anchor Version Manager (avm).\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nanchor init token-claimer-example\n```\n\n----------------------------------------\n\nTITLE: Deserializing Account Data with Custom Serializer\nDESCRIPTION: Shows how to deserialize account data using a custom serializer structure with public keys and numbers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertAccountExists, deserializeAccount } from '@metaplex-foundation/umi';\nimport { struct, publicKey, u64 } from '@metaplex-foundation/umi/serializers';\n\n// Given an existing RPC account.\nconst myRpcAccount = await umi.rpc.getAccount(myPublicKey);\nassertAccountExists(myRpcAccount);\n\n// And an account data serializer.\nconst myDataSerializer = struct([\n  ['source', publicKey()],\n  ['destination', publicKey()],\n  ['amount', u64()],\n]);\n\n// We can deserialize the account like so.\nconst myAccount = deserializeAccount(rawAccount, myDataSerializer);\n```\n\n----------------------------------------\n\nTITLE: Revoking Plugin Authority in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to revoke a plugin authority using the MPL Core library. It uses the revokePluginAuthority function to revoke the 'Attributes' plugin authority for a specific asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/delegating-and-revoking-plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { revokePluginAuthority } from '@metaplex-foundation/mpl-core'\n\nawait revokePluginAuthority(umi, {\n  asset: asset.publicKey,\n  plugin: { type: 'Attributes' },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Installing Bubblegum Beta Package for cNFT Support on Other SVMs\nDESCRIPTION: Command to install the specific beta version of the Metaplex Bubblegum npm package required for interacting with cNFTs on alternative SVM environments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-interact-with-cnfts-on-other-svms.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm -i @metaplex-foundation/mpl-bubblegum@4.3.1-beta.0\n```\n\n----------------------------------------\n\nTITLE: Signed CPI Invocation with PDA\nDESCRIPTION: Example of invoking a CPI call with PDA signer seeds for authorized transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nlet signers = &[&[b\"escrow\", ctx.accounts.asset.key(), &[ctx.bumps.pda_escrow]]]\n\nCreateV1CpiBuilder::new()\n        .asset(context.accounts,asset)\n        ...\n        .invoke(signers)\n```\n\n----------------------------------------\n\nTITLE: Installing Required Package: MPL-Core\nDESCRIPTION: This snippet illustrates how to install the @metaplex-foundation/mpl-core package, which is essential for core functionalities in the MPL-Hybrid framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/mpl-core\n```\n\n----------------------------------------\n\nTITLE: Fetching Asset Data\nDESCRIPTION: Retrieves asset information including attribute plugin data using the MPL-Core SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst fetchedAsset = await fetchAsset(umi, asset);\n```\n\n----------------------------------------\n\nTITLE: Asset Account Deserialization in Anchor\nDESCRIPTION: Example of deserializing a BaseAssetV1 account using Anchor's Account struct\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct ExampleAccountStruct<'info> {\n    ...\n    pub asset: Account<'info, BaseAssetV1>,\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching All Digital Assets With Token by Owner and Mint\nDESCRIPTION: Helper function to fetch all Digital Assets With Token for both an owner and Mint account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetWithTokenByOwnerAndMint } from '@metaplex-foundation/mpl-token-metadata'\n\nconst assets = await fetchAllDigitalAssetWithTokenByOwnerAndMint(\n  umi,\n  owner,\n  mint\n)\n```\n\n----------------------------------------\n\nTITLE: Fetching Latest Blockhash in TypeScript\nDESCRIPTION: Explains how to fetch the latest blockhash alongside its expiry block height. This operation is key for clients needing recent blockchain information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { blockhash, lastValidBlockHeight } = await umi.rpc.getLatestBlockhash();\n```\n\n----------------------------------------\n\nTITLE: Retrieving Asset Signatures Using cURL\nDESCRIPTION: This snippet shows how to make a direct JSON-RPC call to the DAS API using cURL to retrieve transaction signatures for a compressed asset. It specifies the asset ID in the request parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-signatures.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetSignaturesV2\",\n    \"params\": {\n        \"id\": \"GGRbPQhwmo3dXBkJSAjMFc1QYTKGBt8qc11tTp3LkEKA\"\n    },\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Finding Leaf Asset ID PDA\nDESCRIPTION: Function to derive the Leaf Asset ID PDA from merkle tree address and leaf index\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findLeafAssetIdPda } from '@metaplex-foundation/mpl-bubblegum'\n\nconst [assetId, bump] = await findLeafAssetIdPda(umi, {\n  merkleTree,\n  leafIndex,\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Guard into Default Guards in TypeScript\nDESCRIPTION: These TypeScript code snippets show how to integrate the custom guard into various default guard structures and arrays within the client.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomGuardArgs } from \"../generated\"\n\nexport type DefaultGuardSetArgs = GuardSetArgs & {\n    ...\n     // add your guard to the list\n    customGuard: OptionOrNullable<CustomGuardArgs>;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomGuard } from \"../generated\"\n\nexport type DefaultGuardSet = GuardSet & {\n    ...\n     // add your guard to the list\n    customGuard: Option<CustomGuard>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CustomGuardMintArgs } from \"./defaultGuards/customGuard.ts\"\nexport type DefaultGuardSetMintArgs = GuardSetMintArgs & {\n    ...\n    // add your guard to the list\n    customGuard: OptionOrNullable<CustomGuardMintArgs>\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport const defaultCandyGuardNames: string[] = [\n  ...// add your guard to the list\n  'customGuard',\n]\n```\n\n----------------------------------------\n\nTITLE: Adding New Staking Attributes\nDESCRIPTION: Adds new staking attributes to the existing attribute list if they don't exist.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n} else {\n    assetAttribute.push({ key: \"staked\", value: currentTime });\n    assetAttribute.push({ key: \"stakedTime\", value: \"0\" });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NumberSerializer Type in TypeScript\nDESCRIPTION: This snippet defines a type alias for number serializers that includes both number and bigint types.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntype NumberSerializer =\n  | Serializer<number>\n  | Serializer<number | bigint, bigint>;\n```\n\n----------------------------------------\n\nTITLE: Assigning New Authority to Core Candy Machine in TypeScript\nDESCRIPTION: This code shows how to transfer ownership of a Core Candy Machine to a new authority address, which is necessary when changing project management.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/update.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { setMintAuthority } from '@metaplex-foundation/mpl-core-candy-machine'\n\nconst candyMachine = publicKey('11111111111111111111111111111111')\nconst newAuthority = publicKey('22222222222222222222222222222222')\n\nawait setMintAuthority(umi, {\n  candyMachine,\n  mintAuthority: newAuthority,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Defining ValidationResultsOffset in Rust\nDESCRIPTION: This Rust code defines the ValidationResultsOffset enum, which is used to specify the location of the OracleValidation struct within the Oracle account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/oracle.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub enum ValidationResultsOffset {\n    NoOffset,\n    Anchor,\n    Custom(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi Framework\nDESCRIPTION: Basic setup for Umi framework including connection to Devnet and keypair configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://api.devnet.solana.com\", \"finalized\")\n\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(wallet));\nconst myKeypairSigner = createSignerFromKeypair(umi, keypair);\numi.use(signerIdentity(myKeypairSigner));\n```\n\n----------------------------------------\n\nTITLE: Fixing and Reversing Serializers in TypeScript\nDESCRIPTION: This snippet shows how to use the fixSerializer and reverseSerializer functions to transform serializers. fixSerializer makes a variable-size serializer fixed-size, while reverseSerializer reverses the bytes of a fixed-size serializer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myFixedSerializer = fixSerializer(myVariableSerializer, 42);\n\nconst myReversedSerializer = reverseSerializer(mySerializer);\n```\n\n----------------------------------------\n\nTITLE: Estimate NFT Inscription Cost - Bash\nDESCRIPTION: Calculates the total cost of inscribing an NFT based on the account overhead and file sizes. This command is optional and requires a hashlist file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm cli cost hashlist -h <HASHLIST_FILE>\n```\n\n----------------------------------------\n\nTITLE: Resolving Program Errors in TypeScript\nDESCRIPTION: Demonstrates how to use the resolveError method to identify and resolve custom program errors from transaction errors.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\numi.programs.resolveError(error, transaction);\n```\n\n----------------------------------------\n\nTITLE: Implementing Public Key List Match Rule in Token Auth Rules\nDESCRIPTION: Shows how to set up a rule set that checks if a transfer destination matches any public key from a predefined list. Useful for implementing allowlists.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/pubkey-match.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    transfer: {\n      type: 'PubkeyListMatch',\n      field: 'Destination',\n      publicKeys: [publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'), publicKey('6twkdkDaF3xANuvpUQvENSLhtNmPxzYAEu8qUKcVkWwy')],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Example Response Structure for Core Assets by Owner Query\nDESCRIPTION: This JSON snippet shows the expected response format when querying MPL Core assets by owner. It includes asset details such as public key, owner address, royalty information, metadata, and content fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-owner.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    publicKey: '8VrqN8b8Y7rqWsUXqUw7dxQw9J5UAoVyb6YDJs1mBCCz',\n    header: {\n      executable: false,\n      owner: 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',\n      lamports: [Object],\n      rentEpoch: 18446744073709551616n,\n      exists: true\n    },\n    pluginHeader: { key: 3, pluginRegistryOffset: 179n },\n    royalties: {\n      authority: [Object],\n      offset: 138n,\n      basisPoints: 500,\n      creators: [Array],\n      ruleSet: [Object]\n    },\n    key: 1,\n    updateAuthority: {\n      type: 'Collection',\n      address: 'FgEKkVTSfLQ7a7BFuApypy4KaTLh65oeNRn2jZ6fiBav'\n    },\n    name: 'Number 1',\n    uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n    content: {\n      '$schema': 'https://schema.metaplex.com/nft1.0.json',\n      json_uri: 'https://arweave.net/TkklLLQKiO9t9_JPmt-eH_S-VBLMcRjFcgyvIrENBzA',\n      files: [Array],\n      metadata: [Object],\n      links: [Object]\n    },\n    owner: 'AUtnbwWJQfYZjJ5Mc6go9UancufcAuyqUZzR1jSe4esx',\n    seq: { __option: 'None' }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Remove External Plugin from Collection - Rust\nDESCRIPTION: Demonstrates how to remove an external plugin adapter from a collection using RemoveCollectionExternalPluginAdapterV1Builder in Rust. Includes complete transaction building and submission logic.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/removing-external-plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::{instructions::RemoveCollectionExternalPluginAdapterV1Builder, types::ExternalPluginAdapterKey};\nuse solana_client::nonblocking::rpc_client;\nuse solana_sdk::{pubkey::Pubkey, signature::Keypair, signer::Signer, transaction::Transaction};\nuse std::str::FromStr;\n\npub async fn remove_external_plugin_adapter_from_collection() {\n    let rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n\n    let authority = Keypair::new();\n    let collection = Pubkey::from_str(\"11111111111111111111111111111111\").unwrap();\n    let oracle_account = Pubkey::from_str(\"22222222222222222222222222222222\").unwrap();\n\n    let remove_external_plugin_adapter_from_collection_ix = RemoveCollectionExternalPluginAdapterV1Builder::new()\n        .collection(collection)\n        .key(ExternalPluginAdapterKey::Oracle(oracle_account))\n        .payer(authority.pubkey())\n        .instruction();\n\n    let signers = vec![&authority];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await.unwrap();\n\n    let remove_external_plugin_adapter_from_collection_tx = Transaction::new_signed_with_payer(\n        &[remove_external_plugin_adapter_from_collection_ix],\n        Some(&authority.pubkey()),\n        &signers,\n        last_blockhash,\n    );\n\n    let res = rpc_client\n        .send_and_confirm_transaction(&remove_external_plugin_adapter_from_collection_tx)\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: Minting with NFT Burn Guard in TypeScript\nDESCRIPTION: This code demonstrates how to mint from a Candy Machine with the NFT Burn guard enabled, providing the required parameters including the NFT to burn, the collection it belongs to, and its token standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-burn.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from \"@metaplex-foundation/mpl-token-metadata\";\n\nmintV2(umi, {\n  // ...\n  mintArgs: {\n    nftBurn: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n      mint: nftToBurn.publicKey,\n      tokenStandard: TokenStandard.NonFungible,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Verifying On-chain Items with Custom Cache File\nDESCRIPTION: Command to verify items using a custom cache file instead of the default cache.json. The <CACHE> parameter specifies the path to the custom cache file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/verify.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar verify --cache <CACHE>\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions with Multiple Signers in TypeScript\nDESCRIPTION: Shows how to use the signTransaction helper method to sign a transaction with multiple signers. This is useful when a transaction requires signatures from multiple parties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/public-keys-and-signers.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySignedTransaction = await signTransaction(myTransaction, mySigners);\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared NFT Settings for Candy Machine in JavaScript\nDESCRIPTION: Shows how to set up shared NFT settings for a Candy Machine, including seller fee basis points, creators, token standard, symbol, max edition supply, and mutability.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/settings.md#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { percentAmount, generateSigner, some } from '@metaplex-foundation/umi'\nimport { TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\n\nconst creatorA = generateSigner(umi).publicKey\nconst creatorB = generateSigner(umi).publicKey\nconst candyMachineSettings = {\n  tokenStandard: TokenStandard.NonFungible,\n  sellerFeeBasisPoints: percentAmount(33.3, 2),\n  symbol: 'MYPROJECT',\n  maxEditionSupply: 0,\n  isMutable: true,\n  creators: [\n    { address: creatorA, percentageShare: 50, verified: false },\n    { address: creatorB, percentageShare: 50, verified: false },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading Solana Programs\nDESCRIPTION: CLI command for downloading specific programs from a source cluster to use in local validator testing, specifying source and destination.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsolana program dump -u <source cluster> <address of account to fetch> <destination file name/path>\n```\n\n----------------------------------------\n\nTITLE: Sending PUT Request with Bearer Token\nDESCRIPTION: Shows how to send a PUT request with an authentication bearer token using Umi's HTTP request builder\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/http-requests.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait umi.http.send(request().put('https://example.com/users/1').withToken('my-token'));\n```\n\n----------------------------------------\n\nTITLE: Installing Bubblegum Package for Compressed NFTs\nDESCRIPTION: Command to install the Metaplex Bubblegum package which provides functionality for creating and managing compressed NFTs (cNFTs) on Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-bubblegum\n```\n\n----------------------------------------\n\nTITLE: Getting Asset Proof using cURL\nDESCRIPTION: This snippet shows how to make a direct RPC call to retrieve the merkle tree proof for a compressed asset using cURL. It sends a POST request to the DAS API endpoint with the getAssetProof method and the asset ID as a parameter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/methods/get-asset-proof.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncurl --request POST --url \"<ENDPOINT>\" --header 'Content-Type: application/json' --data '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"getAssetProof\",\n    \"params\": [\n      \"Ez6ezCMkRaUkWS5v6WVcP7uuCWiKadr3W2dHFkoZmteW\"\n    ],\n    \"id\": 0\n}'\n```\n\n----------------------------------------\n\nTITLE: Updating Staking Attributes for NFT Unstaking in Rust\nDESCRIPTION: This snippet shows how to update the staking attributes of an NFT during the unstaking process. It sets the 'Staked' field to zero and updates the 'stakedTime' attribute.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nOk((_, fetched_attribute_list, _)) => {\n    let mut attribute_list: Vec<Attribute> = Vec::new();\n    let mut is_initialized: bool = false;\n    let mut staked_time: i64 = 0;\n\n    for attribute in fetched_attribute_list.attribute_list.iter() {\n        if attribute.key == \"staked\" {\n            require!(attribute.value != \"0\", StakingError::NotStaked);\n            attribute_list.push(Attribute { \n                key: \"staked\".to_string(), \n                value: 0.to_string() \n            });\n            staked_time = staked_time\n                .checked_add(Clock::get()?.unix_timestamp\n                .checked_sub(attribute.value.parse::<i64>()\n                .map_err(|_| StakingError::InvalidTimestamp)?)\n                .ok_or(StakingError::Underflow)?)\n                .ok_or(StakingError::Overflow)?;\n            is_initialized = true;\n        } else if attribute.key == \"staked_time\" {\n            staked_time = staked_time\n                .checked_add(attribute.value.parse::<i64>()\n                .map_err(|_| StakingError::InvalidTimestamp)?)\n                .ok_or(StakingError::Overflow)?;\n        } else {\n            attribute_list.push(attribute.clone());\n        } \n    }\n\n    attribute_list.push(Attribute { \n        key: \"staked_time\".to_string(), \n        value: staked_time.to_string() \n    });\n\n    require!(is_initialized, StakingError::StakingNotInitialized);\n```\n\n----------------------------------------\n\nTITLE: Implementing scan_ticket Function in Rust\nDESCRIPTION: This function handles the ticket scanning logic. It checks if the ticket has already been scanned, writes data to the external plugin adapter to mark it as scanned, and updates the plugin state to make the digital asset soulbound. The function utilizes various external plugin adapter methods to achieve this functionality.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\npub fn scan_ticket(ctx: Context<ScanTicket>) -> Result<()> {\n\n    let (_, app_data_length) = fetch_external_plugin_adapter_data_info::<BaseAssetV1>(\n            &ctx.accounts.ticket.to_account_info(), \n            None, \n            &ExternalPluginAdapterKey::AppData(\n                PluginAuthority::Address { address: ctx.accounts.signer.key() }\n            )\n        )?;\n\n    require!(app_data_length == 0, TicketError::AlreadyScanned);\n\n    let data: Vec<u8> = \"Scanned\".as_bytes().to_vec();\n\n    WriteExternalPluginAdapterDataV1CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n    .asset(&ctx.accounts.ticket.to_account_info())\n    .collection(Some(&ctx.accounts.event.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .key(ExternalPluginAdapterKey::AppData(PluginAuthority::Address { address: ctx.accounts.signer.key() }))\n    .data(data)\n    .invoke()?;\n\n    let signer_seeds = &[b\"manager\".as_ref(), &[ctx.accounts.manager.bump]];\n\n    UpdatePluginV1CpiBuilder::new(&ctx.accounts.mpl_core_program.to_account_info())\n    .asset(&ctx.accounts.ticket.to_account_info())\n    .collection(Some(&ctx.accounts.event.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.manager.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::PermanentFreezeDelegate(PermanentFreezeDelegate { frozen: true }))\n    .invoke_signed(&[signer_seeds])?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Environment for Core Asset Creation in TypeScript\nDESCRIPTION: This snippet sets up the test environment using Anchor and imports necessary dependencies for testing Core Asset creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as anchor from \"@coral-xyz/anchor\";\nimport { Program } from \"@coral-xyz/anchor\";\nimport { CreateCoreAssetExample } from \"../target/types/create_core_asset_example\";\nimport { Keypair, SystemProgram } from \"@solana/web3.js\";\nimport { MPL_CORE_PROGRAM_ID } from \"@metaplex-foundation/mpl-core\";\n\ndescribe(\"create-core-asset-example\", () => {\n  anchor.setProvider(anchor.AnchorProvider.env());\n  const wallet = anchor.Wallet.local();\n  const program = anchor.workspace.CreateCoreAssetExample as Program<CreateCoreAssetExample>;\n\n  let asset = Keypair.generate();\n\n  it(\"Create Asset\", async () => {\n\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Escrow with TypeScript\nDESCRIPTION: This code snippet demonstrates how to initialize an MPL 404 Hybrid Escrow account, setting various parameters such as the escrow name, URI for metadata, and collection information. It requires the `umi` library for executing the transaction, as well as the associated token program ID from the `mpl-toolbox` package. The expected input is an object containing all necessary configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/create-escrow.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst initTx = await initEscrowV1(umi, {\n  // Escrow Name\n  name: escrowName,\n  // Metadata Pool Base Uri\n  uri: baseMetadataPoolUri,\n  // Escrow Address based on \"escrow\" + collection address seeds\n  escrow: escrowAddress,\n  // Collection Address\n  collection: collectionAddress,\n  // Token Mint\n  token: tokenMint,\n  // Fee Wallet\n  feeLocation: feeWallet,\n  // Fee Token Account\n  feeAta: feeTokenAccount,\n  // Min index of NFTs in the pool\n  min: minAssetIndex,\n  // Max index of NFTs in the pool\n  max: maxAssetIndex,\n  // Amount of fungible token to swap to\n  amount: swapToTokenValueReceived,\n  // Fee amount to pay when swapping to NFTs\n  feeAmount: swapToNftTokenFee,\n  // Optional additional fee to pay when swapping to NFTs\n  solFeeAmount: sol(0.5).basisPoints,\n  // Reroll metadata on swap 0 = true, 1 = false\n  path: rerollEnabled,\n  // Associated Token Program ID\n  associatedTokenProgram: SPL_ASSOCIATED_TOKEN_PROGRAM_ID,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Performing a Delegated Update on a Collection Item as a Programmable Config Delegate in TypeScript\nDESCRIPTION: Uses a Programmable Config Delegate to update the ruleSet of a PNFT that is part of a collection. Requires the item mint, token account, collection mint, delegate authority as a signer, and the new ruleSet configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateAsAuthorityItemDelegateV2,\n  ruleSetToggle,\n} from '@metaplex-foundation/mpl-token-metadata'\nimport { findAssociatedTokenPda } from '@metaplex-foundation/mpl-toolbox'\n\nawait updateAsProgrammableConfigDelegateV2(umi, {\n  mint,\n  token: findAssociatedTokenPda(umi, { mint, owner: assetOwner }),\n  delegateMint: collectionMint,\n  authority: programmableConfigDelegate,\n  ruleSet: ruleSetToggle('Set', [ruleSet]),\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Exporting Custom Guard in TypeScript\nDESCRIPTION: This TypeScript code exports the newly created custom guard, adding it to the list of existing guards in the index file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from './tokenGate';\nexport * from './tokenPayment';\nexport * from './token2022Payment';\n// add your guard to the list\nexport * from './customGuard';\n```\n\n----------------------------------------\n\nTITLE: Unverifying Collection on Item as Delegate in Metaplex Token Metadata (TypeScript)\nDESCRIPTION: This code example illustrates how a Collection Delegate can unverify a collection on an item using the unverifyCollectionV1 function. It removes the verified status of the collection for the specified NFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/delegates.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  unverifyCollectionV1,\n  findMetadataPda,\n} from '@metaplex-foundation/mpl-token-metadata'\n\nawait unverifyCollectionV1(umi, {\n  metadata: findMetadataPda(umi, { mint }),\n  collectionMint,\n  authority: collectionDelegate,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Allocation Guard in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to mint with the Allocation guard by passing the guard's ID in the mintArgs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allocation.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    allocation: some({ id: 1 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Payer-Authority Pattern with Shank in Rust\nDESCRIPTION: A Shank implementation of the Payer-Authority pattern for creating a new account with separate payer and authority roles. The instruction requires the account and payer as mandatory signers, while the authority is optional.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/payer-authority-pattern.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n    /// Create a new account.\n    #[account(0, writable, signer, name=\"account\", desc = \"The address of the new account\")]\n    #[account(1, writable, signer, name=\"payer\", desc = \"The account paying for the storage fees\")]\n    #[account(2, optional, signer, name=\"authority\", desc = \"The authority signing for account creation\")]\n    #[account(3, name=\"system_program\", desc = \"The system program\")]\n    CreateAccountV1(CreateAccountV1Args),\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds from Freeze Escrow Account Using Candy Guard Authority in JavaScript\nDESCRIPTION: This code snippet demonstrates how to unlock funds from a Freeze Escrow account using the `route` function from the Candy Machine Core program. It specifies the 'unlockFunds' path, the destination wallet address, and uses the current identity as the Candy Guard authority. The `route` function executes the specified path in the route instruction, transferring the funds to the configured destination address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nroute(umi, {\n  // ...\n  guard: 'freezeSolPayment',\n  routeArgs: {\n    path: 'unlockFunds',\n    destination,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata and Collection Structures in Rust\nDESCRIPTION: This Rust code snippet defines the `Metadata` and `Collection` structs which are critical for representing NFT metadata in the Metaplex Token Metadata standard. The `Collection` struct includes fields for indicating verification status and references to the associated SPL token mint account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/get-by-collection.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct Metadata {\n\tpub key: Key,\n\tpub update_authority: Pubkey,\n\tpub mint: Pubkey,\n\tpub data: Data,\n\t// Immutable, once flipped, all sales of this metadata are considered secondary.\n\tpub primary_sale_happened: bool,\n\t// Whether or not the data struct is mutable, default is not\n\tpub is_mutable: bool,\n\t/// nonce for easy calculation of editions, if present\n\tpub edition_nonce: Option<u8>,\n\t/// Token Standard is deterministic and will change from SemiFungible to NonFungible if\n\t/// you call the create master edition call and it succeeds.\n\tpub token_standard: Option<TokenStandard>,\n\t/// Since we cannot easily change Metadata, we add the new DataV2 fields here at the end.\n\t/// Collection\n\tpub collection: Option<Collection>,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug, Clone)]\npub struct Collection {\n\tpub verified: bool, // Whether or not the collection is verified\n\tpub key: Pubkey,    // The SPL token mint account of the collection NFT\n}\n```\n\n----------------------------------------\n\nTITLE: Byte Helper Functions in TypeScript\nDESCRIPTION: This example demonstrates various byte helper functions provided by Umi for manipulating Uint8Array buffers. It includes merging, padding, and fixing byte arrays.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Merge multiple Uint8Array buffers into one.\nmergeBytes([new Uint8Array([1, 2]), new Uint8Array([3, 4])]); // -> Uint8Array([1, 2, 3, 4])\n\n// Pad a Uint8Array buffer to the given size.\npadBytes(new Uint8Array([1, 2]), 4); // -> Uint8Array([1, 2, 0, 0])\npadBytes(new Uint8Array([1, 2, 3, 4]), 2); // -> Uint8Array([1, 2, 3, 4])\n\n// Pad and truncate a Uint8Array buffer to the given size.\nfixBytes(new Uint8Array([1, 2]), 4); // -> Uint8Array([1, 2, 0, 0])\nfixBytes(new Uint8Array([1, 2, 3, 4]), 2); // -> Uint8Array([1, 2])\n```\n\n----------------------------------------\n\nTITLE: Rendering API Method Documentation for getAssetsByGroup\nDESCRIPTION: This snippet uses a custom markdown component to render API documentation for the getAssetsByGroup method. It likely expands into a more detailed API reference when processed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/aura/api/v1/das/get-assets-by-group.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% apiRenderer method=\"getAssetsByGroup\" /%}\n```\n\n----------------------------------------\n\nTITLE: Burning a Compressed NFT using JavaScript with mpl-bubblegum\nDESCRIPTION: This snippet demonstrates how to burn a Compressed NFT using the burn function from the mpl-bubblegum library. It fetches the asset with proof using getAssetWithProof, then calls the burn function with the required parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/burn-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, burn } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, {truncateCanopy: true});\nawait burn(umi, {\n  ...assetWithProof,\n  leafOwner: currentLeafOwner,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Collection Program Structure\nDESCRIPTION: Initial program setup with imports and basic template structure for the Anchor program including program ID declaration and empty structs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\nuse mpl_core::{\n    ID as MPL_CORE_ID,\n    instructions::CreateCollectionV2CpiBuilder, \n};\n\ndeclare_id!(\"C9PLf3qMCVqtUCJtEBy8NCcseNp3KTZwFJxAtDdN1bto\");\n\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateCollectionArgs {\n\n}\n\n#[program]\npub mod create_core_collection_example {\n    use super::*;\n\n    pub fn create_core_collection(ctx: Context<CreateCollection>, args: CreateCollectionArgs) -> Result<()> {\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateCollection<'info> {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Removing an Authority in JavaScript\nDESCRIPTION: This snippet removes the calling authority from the authority array associated with a Metaplex inscription using the removeAuthority function. It emphasizes the importance of caution as removing all authorities will make the inscription immutable.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/authority.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  addAuthority,\n  findInscriptionMetadataPda,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nawait removeAuthority(umi, {\n  inscriptionMetadataAccount,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Complete Candy Machine Creation and Minting Example\nDESCRIPTION: Full JavaScript example that demonstrates creating a Candy Machine without guards, setting up a collection NFT, and minting an NFT to a recipient wallet. Includes configuration, setup, and error handling.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport {\n  addConfigLines,\n  createCandyMachineV2,\n  fetchCandyMachine,\n  mintFromCandyMachineV2,\n  mplCandyMachine,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport {\n  generateSigner,\n  keypairIdentity,\n  percentAmount,\n  publicKey,\n  sol,\n  some,\n  transactionBuilder,\n} from \"@metaplex-foundation/umi\";\nimport {\n  createNft,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { base58 } from \"@metaplex-foundation/umi-serializers\";\nimport {\n  createMintWithAssociatedToken,\n  setComputeUnitLimit,\n} from \"@metaplex-foundation/mpl-toolbox\";\n\n/**\n * This script demonstrates how to create a basic Candy Machine without guards\n * and mint an NFT to a recipient wallet.\n */\n\n// Configuration\nconst RECIPIENT_ADDRESS = \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\";\nconst RPC_ENDPOINT = \"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\";\n\n(async () => {\n  try {\n    // --- Setup ---\n    \n    // Initialize connection to Solana\n    const umi = createUmi(RPC_ENDPOINT).use(mplCandyMachine());\n    const recipient = publicKey(RECIPIENT_ADDRESS);\n\n    // Create and fund a test wallet\n    const walletSigner = generateSigner(umi);\n    umi.use(keypairIdentity(walletSigner));\n    console.log(\"Funding test wallet with devnet SOL...\");\n    await umi.rpc.airdrop(walletSigner.publicKey, sol(0.1), {\n      commitment: \"finalized\",\n    });\n\n    // --- Create Collection NFT ---\n    \n    const collectionMint = generateSigner(umi);\n    console.log(\"Creating collection NFT...\");\n    console.log(\"Collection Address:\", collectionMint.publicKey);\n\n    const createNftTx = await createNft(umi, {\n      mint: collectionMint,\n      authority: umi.identity,\n      name: \"My Collection NFT\",\n      uri: \"https://example.com/path/to/some/json/metadata.json\",\n      sellerFeeBasisPoints: percentAmount(9.99, 2),\n      isCollection: true,\n    }).sendAndConfirm(umi, {\n      confirm: { commitment: \"finalized\" },\n    });\n    console.log(\"Collection Created:\", base58.deserialize(createNftTx.signature)[0]);\n\n    // --- Create Candy Machine ---\n\n    console.log(\"Creating basic Candy Machine...\");\n    const candyMachine = generateSigner(umi);\n    \n    const createCandyMachineV2Tx = await (\n      await createCandyMachineV2(umi, {\n        candyMachine,\n        tokenStandard: TokenStandard.NonFungible,\n        collectionMint: collectionMint.publicKey,\n        collectionUpdateAuthority: umi.identity,\n        itemsAvailable: 2,\n        sellerFeeBasisPoints: percentAmount(1.23),\n        creators: [\n          {\n            address: umi.identity.publicKey,\n            verified: false,\n            percentageShare: 100,\n          },\n        ],\n        configLineSettings: some({\n          prefixName: \"My NFT #\",\n          nameLength: 3,\n          prefixUri: \"https://example.com/\",\n          uriLength: 29,\n          isSequential: false,\n        }),\n      })\n    )\n      .add(\n        addConfigLines(umi, {\n          candyMachine: candyMachine.publicKey,\n          index: 0,\n          configLines: [\n            { name: \"1\", uri: \"https://example.com/nft1.json\" },\n            { name: \"2\", uri: \"https://example.com/nft2.json\" },\n          ],\n        })\n      )\n      .sendAndConfirm(umi, { confirm: { commitment: \"finalized\" } });\n      \n    console.log(\"Candy Machine Created:\", base58.deserialize(createCandyMachineV2Tx.signature)[0]);\n\n    // --- Mint NFT ---\n\n    console.log(\"Minting NFT to recipient...\");\n    \n    // Get latest Candy Machine state\n    const candyMachineAccount = await fetchCandyMachine(umi, candyMachine.publicKey);\n\n    // Create mint transaction\n    const nftMint = generateSigner(umi);\n    const mintTx = await transactionBuilder()\n      .add(setComputeUnitLimit(umi, { units: 800_000 }))\n      .add(\n        createMintWithAssociatedToken(umi, { mint: nftMint, owner: recipient })\n      )\n      .add(\n        mintFromCandyMachineV2(umi, {\n          candyMachine: candyMachine.publicKey,\n          mintAuthority: umi.identity,\n          nftOwner: recipient,\n          nftMint,\n          collectionMint: candyMachineAccount.collectionMint,\n          collectionUpdateAuthority: candyMachineAccount.authority,\n        })\n      )\n      .sendAndConfirm(umi, {\n        confirm: { commitment: \"finalized\" },\n      });\n\n    console.log(\"NFT Minted Successfully!\");  \n    console.log(\"Mint Transaction:\", base58.deserialize(mintTx.signature)[0]);\n\n  } catch (error) {\n    console.error(\"Failed to execute:\", error);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Skipping Preflight with Solana Rust Client\nDESCRIPTION: Shows how to bypass preflight simulation when sending transactions using the Solana Rust client. Uses RpcSendTransactionConfig to set skip_preflight to true, allowing failed transactions to be registered on-chain for debugging.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/how-to-diagnose-solana-transaction-errors.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Create Connection\nlet rpc_client = rpc_client::RpcClient::new(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\".to_string());\n\n// Create your transaction\nlet transaction = new Transaction()\n\n// Add skipPreflight to the sendTransaction() function\nlet res = rpc_client\n    .send_transaction_with_config(&create_asset_tx, RpcSendTransactionConfig {\n        skip_preflight: true,\n        preflight_commitment: Some(CommitmentConfig::confirmed().commitment),\n        encoding: None,\n        max_retries: None,\n        min_context_slot: None,\n    })\n    .await\n    .unwrap();\n\n// Log out the transaction signature\nprintln!(\"Signature: {:?}\", res)\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Redeemed Amount Guard in JavaScript\nDESCRIPTION: This code demonstrates how to set up a Candy Machine with a Redeemed Amount guard using JavaScript. The guard limits minting to 300 NFTs even though the Candy Machine has 500 items available.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  itemsAvailable: 500,\n  guards: {\n    redeemedAmount: some({ maximum: 300 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring NFT Gate Guard in Sugar config.json\nDESCRIPTION: This JSON snippet shows how to configure the NFT Gate guard in the Sugar tool's config.json file. It specifies the required collection that users must own an NFT from to be eligible for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/nft-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"nftGate\" : {\n    \"requiredCollection\": \"<PUBKEY>\",\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Authorization Rules Program ID\nDESCRIPTION: Shows two methods for obtaining the Authorization Rules Program ID: using the mpl-token-auth-rules package or direct program address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/pnfts.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst authorizationRulesProgram = getMplTokenAuthRulesProgramId(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst authorizationRulesProgram = pubicKey(\"auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg\")\n```\n\n----------------------------------------\n\nTITLE: Option Helper Functions Usage\nDESCRIPTION: Examples of using Option helper functions for creating and manipulating Option types\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if an option is a `Some` or `None`.\nisSome(some('Hello World')); // -> true\nisSome(none()); // -> false\nisNone(some('Hello World')); // -> false\nisNone(none()); // -> true\n\n// Unwrap the value of an option if it is a `Some` or return null.\n// Supports custom fallback values for `None`.\nunwrapOption(some('Hello World')) // -> 'Hello World'\nunwrapOption(none()) // -> null\nunwrapOption(some('Hello World'), () => 'Default'); // -> 'Hello World'\nunwrapOption(none(), () => 'Default'); // -> 'Default'\n\n// Same as `unwrapOption` but recursively (without mutating the original object/array).\n// Also supports custom fallback values for `None`.\nunwrapOptionRecursively({\n  a: 'hello',\n  b: none<string>(),\n  c: [{ c1: some(42) }, { c2: none<number>() }],\n}) // -> { a: 'hello', b: null, c: [{ c1: 42 }, { c2: null }] }\n```\n\n----------------------------------------\n\nTITLE: Generating IDL and Client using Shell Commands\nDESCRIPTION: These shell commands are used to generate the IDL and initial client for the custom Candy Guard. They can be run separately or together using pnpm.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm run generate\n```\n\n----------------------------------------\n\nTITLE: Defining Metaplex Core Dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to include the mpl-core crate as a dependency in the Cargo.toml file, enabling the anchor feature for use with the Anchor framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nmpl-core = { version = \"x.x.x\", features = [\"anchor\"] }\n```\n\n----------------------------------------\n\nTITLE: Configuring Third Party Signer Guard in Sugar JSON\nDESCRIPTION: This JSON snippet shows how to configure the Third Party Signer guard in the config.json file for Sugar. It specifies the signer key as a public key string.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/third-party-signer.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"thirdPartySigner\" : {\n    \"signerKey\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using create_pda Method for On-chain Operations in Rust\nDESCRIPTION: This snippet shows how to use the `create_pda` method for on-chain operations. It's recommended for use on-chain as it can save compute units compared to `find_pda`, but requires storing the bump used for PDA derivation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet metadata_pubkey = Metadata::create_pda(mint, bump)?;\n```\n\n----------------------------------------\n\nTITLE: Fetching Attribute Plugin Information in Rust\nDESCRIPTION: This snippet demonstrates how to use the fetch_plugin function to retrieve information about the attribute plugin of an asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmatch fetch_plugin::<BaseAssetV1, Attributes>(\n    &ctx.accounts.asset.to_account_info(), \n    mpl_core::types::PluginType::Attributes\n)\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Anchor Program\nDESCRIPTION: These commands are used to build and deploy the Anchor program for creating Core Collections.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nanchor build\n```\n\nLANGUAGE: bash\nCODE:\n```\nanchor deploy\n```\n\n----------------------------------------\n\nTITLE: Creating NFT Collection\nDESCRIPTION: Implementation for creating a new NFT collection using Metaplex Core SDK.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n(async () => {\n   // Generate the Collection KeyPair\n   const collection = generateSigner(umi)\n   console.log(\"\\nCollection Address: \", collection.publicKey.toString())\n\n   // Generate the collection\n   const tx = await createCollection(umi, {\n       collection: collection,\n       name: 'My Collection',\n       uri: 'https://example.com/my-collection.json',\n   }).sendAndConfirm(umi)\n\n   // Deserialize the Signature from the Transaction\n   const signature = base58.deserialize(tx.signature)[0];\n   console.log(`\\nCollection Created: https://solana.fm/tx/${signature}?cluster=devnet-alpha`);\n})();\n```\n\n----------------------------------------\n\nTITLE: Adding Attribute Plugin to Asset in Rust\nDESCRIPTION: This code adds an attribute plugin to an asset if it doesn't exist, initializing it with 'staked' and 'stakedTime' attributes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nErr(_) => {\n    AddPluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::Attributes(\n        Attributes{ \n            attribute_list: vec![\n                Attribute { \n                    key: \"staked\".to_string(), \n                    value: Clock::get()?.unix_timestamp.to_string() \n                },\n                Attribute { \n                    key: \"staked_time\".to_string(), \n                    value: 0.to_string() \n                },\n            ] \n        }\n    ))\n    .init_authority(PluginAuthority::UpdateAuthority)\n    .invoke()?;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hidden Settings for Sugar Candy Machine\nDESCRIPTION: This JSON snippet shows an example of the hiddenSettings configuration in Sugar. It demonstrates how to set up placeholder metadata for NFTs that will be revealed later, including name, URI, and hash values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/configuration.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"hiddenSettings\": {\n    \"name\": \"Name $ID+1$\",\n    \"uri\": \"https://arweave.net/IM4NByHrEzG87g2AhFY4pY7lk7YNriUVUUbZWhZ0HHY/26.png\",\n    \"hash\": \"49Bj8ZVSvSvAQwziKEts3iAeUhi27ATH\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setup Manager Account Structure\nDESCRIPTION: Defines the account structure for initializing the ticket manager PDA with necessary account validations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct SetupManager<'info> {\n   pub signer: Signer<'info>,\n   #[account(mut)]\n   pub payer: Signer<'info>,\n   #[account(\n       init,\n       payer = payer,\n       space = Manager::INIT_SPACE,\n       seeds = [MANAGER_SEEDS.as_bytes()],\n       bump,\n   )]\n   pub manager: Account<'info, Manager>,\n   pub system_program: Program<'info, System>,\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi Framework in TypeScript\nDESCRIPTION: Sets up the Umi framework with wallet configuration for interacting with Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSignerFromKeypair, signerIdentity } from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\n\n// SecretKey for the wallet you're going to use \nimport wallet from \"../wallet.json\";\n\nconst umi = createUmi(\"https://api.devnet.solana.com\", \"finalized\")\n\nlet keyair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(wallet));\nconst myKeypairSigner = createSignerFromKeypair(umi, keyair);\numi.use(signerIdentity(myKeypairSigner));\n```\n\n----------------------------------------\n\nTITLE: Fetching AssetMintCounter Account in JavaScript\nDESCRIPTION: Retrieves the AssetMintCounter account associated with a specific asset, candy machine, and ID combination for validation purposes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-mint-limit.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { \n  findAssetMintCounterPda,\n  fetchNftMintCounter\n } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst pda = findAssetMintCounterPda(umi, {\n  id: 1, // The nftMintLimit id you set in your guard config\n  mint: asset.publicKey, // The address of the nft your user owns\n  candyMachine: candyMachine.publicKey,\n  // or candyMachine: publicKey(\"Address\") with your CM Address\n  candyGuard: candyMachine.mintAuthority\n  // or candyGuard: publicKey(\"Address\") with your candyGuard Address\n});\n      \nconst nftMintCounter = fetchAssetMintCounter(umi, pda)\n```\n\n----------------------------------------\n\nTITLE: Burning pNFT using Anchor with anchor-spl 0.31.0\nDESCRIPTION: This snippet shows how to burn a programmable NFT (pNFT) using the Anchor framework with anchor-spl 0.31.0 in Rust. It defines the account structure and implements the burn instruction using the BurnNft accounts struct and burn_nft function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{metadata::{BurnNft, burn_nft}, token::Mint};\n\n#[derive(Accounts)]\npub struct PnftBurn<'info> {\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    #[account(mut)]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub metadata: AccountInfo<'info>,\n    #[account(mut)]\n    pub token: AccountInfo<'info>,\n    #[account(mut)]\n    pub edition: AccountInfo<'info>,\n    pub spl_token: AccountInfo<'info>,\n    pub metadata_program_id: AccountInfo<'info>,\n    /// CHECK: Optional collection metadata\n    #[account(mut)]\n    pub collection_metadata: Option<AccountInfo<'info>>,\n}\n\npub fn burn_pnft_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, PnftBurn<'info>>,\n) {\n    // Create the accounts struct\n    let cpi_accounts = BurnNft {\n        metadata: ctx.accounts.metadata.clone(),\n        owner: ctx.accounts.owner.to_account_info().clone(),\n        mint: ctx.accounts.mint.to_account_info().clone(),\n        token: ctx.accounts.token.clone(),\n        edition: ctx.accounts.edition.clone(),\n        spl_token: ctx.accounts.spl_token.clone(),\n    };\n    \n    // Create CPI context\n    let cpi_ctx = CpiContext::new(\n        ctx.accounts.metadata_program_id.clone(),\n        cpi_accounts,\n    ).with_remaining_accounts(ctx.remaining_accounts.to_vec());\n    \n    // Get collection metadata pubkey if it exists\n    let collection_metadata = ctx.accounts.collection_metadata.as_ref().map(|a| a.key());\n    \n    // Execute the CPI\n    burn_nft(cpi_ctx, collection_metadata).expect(\"Failed to burn PNFT\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Freeze Sol Payment Guard in Sugar Config File\nDESCRIPTION: JSON configuration for the Freeze Sol Payment guard in the Sugar CLI. This snippet shows how to add the freezeSolPayment object to your config.json file with SOL value and destination public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"freezeSolPayment\" : {\n    \"value\": SOL value,\n    \"destination\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Topping Up Wallet with Tokens for Turbo Upload\nDESCRIPTION: Converts lamports to Turbo's Winc tokens and tops up the wallet to ensure sufficient funds for the metadata upload.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Top up wallet if required\nawait turbo.topUpWithTokens({tokenAmount: lamportToTokenAmount(requiredLamportsForMetadata)});\n```\n\n----------------------------------------\n\nTITLE: Initializing Boolean Serializers in TypeScript\nDESCRIPTION: This snippet shows how to create boolean serializers with different underlying number types and endianness.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nbool(); // -> Uses a u8.\nbool({ size: u32() }); // -> Uses a u32.\nbool({ size: u32({ endian: Endian.Big }) }); // -> Uses a big-endian u32.\n```\n\n----------------------------------------\n\nTITLE: Defining Hidden Settings Structure in TypeScript\nDESCRIPTION: Defines the structure for hidden settings in a Core Candy Machine, including name, URI, and hash properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/create.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nhiddenSettings = {\n  name: string,\n  uri: string,\n  hash: Uint8Array,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Irys Uploader for Decentralized Storage\nDESCRIPTION: Command to install the Irys uploader package which enables uploading files to decentralized storage for NFT metadata and assets.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-uploader-irys\n```\n\n----------------------------------------\n\nTITLE: Using Signer with Umi\nDESCRIPTION: This code allows assigning a supplied signer to the Umi instance stored in the state. It's beneficial for cases requiring a private key or certain signer types. It's callable from both TypeScript and TypeScript JSX files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst umiWithSigner = (signer: Signer) => {\n  const umi = useUmiStore.getState().umi\n  if (!signer) throw new Error('No Signer selected')\n  return umi.use(signerIdentity(signer))\n}\n\nexport default umiWithSigner\n```\n\n----------------------------------------\n\nTITLE: Fetching Wallet SOL Balance\nDESCRIPTION: This code snippet demonstrates how to fetch the SOL balance of a wallet using the `getAccount` function from Umi. It retrieves the account data and extracts the lamports value, which represents the SOL balance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst account = await umi.rpc.getAccount(umi.identity.publicKey);\nconst solBalance = account.lamports;\n```\n\n----------------------------------------\n\nTITLE: Example Library Function with Umi Context\nDESCRIPTION: TypeScript example showing how to use Umi's Context interface in a library function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Context, PublicKey } from '@metaplex-foundation/umi';\nimport { u32 } from '@metaplex-foundation/umi/serializers';\n\nexport async function myFunction(\n  context: Pick<Context, 'rpc'>, // <-- Inject the interfaces you need.\n  publicKey: PublicKey\n): number {\n  const rawAccount = await context.rpc.getAccount(publicKey);\n  if (!rawAccount.exists) return 0;\n  return u32().deserialize(rawAccount.data)[0];\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Candy Machine Guards in TypeScript\nDESCRIPTION: Demonstrates two methods for fetching guard configurations: individual fetching and batch fetching with RPC. Shows how to access specific guard settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchCandyMachine,\n  fetchCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachine = await fetchCandyMachine(umi, candyMachineAddress)\nconst candyGuard = await fetchCandyGuard(umi, candyMachine.mintAuthority)\n\ncandyGuard.guards // All guard settings.\ncandyGuard.guards.botTax // Bot Tax settings.\ncandyGuard.guards.solPayment // Sol Payment settings.\n// ...\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertAccountExists } from '@metaplex-foundation/umi'\nimport {\n  findCandyGuardPda,\n  deserializeCandyMachine,\n  deserializeCandyGuard,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyGuardAddress = findCandyGuardPda(umi, { base: candyMachineAddress })\nconst [rawCandyMachine, rawCandyGuard] = await umi.rpc.getAccounts([\n  candyMachineAddress,\n  candyGuardAddress,\n])\nassertAccountExists(rawCandyMachine)\nassertAccountExists(rawCandyGuard)\n\nconst candyMachine = deserializeCandyMachine(umi, rawCandyMachine)\nconst candyGuard = deserializeCandyGuard(umi, rawCandyGuard)\n```\n\n----------------------------------------\n\nTITLE: Cloning Example Candy Machine Assets Repository (Bash)\nDESCRIPTION: This command clones a GitHub repository containing example images and metadata for Candy Machine projects.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/upload.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/example-candy-machine-assets.git\n```\n\n----------------------------------------\n\nTITLE: Creating Metaplex Local Validator Script\nDESCRIPTION: Bash script to create a custom local validator that includes Metaplex programs, simplifying the process of starting a comprehensive local testing environment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Validator command\nCOMMAND=\"solana-test-validator -r --bpf-program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s ~/.local/share/metaplex-local-validator/mpl-token-metadata.so --bpf-program BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY ~/.local/share/metaplex-local-validator/mpl-bubblegum.so --bpf-program CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d ~/.local/share/metaplex-local-validator/mpl-core.so\"\n\n# Append any additional arguments passed to the script\nfor arg in \"$@\"\ndo\n    COMMAND+=\" $arg\"\ndone\n\n# Execute the command\neval $COMMAND\n```\n\n----------------------------------------\n\nTITLE: Installing Umi Testing Bundle\nDESCRIPTION: Installation commands for Umi testing packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-tests\n```\n\n----------------------------------------\n\nTITLE: Mapping Serializers in TypeScript\nDESCRIPTION: This example demonstrates how to use the mapSerializer function to transform serializers. It shows transforming a string serializer to a number serializer based on string length.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst serializerA: Serializer<string> = ...;\nconst serializerB: Serializer<number> = mapSerializer(\n  serializerA,\n  (value: number): string => 'x'.repeat(value), // Create a mock string of the given length.\n  (value: string): number => value.length, // Get the length of the string.\n);\n```\n\n----------------------------------------\n\nTITLE: Checking if an Asset is Frozen in TypeScript\nDESCRIPTION: This function checks if an asset is frozen. It returns a boolean value based on the provided asset and optional collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nexport function isFrozen(asset: AssetV1, collection?: CollectionV1)\n```\n\n----------------------------------------\n\nTITLE: Update Token Standard and Rule Set\nDESCRIPTION: Shows how to update the token standard and rule set of a Candy Machine, including support for programmable NFTs. Includes handling for both new and legacy account versions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TokenStandard } from '@metaplex-foundation/mpl-token-metadata'\nimport { setTokenStandard } from '@metaplex-foundation/mpl-candy-machine'\n\nawait setTokenStandard(umi, {\n  candyMachine: candyMachine.publicKey,\n  collectionMint: candyMachine.collectionMint,\n  collectionUpdateAuthority,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  ruleSet: newRuleSetAccount,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing Allocation Tracker PDA for Default Guards\nDESCRIPTION: Routes to the Allocation guard to initialize the Allocation Tracker PDA, which counts mints for the default guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allocation.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nroute(umi, {\n  // ...\n  guard: 'allocation',\n  routeArgs: {\n    id: 1,\n    candyGuardAuthority: umi.identity,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Unlocking Funds using Sugar CLI\nDESCRIPTION: Command line interface for unlocking funds from the Freeze Escrow Account using Sugar CLI with various configuration options.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/freeze-sol-payment.md#2025-04-17_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nsugar freeze unlock-funds\n```\n\n----------------------------------------\n\nTITLE: Airdrop List JSON Format for Multiple Recipients\nDESCRIPTION: JSON format for specifying multiple wallet addresses and the number of NFTs each wallet should receive. This file is used with the sugar airdrop command for batch minting to multiple recipients.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/mint-to-another-wallet.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"22222222222222222222222222222222\": 3,\n  \"33333333333333333333333333333333\": 1\n}\n```\n\n----------------------------------------\n\nTITLE: Listing All Candy Machines and Their Funds\nDESCRIPTION: Command to display a list of all Candy Machines and their associated funds linked to the current keypair.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/withdraw.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar withdraw --list\n```\n\n----------------------------------------\n\nTITLE: Installing Required Umi Packages\nDESCRIPTION: Basic npm installation commands for the core Umi packages and web3.js dependency.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @solana/web3.js@1\n```\n\n----------------------------------------\n\nTITLE: Setting Schema Type for AppData Plugin\nDESCRIPTION: Code examples demonstrating how to set the schema type (Binary, Json, or MsgPack) for the AppData plugin\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ExternalPluginAdapterSchema } from '@metaplex-foundation/mpl-core'\n\n// Chose from Binary, Json or MsgPack\nconst schema = ExternalPluginAdapterSchema.Json\n```\n\nLANGUAGE: rust\nCODE:\n```\n// Chose from Binary, Json or MsgPack\nlet schema = ExternalPluginAdapterSchema::Json\n```\n\n----------------------------------------\n\nTITLE: NFT Signing with Custom RPC URL\nDESCRIPTION: Signs NFTs while using a custom RPC endpoint for the operation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/sign.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar sign -r <RPC_URL>\n```\n\n----------------------------------------\n\nTITLE: Updating Attribute Plugin during Unstaking in Metaplex\nDESCRIPTION: Updates the Attribute plugin of the asset with the modified attributes that indicate the asset has been unstaked. This is part of a transaction that includes multiple operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntx = await transactionBuilder().add(updatePlugin(umi, {\n    asset,\n    collection,\n    plugin: {\n        type: \"Attributes\",\n        attributeList: assetAttribute,\n    },\n})).add(\n    [...]\n).add(\n    [...]\n).buildAndSign(umi);\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Plugin Derivation in DAS API\nDESCRIPTION: This snippet demonstrates how to disable automatic plugin derivation by using the skipDerivePlugins parameter when calling DAS API functions. This is useful when you want to control plugin derivation manually.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/plugin-derivation.md#2025-04-17_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nconst assetsByOwner = await das.getAssetsByOwner(umi, {\n  owner: publicKey('<ownerPublicKey>'),\n  skipDerivePlugins: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Withdrawing Funds from Specific Candy Machine\nDESCRIPTION: Command to withdraw funds from a specific Candy Machine using its ID. The ID is obtained from the deploy command output.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/withdraw.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar withdraw --candy-machine <CANDY MACHINE ID>\n```\n\n----------------------------------------\n\nTITLE: Configuring String Serializers in TypeScript\nDESCRIPTION: This snippet shows various configurations for string serializers, including custom encodings and size strategies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Default behaviour: utf8 encoding and u32 (litte-endian) size.\nstring().serialize('Hi'); // -> 0x020000004869\n\n// Custom encoding: base58.\nstring({ encoding: base58 }).serialize('Hi'); // -> 0x0200000003c9\n\n// Custom size: u16 (big-endian) size.\nstring({ size: u16({ endian: Endian.Big }) }).serialize('Hi'); // -> 0x00024869\n\n// Custom size: 5 bytes.\nstring({ size: 5 }).serialize('Hi'); // -> 0x4869000000\n\n// Custom size: variable.\nstring({ size: 'variable' }).serialize('Hi'); // -> 0x4869\n```\n\n----------------------------------------\n\nTITLE: Creating a Distribution List JSON for Gumdrop\nDESCRIPTION: JSON format for specifying which wallet addresses receive token allocations and the amount each recipient should receive. The handle field contains the recipient's wallet address and the amount field specifies the token quantity without decimals.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/spl-token-claim-airdrop-using-gumdrop.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\n        \"handle\": \"8SoWVrwJ6vPa3rcdNBkhznR54yJ6iQqPSmgcXVGnwtEu\",\n        \"amount\": 10000000\n    },\n    {\n        \"handle\": \"GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS\",\n        \"amount\": 5000000\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Converting Instructions from Umi to Web3.js\nDESCRIPTION: TypeScript code demonstrating how to convert instructions from Umi format to Web3.js format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { transferSol } from '@metaplex-foundation/mpl-toolbox';\nimport { toWeb3JsInstruction } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com').use(mplCore())\n\n// Create a new instruction (like a core nft transfer)\nconst umiInstruction = transferSol(umi, {...TransferParams}).getInstructions();\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst web3jsInstruction = umiInstruction.map(toWeb3JsInstruction);\n```\n\n----------------------------------------\n\nTITLE: Decorating Umi Interface Implementations\nDESCRIPTION: Demonstrates decorating existing Umi interface implementations to add extra functionalities through plugins. The example decorates the `rpc` interface and logs all sent transactions to a third-party service.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const myLoggingRpc = (provider: LoggingProvider): UmiPlugin => ({\n  install(umi: Umi) {\n    umi.rpc = new MyLoggingRpc(umi.rpc, provider);\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching NFT Inscription Rank in JavaScript\nDESCRIPTION: Demonstrates how to fetch and read the inscription rank for a specific NFT by accessing the inscription metadata account. Requires the mint public key to find the correct PDA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst inscriptionAccount = await findMintInscriptionPda(umi, {\n  mint: mint.publicKey,\n})\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount,\n})\n\nconst { inscriptionRank } = await fetchInscriptionMetadata(\n  umi,\n  inscriptionMetadataAccount\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Project with npm\nDESCRIPTION: Initial project setup using npm package manager to create a new Node.js project\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Cloning Example NFT Assets Repository\nDESCRIPTION: Git command to clone the example Candy Machine assets repository which contains sample images and metadata for testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/example-candy-machine-assets.git\n```\n\n----------------------------------------\n\nTITLE: Core Asset Update Authority Types in Rust\nDESCRIPTION: This snippet shows the different update authority types for a Core Asset in Rust. It includes Collection, Address, and None variants.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/what-is-an-asset.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nCollection(Pubkey)\nAddress(Pubkey)\nNone\n```\n\n----------------------------------------\n\nTITLE: Cloning Sugar Repository (Bash)\nDESCRIPTION: This command clones the Sugar repository from GitHub to build it from source.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/sugar.git\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Guard Manifest to Plugin in TypeScript\nDESCRIPTION: This TypeScript code adds the custom guard manifest to the Umi plugin, allowing it to be used within the client.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {customGuardManifest} from \"./defaultGuards\"\n\numi.guards.add(\n  ...// add your guard manifest to the list\n  customGuardManifest\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Owner in CreateV1Builder Instruction\nDESCRIPTION: This Rust snippet shows how to set the owner in a CreateV1Builder instruction, with an optional account. It explains that the owner defaults to the authority if not explicitly set, demonstrating the flexibility in instruction preparation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n/// `[optional account]`\n    /// The owner of the new asset. Defaults to the authority if not present.\n    #[inline(always)]\n    pub fn owner(&mut self, owner: Option<solana_program::pubkey::Pubkey>) -> &mut Self {\n        self.owner = owner;\n        self\n    }\n```\n\n----------------------------------------\n\nTITLE: Filling out CreateV1CpiBuilder in Rust\nDESCRIPTION: Shows how to fill out the CreateV1CpiBuilder parameters including asset details and optional accounts for creating a new asset through a CPI call.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1CpiBuilder::new()\n        .asset(context.accounts.asset)\n        .collection(context.accounts.collection)\n        .authority(context.accounts.authority)\n        .payer(context.accounts.payer)\n        .owner(context.accounts.owner)\n        .update_authority(context.accounts.update_authority)\n        .system_program(context.accounts.system_program)\n        .data_state(input.data_state.unwrap_or(DataState::AccountState))\n        .name(args.asset_name)\n        .uri(args.asset_uri)\n        .plugins(args.plugins)\n```\n\n----------------------------------------\n\nTITLE: Converting Plugin Type to Asset Plugin Key in TypeScript\nDESCRIPTION: This function converts a plugin type to a key for asset plugins. It takes a PluginType as input and returns the corresponding AssetPluginKey.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nexport function assetPluginKeyFromType(pluginType: PluginType)\n```\n\n----------------------------------------\n\nTITLE: Configuring Gatekeeper Guard in Sugar\nDESCRIPTION: This snippet shows how to add the Gatekeeper guard configuration to the config.json file when using Sugar CLI. It specifies the gatekeeper network public key and whether tokens expire after use.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/gatekeeper.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"gatekeeper\" : {\n    \"gatekeeperNetwork\": \"<PUBKEY>\",\n    \"expireOnUse\": boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Market Open/Close Margin Check Helper Function in Rust\nDESCRIPTION: This helper function checks if the current time is within 15 minutes of the market opening or closing based on a given Unix timestamp.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn is_within_15_minutes_of_market_open_or_close(unix_timestamp: i64) -> bool {\n    let seconds_since_midnight = unix_timestamp % SECONDS_IN_A_DAY;\n\n    // Check if current time is within 15 minutes after market open or within 15 minutes after market close\n    (seconds_since_midnight >= MARKET_OPEN_TIME && seconds_since_midnight < MARKET_OPEN_TIME + MARKET_OPEN_CLOSE_MARGIN) ||\n    (seconds_since_midnight >= MARKET_CLOSE_TIME && seconds_since_midnight < MARKET_CLOSE_TIME + MARKET_OPEN_CLOSE_MARGIN)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Displaying Collection Details\nDESCRIPTION: Retrieving the created collection's details using the fetchCollection method from mpl-core. This demonstrates how to verify the collection was created correctly by logging its details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchCollection } from '@metaplex-foundation/mpl-core';\n\nconst collection = await fetchCollection(umi, collectionMint.publicKey);\n\nconsole.log(\"Collection Details: \\n\", collection);\n```\n\n----------------------------------------\n\nTITLE: Displaying Candy Machine Configuration with Sugar CLI\nDESCRIPTION: This command displays the onchain configuration of an existing Candy Machine. It requires the Candy Machine ID (Public Key) as an argument, which is obtained from the 'deploy' command output.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/show.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar show <CANDY MACHINE>\n```\n\n----------------------------------------\n\nTITLE: Sending a Transaction Without Waiting for Confirmation\nDESCRIPTION: Demonstrates how to send a transaction without waiting for confirmation, which can be useful for non-blocking operations or when confirmation is handled separately.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/transactions.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst signature = await builder.send(umi)\n```\n\n----------------------------------------\n\nTITLE: Installing Solana CLI on MacOS & Linux\nDESCRIPTION: Command to install Solana CLI tools for local development using the official release script. Targets version 1.18.18 of the Solana toolkit.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsh -c \"$(curl -sSfL https://release.solana.com/v1.18.18/install)\"\n```\n\n----------------------------------------\n\nTITLE: Defining AssetInfo Struct in Rust\nDESCRIPTION: Defines the AssetInfo struct used to represent assets (files) requiring upload in Sugar. It includes fields for asset ID, name, content, data type, and content type.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/bring-your-own-uploader.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct AssetInfo {\n    /// Id of the asset in the cache.\n    pub asset_id: String,\n    /// Name (file name) of the asset.\n    pub name: String,\n    /// Content of the asset - either a file path or the string\n    /// representation of its content.\n    pub content: String,\n    /// Type of the asset.\n    pub data_type: DataType,\n    /// MIME content type.\n    pub content_type: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Token Configuration\nDESCRIPTION: Shows how to set the token mint address for the MPL Hybrid 404 project.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntoken: publicKey(\"11111111111111111111111111111111\")\n```\n\n----------------------------------------\n\nTITLE: Launching Sugar Candy Machine\nDESCRIPTION: Initiates an interactive process to create configuration file and deploy a Candy Machine to Solana blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar launch\n```\n\n----------------------------------------\n\nTITLE: Installing Umi Defaults Bundle\nDESCRIPTION: This command installs the `umi-bundle-defaults` package, which provides default configurations and settings for Umi, making it easier to get started with Solana development.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n\"npm i @metaplex-foundation/umi-bundle-defaults\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Namespace Rule in Token Auth Rules\nDESCRIPTION: Example showing how to configure a Rule Set with Namespace rules to handle different Transfer scenarios. The configuration demonstrates using a common Pass rule for Owner and Authority transfers while implementing a specific AdditionalSigner rule for Delegate transfers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/namespace.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will evaluate the Pass rule under 'Transfer' and be true for both 'Transfer:Owner' and 'Transfer:Authority' but it will only evaluate to true if the additional signer is present for a 'Delegate' transfer.\nconst revision: RuleSetRevisionV2 = JSON.parse({\n  'libVersion': 2,\n  'name': 'My Rule Set',\n  owner,\n  'operations': {\n    'Transfer': {\n      'type': 'Pass',\n    },\n    'Transfer:Owner': {\n      'type': 'Namespace',\n    },\n    'Transfer:Authority': {\n      'type': 'Namespace',\n    },\n    'Transfer:Delegate': {\n      'type': 'AdditionalSigner',\n      'publicKey': publicKey('DhYCi6pvfhJkPRpt5RjYwsE1hZw84iu6twbRt9B6dYLV'),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: DateTime Helper Functions\nDESCRIPTION: Examples of DateTime helper functions for creating and formatting date/time values\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a new DateTime.\ndateTime(1680097346);\ndateTime(new Date(Date.now()));\ndateTime(\"2021-12-31T23:59:59.000Z\");\n\n// Create a new DateTime for the current time.\nnow();\n\n// Format a DateTime.\nformatDateTime(now());\nformatDateTime(now(), 'fr-FR', myFormatOptions);\n```\n\n----------------------------------------\n\nTITLE: Plugin Lifecycle Validation Table - Transfer\nDESCRIPTION: Table showing plugin validation rules for asset transfer lifecycle event\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/index.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Plugin                      | Action      | Conditions  |\n| --------------------------- | ----------- | ----------- |\n| Royalties                   | Can Reject  | Ruleset     |\n| Freeze Delegate             | Can Reject  | isFrozen    |\n| Transfer Delegate           | Can Approve | isAuthority |\n| Permanent Freeze Delegate   | Can Reject  | isFrozen    |\n| Permanent Transfer Delegate | Can Approve | isAuthority |\n```\n\n----------------------------------------\n\nTITLE: Adding Collection Plugin with Default Authority in TypeScript\nDESCRIPTION: Shows how to add a plugin to an MPL Core Collection with default authority settings using TypeScript. Implements the Royalties plugin type.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/adding-plugins.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { addCollectionPlugin, ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst collection = publicKey('11111111111111111111111111111111')\n\nconst creator = publicKey('22222222222222222222222222222222')\n\nawait addCollectionPlugin(umi, {\n  collection: collection,\n  plugin: {\n    type: 'Royalties',\n    data: {\n      basisPoints: 5000,\n      creators: [\n        {\n          address: creator,\n          percentage: 100,\n        },\n      ],\n      ruleSet: ruleSet('None'),\n    },\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Metaplex Core in Rust\nDESCRIPTION: This code snippet shows the necessary imports from the mpl-core crate to implement the staking program using Metaplex Core features in Rust.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::\n    ID as CORE_PROGRAM_ID,\n    fetch_plugin,\n    accounts::{BaseAssetV1, BaseCollectionV1}, \n    instructions::{AddPluginV1CpiBuilder, RemovePluginV1CpiBuilder, UpdatePluginV1CpiBuilder}, \n    types::{Attribute, Attributes, FreezeDelegate, Plugin, PluginAuthority, PluginType, UpdateAuthority}, \n};\n```\n\n----------------------------------------\n\nTITLE: Setting Fee Location\nDESCRIPTION: Demonstrates setting the wallet address for receiving swap fees.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nfeeLocation: publicKey(\"11111111111111111111111111111111\")\n```\n\n----------------------------------------\n\nTITLE: Updating an Existing Candy Guard\nDESCRIPTION: Command to update an existing Candy Guard with new configuration settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nsugar guard update\n```\n\n----------------------------------------\n\nTITLE: Creator Hash Implementation in Rust\nDESCRIPTION: Reference to the creator hash implementation in the Bubblegum program that handles NFT creator information.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/concurrent-merkle-trees.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlib.rs#L433\n```\n\n----------------------------------------\n\nTITLE: Creating Flow Diagram for Core Candy Machine External Services\nDESCRIPTION: A diagram showing the interaction flow between Core Candy Machine, Candy Guard, Gatekeeper Network, and the minting process. It visualizes how external services integrate with the minting pipeline and token generation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/mint.md#2025-04-17_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n{% diagram %}\n\n{% node %}\n{% node #candy-machine-1 label=\"Core Candy Machine\" theme=\"blue\" /%}\n{% node label=\"Owner: Core Candy Machine Core Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node parent=\"candy-machine-1\" y=80 x=20 %}\n{% node #candy-guard-1 label=\"Candy Guard\" theme=\"blue\" /%}\n{% node label=\"Owner: Candy Guard Program\" theme=\"dimmed\" /%}\n{% node label=\"Guards\" theme=\"mint\" z=1 /%}\n{% node #gatekeeper-guard label=\"Gatekeeper\" /%}\n{% node label=\"...\" /%}\n{% /node %}\n\n{% node parent=\"candy-machine-1\" x=550 %}\n{% node #mint-1 label=\"Mint\" theme=\"pink\" /%}\n{% node label=\"Candy Guard Program\" theme=\"pink\" /%}\n{% /node %}\n{% node parent=\"mint-1\" x=45 y=-20 label=\"Access Control\" theme=\"transparent\" /%}\n\n{% node parent=\"mint-1\" x=-22 y=100 %}\n{% node #mint-2 label=\"Mint\" theme=\"pink\" /%}\n{% node label=\"Core Candy Machine Core Program\" theme=\"pink\" /%}\n{% /node %}\n{% node parent=\"mint-2\" x=120 y=-20 label=\"Mint Logic\" theme=\"transparent\" /%}\n\n{% node #nft parent=\"mint-2\" x=62 y=100 label=\"NFT\" /%}\n\n{% node parent=\"mint-2\" x=-250 y=-40 %}\n{% node #network label=\"Gatekeeper Network\" theme=\"slate\" /%}\n{% node theme=\"slate\" %}\nRequest Gateway Token \\\nfrom the Gatekeeper \\\nNetwork, e.g. Captcha.\n{% /node %}\n{% /node %}\n\n{% node #gateway-token parent=\"network\" x=23 y=140 label=\"Gateway Token\" /%}\n\n{% edge from=\"candy-guard-1\" to=\"candy-machine-1\" fromPosition=\"left\" toPosition=\"left\" arrow=false /%}\n{% edge from=\"mint-1\" to=\"mint-2\" theme=\"pink\" path=\"straight\" /%}\n{% edge from=\"mint-2\" to=\"nft\" theme=\"pink\" path=\"straight\" /%}\n{% edge from=\"candy-machine-1\" to=\"mint-1\" theme=\"pink\" /%}\n{% edge from=\"gatekeeper-guard\" to=\"network\" theme=\"slate\" /%}\n{% edge from=\"network\" to=\"gateway-token\" theme=\"slate\" path=\"straight\" /%}\n{% edge from=\"gateway-token\" to=\"mint-1\" theme=\"pink\" /%}\n\n{% /diagram %}\n```\n\n----------------------------------------\n\nTITLE: Configuring Shankjs with Anchor 27 Fallback in JavaScript\nDESCRIPTION: This configuration for Shankjs includes a fallback to Anchor 27 due to a missing crates.io crate in Anchor 28. It's necessary when generating using Anchor 28.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ngenerateIdl({\n  generator: \"anchor\",\n  programName: \"candy_guard\",\n  programId: \"Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g\", // Your custom Candy Guard deployed program key.\n  idlDir,\n  binaryInstallDir,\n  programDir: path.join(programDir, \"candy-guard\", \"program\"),\n  rustbin: {\n    locked: true,\n    versionRangeFallback: \"0.27.0\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Converting Asset Plugin Key to Plugin Type in TypeScript\nDESCRIPTION: This function converts an asset plugin key to its corresponding plugin type. It takes an AssetPluginKey as input and returns the PluginType.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport function pluginTypeFromAssetPluginKey(key: AssetPluginKey)\n```\n\n----------------------------------------\n\nTITLE: Creating Transactions in Web3.js\nDESCRIPTION: TypeScript code showing how to create both Legacy and Versioned Transactions using Solana Web3.js.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Transaction, VersionedTransaction, TransactionMessage, Connection, clusterApiUrl, SystemProgram } from '@solana/web3.js';\n\n// Create a new Web3Js Legacy Transaction\nconst web3jsTransaction = new Transaction().add(SystemProgram.transfer({...TransferParams}));\n\n// Create a new Web3Js Versioned Transaction\nconst instructions = [SystemProgram.transfer({...TransferParams})];\n\nconst connection = new Connection(clusterApiUrl(\"devnet\"));\nconst blockhash = await connection.getLatestBlockhash().then(res => res.blockhash);\n\nconst messageV0 = new TransactionMessage({\n  payerKey: payer.publicKey,\n  recentBlockhash: blockhash,\n  instructions,\n}).compileToV0Message();\n\nconst web3jsVersionedTransaction = new VersionedTransaction(messageV0);\n```\n\n----------------------------------------\n\nTITLE: TransferV1Cpi Structure for On-chain Instructions\nDESCRIPTION: Defines the TransferV1Cpi struct that encapsulates the necessary information to perform a Cross Program Invocation (CPI) for transferring tokens. It includes references to AccountInfo for all relevant accounts and the arguments for the instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct TransferV1Cpi<'a> {\n    /// The program to invoke.\n    pub __program: &'a AccountInfo<'a>,\n\n    /// Token account\n    pub token: &'a AccountInfo<'a>,\n\n    /// Token account owner\n    pub token_owner: &'a AccountInfo<'a>,\n\n    /// Destination token account\n    pub destination_token: &'a AccountInfo<'a>,\n\n    /// Destination token account owner\n    pub destination_owner: &'a AccountInfo<'a>,\n\n    /// Mint of token asset\n    pub mint: &'a AccountInfo<'a>,\n\n    /// Metadata (pda of ['metadata', program id, mint id])\n    pub metadata: &'a AccountInfo<'a>,\n\n    /// Edition of token asset\n    pub edition: Option<&'a AccountInfo<'a>>,\n\n    /// Owner token record account\n    pub token_record: Option<&'a AccountInfo<'a>>,\n\n    /// Destination token record account\n    pub destination_token_record: Option<&'a AccountInfo<'a>>,\n\n    /// Transfer authority (token owner or delegate)\n    pub authority: &'a AccountInfo<'a>,\n\n    /// Payer\n    pub payer: &'a AccountInfo<'a>,\n\n    /// System Program\n    pub system_program: &'a AccountInfo<'a>,\n\n    /// Instructions sysvar account\n    pub sysvar_instructions: &'a AccountInfo<'a>,\n\n    /// SPL Token Program\n    pub spl_token_program: &'a AccountInfo<'a>,\n\n    /// SPL Associated Token Account program\n    pub spl_ata_program: &'a AccountInfo<'a>,\n\n    /// Token Authorization Rules Program\n    pub authorization_rules_program: Option<&'a AccountInfo<'a>>,\n\n    /// Token Authorization Rules account\n    pub authorization_rules: Option<&'a AccountInfo<'a>>,\n\n    /// The arguments for the instruction.\n    pub __args: TransferV1InstructionArgs,\n}\n```\n\n----------------------------------------\n\nTITLE: Scalar Enum Serialization in TypeScript\nDESCRIPTION: Implementation of scalar enum serialization with various input types and custom size options\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction { Left, Right, Up, Down };\n\nconst directionSerializer = scalarEnum(Direction); // Serializer<Direction>\ndirectionSerializer.serialize(Direction.Left); // -> 0x00\ndirectionSerializer.serialize(Direction.Right); // -> 0x01\ndirectionSerializer.serialize('Left'); // -> 0x00\ndirectionSerializer.serialize('Right'); // -> 0x01\ndirectionSerializer.serialize(0); // -> 0x00\ndirectionSerializer.serialize(1); // -> 0x01\n\n// The deserialized value is always an instance of the enum.\ndirectionSerializer.deserialize(new Uint8Array([1])); // -> [Direction.Right, 1]\n```\n\nLANGUAGE: typescript\nCODE:\n```\nscalarEnum(Direction, { size: u32() }).serialize(Direction.Right); // -> 0x01000000\n```\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction { Left = 'LEFT', Right = 'RIGHT', Up = 'UP', Down = 'DOWN' };\n\nconst directionSerializer = scalarEnum(Direction); // Serializer<Direction>\ndirectionSerializer.serialize(Direction.Left); // -> 0x00\ndirectionSerializer.serialize('Left'); // -> 0x00\n\n// Note that the enum string value can be used as input.\ndirectionSerializer.serialize('LEFT'); // -> 0x00\n```\n\n----------------------------------------\n\nTITLE: Configuring Address Gate Guard in Sugar Config JSON\nDESCRIPTION: This snippet shows how to configure the Address Gate guard in the Sugar CLI config.json file. The guard requires specifying the public key address that will be allowed to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/address-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"addressGate\" : {\n    \"address\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Umi Plugins in TypeScript\nDESCRIPTION: Defines a basic plugin with an `install` function to extend the Umi instance's functionality. The install function enables interaction with and modification of the Umi instance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const myPlugin: UmiPlugin = {\n  install(umi: Umi) {\n    // Do something with the Umi instance.\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Converting PublicKey from Web3.js to Umi\nDESCRIPTION: TypeScript code demonstrating how to convert a PublicKey from Web3.js format to Umi format using the umi-web3js-adapters package.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from '@solana/web3.js';\nimport { fromWeb3JsPublicKey } from '@metaplex-foundation/umi-web3js-adapters';\n\n// Generate a new Publickey\nconst web3jsPublickey = new PublicKey(\"1111111111111111111111111111111111111111\");\n\n// Convert it using the UmiWeb3jsAdapters Package\nconst umiPublicKey = fromWeb3JsPublicKey(web3jsPublickey);\n```\n\n----------------------------------------\n\nTITLE: Viewing Solana CLI Configuration\nDESCRIPTION: Displays current Solana CLI configuration settings including RPC URL and keypair path.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsolana config get\n```\n\n----------------------------------------\n\nTITLE: Configuring CreateV1 CPI Builder\nDESCRIPTION: Example of configuring accounts and data fields for a CreateV1 CPI call.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1CpiBuilder::new()\n        .asset(context.accounts,asset)\n        .collection(context.accounts.collection)\n        .authority(context.accounts.authority)\n        .payer(context.accounts.payer)\n        .owner(context.accounts.owner)\n        .update_authority(context.accounts.update_authority)\n        .system_program(context.accounts.system_program)\n        .data_state(input.data_state.unwrap_or(DataState::AccountState))\n        .name(args.asset_name)\n        .uri(arts.asset_uri)\n        .plugins(args.plugins)\n```\n\n----------------------------------------\n\nTITLE: Selecting Assets for Release in MPL-404 Hybrid Escrow using JavaScript\nDESCRIPTION: This snippet shows how to select a random asset owned by the user for the Release operation in the MPL-404 Hybrid Escrow. It fetches assets by collection and filters for those owned by the user.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\n// Fetch all the assets in the collection\nconst assetsListByCollection = await fetchAssetsByCollection(umi, collection, {\n    skipDerivePlugins: false,\n})\n\n// Usually the user choose what to exchange\nconst asset = assetsListByCollection.filter(\n    (a) => a.owner === umi.identity.publicKey\n)[0].publicKey\n```\n\n----------------------------------------\n\nTITLE: Updating Existing Candy Machine Configuration\nDESCRIPTION: This command updates the Candy Machine account with changes made to the configuration file after the Candy Machine has been deployed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/config.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar config update\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Asset by Metadata\nDESCRIPTION: Helper function to fetch a Digital Asset using its Metadata account public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchDigitalAssetByMetadata } from '@metaplex-foundation/mpl-token-metadata'\n\nconst asset = await fetchDigitalAssetByMetadata(umi, metadata)\n```\n\n----------------------------------------\n\nTITLE: Closing Inscription Account with Metaplex SDK - TypeScript\nDESCRIPTION: This code snippet demonstrates how to close an inscription account using the Metaplex SDK. It imports necessary functions, retrieves the inscription metadata PDA for the given inscription account, and then calls the close function to close the account. The prerequisite for executing this code is to have the correct authority and to ensure that there are no associated inscriptions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/close.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { close, findInscriptionMetadataPda } from '@metaplex-foundation/mpl-inscription';\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nawait close(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n  inscriptionMetadataAccount,\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Core Candy Machine with Redeemed Amount Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Core Candy Machine with a Redeemed Amount guard, limiting the total number of mintable items to 300 out of 500 available items.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/redeemed-amount.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  itemsAvailable: 500,\n  guards: {\n    redeemedAmount: some({ maximum: 300 }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Metaplex DAS API Package\nDESCRIPTION: NPM command to install the Metaplex Digital Asset Standard API package\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @metaplex-foundation/digital-asset-standard-api\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Program Owned Rule in Token Auth Rules\nDESCRIPTION: Demonstrates how to create a rule set that verifies if a PDA account is owned by a specific program. Uses RuleSetRevisionV2 to define ownership verification for an escrow account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/program-owned.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    list: {\n      type: 'ProgramOwned',\n      field: 'Escrow',\n      program: publicKey('TSWAPaqyCSx2KABk68Shruf4rp7CxcNi8hAsbdwmHbN'),\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Inscription Metadata with JavaScript\nDESCRIPTION: Retrieve inscription metadata using the safeFetchInscriptionMetadataFromSeeds function from the Metaplex Inscription library. Allows fetching details like inscriptionRank, associatedInscriptions, and updateAuthorities.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/fetch.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { safeFetchInscriptionMetadataFromSeeds } from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionMetadataAccount = await safeFetchInscriptionMetadataFromSeeds(\n  umi,\n  {\n    inscriptionAccount: inscriptionAccount.publicKey,\n  }\n)\n\nconsole.log(inscriptionMetadataAccount)\n```\n\n----------------------------------------\n\nTITLE: Rust Module Imports for Ticketing Platform\nDESCRIPTION: Lists all necessary imports from anchor_lang and mpl_core for implementing the ticketing system.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\nuse mpl_core::{\n    ID as MPL_CORE_ID,\n    fetch_external_plugin_adapter_data_info, \n    fetch_plugin, \n    instructions::{\n        CreateCollectionV2CpiBuilder, \n        CreateV2CpiBuilder, \n        WriteExternalPluginAdapterDataV1CpiBuilder, \n        UpdatePluginV1CpiBuilder\n    }, \n    accounts::{BaseAssetV1, BaseCollectionV1}, \n    types::{\n        AppDataInitInfo, Attribute, Attributes, \n        ExternalPluginAdapterInitInfo, ExternalPluginAdapterKey, \n        ExternalPluginAdapterSchema, PermanentBurnDelegate, UpdateAuthority,\n        PermanentFreezeDelegate, PermanentTransferDelegate, Plugin, \n        PluginAuthority, PluginAuthorityPair, PluginType\n    }, \n};\n```\n\n----------------------------------------\n\nTITLE: Listing Amman CLI Commands and Options\nDESCRIPTION: This snippet shows the available Amman CLI commands and their descriptions, along with general options for the Amman tool.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/cli-commands.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\namman [command]\n\nCommands:\n  amman start    Launches a solana-test-validator and the amman relay and/or\n                 mock storage if so configured\n  amman stop     Stops the relay and storage and kills the running solana\n                 test validator\n  amman logs     Launches 'solana logs' and pipes them through a prettifier\n  amman airdrop  Airdrops provided Sol to the payer\n  amman label    Adds labels for accounts or transactions to amman\n  amman account  Retrieves account information for a PublicKey or a label or\n                 shows all labeled accounts\n  amman run      Executes the provided command after expanding all address\n                 labels\n\nOptions:\n  --help     Show help                                                 [boolean]\n  --version  Show version number                                       [boolean]\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with New Wallet\nDESCRIPTION: Setting up Umi instance with a new generated wallet and airdrop functionality for testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\nconst signer = generateSigner(umi)\n\numi.use(signerIdentity(signer))\n\n// This will airdrop SOL on devnet only for testing.\nconsole.log('Airdropping 1 SOL to identity')\nawait umi.rpc.airdrop(umi.identity.publickey)\n```\n\n----------------------------------------\n\nTITLE: Basic NFT Signing with Default Keypair\nDESCRIPTION: Signs all NFTs using the default creator keypair from Solana CLI config.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/sign.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar sign\n```\n\n----------------------------------------\n\nTITLE: Configuring Allow List in Sugar JSON\nDESCRIPTION: This JSON snippet demonstrates how to configure the Allow List guard in a Sugar config file. It requires pre-computing the Merkle root hash.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allow-list.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"allowList\" : {\n    \"merkleRoot\": \"<HASH>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Inscribe NFTs - Bash\nDESCRIPTION: Inscribes the NFTs using the specified RPC URL, keypair file, and hashlist file. This is the main command to perform NFT inscription.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npnpm cli inscribe hashlist -r <RPC_URL> -k <KEYPAIR_FILE> -h <HASHLIST_FILE>\n```\n\n----------------------------------------\n\nTITLE: Importing Metaplex Core Types in Rust\nDESCRIPTION: This snippet shows how to import necessary types from the Metaplex Core library for creating collections with plugins.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::\n    Plugin, FreezeDelegate, PluginAuthority,\n    ExternalPluginAdapterInitInfo, AppDataInitInfo, \n    ExternalPluginAdapterSchema;\n```\n\n----------------------------------------\n\nTITLE: Diagramming NFT Structure with Master Edition in Solana\nDESCRIPTION: This snippet provides a diagram illustrating the relationships and structures of various Solana accounts involved with NFTs, including Wallet, Token, Mint, Metadata, and Master Edition accounts. Dependencies include Solana blockchain knowledge and familiarity with token management systems.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/index.md#2025-04-17_snippet_2\n\nLANGUAGE: Diagram\nCODE:\n```\n{% diagram %}\n{% node %}\n{% node #wallet label=\"Wallet Account\" theme=\"indigo\" /%}\n{% node label=\"Owner: System Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"wallet\" %}\n{% node #token label=\"Token Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node label=\"Amount = 1\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"token\" %}\n{% node #mint label=\"Mint Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node label=\"Mint Authority = None\" /%}\n{% node label=\"Supply = 1\" /%}\n{% node label=\"Decimals = 0\" /%}\n{% /node %}\n\n{% node #metadata-pda parent=\"mint\" x=\"41\" y=\"-80\" label=\"PDA\" theme=\"crimson\" /%}\n\n{% node parent=\"metadata-pda\" x=\"-240\" %}\n{% node #metadata label=\"Metadata Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token Metadata Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% edge from=\"wallet\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"metadata-pda\" path=\"straight\" /%}\n{% edge from=\"metadata-pda\" to=\"metadata\" path=\"straight\" /%}\n{% /diagram %}\n```\n\nLANGUAGE: Diagram\nCODE:\n```\n{% diagram %}\n{% node %}\n{% node #wallet label=\"Wallet Account\" theme=\"indigo\" /%}\n{% node label=\"Owner: System Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"wallet\" %}\n{% node #token label=\"Token Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node label=\"Amount = 1\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"token\" %}\n{% node #mint label=\"Mint Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node #mint-authority label=\"Mint Authority = Edition\" /%}\n{% node label=\"Supply = 1\" /%}\n{% node label=\"Decimals = 0\" /%}\n{% node #freeze-authority label=\"Freeze Authority = Edition\" /%}\n{% /node %}\n\n{% node #metadata-pda parent=\"mint\" x=\"-10\" y=\"-80\" label=\"PDA\" theme=\"crimson\" /%}\n\n{% node parent=\"metadata-pda\" x=\"-240\" %}\n{% node #metadata label=\"Metadata Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token Metadata Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node #master-edition-pda parent=\"mint\" x=\"-10\" y=\"-220\" label=\"PDA\" theme=\"crimson\" /%}\n\n{% node parent=\"master-edition-pda\" x=\"-240\" %}\n{% node #master-edition label=\"Master Edition Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token Metadata Program\" theme=\"dimmed\" /%}\n{% node label=\"Key = MasterEditionV2\" /%}\n{% node label=\"Supply\" /%}\n{% node label=\"Max Supply\" /%}\n{% /node %}\n\n{% edge from=\"wallet\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"metadata-pda\" /%}\n{% edge from=\"mint\" to=\"master-edition-pda\" /%}\n{% edge from=\"metadata-pda\" to=\"metadata\" path=\"straight\" /%}\n{% edge from=\"master-edition-pda\" to=\"master-edition\" path=\"straight\" /%}\n{% edge from=\"mint-authority\" to=\"master-edition-pda\" dashed=true arrow=\"none\" fromPosition=\"right\" toPosition=\"right\" animated=true /%}\n{% edge from=\"freeze-authority\" to=\"master-edition-pda\" dashed=true arrow=\"none\" fromPosition=\"right\" toPosition=\"right\" animated=true /%}\n{% /diagram %}\n```\n\nLANGUAGE: Diagram\nCODE:\n```\n{% diagram %}\n{% node %}\n{% node #wallet label=\"Wallet Account\" theme=\"indigo\" /%}\n{% node label=\"Owner: System Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"wallet\" %}\n{% node #token label=\"Token Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node label=\"Amount = 1\" /%}\n{% /node %}\n\n{% node x=\"200\" parent=\"token\" %}\n{% node #mint label=\"Mint Account\" theme=\"blue\" /%}\n{% node label=\"Owner: Token Program\" theme=\"dimmed\" /%}\n{% node #mint-authority label=\"Mint Authority = Edition\" /%}\n{% node label=\"Supply = 1\" /%}\n{% node label=\"Decimals = 0\" /%}\n{% node #freeze-authority label=\"Freeze Authority = Edition\" /%}\n{% /node %}\n\n{% node #metadata-pda parent=\"mint\" x=\"-10\" y=\"-80\" label=\"PDA\" theme=\"crimson\" /%}\n\n{% node parent=\"metadata-pda\" x=\"-280\" %}\n{% node #metadata label=\"Metadata Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token Metadata Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node #master-edition-pda parent=\"mint\" x=\"-10\" y=\"-160\" label=\"PDA\" theme=\"crimson\" /%}\n\n{% node parent=\"master-edition-pda\" x=\"-280\" %}\n{% node #master-edition label=\"Master Edition Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token edition Program\" theme=\"dimmed\" /%}\n{% /node %}\n\n{% node parent=\"master-edition\" y=\"-140\" %}\n{% node #edition label=\"Edition Account\" theme=\"crimson\" /%}\n{% node label=\"Owner: Token edition Program\" theme=\"dimmed\" /%}\n{% node label=\"Key = EditionV1\" /%}\n{% node #edition-parent label=\"Parent\" /%}\n{% node label=\"Edition\" /%}\n{% /node %}\n\n{% edge from=\"wallet\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"token\" /%}\n{% edge from=\"mint\" to=\"metadata-pda\" /%}\n{% edge from=\"mint\" to=\"master-edition-pda\" /%}\n{% edge from=\"metadata-pda\" to=\"metadata\" path=\"straight\" /%}\n{% edge from=\"master-edition-pda\" to=\"master-edition\" path=\"straight\" /%}\n{% edge from=\"master-edition-pda\" to=\"edition\" fromPosition=\"left\" label=\"OR\" /%}\n{% edge from=\"mint-authority\" to=\"master-edition-pda\" dashed=true arrow=\"none\" fromPosition=\"right\" toPosition=\"right\" /%}\n{% edge from=\"freeze-authority\" to=\"master-edition-pda\" dashed=true arrow=\"none\" fromPosition=\"right\" toPosition=\"right\" /%}\n{% edge from=\"edition-parent\" to=\"master-edition\" dashed=true arrow=\"none\" fromPosition=\"left\" toPosition=\"left\" /%}\n{% /diagram %}\n```\n\n----------------------------------------\n\nTITLE: Download NFT Assets - Bash\nDESCRIPTION: Downloads NFT assets including JSON and media files into a cache folder. Additional files can be manually replaced in the cache directory if necessary. The command requires RPC URL, keypair file, and hashlist file as parameters.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm cli download hashlist -r <RPC_URL> -k <KEYPAIR_FILE> -h <HASHLIST_FILE>\n```\n\n----------------------------------------\n\nTITLE: Configuring Sol Payment Guard in Sugar CLI Config\nDESCRIPTION: JSON configuration for the Sol Payment guard in Sugar CLI's config.json file, setting a value of 1 SOL and specifying a destination wallet address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/sol-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"solPayment\": {\n    \"value\": 1,\n    \"destination\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bot Tax Guard with Sugar CLI\nDESCRIPTION: JSON configuration for the Bot Tax guard in a Sugar config.json file. It requires specifying the SOL value to charge and a boolean for the lastInstruction setting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/bot-tax.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"botTax\" : {\n    \"value\": SOL value,\n    \"lastInstruction\": boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Instructions in Web3.js\nDESCRIPTION: TypeScript code showing how to create instructions using Solana Web3.js, specifically for a SOL transfer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SystemProgram } from '@solana/web3.js';\n\n// Create a new instruction (like a lamport transfer)\nconst web3jsInstruction = SystemProgram.transfer({...TransferParams})\n```\n\n----------------------------------------\n\nTITLE: Generating a New Wallet with Umi\nDESCRIPTION: Creates a new Umi instance with a generated signer and sets up the blockchain connection\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n\t.use(mplTokenMetadata())\n\t.use(mplToolbox());\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi);\n\n// Tell umi to use the new signer.\numi.use(signerIdentity(signer));\n\n// Airdrop 2 SOL to the identity\n// if you end up with a 429 too many requests error, you may have to use\n// the a different rpc other than the free default one supplied.\nawait umi.rpc.airdrop(umi.identity.publicKey, sol(2));\n```\n\n----------------------------------------\n\nTITLE: Thawing an MPL Core Asset in JavaScript\nDESCRIPTION: This snippet demonstrates how to thaw a frozen asset using the MPL Core library in JavaScript. It imports necessary functions, fetches the asset account, and uses the thawAsset function to unfreeze the asset.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/freeze-delegate.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { thawAsset, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst assetAddress = publicKey('11111111111111111111111111111111')\nconst assetAccount = await fetchAsset(umi, assetAddress)\n\nconst delegateSigner = generateSigner(umi)\n\nawait thawAsset(umi, {\n  asset: assetAccount,\n  delegate: delegateSigner,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages via NPM\nDESCRIPTION: Installs the necessary packages to use the Metaplex Umi client and MPL Toolbox. Dependencies required include '@metaplex-foundation/umi', '@metaplex-foundation/umi-bundle-defaults', and '@metaplex-foundation/mpl-toolbox'. Ensure Node 18.x.x or above is installed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-spl-tokens-on-solana.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"npm i @metaplex-foundation/umi\"\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"npm i @metaplex-foundation/umi-bundle-defaults\"\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"npm i @metaplex-foundation/mpl-toolbox;\"\n```\n\n----------------------------------------\n\nTITLE: Defining Token Swap Settings and addZeros Function in JavaScript\nDESCRIPTION: This snippet defines the token-related parameters for the escrow, including token decimals, amount, fee amount, and SOL fee amount. It also includes a helper function, `addZeros()`, to adjust token amounts for decimals.  This function is crucial for ensuring accurate token amounts are used during the swap process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n\"// Token Swap Settings - Change these to your needs\nconst tokenDecimals = 6;                                    \nconst amount = addZeros(100, tokenDecimals);                \nconst feeAmount = addZeros(1, tokenDecimals);               \nconst solFeeAmount = addZeros(0, 9);                       \n\n// Function that adds zeros to a number, needed for adding the correct amount of decimals\nfunction addZeros(num: number, numZeros: number): number {\n  return num * Math.pow(10, numZeros)\n}\"\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Setting Up Umi for MPL Core Candy Machine\nDESCRIPTION: This snippet imports necessary functions from MPL Core and Candy Machine libraries, and sets up the Umi instance with RPC and wallet configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/print-editions.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  create,\n  mplCandyMachine,\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport { \n    createCollection, \n    ruleSet \n} from \"@metaplex-foundation/mpl-core\";\nimport crypto from \"crypto\";\nimport {\n  generateSigner,\n  keypairIdentity,\n} from \"@metaplex-foundation/umi\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi(\"http://127.0.0.1:8899\").use(mplCandyMachine());\n\n// use your keypair or Wallet Adapter here.\nconst keypair = generateSigner(umi);\numi.use(keypairIdentity(keypair));\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Interface in Umi Plugins\nDESCRIPTION: Illustrates setting a custom interface implementation through a plugin on Umi. This example sets a fictional `MyRpc` implementation to the `rpc` interface and shows passing the Umi instance to ensure reliance on other interfaces when needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/plugins.md#2025-04-17_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const myRpc = (endpoint: string): UmiPlugin => ({\n  install(umi: Umi) {\n    umi.rpc = new MyRpc(umi, endpoint);\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Fetching NFTs by Owner\nDESCRIPTION: RPC call to fetch all compressed NFTs owned by a specific address\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcAssetList = await umi.rpc.getAssetsByOwner({ owner })\n```\n\n----------------------------------------\n\nTITLE: Token Metadata Account Size Comparison Table\nDESCRIPTION: Table showing the size reduction in bytes for different types of Token Metadata accounts after the update.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/account-size-reduction.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Account           | Size (bytes) | New Size (bytes) |\n| ----------------- | ------------ | ---------------- |\n| Metadata          | 679          | 607              |\n| Master Edition v1 | 282          | 20               |\n| Master Edition v2 | 282          | 20               |\n| Edition           | 241          | 42               |\n```\n\n----------------------------------------\n\nTITLE: Checking Staking Attributes\nDESCRIPTION: Verifies if the asset has the required staking attributes initialized.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n} else {\n    const assetAttribute = fetchedAsset.attributes.attributeList;\n    const isInitialized = assetAttribute.some(\n        (attribute) => attribute.key === \"staked\" || attribute.key === \"stakedTime\"\n    );\n```\n\n----------------------------------------\n\nTITLE: Adding Guards to Candy Machine\nDESCRIPTION: Command to add configured guards to a Candy Machine. After execution, the mint command will no longer work directly as the mint authority transfers to the Candy Guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/guard.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar guard add\n```\n\n----------------------------------------\n\nTITLE: RpcAccount Type Definition in TypeScript\nDESCRIPTION: Defines the structure of an RpcAccount containing account header information, public key, and serialized data.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype RpcAccount = AccountHeader & {\n  publicKey: PublicKey;\n  data: Uint8Array;\n};\n```\n\n----------------------------------------\n\nTITLE: MaybeRpcAccount Type Definition in TypeScript\nDESCRIPTION: Defines a union type representing an account that may or may not exist, maintaining the public key reference in both cases.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype MaybeRpcAccount =\n  | ({ exists: true } & RpcAccount)\n  | { exists: false; publicKey: PublicKey };\n```\n\n----------------------------------------\n\nTITLE: Implementing CreateOracle Account Structure in Rust\nDESCRIPTION: Defines the account structure for initializing an Oracle account with necessary signers, reward vault, and system program dependencies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct CreateOracle<'info> {\n    pub signer: Signer<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(\n        init,\n        payer = payer,\n        space = Oracle::INIT_SPACE,\n        seeds = [b\"oracle\"],\n        bump\n    )]\n    pub oracle: Account<'info, Oracle>,\n    #[account(\n        seeds = [b\"reward_vault\", oracle.key().as_ref()],\n        bump,\n    )]\n    pub reward_vault: SystemAccount<'info>,\n    pub system_program: Program<'info, System>,\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Fanout Client in TypeScript\nDESCRIPTION: This snippet initializes the FanoutClient with a connection to the Solana devnet and the authority wallet. It sets up the fanout client for managing a Hydra wallet and shares distribution.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst connection = new Connection('devnet', 'confirmed')\nlet fanoutSdk: FanoutClient\n\nauthorityWallet = Keypair.generate()\n\nfanoutSdk = new FanoutClient(\n  connection,\n  new NodeWallet(new Account(authorityWallet.secretKey))\n)\n\nconst init = await fanoutSdk.initializeFanout({\n  totalShares: 100,\n  name: `Test${Date.now()}`,\n  membershipModel: MembershipModel.Wallet,\n})\n```\n\n----------------------------------------\n\nTITLE: Markdown Quick Links Template for Candy Machine\nDESCRIPTION: Template code showing quick navigation links to different implementation options for Candy Machine - JavaScript (Umi framework), Rust, and Sugar CLI tool.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/getting-started/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% quick-links %}\n\n{% quick-link title=\"JavaScript\" icon=\"JavaScript\" href=\"/candy-machine/getting-started/js\" description=\"Get started with our JavaScript library based on the Umi framework.\" /%}\n\n{% quick-link title=\"Rust\" icon=\"Rust\" href=\"/candy-machine/getting-started/rust\" description=\"Get started using our Rust crate.\" /%}\n\n{% quick-link title=\"Sugar\" icon=\"SolidCommandLine\" href=\"/candy-machine/sugar/getting-started\" description=\"Get started using the command-line tool Sugar.\" /%}\n\n{% /quick-links %}\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet DenyList in Rust for Royalties Plugin\nDESCRIPTION: This snippet shows how to create a RuleSet DenyList in Rust for the Royalties Plugin. It defines a vector of program public keys that are not allowed to interact with the MPL Core Asset/Collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::RuleSet;\nuse solana_sdk::pubkey::Pubkey\nuse std::str::FromStr;\n\nlet rule_set = RuleSet::ProgramDenyList(\n    vec![\n        Pubkey::from_str(\"11111111111111111111111111111111\").unwrap(),\n        Pubkey::from_str(\"22222222222222222222222222222222\").unwrap()\n    ]\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing NPM Project\nDESCRIPTION: Basic npm project initialization command to set up a new project.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Cloning the Inscriptions Repository - Bash\nDESCRIPTION: Clones the repository containing the Inscriptions CLI, which is necessary for proceeding with any CLI operations. This command requires Git to be installed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/mpl-inscription.git\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi with New Wallet\nDESCRIPTION: Setup Umi instance with a newly generated signer\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// Tell Umi to use the new signer.\numi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Complete Unstake Instruction Implementation in Rust\nDESCRIPTION: This code presents the full implementation of the unstake instruction for NFTs. It includes attribute checks, updating staking status, thawing the asset, and removing the FreezeDelegate plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\npub fn unstake(ctx: Context<Unstake>) -> Result<()> {\n    // Check if the asset has the attribute plugin already on\n    match fetch_plugin::<BaseAssetV1, Attributes>(&ctx.accounts.asset.to_account_info(), mpl_core::types::PluginType::Attributes) {\n        Ok((_, fetched_attribute_list, _)) => {\n            let mut attribute_list: Vec<Attribute> = Vec::new();\n            let mut is_initialized: bool = false;\n            let mut staked_time: i64 = 0;\n\n            for attribute in fetched_attribute_list.attribute_list.iter() {\n                if attribute.key == \"staked\" {\n                    require!(attribute.value != \"0\", StakingError::NotStaked);\n                    attribute_list.push(Attribute { \n                        key: \"staked\".to_string(), \n                        value: 0.to_string() \n                    });\n                    staked_time = staked_time\n                        .checked_add(Clock::get()?.unix_timestamp\n                        .checked_sub(attribute.value.parse::<i64>()\n                        .map_err(|_| StakingError::InvalidTimestamp)?)\n                        .ok_or(StakingError::Underflow)?)\n                        .ok_or(StakingError::Overflow)?;\n                    is_initialized = true;\n                } else if attribute.key == \"staked_time\" {\n                    staked_time = staked_time\n                        .checked_add(attribute.value.parse::<i64>()\n                        .map_err(|_| StakingError::InvalidTimestamp)?)\n                        .ok_or(StakingError::Overflow)?;\n                } else {\n                    attribute_list.push(attribute.clone());\n                } \n            }\n\n            attribute_list.push(Attribute { \n                key: \"staked_time\".to_string(), \n                value: staked_time.to_string() \n            });\n\n            require!(is_initialized, StakingError::StakingNotInitialized);\n\n\n            UpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n            .asset(&ctx.accounts.asset.to_account_info())\n            .collection(Some(&ctx.accounts.collection.to_account_info()))\n            .payer(&ctx.accounts.payer.to_account_info())\n            .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n            .system_program(&ctx.accounts.system_program.to_account_info())\n            .plugin(Plugin::Attributes(Attributes{ attribute_list }))\n            .invoke()?\n\n        }\n        Err(_) => {\n            return Err(StakingError::AttributesNotInitialized.into());\n        }\n    }\n\n    // Thaw the asset\n    UpdatePluginV1CpiBuilder::new(&ctx.accounts.core_program.to_account_info())\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer.to_account_info())\n    .authority(Some(&ctx.accounts.update_authority.to_account_info()))\n    .system_program(&ctx.accounts.system_program.to_account_info())\n    .plugin(Plugin::FreezeDelegate( FreezeDelegate{ frozen: false } ))\n    .invoke()?\n\n    // Remove the FreezeDelegate Plugin\n    RemovePluginV1CpiBuilder::new(&ctx.accounts.core_program)\n    .asset(&ctx.accounts.asset.to_account_info())\n    .collection(Some(&ctx.accounts.collection.to_account_info()))\n    .payer(&ctx.accounts.payer)\n    .authority(Some(&ctx.accounts.owner))\n    .system_program(&ctx.accounts.system_program)\n    .plugin_type(PluginType::FreezeDelegate)\n    .invoke()?\n    \n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Oracle Account State Structure in Rust with Anchor\nDESCRIPTION: This code defines the Oracle account structure using Anchor's account attribute, including validation, bump, and vault_bump fields. It also implements the Space trait for initializing account space.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[account]\npub struct Oracle {\n    pub validation: OracleValidation,\n    pub bump: u8,\n    pub vault_bump: u8,\n}\n\nimpl Space for Oracle {\n    const INIT_SPACE: usize = 8 + 5 + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Account Deserialization in Anchor\nDESCRIPTION: Example of deserializing a BaseCollectionV1 account using Anchor's Account struct\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct ExampleAccountStruct<'info> {\n    ...\n    pub collection: Account<'info, BaseCollectionV1>,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Serializer Types in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the Serializer type and related functionality from Umi. It shows both the bundled import with Umi and the standalone library import.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Bundled with Umi.\nimport { Serializer } from '@metaplex-foundation/umi/serializers';\n\n// As a standalone library.\nimport { Serializer } from '@metaplex-foundation/umi-serializers';\n```\n\n----------------------------------------\n\nTITLE: Configuring Mint Limit Guard in Sugar JSON\nDESCRIPTION: This snippet shows the JSON configuration for the Mint Limit guard when using Sugar. It requires specifying both 'id' and 'limit' as numeric values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/mint-limit.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"mintLimit\" : {\n    \"id\": number,\n    \"limit\": number\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Quick Links in Markdown\nDESCRIPTION: This snippet demonstrates how to create quick links in Markdown for JavaScript and Rust SDKs. It uses custom Markdown syntax to generate formatted links with icons and descriptions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% quick-links %}\n\n{% quick-link title=\"JavaScript\" icon=\"JavaScript\" href=\"/bubblegum/sdk/javascript\" description=\"Get started with our JavaScript library for MPL-Bubblegum based on the Umi framework.\" /%}\n\n{% quick-link title=\"Rust\" icon=\"Rust\" href=\"/bubblegum/sdk/rust\" description=\"Get started using our MPL-Bubblegum Rust crate.\" /%}\n\n{% /quick-links %}\n```\n\n----------------------------------------\n\nTITLE: Installing Metaplex Token Metadata Packages\nDESCRIPTION: Installs required Metaplex packages for token metadata manipulation using npm\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\nnpm i @metaplex-foundation/umi-bundle-defaults\nnpm i @metaplex-foundation/mpl-token-metadata\n```\n\n----------------------------------------\n\nTITLE: Installing MPL Toolbox Package\nDESCRIPTION: This command installs the MPL Toolbox package, which offers a set of utility functions and tools for working with Metaplex programs and data on Solana.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n\"npm i @metaplex-foundation/mpl-toolbox;\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Key Escrow Accounts in JavaScript\nDESCRIPTION: This snippet configures the key accounts needed for the escrow, including the collection, token, fee location, and the derived escrow account.  It uses the `publicKey` function to define the addresses of the collection, token, and fee location. The escrow address is derived using `umi.eddsa.findPda` based on the program ID and collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n\"// Escrow Accounts - Change these to your needs\nconst collection = publicKey('<YOUR-COLLECTION-ADDRESS>'); \nconst token = publicKey('<YOUR-TOKEN-ADDRESS>');           \nconst feeLocation = publicKey('<YOUR-FEE-ADDRESS>');        \nconst escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: 'variable' }).serialize('escrow'),\n    publicKeySerializer().serialize(collection),\n]);                                                        \"\n```\n\n----------------------------------------\n\nTITLE: Generating Transaction Explorer Link for Local Validator\nDESCRIPTION: TypeScript code to generate a transaction link for the Solana Explorer, specifically targeting the local validator cluster.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst signature = base58.deserialize(transaction.signature)[0]\nconsole.log(`Transaction Submitted! https://explorer.solana.com/tx/${signature}?cluster=custom&customUrl=http%3A%2F%2Flocalhost%3A8899`)\n```\n\n----------------------------------------\n\nTITLE: Initializing Node.js Project for Core NFT Asset Creation\nDESCRIPTION: Initializes a new Node.js project using npm. This step is optional but recommended for organizing dependencies.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Setting up Candy Machine with Edition Guard in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a Candy Machine using the Edition guard. The guard is configured with an editionStartOffset of 0, which determines the starting point for edition numbering.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/edition.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    edition: { editionStartOffset: 0 },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Shankjs for Custom Candy Guard in JavaScript\nDESCRIPTION: This snippet shows how to configure Shankjs to generate an IDL for a custom Candy Guard deployment. It includes setting the program name, ID, and necessary directories.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ngenerateIdl({\n  generator: \"anchor\",\n  programName: \"candy_guard\",\n  programId: \"Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g\", // Your custom Candy Guard deployed program key.\n  idlDir,\n  binaryInstallDir,\n  programDir: path.join(programDir, \"candy-guard\", \"program\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Allocation Guard in Sugar config.json\nDESCRIPTION: JSON configuration for the Allocation guard in the Candy Machine config.json file, specifying ID and limit properties.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/allocation.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"allocation\" : {\n    \"id\": number,\n    \"limit\": number\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Allocation Guard in Sugar JSON\nDESCRIPTION: This JSON snippet shows how to configure the Allocation guard in the Sugar config.json file. It specifies the ID and limit for the guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/allocation.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"allocation\" : {\n    \"id\": number,\n    \"limit\": number\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Merkle Tree Token Claimer Program Structure in Rust\nDESCRIPTION: Defines the basic structure of the Merkle Tree Token Claimer program, including imports, account structures, and instruction placeholders.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\nuse anchor_spl::associated_token::AssociatedToken;\nuse anchor_spl::token::{mint_to, set_authority, transfer, Mint, MintTo, SetAuthority, Token, TokenAccount, Transfer, spl_token::instruction::AuthorityType}\n\nuse svm_merkle_tree::{HashingAlgorithm, MerkleProof};\n\ndeclare_id!(\"C9PLf3qMCVqtUCJtEBy8NCcseNp3KTZwFJxAtDdN1bto\");\n\n/// Instructions and Logic behind the program\n#[program]\npub mod merkle_tree_token_claimer {\n    use super::*;\n\n    pub fn initialize_airdrop_data(\n        ctx: Context<Initialize>, \n        merkle_root: [u8; 32],\n        amount: u64,\n    ) -> Result<()> {\n\n        Ok(())\n    }\n\n    pub fn update_tree(\n        ctx: Context<Update>, \n        new_root: [u8; 32]\n    ) -> Result<()> {\n\n        Ok(())\n    }\n\n    pub fn claim_airdrop(\n        ctx: Context<Claim>,\n        amount: u64,\n        hashes: Vec<u8>,\n        index: u64,\n    ) -> Result<()> {  \n\n        Ok(())\n    }\n    \n}\n\n/// Account Struct for the different Instructions\n#[derive(Accounts)]\npub struct Initialize<'info> {\n\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n\n}\n\n#[derive(Accounts)]\npub struct Claim<'info> {\n\n}\n\n/// State account holding the merkle tree and airdrop information\n#[account]\npub struct AirdropState {\n\n}\n\n/// Error for the Program\n#[error_code]\npub enum AirdropError {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Anchor Project via Terminal\nDESCRIPTION: Commands to create a new Anchor project and add the mpl-core dependency with anchor features enabled.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-collection-with-anchor.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nanchor init create-core-collection-example\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd create-core-collection-example\ncargo add mpl-core --features anchor\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Ubuntu/WSL (Bash)\nDESCRIPTION: This command installs necessary dependencies for Sugar when installing from crates.io or source on Ubuntu or WSL systems.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install libudev-dev pkg-config unzip\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet None in JavaScript for Royalties Plugin\nDESCRIPTION: This snippet demonstrates how to create a RuleSet with no rules in JavaScript for the Royalties Plugin. It sets the RuleSet to 'None' when no specific rules are needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ruleSet } from '@metaplex-foundation/mpl-core'\n\nconst rule_set = ruleSet('None')\n```\n\n----------------------------------------\n\nTITLE: Collection Plugin Deserialization\nDESCRIPTION: Accessing plugin data from a Collection account using fetch_plugin()\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet (_, attribute_list, _) = fetch_plugin::<BaseCollectionV1, Attributes>(&ctx.accounts.asset.to_account_info(), mpl_core::types::PluginType::Attributes)?\n```\n\n----------------------------------------\n\nTITLE: Structuring JSON Schema for Video NFT in Metaplex Core\nDESCRIPTION: This snippet illustrates the JSON schema for a video NFT in Metaplex Core. It includes both an image and an animation URL, with the category set to 'video'. The properties section lists both the image and video files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/json-schema.md#2025-04-17_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Video Asset\",\n    \"image\": \"https://arweave.net/uMH-lDz73Q5LQQAdb2HlGu_6KzAgL7pkIKGq1tjqmJc\",\n    \"animation_url\": \"https://arweave.net/b2oifxVmEaHQVTko9l1tEx-eaTLwKErBn-GRRDy2qvM\",\n    \"description\": \"This is a video Asset. It has an image and animation URL with it's category set to 'video'.\",\n    \"external_url\": \"https://example.com\",\n    \"properties\": {\n        \"files\": [\n            {\n                \"uri\": \"https://arweave.net/uMH-lDz73Q5LQQAdb2HlGu_6KzAgL7pkIKGq1tjqmJc\",\n                \"type\": \"image/png\"\n            },\n            {\n                \"uri\": \"https://arweave.net/b2oifxVmEaHQVTko9l1tEx-eaTLwKErBn-GRRDy2qvM\",\n                \"type\": \"video/quicktime\"\n            }\n        ],\n        \"category\": \"video\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Hydra SDK via Package Manager\nDESCRIPTION: Install the Hydra SDK package from npm for JavaScript/TypeScript development environment\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/quick-start.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @glasseaters/hydra-sdk\n```\n\n----------------------------------------\n\nTITLE: Implementing crank_oracle Instruction in Rust\nDESCRIPTION: Instruction to update Oracle validation state and handle cranker rewards based on market timing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub fn crank_oracle(ctx: Context<CrankOracle>) -> Result<()> {\n    match is_us_market_open(Clock::get()?.unix_timestamp) {\n        true => {\n            require!(\n                ctx.accounts.oracle.validation == OracleValidation::V1 {\n                    transfer: ExternalValidationResult::Rejected,\n                    create: ExternalValidationResult::Pass,\n                    burn: ExternalValidationResult::Pass,\n                    update: ExternalValidationResult::Pass\n                },\n                Errors::AlreadyUpdated\n            );\n            ctx.accounts.oracle.validation = OracleValidation::V1 {\n                transfer: ExternalValidationResult::Approved,\n                create: ExternalValidationResult::Pass,\n                burn: ExternalValidationResult::Pass,\n                update: ExternalValidationResult::Pass,\n            };\n        }\n        false => {\n            require!(\n                ctx.accounts.oracle.validation == OracleValidation::V1 {\n                    transfer: ExternalValidationResult::Approved,\n                    create: ExternalValidationResult::Pass,\n                    burn: ExternalValidationResult::Pass,\n                    update: ExternalValidationResult::Pass\n                },\n                Errors::AlreadyUpdated\n            );\n            ctx.accounts.oracle.validation = OracleValidation::V1 {\n                transfer: ExternalValidationResult::Rejected,\n                create: ExternalValidationResult::Pass,\n                burn: ExternalValidationResult::Pass,\n                update: ExternalValidationResult::Pass,\n            };\n        }\n    }\n\n    let reward_vault_lamports = ctx.accounts.reward_vault.lamports();\n    let oracle_key = ctx.accounts.oracle.key().clone();\n    let signer_seeds = &[b\"reward_vault\", oracle_key.as_ref(), &[ctx.accounts.oracle.bump]];\n    \n    if is_within_15_minutes_of_market_open_or_close(Clock::get()?.unix_timestamp) && reward_vault_lamports > REWARD_IN_LAMPORTS {\n        transfer(\n            CpiContext::new_with_signer(\n                ctx.accounts.system_program.to_account_info(), \n                Transfer {\n                    from: ctx.accounts.reward_vault.to_account_info(),\n                    to: ctx.accounts.signer.to_account_info(),\n                }, \n                &[signer_seeds]\n            ),\n            REWARD_IN_LAMPORTS\n        )?\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Kinobi\nDESCRIPTION: Installs the Kinobi package using npm, which is necessary for generating Umi-compatible JavaScript clients for Solana programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @metaplex-foundation/kinobi\n```\n\n----------------------------------------\n\nTITLE: Creating CreateV1 Struct for Off-chain Instructions\nDESCRIPTION: Defines the CreateV1 struct, which represents an off-chain instruction for creating metadata. It includes various fields required for the instruction, such as metadata account, mint, and authority details.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct CreateV1 {\n    /// Unallocated metadata account with address as pda\n    /// of ['metadata', program id, mint id]\n    pub metadata: Pubkey,\n\n    /// Unallocated edition account with address as pda\n    /// of ['metadata', program id, mint, 'edition']\n    pub master_edition: Option<Pubkey>,\n\n    /// Mint of token asset\n    pub mint: (Pubkey, bool),\n\n    /// Mint authority\n    pub authority: Pubkey,\n\n    /// Payer\n    pub payer: Pubkey,\n\n    /// Update authority for the metadata account\n    pub update_authority: (Pubkey, bool),\n\n    /// System program\n    pub system_program: Pubkey,\n\n    /// Instructions sysvar account\n    pub sysvar_instructions: Pubkey,\n\n    /// SPL Token program\n    pub spl_token_program: Pubkey,\n}\n```\n\n----------------------------------------\n\nTITLE: Updatable Fields Structure\nDESCRIPTION: Shows the structure of updatable fields that can be passed to updateEscrowV1 function.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n{\n    name,\n    uri,\n    max,\n    min,\n    amount,\n    feeAmount,\n    solFeeAmount,\n    path\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with MPL-Hybrid\nDESCRIPTION: TypeScript code demonstrating how to create and configure a Umi instance with the MPL-Hybrid package. Shows initialization with an RPC endpoint and adding the mplHybrid package to the instance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/sdk/javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplHybrid } from '@metaplex-foundation/mpl-hybrid'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://api.devenet.solana.com')\n... // additional umi settings and packages\n.use(mplHybrid())\n```\n\n----------------------------------------\n\nTITLE: Deserializing JSON Schema in JavaScript\nDESCRIPTION: This snippet explains that in the JavaScript SDK, deserialization for the JSON schema is handled automatically. The deserialized data can be accessed directly from the raw location shown in the previous example.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n// Due to the JS SDK, the deserialization for the MsgPack schema is automatic and deserialized\n// data can be accessed at the RAW location example above.\n```\n\n----------------------------------------\n\nTITLE: Initializing Project with npm\nDESCRIPTION: Creates a new Node.js project and sets up the initial package configuration\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm init -y\n```\n\n----------------------------------------\n\nTITLE: Implementing Uploader Trait in Rust\nDESCRIPTION: Defines the Uploader trait for custom upload methods in Sugar. This trait gives full control over the upload process and is called for each asset type separately.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/bring-your-own-uploader.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn upload(\n    &self,\n    sugar_config: &SugarConfig,\n    cache: &mut Cache,\n    data_type: DataType,\n    assets: &mut Vec<AssetInfo>,\n    progress: &ProgressBar,\n    interrupted: Arc<AtomicBool>,\n) -> Result<Vec<UploadError>>;\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL to UMI Identity in Typescript\nDESCRIPTION: This snippet demonstrates how to airdrop SOL tokens to the UMI identity's public key using the `umi.rpc.airdrop` method. This provides the identity with the necessary SOL to pay for transaction fees on the Solana network. It logs a message to the console before executing the airdrop.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-create-a-solana-token.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Airdrop 1 SOL to the identity\n  // if you end up with a 429 too many requests error, you may have to use\n  // the filesystem wallet method or change rpcs.\n  console.log(\"AirDrop 1 SOL to the umi identity\");\n  await umi.rpc.airdrop(umi.identity.publicKey, sol(1));\n```\n\n----------------------------------------\n\nTITLE: Setting Min and Max Indexes\nDESCRIPTION: Shows how to set the minimum and maximum indexes for the metadata pool.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nmin: 0,\nmax: 4999\n```\n\n----------------------------------------\n\nTITLE: Metadata URI Formatting Example\nDESCRIPTION: Demonstrates the recommended off-chain metadata URI structure for MPL-404 hybrid projects using incrementing JSON file names\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/preparation.md#2025-04-17_snippet_0\n\nLANGUAGE: uri\nCODE:\n```\nhttps://shdw-drive.genesysgo.net/.../0.json\n```\n\nLANGUAGE: uri\nCODE:\n```\nhttps://shdw-drive.genesysgo.net/.../1.json\n```\n\nLANGUAGE: uri\nCODE:\n```\nhttps://shdw-drive.genesysgo.net/.../999999.json\n```\n\n----------------------------------------\n\nTITLE: Adding an Authority in JavaScript\nDESCRIPTION: This snippet adds a new authority to a Metaplex inscription by calling the addAuthority function. It requires an existing authority to sign the transaction and uses the findInscriptionMetadataPda function to get the inscription metadata account.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/authority.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  addAuthority,\n  findInscriptionMetadataPda,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\n\nawait addAuthority(umi, {\n  inscriptionMetadataAccount,\n  newAuthority: authority.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Implementing Amount Rule for Token Transfers in Javascript\nDESCRIPTION: Example of creating a Rule Set that validates token transfers based on amount. This rule ensures that transfers are only allowed when the amount exceeds 5 tokens. The rule uses the Amount primitive type with a greater than operator.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/amount.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// This Rule Set will only evaluate to true if more than 5 tokens are being transferred.\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    transfer: {\n      type: 'Amount',\n      field: 'Amount',\n      operator: '>'\n      amount: 5,\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Address Gate Guard in Sugar JSON for Core Candy Machine\nDESCRIPTION: This JSON snippet shows how to configure the Address Gate guard in the Sugar config.json file for Core Candy Machine. It specifies the public key that will be allowed to mint.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/address-gate.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"addressGate\" : {\n    \"address\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running Amman Commands with Package Managers\nDESCRIPTION: This snippet shows how to run Amman commands using different package managers (npm, yarn, pnpm) when Amman is added to the package.json scripts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/cli-commands.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n// npm\nnpm run amman:start\n\n// yarn\nyarn amman:start\n\n// pnpm\npnpm run amman:start\n```\n\n----------------------------------------\n\nTITLE: Calculating Required Lamports for Metadata Upload\nDESCRIPTION: Calculates the amount of SOL (in lamports) needed for a metadata folder upload by determining folder size and required Winc tokens.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/create-deterministic-metadata-with-turbo.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst requiredLamportsForMetadata = await calculateRequiredLamportsForUpload(\n  turbo,\n  calculateFolderSize(metadataFolderPath)\n);\n```\n\n----------------------------------------\n\nTITLE: Sugar Cache File Structure\nDESCRIPTION: Main structure of the Sugar cache file showing program details and items tracking. Includes Candy Machine, Candy Guard, creator addresses and collection information along with asset metadata.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/cache.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"program\": {\n    \"candyMachine\": \"<PUBLIC KEY>\",\n    \"candyGuard\": \"<PUBLIC KEY>\",\n    \"candyMachineCreator\": \"<PUBLIC KEY>\",\n    \"collectionMint\": \"<PUBLIC KEY>\"\n  },\n  \"items\": {\n    \"-1\": {\n      \"name\": \"My Collection\",\n      \"image_hash\": \"6500707cb13044b7d133abb5ad68e0af660b154499229af49419c86a251a2b4d\",\n      \"image_link\": \"https://arweave.net/KplI7R59EE24-mavSgai7WVJmkfvYQKhtTnqxXPlPdE?ext=png\",\n      \"metadata_hash\": \"2009eda578d1196356abcfdfbba252ec3318fc6ffe42cc764a624b0c791d8471\",\n      \"metadata_link\": \"https://arweave.net/K75J8IG1HcTYJyr1eC0KksYfpxuFMkPONJMpUNDmCuA\",\n      \"onChain\": true\n    },\n    \"0\": {\n      \"name\": \"My First NFT #1\",\n      \"image_hash\": \"209a200ebea39be9e9e7882da2bc5e652fb690e612abecb094dc13e06db84e54\",\n      \"image_link\": \"https://arweave.net/-qSoAFO7GWTm_js1eHDyoljgB3D_vszlXspVXBM7HyA?ext=png\",\n      \"metadata_hash\": \"cfc45ba94da81c8d21f763ce8bb6bbb845ad598e23e44d5c8db1590672b7653f\",\n      \"metadata_link\": \"https://arweave.net/6DRibEPNjLQKA90v3qa-JsYPPT5a6--VsgKumUnX3_0\",\n      \"onChain\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MPL-Bubblegum Package with Cargo\nDESCRIPTION: Command to add the MPL-Bubblegum package as a dependency to a Rust project using Cargo.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/rust.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-bubblegum\n```\n\n----------------------------------------\n\nTITLE: Installing Token Metadata Package for NFT Standards\nDESCRIPTION: Command to install the Metaplex Token Metadata package which provides functionality for working with Solana's NFT metadata standard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-token-metadata\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine Configuration with Custom Filename\nDESCRIPTION: Similar to the basic create command, but allows specifying a custom filename for the configuration using the '-c' option.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/config.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar config create -c my-config.json\n```\n\n----------------------------------------\n\nTITLE: Calculating Random Inscription Shard in JavaScript\nDESCRIPTION: Shows how to generate a random shard number between 0 and 31 to avoid write locks when creating inscriptions\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/index.md#2025-04-17_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst randomShard = Math.floor(Math.random() * 32)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with Existing Wallet\nDESCRIPTION: Configuration for Umi using an existing wallet loaded from filesystem.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplCore())\n    .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi)\n\n// You will need to us fs and navigate the filesystem to\n// load the wallet you wish to use via relative pathing.\nconst walletFile = fs.readFileSync('./keypair.json')\n  \n\n// Convert your walletFile onto a keypair.\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n\n// Load the keypair into umi.\numi.use(keypairIdentity(umiSigner));\n```\n\n----------------------------------------\n\nTITLE: Accessing RuleSet from Metadata\nDESCRIPTION: Demonstrates how to extract the ruleSet configuration from a pNFT metadata account using unwrapOptionRecursively.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/pnfts.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst ruleSet = unwrapOptionRecursively(assetWithToken.metadata.programmableConfig)?.ruleSet\n```\n\n----------------------------------------\n\nTITLE: Adding Plugins - Old vs New Syntax\nDESCRIPTION: Shows the evolution of plugin data structure from nested to top-level implementation in the new SDK version.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/core-js-sdk-v1-0.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait addPluginV1(umi, {\n  asset: asset.publicKey,\n  plugin: createPlugin({ type: 'FreezeDelegate', data: { frozen: true } }),\n  initAuthority: addressPluginAuthority(delegate),\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait addPlugin(umi, {\n  asset: assetId,\n  plugin: {\n    type: 'Attributes',\n    attributeList: [{ key: 'key', value: 'value' }],\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Initializing CreateV1CpiBuilder in Rust\nDESCRIPTION: This snippet illustrates the new function for CreateV1CpiBuilder, including parameters needed to create a new asset, such as name and URI, which are essential for the CPI call regarding asset creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n//new() function for CreateV1CpiBuilder\n\npub fn new(program: &'b solana_program::account_info::AccountInfo<'a>) -> Self {\n        let instruction = Box::new(CreateV1CpiBuilderInstruction {\n            __program: program,\n            asset: None,\n            collection: None,\n            authority: None,\n            payer: None,\n            owner: None,\n            update_authority: None,\n            system_program: None,\n            log_wrapper: None,\n            data_state: None,\n            name: None,\n            uri: None,\n            plugins: None,\n            __remaining_accounts: Vec::new(),\n        });\n        Self { instruction }\n    }\n```\n\n----------------------------------------\n\nTITLE: Setting Creator to Unverified in MPL Core Asset\nDESCRIPTION: This code example shows how to set a creator's status to unverified. It assumes that umi.identity is the creator that you want to remove.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/verified-creators.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKey } from '@metaplex-foundation/umi'\nimport { updatePlugin, fetchAsset } from '@metaplex-foundation/mpl-core'\n\nconst asset = await fetchAsset(umi, assetAddress.publicKey, {\n  skipDerivePlugins: false,\n})\n\n// The Publickey of the creator that you want to remove \nconst publicKeyToRemove = publicKey(\"abc...\")\n\nconst modifiedCreators = signatures.map(signature => \n  signature.address === creator.publicKey \n    ? { ...signature, verified: false } \n    : signature\n);\n\nawait updatePlugin(umi, {\n  asset: asset.publicKey,\n  plugin: {\n    type: 'VerifiedCreators',\n    signatures: modifiedCreators,\n  },\n  authority: umi.identity, // Should be the creator\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Setting Fee ATA\nDESCRIPTION: Shows how to set the Token Account for fee collection.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfeeAta: findAssociatedTokenPda(umi, {\n    mint: publicKey(\"111111111111111111111111111111111\"),\n    owner: publicKey(\"22222222222222222222222222222222\"),\n  });\n```\n\n----------------------------------------\n\nTITLE: Updating Merkle Tree with New Entry in TypeScript\nDESCRIPTION: Demonstrates how to add a new random allocation to the existing Merkle tree and generate a new Merkle root.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst newData = {\n  address: Keypair.generate().publicKey,\n  amount: Math.floor(Math.random() * 1000),           // Example random amount\n  isClaimed: false,                                   // Default value for isClaimed\n};\n\nmerkleTreeData.push(newData); \n    \nconst entryBytes = Buffer.concat([\n  newData.address.toBuffer(), // PublicKey as bytes\n  Buffer.from(new Uint8Array(new anchor.BN(newData.amount).toArray('le', 8))), // Amount as little-endian\n  Buffer.from([newData.isClaimed ? 1 : 0]), // isClaimed as 1 byte\n]);\n\nmerkleTree.add_leaf(entryBytes);\n    \nmerkleTree.merklize();\n\nconst newMerkleRoot = Array.from(merkleTree.get_merkle_root());\n```\n\n----------------------------------------\n\nTITLE: Setting up Solana RPC client in Rust\nDESCRIPTION: This snippet demonstrates how to set up a Solana RPC client in Rust using the `solana_client` crate. It initializes an `RpcClient` instance connected to the specified Solana devnet endpoint. This client is then used to interact with the Solana blockchain.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse solana_client::rpc_client;\n\nlet rpc_client = rpc_client::RpcClient::new(\"https://api.devnet.solana.com\".to_string());\n```\n\n----------------------------------------\n\nTITLE: Setting URI for Metadata Pool\nDESCRIPTION: Demonstrates setting the base URI for the metadata pool, which should point to sequential JSON files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nuri: \"https://shdw-drive.genesysgo.net/<bucket-id>/\"\n```\n\n----------------------------------------\n\nTITLE: Solana Protocol Fee Structure Table\nDESCRIPTION: Detailed table showing protocol fees for various instructions on Solana chain, including program names, typical payers, and amounts in SOL\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/protocol-fees.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Instruction | Program | Typical Payer | Amount (SOL) | Notes |\n| --------------- | --------------- | ------------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Create | Core | Collector | 0.0015 | Paid by the minter, which is typically individual collectors minting new drops. Includes all instructions that \"create\" an NFT including ones that create print editions. |\n| Execute | Core | Owner | 0.00004872 | Typically paid by the current owner the Core NFT Asset that is calling the execute instruction. |\n| Create | Token Metadata | Collector | 0.01 | Paid by the minter, which is typically individual collectors minting new drops. Alternatively creators may consider using Core (next gen NFTs) for maximum composability and lower mint costs, or Bubblegum (compressed NFTs). Includes all instructions that \"create\" an NFT including ones that create print editions. |\n| Create | Bubblegum | - | Free |\n| Swap | MPL-Hybrid | Collector | 0.005 | Paid by the individual who swaps tokens and NFTs. |\n| Combine | Fusion (Trifle) | Collector | 0.002 | |\n| Split | Fusion (Trifle) | Collector | 0.002 | |\n| Edit constraint | Fusion (Trifle) | Creator | 0.01 | |\n```\n\n----------------------------------------\n\nTITLE: Fetching Recent Slot in TypeScript\nDESCRIPTION: Displays a method to get the most recent blockchain slot as a number using Umi's RpcInterface. Requires no parameters and returns a slot number.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/rpc.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst recentSlot = await umi.rpc.getSlot();\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Payment Guard in TypeScript\nDESCRIPTION: This code snippet shows how to mint using the Asset Payment guard. It provides the necessary mint arguments including the required collection, destination, and asset to send.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-payment.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    assetPayment: some({\n      requiredCollection: publicKey(requiredCollection),\n      destination,\n      asset: assetToSend.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Project with Node.js\nDESCRIPTION: Initializes a new Node.js project for starting a JavaScript application. It asks for project configuration details. This step is optional if there's an existing project setup.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-spl-tokens-on-solana.md#2025-04-17_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n\"npm init\"\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Guard File in TypeScript\nDESCRIPTION: This TypeScript code defines a template for creating a custom guard file. It includes the guard manifest, serializer, and parser functions, as well as custom mint arguments.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PublicKey } from '@metaplex-foundation/umi'\nimport {\n  getCustomGuardSerializer,\n  CustomGuard,\n  CustomGuardArgs,\n} from '../generated'\nimport { GuardManifest, noopParser } from '../guards'\n\nexport const customGuardManifest: GuardManifest<\n  CustomGuardArgs,\n  CustomGuard,\n  CustomGuardMintArgs\n> = {\n  name: 'customGuard',\n  serializer: getCustomGuardSerializer,\n  mintParser: (context, mintContext, args) => {\n    const { publicKeyArg1, arg1 } = args\n    return {\n      data: new Uint8Array(),\n      // Pass in any accounts needed for your custom guard from your mint args.\n      // Your guard may or may not need remaining accounts.\n      remainingAccounts: [\n        { publicKey: publicKeyArg1, isWritable: true },\n        { publicKey: publicKeyArg2, isWritable: false },\n      ],\n    }\n  },\n  routeParser: noopParser,\n}\n\n// Here you would fill out any custom Mint args needed for your guard to operate.\n// Your guard may or may not need MintArgs.\n\nexport type CustomGuardMintArgs = {\n  /**\n   * Custom Guard Mint Arg 1\n   */\n  publicKeyArg1: PublicKey\n\n  /**\n   * Custom Guard Mint Arg 2\n   */\n  publicKeyArg2: PublicKey\n\n  /**\n   * Custom Guard Mint Arg 3.\n   */\n  arg3: Number\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CreateV1Builder Struct in Metaplex SDK\nDESCRIPTION: This Rust struct is defined for the CreateV1Builder in the Metaplex SDK. It includes fields for various public keys and optional data, facilitating the construction of CreateV1 instructions with necessary account and data configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/metaplex-rust-sdks.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct CreateV1Builder {\n    asset: Option<solana_program::pubkey::Pubkey>,\n    collection: Option<solana_program::pubkey::Pubkey>,\n    authority: Option<solana_program::pubkey::Pubkey>,\n    payer: Option<solana_program::pubkey::Pubkey>,\n    owner: Option<solana_program::pubkey::Pubkey>,\n    update_authority: Option<solana_program::pubkey::Pubkey>,\n    system_program: Option<solana_program::pubkey::Pubkey>,\n    log_wrapper: Option<solana_program::pubkey::Pubkey>,\n    data_state: Option<DataState>,\n    name: Option<String>,\n    uri: Option<String>,\n    plugins: Option<Vec<PluginAuthorityPair>>,\n    __remaining_accounts: Vec<solana_program::instruction::AccountMeta>,\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Candy Machine Guards\nDESCRIPTION: Command to view the current onchain configuration of the Candy Machine guards.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/guard.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar guard show\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: Series of npm install commands for required Metaplex and Solana packages\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/mpl-token-metadata\n```\n\nLANGUAGE: javascript\nCODE:\n```\nnpm i @metaplex-foundation/umi-uploader-irys;\n```\n\n----------------------------------------\n\nTITLE: Setting Up Umi with Generated Signer for Solana Interaction\nDESCRIPTION: TypeScript code that initializes the Umi framework with Bubblegum, TokenMetadata, and Irys uploader plugins, and configures it with a generated signer for devnet interaction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = createUmi('https://api.devnet.solana.com')\n  .use(mplBubblegum())\n  .use(mplTokenMetadata())\n  .use(\n    irysUploader({\n      // mainnet address: \"https://node1.irys.xyz\"\n      // devnet address: \"https://devnet.irys.xyz\"\n      address: 'https://devnet.irys.xyz',\n    })\n  )\n\nconst signer = generateSigner(umi)\n\numi.use(signerIdentity(signer))\n\n// This will airdrop SOL on devnet only for testing.\nconsole.log('Airdropping 1 SOL to identity')\nawait umi.rpc.airdrop(umi.identity.publickey, sol(5))\n```\n\n----------------------------------------\n\nTITLE: Leaf Schema Reference in Rust\nDESCRIPTION: Reference to the leaf schema implementation in the Bubblegum program that defines the structure for compressed NFT leaf nodes.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/concurrent-merkle-trees.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nleaf_schema.rs#L40\n```\n\n----------------------------------------\n\nTITLE: Hashing NFT Creator Information in Bubblegum\nDESCRIPTION: This function computes a separate hash for the creator information of a compressed NFT. It converts each creator's address, verification status, and share percentage into bytes, then applies keccak-256 hashing to produce a single hash representing all creators.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/hashed-nft-data.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n/// Computes the hash of the creators.\n///\n/// The hash is computed as the keccak256 hash of the creators bytes.\npub fn hash_creators(creators: &[Creator]) -> [u8; 32] {\n    // convert creator Vec to bytes Vec\n    let creator_data = creators\n        .iter()\n        .map(|c| [c.address.as_ref(), &[c.verified as u8], &[c.share]].concat())\n        .collect::<Vec<_>>();\n    // computes the hash\n    keccak::hashv(\n        creator_data\n            .iter()\n            .map(|c| c.as_slice())\n            .collect::<Vec<&[u8]>>()\n            .as_ref(),\n    )\n    .to_bytes()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Umi with Wallet Adapter\nDESCRIPTION: Integration of Solana Wallet Adapter with Umi instance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-collection-with-javascript.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'\nimport { useWallet } from '@solana/wallet-adapter-react'\n\nconst wallet = useWallet()\n\nconst umi = createUmi('https://api.devnet.solana.com')\n.use(mplCore())\n// Register Wallet Adapter to Umi\n.use(walletAdapterIdentity(wallet))\n```\n\n----------------------------------------\n\nTITLE: Configuring Start Date Guard with Sugar in config.json\nDESCRIPTION: This JSON snippet shows how to configure the Start Date guard in a config.json file using Sugar. It specifies the date field which must use the RFC 3339 standard format.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/start-date.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"startDate\" : {\n    \"date\": \"string\",\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Members to Hydra Wallet\nDESCRIPTION: Add wallet members to the Hydra fanout with specified share allocation, demonstrating member management\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/quick-start.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst member1 = new Keypair();\nconst { membershipAccount1 } = await fanoutSdk.addMemberWallet({\n  fanout: init.fanout,\n  fanoutNativeAccount: init.nativeAccount,\n  membershipKey: member1.publicKey,\n  shares: 10\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Candy Machine Guards\nDESCRIPTION: Command to update the existing guard configuration after making modifications in the Sugar config file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/guard.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar guard update\n```\n\n----------------------------------------\n\nTITLE: Adding addBlocker Plugin to MPL Core Collection\nDESCRIPTION: Shows how to add the addBlocker plugin to a Metaplex Core Collection using the addCollectionPlugin function. This prevents future authority managed plugins from being added to the collection and its associated assets.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/addBlocker.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  addCollectionPlugin,\n} from '@metaplex-foundation/mpl-core'\n\nawait addCollectionPlugin(umi, {\n  collection: collection.publicKey,\n  plugin: {\n    type: 'addBlocker',\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creating CreateV1 Instruction with Builder Pattern\nDESCRIPTION: Demonstrates using the CreateV1Builder companion struct for easier construction of the instruction by chaining method calls for setting fields.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/getting-started/rust.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet create_ix = CreateV1Builder::new()\n    .metadata(metadata)\n    .master_edition(Some(master_edition))\n    .mint(mint_pubkey, true)\n    .authority(payer_pubkey)\n    .payer(payer_pubkey)\n    .update_authority(payer_pubkey, true)\n    .is_mutable(true)\n    .primary_sale_happened(false)\n    .name(String::from(\"My pNFT\"))\n    .uri(String::from(\"https://my.pnft\"))\n    .seller_fee_basis_points(500)\n    .token_standard(TokenStandard::ProgrammableNonFungible)\n    .print_supply(PrintSupply::Zero)\n    .instruction();\n```\n\n----------------------------------------\n\nTITLE: Minting NFTs from a Core Candy Machine using Metaplex Library in TypeScript\nDESCRIPTION: This snippet demonstrates minting multiple NFTs from a Core Candy Machine using the 'mintV1' method from 'mpl-core-candy-machine'. Dependencies include UMI and a transaction builder. The function mints NFTs with placeholder metadata configured in hidden settings and requires asset details and collection information as inputs. The expected output is confirmation of the NFT minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { mintV1 } from '@metaplex-foundation/mpl-core-candy-machine';\n\nconst nftMint = [\n    generateSigner(umi),\n    generateSigner(umi),\n    generateSigner(umi),\n    generateSigner(umi),\n    generateSigner(umi),\n];\n\nfor(let i = 0; i < nftMint.length; i++) {\n    let mintNFT = await transactionBuilder()\n    .add(setComputeUnitLimit(umi, { units: 800_000 }))\n    .add(\n        mintV1(umi, {\n            candyMachine: candyMachine.publicKey,\n            asset: nftMint[i],\n            collection: collectionMint.publicKey,\n        })\n    ).sendAndConfirm(umi);\n\n    console.log(\"NFT minted!\");\n};\n\n```\n\n----------------------------------------\n\nTITLE: Importing Umi Dependencies\nDESCRIPTION: Required imports for working with Umi transactions and signers\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner, signerIdentity, createNoopSigner } from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { fetchCollection, create, mplCore } from '@metaplex-foundation/mpl-core'\nimport { base64 } from '@metaplex-foundation/umi/serializers';\n```\n\n----------------------------------------\n\nTITLE: Update Item Settings\nDESCRIPTION: Shows how to update the Config Line Settings of a Candy Machine. These updates are subject to certain limitations and can only be performed before the first NFT is minted.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  updateCandyMachine,\n  fetchCandyMachine,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst candyMachine = await fetchCandyMachine(umi, candyMachineAddress)\nawait updateCandyMachine(umi, {\n  candyMachine: candyMachine.publicKey,\n  data: {\n    ...candyMachine.data,\n    hiddenSettings: none(),\n    configLineSettings: some({\n      type: 'configLines',\n      prefixName: 'My New NFT #$ID+1$',\n      nameLength: 0,\n      prefixUri: 'https://arweave.net/',\n      uriLength: 43,\n      isSequential: true,\n    }),\n  },\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Importing MPL Core DAS Package\nDESCRIPTION: Code snippet showing how to import the MPL Core DAS package to use Core-specific functions like DAS-to-Core type conversions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/getting-started.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { das } from '@metaplex-foundation/mpl-core-das';\n```\n\n----------------------------------------\n\nTITLE: Generating Keypair in Umi\nDESCRIPTION: TypeScript code demonstrating how to generate a Keypair using Metaplex Umi, including creating a Umi instance and generating a new signer.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { generateSigner, createSignerFromKeypair } from '@metaplex-foundation/umi'\n\n// Generate a new Umi instance\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// Generate a new Umi keypair\nconst umiKeypair = generateSigner(umi)\n\n// Or use an existing one\nconst umiKeypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\n```\n\n----------------------------------------\n\nTITLE: Installing Merkle Tree Dependencies\nDESCRIPTION: Commands to install the required SVM Merkle Tree crate for managing Merkle trees in the Solana Virtual Machine.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd token-claimer-example\ncargo add svm-merkle-tree --git https://github.com/deanmlittle/svm-merkle-tree\n```\n\n----------------------------------------\n\nTITLE: Locking pNFT Asset with Token Metadata\nDESCRIPTION: Shows how to lock a programmable NFT (pNFT) using the Token Metadata program. Includes fetching associated token accounts and handling token records.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/lock.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fetchDigitalAssetWithAssociatedToken,\n  lockV1,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { publicKey } from \"@metaplex-foundation/umi\";\n\n// Mint ID of the pNFT Asset\nconst mintId = publicKey(\"11111111111111111111111111111111\");\n\n// Fetch pNFT Asset with Token Accounts\nconst assetWithToken = await fetchDigitalAssetWithAssociatedToken(\n  umi,\n  mintId,\n  umi.identity.publicKey\n);\n\n// Send lock instruction\nconst { signature } = await lockV1(umi, {\n  // Mint ID of the pNFT Asset\n  mint: mintId,\n  // Update Authority or Delegate Authority\n  authority: umi.identity,\n  // Token Standard\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n  // Owner of the pNFT Asset\n  tokenOwner: assetWithToken.token.owner,\n  // Token Account of the pNFT Asset\n  token: assetWithToken.token.publicKey,\n  // Token Record of the pNFT Asset\n  tokenRecord: assetWithToken.tokenRecord?.publicKey,\n}).sendAndConfirm(umi);\n\nconsole.log(\"Signature: \", base58.deserialize(signature));\n```\n\n----------------------------------------\n\nTITLE: Installing umi-web3js-adapters Package\nDESCRIPTION: Command to install the umi-web3js-adapters package, which provides helper methods for converting between Umi and Web3.js types.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/web3js-differences-and-adapters.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-web3js-adapters\n```\n\n----------------------------------------\n\nTITLE: Creating a Gumdrop Airdrop with CLI\nDESCRIPTION: Command for creating a Gumdrop airdrop specifying the environment, keypair, distribution list, claim integration type, token mint address, and distribution method. This sets up the on-chain Gumdrop with the merkle root from the distribution list.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/spl-token-claim-airdrop-using-gumdrop.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nts-node gumdrop-cli.ts create \\\n  -e devnet \\\n  --keypair <KEYPAIR_PATH> \\\n  --distribution-list <PATH_TO_JSON> \\\n  --claim-integration transfer \\\n  --transfer-mint <TOKEN_MINT> \\\n  --distribution-method <METHOD>\n```\n\n----------------------------------------\n\nTITLE: Minting NFTs to Single Recipient using Sugar CLI\nDESCRIPTION: Command to mint 3 NFTs to a specific wallet address using the Sugar CLI mint command.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/airdrop-mint-to-another-wallet.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint --receiver Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV -n 3 --candy-machine 11111111111111111111111111111111\n```\n\n----------------------------------------\n\nTITLE: Comparing Hash with Custom Cache File in Sugar CLI\nDESCRIPTION: This command compares a published hash value with the value from a specified custom cache file. It allows for flexibility in managing multiple cache files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/hash.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar hash --compare 44oZ3goi9ivakeUnbjWbWJpvdgcWCrsi --cache my_custom_cache.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Bot Tax Guard in Sugar JSON Configuration\nDESCRIPTION: This JSON snippet shows how to configure the Bot Tax guard in a Sugar config.json file. It includes the value property for specifying the SOL amount to charge and the lastInstruction boolean to determine whether the mint instruction must be the last instruction.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/bot-tax.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"botTax\" : {\n    \"value\": SOL value,\n    \"lastInstruction\": boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Eclipse Protocol Fee Structure Table\nDESCRIPTION: Detailed table showing protocol fees for various instructions on Eclipse chain, including program names, typical payers, and amounts in ETH\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/protocol-fees.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Instruction | Program | Typical Payer | Amount (ETH) | Notes |\n| --------------- | --------------- | ------------- | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Create | Core | Collector | 0.00001822 | Paid by the minter, which is typically individual collectors minting new drops. Includes all instructions that \"create\" an NFT including ones that create print editions. |\n| Execute | Core | Owner | 0.000000476 | Typically paid by the current owner the Core NFT Asset that is calling the execute instruction. |\n| Create | Token Metadata | Collector | 0.000103088 | Paid by the minter, which is typically individual collectors minting new drops. Alternatively creators may consider using Core (next gen NFTs) for maximum composability and lower mint costs, or Bubblegum (compressed NFTs). Includes all instructions that \"create\" an NFT including ones that create print editions. |\n| Create | Bubblegum | - | Free |\n| Swap | MPL-Hybrid | Collector | 0.005 | Paid by the individual who swaps tokens and NFTs. |\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi with MPL-Bubblegum Plugin\nDESCRIPTION: TypeScript code demonstrating how to set up a Umi instance with the MPL-Bubblegum plugin. It shows importing required dependencies, creating a Umi instance with an RPC endpoint, and adding the MPL-Bubblegum plugin.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/javascript.md#2025-04-17_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { mplBubblegum } from '@metaplex-foundation/mpl-bubblegum'\n\n// Use the RPC endpoint of your choice.\nconst umi = createUmi('http://api.devnet.solana.com')\n... // additional umi settings, packages, and signers\n.use(mplBubblegum())\n```\n\n----------------------------------------\n\nTITLE: Updating Staking Attributes in Rust\nDESCRIPTION: This snippet checks for existing staking attributes and updates them if present, or adds them if not initialized.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nOk((_, fetched_attribute_list, _)) => {\n    // If yes, check if the asset is already staked, and if the staking attribute are already initialized\n    let mut attribute_list: Vec<Attribute> = Vec::new();\n    let mut is_initialized: bool = false;\n\n    for attribute in fetched_attribute_list.attribute_list {\n        if attribute.key == \"staked\" {\n            require!(attribute.value == \"0\", StakingError::AlreadyStaked);\n            attribute_list.push(Attribute { \n                key: \"staked\".to_string(), \n                value: Clock::get()?.unix_timestamp.to_string() \n            });\n            is_initialized = true;\n        } else {\n            attribute_list.push(attribute);\n        } \n    }\n\nif !is_initialized {\n    attribute_list.push(Attribute { \n        key: \"staked\".to_string(), \n        value: Clock::get()?.unix_timestamp.to_string() \n    });\n    attribute_list.push(Attribute { \n        key: \"staked_time\".to_string(), \n        value: 0.to_string() \n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Option Type Definition\nDESCRIPTION: Type definitions for Option handling in Umi, providing a Rust-like Option type implementation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype Option<T> = Some<T> | None;\ntype Some<T> = { __option: 'Some'; value: T };\ntype None = { __option: 'None' };\n```\n\n----------------------------------------\n\nTITLE: Initializing Umi with Wallet Adapter\nDESCRIPTION: Setup Umi instance with Solana wallet adapter integration\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'\nimport { useWallet } from '@solana/wallet-adapter-react'\n\nconst wallet = useWallet()\n\nconst umi = createUmi('https://api.devnet.solana.com')\n.use(mplCore())\n.use(walletAdapterIdentity(wallet))\n```\n\n----------------------------------------\n\nTITLE: Accept SPL Tokens with Fanout Client\nDESCRIPTION: This snippet adds functionality to an existing Hydra Wallet using the fanout SDK to allow acceptance of specific SPL Tokens. It initializes the wallet for mint using a token's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mintPublicKey = 'SPL-Token-Public-Key'\n\nconst { fanoutForMint, tokenAccount } = await fanoutSdk.initializeFanoutForMint(\n  {\n    fanout,\n    mint: mintPublicKey,\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Public Key Tree Match Rule in Token Auth Rules\nDESCRIPTION: Demonstrates how to implement a merkle tree-based public key validation rule. This approach is efficient for managing large sets of allowed public keys.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-auth-rules/primitive-rules/pubkey-match.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst revision: RuleSetRevisionV2 = {\n  libVersion: 2,\n  name: 'My Rule Set',\n  owner,\n  operations: {\n    transfer: {\n      type: 'PubkeyTreeMatch',\n      pubkeyField: 'Destination',\n      proofField: 'DestinationProof',\n      root: [229, 0, 134, 58, 163, 244, 192, 254, 190, 193, 110, 212, 193, 145, 147, 18, 171, 160, 213, 18, 52, 155, 8, 51, 44, 55, 25, 245, 3, 47, 172, 111],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: GpaBuilder with Field Registration\nDESCRIPTION: Example of registering and using fields with GpaBuilder for improved filtering and slicing\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { gpaBuilder } from '@metaplex-foundation/umi';\nimport { string, u32 } from '@metaplex-foundation/umi/serializers';\n\nconst myGpaBuilderWithFields = gpaBuilder(umi, programId)\n  .registerFields<{ name: string; age: number; }>({\n    name: [16, string({ size: 32 })],\n    age: [48, u32()],\n  })\n```\n\n----------------------------------------\n\nTITLE: Defining Amount Types in TypeScript\nDESCRIPTION: Type definitions for Amount handling in Umi, including generic Amount type and specific variants for SOL, USD, and percentage values\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/helpers.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype AmountIdentifier = 'SOL' | 'USD' | '%' | 'splToken' | string;\ntype AmountDecimals = number;\ntype Amount<\n  I extends AmountIdentifier = AmountIdentifier,\n  D extends AmountDecimals = AmountDecimals\n> = {\n  /** The amount in its lower possible unit such that it does not contain decimals. */\n  basisPoints: bigint;\n  /** The identifier of the amount. */\n  identifier: I;\n  /** The number of decimals in the amount. */\n  decimals: D;\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Required NPM Packages\nDESCRIPTION: Commands to install the necessary Metaplex Umi packages for transaction handling\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/guides/serializing-and-deserializing-transactions.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-core\n```\n\n----------------------------------------\n\nTITLE: Installing MPL Core DAS Package\nDESCRIPTION: Installation command for the MPL Core DAS package which enables DAS support for Metaplex Core Assets, providing proper typing and conversion utilities.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/getting-started.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nnpm install @metaplex-foundation/mpl-core-das\n```\n\n----------------------------------------\n\nTITLE: Running the JavaScript Generator File\nDESCRIPTION: Executes the JavaScript file that generates Umi-compatible clients using Node.js. Ensure that the Kinobi instance and rendering instructions are correctly configured in the JavaScript file before execution.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/kinobi.md#2025-04-17_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnode ./kinobi.js\n```\n\n----------------------------------------\n\nTITLE: Distributing Funds to Hydra Wallet Members\nDESCRIPTION: Generate and send distribution instructions for transferring funds to a specific member of the Hydra wallet\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/quick-start.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nlet distMember1 = await fanoutSdk.distributeWalletMemberInstructions(\n  {\n    distributeForMint: false,\n    member: member1.wallet.publicKey,\n    fanout: fanout,\n    payer: authorityWallet.publicKey,\n  },\n);\n\nconst tx = await fanoutSdk.sendInstructions(\n  [...distMember1.instructions],\n  [authorityWallet],\n  authorityWallet.publicKey\n);\n```\n\n----------------------------------------\n\nTITLE: Fetching Digital Assets by Update Authority\nDESCRIPTION: Helper function to fetch all Digital Assets by their update authority.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/fetch.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchAllDigitalAssetByUpdateAuthority } from '@metaplex-foundation/mpl-token-metadata'\n\nconst assets = await fetchAllDigitalAssetByUpdateAuthority(umi, owner)\n```\n\n----------------------------------------\n\nTITLE: Configuring Airdrop List in JSON\nDESCRIPTION: JSON configuration file format for specifying wallet addresses and the number of NFTs to airdrop to each address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/airdrop.md#2025-04-17_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\"address1\": 2,\n\"address2\": 7\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Plugin Address Authority in TypeScript\nDESCRIPTION: This function checks if a given public key has authority over a plugin address. It returns a boolean value based on whether the plugin's authority is set to an Address type and matches the provided public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/helpers.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport function hasPluginAddressAuthority(\n  pubkey: PublicKey | string,\n  authority: BasePluginAuthority\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Required Package: MPL-Token-Metadata\nDESCRIPTION: This snippet provides the command for installing the @metaplex-foundation/mpl-token-metadata package, necessary for handling token metadata in the MPL-Hybrid program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/mpl-token-metadata\n```\n\n----------------------------------------\n\nTITLE: Full Token Metadata Code Example\nDESCRIPTION: Complete implementation of adding metadata to a Solana token, including imports, Umi setup, and metadata creation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-add-metadata-to-spl-tokens.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n\tcreateV1,\n\tfindMetadataPda,\n\tmplTokenMetadata,\n\tTokenStandard\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { mplToolbox } from \"@metaplex-foundation/mpl-toolbox\";\nimport {\n  generateSigner,\n  percentAmount,\n  publicKey,\n  signerIdentity,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\n\nconst umi = createUmi(\"https://api.devnet.solana.com\")\n\t.use(mplTokenMetadata())\n\t.use(mplToolbox());\n\n// Generate a new keypair signer.\nconst signer = generateSigner(umi);\n\n// Tell umi to use the new signer.\numi.use(signerIdentity(signer));\n\n// your SPL Token mint address\nconst mint = publicKey(\"YOUR_TOKEN_MINT_ADDRESS\");\n \n\n// Sample Metadata for our Token\nconst tokenMetadata = {\n\tname: \"Solana Gold\",\n\tsymbol: \"GOLDSOL\",\n\turi: \"https://raw.githubusercontent.com/solana-developers/program-examples/new-examples/tokens/tokens/.assets/spl-token.json\",\n};\n\n// Add metadata to an existing SPL token wrapper function\nasync function addMetadata() {\n\t// Airdrop 2 SOL to the identity\n    // if you end up with a 429 too many requests error, you may have to use\n    // the a different rpc other than the free default one supplied.\n    await umi.rpc.airdrop(umi.identity.publicKey, sol(2));\n\n    // derive the metadata account that will store our metadata data onchain\n\tconst metadataAccountAddress = await findMetadataPda(umi, {\n\t\tmint: mint,\n\t});\n\n\tconst tx = await createV1(umi, {\n\t\tmint,\n\t\tauthority: umi.identity,\n\t\tpayer: umi.identity,\n\t\tupdateAuthority: umi.identity,\n\t\tname: tokenMetadata.name,\n\t\tsymbol: tokenMetadata.symbol,\n\t\turi: tokenMetadata.uri,\n\t\tsellerFeeBasisPoints: percentAmount(5.5), // 5.5%\n\t\ttokenStandard: TokenStandard.Fungible,\n\t}).sendAndConfirm(umi);\n\n\tlet txSig = base58.deserialize(tx.signature);\n\tconsole.log(`https://explorer.solana.com/tx/${txSig}?cluster=devnet`);\n}\n\n// run the function\naddMetadata();\n```\n\n----------------------------------------\n\nTITLE: Setup Manager Instruction Implementation\nDESCRIPTION: Implements the setup_manager instruction that initializes the manager account and stores its bump seed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub fn setup_manager(ctx: Context<SetupManager>) -> Result<()> {\n    ctx.accounts.manager.bump = ctx.bumps.manager;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Deserializing Binary Schema in JavaScript\nDESCRIPTION: This snippet explains that for binary schema, which contains arbitrary data, you need to implement your own deserializer in JavaScript to parse the data into a format that your application can understand.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/external-plugins/app-data.md#2025-04-17_snippet_13\n\nLANGUAGE: js\nCODE:\n```\n// As the binary data is arbitrary you will need to include your own deserializer to\n// parse the data into a usable format your app/website will understand.\n```\n\n----------------------------------------\n\nTITLE: Installing Umi Package\nDESCRIPTION: This command installs the Umi package, which is a client-side library for interacting with the Solana blockchain. It simplifies the process of creating and sending transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/javascript/how-to-transfer-sol-on-solana.md#2025-04-17_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n\"npm i @metaplex-foundation/umi\"\n```\n\n----------------------------------------\n\nTITLE: Installing Solana CLI on Windows\nDESCRIPTION: Windows-specific command to download and install Solana CLI tools using the official release executable. Targets version 1.18.18 of the Solana toolkit.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\ncmd /c \"curl https://release.solana.com/v1.18.18/solana-install-init-x86_64-pc-windows-msvc.exe --output C:\\solana-install-tmp\\solana-install-init.exe --create-dirs\"\n```\n\n----------------------------------------\n\nTITLE: Creating RuleSet None in Rust for Royalties Plugin\nDESCRIPTION: This snippet shows how to create a RuleSet with no rules in Rust for the Royalties Plugin. It sets the RuleSet to 'None' when no specific rules are needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/royalties.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_core::types::RuleSet;\n\nlet ruleSet = RuleSet::None;\n```\n\n----------------------------------------\n\nTITLE: Closing a Gumdrop Airdrop and Recovering Unclaimed Tokens\nDESCRIPTION: Command for closing a Gumdrop airdrop after the claim period ends. This recovers any unclaimed tokens back to the authority's wallet. Requires the original Gumdrop keypair that was generated during creation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/general/spl-token-claim-airdrop-using-gumdrop.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nts-node gumdrop-cli.ts close \\\n  -e devnet \\\n  --base <GUMDROP_KEYPAIR> \\\n  --keypair <AUTHORITY_KEYPAIR> \\\n  --claim-integration transfer \\\n  --transfer-mint <TOKEN_MINT>\n```\n\n----------------------------------------\n\nTITLE: Initializing General Inscription in JavaScript\nDESCRIPTION: This code snippet shows how to initialize a non-tradable inscription for advanced use cases like gaming. It utilizes functions from '@metaplex-foundation/mpl-inscription' and requires `umi`, `generateSigner`, and a random shard number. It returns an initialized inscription that is not tradable, providing a base for adding data to it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/initialize.md#2025-04-17_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  findInscriptionMetadataPda,\n  findInscriptionShardPda,\n  initialize,\n} from '@metaplex-foundation/mpl-inscription'\n\nconst inscriptionAccount = generateSigner(umi)\n\nconst inscriptionMetadataAccount = await findInscriptionMetadataPda(umi, {\n  inscriptionAccount: inscriptionAccount.publicKey,\n})\nconst inscriptionShardAccount = await findInscriptionShardPda(umi, {\n  shardNumber: 0, //random number between 0 and 31\n})\n\nawait initialize(umi, {\n  inscriptionAccount,\n  inscriptionShardAccount,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Thawing All NFTs in Sugar CLI\nDESCRIPTION: Thaws all NFTs minted from the same Candy Machine. This command is useful for releasing all frozen assets at once.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/freeze.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsugar freeze thaw --all\n```\n\n----------------------------------------\n\nTITLE: Setting up Umi for Core Candy Machine Interaction\nDESCRIPTION: Configuring the Umi environment with a wallet from a local JSON file. This sets up the connection to Solana devnet via Metaplex Aura network and configures the signer identity for transactions.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { generateSigner, some, none, createSignerFromKeypair, signerIdentity, transactionBuilder, dateTime } from \"@metaplex-foundation/umi\";\nimport { mplCandyMachine as mplCoreCandyMachine } from '@metaplex-foundation/mpl-core-candy-machine';\nimport * as fs from 'fs';\n\n// We will be using Solana Devnet from the Metaplex Aura data network as the endpoint while also loading the `mplCoreCandyMachine()` plugin.\nconst umi = createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\")\n            .use(mplCoreCandyMachine());\n\n// Let's create a Keypair from our wallet json file that contains a secret key, and create a signer based on the created keypair\nconst walletFile = fs.readFileSync('./wallet.json');\n\nlet keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(walletFile));\nconst signer = createSignerFromKeypair(umi, keypair);\nconsole.log(\"Signer: \", signer.publicKey);\n\n// Set the identity and the payer to the given signer\numi.use(signerIdentity(signer));\n```\n\n----------------------------------------\n\nTITLE: Cost Comparison Table for cNFTs\nDESCRIPTION: Markdown table showing the cost breakdown for different scales of cNFT deployments on Solana, including storage costs, transaction costs, total costs, and cost per cNFT.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/index.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Number of cNFTs | Storage Cost | Transaction Cost | Total Cost | Cost per cNFT |\n| --------------- | ------------ | ---------------- | ---------- | ------------- |\n| 10,000          | 0.2222       | 0.05             | 0.2722     | 0.000027222   |\n| 100,000         | 0.2656       | 0.5              | 0.7656     | 0.000007656   |\n| 1,000,000       | 0.3122       | 5                | 5.3122     | 0.000005312   |\n| 10,000,000      | 0.4236       | 50               | 50.4236    | 0.000005042   |\n| 100,000,000     | 7.2205       | 500              | 507.2205   | 0.000005072   |\n| 1,000,000,000   | 7.2205       | 5,000            | 5007.2205  | 0.000005007   |\n```\n\n----------------------------------------\n\nTITLE: Configuring End Date Guard in Sugar for Core Candy Machine\nDESCRIPTION: This JSON snippet shows how to add the End Date guard configuration to the config.json file when using Sugar. It specifies the 'endDate' object with a 'date' property.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/end-date.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"endDate\" : {\n    \"date\": \"string\",\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Anchor Program in Bash\nDESCRIPTION: This command deploys the Anchor program to the specified cluster set in the anchor.toml file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nanchor deploy\n```\n\n----------------------------------------\n\nTITLE: Generate IDL and Client Command\nDESCRIPTION: Shell command to generate the IDL and initial client using pnpm.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/custom-guards/generating-client.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm run generate\n```\n\n----------------------------------------\n\nTITLE: Struct Serialization in TypeScript\nDESCRIPTION: Demonstrates how to create struct serializers with basic types and custom field mappings\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/serializers.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = {\n  name: string;\n  age: number;\n}\n\nstruct<Person>([\n  ['name', string()],\n  ['age', u32()],\n]);\n```\n\nLANGUAGE: typescript\nCODE:\n```\ntype Person = { name: string; age: number; }\ntype PersonArgs = { name: string; age?: number; }\n\nconst ageOr42 = mapSerializer(\n  u32(),\n  (age: number | undefined): number => age ?? 42,\n);\n\nstruct<PersonArgs, Person>([\n  ['name', string()],\n  ['age', ageOr42],\n]);\n```\n\n----------------------------------------\n\nTITLE: Installing MPL-Core Rust SDK\nDESCRIPTION: Command to add the MPL-Core Rust SDK to a Cargo project. This allows the use of the SDK in both scripts and Solana on-chain programs.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/sdk/rust.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-core\n```\n\n----------------------------------------\n\nTITLE: Installing Required Package: Umi-Bundle-Defaults\nDESCRIPTION: This snippet provides the command for installing the @metaplex-foundation/umi-bundle-defaults package, which includes default configurations for the Umi framework.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\n----------------------------------------\n\nTITLE: Installing Sugar from Crates.io (Bash)\nDESCRIPTION: This command installs Sugar directly from Crates.io using Cargo, Rust's package manager.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/installation.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo install sugar-cli\n```\n\n----------------------------------------\n\nTITLE: Creating Tree Configuration Using Local Script\nDESCRIPTION: Example of creating a tree configuration using the CreateTreeConfigBuilder. This script demonstrates setting up a Solana client, creating necessary keypairs, and submitting a transaction to create a tree configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/sdk/rust.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_bubblegum::{instructions::CreateTreeConfigBuilder, programs::{SPL_ACCOUNT_COMPRESSION_ID, SPL_NOOP_ID}};\nuse solana_client::{nonblocking::rpc_client, rpc_config::RpcSendTransactionConfig};\nuse solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey, signature::Keypair, signer::Signer, system_program, transaction::Transaction};\n\n#[tokio::main]\npub async fn create_tree(keypair: Keypair) {\n    let rpc_client = rpc_client::RpcClient::new(\"https://devnet.helius-rpc.com/?api-key=555f20ad-afaf-4a78-a889-244f281ab399\".to_string());\n\n    let payer = keypair;\n        \n\n    let asset = Keypair::new();\n\n    let merkle_tree = Keypair::new();\n\n    let tree_config = Pubkey::find_program_address(\n        &[\n            &merkle_tree.pubkey().to_bytes(),\n        ],\n        &mpl_bubblegum::ID,\n    );\n\n    let create_tree_config_ix = CreateTreeConfigBuilder::new()\n        .merkle_tree(merkle_tree.pubkey())\n        .tree_config(tree_config.0)\n        .payer(payer.pubkey())\n        .log_wrapper(SPL_NOOP_ID)\n        .compression_program(SPL_ACCOUNT_COMPRESSION_ID)\n        .system_program(system_program::ID)\n        .max_depth(20)\n        .max_buffer_size(1024)\n        .public(false)\n        .instruction();\n\n    let signers = vec![&asset, &payer];\n\n    let last_blockhash = rpc_client.get_latest_blockhash().await;\n\n    let create_tree_config_tx = Transaction::new_signed_with_payer(\n        &[create_tree_config_ix],\n        Some(&payer.pubkey()),\n        &signers,\n        last_blockhash.unwrap(),\n    );\n\n    let res = rpc_client\n        .send_transaction_with_config(&create_tree_config_tx, RpcSendTransactionConfig {\n            skip_preflight: false,\n            preflight_commitment: Some(CommitmentConfig::confirmed().commitment),\n            encoding: None,\n            max_retries: None,\n            min_context_slot: None,\n        })\n        .await\n        .unwrap();\n\n    println!(\"Signature: {:?}\", res)\n}\n```\n\n----------------------------------------\n\nTITLE: NFT Signing with Custom Keypair\nDESCRIPTION: Signs all NFTs using a specified creator keypair file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/sign.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar sign -k creator-keypair.json\n```\n\n----------------------------------------\n\nTITLE: Fetching Compressed NFT Proof\nDESCRIPTION: RPC call to fetch the proof of a compressed NFT using its asset ID\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/fetch-cnfts.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst rpcAssetProof = await umi.rpc.getAssetProof(assetId)\n```\n\n----------------------------------------\n\nTITLE: Basic CPI Invocation\nDESCRIPTION: Example of invoking a CPI call without PDA signer seeds.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nCreateV1CpiBuilder::new()\n        .asset(context.accounts,asset)\n        ...\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Checking Program Existence and Retrieving All Programs in TypeScript\nDESCRIPTION: Details how to check if a program exists in the repository and retrieve all registered programs using the has and all methods.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/programs.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Check if a program exists in the repository.\numi.programs.has('myProgram');\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Retrieve all programs in the repository.\numi.programs.all();\n```\n\n----------------------------------------\n\nTITLE: Burning NFT Assets with Anchor SPL\nDESCRIPTION: Shows NFT burning implementation using Anchor SPL 0.31.0, providing a simpler interface through the anchor-spl crate.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/burn.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{metadata::BurnNft, token::Mint};\n\n\n#[derive(Accounts)]\npub struct NftBurn<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    edition: AccountInfo<'info>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}\n\npub fn burn_nft_instruction(ctx: Context<NftBurn>) {\n\n        let owner = ctx.accounts.owner.to_account_info();\n        let metadata = ctx.accounts.metadata.to_account_info();\n        let mint = ctx.accounts.mint.to_account_info();\n        let token = ctx.accounts.token.to_account_info();\n        let edition = ctx.accounts.edition.to_account_info();\n        let spl_token = ctx.accounts.spl_token.to_account_info();\n        let metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\n        CpiContext::new(\n            metadata_program_id,\n            BurnNft {\n                metadata,\n                owner,\n                mint,\n                token,\n                edition,\n                spl_token,\n            },\n        );\n\n}\n```\n\n----------------------------------------\n\nTITLE: Sugar Mint with Specific Candy Machine\nDESCRIPTION: Command to specify a particular candy machine address for minting.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/airdrop.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint --candy-machine <CANDY_MACHINE>\n```\n\n----------------------------------------\n\nTITLE: Initializing CreateV1Builder in Rust\nDESCRIPTION: This snippet shows how to initialize the `CreateV1Builder` from the `mpl-core` crate. This builder is used to create a `CreateV1` instruction, which is part of creating a new asset on the Metaplex protocol. The `new()` function initializes the builder with default values.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nCreateV1Builder::new();\n```\n\n----------------------------------------\n\nTITLE: Installing mpl-toolbox Package via npm\nDESCRIPTION: Command to install the mpl-toolbox package using npm. This package is not included by default in Umi and needs to be installed separately.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/index.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/mpl-toolbox\n```\n\n----------------------------------------\n\nTITLE: Basic Sugar Airdrop Command\nDESCRIPTION: Basic command to initiate an airdrop using default cache.json and airdrop_list.json files.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/airdrop.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar airdrop\n```\n\n----------------------------------------\n\nTITLE: Distributing Funds with Wallet Model\nDESCRIPTION: Illustrates distributing funds in a Hydra wallet using the Wallet membership model by specifying the member and making a transaction through the distribute method.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst member1\n.\npublicKey = \"Member1.publicKey\";\nconst distributionBot = new Keypair();\n// This is the caller of the Distribute method, it can be a bot or a user,\n// they just need enough funds to pay for the transaction fee. If you're using\n// this code, airdrop a sol to distributionBot.\n\nlet distributeToMember1 = await fanoutSdk.distributeWalletMemberInstructions(\n  {\n    distributeForMint: false,\n    member: member1.publicKey,\n    fanout: fanout, // From initialization\n    payer: distributionBot.publicKey,\n  },\n);\n\nconst tx = await fanoutSdk.sendInstructions(\n  [...distMember1.instructions],\n  [distributionBot],\n  distributionBot.publicKey\n);\nif (!!tx.RpcResponseAndContext.value.err) {\n  const txdetails = await connection.getConfirmedTransaction(tx.TransactionSignature);\n  console.log(txdetails, tx.RpcResponseAndContext.value.err);\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Sugar CLI Commands\nDESCRIPTION: This command displays a list of available Sugar commands and their short descriptions. It shows the usage, options, and subcommands available in Sugar CLI.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/index.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsugar\n```\n\n----------------------------------------\n\nTITLE: Adding Members with NFT Model\nDESCRIPTION: This snippet demonstrates how to add members to a Hydra wallet using the NFT membership model, associating membership with an NFT mint address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/hydra/index.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst nftMintPublicKey = \"nftMintPublicKey\";\n\nconst init = await fanoutSdk.initializeFanout({\n  totalShares: 100,\n  name: `Test${Date.now()}`,\n  membershipModel: MembershipModel.NFT,\n});\n\nconst { membershipAccount } = await fanoutSdk.addMemberNft({\n  fanout: init.fanout,\n  fanoutNativeAccount: init.nativeAccount,\n  membershipKey: nftMintPublicKey,\n  shares: 10\n});\n\n// Add members until sum of shares = totalShares\n...\n```\n\n----------------------------------------\n\nTITLE: Checking Asset Burning Permission in JavaScript\nDESCRIPTION: This snippet shows how to use Core's lifecycle helpers to check if an authority has permission to burn an asset. It demonstrates Core's simplified approach to checking asset statuses.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/tm-differences.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst burningAllowed = canBurn(authority, asset, collection)\n```\n\n----------------------------------------\n\nTITLE: Generating Merkle Tree Data in TypeScript\nDESCRIPTION: Creates a Merkle tree with random addresses and amounts for 100 entries, serializes the data, and generates the Merkle root.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as anchor from \"@coral-xyz/anchor\";\nimport { Keypair, PublicKey, SystemProgram, LAMPORTS_PER_SOL, Transaction } from \"@solana/web3.js\";\nimport { HashingAlgorithm, MerkleTree } from \"svm-merkle-tree\";\n\n// Generate 100 random addresses and amount\nlet merkleTreeData = Array.from({ length: 100 }, () => ({\n  address: Keypair.generate().publicKey,              // Example random address\n  amount: Math.floor(Math.random() * 1000),           // Example random amount\n  isClaimed: false,                                   // Default value for isClaimed\n}));\n\n// Create Merkle Tree\nlet merkleTree = new MerkleTree(HashingAlgorithm.Keccak, 32);\n\nmerkleTreeData.forEach((entry) => {\n  // Serialize address, amount, and isClaimed in binary format\n  const entryBytes = Buffer.concat([\n    entry.address.toBuffer(),\n    Buffer.from(new Uint8Array(new anchor.BN(entry.amount).toArray('le', 8))),\n    Buffer.from([entry.isClaimed ? 1 : 0]),\n  ]);\n  merkleTree.add_leaf(entryBytes);\n});\n\nmerkleTree.merklize();\n\nconst merkleRoot = Array.from(merkleTree.get_merkle_root());\n```\n\n----------------------------------------\n\nTITLE: Manual Parameter Handling for Leaf Operations in TypeScript\nDESCRIPTION: Shows how to manually handle leaf operation parameters without using the helper function, demonstrating direct RPC calls and parameter construction for transfer operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/faq.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicKeyBytes } from '@metaplex-foundation/umi'\nimport { transfer } from '@metaplex-foundation/mpl-bubblegum'\n\nconst rpcAsset = await umi.rpc.getAsset(assetId)\nconst rpcAssetProof = await umi.rpc.getAssetProof(assetId)\n\nawait transfer(umi, {\n  leafOwner: leafOwnerA,\n  newLeafOwner: leafOwnerB.publicKey,\n  merkleTree: rpcAssetProof.tree_id,\n  root: publicKeyBytes(rpcAssetProof.root),\n  dataHash: publicKeyBytes(rpcAsset.compression.data_hash),\n  creatorHash: publicKeyBytes(rpcAsset.compression.creator_hash),\n  nonce: rpcAsset.compression.leaf_id,\n  index: rpcAssetProof.node_index - 2 ** rpcAssetProof.proof.length,\n  proof: rpcAssetProof.proof,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Validating SolPayment Guard\nDESCRIPTION: This code snippet demonstrates how to validate the `SolPayment` guard. It checks if the wallet has enough SOL to pay for the mint, based on the lamports specified in the guard configuration and the user's current SOL balance.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapOption } from '@metaplex-foundation/umi';\n\nconst solPayment = unwrapOption(candyGuard.guards.solPayment);\nif (solPayment){\n  if (solPayment.lamports.basisPoints > solBalance){\n    console.info(`Not enough SOL!`);\n    allowed = false;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Umi Default Bundle for Solana\nDESCRIPTION: Command to install the default bundle of Umi tools which includes common utilities and functions needed for Solana development.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/guides/javascript/how-to-create-1000000-nfts-on-solana.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @metaplex-foundation/umi-bundle-defaults\n```\n\n----------------------------------------\n\nTITLE: Minting Tokens with Token Metadata in Rust\nDESCRIPTION: This snippet shows how to mint tokens using the Mint V1 instruction of the Token Metadata program in Rust. It uses the mpl_token_metadata crate to create and send a transaction for minting a Non-Fungible token.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/mint.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::instructions::MintV1Builder;\nuse solana_rpc_client::rpc_client::RpcClient;\nuse solana_sdk::\n     message::Message,\n     transaction::Transaction,\n};\n\n// 1. client is a reference to the initialized RpcClient\n// 2. every account is specified by their pubkey\n\nlet client = ...;\n\nlet mint_ix = MintV1Builder::new()\n    .token(token)\n    .token_owner(Some(token_owner))\n    .metadata(metadata)\n    .master_edition(Some(master_edition))\n    .mint(mint)\n    .authority(update_authority)\n    .payer(payer)\n    .amount(1)\n    .instruction();\n\nlet message = Message::new(\n    &[mint_ix],\n    Some(&payer.pubkey()),\n);\n\nlet blockhash = client.get_latest_blockhash()?;\nlet mut tx = Transaction::new(&[update_authority, payer], message, blockhash);\nclient.send_and_confirm_transaction(&tx)?\n```\n\n----------------------------------------\n\nTITLE: Alternative Claiming Approach with PDA Receipt in Rust\nDESCRIPTION: This Rust code shows an alternative approach to tracking claims using Program Derived Addresses (PDAs) instead of updating the Merkle root. This avoids locking the airdrop state account but requires users to pay rent for the new PDA.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/anchor/token-claimer-smart-contract.md#2025-04-17_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct Claim<'info> {\n  //...\n  #[account(\n    init,\n    payer = signer,\n    seeds = [b\"user_receipt\".as_ref(), signer.key().to_bytes().as_ref()],\n    bump,\n    space = 8 + 32\n  )]\n  pub user_receipt: Account<'info, UserReceipt>,\n  //...\n}\n\n#[account]\npub struct UserReceipt {\n  pub user: Pubkey,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Candy Machine with NFT Payment Guard in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a Candy Machine using the NFT Payment guard. It specifies the required collection and destination for the NFT payment.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-payment.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ncreate(umi, {\n  // ...\n  guards: {\n    nftPayment: some({\n      requiredCollection: requiredCollectionNft.publicKey,\n      destination: umi.identity.publicKey,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Running Amman Start Command with Configuration\nDESCRIPTION: This snippet demonstrates how to run the Amman start command with a custom configuration file. If no config file is provided, Amman looks for an .ammanrc.js file or uses a default configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/cli-commands.md#2025-04-17_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx amman start <config.js>\n```\n\n----------------------------------------\n\nTITLE: Validating Start Date Guard\nDESCRIPTION: This code snippet demonstrates how to validate the `startDate` guard. It fetches the current Solana blocktime and compares it to the start date specified in the guard configuration. If the current time is before the start date, the mint is not allowed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { unwrapOption } from '@metaplex-foundation/umi';\n\nlet allowed = true;\n\n// fetch the current slot and read the blocktime\nconst slot = await umi.rpc.getSlot();\nlet solanaTime = await umi.rpc.getBlockTime(slot);\n\n// Check if a `default` startDate guard is attached\nconst startDate = unwrapOption(candyGuard.guards.startDate);\nif (startDate) {\n  // validate the startTime is in the future\n  if (solanaTime < startDate) {\n        console.info(`StartDate not reached!`);\n        allowed = false;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving MPL Core Assets by Authority using Metaplex Umi and DAS API\nDESCRIPTION: This snippet demonstrates how to fetch all MPL Core assets associated with a specific authority. It uses the Metaplex Umi framework and DAS API to query assets by authority. Replace the endpoint placeholder with your RPC endpoint and the PublicKey value with the target authority's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/das-api/core-extension/methods/get-assets-by-authority.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults';\nimport { dasApi } from '@metaplex-foundation/digital-asset-standard-api';\nimport { das }  from '@metaplex-foundation/mpl-core-das';\nimport { publicKey } from '@metaplex-foundation/umi';\n\nconst umi = createUmi('<ENDPOINT>').use(dasApi());\n\nconst assets = await das.getAssetsByAuthority(umi, {authority:  publicKey('<PublicKey>')});\nconsole.log(assets);\n```\n\n----------------------------------------\n\nTITLE: Using getAssetWithProof Helper for Leaf Operations in TypeScript\nDESCRIPTION: Demonstrates how to use the getAssetWithProof helper method from the Bubblegum Umi library to handle transfer operations. Shows how to manage leaf parameters and implement optional canopy truncation for optimizing transaction size.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/faq.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getAssetWithProof, transfer } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId, \n// {  truncateCanopy: true } // optional to prune the proofs \n);\nawait transfer(umi, {\n  ...assetWithProof,\n  leafOwner: leafOwnerA, // As a signer.\n  newLeafOwner: leafOwnerB.publicKey,\n}).sendAndConfirm(umi);\n\nawait transfer(umi, {\n  ...assetWithProof,\n  leafOwner: leafOwnerA, // As a signer.\n  newLeafOwner: leafOwnerB.publicKey,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Execute Instruction Overview in TypeScript\nDESCRIPTION: This snippet provides an overview of the execute instruction and its arguments, including the asset, collection, instructions, and optional signers.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/execute-asset-signing.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst executeIx = await execute(umi, {\n    {\n        // The asset via `fetchAsset()` that is signing the transaction.\n        asset: AssetV1,\n        // The collection via `fetchCollection()`\n        collection?: CollectionV1,\n        // Either a TransactionBuilder | Instruction[]\n        instructions: ExecuteInput,\n        // Additional Signers that will be required for the transaction/instructions.\n        signers?: Signer[]\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up Base Implementation\nDESCRIPTION: Initial setup including imports and wrapper function for NFT creation\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createProgrammableNft, mplTokenMetadata } from \"@metaplex-foundation/mpl-token-metadata\";\nimport {\n  createGenericFile,\n  generateSigner,\n  percentAmount,\n  signerIdentity,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { irysUploader } from \"@metaplex-foundation/umi-uploader-irys\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n// Create the wrapper function\nconst createNft = async () => {\n  ///\n  ///\n  ///  all our code will go in here\n  ///\n  ///\n}\n\n// run the wrapper function\ncreatNft()\n```\n\n----------------------------------------\n\nTITLE: Minting Token-2022 Tokens in Rust\nDESCRIPTION: Mints a Token-2022 token using Rust. Shows how to build and send a transaction to mint tokens using the Token-2022 program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/token-2022.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mpl_token_metadata::instructions::MintV1Builder;\nuse solana_rpc_client::rpc_client::RpcClient;\nuse solana_sdk::{\n     message::Message,\n     transaction::Transaction,\n};\n\n// 1. client is a reference to the initialized RpcClient\n// 2. every account is specified by their pubkey\n\nlet client = ...;\n\nlet mint_ix = MintV1Builder::new()\n    .token(token)\n    .token_owner(Some(token_owner))\n    .metadata(metadata)\n    .master_edition(Some(master_edition))\n    .mint(mint)\n    .authority(update_authority)\n    .payer(payer)\n    .spl_token_program(spl_token_2022::id())\n    .amount(1)\n    .instruction();\n\nlet message = Message::new(\n    &[mint_ix],\n    Some(&payer.pubkey()),\n);\n\nlet blockhash = client.get_latest_blockhash()?;\nlet mut tx = Transaction::new(&[update_authority, payer], message, blockhash);\nclient.send_and_confirm_transaction(&tx)?\n```\n\n----------------------------------------\n\nTITLE: Checking Account Existence with Umi\nDESCRIPTION: Demonstrates how to check if an account exists at a given address.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/accounts.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst accountExists = await umi.rpc.accountExists(myPublicKey);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Accounts for MPL-404 Hybrid Escrow Operations in JavaScript\nDESCRIPTION: This snippet shows how to set up the necessary accounts for Capture and Release operations in the MPL-404 Hybrid Escrow. It includes setting up collection, token, fee, and escrow accounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/guides/create-your-first-hybrid-collection.md#2025-04-17_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\n// Step 2: Escrow Accounts - Change these to your needs\nconst collection = publicKey('<YOUR-COLLECTION-ADDRESS>');\nconst token = publicKey('<YOUR-TOKEN-ADDRESS>');\nconst feeProjectAccount = publicKey('<YOUR-FEE-ADDRESS>');\nconst escrow = umi.eddsa.findPda(MPL_HYBRID_PROGRAM_ID, [\n    string({ size: 'variable' }).serialize('escrow'),\n    publicKeySerializer().serialize(collection),\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining Constants for US Market Trading Oracle in Rust\nDESCRIPTION: This code snippet defines constants used in the oracle protocol for US market trading hours, including time conversions and reward amounts.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/oracle-plugin-example.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst SECONDS_IN_AN_HOUR: i64 = 3600;\nconst SECONDS_IN_A_MINUTE: i64 = 60;\nconst SECONDS_IN_A_DAY: i64 = 86400;\n\nconst MARKET_OPEN_TIME: i64 = 14 * SECONDS_IN_AN_HOUR + 30 * SECONDS_IN_A_MINUTE; // 14:30 UTC == 9:30 EST\nconst MARKET_CLOSE_TIME: i64 = 21 * SECONDS_IN_AN_HOUR; // 21:00 UTC == 16:00 EST\nconst MARKET_OPEN_CLOSE_MARGIN: i64 = 15 * SECONDS_IN_A_MINUTE; // 15 minutes in seconds\nconst REWARD_IN_LAMPORTS: u64 = 10000000; // 0.001 SOL\n```\n\n----------------------------------------\n\nTITLE: Updating Staking Attributes for Unstaking in Metaplex\nDESCRIPTION: Checks if the asset is currently staked and updates the attributes by setting the 'staked' value to 0 and updating the 'stakedTime' to include the elapsed time since staking.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/web2-typescript-staking-example.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nif (stakedAttribute.value === \"0\") {\n    throw new Error(\"Asset is not staked\");\n} else {\n    const stakedTimeValue = parseInt(stakedTimeAttribute.value);\n    const stakedValue = parseInt(stakedAttribute.value);\n    const elapsedTime = new Date().getTime() - stakedValue;\n\n    assetAttribute.forEach((attr) => {\n        if (attr.key === \"stakedTime\") {\n            attr.value = (stakedTimeValue + elapsedTime).toString();\n        }\n        if (attr.key === \"staked\") {\n            attr.value = \"0\";\n        }\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring robots.txt for Metaplex Developer Hub\nDESCRIPTION: This robots.txt file allows all user agents to crawl the entire website and specifies the location of the sitemap. It uses standard robots.txt syntax to define crawling rules for web robots.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/public/robots.txt#2025-04-17_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nUser-agent: * \nDisallow:\n\nSitemap: https://developers.metaplex.com/sitemap.xml\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Response from Candy Machine Data Fetch\nDESCRIPTION: Example of the JSON data structure returned when fetching a Candy Machine from the blockchain. This includes details like the authority, mint authority, collection mint, items redeemed, and configuration settings.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"publicKey\": \"Ct5CWicvmjETYXarcUVJenfz3CCh2hcrCM3CMiB8x3k9\",\n    \"header\": {\n        \"executable\": false,\n        \"owner\": \"CMACYFENjoBMHzapRXyo1JZkVS6EtaDDzkjMrmQLvr4J\",\n        \"lamports\": {\n            \"basisPoints\": \"91814160\",\n            \"identifier\": \"SOL\",\n            \"decimals\": 9\n        },\n        \"rentEpoch\": \"18446744073709551616\",\n        \"exists\": true\n    },\n    \"discriminator\": [\n        51,\n        173,\n        177,\n        113,\n        25,\n        241,\n        109,\n        189\n    ],\n    \"authority\": \"Tes1zkZkXhgTaMFqVgbgvMsVkRJpq4Y6g54SbDBeKVV\",\n    \"mintAuthority\": \"ACJCHhsWCKw9Euu9nLdyxajqitvmwrXQMRWe2mrmva8u\",\n    \"collectionMint\": \"GPHD33NBaM8TgvbfgcxrusD6nyfhNLbeyKjxMRLAr9LM\",\n    \"itemsRedeemed\": \"13\",\n    \"data\": {\n        \"itemsAvailable\": \"16\",\n        \"maxEditionSupply\": \"0\",\n        \"isMutable\": true,\n        \"configLineSettings\": {\n            \"__option\": \"Some\",\n            \"value\": {\n                \"prefixName\": \"\",\n                \"nameLength\": 32,\n                \"prefixUri\": \"\",\n                \"uriLength\": 200,\n                \"isSequential\": false\n            }\n        },\n        \"hiddenSettings\": {\n            \"__option\": \"None\"\n        }\n    },\n    \"items\": [\n        {\n            \"index\": 0,\n            \"minted\": true,\n            \"name\": \"0.json\",\n            \"uri\": \"\"\n        }\n    ],\n    \"itemsLoaded\": 16\n}\n```\n\n----------------------------------------\n\nTITLE: Update Candy Machine and Guard Authority using Umi\nDESCRIPTION: Demonstrates how to update both the Candy Machine authority and its associated Candy Guard authority using the Umi library. Requires the current authority as a signer and the new authority's public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/manage.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSigner } from '@metaplex-foundation/umi'\nimport {\n  setCandyMachineAuthority,\n  setCandyGuardAuthority,\n} from '@metaplex-foundation/mpl-candy-machine'\n\nconst newAuthority = generateSigner(umi)\nawait setCandyMachineAuthority(umi, {\n  candyMachine: candyMachine.publicKey,\n  authority: currentAuthority,\n  newAuthority: newAuthority.publicKey,\n})\n  .add(\n    setCandyGuardAuthority(umi, {\n      candyGuard: candyMachine.mintAuthority,\n      authority: currentAuthority,\n      newAuthority: newAuthority.publicKey,\n    })\n  )\n  .sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Minting with Asset Payment Multi Guard in JavaScript\nDESCRIPTION: This code shows how to mint from a Candy Machine with Asset Payment Multi guard by providing the necessary mint arguments. It specifies which assets to use for payment, the required collection, the destination address, and the number of assets required.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/asset-payment-multi.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nmintV1(umi, {\n  // ...\n  mintArgs: {\n    assetPaymentMulti: some({\n      requiredCollection: publicKey(requiredCollection),\n      destination,\n      assets: [firstAssetToSend.publicKey, secondAssetToSend.publicKey],\n      num: 2\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Allowlist Guard Route\nDESCRIPTION: This code snippet demonstrates how to execute the route instruction for the `Allowlist` guard. It checks if the allowlist proof is null, and if so, it calls the `route` function with the appropriate parameters, including the merkle root and merkle proof.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-ui.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  getMerkleRoot,\n  getMerkleProof,\n  route\n} from \"@metaplex-foundation/mpl-core-candy-machine\";\nimport {\n  publicKey,\n} from \"@metaplex-foundation/umi\";\n\n// assuming you fetched the AllowListProof as described above\nif (allowListProof === null) { \n  route(umi, {\n    guard: \"allowList\",\n    candyMachine: candyMachine.publicKey,\n    candyGuard: candyMachine.mintAuthority,\n    group: \"default\", // Add your guard label here\n    routeArgs: {\n      path: \"proof\",\n      merkleRoot: getMerkleRoot(allowlist),\n      merkleProof: getMerkleProof(allowlist, publicKey(umi.identity)),\n    },\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Imports and Wrapper Function for Core NFT Asset Creation\nDESCRIPTION: Defines all necessary imports and creates a wrapper function to encapsulate the NFT creation process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/javascript/how-to-create-a-core-nft-asset-with-javascript.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { create, mplCore } from '@metaplex-foundation/mpl-core'\nimport {\n  createGenericFile,\n  generateSigner,\n  signerIdentity,\n  sol,\n} from '@metaplex-foundation/umi'\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { irysUploader } from '@metaplex-foundation/umi-uploader-irys'\nimport { base58 } from '@metaplex-foundation/umi/serializers'\nimport fs from 'fs'\nimport path from 'path'\n\n// Create the wrapper function\nconst createNft = async () => {\n  ///\n  ///\n  ///  all our code will go in here\n  ///\n  ///\n}\n\n// run the wrapper function\ncreateNft()\n```\n\n----------------------------------------\n\nTITLE: Accessing Umi in .tsx Files\nDESCRIPTION: This code snippet demonstrates how to access the Umi instance and its signer from the Zustand store in a TypeScript JSX file. The purpose is to apply the signer identity to Umi, facilitating blockchain operations that require user identification.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = useUmiStore().umi\nconst signer = useUmiStore().signer\numi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Defining Create Event Arguments Structure in Rust\nDESCRIPTION: This code defines the structure for the arguments passed to the Create Event instruction. It includes fields for event details such as name, URI, city, venue, artist, date, time, and capacity.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub struct CreateEventArgs {\n   pub name: String,\n   pub uri: String,\n   pub city: String,\n   pub venue: String,\n   pub artist: String,\n   pub date: String,\n   pub time: String,\n   pub capacity: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Burn Guard in Sugar JSON\nDESCRIPTION: This JSON snippet shows how to configure the Token Burn guard in the Sugar config.json file. It includes the amount of tokens to burn and the mint account public key.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guards/token-burn.md#2025-04-17_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n\"tokenBurn\" : {\n    \"amount\": number in basis points (e.g. 1000 for 1 Token that has 3 decimals),\n    \"mint\": \"<PUBKEY>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Redeeming a Compressed NFT using Bubblegum SDK\nDESCRIPTION: Uses the Metaplex Bubblegum SDK to redeem a Compressed NFT, which creates a Voucher account and removes the leaf from the Bubblegum tree. This is the first step in the decompression process.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/decompress-cnfts.md#2025-04-17_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getAssetWithProof, redeem } from '@metaplex-foundation/mpl-bubblegum'\n\nconst assetWithProof = await getAssetWithProof(umi, assetId)\nawait redeem(umi, {\n  ...assetWithProof,\n  leafOwner: currentLeafOwner,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Fetching NftMintCounter Account in JavaScript\nDESCRIPTION: This code snippet demonstrates how to fetch the NftMintCounter account for validation purposes when using the NFT Mint Limit guard.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guards/nft-mint-limit.md#2025-04-17_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { \n  findNftMintCounterPda,\n  fetchNftMintCounter\n } from \"@metaplex-foundation/mpl-core-candy-machine\";\n\nconst pda = findNftMintCounterPda(umi, {\n  id: 1, // The nftMintLimit id you set in your guard config\n  mint: asset.publicKey, // The address of the nft your user owns\n  candyMachine: candyMachine.publicKey,\n  // or candyMachine: publicKey(\"Address\") with your CM Address\n  candyGuard: candyMachine.mintAuthority\n  // or candyGuard: publicKey(\"Address\") with your candyGuard Address\n});\n      \nconst nftMintCounter = fetchNftMintCounter(umi, pda)\n```\n\n----------------------------------------\n\nTITLE: Adding a Guard to Candy Machine\nDESCRIPTION: Command to add the configured guard to the Candy Machine, allowing users to interact with it according to the specified rules.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/guides/create-an-nft-collection-on-solana-with-candy-machine.md#2025-04-17_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nsugar guard add\n```\n\n----------------------------------------\n\nTITLE: Full example of using TransferV1CpiBuilder in Rust\nDESCRIPTION: Provides a complete example of leveraging the TransferV1CpiBuilder, showing how to gather all necessary parameters and invoke the CPI call in a single operation.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/how-to-cpi-into-a-metaplex-program.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new()\n        .asset(ctx.accounts.asset)\n        .collection(context.accounts.collection)\n        .payer(context.accounts.payer)\n        .authority(context.accounts.authority)\n        .new_owner(context.accounts.new_owner)\n        .system_program(context.accounts.system_program)\n        .invoke()\n```\n\n----------------------------------------\n\nTITLE: Connecting Wallet Adapter\nDESCRIPTION: TypeScript code for connecting a wallet adapter to Umi.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/getting-started/index.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createUmi } from '@metaplex-foundation/umi-bundle-defaults'\nimport { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters'\nimport { useWallet } from '@solana/wallet-adapter-react'\n\nconst wallet = useWallet()\n\nconst umi = createUmi('https://api.devnet.solana.com')\n\n// Register Wallet Adapter to Umi\numi.use(walletAdapterIdentity(wallet))\n```\n\n----------------------------------------\n\nTITLE: Updating Assets - Full Asset Object Requirement\nDESCRIPTION: Illustrates the new requirement of passing full asset objects instead of just public keys for lifecycle operations.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/core-js-sdk-v1-0.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = publicKey('11111111111111111111111111111111')\n\nawait updateV1(umi, {\n  asset, // Takes a publicKey\n  newName: 'New Asset Name',\n  newUri: 'https://example.com/new-uri',\n}).sendAndConfirm(umi)\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst asset = await fetchAssetV1(umi, asset)\n\nawait update(umi, {\n  asset, // Takes the entire Asset object.\n  name: 'New Asset Name',\n  uri: 'https://example.com/new-uri',\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Getting Help for a Specific Sugar Command\nDESCRIPTION: This command demonstrates how to get detailed help information for a specific Sugar command, in this case, the 'deploy' command. It displays the usage and available options for the deploy command.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/index.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar help deploy\n```\n\n----------------------------------------\n\nTITLE: Adding Amman to Package.json Scripts\nDESCRIPTION: Script configuration for package.json to easily start Amman. This allows running the validator with a simple npm script command rather than using npx directly.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/amman/getting-started.md#2025-04-17_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n\"scripts\": {\n    ...\n    \"amman:start\": \"npx amman start\"\n  },\n```\n\n----------------------------------------\n\nTITLE: Trim JSON Fields - Bash\nDESCRIPTION: Trims deprecated or unnecessary fields from NFT JSON data to save costs during the inscription process. This command can be adjusted to specify which fields to remove.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/inscription/getting-started/cli.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm cli compress json --fields symbol\n```\n\n----------------------------------------\n\nTITLE: Cloning Metaplex Next.js Tailwind Template\nDESCRIPTION: This shell command clones the Metaplex Next.js Tailwind template repository from GitHub. It requires Git to be installed on your local machine. The command downloads the template into the current directory.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/metaplex-foundation/metaplex-nextjs-tailwind-template.git\n```\n\n----------------------------------------\n\nTITLE: Plugin Lifecycle Validation Table - Add Plugin\nDESCRIPTION: Table showing plugin validation rules for adding new plugins\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/plugins/index.md#2025-04-17_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Plugin          | Action      | Conditions  |\n| --------------- | ----------- | ----------- |\n| Royalties       | Can Reject  | Ruleset     |\n| Update Delegate | Can Approve | isAuthority |\n```\n\n----------------------------------------\n\nTITLE: Comparing Published Hash with Cache File in Sugar CLI\nDESCRIPTION: This command compares a published hash value with the value from the default cache.json file. It's useful for verifying the integrity of the cache file.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/hash.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar hash --compare 44oZ3goi9ivakeUnbjWbWJpvdgcWCrsi\n```\n\n----------------------------------------\n\nTITLE: Downloading Solana Accounts\nDESCRIPTION: CLI command for downloading specific accounts from a source cluster to use in local validator testing, with configurable output format and destination.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsolana account -u <source cluster> --output <output format> --output-file <destination file name/path> <address of account to fetch>\n```\n\n----------------------------------------\n\nTITLE: Thawing Individual NFT in Sugar CLI\nDESCRIPTION: Thaws a specific NFT using its mint address. This command is used to release a single frozen asset after the freeze period.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/freeze.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsugar freeze thaw <NFT MINT>\n```\n\n----------------------------------------\n\nTITLE: Manager Account Implementation\nDESCRIPTION: Implements the Manager account structure with space allocation for storing the bump seed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/onchain-ticketing-with-appdata.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[account]\npub struct Manager {\n    pub bump: u8,\n}\n\nimpl Space for Manager {\n    const INIT_SPACE: usize = 8 + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Metadata Data Hash Implementation in Rust\nDESCRIPTION: Reference to the data hash implementation that represents the compressed NFT's metadata in the Bubblegum program.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/concurrent-merkle-trees.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlib.rs#L450\n```\n\n----------------------------------------\n\nTITLE: Configuring Algolia DocSearch Environment Variables\nDESCRIPTION: Environment variables required for setting up Algolia DocSearch global search functionality in the Metaplex Developer Hub application.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nNEXT_PUBLIC_DOCSEARCH_APP_ID=\nNEXT_PUBLIC_DOCSEARCH_API_KEY=\nNEXT_PUBLIC_DOCSEARCH_INDEX_NAME=\n```\n\n----------------------------------------\n\nTITLE: Starting Local Solana Validator\nDESCRIPTION: Command to launch a local Solana test validator, which creates a sandboxed blockchain environment on localhost:8899 for development and testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/setup-a-local-validator.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsolana-test-validator\n```\n\n----------------------------------------\n\nTITLE: Building Anchor Workspace in Bash\nDESCRIPTION: This command builds the entire Anchor workspace, preparing it for deployment and testing.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/how-to-create-a-core-nft-asset-with-anchor.md#2025-04-17_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nanchor build\n```\n\n----------------------------------------\n\nTITLE: Initializing TransferV1 CPI Builder in Rust\nDESCRIPTION: Shows how to initialize a new TransferV1 CPI Builder instance by passing the program AccountInfo.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/rust/working-with-rust.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nTransferV1CpiBuilder::new(ctx.accounts.mpl_core_program);\n```\n\n----------------------------------------\n\nTITLE: Installing Umi framework and Candy Machine JavaScript library\nDESCRIPTION: This command installs the necessary dependencies for using the Candy Machine JavaScript SDK, including Umi framework and related packages.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/getting-started/js.md#2025-04-17_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install \\\n  @metaplex-foundation/umi \\\n  @metaplex-foundation/umi-bundle-defaults \\\n  @solana/web3.js@1 \\\n  @metaplex-foundation/mpl-candy-machine\n```\n\n----------------------------------------\n\nTITLE: Initializing NPM Project\nDESCRIPTION: Basic npm project initialization command for setting up the development environment\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/token-metadata/guides/javascript/create-an-nft.md#2025-04-17_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nnpm init\n```\n\n----------------------------------------\n\nTITLE: Sending GET Request with Abort Signal\nDESCRIPTION: Demonstrates sending a GET request with an abort signal to allow cancellation of the HTTP request\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/http-requests.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait umi.http.send(request().get('https://example.com/users').withAbortSignal(mySignal));\n```\n\n----------------------------------------\n\nTITLE: Sugar Mint with Custom Cache\nDESCRIPTION: Command to specify a custom cache file instead of using the default cache.json.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/candy-machine/sugar/commands/airdrop.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsugar mint --cache <CACHE>\n```\n\n----------------------------------------\n\nTITLE: Freezing Address Lookup Table in Umi\nDESCRIPTION: This instruction allows freezing a LUT, making it immutable. It uses the findAddressLookupTablePda function to locate the LUT and the freezeLut function to freeze it.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/umi/toolbox/address-lookup-table.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { findAddressLookupTablePda, freezeLut } from '@metaplex-foundation/mpl-toolbox'\n\n// The authority and slot used to create the LUT.\nconst lutAddress = findAddressLookupTablePda(umi, { authority, recentSlot })\n\nawait freezeLut(umi, {\n  authority,\n  address: lutAddress,\n}).sendAndConfirm(umi)\n```\n\n----------------------------------------\n\nTITLE: Creators Struct Implementation in Rust\nDESCRIPTION: Reference to the creators structure implementation in the Bubblegum program's metaplex adapter.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/bubblegum/concurrent-merkle-trees.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nmetaplex_adapter.rs#L103\n```\n\n----------------------------------------\n\nTITLE: Installing Metaplex Core via Cargo\nDESCRIPTION: Command to add the mpl-core dependency using cargo\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/using-core-in-anchor.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo add mpl-core\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages for Core Candy Machine\nDESCRIPTION: Command to install the necessary npm packages for interacting with Core Candy Machine, including Umi and related libraries.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core-candy-machine/guides/create-a-core-candy-machine-with-hidden-settings.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nnpm i @metaplex-foundation/umi @metaplex-foundation/umi-bundle-defaults @metaplex-foundation/mpl-core-candy-machine\n```\n\n----------------------------------------\n\nTITLE: Accessing Umi in .ts Files\nDESCRIPTION: This code snippet demonstrates how to retrieve the Umi instance and its signer from the Zustand store in a TypeScript file. This is useful for non-React code where direct interaction with Umi's functionalities is needed.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/guides/templates/metaplex-nextjs-tailwind-template.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst umi = useUmiStore.getState().umi\nconst signer = useUmiStore.getState().signer\numi.use(signerIdentity(signer))\n```\n\n----------------------------------------\n\nTITLE: Defining Stake Account Structure in Anchor\nDESCRIPTION: This code defines the Stake account structure used for both stake and unstake instructions in the Anchor program. It includes necessary account constraints and uses Metaplex Core types.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/core/guides/anchor/anchor-staking-example.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Accounts)]\npub struct Stake<'info> {\n    pub owner: Signer<'info>,\n    pub update_authority: Signer<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(\n        mut,\n        has_one = owner,\n        constraint = asset.update_authority == UpdateAuthority::Collection(collection.key()),\n    )]\n    pub asset: Account<'info, BaseAssetV1>,\n    #[account(\n        mut,\n        has_one = update_authority,\n    )]\n    pub collection: Account<'info, BaseCollectionV1>,\n    #[account(address = CORE_PROGRAM_ID)]\n    /// CHECK: this will be checked by core\n    pub core_program: UncheckedAccount<'info>,\n    pub system_program: Program<'info, System>,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Metaplex Developer Hub in Bash\nDESCRIPTION: Commands for installing npm dependencies and setting up environment variables for the Metaplex Developer Hub application.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\ncp .env.example .env.local\n```\n\n----------------------------------------\n\nTITLE: Running Development Server for Metaplex Developer Hub in Bash\nDESCRIPTION: Command to start the development server for the Metaplex Developer Hub application.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Setting Escrow Name\nDESCRIPTION: Shows how to set the name field for the escrow configuration.\nSOURCE: https://github.com/metaplex-foundation/developer-hub/blob/main/src/pages/mpl-hybrid/update-escrow.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nname: \"My Test Escrow\"\n```"
  }
]