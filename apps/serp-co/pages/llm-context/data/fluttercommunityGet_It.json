[
  {
    "owner": "fluttercommunity",
    "repo": "get_it",
    "content": "TITLE: Registering Singletons and Lazy Singletons\nDESCRIPTION: Registers an AppModel singleton and a RESTAPI lazy singleton with GetIt, using both `getIt` and `GetIt.I`. This shows how to register different types of singletons using both instance and factory functions.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\ngetIt.registerSingleton<AppModel>(AppModelImplementation());\ngetIt.registerLazySingleton<RESTAPI>(() => RestAPIImplementation());\n\n// if you want to work just with the singleton:\nGetIt.instance.registerSingleton<AppModel>(AppModelImplementation());\nGetIt.I.registerLazySingleton<RESTAPI>(() => RestAPIImplementation());\n\n/// `AppModel` and `RESTAPI` are both abstract base classes in this example\n```\n\n----------------------------------------\n\nTITLE: Accessing Registered Objects (Generic)\nDESCRIPTION: Demonstrates how to access registered objects using the `get<Type>()` method of the GetIt instance. Also shows the callable class shorthand.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_5\n\nLANGUAGE: Dart\nCODE:\n```\nvar myAppModel = getIt.get<AppModel>();\n```\n\n----------------------------------------\n\nTITLE: Getting GetIt instance\nDESCRIPTION: Retrieves the singleton instance of GetIt using both the `GetIt.instance` and `GetIt.I` shortcuts.  This shows how to obtain the GetIt instance to register and retrieve dependencies.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nGetIt getIt = GetIt.instance;\n\n//There is also a shortcut (if you don't like it just ignore it):\nGetIt getIt = GetIt.I;\n```\n\n----------------------------------------\n\nTITLE: Accessing Registered Objects (Callable)\nDESCRIPTION: Demonstrates a shorter way to access registered objects using the callable class feature of GetIt.  Shows how to access singletons using the GetIt instance and shortcut.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_6\n\nLANGUAGE: Dart\nCODE:\n```\nvar myAppModel = getIt<AppModel>();\n\n// as Singleton:\nvar myAppModel = GetIt.instance<AppModel>();\nvar myAppModel = GetIt.I<AppModel>();\n```\n\n----------------------------------------\n\nTITLE: Register Factory with Parameters Dart\nDESCRIPTION: Registers a type so that a new instance will be created on each call of [get] on that type based on up to two parameters provided to [get()].\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_33\n\nLANGUAGE: Dart\nCODE:\n```\n/// registers a type so that a new instance will be created on each call of [get] on that type based on\n/// up to two parameters provided to [get()]\n/// [T] type to register\n/// [P1] type of param1\n/// [P2] type of param2\n/// if you use only one parameter pass void here\n/// [factoryfunc] factory function for this type that accepts two parameters\n/// [instanceName] if you provide a value here your factory gets registered with that\n/// name instead of a type. This should only be necessary if you need to register more\n/// than one instance of one type.\n///\n/// example:\n///    getIt.registerFactoryParam<TestClassParam,String,int>((s,i)\n///        => TestClassParam(param1:s, param2: i));\n///\n/// if you only use one parameter:\n///\n///    getIt.registerFactoryParam<TestClassParam,String,void>((s,_)\n///        => TestClassParam(param1:s);\nvoid registerFactoryParam<T,P1,P2>(FactoryFuncParam<T,P1,P2> factoryfunc, {String instanceName});\n```\n\n----------------------------------------\n\nTITLE: Accessing registered objects\nDESCRIPTION: Accesses the AppModel singleton instance registered with GetIt. This snippet shows how to retrieve a registered object and use its methods within a Flutter widget.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nMaterialButton(\n  child: Text(\"Update\"),\n  onPressed: getIt<AppModel>().update   // given that your AppModel has a method update\n),\n```\n\n----------------------------------------\n\nTITLE: Async Singleton Registration Example Dart\nDESCRIPTION: Demonstrates different ways to register async Singletons and how the startup page displays a `CircularProgressIndicator` until all services have been created using `getIt.allReady()`.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_27\n\nLANGUAGE: Dart\nCODE:\n```\n  class RestService {\n    Future<RestService> init() async {\n      Future.delayed(Duration(seconds: 1));\n      return this;\n    }\n  }\n\n  final getIt = GetIt.instance;\n\n  /// in your setup function:\n  getIt.registerSingletonAsync<ConfigService>(() async {\n    final configService = ConfigService();\n    await configService.init();\n    return configService;\n  });\n\n  getIt.registerSingletonAsync<RestService>(() async => RestService().init());\n  // here we asume an async factory function `createDbServiceAsync`\n  getIt.registerSingletonAsync<DbService>(createDbServiceAsync);\n\n\n  /// ... in your startup page:\n  return FutureBuilder(\n      future: getIt.allReady(),\n      builder: (BuildContext context, AsyncSnapshot snapshot) {\n        if (snapshot.hasData) {\n          return Scaffold(\n            body: Center(\n              child: Text('The first real Page of your App'),\n            ),\n          );\n        } else {\n          return CircularProgressIndicator();\n        }\n      });\n```\n\n----------------------------------------\n\nTITLE: Await Asynchronous Initializations Dart\nDESCRIPTION: The `allReady` function returns a Future that completes after all asynchronous singletons have completed their factory functions or after a timeout. The `ignorePendingAsyncCreation` parameter controls whether to ignore pending asynchronous creations.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_26\n\nLANGUAGE: Dart\nCODE:\n```\n  Future<void> allReady({Duration timeout, bool ignorePendingAsyncCreation = false});\n```\n\n----------------------------------------\n\nTITLE: Register Async Factory with Parameters Dart\nDESCRIPTION: Registers an asynchronous type so that a new instance will be created on each call of [get] on that type based on up to two parameters provided to [get()].\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_34\n\nLANGUAGE: Dart\nCODE:\n```\n  void registerFactoryParamAsync<T,P1,P2>(FactoryFuncParamAsync<T,P1,P2> factoryfunc, {String instanceName});\n```\n\n----------------------------------------\n\nTITLE: Register Asynchronous Singleton Dart\nDESCRIPTION: Registers an asynchronous singleton using a factory function that returns a Future. It allows specifying dependencies that must be initialized before the factory function is executed. The `signalsReady` parameter controls when the singleton is considered ready.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_25\n\nLANGUAGE: Dart\nCODE:\n```\n  void registerSingletonAsync<T>(FactoryFuncAsync<T> factoryfunc,\n      {String instanceName,\n      Iterable<Type> dependsOn,\n      bool signalsReady = false});\n```\n\n----------------------------------------\n\nTITLE: Unit Test Setup with GetIt Dart\nDESCRIPTION: Shows how to access dependencies within a class for testing purposes.  Either get dependencies from GetIt or inject them directly allowing for mocking.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_36\n\nLANGUAGE: Dart\nCODE:\n```\nGetIt getIt = GetIt.instance;\n\nclass UserManager {\n  AppModel appModel;\n  DbService dbService;\n\n  UserManager({AppModel? appModel, DbService? dbService}) {\n    this.appModel = appModel ?? getIt.get<AppModel>();\n    this.dbService = dbService ?? getIt.get<DbService>();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Named Registration: Registering and Accessing Named Instances (Dart)\nDESCRIPTION: This example shows how to register multiple instances of the same type with different names using the `instanceName` parameter in `registerSingletonAsync`. It then demonstrates how to access these named instances using `get` with the corresponding `instanceName`. This allows for registering and retrieving different implementations of the same interface.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_38\n\nLANGUAGE: Dart\nCODE:\n```\n  abstract class RestService {}\n  class RestService1 implements RestService{\n    Future<RestService1> init() async {\n      Future.delayed(Duration(seconds: 1));\n      return this;\n    }\n  }\n  class RestService2 implements RestService{\n    Future<RestService2> init() async {\n      Future.delayed(Duration(seconds: 1));\n      return this;\n    }\n  }\n\n  getIt.registerSingletonAsync<RestService>(() async => RestService1().init(), instanceName : \"restService1\");\n  getIt.registerSingletonAsync<RestService>(() async => RestService2().init(), instanceName : \"restService2\");\n\n  getIt.registerSingletonWithDependencies<AppModel>(\n      () {\n          RestService restService1 = GetIt.I.get<RestService>(instanceName: \"restService1\");\n          return AppModelImplmentation(restService1);\n      },\n      dependsOn: [InitDependency(RestService, instanceName:\"restService1\")],\n  );\n```\n\n----------------------------------------\n\nTITLE: Access by Runtime Type: Retrieving Instance without Generic Parameter (Dart)\nDESCRIPTION: This snippet demonstrates how to retrieve an instance from GetIt using the optional `type` parameter in the `get` function when the type is not known at compile time. This allows accessing registered instances without specifying a generic type parameter. The code registers a `TestClass` instance and retrieves it using its runtime type.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_39\n\nLANGUAGE: Dart\nCODE:\n```\n    getIt.registerSingleton(TestClass());\n\n    final instance1 = getIt.get(type: TestClass);\n\n    expect(instance1 is TestClass, true);\n```\n\n----------------------------------------\n\nTITLE: Integration Test: Mock Service Registration (Dart)\nDESCRIPTION: This code snippet demonstrates how to register either a mocked or a real implementation of a service in GetIt based on a `testing` flag. This is useful for integration tests where you want to use a mock implementation instead of the real one.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_37\n\nLANGUAGE: Dart\nCODE:\n```\n  if (testing) {\n    getIt.registerSingleton<AppModel>(AppModelMock());\n  } else {\n    getIt.registerSingleton<AppModel>(AppModelImplementation());\n  }\n```\n\n----------------------------------------\n\nTITLE: Get Asynchronous Instance (Dart)\nDESCRIPTION: This snippet shows how to get an instance created by an asynchronous factory or a singleton that is not ready with its initialization, using `getAsync`. This allows awaiting the creation of the requested new instance. An optional `instanceName` can be provided.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_24\n\nLANGUAGE: Dart\nCODE:\n```\n/// Returns a Future of an instance that is created by an async factory or a Singleton that is\n/// not ready with its initialization.\nFuture<T> getAsync<T>([String instanceName]);\n```\n\n----------------------------------------\n\nTITLE: Register Async Singletons with Dependencies Dart\nDESCRIPTION: Registers asynchronous singletons with dependencies using the `dependsOn` parameter. This ensures that the registration waits for the completion of the types defined in `dependsOn` before creating the singleton.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_28\n\nLANGUAGE: Dart\nCODE:\n```\n  getIt.registerSingletonAsync<ConfigService>(() async {\n    final configService = ConfigService();\n    await configService.init();\n    return configService;\n  });\n\n  getIt.registerSingletonAsync<RestService>(() async => RestService().init());\n\n  getIt.registerSingletonAsync<DbService>(createDbServiceAsync,\n      dependsOn: [ConfigService]);\n\n  getIt.registerSingletonWithDependencies<AppModel>(\n      () => AppModelImplmentation(),\n      dependsOn: [ConfigService, DbService, RestService]);\n```\n\n----------------------------------------\n\nTITLE: Check Singleton Ready State Dart\nDESCRIPTION: Returns a Future that completes if the instance of a Singleton, defined by Type [T] or by name [instanceName] or passing the an existing [instance], is ready. If a [timeout] is passed, a [WaitingTimeOutException] will be thrown if the instance is not ready in the given time.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_30\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Returns a Future that completes if the instance of a Singleton, defined by Type [T] or\n  /// by name [instanceName] or passing the an existing [instance], is ready\n  /// If you pass a [timeout], a [WaitingTimeOutException] will be thrown if the instance\n  /// is not ready in the given time. The Exception contains details on which Singletons are\n  /// not ready at that time.\n  /// [callee] optional parameter which makes debugging easier. Pass `this` in here.\n  Future<void> isReady<T>({\n    Object instance,\n    String instanceName,\n    Duration timeout,\n    Object callee,\n  });\n```\n\n----------------------------------------\n\nTITLE: Register Asynchronous Factory (Dart)\nDESCRIPTION: This snippet demonstrates how to register an asynchronous factory using `registerFactoryAsync`. This is useful when a factory needs to call an async function. The `func` parameter is the factory function, and `instanceName` allows registering the factory with a name instead of a type when multiple instances of the same type are needed.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_23\n\nLANGUAGE: Dart\nCODE:\n```\n/// [T] type to register\n/// [func] factory function for this type\n/// [instanceName] if you provide a value here your factory gets registered with that\n/// name instead of a type. This should only be necessary if you need to register more\n/// than one instance of one type.\nvoid registerFactoryAsync<T>(FactoryFuncAsync<T> func, {String instanceName});\n```\n\n----------------------------------------\n\nTITLE: Register Singleton with InitDependency Dart\nDESCRIPTION: Example of registering a Singleton with dependencies specified using the InitDependency class which allows you to specify a dependency based on type and instance name.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_29\n\nLANGUAGE: Dart\nCODE:\n```\n  getIt.registerSingletonAsync<RestService>(() async => RestService().init(), instanceName:\"rest1\");\n\n  getIt.registerSingletonWithDependencies<AppModel>(\n      () => AppModelImplmentation(),\n      dependsOn: [InitDependency(RestService, instanceName:\"rest1\")]);\n```\n\n----------------------------------------\n\nTITLE: Push New Scope in GetIt (Dart)\nDESCRIPTION: This snippet demonstrates how to create a new registration scope in GetIt. Types registered within the new scope will shadow any previous registrations of the same type. It allows for managing object lifetimes.  `scopeName` allows popping scopes above a named scope. `dispose` function gets called when popping the scope.  `init` lets you register objects immediately after pushing.  `isFinal` ensures that objects can only be registered inside the `init` function.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_14\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Creates a new registration scope. If you register types after creating\n  /// a new scope they will hide any previous registration of the same type.\n  /// Scopes allow you to manage different live times of your Objects.\n  /// [scopeName] if you name a scope you can pop all scopes above the named one\n  /// by using the name.\n  /// [dispose] function that will be called when you pop this scope. The scope\n  /// is still valid while it is executed\n  /// [init] optional function to register Objects immediately after the new scope is\n  /// pushed. This ensures that [onScopeChanged] will be called after their registration\n  /// if [isFinal] is set to true, you can't register any new objects in this scope after\n  /// this call. In Other words you have to register the objects for this scope inside\n  /// [init] if you set [isFinal] to true. This is useful if you want to ensure that\n  /// no new objects are registered in this scope by accident which could lead to race conditions\n  void pushNewScope({void Function(GetIt getIt)? init,String scopeName, ScopeDisposeFunc dispose});\n```\n\n----------------------------------------\n\nTITLE: Reset Lazy Singleton in GetIt (Dart)\nDESCRIPTION: This snippet demonstrates how to reset a lazy singleton's instance in GetIt, allowing it to be recreated on the next access. It uses either the instance, its registered type, or its registration name to select the lazy singleton to reset. A `disposingFunction` can be provided to dispose of resources before the reset, overriding any previously provided during registration.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_12\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Clears the instance of a lazy singleton,\n  /// being able to call the factory function on the next call\n  /// of [get] on that type again.\n  /// you select the lazy Singleton you want to reset by either providing\n  /// an [instance], its registered type [T] or its registration name.\n  /// if you need to dispose some resources before the reset, you can\n  /// provide a [disposingFunction]. This function overrides the disposing\n  /// you might have provided when registering.\nvoid resetLazySingleton<T>({Object instance,\n                            String instanceName,\n                            void Function(T) disposingFunction})\n```\n\n----------------------------------------\n\nTITLE: Unregister Singleton/Factory in GetIt (Dart)\nDESCRIPTION: This snippet shows how to unregister a registered singleton or factory by type or instance name in GetIt. It also shows how to pass a disposing function to clean up resources before unregistering.  The `disposingFunction` overrides any disposing function provided during registration. It takes an optional `instanceName` to unregister by name.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_11\n\nLANGUAGE: Dart\nCODE:\n```\n/// Unregister an [instance] of an object or a factory/singleton by Type [T] or by name [instanceName]\n/// if you need to dispose some resources before the reset, you can\n/// provide a [disposingFunction]. This function overrides the disposing\n/// you might have provided when registering.\nvoid unregister<T>({Object instance,String instanceName, void Function(T) disposingFunction})\n```\n\n----------------------------------------\n\nTITLE: Signal Singleton Ready Dart\nDESCRIPTION: Signals that a singleton is ready. This is typically used inside the registered object's init method.  Must have set `signalsReady` or implement `WillSignalReady`.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_31\n\nLANGUAGE: Dart\nCODE:\n```\n/// Typically this is used in this way inside the registered objects init\n/// method `GetIt.instance.signalReady(this);`\nvoid signalReady(Object instance);\n```\n\n----------------------------------------\n\nTITLE: Pop Scope in GetIt (Dart)\nDESCRIPTION: This snippet shows how to dispose of all factories/singletons in a scope and pop the scope, activating the previous scope. Dispose functions registered during registration are called. A dispose function passed when pushing the scope is also called before popping. It's an asynchronous operation and needs to be awaited.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_15\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Disposes all factories/Singletons that have been registered in this scope\n  /// and pops (destroys) the scope so that the previous scope gets active again.\n  /// if you provided dispose functions on registration, they will be called.\n  /// if you passed a dispose function when you pushed this scope it will be\n  /// called before the scope is popped.\n  /// As dispose functions can be async, you should await this function.\n  Future<void> popScope();\n```\n\n----------------------------------------\n\nTITLE: Multiple GetIt Instances: Creating Independent GetIt Instance (Dart)\nDESCRIPTION: This code shows how to create a new, independent instance of GetIt using `GetIt.asNewInstance()`. This is useful when you need separate service locators that don't share registrations with the default singleton instance.  It mentions that this feature needs to be explicitly enabled before being used.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_40\n\nLANGUAGE: Dart\nCODE:\n```\n/// To make sure you really know what you are doing\n/// you have to first enable this feature:\nGetIt myOwnInstance = GetIt.asNewInstance();\n```\n\n----------------------------------------\n\nTITLE: Fetching All Instances\nDESCRIPTION: Fetches all registered instances of a given type from GetIt. Shows both synchronous and asynchronous versions of the call.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\nfinal Iterable<MyBase> instances = getIt.getAll<MyBase>();\n```\n\nLANGUAGE: Dart\nCODE:\n```\nfinal Iterable<MyBase> instances = await getIt.getAllAsync<MyBase>();\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Implementations\nDESCRIPTION: Registers multiple lazy singletons for the same base type. Demonstrates how to register multiple implementations of an interface.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\ngetIt.registerLazySingleton<MyBase>(\n  () => ImplA(),\n);\ngetIt.registerLazySingleton<MyBase>(\n  () => ImplB(),\n);\n```\n\n----------------------------------------\n\nTITLE: Reset Scope in GetIt (Dart)\nDESCRIPTION: This snippet demonstrates clearing all registered types for the current scope in reverse order of registration. Dispose functions registered during registration are called, unless explicitly disabled via the `dispose` parameter. It's an asynchronous operation and needs to be awaited.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_19\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Clears all registered types for the current scope in the reverse order in which they were registered.\n  /// If you provided dispose function when registering they will be called\n  /// [dispose] if `false` it only resets without calling any dispose\n  /// functions\n  /// As dispose funcions can be async, you should await this function.\n  Future<void> resetScope({bool dispose = true});\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Instances\nDESCRIPTION: Enables the registration of multiple instances of the same type in GetIt.  This must be called before attempting to register multiple instances of the same type.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\ngetIt.enableRegisteringMultipleInstancesOfOneType();\n```\n\n----------------------------------------\n\nTITLE: Scope Change Callback (Dart)\nDESCRIPTION: This snippet shows how to register a callback function in GetIt that is called whenever a change in the current scope happens. This is helpful for updating the UI to ensure it uses the correct objects after a scope change. The `onScopeChanged` parameter accepts a function with a boolean `pushed` argument.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_21\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Optional call-back that will get called whenever a change in the current scope happens\n  /// This can be very helpful to update the UI in such a case to make sure it uses\n  /// the correct Objects after a scope change\n  void Function(bool pushed)? onScopeChanged;\n```\n\n----------------------------------------\n\nTITLE: Registering onScopeChanged Callback\nDESCRIPTION: Demonstrates registering an `onScopeChanged` callback in GetIt.  This callback function is invoked whenever the active scope changes, allowing for UI updates or other actions to reflect the new scope. Intended for use cases involving shadowing and scope management.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n/// Optional call-back that will get call whenever a change in the current scope happens\n/// This can be very helpful to update the UI in such a case to make sure it uses\n/// the correct Objects after a scope change\nvoid Function(bool pushed)? onScopeChanged;\n```\n\n----------------------------------------\n\nTITLE: Access Factory with Parameters Dart\nDESCRIPTION: Example of accessing a factory that requires parameters. The parameters are passed as optional arguments to the `get()` function.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_35\n\nLANGUAGE: Dart\nCODE:\n```\n  var instance = getIt<TestClassParam>(param1: 'abc',param2:3);\n```\n\n----------------------------------------\n\nTITLE: Shadow Change Handlers Interface (Dart)\nDESCRIPTION: This snippet presents the `ShadowChangeHandlers` abstract class.  Implementing this interface allows an object to be notified when it's shadowed by another object or when it becomes active again after a shadowing object is removed. The `onGetShadowed` method is called when the object is shadowed, and `onLeaveShadow` is called when the shadowing object is removed.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_20\n\nLANGUAGE: Dart\nCODE:\n```\nabstract class ShadowChangeHandlers {\n  void onGetShadowed(Object shadowing);\n  void onLeaveShadow(Object shadowing);\n}\n```\n\n----------------------------------------\n\nTITLE: Reset GetIt Completely (Dart)\nDESCRIPTION: This snippet shows how to clear all registered types in GetIt, in reverse order of registration. It is useful for unit tests or before application shutdown.  It allows calling dispose functions if provided during registration, unless explicitly disabled via the `dispose` parameter. It's an asynchronous operation and needs to be awaited.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_13\n\nLANGUAGE: Dart\nCODE:\n```\n/// Clears all registered types in the reverse order in which they were registered.\n/// Handy when writing unit tests or before quitting your application.\n/// If you provided dispose function when registering they will be called\n/// [dispose] if `false` it only resets without calling any dispose\n/// functions\n/// As dispose funcions can be async, you should await this function.\nFuture<void> reset({bool dispose = true});\n```\n\n----------------------------------------\n\nTITLE: Disposable Interface (Dart)\nDESCRIPTION: This snippet defines the `Disposable` interface, which can be implemented by objects registered with GetIt. The `onDispose` method will be called when the scope is popped or reset, or when GetIt is reset completely, offering an alternative to providing a disposing function during registration or when pushing a scope.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_22\n\nLANGUAGE: Dart\nCODE:\n```\nabstract class Disposable {\n  FutureOr onDispose();\n}\n```\n\n----------------------------------------\n\nTITLE: Drop Scope in GetIt (Dart)\nDESCRIPTION: This snippet illustrates clearing all registered factories and singletons in a scope and then dropping the scope. If the dropped scope was the last one, the previous scope becomes active. Dispose functions registered during registration, and the dispose function passed when pushing the scope are called before the scope is dropped. It's an asynchronous operation and needs to be awaited.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_17\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Clears all registered factories and singletons in the provided scope,\n  /// then destroys (drops) the scope. If the dropped scope was the last one,\n  /// the previous scope becomes active again.\n  /// if you provided dispose functions on registration, they will be called.\n  /// if you passed a dispose function when you pushed this scope it will be\n  /// called before the scope is dropped.\n  /// As dispose functions can be async, you should await this function.\n  Future<void> dropScope(String scopeName);\n```\n\n----------------------------------------\n\nTITLE: Check if Registered\nDESCRIPTION: Checks if an instance or type is already registered in GetIt. Used for testing if a type is already registered before attempting to register it again.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\n /// Tests if an [instance] of an object or aType [T] or a name [instanceName]\n /// is registered inside GetIt\n bool isRegistered<T>({Object instance, String instanceName});\n```\n\n----------------------------------------\n\nTITLE: Initialize Singleton Asynchronously Dart\nDESCRIPTION: Initializes a singleton asynchronously by using fire and forget async function from the constructor.  Signals when the service is ready using `GetIt.instance.signalReady(this)`\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_32\n\nLANGUAGE: Dart\nCODE:\n```\nclass ConfigService {\n  ConfigService()\n  {\n    init();\n  }\n  Future init() async {\n    // do your async initialisation...\n\n    GetIt.instance.signalReady(this);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disposable Interface Implementation\nDESCRIPTION: Illustrates how to implement the `Disposable` interface in GetIt. Objects implementing this interface have their `onDispose()` method called when the object is disposed of, allowing for resource cleanup. Requires GetIt version 7.0.0 or later.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Dart\nCODE:\n```\nabstract class Disposable {\n  FutureOr onDispose();\n}\n```\n\n----------------------------------------\n\nTITLE: Pop Scopes Till in GetIt (Dart)\nDESCRIPTION: This snippet demonstrates popping all scopes above a scope with a given name, including that scope, unless `inclusive` is set to false. Scopes are popped in order from the top.  If no scope with the given name exists, nothing is popped, and `false` is returned.  It's an asynchronous operation and needs to be awaited.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_16\n\nLANGUAGE: Dart\nCODE:\n```\n  /// if you have a lot of scopes with names you can pop (see [popScope]) all\n  /// scopes above the scope with [name] including that scope unless [inclusive]= false\n  /// Scopes are popped in order from the top\n  /// As dispose functions can be async, you should await this function.\n  /// If no scope with [name] exists, nothing is popped and `false` is returned\n  Future<bool> popScopesTill(String name, {bool inclusive = true});\n```\n\n----------------------------------------\n\nTITLE: Initializing GetIt instance\nDESCRIPTION: Creates a GetIt instance and registers an AppModel singleton. This demonstrates how to register a singleton using both the `GetIt.instance` and `GetIt.I` shortcuts.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\nfinal getIt = GetIt.instance;\n\nvoid setup() {\n  getIt.registerSingleton<AppModel>(AppModel());\n\n// Alternatively you could write it if you don't like global variables\n  GetIt.I.registerSingleton<AppModel>(AppModel());\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing GetIt instance (alternate)\nDESCRIPTION: Creates a GetIt instance. Assigns the instance to a variable to be used for later object registration.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\nGetIt getIt = GetIt.instance;\n```\n\n----------------------------------------\n\nTITLE: ShadowChangeHandlers Interface Implementation\nDESCRIPTION: Shows how to implement the `ShadowChangeHandlers` interface in GetIt. Objects implementing this interface receive callbacks when they are shadowed or unshadowed by other objects, enabling them to manage their state accordingly. Requires GetIt version 7.0.0 or later.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\nabstract class ShadowChangeHandlers {\n  void onGetShadowed(Object shadowing);\n  void onLeaveShadow(Object shadowing);\n}\n```\n\n----------------------------------------\n\nTITLE: Check Scope Existence in GetIt (Dart)\nDESCRIPTION: This snippet shows how to test if a scope with a given name is registered in GetIt. It returns `true` if the scope exists and `false` otherwise.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/README.md#_snippet_18\n\nLANGUAGE: Dart\nCODE:\n```\n  /// Tests if the scope by name [scopeName] is registered in GetIt\n  bool hasScope(String scopeName);\n```\n\n----------------------------------------\n\nTITLE: Accessing Objects by Runtime Type\nDESCRIPTION: Demonstrates how to access objects within GetIt using runtime types. This functionality allows retrieval of registered instances based on their type, which can be useful in scenarios where compile-time type information is not readily available. Requires GetIt version 7.6.0 or later.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Dart\nCODE:\n```\ngetIt.registerSingleton(TestClass());\n\nfinal instance1 = getIt.get(type: TestClass);\n\nexpect(instance1 is TestClass, true);\n```\n\n----------------------------------------\n\nTITLE: CMake Unicode Definitions\nDESCRIPTION: This snippet adds definitions to use Unicode for all projects.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# Use Unicode for all projects.\nadd_definitions(-DUNICODE -D_UNICODE)\n```\n\n----------------------------------------\n\nTITLE: Defining the Executable Target\nDESCRIPTION: This snippet defines the executable target for the application, specifying the source files to be included. It then applies the standard build settings and links the necessary libraries, including flutter and GTK.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(${BINARY_NAME}\n  \"main.cc\"\n  \"my_application.cc\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n)\n\n# Apply the standard set of build settings. This can be removed for applications\n# that need different build settings.\napply_standard_settings(${BINARY_NAME})\n\n# Add dependency libraries. Add any application-specific dependencies here.\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter)\ntarget_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)\n```\n\n----------------------------------------\n\nTITLE: Applying Standard Build Settings\nDESCRIPTION: This CMake function applies standard compilation settings to a target, including setting the C++ standard to C++14, enabling compiler warnings as errors, and setting optimization levels based on the build configuration. This helps ensure consistent build settings across different targets.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_14)\n  target_compile_options(${TARGET} PRIVATE -Wall -Werror)\n  target_compile_options(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:NDEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Policies\nDESCRIPTION: This snippet sets a CMake policy to opt-in to modern CMake behaviors, avoiding warnings in recent CMake versions. It also sets the CMAKE_INSTALL_RPATH to load bundled libraries from the lib/ directory relative to the binary.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(SET CMP0063 NEW)\n\n# Load bundled libraries from the lib/ directory relative to the binary.\nset(CMAKE_INSTALL_RPATH \"$ORIGIN/lib\")\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Subdirectory\nDESCRIPTION: This snippet adds the Flutter managed directory as a subdirectory, which contains the Flutter build rules and generated code. This allows the CMake build process to integrate with the Flutter build system.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Adding Flutter Assemble Dependency\nDESCRIPTION: This snippet adds a dependency on the flutter_assemble target, which runs the Flutter tool portions of the build. This ensures that the Flutter assets and code are built before the main executable is linked.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\n# Run the Flutter tool portions of the build. This must not be removed.\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Apply Standard Build Settings in CMake\nDESCRIPTION: This CMake snippet applies a set of standard build settings to the executable target.  It provides a set of default configurations that can be removed if the application requires customized settings.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\napply_standard_settings(${BINARY_NAME})\n```\n\n----------------------------------------\n\nTITLE: CMake Standard Settings Function\nDESCRIPTION: This CMake function applies standard compilation settings to a target, including C++ standard version, compiler options, and definitions.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(APPLY_STANDARD_SETTINGS TARGET)\n  target_compile_features(${TARGET} PUBLIC cxx_std_17)\n  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd\"4100\")\n  target_compile_options(${TARGET} PRIVATE /EHsc)\n  target_compile_definitions(${TARGET} PRIVATE \"_HAS_EXCEPTIONS=0\")\n  target_compile_definitions(${TARGET} PRIVATE \"$<$<CONFIG:Debug>:_DEBUG>\")\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum CMake version, defines the project name and language, and sets the binary name for the executable.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nproject(example LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"example\")\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Required Version\nDESCRIPTION: This snippet sets the minimum required CMake version for the build to 3.14. This ensures that the CMake version used is compatible with the features and commands used in the script.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Finding System-Level Dependencies\nDESCRIPTION: This snippet uses the PkgConfig module to find the GTK library, marking it as a required dependency. It also defines an application ID using add_definitions.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\n# System-level dependencies.\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\n\nadd_definitions(-DAPPLICATION_ID=\"${APPLICATION_ID}\")\n```\n\n----------------------------------------\n\nTITLE: Including Generated Plugins\nDESCRIPTION: This snippet includes the generated_plugins.cmake file, which manages building the plugins and adding them to the application. This allows the application to use Flutter plugins.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Setting up Installation\nDESCRIPTION: This section configures the installation process, which creates a relocatable bundle in the build directory. It defines the installation prefix and ensures a clean build bundle directory for each build.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\n# === Installation ===\n# By default, \"installing\" just makes a relocatable bundle in the build\n# directory.\nset(BUILD_BUNDLE_DIR \"${PROJECT_BINARY_DIR}/bundle\")\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\n# Start with a clean build bundle directory every time.\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${BUILD_BUNDLE_DIR}/\\\"\n  \" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Installing Application Files\nDESCRIPTION: This section installs the application's runtime components, including the executable, ICU data file, Flutter library, and bundled plugin libraries, to the specified installation directories. It ensures all required files are correctly placed in the bundle.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}/lib\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nforeach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})\n  install(FILES \"${bundled_library}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendforeach(bundled_library)\n```\n\n----------------------------------------\n\nTITLE: CMake Build Configuration\nDESCRIPTION: This snippet defines the build configuration options (Debug, Profile, Release) based on whether the generator is multi-config or single-config. It sets the default build type to Debug if not already defined.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Define build configuration option.\nget_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(IS_MULTICONFIG)\n  set(CMAKE_CONFIGURATION_TYPES \"Debug;Profile;Release\"\n    CACHE STRING \"\" FORCE)\nelse()\n  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n    set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n      STRING \"Flutter build mode\" FORCE)\n    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n      \"Debug\" \"Profile\" \"Release\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding System Packages\nDESCRIPTION: This snippet uses `pkg_check_modules` to find required system-level dependencies such as GTK, GLib, and GIO. The `IMPORTED_TARGET` option creates imported targets for these packages, making them easier to link against.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)\npkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)\npkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)\n```\n\n----------------------------------------\n\nTITLE: Setting Project Configuration\nDESCRIPTION: This snippet sets the minimum required CMake version, defines the project name, and sets variables for the binary name and application ID. These variables are used throughout the CMake configuration to define the application's identity and build process.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\nproject(runner LANGUAGES CXX)\n\n# The name of the executable created for the application. Change this to change\n# the on-disk name of your application.\nset(BINARY_NAME \"example\")\n# The unique GTK application identifier for this application. See:\n# https://wiki.gnome.org/HowDoI/ChooseApplicationID\nset(APPLICATION_ID \"com.example.example\")\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Target for Flutter Assembly\nDESCRIPTION: This snippet creates a custom target named `flutter_assemble` that depends on the Flutter library and headers. This target is used to trigger the custom command that generates these files.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Interface Library\nDESCRIPTION: This snippet creates an interface library named `flutter`. It sets the include directories and links the library to the Flutter DLL using target include directories and target link libraries.  It also makes `flutter` depend on the `flutter_assemble` target.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}.lib\")\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configuration Options\nDESCRIPTION: This snippet defines the build type if it's not already set, defaulting to \"Debug\". It also sets the possible values for the CMAKE_BUILD_TYPE cache variable, allowing the user to choose between \"Debug\", \"Profile\", and \"Release\" build modes.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Define build configuration options.\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE\n    STRING \"Flutter build mode\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n    \"Debug\" \"Profile\" \"Release\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Wrapper Plugin Library\nDESCRIPTION: This snippet creates a static library named `flutter_wrapper_plugin` that includes core and plugin wrapper sources. It applies standard settings, sets position-independent code, hides CXX visibility, links to the `flutter` interface library, adds include directories, and establishes a dependency on `flutter_assemble`. Requires `apply_standard_settings` function.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter_wrapper_plugin STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n)\napply_standard_settings(flutter_wrapper_plugin)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  POSITION_INDEPENDENT_CODE ON)\nset_target_properties(flutter_wrapper_plugin PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_link_libraries(flutter_wrapper_plugin PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_plugin PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_plugin flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Setting Root Filesystem for Cross-Building\nDESCRIPTION: This snippet configures the CMake environment for cross-building by setting the CMAKE_SYSROOT and CMAKE_FIND_ROOT_PATH variables based on the FLUTTER_TARGET_PLATFORM_SYSROOT. It also sets the search modes for finding programs, packages, libraries, and includes.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Root filesystem for cross-building.\nif(FLUTTER_TARGET_PLATFORM_SYSROOT)\n  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})\n  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\n  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\n  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Link Libraries and Include Directories in CMake\nDESCRIPTION: This CMake snippet adds dependency libraries and include directories to the executable target. It links the Flutter framework and other required libraries, and specifies the include directories needed for compilation.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)\ntarget_link_libraries(${BINARY_NAME} PRIVATE \"dwmapi.lib\")\ntarget_include_directories(${BINARY_NAME} PRIVATE \"${CMAKE_SOURCE_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Path\nDESCRIPTION: This snippet defines the `FLUTTER_LIBRARY` variable, which points to the Flutter Windows DLL. It also sets this and related variables in the parent scope for use in other CMake scripts.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/flutter_windows.dll\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/windows/app.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Command for Flutter Assembly\nDESCRIPTION: This snippet creates a custom command that executes the `tool_backend.sh` script to generate the Flutter library and headers. The `_phony_` file is used to force the command to run every time. The custom command defines the command to execute and the output files that are generated.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CMAKE_CURRENT_BINARY_DIR}/_phony_\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh\"\n      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Plugin Inclusion\nDESCRIPTION: This includes the generated plugin build rules for building and adding plugins to the application.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\n# Generated plugin build rules, which manage building the plugins and adding\n# them to the application.\ninclude(flutter/generated_plugins.cmake)\n```\n\n----------------------------------------\n\nTITLE: Installing Assets Directory\nDESCRIPTION: This snippet installs the flutter_assets directory, ensuring it's fully re-copied on each build to avoid stale files. This keeps assets up-to-date.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Setting Runtime Output Directory\nDESCRIPTION: This snippet sets the runtime output directory for the executable to a subdirectory, preventing users from running the unbundled copy. This ensures that only the install-generated bundle's copy is executed.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nset_target_properties(${BINARY_NAME}\n  PROPERTIES\n  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/intermediates_do_not_run\"\n)\n```\n\n----------------------------------------\n\nTITLE: Add Flutter Assembly Dependency in CMake\nDESCRIPTION: This CMake snippet adds a dependency on the Flutter assembly process to the executable target.  Ensuring that the Flutter resources are assembled before building the executable.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_dependencies(${BINARY_NAME} flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Command for Flutter Assembly\nDESCRIPTION: This snippet defines a custom command to run the Flutter tool's backend, generating the Flutter library and related files. It uses a phony output file to ensure the command runs every time. It relies on `FLUTTER_TOOL_ENVIRONMENT`, `FLUTTER_ROOT`, and `FLUTTER_TARGET_PLATFORM` being defined.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nset(PHONY_OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/_phony_\")\nset_source_files_properties(\"${PHONY_OUTPUT}\" PROPERTIES SYMBOLIC TRUE)\nadd_custom_command(\n  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}\n    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}\n    ${CPP_WRAPPER_SOURCES_APP}\n    ${PHONY_OUTPUT}\n  COMMAND ${CMAKE_COMMAND} -E env\n    ${FLUTTER_TOOL_ENVIRONMENT}\n    \"${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat\"\n      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>\n  VERBATIM\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Target for Flutter Assembly\nDESCRIPTION: This snippet defines a custom target named `flutter_assemble` that depends on the generated Flutter library, headers, and wrapper sources. This target ensures that the Flutter library is assembled before any other target that depends on it.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(flutter_assemble DEPENDS\n  \"${FLUTTER_LIBRARY}\"\n  ${FLUTTER_LIBRARY_HEADERS}\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_PLUGIN}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Installation Setup\nDESCRIPTION: This section configures the installation process, setting up the destination directories and copying necessary files for running the application.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\n# === Installation ===\n# Support files are copied into place next to the executable, so that it can\n# run in place. This is done instead of making a separate bundle (as on Linux)\n# so that building and running from within Visual Studio will work.\nset(BUILD_BUNDLE_DIR \"$<TARGET_FILE_DIR:${BINARY_NAME}>\")\n# Make the \"install\" step default, as it's required to run.\nset(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${BUILD_BUNDLE_DIR}\" CACHE PATH \"...\" FORCE)\nendif()\n\nset(INSTALL_BUNDLE_DATA_DIR \"${CMAKE_INSTALL_PREFIX}/data\")\nset(INSTALL_BUNDLE_LIB_DIR \"${CMAKE_INSTALL_PREFIX}\")\n\ninstall(TARGETS ${BINARY_NAME} RUNTIME DESTINATION \"${CMAKE_INSTALL_PREFIX}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_ICU_DATA_FILE}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  COMPONENT Runtime)\n\ninstall(FILES \"${FLUTTER_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n  COMPONENT Runtime)\n\nif(PLUGIN_BUNDLED_LIBRARIES)\n  install(FILES \"${PLUGIN_BUNDLED_LIBRARIES}\"\n    DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n\n# Fully re-copy the assets directory on each build to avoid having stale files\n# from a previous install.\nset(FLUTTER_ASSET_DIR_NAME \"flutter_assets\")\ninstall(CODE \"\n  file(REMOVE_RECURSE \\\"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\\\")\n  \" COMPONENT Runtime)\ninstall(DIRECTORY \"${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}\"\n  DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\" COMPONENT Runtime)\n\n# Install the AOT library on non-Debug builds only.\ninstall(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_DATA_DIR}\"\n  CONFIGURATIONS Profile;Release\n  COMPONENT Runtime)\n```\n\n----------------------------------------\n\nTITLE: Add Compiler Definitions for Flutter Version in CMake\nDESCRIPTION: This CMake snippet adds preprocessor definitions for the Flutter version information to the executable target. These definitions are used during compilation to embed the version number into the application.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION=\\\"${FLUTTER_VERSION}\\\"\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}\")\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}\")\n```\n\n----------------------------------------\n\nTITLE: Setting Ephemeral Directory\nDESCRIPTION: This snippet defines the `EPHEMERAL_DIR` variable, which points to the ephemeral directory containing generated configuration files and build artifacts. This directory is used to store files created by the Flutter tool.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: Include Generated Configuration\nDESCRIPTION: This snippet includes a generated configuration file from the ephemeral directory. This file likely contains settings specific to the Flutter build environment.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Library Headers\nDESCRIPTION: This snippet defines a list of Flutter library headers and prepends the ephemeral directory path to each header. It creates an interface library named `flutter` and sets its include directories and link libraries.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"fl_basic_message_channel.h\"\n  \"fl_binary_codec.h\"\n  \"fl_binary_messenger.h\"\n  \"fl_dart_project.h\"\n  \"fl_engine.h\"\n  \"fl_json_message_codec.h\"\n  \"fl_json_method_codec.h\"\n  \"fl_message_codec.h\"\n  \"fl_method_call.h\"\n  \"fl_method_channel.h\"\n  \"fl_method_codec.h\"\n  \"fl_method_response.h\"\n  \"fl_plugin_registrar.h\"\n  \"fl_plugin_registry.h\"\n  \"fl_standard_message_codec.h\"\n  \"fl_standard_method_codec.h\"\n  \"fl_string_codec.h\"\n  \"fl_value.h\"\n  \"fl_view.h\"\n  \"flutter_linux.h\"\n)\nlist_prepend(FLUTTER_LIBRARY_HEADERS \"${EPHEMERAL_DIR}/flutter_linux/\")\nadd_library(flutter INTERFACE)\ntarget_include_directories(flutter INTERFACE\n  \"${EPHEMERAL_DIR}\"\n)\ntarget_link_libraries(flutter INTERFACE \"${FLUTTER_LIBRARY}\")\ntarget_link_libraries(flutter INTERFACE\n  PkgConfig::GTK\n  PkgConfig::GLIB\n  PkgConfig::GIO\n)\nadd_dependencies(flutter flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: CMake Flutter Subdirectory Inclusion\nDESCRIPTION: This snippet includes the Flutter managed directory as a subdirectory for building Flutter-related components.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\n# Flutter library and tool build rules.\nset(FLUTTER_MANAGED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/flutter\")\nadd_subdirectory(${FLUTTER_MANAGED_DIR})\n```\n\n----------------------------------------\n\nTITLE: Define Executable and Source Files in CMake\nDESCRIPTION: This CMake snippet defines the executable target for the Flutter runner and specifies the source files required for the build. It includes C++ source files, generated plugin registrants, resource files, and manifest files.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(${BINARY_NAME} WIN32\n  \"flutter_window.cpp\"\n  \"main.cpp\"\n  \"utils.cpp\"\n  \"win32_window.cpp\"\n  \"${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc\"\n  \"Runner.rc\"\n  \"runner.exe.manifest\"\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Runner Subdirectory Inclusion\nDESCRIPTION: This snippet includes the runner directory as a subdirectory, responsible for building the application.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\n# Application build; see runner/CMakeLists.txt.\nadd_subdirectory(\"runner\")\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Wrapper Sources (Core)\nDESCRIPTION: This snippet defines the core C++ wrapper source files and prepends the `WRAPPER_ROOT` to their paths. These source files provide core functionalities for the Flutter engine integration.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_CORE\n  \"core_implementations.cc\"\n  \"standard_codec.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Defining Flutter Library Headers\nDESCRIPTION: This snippet creates a list of Flutter library header files and prepends the `EPHEMERAL_DIR` to each entry, preparing them for use in include directories.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND FLUTTER_LIBRARY_HEADERS\n  \"flutter_export.h\"\n  \"flutter_windows.h\"\n  \"flutter_messenger.h\"\n  \"flutter_plugin_registrar.h\"\n  \"flutter_texture_registrar.h\"\n)\nlist(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND \"${EPHEMERAL_DIR}/\")\n```\n\n----------------------------------------\n\nTITLE: Creating Flutter Wrapper App Library\nDESCRIPTION: This snippet creates a static library named `flutter_wrapper_app` that includes core and app wrapper sources. It applies standard settings, links to the `flutter` interface library, adds include directories, and establishes a dependency on `flutter_assemble`. Requires `apply_standard_settings` function.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(flutter_wrapper_app STATIC\n  ${CPP_WRAPPER_SOURCES_CORE}\n  ${CPP_WRAPPER_SOURCES_APP}\n)\napply_standard_settings(flutter_wrapper_app)\ntarget_link_libraries(flutter_wrapper_app PUBLIC flutter)\ntarget_include_directories(flutter_wrapper_app PUBLIC\n  \"${WRAPPER_ROOT}/include\"\n)\nadd_dependencies(flutter_wrapper_app flutter_assemble)\n```\n\n----------------------------------------\n\nTITLE: Setting Wrapper Root Directory\nDESCRIPTION: This snippet sets the `WRAPPER_ROOT` variable, which points to the C++ client wrapper directory. This directory contains the source code for the C++ wrappers used to interact with the Flutter engine.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(WRAPPER_ROOT \"${EPHEMERAL_DIR}/cpp_client_wrapper\")\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Wrapper Sources (Plugin)\nDESCRIPTION: This snippet defines the C++ wrapper source files specifically for plugins and prepends the `WRAPPER_ROOT` to their paths. These source files are related to plugin registration.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_PLUGIN\n  \"plugin_registrar.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Wrapper Sources (App)\nDESCRIPTION: This snippet defines the C++ wrapper source files for the main application and prepends the `WRAPPER_ROOT` to their paths. These source files handle Flutter engine and view controller functionalities.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND CPP_WRAPPER_SOURCES_APP\n  \"flutter_engine.cc\"\n  \"flutter_view_controller.cc\"\n)\nlist(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND \"${WRAPPER_ROOT}/\")\n```\n\n----------------------------------------\n\nTITLE: Setting Flutter Library Path\nDESCRIPTION: This snippet sets the `FLUTTER_LIBRARY` variable to the path of the Flutter Linux GTK shared library. It then publishes several variables to the parent scope, including the Flutter library, ICU data file, project build directory, and AOT library.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nset(FLUTTER_LIBRARY \"${EPHEMERAL_DIR}/libflutter_linux_gtk.so\")\n\n# Published to parent scope for install step.\nset(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)\nset(FLUTTER_ICU_DATA_FILE \"${EPHEMERAL_DIR}/icudtl.dat\" PARENT_SCOPE)\nset(PROJECT_BUILD_DIR \"${PROJECT_DIR}/build/\" PARENT_SCOPE)\nset(AOT_LIBRARY \"${PROJECT_DIR}/build/lib/libapp.so\" PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Setting Ephemeral Directory\nDESCRIPTION: This snippet sets the `EPHEMERAL_DIR` variable to the location of the ephemeral directory within the CMake source directory.  This directory likely contains generated files and configuration data.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(EPHEMERAL_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/ephemeral\")\n```\n\n----------------------------------------\n\nTITLE: CMake Profile Build Mode Settings\nDESCRIPTION: This snippet defines settings for the Profile build mode, setting linker and compiler flags to be the same as the Release build mode.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Define settings for the Profile build mode.\nset(CMAKE_EXE_LINKER_FLAGS_PROFILE \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_SHARED_LINKER_FLAGS_PROFILE \"${CMAKE_SHARED_LINKER_FLAGS_RELEASE}\")\nset(CMAKE_C_FLAGS_PROFILE \"${CMAKE_C_FLAGS_RELEASE}\")\nset(CMAKE_CXX_FLAGS_PROFILE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n```\n\n----------------------------------------\n\nTITLE: Disable Windows Macros in CMake\nDESCRIPTION: This CMake snippet disables Windows macros that might conflict with C++ standard library functions, ensuring compatibility and avoiding potential build errors.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/runner/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${BINARY_NAME} PRIVATE \"NOMINMAX\")\n```\n\n----------------------------------------\n\nTITLE: Including Generated Configuration\nDESCRIPTION: This snippet includes the `generated_config.cmake` file from the ephemeral directory. This file contains configuration settings generated by the Flutter tool, such as platform-specific definitions and build flags.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${EPHEMERAL_DIR}/generated_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: List Prepend Function\nDESCRIPTION: This function prepends a given prefix to each element in a list. It's used because `list(TRANSFORM ... PREPEND ...)` isn't available in CMake 3.10.  The resulting list is then set in the parent scope, making it available to the calling scope.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(list_prepend LIST_NAME PREFIX)\n    set(NEW_LIST \"\")\n    foreach(element ${${LIST_NAME}})\n        list(APPEND NEW_LIST \"${PREFIX}${element}\")\n    endforeach(element)\n    set(${LIST_NAME} \"${NEW_LIST}\" PARENT_SCOPE)\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Setting Fallback Target Platform\nDESCRIPTION: This snippet sets a default value for `FLUTTER_TARGET_PLATFORM` to \"windows-x64\" if it's not already defined. This ensures a default target platform when building for Windows.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/flutter/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT DEFINED FLUTTER_TARGET_PLATFORM)\n  set(FLUTTER_TARGET_PLATFORM \"windows-x64\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Modern Behavior Opt-In\nDESCRIPTION: This snippet explicitly opts in to modern CMake behaviors to avoid warnings with recent CMake versions.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/windows/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Explicitly opt in to modern CMake behaviors to avoid warnings with recent\n# versions of CMake.\ncmake_policy(SET CMP0063 NEW)\n```\n\n----------------------------------------\n\nTITLE: Installing AOT Library\nDESCRIPTION: This snippet installs the AOT library for non-Debug builds only, optimizing performance in release builds.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\n# Install the AOT library on non-Debug builds only.\nif(NOT CMAKE_BUILD_TYPE MATCHES \"Debug\")\n  install(FILES \"${AOT_LIBRARY}\" DESTINATION \"${INSTALL_BUNDLE_LIB_DIR}\"\n    COMPONENT Runtime)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.10.  This ensures that the CMake features used in the rest of the file are compatible with the CMake installation.\nSOURCE: https://github.com/fluttercommunity/get_it/blob/master/example/linux/flutter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\n```"
  }
]