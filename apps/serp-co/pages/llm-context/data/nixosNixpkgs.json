[
  {
    "owner": "nixos",
    "repo": "nixpkgs",
    "content": "TITLE: Including Documentation Sections with Markdown Fenced Code Block\nDESCRIPTION: This snippet demonstrates how to include external documentation sections into the main markdown file using a language-tagged code fence (here, '{=include=}'). This is typically supported by build or documentation tools that preprocess such code regions. No direct dependencies are required, but the build pipeline must recognize and process the '{=include=}' directive. The main parameter is the list of file paths to include. This enables modularity and reuse in documentation authoring.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-syntax.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\nconfig-file.section.md\nabstractions.section.md\nmodularity.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a NixOS Module for the Locate Service – Nix\nDESCRIPTION: Defines a full-featured NixOS module that manages periodic updates of the locate command's database. Declares options (e.g., services.locate.enable, services.locate.interval) for external configuration and defines systemd service handlers and timers to ensure the update process is controlled as per user specification. Expects NixOS framework and libraries (lib, mkOption), use of pkgs for package references, and properly formed configuration object. Inputs are module parameters (e.g., config, lib, pkgs); output defines options and their documentation as well as concrete systemd service/timer entries. Key outputs are in 'systemd.services' and 'systemd.timers'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-modules.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n\nlet\n  inherit (lib) concatStringsSep mkIf mkOption optionalString types;\n  cfg = config.services.locate;\nin {\n  options.services.locate = {\n    enable = mkOption {\n      type = types.bool;\n      default = false;\n      description = ''\n        If enabled, NixOS will periodically update the database of\n        files used by the locate command.\n      '';\n    };\n\n    interval = mkOption {\n      type = types.str;\n      default = \"02:15\";\n      example = \"hourly\";\n      description = ''\n        Update the locate database at this interval. Updates by\n        default at 2:15 AM every day.\n\n        The format is described in\n        systemd.time(7).\n      '';\n    };\n\n    # Other options omitted for documentation\n  };\n\n  config = {\n    systemd.services.update-locatedb =\n      { description = \"Update Locate Database\";\n        path  = [ pkgs.su ];\n        script =\n          ''\n            mkdir -p $(dirname ${toString cfg.output})\n            chmod 0755 $(dirname ${toString cfg.output})\n            exec updatedb \\\n              --localuser=${cfg.localuser} \\\n              ${optionalString (!cfg.includeStore) \"--prunepaths='/nix/store'\"} \\\n              --output=${toString cfg.output} ${concatStringsSep \" \" cfg.extraFlags}\n          '';\n      };\n\n    systemd.timers.update-locatedb = mkIf cfg.enable\n      { description = \"Update timer for locate database\";\n        partOf      = [ \"update-locatedb.service\" ];\n        wantedBy    = [ \"timers.target\" ];\n        timerConfig.OnCalendar = cfg.interval;\n      };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package using buildPythonPackage - Nix Language\nDESCRIPTION: This Nix snippet demonstrates how to define a Python package (here, pytest) using the buildPythonPackage function in the Nixpkgs ecosystem. It sets up essential derivation attributes such as pname, version, source fetching via fetchPypi, build-system dependencies (setuptools, setuptools-scm), runtime dependencies (attrs, pluggy, py, setuptools, six), test dependencies (hypothesis), and customizes build phases (e.g., removes a problematic test file using postPatch). Metadata including changelog, description, homepage, license, and maintainers are also specified. The build system automatically builds a wheel, installs it, wraps programs with dependencies, and runs tests with pytest. Prerequisites include nix, nixpkgs, and correctly defined dependency packages. The snippet expects the inputs to be dependency derivations and outputs a Python package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n\n  # build-system\n  setuptools,\n  setuptools-scm,\n\n  # dependencies\n  attrs,\n  pluggy,\n  py,\n  setuptools,\n  six,\n\n  # tests\n  hypothesis,\n}:\n\nbuildPythonPackage rec {\n  pname = \"pytest\";\n  version = \"3.3.1\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-z4Q23FnYaVNG/NOrKW3kZCXsqwDWQJbOvnn7Ueyy65M=\";\n  };\n\n  postPatch = ''\n    # don't test bash builtins\n    rm testing/test_argcomplete.py\n  '';\n\n  build-system = [\n    setuptools\n    setuptools-scm\n  ];\n\n  dependencies = [\n    attrs\n    py\n    setuptools\n    six\n    pluggy\n  ];\n\n  nativeCheckInputs = [\n    hypothesis\n  ];\n\n  meta = {\n    changelog = \"https://github.com/pytest-dev/pytest/releases/tag/${version}\";\n    description = \"Framework for writing tests\";\n    homepage = \"https://github.com/pytest-dev/pytest\";\n    license = lib.licenses.mit;\n    maintainers = with lib.maintainers; [\n      domenkozar\n      lovek323\n      madjar\n      lsix\n    ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing NixOS with Flake-based Configuration\nDESCRIPTION: Command to install NixOS using a flake-based configuration. Requires specifying the flake path and the configuration name as defined in the flake.nix file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_20\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-install --flake 'path/to/flake.nix#nixos'\n```\n\n----------------------------------------\n\nTITLE: Basic NixOS Configuration Example\nDESCRIPTION: Example of a basic NixOS configuration file showing essential settings including boot loader configuration and enabling SSH server. Imports hardware-configuration.nix which contains system-specific settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_26\n\nLANGUAGE: ShellSession\nCODE:\n```\n{ config, pkgs, ... }: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n  ];\n\n  boot.loader.grub.device = \"/dev/sda\";   # (for BIOS systems only)\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n\n  # Note: setting fileSystems is generally not\n  # necessary, since nixos-generate-config figures them out\n  # automatically in hardware-configuration.nix.\n  #fileSystems.\"/\".device = \"/dev/disk/by-label/nixos\";\n\n  # Enable the OpenSSH server.\n  services.sshd.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling OpenSSH Service - NixOS - Nix\nDESCRIPTION: This code declaratively enables the OpenSSH server on a NixOS system using the system's configuration.nix. The 'services.openssh.enable' attribute is set to 'true', which instructs NixOS to start and manage the SSH daemon. No additional dependencies are needed beyond a standard NixOS installation. There are no required parameters, but further configuration may be added as needed. The input is the NixOS options set, and the output is enabling SSH server functionality upon rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ssh.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.openssh.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Extensions in NixOS\nDESCRIPTION: Example of how to configure PostgreSQL extensions via NixOS configuration. This shows setting up PostgreSQL 17 with pg_repack and postgis extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.package = pkgs.postgresql_17;\n  services.postgresql.extensions = ps: with ps; [\n    pg_repack\n    postgis\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akkoma and nginx Reverse Proxy for SSL - Nix\nDESCRIPTION: This Nix snippet configures Akkoma and nginx services to enable ACME SSL/TLS certificates, enforce HTTPS, and apply recommended server and optimization settings. Both services are enabled, and recommended TLS, gzip, and performance configurations are applied. Required prerequisites include valid domain setup and operational nginx/Akkoma modules on NixOS. Inputs are the relevant configuration attribute sets; output is secure, proxied HTTP service for Akkoma.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.nginx = {\n    enableACME = true;\n    forceSSL = true;\n  };\n\n  services.nginx = {\n    enable = true;\n\n    clientMaxBodySize = \"16m\";\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Python Environment with Additional Dependencies using nix-shell - Shell - Shell\nDESCRIPTION: Demonstrates launching a custom Python interpreter with numpy, toolz, and requests preinstalled by specifying them in the nix-shell command. The --run python3 argument runs the interpreter directly. This approach enables testing environments with precise, extended dependencies without polluting the global Python environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n$ nix-shell -p \"python312.withPackages (ps: with ps; [ numpy toolz requests ])\" --run python3\nPython 3.12.4 (main, Jun  6 2024, 18:26:44) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import requests\n>>>\n```\n\n----------------------------------------\n\nTITLE: Creating a Nix Shell with Custom Packages and Environment\nDESCRIPTION: This snippet demonstrates how to use pkgs.mkShell to create a custom Nix shell environment. It includes specifying packages, inputsFrom for build dependencies, and a shellHook for setting environment variables.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/mkshell.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\npkgs.mkShell {\n  packages = [ pkgs.gnumake ];\n\n  inputsFrom = [\n    pkgs.hello\n    pkgs.gnutar\n  ];\n\n  shellHook = ''\n    export DEBUG=1\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Creating MBR (msdos) Partition Table Using parted (ShellSession)\nDESCRIPTION: Initializes a new MBR (msdos) partition table on the target disk (/dev/sda) via 'parted'. All existing partitions and data will be lost. This prepares the disk for traditional BIOS/legacy bootroom schemes, with subsequent steps for partition creation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mklabel msdos\n```\n\n----------------------------------------\n\nTITLE: Building a Rust Project with Meson and Cargo Dependencies in Nix (Nix)\nDESCRIPTION: This Nix expression builds a Rust-based GNOME application (health) using Meson as the build system. It manages Cargo dependencies using `fetchCargoVendor` and `cargoSetupHook`, while the main build is handled by Meson with the help of other native build tools. The snippet illustrates specifying main and build dependencies, including `libadwaita` and `tinysparql`, and outlines the use of derivation attributes such as `pname`, `version`, and various build hooks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  fetchFromGitLab,\n  meson,\n  ninja,\n  pkg-config,\n  rustPlatform,\n  rustc,\n  cargo,\n  wrapGAppsHook4,\n  blueprint-compiler,\n  libadwaita,\n  libsecret,\n  tinysparql,\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"health\";\n  version = \"0.95.0\";\n\n  src = fetchFromGitLab {\n    domain = \"gitlab.gnome.org\";\n    owner = \"World\";\n    repo = \"health\";\n    tag = finalAttrs.version;\n    hash = \"sha256-PrNPprSS98yN8b8yw2G6hzTSaoE65VbsM3q7FVB4mds=\";\n  };\n\n  cargoDeps = rustPlatform.fetchCargoVendor {\n    inherit (finalAttrs) pname version src;\n    hash = \"sha256-eR1ZGtTZQNhofFUEjI7IX16sMKPJmAl7aIFfPJukecg=\";\n  };\n\n  nativeBuildInputs = [\n    meson\n    ninja\n    pkg-config\n    rustPlatform.cargoSetupHook\n    rustc\n    cargo\n    wrapGAppsHook4\n    blueprint-compiler\n  ];\n\n  buildInputs = [\n    libadwaita\n    libsecret\n    tinysparql\n  ];\n\n  # ...\n})\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Test Selection with pytestCheckHook\nDESCRIPTION: Demonstrates how to conditionally select tests based on Python version or platform. This approach uses lib.optionals to add or exclude tests based on runtime conditions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_36\n\nLANGUAGE: nix\nCODE:\n```\n{\n  disabledTests =\n    [\n      # touches network\n      \"download\"\n      \"update\"\n    ]\n    ++ lib.optionals (pythonAtLeast \"3.8\") [\n      # broken due to python3.8 async changes\n      \"async\"\n    ]\n    ++ lib.optionals stdenv.buildPlatform.isDarwin [\n      # can fail when building with other packages\n      \"socket\"\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Example Custom NixOS Configuration for kexec - Nix\nDESCRIPTION: Defines a minimal NixOS configuration as a Nix expression, importing the netboot-minimal.nix module. SSH is enabled, and a root SSH authorized public key is set for access. Dependency: Requires a valid modulesPath reference and Nix/NixOS system; must be used in a nix-build context. Input is the Nix function argument for modulesPath; output is a NixOS system closure build; relevant for customizing the ephemeral system used by kexec.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-kexec.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ modulesPath, ... }: {\n  imports = [\n    (modulesPath + \"/installer/netboot/netboot-minimal.nix\")\n  ];\n\n  services.openssh.enable = true;\n  users.users.root.openssh.authorizedKeys.keys = [\n    \"my-ssh-pubkey\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Yarn package with fetchYarnDeps and hooks in Nix\nDESCRIPTION: Comprehensive example showing how to create a Nix derivation for a package using Yarn, including fetching dependencies and using the various Yarn hooks for configuration, building, and installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  fetchFromGitHub,\n  fetchYarnDeps,\n  yarnConfigHook,\n  yarnBuildHook,\n  yarnInstallHook,\n  nodejs,\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"...\";\n  version = \"...\";\n\n  src = fetchFromGitHub {\n    owner = \"...\";\n    repo = \"...\";\n    rev = \"v${finalAttrs.version}\";\n    hash = \"sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\";\n  };\n\n  yarnOfflineCache = fetchYarnDeps {\n    yarnLock = finalAttrs.src + \"/yarn.lock\";\n    hash = \"sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\";\n  };\n\n  nativeBuildInputs = [\n    yarnConfigHook\n    yarnBuildHook\n    yarnInstallHook\n    # Needed for executing package.json scripts\n    nodejs\n  ];\n\n  meta = {\n    # ...\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Writing NixOS ISO to USB using dd on macOS - ShellSession\nDESCRIPTION: This code snippet uses dd to write a NixOS ISO image to a USB flash drive on macOS. It is recommended to use the 'rdiskX' raw device, which greatly accelerates the write process. 'if' is the path to the ISO image, and 'of' is the raw disk identifier. Block size is set to 4m for efficiency. Proper selection of device is crucial. Requires sudo.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-usb.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\nsudo dd if=<path-to-image> of=/dev/rdiskX bs=4m\n```\n\n----------------------------------------\n\nTITLE: Basic NixOS Option Declaration\nDESCRIPTION: Shows the standard structure for declaring a NixOS configuration option using mkOption, including type specification, default value, example, and description.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options = {\n    name = mkOption {\n      type = type specification;\n      default = default value;\n      example = example value;\n      description = \"Description for use in the NixOS manual.\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling GRUB Cryptodisk for Encrypted Boot Partition - nix\nDESCRIPTION: This NixOS configuration enables GRUB's cryptodisk feature to allow booting from an encrypted /boot partition. The code should be added to 'configuration.nix' when /boot resides on a LUKS-encrypted volume. It requires the use of the GRUB boot loader; primary effect is proper unlock of encrypted boot partitions at boot. Inputs are Nix options; output is an updated bootloader configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.loader.grub.enableCryptodisk = true;\\n}\n```\n\n----------------------------------------\n\nTITLE: Using pname and version Attributes with stdenv.mkDerivation - Nix\nDESCRIPTION: This snippet utilizes pname and version with stdenv.mkDerivation, following best practices from RFC 0035 for maintainability and version reuse. The src attribute references finalAttrs.version for dynamic URL formation, and fetchurl secures the downloaded source. It requires stdenv and fetchurl in scope and outputs a derivation where the name attribute is set automatically from pname and version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"libfoo\";\n  version = \"1.2.3\";\n  src = fetchurl {\n    url = \"http://example.org/libfoo-source-${finalAttrs.version}.tar.bz2\";\n    hash = \"sha256-tWxU/LANbQE32my+9AXyt3nCT7NBVfJ45CX757EMT3Q=\";\n  };\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Discourse with Let's Encrypt TLS - Nix\nDESCRIPTION: This Nix code snippet demonstrates a minimal Discourse configuration using Let's Encrypt for TLS. It enables the Discourse service, sets the hostname, administrator credentials, and configures security settings using acme (Let’s Encrypt) with all required paths as parameters. The output is a valid NixOS configuration declaration; proper DNS configuration and file paths for credentials are required for successful deployment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.discourse = {\n    enable = true;\n    hostname = \"discourse.example.com\";\n    admin = {\n      email = \"admin@example.com\";\n      username = \"admin\";\n      fullName = \"Administrator\";\n      passwordFile = \"/path/to/password_file\";\n    };\n    secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n  };\n  security.acme.email = \"me@example.com\";\n  security.acme.acceptTerms = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimal Jitsi Meet Deployment - NixOS Module - Nix\nDESCRIPTION: This snippet defines a minimal NixOS module configuration to deploy Jitsi Meet with Let's Encrypt for TLS certificates. The configuration enables the jitsi-meet and jitsi-videobridge services, configures the desired hostName, opens HTTP and HTTPS ports in the firewall, and sets up ACME certificate management with required email and terms acceptance. Users must provide their actual domain and email address; services.jitsi-meet.enable must be set to true and firewall/ACME options must be compatible with host requirements. Inputs include domain and email; output is a working Jitsi Meet instance with proper access and certificates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/jitsi-meet.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.jitsi-meet = {\n    enable = true;\n    hostName = \"jitsi.example.com\";\n  };\n  services.jitsi-videobridge.openFirewall = true;\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  security.acme.email = \"me@example.com\";\n  security.acme.acceptTerms = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Haskell shell environment with shellFor - Nix Expression Language\nDESCRIPTION: Defines a development environment for multiple Haskell packages using the pkgs.haskellPackages.shellFor function in a shell.nix file. This snippet configures package selection, adds native build inputs such as cabal-install and doctest, and sets an environment variable for package data files. Dependencies include a suitable nixpkgs (pkgs) input and custom project expressions. The inputs are passed as a function for extensibility, and output is a derivation suitable for nix-shell usage. The shell environment includes all necessary development tools and ensures that dependencies of included packages are available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\npkgs.haskellPackages.shellFor {\n  packages = hpkgs: [\n    # reuse the nixpkgs for this package\n    hpkgs.distribution-nixpkgs\n    # call our generated Nix expression manually\n    (hpkgs.callPackage ./my-project/my-project.nix { })\n  ];\n\n  # development tools we use\n  nativeBuildInputs = [\n    pkgs.cabal-install\n    pkgs.haskellPackages.doctest\n    pkgs.cabal2nix\n  ];\n\n  # Extra arguments are added to mkDerivation's arguments as-is.\n  # Since it adds all passed arguments to the shell environment,\n  # we can use this to set the environment variable the `Paths_`\n  # module of distribution-nixpkgs uses to search for bundled\n  # files.\n  # See also: https://cabal.readthedocs.io/en/latest/cabal-package.html#accessing-data-files-from-package-code\n  distribution_nixpkgs_datadir = toString ./distribution-nixpkgs;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Procedural Languages to PostgreSQL in NixOS\nDESCRIPTION: Shows how to enable procedural languages like PL/Perl, PL/Python, and PL/Tcl in PostgreSQL through the NixOS extensions configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.extensions = ps: with ps; [\n    plperl\n    plpython3\n    pltcl\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Wireless Networking in NixOS\nDESCRIPTION: Basic configuration to enable wireless networking with wpa_supplicant in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.wireless.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Sphinx Builders\nDESCRIPTION: Demonstrates how to configure sphinxHook with multiple builders for generating different documentation formats. This example builds both HTML documentation and man pages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_42\n\nLANGUAGE: nix\nCODE:\n```\n{\n  outputs = [\n    \"out\"\n    \"doc\"\n    \"man\"\n  ];\n\n  # Use multiple builders\n  sphinxBuilders = [\n    \"singlehtml\"\n    \"man\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimal Self-Hosted Firefox Sync Server - Nix\nDESCRIPTION: This Nix snippet demonstrates a minimal configuration for setting up a local Firefox Syncserver instance on NixOS. It declares the MariaDB package for MySQL services, enables the firefox-syncserver service, and provides an in-place secret (with example, world-readable, plaintext storage for demonstration purposes). The configuration enables single-node mode, specifies a hostname, and sets the server URL. To use, add this code to your NixOS configuration, then point the Firefox browser's sync token server URI to the specified URL. Requires the NixOS module system and MariaDB, and should not be used in production due to insecure secret handling.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/firefox-syncserver.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mysql.package = pkgs.mariadb;\n\n  services.firefox-syncserver = {\n    enable = true;\n    secrets = builtins.toFile \"sync-secrets\" ''\n      SYNC_MASTER_SECRET=this-secret-is-actually-leaked-to-/nix/store\n    '';\n    singleNode = {\n      enable = true;\n      hostname = \"localhost\";\n      url = \"http://localhost:5000\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Gradle Package Derivation in Nix - Nix Expressions\nDESCRIPTION: This snippet demonstrates a full nix expression for building a Java/Kotlin project (pdftk) using Gradle. It configures all necessary inputs, enables reproducible dependency builds using gradle.fetchDeps for mitmCache, and provides a custom install phase for binary and man pages. Dependencies include nixpkgs's stdenv, gradle, makeWrapper, and lib, as well as a valid deps.json lockfile. Key parameters are pname, version, src, nativeBuildInputs, mitmCache, gradleFlags, gradleBuildTask, and installPhase. The output is a Nix derivation ready for reproducible Java/Kotlin package builds; requires nix and relevant packages in the surrounding nixpkgs scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gradle.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"pdftk\";\n  version = \"3.3.3\";\n\n  src = fetchFromGitLab {\n    owner = \"pdftk-java\";\n    repo = \"pdftk\";\n    tag = \"v${finalAttrs.version}\";\n    hash = \"sha256-ciKotTHSEcITfQYKFZ6sY2LZnXGChBJy0+eno8B3YHY=\";\n  };\n\n  nativeBuildInputs = [\n    gradle\n    makeWrapper\n  ];\n\n  # if the package has dependencies, mitmCache must be set\n  mitmCache = gradle.fetchDeps {\n    inherit (finalAttrs) pname;\n    data = ./deps.json;\n  };\n\n  # this is required for using mitm-cache on Darwin\n  __darwinAllowLocalNetworking = true;\n\n  gradleFlags = [ \"-Dfile.encoding=utf-8\" ];\n\n  # defaults to \"assemble\"\n  gradleBuildTask = \"shadowJar\";\n\n  # will run the gradleCheckTask (defaults to \"test\")\n  doCheck = true;\n\n  installPhase = ''\n    mkdir -p $out/{bin,share/pdftk}\n    cp build/libs/pdftk-all.jar $out/share/pdftk\n\n    makeWrapper ${lib.getExe jre} $out/bin/pdftk \\\n      --add-flags \"-jar $out/share/pdftk/pdftk-all.jar\"\n\n    cp ${finalAttrs.src}/pdftk.1 $out/share/man/man1\n  '';\n\n  meta.sourceProvenance = with lib.sourceTypes; [\n    fromSource\n    binaryBytecode # mitm cache\n  ];\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Guarded Shell Completion Files with Emulator - Nix\nDESCRIPTION: This advanced snippet demonstrates using the `installShellCompletion` function within a conditional expression to handle cross-compilation cases where completions are generated by running package executables via an emulator. The code uses `lib.optionalString` to only execute if the emulator is available and builds shell completions for each shell by piping the output of emulator-based commands using named file descriptors. Inputs are command-line concatenations, flags denoting shell types, and commands generating completion data. Outputs are installed non-empty shell completion files; the code guards against empty outputs to prevent build failures. Dependencies include `installShellFiles` and `lib`, along with proper host platform support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/installShellFiles.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ installShellFiles ];\n  postInstall = lib.optionalString (stdenv.hostPlatform.emulatorAvailable buildPackages) (\n    let\n      emulator = stdenv.hostPlatform.emulator buildPackages;\n    in\n    ''\n      # using named fd\n      installShellCompletion --cmd foobar \\\n        --bash <(${emulator} $out/bin/foobar --bash-completion) \\\n        --fish <(${emulator} $out/bin/foobar --fish-completion) \\\n        --zsh <(${emulator} $out/bin/foobar --zsh-completion)\n    ''\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Discourse with Regular TLS Certificate - Nix\nDESCRIPTION: This snippet describes how to set up Discourse with a regular TLS certificate by specifying certificate and key file paths using the dedicated module options. It also sets up basic administrator information. All file paths must exist and contain appropriate secrets for the NixOS deployment to succeed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.discourse = {\n    enable = true;\n    hostname = \"discourse.example.com\";\n    sslCertificate = \"/path/to/ssl_certificate\";\n    sslCertificateKey = \"/path/to/ssl_certificate_key\";\n    admin = {\n      email = \"admin@example.com\";\n      username = \"admin\";\n      fullName = \"Administrator\";\n      passwordFile = \"/path/to/password_file\";\n    };\n    secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Local Backup with BorgBackup in NixOS\nDESCRIPTION: A basic NixOS configuration for setting up BorgBackup to back up to a local directory. It includes paths to backup, exclusions, repository location, encryption settings, and a weekly backup schedule.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.borgbackup.jobs = {\n      rootBackup = {\n        paths = \"/\";\n        exclude = [ \"/nix\" \"/path/to/local/repo\" ];\n        repo = \"/path/to/local/repo\";\n        doInit = true;\n        encryption = {\n          mode = \"repokey\";\n          passphrase = \"secret\";\n        };\n        compression = \"auto,lzma\";\n        startAt = \"weekly\";\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Derivation Arguments with override (Nix Language)\nDESCRIPTION: Demonstrates how to use the override function to change the arguments passed to a derivation function in nixpkgs. The first snippet shows attribute-based overrides, while the second uses a function to access prior argument values. Requires nixpkgs environment and a derivation exposing .override. Accepts new argument sets, passes them to the original function, and returns the customized derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\npkgs.foo.override {\n  arg1 = val1;\n  arg2 = val2; # ...\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\npkgs.foo.override (previous: {\n  arg1 = previous.arg1; # ...\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Git for GitHub protocol in Shell\nDESCRIPTION: Git configuration command to resolve issues with the git:// protocol when accessing GitHub repositories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit config --global url.\"https://github.com/\".insteadOf git://github.com/\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Ruby Environment with nix-shell\nDESCRIPTION: Demonstrates how to create a temporary Ruby environment with specific gems using nix-shell. This method allows for isolated project environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-shell -p \"ruby.withPackages (ps: with ps; [ nokogiri pry ])\"\n```\n\n----------------------------------------\n\nTITLE: Installing Nix Package Manager (Shell)\nDESCRIPTION: Downloads and installs the Nix package manager using a curl command piped to a shell. The second command sources the Nix profile script or can be substituted by restarting the shell session. Prerequisites: existing Linux environment with curl and sh available. No additional parameters required. Input: none, Output: Nix installed and initialized in current shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ curl -L https://nixos.org/nix/install | sh\\n$ . $HOME/.nix-profile/etc/profile.d/nix.sh # …or open a fresh shell\n```\n\n----------------------------------------\n\nTITLE: Basic Prosody Configuration with MUC and HTTP File Upload in NixOS\nDESCRIPTION: A starter configuration for Prosody XMPP server that includes the main virtual host, Multi User Chat endpoint, and HTTP File Upload component. This setup follows the XEP-0423 recommendations for a modern XMPP experience.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/prosody.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.prosody = {\n    enable = true;\n    admins = [ \"root@example.org\" ];\n    ssl.cert = \"/var/lib/acme/example.org/fullchain.pem\";\n    ssl.key = \"/var/lib/acme/example.org/key.pem\";\n    virtualHosts.\"example.org\" = {\n        enabled = true;\n        domain = \"example.org\";\n        ssl.cert = \"/var/lib/acme/example.org/fullchain.pem\";\n        ssl.key = \"/var/lib/acme/example.org/key.pem\";\n    };\n    muc = [ {\n        domain = \"conference.example.org\";\n    } ];\n    uploadHttp = {\n        domain = \"upload.example.org\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Password for User Account\nDESCRIPTION: Command to set a password for a user account before rebooting into the new system. Uses nixos-enter to access the environment of the installed system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_21\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-enter --root /mnt -c 'passwd alice'\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS-01 Validation for Virtual Hosts in Nginx using NixOS Modules - Nix\nDESCRIPTION: Defines a NixOS configuration to enable ACME certificate provisioning for Nginx virtual hosts using DNS-01 validation. The configuration sets global ACME defaults (provider, email, environment secrets, and disables DNS propagation check for local DNS), and configures a virtual host to leverage these settings by enabling ACME and disabling the default webroot. Requires NixOS, Nginx, properly configured DNS-01 provider, and secrets file. Inputs are hostnames and certificate provider configs; outputs are ACME-managed certificates per vhost.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Configure ACME appropriately\n  security.acme.acceptTerms = true;\n  security.acme.defaults.email = \"admin+acme@example.com\";\n  security.acme.defaults = {\n    dnsProvider = \"rfc2136\";\n    environmentFile = \"/var/lib/secrets/certs.secret\";\n    # We don't need to wait for propagation since this is a local DNS server\n    dnsPropagationCheck = false;\n  };\n\n  # For each virtual host you would like to use DNS-01 validation with,\n  # set acmeRoot = null\n  services.nginx = {\n    enable = true;\n    virtualHosts = {\n      \"foo.example.com\" = {\n        enableACME = true;\n        acmeRoot = null;\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: mkEnableOption Example\nDESCRIPTION: Demonstrates the usage of mkEnableOption utility function to create a boolean toggle option, showing both the function call and its equivalent expanded form.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlib.mkEnableOption \"magic\"\n# is like\nlib.mkOption {\n  type = lib.types.bool;\n  default = false;\n  example = true;\n  description = \"Whether to enable magic.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Video Driver for X Server - Nix\nDESCRIPTION: This code allows manual selection of the X server video driver, in this example 'r128', by setting the services.xserver.videoDrivers attribute to a list containing the driver name. It overrides automatic detection, forcing the use of the specified X.org video driver. Requires: desired driver (here, xf86-video-r128) installed and available in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.videoDrivers = [ \"r128\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WiFi network using wpa_cli in NixOS installer\nDESCRIPTION: Commands to configure a WiFi network connection using wpa_cli in the NixOS minimal installer. This snippet shows how to connect to a home network with SSID and password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> add_network\n0\n> set_network 0 ssid \"myhomenetwork\"\nOK\n> set_network 0 psk \"mypassword\"\nOK\n> enable_network 0\nOK\n```\n\n----------------------------------------\n\nTITLE: Changing Ownership of /nix Tree to Root (Shell)\nDESCRIPTION: Recursively assigns ownership of the /nix filesystem subtree to the root (UID 0) user and group as required for a multi-user NixOS installation. Intended for use after single-user installs or migrations. Prerequisites: sudo/root access. Input: None. Output: /nix owned by root.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo chown -R 0:0 /nix\n```\n\n----------------------------------------\n\nTITLE: Enabling KDE Plasma Desktop in a NixOS Module - Nix\nDESCRIPTION: This module snippet enables X server and the KDE Plasma 5 desktop environment using Nix syntax. It also enables the SDDM display manager and adds Vim to the system packages. Dependencies: Requires the 'pkgs' argument and is intended as a module imported by a main configuration. Inputs: None required; Output: Sets configuration options for services.xserver, display manager, Plasma 5, and system packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ services.xserver.enable = true;\n  services.displayManager.sddm.enable = true;\n  services.xserver.desktopManager.plasma5.enable = true;\n  environment.systemPackages = [ pkgs.vim ];\n}\n```\n\n----------------------------------------\n\nTITLE: Including mpiCheckPhaseHook in nativeCheckInputs with Nix\nDESCRIPTION: This Nix expression demonstrates adding mpiCheckPhaseHook (which sets up the MPI check environment) and its dependencies to a package's nativeCheckInputs. The hook configures necessary environment variables for MPI applications and ensures mpirun/mpiexec function correctly inside the Nix sandbox during check phases. Dependencies include mpiCheckPhaseHook for the hook logic and an MPI implementation (represented by mpi); additional check-time dependencies like openssh are also specified.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/mpi-check-hook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ mpiCheckPhaseHook, mpi, ... }:\n{\n  # ...\n\n  nativeCheckInputs = [\n    openssh\n    mpiCheckPhaseHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling X Server in NixOS - Nix\nDESCRIPTION: This snippet configures NixOS to enable the X server by setting the services.xserver.enable attribute to true in the NixOS configuration file. No other parameters are required. Activating this option starts the X Server at system boot, providing graphical capabilities. Dependencies: X server package is needed; no display/desktop manager is specified here.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Grocy Configuration Override in NixOS\nDESCRIPTION: Method for manually overriding Grocy's PHP configuration file using NixOS's environment.etc mechanism with mkAfter. This allows inserting arbitrary PHP code into Grocy's configuration file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/grocy.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ lib, ... }:\n{\n  environment.etc.\"grocy/config.php\".text = lib.mkAfter ''\n    // Arbitrary PHP code in grocy's configuration file\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Kernel in NixOS\nDESCRIPTION: Shows how to integrate a custom Linux kernel into a NixOS configuration using the linuxPackagesFor function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelPackages = pkgs.linuxPackagesFor yourCustomKernel;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tauri Desktop App Build with cargo-tauri.hook in Nix - Nix\nDESCRIPTION: This Nix expression demonstrates the configuration of a Rust-based Tauri desktop application build process using the cargo-tauri.hook. It sets up both Rust and npm dependencies, manages native build and runtime inputs (such as openssl, glib-networking, and webkitgtk), and manipulates relevant build variables like cargoRoot and buildAndTestSubdir. Required dependencies include the Nixpkgs Rust build platform, Tauri-specific hooks, Node.js/npm, and GTK/GNOME wrappers; expected inputs are Nix derivation attributes, while outputs are reproducibly built Tauri application packages. The snippet highlights cross-platform (Linux) support and integrates npm asset management for web-based frontends.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/tauri.section.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  rustPlatform,\n  fetchNpmDeps,\n  cargo-tauri,\n  glib-networking,\n  nodejs,\n  npmHooks,\n  openssl,\n  pkg-config,\n  webkitgtk_4_1,\n  wrapGAppsHook4,\n}:\n\nrustPlatform.buildRustPackage (finalAttrs: {\n  # ...\n\n  useFetchCargoVendor = true;\n  cargoHash = \"...\";\n\n  # Assuming our app's frontend uses `npm` as a package manager\n  npmDeps = fetchNpmDeps {\n    name = \"${finalAttrs.pname}-npm-deps-${finalAttrs.version}\";\n    inherit src;\n    hash = \"...\";\n  };\n\n  nativeBuildInputs = [\n    # Pull in our main hook\n    cargo-tauri.hook\n\n    # Setup npm\n    nodejs\n    npmHooks.npmConfigHook\n\n    # Make sure we can find our libraries\n    pkg-config\n    wrapGAppsHook4\n  ];\n\n  buildInputs =\n    [ openssl ]\n    ++ lib.optionals stdenv.hostPlatform.isLinux [\n      glib-networking # Most Tauri apps need networking\n      webkitgtk_4_1\n    ];\n\n  # Set our Tauri source directory\n  cargoRoot = \"src-tauri\";\n  # And make sure we build there too\n  buildAndTestSubdir = cargoRoot;\n\n  # ...\n})\n```\n\n----------------------------------------\n\nTITLE: Using makeWrapper to Create Program Wrappers - Bash\nDESCRIPTION: Demonstrates usage of the makeWrapper function to wrap a binary and set environment variables or manipulate the PATH for dependencies. This requires 'makeWrapper' in 'nativeBuildInputs' and expects the wrapped program and output files to be specified. '--set' injects environment variables, '--prefix' and '--suffix' modify PATH. Limitations include that PATH injections are hardcoded unless using '--suffix' for dynamic fallback.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n# adds `FOOBAR=baz` to `$out/bin/foo`’s environment\nmakeWrapper $out/bin/foo $wrapperfile --set FOOBAR baz\n\n# Prefixes the binary paths of `hello` and `git`\n# and suffixes the binary path of `xdg-utils`.\n# Be advised that paths often should be patched in directly\n# (via string replacements or in `configurePhase`).\nmakeWrapper $out/bin/foo $wrapperfile \\\n  --prefix PATH : ${lib.makeBinPath [ hello git ]} \\\n  --suffix PATH : ${lib.makeBinPath [ xdg-utils ]}\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Environment with python.withPackages (Nix)\nDESCRIPTION: This example demonstrates the use of python.withPackages in Nix to instantiate a Python environment with specified packages. It uses a function argument to select wanted packages from the current package set, here the Pyramid web framework. Dependencies include the appropriate Nixpkgs and Python interpreter attributes. The main input is the function returning the list of packages; the output is a Python interpreter with requested dependencies available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\npython.withPackages (ps: [ ps.pyramid ])\n```\n\n----------------------------------------\n\nTITLE: Configuring Dnsmasq DHCP and DNS Server via NixOS Module - Nix\nDESCRIPTION: This Nix expression enables and configures Dnsmasq as an authoritative DHCP and DNS server for a home network within NixOS. Dependencies include the NixOS Dnsmasq module and pre-configuration of network interfaces, gateway, and nameservers in the NixOS networking options. The configuration specifies the interface for Dnsmasq, binds the service, sets static and range DHCP leasing, enables DNSSEC, and includes logging and security options. Inputs such as network interface, gateway address, and hostnames are referenced from NixOS configuration; outputs include active DHCP/DNS services on the specified interface, static DHCP assignments, and DNSSEC validation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/dnsmasq.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.dnsmasq = {\n    enable = true;\n    settings = {\n      interface = \"eth0\";\n      bind-interfaces = true; # Only bind to the specified interface\n      dhcp-authoritative = true; # Should be set when dnsmasq is definitely the only DHCP server on a network\n\n      server = config.networking.nameservers; # Upstream dns servers to which requests should be forwarded\n\n      dhcp-host = [\n        # Give the current system a fixed address of 192.168.0.254\n        \"dc:a6:32:0b:ea:b9,192.168.0.254,${config.networking.hostName},infinite\"\n      ];\n\n      dhcp-option = [\n        # Address of the gateway, i.e. your router\n        \"option:router,${config.networking.defaultGateway.address}\"\n      ];\n\n      dhcp-range = [\n        # Range of IPv4 addresses to give out\n        # <range start>,<range end>,<lease time>\n        \"192.168.0.10,192.168.0.253,24h\"\n        # Enable stateless IPv6 allocation\n        \"::f,::ff,constructor:eth0,ra-stateless\"\n      ];\n\n      dhcp-rapid-commit = true; # Faster DHCP negotiation for IPv6\n      local-service = true; # Accept DNS queries only from hosts whose address is on a local subnet\n      log-queries = true; # Log results of all DNS queries\n      bogus-priv = true; # Don't forward requests for the local address ranges (192.168.x.x etc) to upstream nameservers\n      domain-needed = true; # Don't forward requests without dots or domain parts to upstream nameservers\n\n      dnssec = true; # Enable DNSSEC\n      # DNSSEC trust anchor. Source: https://data.iana.org/root-anchors/root-anchors.xml\n      trust-anchor = \".,20326,8,2,E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Bootloader Entries in NixOS Configuration (Nix)\nDESCRIPTION: Provides a configuration.nix snippet where an extra GRUB menu entry is configured for booting an existing Ubuntu installation. This uses UUID-based filesystem search and chainloads the Ubuntu GRUB configuration. Dependencies: NixOS system with GRUB as boot.loader; proper UUID and existing partition required. Input: None; output: Additional menu entry in NixOS boot menu.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.loader.grub.extraEntries = ''\\n    menuentry \\\"Ubuntu\\\" {\\n      search --set=ubuntu --fs-uuid 3cc3e652-0c1f-4800-8451-033754f68e6e\\n      configfile \\\"($ubuntu)/boot/grub/grub.cfg\\\"\\n    }\\n  '';\\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring FIDO2 Support for LUKS in NixOS Configuration - nix\nDESCRIPTION: This NixOS configuration enables FIDO2-based unlocking for a LUKS device by specifying the required FIDO2 credential. Dependencies are a previously enrolled FIDO2 token and credential; configuration is placed in 'configuration.nix'. Inputs are device paths and credential strings; output is integration of FIDO2 unlocking during system boot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.initrd.luks.fido2Support = true;\\n  boot.initrd.luks.devices.\"/dev/sda2\".fido2.credential = \"f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maubot Plugins in NixOS\nDESCRIPTION: This snippet demonstrates various ways to configure Maubot plugins in NixOS. It shows how to select specific plugins, override their default configurations, and include all official or all available plugins.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/maubot.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.maubot.plugins = with config.services.maubot.package.plugins; [\n    reactbot\n    # This will only change the default config! After you create a\n    # plugin instance, the default config will be copied into that\n    # instance's config in Maubot's database, and further base config\n    # changes won't affect the running plugin.\n    (rss.override {\n      base_config = {\n        update_interval = 60;\n        max_backoff = 7200;\n        spam_sleep = 2;\n        command_prefix = \"rss\";\n        admins = [ \"@chayleaf:pavluk.org\" ];\n      };\n    })\n  ];\n  # ...or...\n  services.maubot.plugins = config.services.maubot.package.plugins.allOfficialPlugins;\n  # ...or...\n  services.maubot.plugins = config.services.maubot.package.plugins.allPlugins;\n  # ...or...\n  services.maubot.plugins = with config.services.maubot.package.plugins; [\n    (weather.override {\n      # you can pass base_config as a string\n      base_config = ''\n        default_location: New York\n        default_units: M\n        default_language:\n        show_link: true\n        show_image: false\n      '';\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Garbage Collection in NixOS (Nix - nix)\nDESCRIPTION: This configuration snippet enables NixOS to automatically run the garbage collector at scheduled times. Setting nix.gc.automatic to true activates periodic garbage collection, and nix.gc.dates sets the CRON-style schedule (here, every day at 03:15). Requires editing the NixOS configuration.nix file and applying changes via nixos-rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n```nix\\n{\\n  nix.gc.automatic = true;\\n  nix.gc.dates = \"03:15\";\\n}\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring networking.localCommands for IPv6 Address Assignment in NixOS (Nix)\nDESCRIPTION: This snippet shows how to set the networking.localCommands option in a NixOS configuration using the Nix language to run custom shell commands after the main network setup. It adds a static IPv6 address (2001:610:685:1::1/64) to the 'eth0' device using the 'ip' command. Requirements: NixOS system, appropriate network permissions, the 'ip' command available in PATH. Input: NixOS configuration file; Output: the specified shell command is executed at the end of network setup. Limitation: Only suitable for custom, unscripted network adjustments not covered by NixOS modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-network-config.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.localCommands =\n    ''\n      ip -6 addr add 2001:610:685:1::1/64 dev eth0\n    '';\n}\n```\n\n----------------------------------------\n\nTITLE: System-wide Lua Environment Installation - NixOS configuration.nix - nix\nDESCRIPTION: This Nix snippet demonstrates integrating a custom Lua environment (with additional packages) into NixOS by updating environment.systemPackages in /etc/nixos/configuration.nix. The environment is created using lua.withPackages and bundled with busted and luafilesystem libraries. Requires the pkgs set and applies system-wide upon rebuilding the NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n\n  environment.systemPackages = with pkgs; [\n    (lua.withPackages (\n      ps: with ps; [\n        busted\n        luafilesystem\n      ]\n    ))\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Rust Compiler, Build Mode, Verbosity, and Rustc Options (Nix)\nDESCRIPTION: These code fragments illustrate how to override various build parameters of a Rust crate derivation in Nix, such as the version of Rust, build mode (release or debug), verbosity, and cpu/feature options passed to rustc. These options are provided via the `.override` mechanism and let Nix users control fine aspects of the build such as reproducibility, build performance, and introspection.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_29\n\nLANGUAGE: nix\nCODE:\n```\n(hello { }).override { rust = pkgs.rust; }\n\n```\n\nLANGUAGE: nix\nCODE:\n```\n(hello { }).override { release = false; }\n\n```\n\nLANGUAGE: nix\nCODE:\n```\n(hello { }).override { verbose = false; }\n\n```\n\nLANGUAGE: nix\nCODE:\n```\n(hello { }).override { extraRustcOpts = \"-Z debuginfo=2\"; }\n\n```\n\n----------------------------------------\n\nTITLE: Package Dependency Override in NixOS\nDESCRIPTION: Example of overriding package dependencies using the override function, specifically showing how to change Emacs' GTK dependency from version 2 to 3.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/customizing-packages.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ];\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging a Python Library with buildPythonPackage - Nix\nDESCRIPTION: Shows a complete Nix function expression for building a Python package ('toolz') via buildPythonPackage. It specifies metadata, version, source fetched from PyPI, a build-system dependency (setuptools), disables tests, sets pythonImportsCheck, and fills out meta attributes. This is meant for standalone use or addition into the Nixpkgs tree as a custom or override package. Requires fetchPypi and buildPythonPackage, and all parameters must be correct for the build to succeed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n  setuptools,\n}:\n\nbuildPythonPackage rec {\n  pname = \"toolz\";\n  version = \"0.10.0\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-CP3V73yWSArRHBLUct4hrNMjWZlvaaUlkpm1QP66RWA=\";\n  };\n\n  build-system = [\n    setuptools\n  ];\n\n  # has no tests\n  doCheck = false;\n\n  pythonImportsCheck = [\n    \"toolz.itertoolz\"\n    \"toolz.functoolz\"\n    \"toolz.dicttoolz\"\n  ];\n\n  meta = {\n    changelog = \"https://github.com/pytoolz/toolz/releases/tag/${version}\";\n    homepage = \"https://github.com/pytoolz/toolz\";\n    description = \"List processing tools and functional utilities\";\n    license = lib.licenses.bsd3;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maubot Homeserver in YAML\nDESCRIPTION: This YAML configuration demonstrates how to add a Matrix homeserver to the Maubot configuration. It includes the homeserver URL and registration secret, which is necessary for registering new users via the Maubot CLI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/maubot.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nhomeservers:\n    matrix.example.org:\n        url: https://matrix.example.org\n        secret: your-very-secret-key\n```\n\n----------------------------------------\n\nTITLE: Using runCommand with Network Access in NixOS\nDESCRIPTION: Example of using testers.runCommand to execute a command that requires internet access. The script downloads content from example.com using curl with proper SSL certificates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\ntesters.runCommand {\n  name = \"access-the-internet\";\n  script = ''\n    curl -o /dev/null https://example.com\n    touch $out\n  '';\n  nativeBuildInputs = with pkgs; [\n    cacert\n    curl\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a NixOS Virtual Machine for Configuration Testing - ShellSession\nDESCRIPTION: These commands build a QEMU VM containing the new NixOS configuration and then boot it for isolated testing. The 'build-vm' step creates the VM, and the resulting shell script launches it. Useful for hardware isolation and does not carry over host user accounts unless configured. Prerequisites: hardware virtualization support, QEMU installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nixos-rebuild build-vm\n$ ./result/bin/run-*-vm\n```\n\n----------------------------------------\n\nTITLE: Enabling Pantheon Desktop Environment in NixOS\nDESCRIPTION: Basic configuration to enable the Pantheon desktop environment in NixOS. This automatically enables LightDM and Pantheon's LightDM greeter.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.pantheon.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Lua Package Using buildLuarocksPackage - Nix Expression - nix\nDESCRIPTION: This Nix snippet demonstrates the use of buildLuarocksPackage to create a package (luaposix) from a source rock file. It specifies attributes like pname, version, src (with URL and hash), and configures conditional builds using luaOlder/luaAtLeast. The build process delegates to luarocks for unpacking, installation, and environment configuration, with meta-information provided for discoverability. Prerequisites include fetchurl and dependencies like bit32 and lua.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  luaposix = buildLuarocksPackage {\n    pname = \"luaposix\";\n    version = \"34.0.4-1\";\n\n    src = fetchurl {\n      url = \"https://raw.githubusercontent.com/rocks-moonscript-org/moonrocks-mirror/master/luaposix-34.0.4-1.src.rock\";\n      hash = \"sha256-4mLJG8n4m6y4Fqd0meUDfsOb9RHSR0qa/KD5KCwrNXs=\";\n    };\n    disabled = (luaOlder \"5.1\") || (luaAtLeast \"5.4\");\n    propagatedBuildInputs = [\n      bit32\n      lua\n      std_normalize\n    ];\n\n    meta = {\n      homepage = \"https://github.com/luaposix/luaposix/\";\n      description = \"Lua bindings for POSIX\";\n      maintainers = with lib.maintainers; [\n        vyp\n        lblasc\n      ];\n      license.fullName = \"MIT/X11\";\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding String Type Check Function (Nix)\nDESCRIPTION: Illustrates overriding the default string type's check function to accept only strings that start with 'nix'. Uses 'types.str' as base and replaces the 'check' attribute with a custom predicate relying on 'lib.hasPrefix'. This approach requires knowledge of the underlying type's structure and presumes the presence of 'lib.hasPrefix'. The result is an option accepting only valid prefixed strings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixThings = mkOption {\n    description = \"words that start with 'nix'\";\n    type = types.str // {\n      check = (x: lib.hasPrefix \"nix\" x);\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Proxy Environment Variables for nixos-install - Shell\nDESCRIPTION: This shell session snippet exports the required proxy environment variables before running nixos-install, ensuring installation steps can access external resources through the proxy. It sets both lowercase and uppercase environment variables for HTTP and HTTPS protocols, increasing compatibility with various tools. Replace the example proxy_url with your actual proxy details before use.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-behind-a-proxy.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# proxy_url=\"http://user:password@proxy:port/\"\n# export http_proxy=\"$proxy_url\"\n# export HTTP_PROXY=\"$proxy_url\"\n# export https_proxy=\"$proxy_url\"\n# export HTTPS_PROXY=\"$proxy_url\"\n```\n\n----------------------------------------\n\nTITLE: Enabling PostgreSQL JIT Compilation in NixOS\nDESCRIPTION: Demonstrates how to enable Just-In-Time compilation for PostgreSQL in NixOS. JIT can improve query performance but increases the closure size due to LLVM dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.enableJIT = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Static IPv4 Address in NixOS\nDESCRIPTION: This snippet demonstrates how to manually configure a static IPv4 address for a network interface in NixOS. It assigns the IP address 192.168.1.2 with a subnet mask of 255.255.255.0 (prefixLength 24) to the eth0 interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv4-config.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.interfaces.eth0.ipv4.addresses = [ {\n    address = \"192.168.1.2\";\n    prefixLength = 24;\n  } ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Hashed Password for a User in NixOS - nix\nDESCRIPTION: This Nix configuration snippet adds or overrides the initial hashed password for a user, enabling login access for the specified user in the VM environment. Place this in 'configuration.nix' to ensure the user exists after deployment. Key: replace 'your-user' with actual username. Requires that passwords be hashed; shown value is a placeholder.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.your-user.initialHashedPassword = \"test\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Global Environment Overlay with Python Packages - Nix\nDESCRIPTION: Defines a Nix overlay in ~/.config/nixpkgs/overlays/myEnv.nix to create a reusable environment named 'myEnv'. This environment bundles a Python 3 interpreter with selected packages (pyflakes, pytest, black) alongside additional tools (mypy, black, ripgrep, tmux). This overlay can be globally accessed and is intended for users seeking commonly available development or scripting tools system-wide. Requires Nix/Nixpkgs infrastructure and an overlay-aware Nix configuration. The main parameters include custom package selection and overlay naming. The resulting environment can be built and installed globally, but only one python environment may be installed globally due to PATH conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\n# ~/.config/nixpkgs/overlays/myEnv.nix\nself: super: {\n  myEnv = super.buildEnv {\n    name = \"myEnv\";\n    paths = [\n      # A Python 3 interpreter with some packages\n      (self.python3.withPackages (\n        ps: with ps; [\n          pyflakes\n          pytest\n          black\n        ]\n      ))\n\n      # Some other packages we'd like as part of this env\n      self.mypy\n      self.black\n      self.ripgrep\n      self.tmux\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Akkoma Service with Custom Instance Settings - Nix\nDESCRIPTION: This Nix configuration snippet enables the Akkoma service and supplies core settings such as instance metadata and network binding to a Unix socket for proxy use. It defines the instance's name, description, contact email, and registration policy, as well as the public URL host. Required secrets are referenced separately, with most values written directly. Dependencies include the Akkoma NixOS module and accurate file paths for any secrets. Inputs are module options and attributes; output is an operational configuration file for Akkoma.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.enable = true;\n  services.akkoma.config = {\n    \":pleroma\" = {\n      \":instance\" = {\n        name = \"My Akkoma instance\";\n        description = \"More detailed description\";\n        email = \"admin@example.com\";\n        registration_open = false;\n      };\n\n      \"Pleroma.Web.Endpoint\" = {\n        url.host = \"fediverse.example.com\";\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Correct mkIf Usage for Conditional Definition\nDESCRIPTION: Proper way to handle conditional option definitions using mkIf to avoid infinite recursion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = mkIf config.services.httpd.enable {\n    environment.systemPackages = [ /* ... */ ];\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Python Script with nix-shell as Shebang for Self-Contained Dependency Management - Python - Python\nDESCRIPTION: Python script that uses a nix-shell shebang to declaratively specify Python and its dependencies (numpy) in-source. Top lines instruct Nix to invoke the script with Python 3 and the listed package automatically. Allows running the script directly on any system with Nix installed, independently of host Python setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env nix-shell\n#!nix-shell -i python3 -p \"python3.withPackages(ps: [ ps.numpy ])\"\nimport numpy as np\na = np.array([1,2])\nb = np.array([3,4])\nprint(f\"The dot product of {a} and {b} is: {np.dot(a, b)}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Nextcloud Service with PostgreSQL - Nix\nDESCRIPTION: This NixOS configuration snippet demonstrates how to enable the Nextcloud service using the default nginx HTTP server and configure it to use a locally managed PostgreSQL database. It sets up the admin password source file and the firewall ports for HTTP/HTTPS access. Dependencies include the Nextcloud package, PHP-FPM, and PostgreSQL, which are managed automatically by NixOS when using this module. Inputs required are valid hostName and adminpassFile paths; upon deployment, Nextcloud will be running and accessible at the configured host.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/nextcloud.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  services.nextcloud = {\n    enable = true;\n    hostName = \"nextcloud.tld\";\n    database.createLocally = true;\n    config = {\n      dbtype = \"pgsql\";\n      adminpassFile = \"/path/to/admin-pass-file\";\n    };\n  };\n\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using pytestCheckHook in Nix Python Packages\nDESCRIPTION: Demonstrates how to use pytestCheckHook to run pytest tests for Python packages. This hook sets up the checkPhase to run pytest and automatically includes pytest as a dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_33\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeCheckInputs = [\n    pytestCheckHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Python Environment with Overridden Packages - Nix\nDESCRIPTION: Creates a custom Python 3.12 environment in Nix by defining a user-local build of the 'toolz' package using buildPythonPackage within a let block and including it in a withPackages call alongside numpy. This is useful for testing custom package builds or temporary overrides outside of the Nixpkgs repository. Requires importing nixpkgs, specifying interpreter version, and using fetchPypi for source. The result is a shell environment suitable for Python development and experimentation, with precise control over included package versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(\n  let\n    my_toolz = python312.pkgs.buildPythonPackage rec {\n      pname = \"toolz\";\n      version = \"0.10.0\";\n      pyproject = true;\n\n      src = fetchPypi {\n        inherit pname version;\n        hash = \"sha256-CP3V73yWSArRHBLUct4hrNMjWZlvaaUlkpm1QP66RWA=\";\n      };\n\n      build-system = [\n        python312.pkgs.setuptools\n      ];\n\n      # has no tests\n      doCheck = false;\n\n      meta = {\n        homepage = \"https://github.com/pytoolz/toolz/\";\n        description = \"List processing tools and functional utilities\";\n        # [...]\n      };\n    };\n\n  in\n  python312.withPackages (\n    ps: with ps; [\n      numpy\n      my_toolz\n    ]\n  )\n).env\n```\n\n----------------------------------------\n\nTITLE: Enabling LightDM Auto-login for a User - Nix\nDESCRIPTION: Enables LightDM as the display manager and configures auto-login for the user 'alice'. Sets both services.xserver.displayManager.lightdm.enable and services.displayManager.autoLogin.enable to true, and specifies the user. All three fields must be set for auto-login to function properly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.lightdm.enable = true;\n  services.displayManager.autoLogin.enable = true;\n  services.displayManager.autoLogin.user = \"alice\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Manual Maven Artifacts for Offline Build - Nix\nDESCRIPTION: Shows how to provide additional dynamic test dependencies manually to maven.buildMavenPackage, ensuring an offline build works correctly even when go-offline cannot resolve dynamic dependencies. The manualMvnArtifacts attribute is assigned a list of Maven coordinates for required artifacts. Requires knowledge of the needed dynamic dependencies for the project.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nmaven.buildMavenPackage rec {\n  manualMvnArtifacts = [\n    # add dynamic test dependencies here\n    \"org.apache.maven.surefire:surefire-junit-platform:3.1.2\"\n    \"org.junit.platform:junit-platform-launcher:1.10.0\"\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating MBR Partition Scheme for NixOS\nDESCRIPTION: Commands to create a basic MBR partition scheme with a main partition and a swap partition for a BIOS-based system installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_23\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mklabel msdos\n# parted /dev/sda -- mkpart primary 1MB -8GB\n# parted /dev/sda -- mkpart primary linux-swap -8GB 100%\n```\n\n----------------------------------------\n\nTITLE: Ensuring Derivation Equality for Package Builds - Nix - nix\nDESCRIPTION: This code compares two package derivations for equality—ensuring changes like enabling checks do not alter the build plan. The testers.testEqualDerivation function is used to assert that the hello package and a variant with doCheck enabled have identical build instructions, helping to guard against accidental cache misses due to configuration changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\ntesters.testEqualDerivation \"The hello package must stay the same when enabling checks.\" hello (\n  hello.overrideAttrs (o: {\n    doCheck = true;\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment with nix-shell\nDESCRIPTION: Sets up a Python virtual environment using nix-shell with pip support. Includes configuration for dependencies and post-creation hooks for pip installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_51\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  pythonPackages = python3Packages;\nin\npkgs.mkShell rec {\n  name = \"impurePythonEnv\";\n  venvDir = \"./.venv\";\n  buildInputs = [\n    pythonPackages.python\n    pythonPackages.venvShellHook\n    pythonPackages.numpy\n    pythonPackages.requests\n    taglib\n    openssl\n    git\n    libxml2\n    libxslt\n    libzip\n    zlib\n  ];\n\n  postVenvCreation = ''\n    unset SOURCE_DATE_EPOCH\n    pip install -r requirements.txt\n  '';\n\n  postShellHook = ''\n    unset SOURCE_DATE_EPOCH\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: mkPackageOption Simple Example\nDESCRIPTION: Demonstrates simple usage of mkPackageOption with the hello package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlib.mkPackageOption pkgs \"hello\" { }\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.hello;\n  defaultText = lib.literalExpression \"pkgs.hello\";\n  description = \"The hello package to use.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Build Dependencies in buildInputs - Nix\nDESCRIPTION: This snippet extends the derivation with the buildInputs attribute, listing dependencies required during the build and runtime (e.g., libraries or tools placed in PATH and available for compiler includes). Each listed package (libbar, perl, ncurses) must be available in scope, and this ensures their binaries and headers are accessible in the build environment. This pattern is essential for providing necessary libraries or interpreters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  pname = \"libfoo\";\n  version = \"1.2.3\";\n  # ...\n  buildInputs = [\n    libbar\n    perl\n    ncurses\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Derivation Attributes with overrideAttrs (Nix Language)\nDESCRIPTION: Demonstrates overriding attributes for a derivation using overrideAttrs. The first example shows how to append to the pname by using both finalAttrs and previousAttrs functions, while retaining other attributes. The second example shows a simpler case where only the separateDebugInfo attribute is set. Requires pkgs.hello or another derivation supporting .overrideAttrs. Outputs are modified derivations based on input attribute changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  helloBar = pkgs.hello.overrideAttrs (\n    finalAttrs: previousAttrs: {\n      pname = previousAttrs.pname + \"-bar\";\n    }\n  );\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  helloWithDebug = pkgs.hello.overrideAttrs {\n    separateDebugInfo = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistent Yggdrasil Node with Prefix Announcement in NixOS\nDESCRIPTION: This snippet shows how to configure a persistent Yggdrasil node with a fixed address that announces a prefix. It enables IPv6 forwarding, sets up network interfaces, and configures radvd for prefix announcement. The configuration maintains a fixed public key and IPv6 address.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/yggdrasil.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  address = \"210:5217:69c0:9afc:1b95:b9f:8718:c3d2\";\n  prefix = \"310:5217:69c0:9afc\";\n  # taken from the output of \"yggdrasilctl getself\".\nin {\n\n  services.yggdrasil = {\n    enable = true;\n    persistentKeys = true; # Maintain a fixed public key and IPv6 address.\n    settings = {\n      Peers = [ \"tcp://1.2.3.4:1024\" \"tcp://1.2.3.5:1024\" ];\n      NodeInfo = {\n        # This information is visible to the network.\n        name = config.networking.hostName;\n        location = \"The North Pole\";\n      };\n    };\n  };\n\n  boot.kernel.sysctl.\"net.ipv6.conf.all.forwarding\" = 1;\n    # Forward traffic under the prefix.\n\n  networking.interfaces.${eth0}.ipv6.addresses = [{\n    # Set a 300::/8 address on the local physical device.\n    address = prefix + \"::1\";\n    prefixLength = 64;\n  }];\n\n  services.radvd = {\n    # Announce the 300::/8 prefix to eth0.\n    enable = true;\n    config = ''\n      interface eth0\n      {\n        AdvSendAdvert on;\n        prefix ${prefix}::/64 {\n          AdvOnLink on;\n          AdvAutonomous on;\n        };\n        route 200::/8 {};\n      };\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a File System Mount in NixOS with Nix\nDESCRIPTION: This Nix code defines a file system mount by setting an attribute in the fileSystems config, specifying the target mount point, device, and file system type. Dependencies include a running NixOS system, proper device naming (e.g., paths from /dev/disk/by-label), and NixOS module system. The key parameters are device (which path to mount) and fsType (the type of file system), with the mount point set as a key. Inputs are Nix attribute values; outputs are fstab and systemd unit generation for automated mounting. If options like \"noauto\" or \"nofail\" are set, mounting behavior changes accordingly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/file-systems.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems.\"/data\" =\n    { device = \"/dev/disk/by-label/data\";\n      fsType = \"ext4\";\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Mosquitto MQTT Broker in NixOS\nDESCRIPTION: A minimal configuration for Mosquitto that enables the service, starts a broker on port 1883, and allows anonymous read/write access to all topics.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/mosquitto.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mosquitto = {\n    enable = true;\n    listeners = [ {\n      acl = [ \"pattern readwrite #\" ];\n      omitPasswordAuth = true;\n      settings.allow_anonymous = true;\n    } ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Node K3s Server - NixOS Module - Nix\nDESCRIPTION: Configures a single-node K3s server instance on NixOS using a Nix expression. This snippet enables K3s in server mode, opens the necessary API and etcd-related TCP ports via the firewall, and specifies additional service flags. Key parameters include the allowedTCPPorts (for API and etcd access), allowedUDPPorts (commented guidance for multi-node networking), and extraFlags for advanced K3s configuration. Requires the NixOS k3s module; the output is a functioning single-node K3s Kubernetes cluster accessible via kubectl.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/USAGE.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.allowedTCPPorts = [\n    6443 # k3s: required so that pods can reach the API server (running on port 6443 by default)\n    # 2379 # k3s, etcd clients: required if using a \"High Availability Embedded etcd\" configuration\n    # 2380 # k3s, etcd peers: required if using a \"High Availability Embedded etcd\" configuration\n  ];\n  networking.firewall.allowedUDPPorts = [\n    # 8472 # k3s, flannel: required if using multi-node for inter-node networking\n  ];\n  services.k3s.enable = true;\n  services.k3s.role = \"server\";\n  services.k3s.extraFlags = toString [\n    # \"--debug\" # Optionally add additional args to k3s\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using Overlays to Override Dependency Version Globally - Nix\nDESCRIPTION: This advanced Nix example shows how to use overlays to globally override a dependency (numpy) for a Python interpreter (python310), and then build an application (inkscape) with the new interpreter. The overlay alters the numpy version throughout the Python package set, providing consistency for the whole system or for large projects. This snippet presupposes familiarity with overlays and Nixpkgs internals, and outputs a derivation for inkscape built against custom Python dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_48\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  newpkgs = import pkgs.path {\n    overlays = [\n      (self: super: {\n        python310 =\n          let\n            packageOverrides = python-self: python-super: {\n              numpy = python-super.numpy_1_18;\n            };\n          in\n          super.python310.override { inherit packageOverrides; };\n      })\n    ];\n  };\nin\nnewpkgs.inkscape\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Minimal JRE Modules with jre_minimal.override (Nix)\nDESCRIPTION: Illustrates overriding the default modules in a minimal JRE via jre_minimal.override, allowing selection of exactly which Java modules (e.g., java.base, java.logging) are included. Depends on pkgs.jre_minimal and pkgs.something/other, enabling smaller images tailored for specific apps. Inputs: list of Java modules. Outputs: minimal, size-optimized JREs. Implementation uses Nix's let/in syntax for sharing the customized JRE among multiple packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  my_jre = pkgs.jre_minimal.override {\n    modules = [\n      # The modules used by 'something' and 'other' combined:\n      \"java.base\"\n      \"java.logging\"\n    ];\n  };\n  something = (pkgs.something.override { jre = my_jre; });\n  other = (pkgs.other.override { jre = my_jre; });\nin\n<...>\n```\n\n----------------------------------------\n\nTITLE: Enabling GNOME Desktop and GDM - NixOS Module Configuration - Nix\nDESCRIPTION: This snippet enables the GNOME desktop environment and the GDM display manager in NixOS by setting the appropriate module options in the Nix configuration. It requires access to the 'services.xserver.desktopManager.gnome' and 'services.xserver.displayManager.gdm' options through the NixOS modules system. Inputs are Nix attribute sets defining the enabled services; outputs are a NixOS system with GNOME and GDM activated. Both must be set for some features (like screen lock) to function as recommended.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.gnome.enable = true;\n  services.xserver.displayManager.gdm.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating SSH Keys for BorgBackup Server\nDESCRIPTION: Terminal commands to generate an SSH key for a BorgBackup repository and display the public key. This key will be used for authorization in the Borg server setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# sudo ssh-keygen -N '' -t ed25519 -f /run/keys/id_ed25519_my_borg_repo\n# cat /run/keys/id_ed25519_my_borg_repo\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID78zmOyA+5uPG4Ot0hfAy+sLDPU1L4AiIoRYEIVbbQ/ root@nixos\n```\n\n----------------------------------------\n\nTITLE: Creating Java Program Wrappers with makeWrapper (Nix)\nDESCRIPTION: Shows how to use makeWrapper in the installPhase to generate a launcher script for a Java program, specifying the JRE to use and classpath settings. Requires makeWrapper and a valid JRE package as dependencies. Inputs include the path to the main JAR and main class; produces a runnable script in $out/bin. Useful for packaging Java CLI applications.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ makeWrapper ];\n\n  installPhase = ''\n    mkdir -p $out/bin\n    makeWrapper ${jre}/bin/java $out/bin/foo \\\n      --add-flags \"-cp $out/share/java/foo.jar org.foo.Main\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Updating Nixpkgs Repository with Git in ShellSession\nDESCRIPTION: This snippet demonstrates cloning the Nixpkgs repository from GitHub, navigating into the directory, and updating remote references with Git. It requires Git to be installed and a network connection for accessing GitHub. The primary inputs are the git clone URL and target directory, and it results in a local copy of the Nixpkgs repo ready for further operations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git clone https://github.com/NixOS/nixpkgs\n$ cd nixpkgs\n$ git remote update origin\n```\n\n----------------------------------------\n\nTITLE: Configuring Extra Read/Write Paths in FoundationDB NixOS Module (Nix)\nDESCRIPTION: This snippet illustrates how to extend FoundationDB's writable directory access in NixOS by setting the extraReadWritePaths option within the NixOS module configuration. The specified path(s) are whitelisted for both read and write access within the FoundationDB systemd unit, enabling flexible placement of backups. To use, ensure the listed directories exist before restarting the FoundationDB service, as systemd will only add them to the namespace at startup, not dynamically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.foundationdb.extraReadWritePaths = [ \"/opt/fdb-backups\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Swap Space for Low-Memory Systems\nDESCRIPTION: Command to enable a swap partition to provide additional virtual memory for systems with limited RAM. This is especially important during installation when building packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_16\n\nLANGUAGE: ShellSession\nCODE:\n```\n# swapon /dev/sda2\n```\n\n----------------------------------------\n\nTITLE: Joining Additional Nodes to Multi-Node K3s Cluster - NixOS Module - Nix\nDESCRIPTION: Provides the Nix expression to add subsequent control-plane or agent nodes to an existing K3s cluster. This configuration ensures nodes join via the specified cluster API address and use a shared secret token for trust/authentication. Prerequisites include having previously initialized the primary node with 'clusterInit', open firewall ports, and distribution of the common token to all joining nodes. Inputs include the role, token, and API server IP; the result is a joined, scalable K3s cluster on NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/USAGE.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.k3s = {\n    enable = true;\n    role = \"server\"; # Or \"agent\" for worker only nodes\n    token = \"<randomized common secret>\";\n    serverAddr = \"https://<ip of first node>:6443\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Kernel Modules in NixOS\nDESCRIPTION: Configuration example for forcing specific kernel modules to be loaded at boot time using the boot.kernelModules option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Kime Korean Input Method in NixOS\nDESCRIPTION: Configuration for enabling Kime, a Rust-based Korean input method engine focused on simplicity and performance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"kime\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Basic NixOS Test Module Structure\nDESCRIPTION: Demonstrates the basic structure of a NixOS test module with node configurations and test script\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # One or more machines:\n  nodes =\n    { machine =\n        { config, pkgs, ... }: { /* ... */ };\n      machine2 =\n        { config, pkgs, ... }: { /* ... */ };\n      # …\n    };\n\n  testScript =\n    ''\n      Python code…\n    '';\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Test to NixOS All-Tests Configuration\nDESCRIPTION: Shows how to add a test to the NixOS all-tests.nix file with optional overrides\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hostname = runTest ./hostname.nix;\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hostname = runTest {\n    imports = [ ./hostname.nix ];\n    defaults.networking.firewall.enable = false;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Host Name Option Using String - NixOS - nix\nDESCRIPTION: Sets the system's network host name in NixOS using a string value in an option definition. Requires correct key (networking.hostName) and a string parameter. Useful as a minimal example for assigning textual values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.hostName = \"dexter\";\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling with Custom Target and Platform JSON - Nix Shell & Nix Expressions\nDESCRIPTION: Elaborates on cross-compiling Rust for a custom (non-standard) target using both the `rustcTarget` name and supplying a JSON platform configuration. The platform value is serialized to a JSON file whose path is used as the cargo target. This technique is suitable for highly specialized or embedded targets. Requirements: Nixpkgs, a crossSystem config, and suitable Rust support on the platform.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\nimport <nixpkgs> {\n  crossSystem = (import <nixpkgs/lib>).systems.examples.armhf-embedded // {\n    rust.rustcTarget = \"thumb-crazy\";\n    rust.platform = {\n      foo = \"\";\n      bar = \"\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Go Test Selection with checkFlags - Nix\nDESCRIPTION: Illustrates narrowing down executed Go tests during the Nix build process by setting the `checkFlags` parameter. Specifically, the `-run` flag is passed with a regular expression to run only tests matching the supplied pattern (e.g., `TestSimple` or `TestFast`). This customization is set as an attribute within a Nix derivation when building with `buildGoModule`. Inputs are the flags in a list, and outputs are a restricted set of executed tests during build. The limitations are the patterns accepted by `go test`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # -run and -skip accept regular expressions\n  checkFlags = [\n    \"-run=^Test(Simple|Fast)$\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Simple Ephemeral Yggdrasil Node in NixOS\nDESCRIPTION: This snippet demonstrates a basic configuration for an ephemeral Yggdrasil node in NixOS. It enables the Yggdrasil service, sets non-persistent keys, and specifies peer connections. The configuration generates new keys and IPv6 address on each start.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/yggdrasil.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.yggdrasil = {\n    enable = true;\n    persistentKeys = false;\n      # The NixOS module will generate new keys and a new IPv6 address each time\n      # it is started if persistentKeys is not enabled.\n\n    settings = {\n      Peers = [\n        # Yggdrasil will automatically connect and \"peer\" with other nodes it\n        # discovers via link-local multicast announcements. Unless this is the\n        # case (it probably isn't) a node needs peers within the existing\n        # network that it can tunnel to.\n        \"tcp://1.2.3.4:1024\"\n        \"tcp://1.2.3.5:1024\"\n        # Public peers can be found at\n        # https://github.com/yggdrasil-network/public-peers\n      ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching GitHub Source with fetchFromGitHub (Best Practice)\nDESCRIPTION: The recommended approach for fetching source code from GitHub using fetchFromGitHub, which retrieves a snapshot archive for the given revision and is more efficient.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  src = fetchFromGitHub {\n    owner = \"NixOS\";\n    repo = \"nix\";\n    rev = \"1f795f9f44607cc5bec70d1300150bfefcef2aae\";\n    hash = \"sha256-7D4m+saJjbSFP5hOwpQq2FGR2rr+psQMTcyb1ZvtXsQ=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions via Intermediate Oneshot Service as Service User - NixOS systemd Service - Nix\nDESCRIPTION: Creates a oneshot systemd service, configured to run as the service user, that performs permission grants on its database before the main service starts. This leverages environment and path setup for finding the appropriate psql binary. Appropriate when the service user has sufficient rights and allows for flexible migration timing. Key parameters are serviceConfig.User and SQL command execution in the script field. It is safe for incremental and idempotent permission assignment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n  {\n    systemd.services.\"migrate-service1-db1\" = {\n      serviceConfig.Type = \"oneshot\";\n      requiredBy = \"service1.service\";\n      before = \"service1.service\";\n      after = \"postgresql.service\";\n      serviceConfig.User = \"service1\";\n      environment.PSQL = \"psql --port=${toString services.postgresql.settings.port}\";\n      path = [ postgresql ];\n      script = ''\n        $PSQL -c 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"extraUser1\"'\n        $PSQL -c 'GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO \"extraUser1\"'\n        # ....\n      '';\n    };\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining an Overlay in Nix\nDESCRIPTION: This snippet demonstrates how to define an overlay in Nix. It overrides the 'boost' package to use Python 3 and adds a new package 'rr' with custom dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nself: super:\n\n{\n  boost = super.boost.override {\n    python = self.python3;\n  };\n  rr = super.callPackage ./pkgs/rr {\n    stdenv = self.stdenv_32bit;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Python Script with Specified nix-shell Environment - ShellSession - Shell\nDESCRIPTION: Shows executing a Python script requiring numpy by running it within a nix-shell session configured for numpy. Utilizes --run to directly invoke the script ('python3 foo.py'). Ensures dependencies are present without manual environment setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_18\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p 'python312.withPackages (ps: with ps; [ numpy ])' --run 'python3 foo.py'\nThe dot product of [1 2] and [3 4] is: 11\n```\n\n----------------------------------------\n\nTITLE: Building the datashape Package with buildPythonPackage - Nix\nDESCRIPTION: This snippet demonstrates a Nix expression for building the datashape Python package using buildPythonPackage. It specifies Python runtime dependencies (multipledispatch, numpy, python-dateutil), build-time dependency (setuptools), and test hook (pytestCheckHook), showing how to categorize each dependency. Required dependencies: Nix, nixpkgs, Python, setuptools, and other listed packages. Expected input is a set of arguments mapping to available packages; the output is a derivation for the datashape package with metadata provided for Nix's package manager. Tests are configured to use pytestCheckHook as nativeCheckInput, and no system libraries are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_29\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n\n  # build dependencies\n  setuptools,\n\n  # dependencies\n  numpy,\n  multipledispatch,\n  python-dateutil,\n\n  # tests\n  pytestCheckHook,\n}:\n\nbuildPythonPackage rec {\n  pname = \"datashape\";\n  version = \"0.4.7\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-FLLvdm1MllKrgTGC6Gb0k0deZeVYvtCCLji/B7uhong=\";\n  };\n\n  build-system = [\n    setuptools\n  ];\n\n  dependencies = [\n    multipledispatch\n    numpy\n    python-dateutil\n  ];\n\n  nativeCheckInputs = [\n    pytestCheckHook\n  ];\n\n  meta = {\n    changelog = \"https://github.com/blaze/datashape/releases/tag/${version}\";\n    homepage = \"https://github.com/ContinuumIO/datashape\";\n    description = \"Data description language\";\n    license = lib.licenses.bsd2;\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Loading Built Docker Image via nix-build and docker image load (shell)\nDESCRIPTION: These shell commands demonstrate building a Docker image from the provided Nix expression using 'nix-build', resulting in a .tar.gz file. The resulting image is then loaded into Docker with 'docker image load -i'. Assumes Nix is installed and dockerTools expressions are set as per the previous snippet. The input is a Nix derivation; output is a Docker image available in the local daemon.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\nbuilding '/nix/store/yw0adm4wpsw1w6j4fb5hy25b3arr9s1v-docker-image-redis.tar.gz.drv'...\nAdding layer...\ntar: Removing leading `/' from member names\nAdding meta...\nCooking the image...\nFinished.\n/nix/store/p4dsg62inh9d2ksy3c7bv58xa851dasr-docker-image-redis.tar.gz\n\n$ docker image load -i /nix/store/p4dsg62inh9d2ksy3c7bv58xa851dasr-docker-image-redis.tar.gz\n(some output removed for clarity)\nLoaded image: redis:latest\n\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Roles and Database for Matrix Synapse - SQL\nDESCRIPTION: Initializes a PostgreSQL role and database specifically for the matrix-synapse homeserver. This snippet creates a role and database both named \\\"matrix-synapse\\\", with language and collation settings set to 'C' for broad compatibility. The role must exist before Synapse can connect; adapt the password and access controls according to your security policy.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/synapse.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE ROLE \"matrix-synapse\";\nCREATE DATABASE \"matrix-synapse\" WITH OWNER \"matrix-synapse\"\n  TEMPLATE template0\n  LC_COLLATE = \"C\"\n  LC_CTYPE = \"C\";\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Shares for a systemd Service - NixOS Configuration - nix\nDESCRIPTION: This Nix expression shows how to configure CPU resource allocation for a specific systemd service (here 'httpd.service') by setting the 'CPUShares' value. It adjusts the number of CPU shares assigned to the service, effectively throttling or boosting CPU access relative to other services. This configuration snippet requires placement in the 'configuration.nix' file and assumes familiarity with NixOS's declarative configuration model and the 'systemd.services' attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/control-groups.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  systemd.services.httpd.serviceConfig.CPUShares = 512;\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple NixOS Modules - Nix\nDESCRIPTION: This snippet shows how to include multiple NixOS configuration modules by listing them in the imports array. Dependencies: The 'pkgs' and 'config' should be provided by the NixOS system. Each module being imported (e.g., vpn.nix, kde.nix) must exist in the same directory. The snippet also demonstrates enabling the HTTP daemon (services.httpd) and adding Emacs to system packages. Input: N/A; Output: A composed system configuration with merged imports and options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ imports = [ ./vpn.nix ./kde.nix ];\n  services.httpd.enable = true;\n  environment.systemPackages = [ pkgs.emacs ];\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using pythonRelaxDepsHook with Global Option\nDESCRIPTION: Shows how to relax all dependencies with pythonRelaxDepsHook by setting the option to true. This is useful when you need to override all version constraints at once.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_39\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pythonRelaxDeps = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Python 3 Environment with python3.withPackages (Nix)\nDESCRIPTION: This snippet shows building a Python 3 environment in Nix using python3.withPackages, providing version-specific dependency resolution. It defines ps as python3Packages, enabling inclusion of the Pyramid package. Requires Nixpkgs and the Python 3 package set. The function argument provides the package list, and the output is a Python 3 interpreter environment with desired packages installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\npython3.withPackages (ps: [ ps.pyramid ])\n```\n\n----------------------------------------\n\nTITLE: Overriding Akkoma Primary Frontend Configuration with Custom Derivation - Nix\nDESCRIPTION: This Nix override provides a custom derivation for the primary Akkoma frontend, specifying a JSON-formatted config, using jq and lndir for file manipulation within a build sandbox. It illustrates building a new frontend package by merging a custom config into the default, requires pkgs.jq and pkgs.xorg.lndir, and key params include feature toggles, UX flags, and post formatting. Output is a new frontend package with merged configuration, supportive of advanced customizations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.frontends.primary.package = pkgs.runCommand \"akkoma-fe\" {\n    config = builtins.toJSON {\n      expertLevel = 1;\n      collapseMessageWithSubject = false;\n      stopGifs = false;\n      replyVisibility = \"following\";\n      webPushHideIfCW = true;\n      hideScopeNotice = true;\n      renderMisskeyMarkdown = false;\n      hideSiteFavicon = true;\n      postContentType = \"text/markdown\";\n      showNavShortcuts = false;\n    };\n    nativeBuildInputs = with pkgs; [ jq xorg.lndir ];\n    passAsFile = [ \"config\" ];\n  } ''\n    mkdir $out\n    lndir ${pkgs.akkoma-frontends.akkoma-fe} $out\n\n    rm $out/static/config.json\n    jq -s add ${pkgs.akkoma-frontends.akkoma-fe}/static/config.json ${config} \\\n      >$out/static/config.json\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Additional SSH Options for SSHFS in NixOS\nDESCRIPTION: Example of adding extra SSH options to the SSHFS configuration in NixOS, such as changing the default port or specifying a jump proxy.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options =\n    [ \"ProxyJump=bastion@example.com\"\n      \"Port=22\"\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Entering a Haskell Development Environment with Nix-Shell (Console)\nDESCRIPTION: This console sequence shows how to enter a preconfigured Haskell development environment using nix-shell and the env attribute of a package. This makes all dependencies of a Haskell package (e.g., 'random') available to GHC within the shell, allowing interactive development and inspection. The command requires nix-shell and an appropriate Nixpkgs channel. Input: path to the project directory and package environment; Output: interactive shell with GHC setup to find all dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ cd ~/src/random\n$ nix-shell -A haskellPackages.random.env '<nixpkgs>'\n[nix-shell:~/src/random]$ ghc-pkg list\n/nix/store/a8hhl54xlzfizrhcf03c1l3f6l9l8qwv-ghc-9.2.4-with-packages/lib/ghc-9.2.4/package.conf.d\n    Cabal-3.6.3.0\n    array-0.5.4.0\n    base-4.16.3.0\n    binary-0.8.9.0\n    …\n    ghc-9.2.4\n    …\n```\n\n----------------------------------------\n\nTITLE: Building Custom Mattermost Plugins with buildPlugin Passthru - NixOS Module - Nix\nDESCRIPTION: This snippet configures Mattermost to build and install a custom plugin using the 'mattermost.buildPlugin' passthru from Nixpkgs. It specifies the plugin name, version, source repository, hashes for both the source and dependencies, and extra Go and NPM build options. Required dependencies include the Nixpkgs 'mattermost' attribute and a working 'fetchFromGitHub' function. Inputs are plugin-specific metadata and hashes; outputs are fully built plugin tarballs included in the Mattermost instance. The configuration relies on correct dependency hashes and assumes the lockfile is assembled properly for NPM builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/mattermost.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mattermost = {\n    plugins = with pkgs; [\n      (mattermost.buildPlugin {\n        pname = \"mattermost-plugin-todo\";\n        version = \"0.8-pre\";\n        src = fetchFromGitHub {\n          owner = \"mattermost-community\";\n          repo = \"mattermost-plugin-todo\";\n          # 0.7.1 didn't work, seems to use an older set of node dependencies.\n          rev = \"f25dc91ea401c9f0dcd4abcebaff10eb8b9836e5\";\n          hash = \"sha256-OM+m4rTqVtolvL5tUE8RKfclqzoe0Y38jLU60Pz7+HI=\";\n        };\n        vendorHash = \"sha256-5KpechSp3z/Nq713PXYruyNxveo6CwrCSKf2JaErbgg=\";\n        npmDepsHash = \"sha256-o2UOEkwb8Vx2lDWayNYgng0GXvmS6lp/ExfOq3peyMY=\";\n        extraGoModuleAttrs = {\n          npmFlags = [ \"--legacy-peer-deps\" ];\n        };\n      })\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring an IPv6 Default Gateway on NixOS - Nix\nDESCRIPTION: Sets the system-wide IPv6 default gateway on NixOS, optionally associating it with a specified interface. The 'networking.defaultGateway6' attribute is set to an object specifying both 'address' and 'interface'. Requires a valid interface name and a routable IPv6 gateway address. No additional dependencies, but correct functioning depends on network topology and interface availability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv6-config.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.defaultGateway6 = {\n    address = \"fe00::1\";\n    interface = \"enp0s3\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring systemd services to wait for network connectivity in NixOS\nDESCRIPTION: This snippet demonstrates how to properly configure systemd services to wait for network connectivity before starting. This is now required since `multi-user.target` is no longer ordered after `network-online.target`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nsystemd.services.<name> = {\n  wants = [ \"network-online.target\" ];\n  after = [ \"network-online.target\" ];\n};\n```\n\n----------------------------------------\n\nTITLE: Packaging Elixir Phoenix application with mix2nix\nDESCRIPTION: This Nix snippet demonstrates how to package an Elixir Phoenix application using mix2nix. It imports the generated mix dependencies and handles git dependencies by overriding the import function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mixNixDeps = import ./mix.nix {\n    inherit beamPackages lib;\n    overrides = (\n      final: prev: {\n        # mix2nix does not support git dependencies yet,\n        # so we need to add them manually\n        prometheus_ex = beamPackages.buildMix rec {\n          name = \"prometheus_ex\";\n          version = \"3.0.5\";\n\n          # Change the argument src with the git src that you actually need\n          src = fetchFromGitLab {\n            domain = \"git.pleroma.social\";\n            group = \"pleroma\";\n            owner = \"elixir-libraries\";\n            repo = \"prometheus.ex\";\n            rev = \"a4e9beb3c1c479d14b352fd9d6dd7b1f6d7deee5\";\n            hash = \"sha256-U17LlN6aGUKUFnT4XyYXppRN+TvUBIBRHEUsfeIiGOw=\";\n          };\n          # you can re-use the same beamDeps argument as generated\n          beamDeps = with final; [ prometheus ];\n        };\n      }\n    );\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging an npm Project using buildNpmPackage - Nix\nDESCRIPTION: This Nix expression demonstrates building an npm-based project with buildNpmPackage by specifying all required attributes such as source location, dependency hash, and metadata. It illustrates overriding the npm prepack script, supplying npm flags, and specifying a Node.js provider for compatibility. Dependencies include buildNpmPackage, fetchFromGitHub, and a suitable lib attribute set. The output is a packaged derivation suitable for use in other Nix workflows, with reproducible deps and override options for custom build environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildNpmPackage,\n  fetchFromGitHub,\n}:\n\nbuildNpmPackage (finalAttrs: {\n  pname = \"flood\";\n  version = \"4.7.0\";\n\n  src = fetchFromGitHub {\n    owner = \"jesec\";\n    repo = \"flood\";\n    tag = \"v${finalAttrs.version}\";\n    hash = \"sha256-BR+ZGkBBfd0dSQqAvujsbgsEPFYw/ThrylxUbOksYxM=\";\n  };\n\n  npmDepsHash = \"sha256-tuEfyePwlOy2/mOPdXbqJskO6IowvAP4DWg8xSZwbJw=\";\n\n  # The prepack script runs the build script, which we'd rather do in the build phase.\n  npmPackFlags = [ \"--ignore-scripts\" ];\n\n  NODE_OPTIONS = \"--openssl-legacy-provider\";\n\n  meta = {\n    description = \"Modern web UI for various torrent clients with a Node.js backend and React frontend\";\n    homepage = \"https://flood.js.org\";\n    license = lib.licenses.gpl3Only;\n    maintainers = with lib.maintainers; [ winter ];\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Building and Loading a Nix-Generated Docker Image - Shell\nDESCRIPTION: This snippet shows the shell commands needed to build a streamNixShellImage-based Nix package and load the resulting Docker image into a local Docker daemon. It first runs nix-build, which produces a script, and then uses the script's output as input for docker image load. The process requires a functional nix-build environment with a suitable nixpkgs and access to Docker.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_36\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/8vhznpz2frqazxnd8pgdvf38jscdypax-stream-hello-2.12.1-env\n\n$ /nix/store/8vhznpz2frqazxnd8pgdvf38jscdypax-stream-hello-2.12.1-env | docker image load\n(some output removed for clarity)\nLoaded image: hello-2.12.1-env:latest\n```\n\n----------------------------------------\n\nTITLE: Dynamically Generating and Importing NixOS Modules - Nix\nDESCRIPTION: This snippet dynamically creates a module function to set networking options, and then imports the generated module on the fly. Dependencies: Requires a functional Nix environment and access to arguments config, pkgs, etc. Inputs: A hostName string; Output: A composed module which disables DHCP and sets the host's network name. This approach is useful for code-driven modularity instead of static files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\nlet netConfig = hostName: {\n  networking.hostName = hostName;\n  networking.useDHCP = false;\n};\n\nin\n\n{ imports = [ (netConfig \"nixos.localdomain\") ]; }\n```\n\n----------------------------------------\n\nTITLE: Using pythonImportsCheck for Basic Package Validation\nDESCRIPTION: Shows how to use pythonImportsCheck to verify that Python modules can be imported correctly. This provides a basic sanity check when proper test suites are not available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_37\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pythonImportsCheck = [\n    \"requests\"\n    \"urllib\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding package.json with jq in Nix\nDESCRIPTION: Demonstrates how to modify a package.json file using jq within a Nix expression. This technique allows for explicit overrides of package versions and dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  patchedPackageJSON = final.runCommand \"package.json\" { } ''\n    ${jq}/bin/jq '.version = \"0.4.0\" |\n      .devDependencies.\"@jsdoc/cli\" = \"^0.2.5\"\n      ${sonar-src}/package.json > $out\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a NixOS Container - ShellSession\nDESCRIPTION: This snippet demonstrates creating a new NixOS container named 'foo' via the nixos-container CLI utility. The command initializes the container's root directory, configuration, and system profile. Requires root permissions and the NixOS environment. The primary parameter is the container identifier ('foo'). Output includes the creation of new directories and configuration files, but does not start the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container create foo\n```\n\n----------------------------------------\n\nTITLE: Configuring Mailman with Postfix on NixOS (Nix)\nDESCRIPTION: This Nix code snippet demonstrates how to configure Mailman in conjunction with Postfix on NixOS. It enables Mailman, Postfix, and NGINX, sets relevant domains and SSL paths, and exposes necessary network ports. Key parameters include postfix domain and transport maps, Mailman web hosts and site owner, and the ACME certificate for secure HTTPS. The configuration expects correct DNS records and assumes an existing, working Postfix installation. Email authentication mechanisms like SPF, DKIM, and DMARC must still be configured separately.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/mail/mailman.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, ... }: {\n  services.postfix = {\n    enable = true;\n    relayDomains = [\"hash:/var/lib/mailman/data/postfix_domains\"];\n    sslCert = config.security.acme.certs.\"lists.example.org\".directory + \"/full.pem\";\n    sslKey = config.security.acme.certs.\"lists.example.org\".directory + \"/key.pem\";\n    config = {\n      transport_maps = [\"hash:/var/lib/mailman/data/postfix_lmtp\"];\n      local_recipient_maps = [\"hash:/var/lib/mailman/data/postfix_lmtp\"];\n    };\n  };\n  services.mailman = {\n    enable = true;\n    serve.enable = true;\n    hyperkitty.enable = true;\n    webHosts = [\"lists.example.org\"];\n    siteOwner = \"mailman@example.org\";\n  };\n  services.nginx.virtualHosts.\"lists.example.org\".enableACME = true;\n  networking.firewall.allowedTCPPorts = [ 25 80 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Root-Owned ACME Certificates for OpenSMTPD with systemd Credentials - Nix\nDESCRIPTION: Presents a full NixOS configuration pattern to support services requiring root-owned certificate files, using OpenSMTPD as an example. The snippet configures ACME with a postRun-restart hook, sets up systemd LoadCredential to pass certificates securely to the service, and finally configures OpenSMTPD to use the credentials path for its TLS configuration. Dependencies include systemd, NixOS, valid ACME cert generation, and OpenSMTPD. Key parameters are certificate paths, credential directory, and OpenSMTPD actions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Configure ACME however you like (DNS or HTTP validation), adding\n  # the following configuration for the relevant certificate.\n  # Note: You cannot use `systemctl reload` here as that would mean\n  # the LoadCredential configuration below would be skipped and\n  # the service would continue to use old certificates.\n  security.acme.certs.\"mail.example.com\".postRun = ''\n    systemctl restart opensmtpd\n  '';\n\n  # Now you must augment OpenSMTPD's systemd service to load\n  # the certificate files.\n  systemd.services.opensmtpd.requires = [\"acme-finished-mail.example.com.target\"];\n  systemd.services.opensmtpd.serviceConfig.LoadCredential = let\n    certDir = config.security.acme.certs.\"mail.example.com\".directory;\n  in [\n    \"cert.pem:${certDir}/cert.pem\"\n    \"key.pem:${certDir}/key.pem\"\n  ];\n\n  # Finally, configure OpenSMTPD to use these certs.\n  services.opensmtpd = let\n    credsDir = \"/run/credentials/opensmtpd.service\";\n  in {\n    enable = true;\n    setSendmail = false;\n    serverConfiguration = ''\n      pki mail.example.com cert \"${credsDir}/cert.pem\"\n      pki mail.example.com key \"${credsDir}/key.pem\"\n      listen on localhost tls pki mail.example.com\n      action act1 relay host smtp://127.0.0.1:10027\n      match for local action act1\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Symlinking Cargo.lock using postPatch - Nix Derivation Phase - Nix\nDESCRIPTION: Provides a method to add a missing `Cargo.lock` file to the source by creating a symbolic link in the `postPatch` build phase. The snippet uses shell syntax within a Nix string and expects `./Cargo.lock` to exist at evaluation time. This approach ensures compatibility with `buildRustPackage` without modifying the original source.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  postPatch = ''\n    ln -s ${./Cargo.lock} Cargo.lock\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Compiler and Cargo - Nix Expressions - Nix\nDESCRIPTION: This Nix snippet shows how to include the Rust compiler (`rustc`) and Cargo package manager in the system environment packages by modifying `configuration.nix`. No extra dependencies beyond the standard NixOS channel packages are required. Add these attributes to bring Rust tools into the system or use them interactively with `nix-shell`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    rustc\n    cargo\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging a Swift Project Using mkDerivation and swiftpm2nix in Nix\nDESCRIPTION: This large Nix snippet shows how to define a derivation (`mkDerivation`) for building a Swift project using files generated by `swiftpm2nix`. It requires the `stdenv`, `swift`, `swiftpm`, `swiftpm2nix`, and `fetchFromGitHub` packages as dependencies. The derivation is configured to use generated helper scripts for setting up dependencies and includes phases for configuration and installation of the main binary. Key parameters include project metadata (`pname`, `version`) and a `src` attribute to fetch project sources from GitHub. The derivation provides an automated build and install pipeline adapted for Nixpkgs and SwiftPM integration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  swift,\n  swiftpm,\n  swiftpm2nix,\n  fetchFromGitHub,\n}:\n\nlet\n  # Pass the generated files to the helper.\n  generated = swiftpm2nix.helpers ./nix;\nin\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"myproject\";\n  version = \"0.0.0\";\n\n  src = fetchFromGitHub {\n    owner = \"nixos\";\n    repo = \"myproject\";\n    tag = finalAttrs.version;\n    hash = \"\";\n  };\n\n  # Including SwiftPM as a nativeBuildInput provides a buildPhase for you.\n  # This by default performs a release build using SwiftPM, essentially:\n  #   swift build -c release\n  nativeBuildInputs = [\n    swift\n    swiftpm\n  ];\n\n  # The helper provides a configure snippet that will prepare all dependencies\n  # in the correct place, where SwiftPM expects them.\n  configurePhase = generated.configure;\n\n  installPhase = ''\n    runHook preInstall\n\n    # This is a special function that invokes swiftpm to find the location\n    # of the binaries it produced.\n    binPath=\"$(swiftpmBinPath)\"\n    # Now perform any installation steps.\n    mkdir -p $out/bin\n    cp $binPath/myproject $out/bin/\n\n    runHook postInstall\n  '';\n})\n```\n\n----------------------------------------\n\nTITLE: Packaging a Dotnet Application with buildDotnetModule - Nix\nDESCRIPTION: This Nix expression provides a full example of using buildDotnetModule to package a .NET application with specific project and dependency configuration. It demonstrates specifying project files, NuGet dependencies, buildInputs for project linkage, SDK/runtime selection, runtime and packaging options, and overrides for executables and runtime dependencies. The snippet relies on dependencies such as buildDotnetModule, dotnetCorePackages, and referencedProject. Inputs are project/meta attributes; output is a derivation for the .NET application in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildDotnetModule,\n  dotnetCorePackages,\n  ffmpeg,\n}:\n\nlet\n  referencedProject = import ../../bar {\n    # ...\n  };\nin\nbuildDotnetModule rec {\n  pname = \"someDotnetApplication\";\n  version = \"0.1\";\n\n  src = ./.;\n\n  projectFile = \"src/project.sln\";\n  nugetDeps = ./deps.json; # see \"Generating and updating NuGet dependencies\" section for details\n\n  buildInputs = [ referencedProject ]; # `referencedProject` must contain `nupkg` in the folder structure.\n\n  dotnet-sdk = dotnetCorePackages.sdk_8_0;\n  dotnet-runtime = dotnetCorePackages.runtime_8_0;\n\n  executables = [ \"foo\" ]; # This wraps \"$out/lib/$pname/foo\" to `$out/bin/foo`.\n  executables = [ ]; # Don't install any executables.\n\n  packNupkg = true; # This packs the project as \"foo-0.1.nupkg\" at `$out/share`.\n\n  runtimeDeps = [ ffmpeg ]; # This will wrap ffmpeg's library path into `LD_LIBRARY_PATH`.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nextcloud with httpd as Reverse-Proxy - Nix\nDESCRIPTION: This full NixOS configuration replaces nginx with httpd as the reverse-proxy for Nextcloud, and ensures the PHP-FPM pool used by Nextcloud is properly set up for socket permissions. It includes enabling the necessary httpd modules and virtual host configuration required for proxying PHP requests to Nextcloud. Dependencies include NixOS's httpd, Nextcloud, php-fpm, and proxy_fcgi Apache module. Parameters include hostName, adminAddr, and details for the services.phpfpm.pools and services.httpd.virtualHosts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/nextcloud.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }: {\n  services.nginx.enable = false;\n  services.nextcloud = {\n    enable = true;\n    hostName = \"localhost\";\n\n    /* further, required options */\n  };\n  services.phpfpm.pools.nextcloud.settings = {\n    \"listen.owner\" = config.services.httpd.user;\n    \"listen.group\" = config.services.httpd.group;\n  };\n  services.httpd = {\n    enable = true;\n    adminAddr = \"webmaster@localhost\";\n    extraModules = [ \"proxy_fcgi\" ];\n    virtualHosts.\"localhost\" = {\n      documentRoot = config.services.nextcloud.package;\n      extraConfig = ''\n        <Directory \"${config.services.nextcloud.package}\">\n          <FilesMatch \"\\\\.php$\">\n            <If \"-f %{REQUEST_FILENAME}\">\n              SetHandler \"proxy:unix:${config.services.phpfpm.pools.nextcloud.socket}|fcgi://localhost/\"\n            </If>\n          </FilesMatch>\n          <IfModule mod_rewrite.c>\n            RewriteEngine On\n            RewriteBase /\n            RewriteRule ^index\\\\.php$ - [L]\n            RewriteCond %{REQUEST_FILENAME} !-f\n            RewriteCond %{REQUEST_FILENAME} !-d\n            RewriteRule . /index.php [L]\n          </IfModule>\n          DirectoryIndex index.php\n          Require all granted\n          Options +FollowSymLinks\n        </Directory>\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available NixOS System Generations (Shell)\nDESCRIPTION: Lists all NixOS system profile generations available for rollback using a long directory listing. Run as any user in a shell to see the symbolic links corresponding to each configuration generation. Outputs details such as the link target and timestamps. No arguments beyond the path are necessary; the command is non-destructive and intended for information gathering.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rollback.section.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ ls -l /nix/var/nix/profiles/system-*-link\n...\nlrwxrwxrwx 1 root root 78 Aug 12 13:54 /nix/var/nix/profiles/system-268-link -> /nix/store/202b...-nixos-13.07pre4932_5a676e4-4be1055\n```\n\n----------------------------------------\n\nTITLE: Selecting a Specific Kernel Version in NixOS\nDESCRIPTION: This snippet demonstrates how to override the default Linux kernel with a specific version (Linux 3.10) using the boot.kernelPackages option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelPackages = pkgs.linuxKernel.packages.linux_3_10;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Pleroma Service in NixOS\nDESCRIPTION: NixOS configuration for the Pleroma service with public settings. This separates sensitive information to a secrets file while keeping non-sensitive configuration in the NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.pleroma = {\n    enable = true;\n    secretConfigFile = \"/var/lib/pleroma/secrets.exs\";\n    configs = [\n      ''\n      import Config\n\n      config :pleroma, Pleroma.Web.Endpoint,\n        url: [host: \"pleroma.example.net\", scheme: \"https\", port: 443],\n        http: [ip: {127, 0, 0, 1}, port: 4000]\n\n      config :pleroma, :instance,\n        name: \"Test\",\n        email: \"admin@example.net\",\n        notify_email: \"admin@example.net\",\n        limit: 5000,\n        registrations_open: true\n\n      config :pleroma, :media_proxy,\n        enabled: false,\n        redirect_on_failure: true\n\n      config :pleroma, Pleroma.Repo,\n        adapter: Ecto.Adapters.Postgres,\n        username: \"pleroma\",\n        database: \"pleroma\",\n        hostname: \"localhost\"\n\n      # Configure web push notifications\n      config :web_push_encryption, :vapid_details,\n        subject: \"mailto:admin@example.net\"\n\n      # ... TO CONTINUE ...\n      ''\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing NixOS Installation Process in a Temporary Filesystem\nDESCRIPTION: Commands to test NixOS installation without physical media by mounting a tmpfs filesystem, generating a configuration, and running the installer. This provides a quick way to verify the installer functionality without burning installation media.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-installer.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mount -t tmpfs none /mnt\n# nixos-generate-config --root /mnt\n$ nix-build '<nixpkgs>' -A nixos-install\n# ./result/bin/nixos-install\n```\n\n----------------------------------------\n\nTITLE: Configuring User Authentication for Mosquitto in NixOS\nDESCRIPTION: Configuration example for Mosquitto that sets up user authentication with different access levels. It gives full read access to a 'monitor' user and restricted write access to a 'service' user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/mosquitto.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mosquitto = {\n    enable = true;\n    listeners = [ {\n      users = {\n        monitor = {\n          acl = [ \"read #\" ];\n          password = \"monitor\";\n        };\n        service = {\n          acl = [ \"write service/#\" ];\n          password = \"service\";\n        };\n      };\n    } ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NixOS from Configuration\nDESCRIPTION: Command to start the actual NixOS installation process. This builds and installs the system based on the configuration created in the previous steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_19\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-install\n```\n\n----------------------------------------\n\nTITLE: Selecting Legacy NVIDIA Driver Package by Kernel Version - Nix\nDESCRIPTION: Demonstrates how to explicitly assign legacy driver packages for older NVIDIA graphics cards using hardware.nvidia.package. Selects from available legacy versions depending on hardware generation. Must only specify one package; package lines are mutually exclusive.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_470;\n  hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_390;\n  hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_340;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Samba Services using NixOS Modules (Nix)\nDESCRIPTION: This code snippet provides a minimal NixOS configuration to enable the Samba service. By setting 'services.samba.enable = true;', it automatically starts the smbd, nmbd, and winbindd daemons required for SMB/CIFS operation. No additional parameters are needed, and no authentication or share configuration is specified. This basic enablement serves as a foundation for further customization and requires NixOS with access to the Samba module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/network-filesystems/samba.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.samba.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Enrolling FIDO2 Token with systemd-cryptenroll - ShellSession\nDESCRIPTION: This shell command uses 'systemd-cryptenroll' to add a FIDO2 token as an unlock key for a LUKS device. Designed for LUKS2 volumes with systemd integration, this snippet requires a compatible token and the 'systemd-cryptenroll' tool. Input is the device path; output is a newly enrolled token usable at boot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemd-cryptenroll --fido2-device=auto /dev/sda2\n```\n\n----------------------------------------\n\nTITLE: Enabling JIT Compilation in PostgreSQL Service - NixOS - nix\nDESCRIPTION: This snippet enables Just-In-Time (JIT) compilation for the PostgreSQL service in a NixOS configuration. It requires NixOS with the 'services.postgresql' module enabled and a PostgreSQL version that supports JIT. Setting 'services.postgresql.enableJIT = true;' optimizes database query performance for eligible workloads. Potential limitations are compatibility with existing PostgreSQL deployments and hardware support for JIT.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.enableJIT = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Glances Service - Nix\nDESCRIPTION: This NixOS configuration snippet demonstrates how to enable the Glances monitoring service and open the necessary firewall ports. It requires a NixOS system with the 'glances' service module available. The 'services.glances.enable' flag starts the service, and 'openFirewall' ensures network access to the Glances web interface. Inputs are configuration options for the Glances service; the output is an activated and accessible Glances system monitor instance. Prerequisites include a NixOS system and proper privileges to edit system configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/glances.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.glances = {\n    enable = true;\n    openFirewall = true;\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions in Service preStart as Service User - NixOS systemd Service - Nix\nDESCRIPTION: Shows how a systemd service's preStart hook (running as the application service user) can grant PostgreSQL privileges, leveraging systemd's dependency handling. Assumes prior ownership and grant permission. Environment.PSQL defines the psql invocation. Requires correct permissions, configured path, and an existing DB user. This is especially effective where DBOwner and service user coincide, but may not work if the service user doesn't have sufficient rights.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n  {\n    environment.PSQL = \"psql --port=${toString services.postgresql.settings.port}\";\n    path = [ postgresql ];\n    systemd.services.\"service1\".preStart = ''\n      $PSQL -c 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"extraUser1\"'\n      $PSQL -c 'GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO \"extraUser1\"'\n      # ....\n    '';\n  }\n```\n\n----------------------------------------\n\nTITLE: Boilerplate for Packaging Home Assistant Component - buildHomeAssistantComponent - Nix\nDESCRIPTION: This boilerplate Nix code demonstrates how to use the buildHomeAssistantComponent helper to package a custom Home Assistant component. It includes function argument import, fetching the source from GitHub, specifying Python dependencies and meta attribute set. Dependencies such as lib, buildHomeAssistantComponent, and fetchFromGitHub must be available in scope. The builder expects arguments for src (source), dependencies (Python runtime dependencies), and meta (package metadata). Outputs will be Nix derivations for Home Assistant custom components.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/home-assistant/custom-components/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ lib\n, buildHomeAssistantComponent\n, fetchFromGitHub\n}:\n\nbuildHomeAssistantComponent {\n  # owner, domain, version\n\n  src = fetchFromGithub {\n    # owner, repo, rev, hash\n  };\n\n  dependencies = [\n    # python requirements, as specified in manifest.json\n  ];\n\n  meta = with lib; {\n    # changelog, description, homepage, license, maintainers\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rolling Back Configuration Using nixos-rebuild (Shell)\nDESCRIPTION: Uses the nixos-rebuild utility to switch the running system to the previous configuration by specifying the --rollback flag. This command should be executed as root in a shell. Depends on NixOS and the nixos-rebuild tool. It affects the currently running system, so ensure you have permission to make configuration changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rollback.section.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n# nixos-rebuild switch --rollback\n```\n\n----------------------------------------\n\nTITLE: Building Phoenix Project Releases with Nix - Nix Language\nDESCRIPTION: This snippet provides a complete example of a default.nix configuration to build and package an Elixir Phoenix project using mixRelease in Nix. It demonstrates how to fetch dependencies, configure build environments, wire up NodeJS frontend assets, and customize build-time environment variables. Key parameters include project source location, dependency hashes, and environment variables for both Elixir and NodeJS subsystems. Required dependencies include Nixpkgs with BEAM and Nodejs packages; customization of postBuild allows for deploying assets and handling Phoenix digest tasks. Inputs expect a Phoenix codebase, and outputs a releasable artifact suitable for deployment via nix-build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  # beam.interpreters.erlang_26 is available if you need a particular version\n  packages = beam.packagesWith beam.interpreters.erlang;\n\n  pname = \"your_project\";\n  version = \"0.0.1\";\n\n  src = builtins.fetchgit {\n    url = \"ssh://git@github.com/your_id/your_repo\";\n    rev = \"replace_with_your_commit\";\n  };\n\n  # if using mix2nix you can use the mixNixDeps attribute\n  mixFodDeps = packages.fetchMixDeps {\n    pname = \"mix-deps-${pname}\";\n    inherit src version;\n    # nix will complain and tell you the right value to replace this with\n    hash = lib.fakeHash;\n    mixEnv = \"\"; # default is \"prod\", when empty includes all dependencies, such as \"dev\", \"test\".\n    # if you have build time environment variables add them here\n    MY_ENV_VAR = \"my_value\";\n  };\n\n  nodeDependencies = (pkgs.callPackage ./assets/default.nix { }).shell.nodeDependencies;\n\nin\npackages.mixRelease {\n  inherit\n    src\n    pname\n    version\n    mixFodDeps\n    ;\n  # if you have build time environment variables add them here\n  MY_ENV_VAR = \"my_value\";\n\n  postBuild = ''\n    ln -sf ${nodeDependencies}/lib/node_modules assets/node_modules\n    npm run deploy --prefix ./assets\n\n    # for external task you need a workaround for the no deps check flag\n    # https://github.com/phoenixframework/phoenix/issues/2690\n    mix do deps.loadpaths --no-deps-check, phx.digest\n    mix phx.digest --no-deps-check\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Raw PSK in NixOS Wireless Configuration\nDESCRIPTION: Shows how to configure a wireless network in NixOS using a raw PSK hash instead of a plaintext password for improved security.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.wireless.networks = {\n    echelon = {\n      pskRaw = \"dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Crystal Package Derivation with Dependencies\nDESCRIPTION: A complete Nix derivation for building the Mint language. It includes the package metadata, source repository, dependency file, binary target specification, and additional build inputs (OpenSSL) required for compilation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/crystal.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\ncrystal.buildCrystalPackage rec {\n  version = \"0.5.0\";\n  pname = \"mint\";\n  src = fetchFromGitHub {\n    owner = \"mint-lang\";\n    repo = \"mint\";\n    rev = version;\n    hash = \"sha256-dFN9l5fgrM/TtOPqlQvUYgixE4KPr629aBmkwdDoq28=\";\n  };\n\n  shardsFile = ./shards.nix;\n  crystalBinaries.mint.src = \"src/mint.cr\";\n\n  buildInputs = [ openssl ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Plotinus via NixOS Module Configuration - Nix\nDESCRIPTION: This snippet demonstrates how to enable the Plotinus command palette for GTK 3 applications by setting the \"programs.plotinus.enable\" option to true in the NixOS \"configuration.nix\" file. The snippet should be added to the main configuration file to activate Plotinus system-wide, allowing users to summon the palette with Ctrl+Shift+P. Requires NixOS and GTK 3 applications; no extra dependencies beyond standard NixOS installation are needed. This configuration impacts all user sessions, enabling the feature universally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/plotinus.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.plotinus.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Running NixOS Test Command\nDESCRIPTION: Shell command to run a NixOS test from the command line\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd /my/git/clone/of/nixpkgs\nnix-build -A nixosTests.hostname\n```\n\n----------------------------------------\n\nTITLE: Configuring enterprise WiFi network using wpa_cli in NixOS installer\nDESCRIPTION: Commands to configure an enterprise WiFi network connection (e.g., eduroam) using wpa_cli in the NixOS minimal installer. This snippet shows how to connect using identity and password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n> add_network\n0\n> set_network 0 ssid \"eduroam\"\nOK\n> set_network 0 identity \"myname@example.com\"\nOK\n> set_network 0 password \"mypassword\"\nOK\n> enable_network 0\nOK\n```\n\n----------------------------------------\n\nTITLE: Enabling GRUB Bootloader in NixOS Configuration - Nix\nDESCRIPTION: This snippet demonstrates how to set the GRUB bootloader target device using the Nix expression language in configuration.nix. Specifying boot.loader.grub.device as \\\"/dev/sda\\\" ensures that GRUB is installed to the main virtual hard drive for NixOS to boot properly. This change is required for VirtualBox guest environments and assumes that the primary disk is /dev/sda. No additional dependencies are required, but this must be placed in the NixOS system configuration file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-virtualbox-guest.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.loader.grub.device = \"/dev/sda\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Passwordless FIDO2 Unlocking for LUKS in NixOS - nix\nDESCRIPTION: This snippet enables passwordless FIDO2 unlocking for a LUKS device in NixOS by setting the 'passwordLess' flag. Intended for added security when hardware tokens are PIN protected, this setting adds convenience for boot-time decryption. Dependency is a FIDO2-compatible device. Input is a device path; output is a passwordless unlock workflow.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.initrd.luks.devices.\"/dev/sda2\".fido2.passwordLess = true;\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring OCS Inventory Agent in NixOS\nDESCRIPTION: A minimal configuration for enabling OCS Inventory Agent in NixOS. It sets up the agent to periodically send inventory data to a specified OCS Inventory server. The configuration includes the server URL and a tag for identification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/ocsinventory-agent.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.ocsinventory-agent = {\n    enable = true;\n    settings = {\n      server = \"https://ocsinventory.localhost:8080/ocsinventory\";\n      tag = \"01234567890123\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Nix Profile for a User with su - ShellSession - ShellSession\nDESCRIPTION: This shell command snippet demonstrates how to use 'su' to switch to a user's login shell and trigger profile initialization, such as creating the '~/.nix-defexpr' symlink for the user 'alice'. The '-c \"true\"' flag runs a no-op command but ensures the login shell session is started, so environment and profile scripts execute. Run as root or a user with sufficient privileges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# su - alice -c \"true\"\n```\n\n----------------------------------------\n\nTITLE: Generating GitLab Secrets in NixOS\nDESCRIPTION: This command demonstrates how to generate a new secret for GitLab's database configuration using random data from /dev/urandom.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/gitlab.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\n$ tr -dc A-Za-z0-9 < /dev/urandom | head -c 128 > /var/keys/gitlab/db\n```\n\n----------------------------------------\n\nTITLE: Rebasing Pull Requests onto nixos-unstable - Git Commands - ShellSession\nDESCRIPTION: Outlines the sequence of terminal commands to fetch and rebase a pull request branch onto nixos-unstable for local review in the nixpkgs development process. Users replace PRNUMBER and BASEBRANCH to match the relevant pull request. Prerequisites include a local git clone of nixpkgs and access to the upstream origin. Inputs are the pull request identifiers; outputs are a rebased working directory for review. Ensure the pull request applies cleanly to the updated base.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_22\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git fetch origin nixos-unstable\n$ git fetch origin pull/PRNUMBER/head\n$ git rebase --onto nixos-unstable BASEBRANCH FETCH_HEAD\n```\n\n----------------------------------------\n\nTITLE: Generating a Nix Derivation from a Haskell Package using cabal2nix - Nix\nDESCRIPTION: This snippet demonstrates a typical Nix expression generated by cabal2nix for the Haskell package 'mtl'. It defines package dependencies, metadata, and uses mkDerivation as the standard entry point for Haskell package building. The example expects to be included in a Nix expression and called with haskellPackages.callPackage, providing mkDerivation and dependencies like base and transformers. The input 'src' should point to the unpacked Haskell source (e.g., by running 'cabal get'). This technique requires cabal2nix and appropriate haskellPackages in your Nix environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_35\n\nLANGUAGE: nix\nCODE:\n```\n# cabal get mtl-2.2.1 && cd mtl-2.2.1 && cabal2nix .\n{\n  mkDerivation,\n  base,\n  lib,\n  transformers,\n}:\nmkDerivation {\n  pname = \"mtl\";\n  version = \"2.2.1\";\n  src = ./.;\n  libraryHaskellDepends = [\n    base\n    transformers\n  ];\n  homepage = \"http://github.com/ekmett/mtl\";\n  description = \"Monad classes, using functional dependencies\";\n  license = lib.licenses.bsd3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining systemd Services for Elixir Phoenix Releases with Nix - Nix Language\nDESCRIPTION: This snippet illustrates creating a service.nix file for running an Elixir Phoenix release as a systemd service using Nix. It defines systemd unit attributes, environmental variables for runtime configuration, process behaviors, and disk/package access requirements. Essential dependencies involve systemd integration (via NixOS modules), the release derivation, and bash for specific BEAM/Elixir commands. Inputs are the previously built release and an intended working directory, and the snippet outputs a functional service plus optional convenience shell/migration environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config,\n  pkgs,\n  lib,\n  ...\n}:\n\nlet\n  release = pkgs.callPackage ./default.nix;\n  release_name = \"app\";\n  working_directory = \"/home/app\";\nin\n{\n  systemd.services.${release_name} = {\n    wantedBy = [ \"multi-user.target\" ];\n    after = [\n      \"network.target\"\n      \"postgresql.service\"\n    ];\n    # note that if you are connecting to a postgres instance on a different host\n    # postgresql.service should not be included in the requires.\n    requires = [\n      \"network-online.target\"\n      \"postgresql.service\"\n    ];\n    description = \"my app\";\n    environment = {\n      # RELEASE_TMP is used to write the state of the\n      # VM configuration when the system is running\n      # it needs to be a writable directory\n      RELEASE_TMP = working_directory;\n      # can be generated in an elixir console with\n      # Base.encode32(:crypto.strong_rand_bytes(32))\n      RELEASE_COOKIE = \"my_cookie\";\n      MY_VAR = \"my_var\";\n    };\n    serviceConfig = {\n      Type = \"exec\";\n      DynamicUser = true;\n      WorkingDirectory = working_directory;\n      # Implied by DynamicUser, but just to emphasize due to RELEASE_TMP\n      PrivateTmp = true;\n      ExecStart = ''\n        ${release}/bin/${release_name} start\n      '';\n      ExecStop = ''\n        ${release}/bin/${release_name} stop\n      '';\n      ExecReload = ''\n        ${release}/bin/${release_name} restart\n      '';\n      Restart = \"on-failure\";\n      RestartSec = 5;\n      StartLimitBurst = 3;\n      StartLimitInterval = 10;\n    };\n    # disksup requires bash\n    path = [ pkgs.bash ];\n  };\n\n  # in case you have migration scripts or you want to use a remote shell\n  environment.systemPackages = [ release ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Fcitx5 Input Method in NixOS\nDESCRIPTION: Configuration for setting up Fcitx5 input method framework with Japanese (Mozc), Korean (Hangul), and m17n add-ons. Shows how to enable the system and add extra input method add-ons.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"fcitx5\";\n    fcitx5.addons = with pkgs; [ fcitx5-mozc fcitx5-hangul fcitx5-m17n ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Placement of Let in Virtual Hosts Attribute Set in Nix\nDESCRIPTION: This Nix snippet places the let-binding directly inside the virtualHosts attribute set definition, showing flexibility in Nix scoping. The example declares commonConfig within the scope of the value assigned to services.httpd.virtualHosts, and merges host-specific configs similarly. Dependencies and principles are the same as earlier, but the let can be declared at any Nix expression position, except as an attribute name. Inputs are server names and config snippets, outputs are merged attribute sets per virtual host. Limitation: Let must be in attribute values, not attribute keys.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/abstractions.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.virtualHosts =\n    let commonConfig = { /* ... */ }; in\n    { \"blog.example.org\" = (commonConfig // { /* ... */ });\n      \"wiki.example.org\" = (commonConfig // { /* ... */ });\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Castopod Service in NixOS\nDESCRIPTION: Basic NixOS configuration to set up a public Castopod instance with ACME SSL certificates. This configuration enables the Castopod service, creates a local database, and configures Nginx with a virtual host using HTTPS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/castopod.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  services.castopod = {\n    enable = true;\n    database.createLocally = true;\n    nginx.virtualHost = {\n      serverName = \"castopod.example.com\";\n      enableACME = true;\n      forceSSL = true;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a User Imperatively with useradd - ShellSession - ShellSession\nDESCRIPTION: This shell snippet shows the imperative creation of a user named 'alice' using the Unix 'useradd' command with the '-m' flag, which also creates a home directory. It requires appropriate system permissions (typically root). This method bypasses NixOS declarative management and is well-suited for non-immutable systems. Note: No password is set initially; subsequent commands are needed to assign one.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# useradd -m alice\n```\n\n----------------------------------------\n\nTITLE: Adding redisTestHook to custom checkPhase\nDESCRIPTION: Demonstrates how to properly use redisTestHook with a custom checkPhase by including the necessary runHook calls to ensure the Redis server is started and stopped.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/redis-test-hook.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  checkPhase = ''\n    runHook preCheck\n\n    # ... your tests\n\n    runHook postCheck\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Ad-hoc Python Environment with nix-shell - Nix Shell - Shell\nDESCRIPTION: Demonstrates using nix-shell to create a temporary shell with a specific Python version and packages (numpy, toolz) available. Requires Nix to be installed and access to the desired python version in nixpkgs. Invoking this command results in a bash session with Python and specified libraries available in the environment PATH; additional dependencies can be added similarly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\n$ nix-shell -p 'python312.withPackages(ps: with ps; [ numpy toolz ])'\n```\n\n----------------------------------------\n\nTITLE: Overriding Python Package Attributes Using buildPythonPackage in Nix\nDESCRIPTION: Demonstrates how to override a Python package's attributes (specifically pandas' version and source hash) using buildPythonPackage in the Nix expression language. This pattern involves providing a custom packageOverrides function to a Python interpreter derivation and creating an environment with the overridden package. Requires the nixpkgs repository, specifically access to pkgs.python3, and an understanding of packageSets and overridePythonAttrs methods. Inputs include a desired Python environment with blaze and a custom pandas; output is a shell environment (.env) with the specified dependencies. Users must ensure the correct attribute path and hashes for their use case.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(\n  let\n    python =\n      let\n        packageOverrides = self: super: {\n          pandas = super.pandas.overridePythonAttrs (old: rec {\n            version = \"0.19.1\";\n            src = fetchPypi {\n              pname = \"pandas\";\n              inherit version;\n              hash = \"sha256-JQn+rtpy/OA2deLszSKEuxyttqBzcAil50H+JDHUdCE=\";\n            };\n          });\n        };\n      in\n      pkgs.python3.override {\n        inherit packageOverrides;\n        self = python;\n      };\n\n  in\n  python.withPackages (ps: [ ps.blaze ])\n).env\n```\n\n----------------------------------------\n\nTITLE: Enabling and Configuring PostgreSQL Service - NixOS Module - Nix\nDESCRIPTION: This snippet demonstrates enabling the PostgreSQL service in NixOS via configuration.nix, specifying the PostgreSQL package version to ensure controlled upgrades and compatibility. Requires NixOS, a suitable pkgs attribute for the desired postgresql version, and familiarity with Nix language structure. Inputs include the service enablement flag and package selection; output is a configured PostgreSQL instance managed by systemd. It's essential as upgrades require manual intervention, and the version must be chosen explicitly by the user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.enable = true;\n  services.postgresql.package = pkgs.postgresql_15;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Gateway and DNS Nameservers in NixOS\nDESCRIPTION: This snippet shows how to configure the default gateway and DNS nameservers in NixOS. It sets the default gateway to 192.168.1.1 and configures Google's public DNS server (8.8.8.8) as the nameserver.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv4-config.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.defaultGateway = \"192.168.1.1\";\n  networking.nameservers = [ \"8.8.8.8\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Keycloak Service in NixOS\nDESCRIPTION: This snippet demonstrates a basic configuration for the Keycloak service in NixOS. It includes settings for hostname, SSL certificates, initial admin password, and database password file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/keycloak.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.keycloak = {\n    enable = true;\n    settings = {\n      hostname = \"keycloak.example.com\";\n      hostname-strict-backchannel = true;\n    };\n    initialAdminPassword = \"e6Wcm0RrtegMEHl\";  # change on first login\n    sslCertificate = \"/run/keys/ssl_cert\";\n    sslCertificateKey = \"/run/keys/ssl_key\";\n    database.passwordFile = \"/run/keys/db_password\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Searching, Installing, and Running Flatpak Applications - ShellSession\nDESCRIPTION: This sequence of Flatpak CLI commands enables users to search for an app, install it from the Flathub repository, and run it. It requires the 'flatpak' binary and access to the specified repository. The parameters include the application ID and repository name; outputs are application listings, installation logs, or runtime messages. Ideal for users managing Flatpak apps from the terminal.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/desktops/flatpak.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ flatpak search bustle\n$ flatpak install flathub org.freedesktop.Bustle\n$ flatpak run org.freedesktop.Bustle\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Backup to BorgBase in NixOS\nDESCRIPTION: NixOS configuration for setting up a daily backup to the BorgBase hosting service. It includes path configuration, encryption with a secure passphrase file, SSH settings, and compression options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.borgbackup.jobs = {\n    my_Remote_Backup = {\n        paths = [ \"/\" ];\n        exclude = [ \"/nix\" \"'**/.cache'\" ];\n        repo =  \"zzz2aaaaa@zzz2aaaaa.repo.borgbase.com:repo\";\n          encryption = {\n          mode = \"repokey-blake2\";\n          passCommand = \"cat /run/keys/borgbackup_passphrase\";\n        };\n        environment = { BORG_RSH = \"ssh -i /run/keys/id_ed25519_borgbase\"; };\n        compression = \"auto,lzma\";\n        startAt = \"daily\";\n    };\n  };\n}}\n```\n\n----------------------------------------\n\nTITLE: Declaring a List of Submodules Option (Nix)\nDESCRIPTION: Defines an option 'mod' that accepts a list of submodules, each with integer 'foo' and string 'bar' fields. Uses 'listOf' and 'submodule' combinators with types and mkOption. The option expects a list of attribute sets matching the submodule schema. Useful when multiple instances are configurable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options.mod = mkOption {\n    description = \"submodule example\";\n    type = with types; listOf (submodule {\n      options = {\n        foo = mkOption {\n          type = int;\n        };\n        bar = mkOption {\n          type = str;\n        };\n      };\n    });\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Entire Haskell Package Set Profiling Settings with Overlays - Nix\nDESCRIPTION: This Nix overlay snippet targets the Haskell package set, globally enabling or disabling library and executable profiling by overriding mkDerivation within the specified GHC package set. Additionally, it demonstrates how to selectively enable executable profiling or disable library profiling for individual packages to save on build times. The overlay is designed to be used in tandem with the compiler overlay for holistic profiling configuration, and requires a compatible Nixpkgs and knowledge of the haskell.lib.compose helpers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_37\n\nLANGUAGE: nix\nCODE:\n```\n(\\n  final: prev:\\n  let\\n    inherit (final) lib;\\n    haskellLib = final.haskell.lib.compose;\\n  in\\n\\n  {\\n    haskell = prev.haskell // {\\n      packages = prev.haskell.packages // {\\n        ${ghcName} = prev.haskell.packages.${ghcName}.override {\\n          overrides = hfinal: hprev: {\\n            mkDerivation =\\n              args:\\n              hprev.mkDerivation (\\n                args\\n                // {\\n                  # Since we are forcing our ideas upon mkDerivation, this change will\\n                  # affect every package in the package set.\\n                  enableLibraryProfiling = enableProfiling;\\n\\n                  # To actually use profiling on an executable, executable profiling\\n                  # needs to be enabled for the executable you want to profile. You\\n                  # can either do this globally or…\\n                  enableExecutableProfiling = enableProfiling;\\n                }\\n              );\\n\\n            # …only for the package that contains an executable you want to profile.\\n            # That saves on unnecessary rebuilds for packages that you only depend\\n            # on for their library, but also contain executables (e.g. pandoc).\\n            my-executable = haskellLib.enableExecutableProfiling hprev.my-executable;\\n\\n            # If you are disabling profiling to save on build time, but want to\\n            # retain the ability to substitute from the binary cache. Drop the\\n            # override for mkDerivation above and instead have an override like\\n            # this for the specific packages you are building locally and want\\n            # to make cheaper to build.\\n            my-library = haskellLib.disableLibraryProfiling hprev.my-library;\\n          };\\n        };\\n      };\\n    };\\n  }\\n)\n```\n\n----------------------------------------\n\nTITLE: Using pythonRelaxDepsHook for Dependency Version Management\nDESCRIPTION: Demonstrates how to use pythonRelaxDepsHook to modify dependency version constraints when packaging Python modules. This can help resolve compatibility issues when upstream specifies incompatible version ranges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_38\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pythonRelaxDeps = [\n    \"pkg1\"\n    \"pkg3\"\n  ];\n  pythonRemoveDeps = [\n    \"pkg2\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Switching to a Specific Configuration Generation (NixOS - Shell)\nDESCRIPTION: Directly invokes the switch-to-configuration script inside a specific NixOS system generation's profile to activate it immediately. The placeholder 'N' should be replaced with the system configuration number to target (as listed in the available generations). Shell access with root privileges and knowledge of the correct generation number are required. Useful for precise rollbacks or advanced troubleshooting; take care to select the correct profile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rollback.section.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n# /nix/var/nix/profiles/system-N-link/bin/switch-to-configuration switch\n```\n\n----------------------------------------\n\nTITLE: Including a Custom Python Package in an Environment with callPackage - Nix\nDESCRIPTION: This Nix snippet shows how to include a custom Python package derivation (such as the one for 'toolz') into a Python environment using callPackage. It imports Nixpkgs, calls the custom package function with required overrides, and constructs an environment where both numpy and the custom package are available. The key parameter is the path to the package definition and the explicit dictionary for buildPythonPackage, ensuring the correct Python version is used. Outputs a Python environment derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_45\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(\n  let\n    toolz = callPackage /path/to/toolz/release.nix {\n      buildPythonPackage = python3Packages.buildPythonPackage;\n    };\n  in\n  python3.withPackages (ps: [\n    ps.numpy\n    toolz\n  ])\n).env\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Elm Development Environment with Nix-Shell - ShellSession\nDESCRIPTION: This snippet demonstrates how to launch a Nix shell with the Elm compiler and elm-format available. To use it, run the command in the terminal with Nix installed. The -p flag specifies the required Nix packages (elmPackages.elm and elmPackages.elm-format). This sets up an isolated development environment with both tools available. No other configuration or input is needed. Requires Nix to be set up on the host system; limitations depend on your nixpkgs channel and available derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/elm.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-shell -p elmPackages.elm elmPackages.elm-format\n```\n\n----------------------------------------\n\nTITLE: Formatting FAT32 EFI Partition with mkfs.fat and Label (ShellSession)\nDESCRIPTION: Creates a FAT32 filesystem on the specified partition (/dev/sda3) and assigns it the label 'boot'. The '-F 32' option sets the FAT type, and '-n' sets the volume label. Used primarily for UEFI system partitions; requires 'mkfs.fat'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_13\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkfs.fat -F 32 -n boot /dev/sda3\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package with Maturin and Rust Dependencies in Nix (Nix)\nDESCRIPTION: This code defines a Python package build using Maturin as the build backend. It uses `buildPythonPackage`, with sources fetched from GitHub, and applies `fetchCargoVendor` and `cargoSetupHook` for Rust dependencies. The build is performed via `maturinBuildHook`. This setup is suitable for Python packages with Rust extensions built via Maturin and requires correct hashes for both source and Cargo dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  rustPlatform,\n  fetchFromGitHub,\n}:\n\nbuildPythonPackage rec {\n  pname = \"retworkx\";\n  version = \"0.6.0\";\n  pyproject = true;\n\n  src = fetchFromGitHub {\n    owner = \"Qiskit\";\n    repo = \"retworkx\";\n    tag = version;\n    hash = \"sha256-11n30ldg3y3y6qxg3hbj837pnbwjkqw3nxq6frds647mmmprrd20=\";\n  };\n\n  cargoDeps = rustPlatform.fetchCargoVendor {\n    inherit pname version src;\n    hash = \"sha256-QsPCQhNZKYCAogQriQX6pBYQUDAIUsEdRX/63dAqTzg=\";\n  };\n\n  nativeBuildInputs = with rustPlatform; [\n    cargoSetupHook\n    maturinBuildHook\n  ];\n\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Sway Wayland Compositor in NixOS\nDESCRIPTION: This snippet shows how to enable the Sway Wayland compositor in NixOS configuration. Enabling Sway installs the compositor along with essential utilities, allowing it to be started directly from the TTY console.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wayland.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.sway.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Development Shell with importNpmLock.buildNodeModules and linkNodeModulesHook - Nix\nDESCRIPTION: This example demonstrates creating a development shell environment using pkgs.mkShell that automatically builds and symlinks node_modules using importNpmLock.buildNodeModules and linkNodeModulesHook. The snippet specifies necessary packages, npmDeps configuration, and creates a shell where dependencies are made available from the Nix store. It requires pkgs.mkShell, nodejs, and importNpmLock. Key inputs are the package root and nodejs version; output is a shell with linked dependencies for immediate development.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\npkgs.mkShell {\n  packages = [\n    importNpmLock.hooks.linkNodeModulesHook\n    nodejs\n  ];\n\n  npmDeps = importNpmLock.buildNodeModules {\n    npmRoot = ./.;\n    inherit nodejs;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Flathub Repository and Updating Flatpak - ShellSession\nDESCRIPTION: This ShellSession demonstrates how to add the Flathub Flatpak repository if it does not already exist and update Flatpak sources. It relies on the 'flatpak' command-line tool and requires the user to have permissions to run Flatpak. The main parameters are the repository name, URL, and the optional update command. Outputs include success messages or errors; may require network connectivity.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/desktops/flatpak.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\n$ flatpak update\n```\n\n----------------------------------------\n\nTITLE: Installing a Package via nix-env - ShellSession\nDESCRIPTION: Installs the Mozilla Thunderbird package using the nix-env tool with the -iA flags. The -iA flag specifies the package by its attribute name, resulting in a faster and more precise installation than matching by name. This command can be executed as root (for a system-wide install) or as a regular user (installing only for the current user's profile). Expected input is the package attribute name, with the output being the package added to the user's or system profile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-packages.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -iA nixos.thunderbird\n```\n\n----------------------------------------\n\nTITLE: Specifying System Packages in NixOS Configuration - Nix Expression - Nix\nDESCRIPTION: This Nix snippet demonstrates how to declare the list of system packages for a NixOS installation by assigning the desired packages to the environment.systemPackages option within configuration.nix. Dependencies include the NixOS configuration system and an available pkgs set (typically imported from Nixpkgs). The key parameter environment.systemPackages expects a list of package attributes such as pkgs.thunderbird to ensure the specified applications are included at build or update. The output is integration of the listed packages into the system profile on rebuild. Limitations include the potential need for additional configuration for some packages requiring global services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/declarative-packages.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [ pkgs.thunderbird ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building a fetchurl Multiple URLs Package with nix-build - Shell\nDESCRIPTION: This shell block shows the output of building a Nix package using 'fetchurl' with multiple URLs. It demonstrates fetchurl's fallback logic by attempting to fetch from each listed URL until a working one is found, and displays the resulting file's content from the Nix store. No prerequisites beyond the Nix toolchain are needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\ntrying https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/does-not-exist\n(some output removed for clarity)\ncurl: (22) The requested URL returned error: 404\n\ntrying https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\n(some output removed for clarity)\n/nix/store/n9asny31z32q7sdw6a8r1gllrsfy53kl-does-not-exist\n\n$ cat /nix/store/n9asny31z32q7sdw6a8r1gllrsfy53kl-does-not-exist\n23.11\n```\n\n----------------------------------------\n\nTITLE: Example Image Processing URL Request\nDESCRIPTION: Example GET request for the /image/process endpoint that applies multiple transformations to an image, creating a 256x256px JPEG thumbnail with a Gaussian blur.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pict-rs.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nGET /image/process.jpg?src=asdf.png&thumbnail=256&blur=3.0\n```\n\n----------------------------------------\n\nTITLE: Installing Prebuilt Mattermost Plugins - NixOS Module - Nix\nDESCRIPTION: This configuration demonstrates how to add prebuilt Mattermost plugin tarballs via the 'plugins' attribute in the NixOS Mattermost service definition. It uses the 'fetchurl' function from the Nixpkgs package set, specifying the plugin URL and hash. Prerequisites include access to the plugin tarball, Nixpkgs, and the 'pkgs' alias in scope. Inputs are plugin URLs and hashes, and the output is an updated Mattermost instance with the plugins pre-installed once the configuration is rebuilt. Plugin activation must be done in the Mattermost System Console.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/mattermost.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mattermost = {\n    plugins = with pkgs; [\n      /*\n       * todo\n       * 0.7.1\n       * https://github.com/mattermost/mattermost-plugin-todo/releases/tag/v0.7.1\n       */\n      (fetchurl {\n        # Note: Don't unpack the tarball; the NixOS module will repack it for you.\n        url = \"https://github.com/mattermost-community/mattermost-plugin-todo/releases/download/v0.7.1/com.mattermost.plugin-todo-0.7.1.tar.gz\";\n        hash = \"sha256-P+Z66vqE7FRmc2kTZw9FyU5YdLLbVlcJf11QCbfeJ84=\";\n      })\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Editable Python Package with mkPythonEditablePackage (Nix)\nDESCRIPTION: This example demonstrates creating an editable Python package using mkPythonEditablePackage within a custom Python interpreter override in Nix. The snippet includes loading metadata from pyproject.toml, setting an impure/mutable source root using environment variable expansion, and injecting custom scripts from the project's metadata. It requires pkgs, the relevant pyproject TOML file, and a shell hook that sets up needed environment variables. The result is an environment with an editable Python package for iterative development; mutation is possible without rebuilding due to pointer indirection. Intended for development workflows where source code outside the Nix store is needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\nlet\n  pyproject = pkgs.lib.importTOML ./pyproject.toml;\n\n  myPython = pkgs.python.override {\n    self = myPython;\n    packageOverrides = pyfinal: pyprev: {\n      # An editable package with a script that loads our mutable location\n      my-editable = pyfinal.mkPythonEditablePackage {\n        # Inherit project metadata from pyproject.toml\n        pname = pyproject.project.name;\n        inherit (pyproject.project) version;\n\n        # The editable root passed as a string\n        root = \"$REPO_ROOT/src\"; # Use environment variable expansion at runtime\n\n        # Inject a script (other PEP-621 entrypoints are also accepted)\n        inherit (pyproject.project) scripts;\n      };\n    };\n  };\n\n  pythonEnv = myPython.withPackages (ps: [ ps.my-editable ]);\n\nin\npkgs.mkShell {\n  packages = [ pythonEnv ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package Derivation with buildPythonPackage - Nix\nDESCRIPTION: This snippet defines a Nix function that builds the Python package 'toolz' using the buildPythonPackage helper and fetches the source from PyPI. It declares metadata, build dependencies (setuptools), and uses a fixed hash for source verification. To use this function, call it with required dependencies such as buildPythonPackage, fetchPypi, setuptools, and lib (usually provided by Nixpkgs). Outputs a derivation for the 'toolz' package for inclusion in an environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_44\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n  setuptools,\n}:\n\nbuildPythonPackage rec {\n  pname = \"toolz\";\n  version = \"0.10.0\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-CP3V73yWSArRHBLUct4hrNMjWZlvaaUlkpm1QP66RWA=\";\n  };\n\n  build-system = [\n    setuptools\n  ];\n\n  meta = {\n    changelog = \"https://github.com/pytoolz/toolz/releases/tag/${version}\";\n    homepage = \"https://github.com/pytoolz/toolz/\";\n    description = \"List processing tools and functional utilities\";\n    license = lib.licenses.bsd3;\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Default CMake Configure Phase in Nix\nDESCRIPTION: When set to true, this variable prevents the use of the predefined cmakeConfigurePhase in the Nix build process. This allows for custom configuration of the CMake build process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/cmake.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\ndontUseCmakeConfigure = true;\n```\n\n----------------------------------------\n\nTITLE: Building a Maven Project JAR with a Custom Repository - Nix Language\nDESCRIPTION: Presents a Nix expression for building a Maven project JAR. It sets up a repository using callPackage, fetches the project source as a tarball, and runs mvn package with a specified repository path. The built JAR is installed to $out/share/java as per Nixpkgs guidelines, which aids Java CLASSPATH handling in dependent builds. Requires inputs for stdenv, maven, callPackage, a valid Maven repository, and the project source tarball.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  maven,\n  callPackage,\n}:\nlet\n  # pick a repository derivation, here we will use buildMaven\n  repository = callPackage ./build-maven-repository.nix { };\nin\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"maven-demo\";\n  version = \"1.0\";\n\n  src = builtins.fetchTarball \"https://github.com/fzakaria/nixos-maven-example/archive/main.tar.gz\";\n  buildInputs = [ maven ];\n\n  buildPhase = ''\n    runHook preBuild\n\n    echo \"Using repository ${repository}\"\n    mvn --offline -Dmaven.repo.local=${repository} package;\n\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    install -Dm644 target/${finalAttrs.pname}-${finalAttrs.version}.jar $out/share/java\n\n    runHook postInstall\n  '';\n})\n\n```\n\n----------------------------------------\n\nTITLE: Building and Starting NixOS Test Driver in Interactive Mode\nDESCRIPTION: Commands to build a NixOS test driver in interactive mode and start it. This builds the login test's interactive driver component and launches it for manual testing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build . -A nixosTests.login.driverInteractive\n$ ./result/bin/nixos-test-driver\n[...]\n>>>\n```\n\n----------------------------------------\n\nTITLE: Defining and Enabling a PostgreSQL Container using NixOS Modules in Nix\nDESCRIPTION: This Nix snippet demonstrates how to declare a container named 'database' within configuration.nix. It uses the NixOS module system to enable the PostgreSQL service inside the container and specifies the PostgreSQL package version via pkgs.postgresql_14. The configuration structure leverages attribute sets, allowing further container customization or service additions. Inputs are the Nix context (config, pkgs, etc.), and the output is an attribute set configuring the desired service. NixOS and relevant package definitions are prerequisites.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/declarative-containers.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  containers.database =\n    { config =\n        { config, pkgs, ... }:\n        { services.postgresql.enable = true;\n        services.postgresql.package = pkgs.postgresql_14;\n        };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Cabal Configuration for Haskell Packages\nDESCRIPTION: Functions to append configure flags and enable or disable Cabal flags for Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\nappendConfigureFlags list drv\nenableCabalFlag flag drv\ndisableCabalFlag flag drv\n```\n\n----------------------------------------\n\nTITLE: Enabling Apache HTTP Server with Option Definitions - NixOS - nix\nDESCRIPTION: Configures NixOS to enable the Apache HTTP Server by setting the relevant service options in a NixOS configuration file. It specifies admin address and virtual host document root. Requires: 'config' and 'pkgs' available as function arguments, NixOS module system. Expects service options as Boolean and String parameters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ services.httpd.enable = true;\n  services.httpd.adminAddr = \"alice@example.org\";\n  services.httpd.virtualHosts.localhost.documentRoot = \"/webroot\";\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning a Private Virtual Network to a Container with NixOS in Nix\nDESCRIPTION: This snippet configures a declarative NixOS container to use a private network by setting privateNetwork to true and specifying hostAddress and localAddress. The result is that the container and the host are assigned separate IP addresses within a private Ethernet segment. The code assumes NixOS with support for declarative containers. Key parameters include the container name, privateNetwork flag, and address settings; the output is a Nix attribute set configuring network isolation for the specified container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/declarative-containers.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  containers.database = {\n    privateNetwork = true;\n    hostAddress = \"192.168.100.10\";\n    localAddress = \"192.168.100.11\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Intel OpenCL Gen12+ Packages to NixOS Hardware Configuration (nix)\nDESCRIPTION: Shows how to enable Intel OpenCL support by adding intel-compute-runtime to hardware.graphics.extraPackages. Requires a supported Intel GPU and NixOS system. The key parameter is the extraPackages list, populated with intel-compute-runtime. This makes the package visible to the OpenCL loader for Gen12 or later Intel GPUs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.extraPackages = [\n    intel-compute-runtime\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Kernel and Initrd Images with QEMU - ShellSession\nDESCRIPTION: This block details commands for building the kernel and initial ramdisk images in isolation, then testing them in a virtual QEMU environment. The first two lines build and output the initrd and kernel images as symlinks named initrd and kernel, respectively. The third command invokes QEMU to boot with these artifacts, accepting as input the built image paths and assuming QEMU is installed. Useful for validating new kernels or initrd without a full NixOS rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/building-parts.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A config.system.build.initialRamdisk -o initrd\\n$ nix-build -A config.system.build.kernel -o kernel\\n$ qemu-system-x86_64 -kernel ./kernel/bzImage -initrd ./initrd/initrd -hda /dev/null\n```\n\n----------------------------------------\n\nTITLE: Adding Package to System Packages (Nix, nix)\nDESCRIPTION: This snippet illustrates how to add a custom package (\\\"my-package\\\") to the system-wide environment.systemPackages attribute within a NixOS configuration. It assumes \\\"pkgs.my-package\\\" is defined or imported elsewhere. Input is a Nix attribute set; output is a new configuration with the package included. Requires knowledge of Nix syntax and NixOS configuration structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  environment.systemPackages = [ pkgs.my-package ];\\n}\n```\n\n----------------------------------------\n\nTITLE: Python Package Override Using Overlays\nDESCRIPTION: Shows how to override Python packages using the Nixpkgs overlay system, allowing for system-wide package modifications.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_54\n\nLANGUAGE: nix\nCODE:\n```\nself: super: {\n  python = super.python.override {\n    packageOverrides = python-self: python-super: {\n      twisted = python-super.twisted.overrideAttrs (oldAttrs: {\n        src = super.fetchPypi {\n          pname = \"Twisted\";\n          version = \"19.10.0\";\n          hash = \"sha256-c5S6fycq5yKnTz2Wnc9Zm8TvCTvDkgOHSKSQ8XJKUV0=\";\n          extension = \"tar.bz2\";\n        };\n      });\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Derivation with stdenv.mkDerivation - Nix\nDESCRIPTION: This snippet demonstrates how to define a basic package derivation using stdenv.mkDerivation in the Nix expression language. The required attributes are name and src, where src typically uses fetchurl to securely retrieve the package source with a specified hash for reproducibility. stdenv and fetchurl must be available in scope, and the derivation will fetch, build, and install the specified source package using default phases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  src = fetchurl {\n    url = \"http://example.org/libfoo-1.2.3.tar.bz2\";\n    hash = \"sha256-tWxU/LANbQE32my+9AXyt3nCT7NBVfJ45CX757EMT3Q=\";\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting up pnpm package with dependency fetching in Nix\nDESCRIPTION: Example showing how to create a Nix derivation for a package using pnpm, including fetching dependencies from a pnpm-lock.yaml file and configuring the build environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  nodejs,\n  # This is pinned as { pnpm = pnpm_9; }\n  pnpm,\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"foo\";\n  version = \"0-unstable-1980-01-01\";\n\n  src = {\n    #...\n  };\n\n  nativeBuildInputs = [\n    nodejs\n    pnpm.configHook\n  ];\n\n  pnpmDeps = pnpm.fetchDeps {\n    inherit (finalAttrs) pname version src;\n    hash = \"...\";\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package with Setuptools-Rust and Cargo Dependencies in Nix (Nix)\nDESCRIPTION: This Nix expression demonstrates how to use `buildPythonPackage` together with `fetchCargoVendor` and `cargoSetupHook` to build a Python package (tokenizers) that includes Rust extensions via setuptools-rust. It sets the correct `sourceRoot` for cases where the Python bindings are under a subdirectory and prepares rust dependencies. Dependencies include `cargo`, `rustc`, `setuptools-rust`, and `rustPlatform.cargoSetupHook`. Main parameters are the package name, version, source fetcher (from GitHub), and the explicit hash for Cargo dependencies. Outputs a Nix derivation to build and install the Python package with all binary extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fetchFromGitHub,\n  buildPythonPackage,\n  cargo,\n  rustPlatform,\n  rustc,\n  setuptools-rust,\n}:\n\nbuildPythonPackage rec {\n  pname = \"tokenizers\";\n  version = \"0.10.0\";\n\n  src = fetchFromGitHub {\n    owner = \"huggingface\";\n    repo = \"tokenizers\";\n    tag = \"python-v${version}\";\n    hash = \"sha256-rQ2hRV52naEf6PvRsWVCTN7B1oXAQGmnpJw4iIdhamw=\";\n  };\n\n  cargoDeps = rustPlatform.fetchCargoVendor {\n    inherit\n      pname\n      version\n      src\n      sourceRoot\n      ;\n    hash = \"sha256-RO1m8wEd5Ic2M9q+zFHeCJWhCr4Sv3CEWd08mkxsBec=\";\n  };\n\n  sourceRoot = \"${src.name}/bindings/python\";\n\n  nativeBuildInputs = [\n    cargo\n    rustPlatform.cargoSetupHook\n    rustc\n    setuptools-rust\n  ];\n\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx for Maubot Web Interface in NixOS\nDESCRIPTION: This code block shows how to set up an Nginx virtual host to expose the Maubot interface to the web. It includes proxy settings and configuration for the Maubot server's public URL and UI base path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/maubot.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nginx.virtualHosts.\"matrix.example.org\".locations = {\n    \"/_matrix/maubot/\" = {\n      proxyPass = \"http://127.0.0.1:${toString config.services.maubot.settings.server.port}\";\n      proxyWebsockets = true;\n    };\n  };\n  services.maubot.settings.server.public_url = \"matrix.example.org\";\n  # do the following only if you want to use something other than /_matrix/maubot...\n  services.maubot.settings.server.ui_base_path = \"/another/base/path\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Python Meta Package with mkPythonMetaPackage (Nix)\nDESCRIPTION: This snippet shows how to use the mkPythonMetaPackage function to create a meta package in Nix, providing metadata for a Python dependency without actually installing the package. It is helpful for packaging scenarios like split binary/source distributions (e.g., psycopg2 and psycopg2-binary). Dependencies such as the underlying package (psycopg2) are required, and key parameters are pname (name), version, dependencies (list of packages to satisfy), and meta (metadata inherited). The resulting package satisfies dependency checks but contains only metadata.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nmkPythonMetaPackage {\n  pname = \"psycopg2-binary\";\n  inherit (psycopg2) optional-dependencies version;\n  dependencies = [ psycopg2 ];\n  meta = {\n    inherit (psycopg2.meta) description homepage;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GNS3 Server with NixOS Module in Nix\nDESCRIPTION: This code snippet demonstrates a minimal NixOS module configuration to enable and secure the GNS3 Server. It activates the server component, sets up authentication with user credentials and a password file, enables SSL with specified certificate and key files, and ensures that essential components (dynamips, ubridge, and vpcs) are also enabled. Dependencies include appropriate GNS3 server packages available via Nixpkgs, and files referenced (like passwordFile and certFile) must exist and have proper permissions. Users should provide secure credential stores and certificates according to their deployment environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/gns3-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gns3-server = {\n    enable = true;\n\n    auth = {\n      enable = true;\n      user = \"gns3\";\n      passwordFile = \"/var/lib/secrets/gns3_password\";\n    };\n\n    ssl = {\n      enable = true;\n      certFile = \"/var/lib/gns3/ssl/cert.pem\";\n      keyFile = \"/var/lib/gns3/ssl/key.pem\";\n    };\n\n    dynamips.enable = true;\n    ubridge.enable = true;\n    vpcs.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redundancy and Coordinators via fdbcli - ShellSession - shell\nDESCRIPTION: This snippet shows how to use the interactive fdbcli to set up a FoundationDB cluster's redundancy mode and automatically configure coordinators. The commands 'configure double ssd' and 'coordinators auto' are entered at the fdbcli prompt, setting up double redundancy with SSD storage and allowing the cluster to automatically select optimal coordinator processes. This is typically run after adding multiple nodes to a cluster. Inputs are CLI commands, and outputs are not shown but involve cluster configuration changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nfdbcli> configure double ssd\nfdbcli> coordinators auto\n\n```\n\n----------------------------------------\n\nTITLE: Generating Shell Environment from Derivation Attributes (Nix) with devShellTools\nDESCRIPTION: Illustrates the conversion of a Nix derivation attribute set into a shell-ready environment dictionary using devShellTools.unstructuredDerivationInputEnv. Requires the devShellTools module and dependencies like hello, figlet, and bash derivations. The function maps fields like name, buildInputs, and builder to their appropriate string values, returning an attribute set suitable for exporting to shell. Note that certain fields such as args are intentionally excluded from the environment output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/dev-shell-tools.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\ndevShellTools.unstructuredDerivationInputEnv {\n  drvAttrs = {\n    name = \"foo\";\n    buildInputs = [\n      hello\n      figlet\n    ];\n    builder = bash;\n    args = [\n      \"-c\"\n      \"${./builder.sh}\"\n    ];\n  };\n}\n# => {\n#  name = \"foo\";\n#  buildInputs = \"/nix/store/...-hello /nix/store/...-figlet\";\n#  builder = \"/nix/store/...-bash\";\n#}\n```\n\n----------------------------------------\n\nTITLE: Creating a BorgBackup Server in NixOS\nDESCRIPTION: NixOS configuration snippet to set up a BorgBackup repository server. It defines a repository with authorized SSH keys for secure access and specifies the repository path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.borgbackup.repos = {\n    my_borg_repo = {\n      authorizedKeys = [\n        \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID78zmOyA+5uPG4Ot0hfAy+sLDPU1L4AiIoRYEIVbbQ/ root@nixos\"\n      ] ;\n      path = \"/var/lib/my_borg_repo\" ;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Cargo Build and Check Features - buildRustPackage - Nix\nDESCRIPTION: Demonstrates advanced control over which cargo features are enabled during build and test phases. Attributes include `buildNoDefaultFeatures`, `buildFeatures`, and `checkFeatures` to selectively toggle feature sets. This approach supports scenarios where enabling or disabling certain features affects build determinism or test reliability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  pname = \"myproject\";\n  version = \"1.0.0\";\n\n  buildNoDefaultFeatures = true;\n  buildFeatures = [\n    \"color\"\n    \"net\"\n  ];\n\n  # disable network features in tests\n  checkFeatures = [ \"color\" ];\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Additional Users to SVN Password File - Command Line (Shell)\nDESCRIPTION: This shell command adds a new user to an existing SVN password file using SHA encryption. The absence of the 'c' flag means the file must already exist. Prerequisites: Password file must already have been created, and htpasswd must be installed. Inputs: PASSWORD_FILE is the path to the credentials file, USER_NAME is the login of the new user. Output: Appends/encrypts new username to the list.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ htpasswd -s PASSWORD_FILE USER_NAME\n```\n\n----------------------------------------\n\nTITLE: Substituting Environment Variables in a Script using substituteAll in Nix\nDESCRIPTION: Demonstrates usage of the substituteAll function in a Nix expression to process a shell script and substitute placeholders with environment variable values. Requires the substituteAll function and dependencies injected as Nix derivation inputs. The env attribute maps variable names to string values or dependencies. Output is the modified script with variables inlined, except for those not listed in env (e.g., @unchanged@ will remain).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  substituteAll,\n  bash,\n  hello,\n}:\nsubstituteAll {\n  src = ./say-goodbye.sh;\n  env = {\n    inherit bash hello;\n    greeting = \"goodbye\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing NixOS Configuration Changes without Setting Boot Default - ShellSession\nDESCRIPTION: This command builds and switches the running system to the new NixOS configuration, but does not set it as the default for future boots. Useful for testing changes without risking persistent system breakage. Must be run as root. Input: None; Output: Temporarily switches system configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild test\n```\n\n----------------------------------------\n\nTITLE: Configuring Node Exporter in NixOS\nDESCRIPTION: This snippet shows how to enable and configure the Prometheus node exporter in NixOS, setting the port, enabling specific collectors, disabling others, and configuring firewall settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/prometheus/exporters.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.prometheus.exporters.node = {\n    enable = true;\n    port = 9100;\n    enabledCollectors = [\n      \"logind\"\n      \"systemd\"\n    ];\n    disabledCollectors = [\n      \"textfile\"\n    ];\n    openFirewall = true;\n    firewallFilter = \"-i br0 -p tcp -m tcp --dport 9100\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Media Proxy Warming with MRF Policy in Akkoma - Nix\nDESCRIPTION: This snippet enables the MediaProxyWarmingPolicy automated policy in Akkoma by pushing its module reference into the list of active federation policies. It utilizes functional constructs to format configuration for Elixir and expects pkgs.formats.elixirConf and mkRaw utilities. The main input is the policy module string; output is aggressive prefetching and caching of remote media upon post receipt.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.config.\":pleroma\".\":mrf\".policies =\n    map (pkgs.formats.elixirConf { }).lib.mkRaw [\n      \"Pleroma.Web.ActivityPub.MRF.MediaProxyWarmingPolicy\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting and Installing Emacs Packages with withPackages in Nix (Nix)\nDESCRIPTION: This Nix snippet demonstrates how to use the emacs.pkgs.withPackages helper to select Emacs packages (such as company, counsel, flycheck, ivy, magit, projectile, use-package) at install time instead of interactively through Emacs. Users define a packageOverrides attribute that produces myEmacs, a configured Emacs package set, which can then be installed via nix-env. This approach requires nixpkgs as a dependency and assumes basic familiarity with Nix expressions; package selection is declarative and includes only the specified packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/emacs.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    pkgs: with pkgs; {\n      myEmacs = emacs.pkgs.withPackages (\n        epkgs:\n        (with epkgs.melpaStablePackages; [\n          company\n          counsel\n          flycheck\n          ivy\n          magit\n          projectile\n          use-package\n        ])\n      );\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Hash Calculation with fetchurl (Nix Language)\nDESCRIPTION: This snippet shows the correct way to trigger a new hash calculation by setting the hash parameter to an empty string. When the hash is empty, building the derivation will fail but print the correct hash value to use. Set hash = \"\" to intentionally cause a hash mismatch error during build, allowing you to copy the correct hash from the error message and update your package recipe. Requires internet connectivity and a working Nix build environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  url = \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\";\n  hash = \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS User Module with Explicit Group Assignment - nix\nDESCRIPTION: This snippet provides the recommended way to define a system user in NixOS, including explicit group assignment. It configures users.users.foo with isSystemUser = true and group = \"foo\", and also creates a corresponding entry in users.groups. This ensures the user is safely and properly integrated into the system, addressing recent changes that require non-default group assignments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2111.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.foo = {\n    isSystemUser = true;\n    group = \"foo\";\n  };\n  users.groups.foo = {};\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Database for Maubot in NixOS\nDESCRIPTION: This snippet demonstrates how to configure Maubot to use a PostgreSQL database instead of the default SQLite. It sets the database connection string in the Maubot settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/maubot.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.maubot.settings.database = \"postgresql://maubot@localhost/maubot\";\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Taskserver User Credentials to Client via SSH (ShellSession)\nDESCRIPTION: This snippet shows how to export credentials for a Taskserver user ('alice' in organization 'my-company') from a NixOS server and import them onto a client machine ('alicebox') using SSH. The command pipes the output of nixos-taskserver user export directly into a shell process on the client, effectively installing the necessary client certificates and keys. This requires SSH access to the server, the nixos-taskserver tool installed, and that the user/org exist on the server. The expected output is the importation of the Taskserver user's credentials on the client system. Usage is limited by network access and the presence of a compatible shell environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/taskserver/default.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ ssh server nixos-taskserver user export my-company alice | sh\n```\n\n----------------------------------------\n\nTITLE: Defining a Nix Shell Environment with Octave Packages (nix)\nDESCRIPTION: This Nix expression configures an isolated shell.nix environment, using mkShell to set up the development shell and withPackages to include the 'symbolic' Octave package. The attribute set imports <nixpkgs> by default and attaches the Octave environment via nativeBuildInputs. Dependencies include Nix, Nixpkgs, and a functional network connection when evaluating the flake or expression. It is structured for use within project development directories and provides Octave and its extensions when the shell is loaded.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/octave.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\npkgs.mkShell {\n  nativeBuildInputs = with pkgs; [\n    (octave.withPackages (opkgs: with opkgs; [ symbolic ]))\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling NetworkManager in NixOS\nDESCRIPTION: Basic configuration to enable NetworkManager system-wide in NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/network-manager.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.networkmanager.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ACME Certificates for Nginx in NixOS\nDESCRIPTION: This snippet demonstrates how to set up ACME certificate generation for Nginx virtual hosts in NixOS. It includes configuration for accepting ACME terms, setting an email address, and defining virtual hosts with ACME enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.acme.acceptTerms = true;\n  security.acme.defaults.email = \"admin+acme@example.com\";\n  services.nginx = {\n    enable = true;\n    virtualHosts = {\n      \"foo.example.com\" = {\n        forceSSL = true;\n        enableACME = true;\n        # All serverAliases will be added as extra domain names on the certificate.\n        serverAliases = [ \"bar.example.com\" ];\n        locations.\"/\" = {\n          root = \"/var/www\";\n        };\n      };\n\n      # We can also add a different vhost and reuse the same certificate\n      # but we have to append extraDomainNames manually beforehand:\n      # security.acme.certs.\"foo.example.com\".extraDomainNames = [ \"baz.example.com\" ];\n      \"baz.example.com\" = {\n        forceSSL = true;\n        useACMEHost = \"foo.example.com\";\n        locations.\"/\" = {\n          root = \"/var/www\";\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building the lxml Package with System Library Dependencies - Nix\nDESCRIPTION: This example shows how to package the lxml Python package, which requires system libraries (libxml2 and libxslt) as build inputs, using buildPythonPackage. It demonstrates specifying both Python and C library dependencies, disabling checks due to 'in-place' testing requirements, and using pythonImportsCheck for basic validation. Prerequisites include all listed dependencies in the Nixpkgs environment. The derivation includes relevant metadata such as homepage, changelog, and license. Tests are disabled but some import checks are still performed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_30\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n  setuptools,\n  libxml2,\n  libxslt,\n}:\n\nbuildPythonPackage rec {\n  pname = \"lxml\";\n  version = \"3.4.4\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-s9NiusRxFydHzaNRMjjxFcvWxfi45jGb9ql6eJJyQJk=\";\n  };\n\n  build-system = [\n    setuptools\n  ];\n\n  buildInputs = [\n    libxml2\n    libxslt\n  ];\n\n  # tests are meant to be ran \"in-place\" in the same directory as src\n  doCheck = false;\n\n  pythonImportsCheck = [\n    \"lxml\"\n    \"lxml.etree\"\n  ];\n\n  meta = {\n    changelog = \"https://github.com/lxml/lxml/releases/tag/lxml-${version}\";\n    description = \"Pythonic binding for the libxml2 and libxslt libraries\";\n    homepage = \"https://lxml.de\";\n    license = lib.licenses.bsd3;\n    maintainers = with lib.maintainers; [ sjourdois ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing PHP with Extensions in Nix\nDESCRIPTION: Demonstrates how to install PHP with specific extensions using the php.withExtensions function. This example adds the ImageMagick extension to the default set of extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nphp.withExtensions ({ enabled, all }: enabled ++ [ all.imagick ])\n```\n\n----------------------------------------\n\nTITLE: Enabling postgresqlTestHook in Nix Derivation - Nix\nDESCRIPTION: This snippet demonstrates how to include the postgresqlTestHook in the nativeCheckInputs of a stdenv.mkDerivation to launch a PostgreSQL server during the checkPhase of package building in Nix. The dependencies required are 'stdenv' (the standard Nix build environment), 'postgresql' (the database server package), and 'postgresqlTestHook' (the actual test hook script). You must list both postgresql and postgresqlTestHook in nativeCheckInputs for the hook to take effect. The inputs should be Nix package derivations, and this approach assumes you are using the default checkPhase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/postgresql-test-hook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  postgresql,\n  postgresqlTestHook,\n}:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeCheckInputs = [\n    postgresql\n    postgresqlTestHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Check Phase Build Type - buildRustPackage - Nix\nDESCRIPTION: Sets the `checkType` attribute to `debug` within a `buildRustPackage` expression, causing cargo tests to run in debug mode instead of the default release. Returns separate debug and release builds via `cargo build` and `cargo test`, trading off test coverage for potential build speed or test stability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  checkType = \"debug\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Backup to a BorgBackup Server in NixOS\nDESCRIPTION: NixOS configuration for setting up an hourly backup to a remote BorgBackup server. It includes encryption settings with a secure passphrase stored in a key file, SSH configuration, and compression settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.borgbackup.jobs = {\n    backupToLocalServer = {\n      paths = [ \"/etc/nixos\" ];\n      doInit = true;\n      repo =  \"borg@nixos:.\" ;\n      encryption = {\n        mode = \"repokey-blake2\";\n        passCommand = \"cat /run/keys/borgbackup_passphrase\";\n      };\n      environment = { BORG_RSH = \"ssh -i /run/keys/id_ed25519_my_borg_repo\"; };\n      compression = \"auto,lzma\";\n      startAt = \"hourly\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wireless Networks Declaratively in NixOS\nDESCRIPTION: Demonstrates how to declaratively specify wireless networks in NixOS configuration, including regular networks, networks with special characters in SSID, hidden networks, and public networks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.wireless.networks = {\n    echelon = {                # SSID with no spaces or special characters\n      psk = \"abcdefgh\";\n    };\n    \"echelon's AP\" = {         # SSID with spaces and/or special characters\n      psk = \"ijklmnop\";\n    };\n    echelon = {                # Hidden SSID\n      hidden = true;\n      psk = \"qrstuvwx\";\n    };\n    free.wifi = {};            # Public wireless network\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Serving the Element Web Client with Nginx and Custom Homeserver Config - NixOS Modules - Nix\nDESCRIPTION: Establishes an Nginx virtualHost for serving Element Web at an Element-specific subdomain, using a custom homeserver config derived from the main Synapse configuration. Requires pkgs.element-web, which is optionally overridden with a configuration object referencing the clientConfig from earlier in the page. Key parameter: fqdn must match the main server, and clientConfig must be correctly set. Ensures secure, self-hosted Element client separation from the Matrix homeserver.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/synapse.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nginx.virtualHosts.\"element.${fqdn}\" = {\n    enableACME = true;\n    forceSSL = true;\n    serverAliases = [\n      \"element.${config.networking.domain}\"\n    ];\n\n    root = pkgs.element-web.override {\n      conf = {\n        default_server_config = clientConfig; # see `clientConfig` from the snippet above.\n      };\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Perl Dependencies to Urxvt Plugins in Nix\nDESCRIPTION: This code demonstrates how to add Perl package dependencies to custom Urxvt plugins. It uses the 'perlDeps' option to provide the 'AnyEvent' Perl package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nrxvt-unicode.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      perlDeps = with perlPackages; [ AnyEvent ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Chapters in Nixpkgs Documentation\nDESCRIPTION: This code snippet uses a custom include directive to incorporate multiple chapter files into the main documentation. It references four specific markdown files that make up the 'Using Nixpkgs' section.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using-nixpkgs.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\nusing/platform-support.chapter.md\nusing/configuration.chapter.md\nusing/overlays.chapter.md\nusing/overrides.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Shellcheck validation for single script in Nix\nDESCRIPTION: Demonstrates how to run shellcheck on a single shell script using testers.shellcheck. This tester performs static analysis on shell scripts to identify potential issues or errors.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\ntesters.shellcheck {\n  name = \"script\";\n  src = ./script.sh;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Standalone DNS-over-HTTPS Server with ACME - Nix\nDESCRIPTION: This Nix configuration sets up a standalone doh-server DNS-over-HTTPS instance, specifying a domain for ACME certificate management and upstream DNS resolver. The example introduces a dynamic domain variable and securely provides Cloudflare DNS API credentials for certificate issuance. The doh-server listens on port 443 and is associated with the ACME-provided certificate. Required modules include doh-server, ACME, and necessary firewall adjustments for HTTPS. The input domain and credential file paths must be customized. The output is a minimal, production-grade standalone DoH server using proper TLS certificates. Limitations include no reverse proxy and the recommendation to use Nginx for OCSP stapling.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/doh-server.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  domain = \"doh.example.com\";\nin\n{\n  security.acme.certs.${domain} = {\n    dnsProvider = \"cloudflare\";\n    credentialFiles.\"CF_DNS_API_TOKEN_FILE\" = \"/run/secrets/cf-api-token\";\n  };\n\n  services.doh-server = {\n    enable = true;\n    settings = {\n      listen = [ \":443\" ];\n      upstream = [ \"udp:1.1.1.1:53\" ];\n    };\n    useACMEHost = domain;\n  };\n\n  networking.firewall.allowedTCPPorts = [ 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Athens Caching Proxy Configuration in NixOS\nDESCRIPTION: Minimal configuration to enable Athens as a caching and forwarding HTTP proxy service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/athens.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.athens = {\n      enable = true;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Manpage Files with installShellFiles - Nix\nDESCRIPTION: This snippet shows the use of `installManPage` to copy manpage files into appropriate directories within the package's `outputMan` output. The example demonstrates renaming a manpage to avoid filename conflicts and then installing it alongside other manpages within a `postInstall` hook. The code depends on `installShellFiles` and expects manpages to have valid section suffixes and, optionally, `.gz` compression. Inputs are manpage filenames; outputs are correctly installed manpages in their expected locations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/installShellFiles.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ installShellFiles ];\n\n  # Sometimes the manpage file has an undersirable name; e.g. it conflicts with\n  # another software with an equal name. It should be renamed before being\n  # installed via installManPage\n  postInstall = ''\n    mv fromsea.3 delmar.3\n    installManPage foobar.1 delmar.3\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Updating All Python Libraries with update-python-libraries - Shell\nDESCRIPTION: Demonstrates how to use the update-python-libraries script to bulk-update all Python libraries between minor versions in Nixpkgs. This approach automates version bumps and commit creation while supporting package discovery via pkgs/development/python-modules/**/default.nix. The script depends on a functional Nix environment, and for GitHub hosting it is recommended to set a GITHUB_API_TOKEN in the environment for rate-limited API access. The command takes options for minor/major version updates. It is tailored for maintainers and should be run after ensuring a backup or branch is available. Output includes updated derivations and their commits; breakages may occur, requiring subsequent stabilization.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_56\n\nLANGUAGE: shell\nCODE:\n```\n$ maintainers/scripts/update-python-libraries --target minor --commit --use-pkgs-prefix pkgs/development/python-modules/**/default.nix\n```\n\n----------------------------------------\n\nTITLE: Obtaining vendorHash Using nix-prefetch\nDESCRIPTION: Command to obtain the vendorHash value for a package using nix-prefetch tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd path/to/nixpkgs\nnix-prefetch -E \"{ sha256 }: ((import ./. { }).my-package.overrideAttrs { vendorHash = sha256; }).goModules\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Gem-specific Build Settings in bundlerEnv\nDESCRIPTION: Shows how to override default gem configurations in a bundlerEnv derivation. This approach is useful for projects using Bundler with gems that require specific build settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pg_version ? \"10\",\n  pkgs ? import <nixpkgs> { },\n}:\nlet\n  gems = pkgs.bundlerEnv {\n    name = \"gems-for-some-project\";\n    gemdir = ./.;\n    gemConfig = pkgs.defaultGemConfig // {\n      pg = attrs: {\n        buildFlags = [ \"--with-pg-config=${pkgs.\"postgresql_${pg_version}\".pg_config}/bin/pg_config\" ];\n      };\n    };\n  };\nin\nmkShell {\n  buildInputs = [\n    gems\n    gems.wrappedRuby\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Template for Reviewing New Packages - Markdown\nDESCRIPTION: Provides a comprehensive markdown checklist for reviewing new package submissions to nixpkgs. Reviewers validate file paths, meta attributes, licenses, dependency declarations, and patch procedures. The reviewer documents findings and areas for potential improvement. The checklist standardizes evaluation and helps ensure quality and policy compliance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_25\n\nLANGUAGE: markdown\nCODE:\n```\n##### Reviewed points\n\n- [ ] package path fits guidelines\n- [ ] package name fits guidelines\n- [ ] package version fits guidelines\n- [ ] package builds on ARCHITECTURE\n- [ ] executables tested on ARCHITECTURE\n- [ ] `meta.description` is set and fits guidelines\n- [ ] `meta.license` fits upstream license\n- [ ] `meta.platforms` is set\n- [ ] `meta.maintainers` is set\n- [ ] `meta.mainProgram` is set, if applicable.\n- [ ] build time only dependencies are declared in `nativeBuildInputs`\n- [ ] source is fetched using the appropriate function\n- [ ] the list of `phases` is not overridden\n- [ ] when a phase (like `installPhase`) is overridden it starts with `runHook preInstall` and ends with `runHook postInstall`.\n- [ ] patches have a comment describing either the upstream URL or a reason why the patch wasn't upstreamed\n- [ ] patches that are remotely available are fetched rather than vendored\n\n##### Possible improvements\n\n##### Comments\n```\n\n----------------------------------------\n\nTITLE: Migrating Grafana Option to settings INI Syntax in Nix\nDESCRIPTION: This snippet shows the updated preferred way to configure Grafana administrative parameters using attribute sets under services.grafana.settings. The settings attribute is converted to Grafana-compatible INI format, reflecting sections and keys as nested attributes. Here, security.admin_user is set to 'foobar' as part of the recommended migration from environment-based configuration. Inputs are native Nix attribute sets; the module translates this for Grafana's consumption. Dependency: Modern NixOS Grafana module. Outputs a properly configured and restarted Grafana instance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  services.grafana.settings.security.admin_user = \\\"foobar\\\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Lua Environment in config.nix - Nix Expression - nix\nDESCRIPTION: This snippet demonstrates how to use packageOverrides within ~/.config/nixpkgs/config.nix to create and inject a custom Lua environment (myLuaEnv) into the user's package set. It leverages lua5_2.withPackages to bundle extra packages. Main dependencies are pkgs, lua5_2, and the chosen extras. Once configured, myLuaEnv can be referenced and installed system-wide or in user profiles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n\n  packageOverrides =\n    pkgs: with pkgs; {\n      myLuaEnv = lua5_2.withPackages (\n        ps: with ps; [\n          busted\n          luafilesystem\n        ]\n      );\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing BorgBackup Configuration with Terminal Commands\nDESCRIPTION: A series of terminal commands to test a BorgBackup configuration. It includes restarting the service, checking backup status, and listing backups in the repository using the Borg CLI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n> nixos-rebuild switch\n...restarting the following units: polkit.service\n> systemctl restart borgbackup-job-backupToLocalServer\n> sleep 10\n> systemctl restart borgbackup-job-backupToLocalServer\n> export BORG_PASSPHRASE=topSecrect\n> borg list --rsh='ssh -i /run/keys/id_ed25519_my_borg_repo' borg@nixos:.\nnixos-backupToLocalServer-2020-03-30T21:46:17 Mon, 2020-03-30 21:46:19 [84feb97710954931ca384182f5f3cb90665f35cef214760abd7350fb064786ac]\nnixos-backupToLocalServer-2020-03-30T21:46:30 Mon, 2020-03-30 21:46:32 [e77321694ecd160ca2228611747c6ad1be177d6e0d894538898de7a2621b6e68]\n```\n\n----------------------------------------\n\nTITLE: Listing Available GitLab Rake Tasks in NixOS\nDESCRIPTION: This command demonstrates how to list all available rake tasks for GitLab when running as the configured GitLab user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/gitlab.md#_snippet_4\n\nLANGUAGE: shellsession\nCODE:\n```\n$ sudo -u git -H gitlab-rake -T\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Sections in Markdown\nDESCRIPTION: Markdown include directive specifying documentation sections related to NixOS testing, including writing tests, running tests, interactive testing, package linking, and hardware testing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/nixos-tests.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{=include=} sections\nwriting-nixos-tests.section.md\nrunning-nixos-tests.section.md\nrunning-nixos-tests-interactively.section.md\nlinking-nixos-tests-to-packages.section.md\ntesting-hardware-features.section.md\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus to Scrape Node Exporter Metrics\nDESCRIPTION: This snippet demonstrates how to configure Prometheus to scrape metrics from a node exporter by defining a scrape configuration with a job name and target.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/prometheus/exporters.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.prometheus = {\n      # ...\n\n      scrapeConfigs = [\n        {\n          job_name = \"node\";\n          static_configs = [{\n            targets = [ \"localhost:${toString config.services.prometheus.exporters.node.port}\" ];\n          }];\n        }\n      ];\n\n      # ...\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Python Environment with python.buildEnv.override (Nix)\nDESCRIPTION: This snippet illustrates how to use python3.buildEnv.override in Nix to create a Python environment featuring selected extra libraries, here specifically the Pyramid web framework. Required dependencies include Nixpkgs and the python3Packages.pyramid package. The key parameters are extraLibs (the set of packages to include) and ignoreCollisions (controls conflict behavior). The environment is constructed as a derivation, resulting in a Nix store path with wrapped binaries in bin/. Outputs include a self-contained, reproducible Python interpreter setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\npython3.buildEnv.override {\n  extraLibs = [ python3Packages.pyramid ];\n  ignoreCollisions = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving gitignoreSource and gitignoreSourcePure via Filter Functions in Nix\nDESCRIPTION: This snippet illustrates how gitignoreSourcePure and gitignoreSource are created from more general filter functions by providing a filter that includes all files (function returns true). It relies on gitignoreFilterSourcePure and gitignoreFilterSource functions. No external dependencies beyond standard nixpkgs are required and outputs two filter functions tailored for most common use cases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/nix-gitignore.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  gitignoreSourcePure = gitignoreFilterSourcePure (_: _: true);\n  gitignoreSource = gitignoreFilterSource (_: _: true);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Plausible Analytics Options - NixOS - Nix\nDESCRIPTION: This Nix language snippet presents the required configuration for enabling the Plausible analytics service on NixOS. It specifies enabling the service, setting the public base URL, and referencing the file containing the previously generated secret key. The configuration expects that the secret key file is accessible at the given path on the system. The key parameters are 'enable' (to toggle the service), 'baseUrl' (the publicly accessible URL), and 'secretKeybaseFile' (which should point to the secure secret file).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/plausible.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.plausible = {\n    enable = true;\n    server = {\n      baseUrl = \"http://analytics.example.org\";\n      # secretKeybaseFile is a path to the file which contains the secret generated\n      # with openssl as described above.\n      secretKeybaseFile = \"/run/secrets/plausible-secret-key-base\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Flags in Rust Package Build\nDESCRIPTION: Example showing how to configure test flags to skip specific tests in a Rust package build using buildRustPackage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  checkFlags = [\n    # reason for disabling test\n    \"--skip=example::tests:example_test\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Extending systemPackages with Hy and Python Packages in configuration.nix - nix\nDESCRIPTION: This snippet demonstrates how to extend the environment.systemPackages list in configuration.nix to include Hy along with additional Python packages like numpy and matplotlib. It uses the hy.withPackages function in Nix to add these dependencies system-wide. Dependencies include the Nixpkgs collection with Hy and desired Python packages, and knowledge of configuration.nix structure. The configuration results in Hy being available globally with access to the specified libraries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/hy.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n\n  environment.systemPackages = with pkgs; [\n    (hy.withPackages (\n      py-packages: with py-packages; [\n        numpy\n        matplotlib\n      ]\n    ))\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Executable Script in a Bin Directory with writeScriptBin in Nix\nDESCRIPTION: This example demonstrates how to use writeScriptBin to create an executable script within a bin subdirectory of the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\nwriteScriptBin \"my-script\" ''\n  echo \"hi\"\n''\n```\n\n----------------------------------------\n\nTITLE: Declaring a Custom Emscripten Package Derivation with buildEmscriptenPackage - Nix\nDESCRIPTION: This snippet defines a complete Emscripten-enabled package (xmlmirror) using Nix's buildEmscriptenPackage. It specifies all inputs, source fetching using pkgs.fetchgit, and custom build phases to patch Makefiles for Emscripten requirements. Build and install phases are detailed for collecting specific project files, with outputs organized for both distribution and documentation. It relies on dependencies like autoconf, automake, libtool, gnumake, and nodejs, using sed for Makefile modifications and explicit cache handling for reliable builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/emscripten.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\npkgs.buildEmscriptenPackage {\n  pname = \"xmlmirror\";\n  version = \"1.2.3\";\n\n  buildInputs = [\n    pkg-config\n    autoconf\n    automake\n    libtool\n    gnumake\n    libxml2\n    nodejs\n    openjdk\n    json_c\n  ];\n\n  nativeBuildInputs = [\n    pkg-config\n    writableTmpDirAsHomeHook\n    zlib\n  ];\n\n  src = pkgs.fetchgit {\n    url = \"https://gitlab.com/odfplugfest/xmlmirror.git\";\n    rev = \"4fd7e86f7c9526b8f4c1733e5c8b45175860a8fd\";\n    hash = \"sha256-i+QgY+5PYVg5pwhzcDnkfXAznBg3e8sWH2jZtixuWsk=\";\n  };\n\n  configurePhase = ''\n    runHook preConfigure\n\n    rm -f fastXmlLint.js*\n    # a fix for ERROR:root:For asm.js, TOTAL_MEMORY must be a multiple of 16MB, was 234217728\n    # https://gitlab.com/odfplugfest/xmlmirror/issues/8\n    sed -e \"s/TOTAL_MEMORY=234217728/TOTAL_MEMORY=268435456/g\" -i Makefile.emEnv\n    # https://github.com/kripken/emscripten/issues/6344\n    # https://gitlab.com/odfplugfest/xmlmirror/issues/9\n    sed -e \"s/\\$(JSONC_LDFLAGS) \\$(ZLIB_LDFLAGS) \\$(LIBXML20_LDFLAGS)/\\$(JSONC_LDFLAGS) \\$(LIBXML20_LDFLAGS) \\$(ZLIB_LDFLAGS) /g\" -i Makefile.emEnv\n    # https://gitlab.com/odfplugfest/xmlmirror/issues/11\n    sed -e \"s/-o fastXmlLint.js/-s EXTRA_EXPORTED_RUNTIME_METHODS='[\\\"ccall\\\", \\\"cwrap\\\"]' -o fastXmlLint.js/g\" -i Makefile.emEnv\n\n    runHook postConfigure\n  '';\n\n  buildPhase = ''\n    runHook preBuild\n\n    make -f Makefile.emEnv\n\n    runHook postBuild\n  '';\n\n  outputs = [\n    \"out\"\n    \"doc\"\n  ];\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/share\n    mkdir -p $doc/share/${name}\n\n    cp Demo* $out/share\n    cp -R codemirror-5.12 $out/share\n    cp fastXmlLint.js* $out/share\n    cp *.xsd $out/share\n    cp *.js $out/share\n    cp *.xhtml $out/share\n    cp *.html $out/share\n    cp *.json $out/share\n    cp *.rng $out/share\n    cp README.md $doc/share/${name}\n    runHook postInstall\n  '';\n\n  checkPhase = ''\n    runHook preCheck\n\n    runHook postCheck\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MariaDB and MySQL Databases for Matomo in SQL\nDESCRIPTION: SQL commands to set up a MariaDB or MySQL database for Matomo using passwordless authentication via the UNIX_SOCKET plugin. This allows the 'matomo' unix user to authenticate as the 'matomo' database user without a password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/matomo.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\n# For MariaDB\nINSTALL PLUGIN unix_socket SONAME 'auth_socket';\nCREATE DATABASE matomo;\nCREATE USER 'matomo'@'localhost' IDENTIFIED WITH unix_socket;\nGRANT ALL PRIVILEGES ON matomo.* TO 'matomo'@'localhost';\n\n# For MySQL\nINSTALL PLUGIN auth_socket SONAME 'auth_socket.so';\nCREATE DATABASE matomo;\nCREATE USER 'matomo'@'localhost' IDENTIFIED WITH auth_socket;\nGRANT ALL PRIVILEGES ON matomo.* TO 'matomo'@'localhost';\n```\n\n----------------------------------------\n\nTITLE: Declaring Go Build Dependencies in Nix Expressions - Nix\nDESCRIPTION: Demonstrates how to explicitly specify system-level C library dependencies for Go projects in Nix using the `buildInputs` attribute. This is necessary when building Go programs that link against C libraries (when CGO is enabled). The dependencies, such as `libvirt` and `libxml2`, are listed as derivations. The input is a set attribute in a Nix derivation, and the output is proper linkage of C dependencies during the Go build process. No additional constraints aside from listing all required libraries apply.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    libvirt\n    libxml2\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: User Unit Test Example\nDESCRIPTION: Example of testing user systemd units in Python test script\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmachine.start()\nmachine.wait_for_x()\nmachine.wait_for_unit(\"xautolock.service\", \"x-session-user\")\n```\n\n----------------------------------------\n\nTITLE: Basic buildGoModule Example for Pet CLI Tool\nDESCRIPTION: Example showing how to build a Go module called 'pet' using buildGoModule, including source fetching from GitHub and vendor hash specification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pet = buildGoModule (finalAttrs: {\n    pname = \"pet\";\n    version = \"0.3.4\";\n\n    src = fetchFromGitHub {\n      owner = \"knqyf263\";\n      repo = \"pet\";\n      tag = \"v${finalAttrs.version}\";\n      hash = \"sha256-Gjw1dRrgM8D3G7v6WIM2+50r4HmTXvx0Xxme2fH9TlQ=\";\n    };\n\n    vendorHash = \"sha256-ciBIR+a1oaYH+H1PcC8cD8ncfJczk1IiJ8iYNM+R6aA=\";\n\n    meta = {\n      description = \"Simple command-line snippet manager, written in Go\";\n      homepage = \"https://github.com/knqyf263/pet\";\n      license = lib.licenses.mit;\n      maintainers = with lib.maintainers; [ kalbasit ];\n    };\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring End-of-Life Nextcloud Package Attribute - Nix\nDESCRIPTION: This snippet shows how to mark a specific Nextcloud package version as end-of-life (EOL) using an attribute set in Nix. It is typically used in the Nixpkgs codebase to maintain upgrade paths and deprecate outdated Nextcloud releases. Dependencies include the generic function (a builder for Nextcloud versions). Key parameters are version, sha256 (source hash), and eol (end-of-life boolean). Inputs are inherited package parameters; output is an attribute set marking this particular Nextcloud version as deprecated in the Nix Infrastruture. This strategy helps maintainers safely manage removal of old package versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/nextcloud.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n/* ... */\n{\n  nextcloud17 = generic {\n    version = \"17.0.x\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n    eol = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Pre-Build Script with preConfigure in a Nix Rust Crate Derivation (Nix)\nDESCRIPTION: This Nix code demonstrates assigning custom phase hooks in a Rust crate build, specifically using the `preConfigure` attribute to append Rust constants to a source file before compilation. This enables injection of environment- or build-time configuration directly into the crate during the build process. The provided shell snippet creates a source file with a constant path value.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_30\n\nLANGUAGE: nix\nCODE:\n```\n(hello { }).override {\n  preConfigure = ''\n    echo \"pub const PATH=\\\"${hi.out}\\\";\" >> src/path.rs\"\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building a Python Application with buildPythonApplication in Nix\nDESCRIPTION: Presents a Nix expression for packaging a Python application using buildPythonApplication. It specifies the package name, version, source hash, build-system dependencies (setuptools), runtime dependencies (tornado, python-daemon), and standard application metadata. The pattern requires functioning python3Packages and fetchPypi from nixpkgs, integrates the app into the standard applications directory (pkgs/by-name), and omits importable modules from the global python3Packages environment. Inputs are package metadata and dependencies, and outputs are a build derivation suitable for distribution as a CLI tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  python3Packages,\n  fetchPypi,\n}:\n\npython3Packages.buildPythonApplication rec {\n  pname = \"luigi\";\n  version = \"2.7.9\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-Pe229rT0aHwA98s+nTHQMEFKZPo/yw6sot8MivFDvAw=\";\n  };\n\n  build-system = with python3Packages; [\n    setuptools\n  ];\n\n  dependencies = with python3Packages; [\n    tornado\n    python-daemon\n  ];\n\n  meta = {\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Netbird Firewall Configuration for Internal Services in NixOS\nDESCRIPTION: Demonstrates how to expose services exclusively to Netbird network by combining firewall rules with interface names. Different services can be exposed on different Netbird interfaces.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/netbird.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.netbird.clients.priv.port = 51819;\n  services.netbird.clients.work.port = 51818;\n  networking.firewall.interfaces = {\n    \"${config.services.netbird.clients.priv.interface}\" = {\n      allowedUDPPorts = [ 1234 ];\n    };\n    \"${config.services.netbird.clients.work.interface}\" = {\n      allowedTCPPorts = [ 8080 ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Synaptics Touchpad Support with Libinput - Nix\nDESCRIPTION: Sets services.libinput.enable to true, activating libinput driver support for Synaptics (and other) touchpads. Replaces deprecated synaptics driver. No parameters required, but only available if hardware supports touchpad input.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.libinput.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling and Configuring Mattermost with Postgres - NixOS Module - Nix\nDESCRIPTION: This snippet shows how to enable the Mattermost service in NixOS, configure it to listen on all interfaces at port 8065, and adjust both plugin auto-installation and local control socket settings. Dependencies include the NixOS module system and a properly configured Postgres database. Key options include 'enable', 'host', 'port', 'mutableConfig', 'preferNixConfig', and 'socket.export'. Inputs are NixOS configuration keys, and the output is an activated, customized Mattermost service. The configuration must be included as part of the NixOS system configuration for proper activation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/mattermost.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mattermost = {\n    enable = true;\n\n    # You can change this if you are reverse proxying.\n    host = \"0.0.0.0\";\n    port = 8065;\n\n    # Allow modifications to the config from Mattermost.\n    mutableConfig = true;\n\n    # Override modifications to the config with your NixOS config.\n    preferNixConfig = true;\n\n    socket = {\n      # Enable control with the `mmctl` socket.\n      enable = true;\n\n      # Exporting the control socket will add `mmctl` to your PATH, and export\n      # MMCTL_LOCAL_SOCKET_PATH systemwide. Otherwise, you can get the socket\n      # path out of `config.mattermost.socket.path` and set it manually.\n      export = true;\n    };\n\n    # For example, to disable auto-installation of prepackaged plugins.\n    settings.PluginSettings.AutomaticPrepackagedPlugins = false;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Xfce Desktop Environment in NixOS - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to enable the Xfce Desktop Environment by setting the appropriate options in the NixOS configuration. It enables Xfce as the desktop manager and sets it as the default session. No additional dependencies are required beyond a working NixOS configuration environment. The configuration expects to be placed within the system 'configuration.nix' file and, upon rebuilding, will result in Xfce being available as the graphical desktop.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/xfce.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.xfce.enable = true;\n  services.displayManager.defaultSession = \"xfce\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Clevis-Backed Unattended Decryption in NixOS (Nix)\nDESCRIPTION: This Nix configuration snippet enables the Clevis module within the NixOS initial RAM disk (initrd) environment. By setting \"boot.initrd.clevis.enable\" to true, Clevis support is integrated into early boot, allowing automated device decryption. No additional parameters are needed for basic activation. This is a prerequisite for specifying which devices to automatically decrypt during boot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/clevis.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.initrd.clevis.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx as Frontend Proxy for GitLab in NixOS\nDESCRIPTION: This snippet demonstrates how to set up Nginx as a frontend proxy for GitLab. It includes recommended settings and configures a virtual host with ACME for SSL.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/gitlab.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nginx = {\n    enable = true;\n    recommendedGzipSettings = true;\n    recommendedOptimisation = true;\n    recommendedProxySettings = true;\n    recommendedTlsSettings = true;\n    virtualHosts.\"git.example.com\" = {\n      enableACME = true;\n      forceSSL = true;\n      locations.\"/\".proxyPass = \"http://unix:/run/gitlab/gitlab-workhorse.socket\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Assertions in NixOS Modules - Nix\nDESCRIPTION: This example enforces a mutual exclusivity condition between 'syslogd' and 'rsyslogd' services in a NixOS configuration. Using the 'assertions' attribute and 'lib.mkIf', it ensures that only one syslog daemon is enabled at a time, aborting the build if both are active. The assertion includes a custom error message for clear user feedback. Prerequisites include definitions for 'services.syslogd.enable' and 'services.rsyslogd.enable'. The output is a build-time assertion failure if the constraint is violated, safeguarding system integrity.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/assertions.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, ... }:\n{\n  config = lib.mkIf config.services.syslogd.enable {\n    assertions =\n      [ { assertion = !config.services.rsyslogd.enable;\n          message = \"rsyslogd conflicts with syslogd\";\n        }\n      ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mjolnir Matrix Moderation Tool - Nix\nDESCRIPTION: This snippet sets up the Mjolnir Matrix moderation bot on a NixOS system by enabling the relevant service and setting essential options including the homeserver URL, Pantalaimon E2EE proxy configuration, protected rooms, and the management room. Pantalaimon integration enables encrypted management rooms, and sensitive credentials are passed securely through a password file. The main configuration block should be placed within the NixOS configuration.nix file, with the expectation that a Matrix user for Mjolnir and a management room have already been created. Requires the homeserver to be accessible and (optionally) Pantalaimon available on the system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/mjolnir.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mjolnir = {\n    enable = true;\n    homeserverUrl = \"https://matrix.domain.tld\";\n    pantalaimon = {\n       enable = true;\n       username = \"mjolnir\";\n       passwordFile = \"/run/secrets/mjolnir-password\";\n    };\n    protectedRooms = [\n      \"https://matrix.to/#/!xxx:domain.tld\"\n    ];\n    managementRoom = \"!yyy:domain.tld\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Idris Package with Nix\nDESCRIPTION: Complete Nix expression for building an Idris package (yaml), showing how to specify dependencies, source location, and metadata.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  build-idris-package,\n  fetchFromGitHub,\n  contrib,\n  lightyear,\n}:\nbuild-idris-package {\n  name = \"yaml\";\n  version = \"2018-01-25\";\n\n  # This is the .ipkg file that should be built, defaults to the package name\n  # In this case it should build `Yaml.ipkg` instead of `yaml.ipkg`\n  # This is only necessary because the yaml packages ipkg file is\n  # different from its package name here.\n  ipkgName = \"Yaml\";\n  # Idris dependencies to provide for the build\n  idrisDeps = [\n    contrib\n    lightyear\n  ];\n\n  src = fetchFromGitHub {\n    owner = \"Heather\";\n    repo = \"Idris.Yaml\";\n    rev = \"5afa51ffc839844862b8316faba3bafa15656db4\";\n    hash = \"sha256-h28F9EEPuvab6zrfeE+0k1XGQJGwINnsJEG8yjWIl7w=\";\n  };\n\n  meta = {\n    description = \"Idris YAML lib\";\n    homepage = \"https://github.com/Heather/Idris.Yaml\";\n    license = lib.licenses.mit;\n    maintainers = [ lib.maintainers.brainrape ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: nix-build Output for Hash Mismatch Error (Shell)\nDESCRIPTION: This example reflects typical shell output when building a derivation with a fake or empty hash. It demonstrates how Nix reports a hash mismatch, including both the specified and the correct hash. The build process fails, but the error message contains the correct hash needed for the package recipe, which the user should copy for the next build attempt. No dependencies needed beyond Nix and internet access for the specified URL.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\nerror: hash mismatch in fixed-output derivation '/nix/store/7yynn53jpc93l76z9zdjj4xdxgynawcw-version.drv':\n        specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n            got:    sha256-BZqI7r0MNP29yGH5+yW2tjU9OOpOCEvwWKrWCv5CQ0I=\nerror: build of '/nix/store/bqdjcw5ij5ymfbm41dq230chk9hdhqff-version.drv' failed\n```\n\n----------------------------------------\n\nTITLE: Fetching a File with fetchurl in Nixpkgs (Nix Language)\nDESCRIPTION: This example demonstrates a minimal package recipe using the fetchurl function to retrieve a remote file and specify its expected hash for verification. fetchurl is a standard Nixpkgs fetcher which creates a fixed-output derivation at build time and stores the file content in the Nix store. Requires the fetchurl attribute provided in the argument set (usually passed from the Nixpkgs library). The url parameter specifies the remote file location; the hash parameter should be set to the file's expected hash to verify integrity. Outputs a store path containing the downloaded file. Ensure network access and permissions are configured as required by your build environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  url = \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.05/.version\";\n  hash = \"sha256-ZHl1emidXVojm83LCVrwULpwIzKE/mYwfztVkvpruOM=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating npm Dependency Hash with prefetch-npm-deps - Console\nDESCRIPTION: This console example shows a typical workflow to calculate an npm dependency hash by invoking prefetch-npm-deps on a package-lock.json file. The command outputs a sha256 hash that can be used as the npmDepsHash argument in buildNpmPackage. Prerequisites include an installed prefetch-npm-deps tool and valid lock file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ ls\npackage.json package-lock.json index.js\n$ prefetch-npm-deps package-lock.json\n...\nsha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n```\n\n----------------------------------------\n\nTITLE: Registering Matrix Users via CLI - ShellSession\nDESCRIPTION: Demonstrates the step-by-step process to register a new Matrix user using the command-line client. Requires that matrix-synapse and its dependencies are installed and the registration shared secret is set. The shell commands must be run after configuring the Synapse listener socket as described, and expects manual user input for username and password. Outputs user creation success or error.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/synapse.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\n$ nix-shell -p matrix-synapse\n$ register_new_matrix_user -k your-registration-shared-secret http://localhost:8008\nNew user localpart: your-username\nPassword:\nConfirm password:\nMake admin [no]:\nSuccess!\n```\n\n----------------------------------------\n\nTITLE: Configuring stripExclude for File Patterns - Nix\nDESCRIPTION: Prevents all files matching the '*.rlib' pattern from being stripped during the build process by setting the 'stripExclude' attribute inside a derivation. No external dependencies are required, just the standard Nix build environment. The 'stripExclude' attribute must be assigned a list of file patterns; input is the derivation definition and output is an unstripped '*.rlib' in the result.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  # ...\n  stripExclude = [ \"*.rlib\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Version testing with default values in Nix\nDESCRIPTION: Demonstrates how to check a program's version using testers.testVersion with default values. This example will run 'hello --version' and verify the output contains the version from the package definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  passthru.tests.version = testers.testVersion { package = hello; };\n}\n```\n\n----------------------------------------\n\nTITLE: Basic GitLab Configuration in NixOS\nDESCRIPTION: This snippet shows a basic GitLab configuration in NixOS. It includes settings for database passwords, HTTPS, SMTP, and various GitLab-specific options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/gitlab.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gitlab = {\n    enable = true;\n    databasePasswordFile = \"/var/keys/gitlab/db_password\";\n    initialRootPasswordFile = \"/var/keys/gitlab/root_password\";\n    https = true;\n    host = \"git.example.com\";\n    port = 443;\n    user = \"git\";\n    group = \"git\";\n    smtp = {\n      enable = true;\n      address = \"localhost\";\n      port = 25;\n    };\n    secrets = {\n      dbFile = \"/var/keys/gitlab/db\";\n      secretFile = \"/var/keys/gitlab/secret\";\n      otpFile = \"/var/keys/gitlab/otp\";\n      jwsFile = \"/var/keys/gitlab/jws\";\n    };\n    extraConfig = {\n      gitlab = {\n        email_from = \"gitlab-no-reply@example.com\";\n        email_display_name = \"Example GitLab\";\n        email_reply_to = \"gitlab-no-reply@example.com\";\n        default_projects_features = { builds = false; };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Bash Script in a Bin Directory with writeShellScriptBin in Nix\nDESCRIPTION: This example demonstrates how to use writeShellScriptBin to create a Bash script with a proper shebang in a bin subdirectory of the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\nwriteShellScriptBin \"my-script\" ''\n  echo \"hi\"\n''\n```\n\n----------------------------------------\n\nTITLE: Building and Installing NixOS to the System Profile (Shell)\nDESCRIPTION: Installs the built NixOS system configuration into the /nix/var/nix/profiles/system profile using nix-env. Passes the target configuration.nix path via the -I argument. Prerequisites: Nix installed, configuration prepared. Output: System profile updated for next boot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -p /nix/var/nix/profiles/system -f '<nixpkgs/nixos>' -I nixos-config=/etc/nixos/configuration.nix -iA system\n```\n\n----------------------------------------\n\nTITLE: Installing NixOS to Target Partition (Shell)\nDESCRIPTION: Invokes nixos-install to perform the actual installation of NixOS onto the target root. May require path adjustments for root-owned commands. Successful execution results in an installed NixOS on /mnt. Prerequisites: All previous preparation steps and target system mounted at /mnt. Output: NixOS system written to partition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo PATH=\\\"$PATH\\\" `which nixos-install` --root /mnt\n```\n\n----------------------------------------\n\nTITLE: Building Rust Packages with Nightly Toolchain via Oxalica Overlay - Nix\nDESCRIPTION: This Nix expression shows how to use oxalica's Rust overlay alongside makeRustPlatform/buildRustPackage to build a Rust project (ripgrep) with a nightly toolchain. It overlays nixpkgs with oxalica's source, defines a custom Rust platform using the latest nightly, and invokes buildRustPackage with project metadata, fetches sources, sets hashes, and disables tests requiring network access. This is intended for use with nix-build, and supports downstream packaging workflows.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_35\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> {\n  overlays = [\n    (import (fetchTarball \"https://github.com/oxalica/rust-overlay/archive/master.tar.gz\"))\n  ];\n};\nlet\n  rustPlatform = makeRustPlatform {\n    cargo = rust-bin.selectLatestNightlyWith (toolchain: toolchain.default);\n    rustc = rust-bin.selectLatestNightlyWith (toolchain: toolchain.default);\n  };\nin\n\nrustPlatform.buildRustPackage (finalAttrs: {\n  pname = \"ripgrep\";\n  version = \"14.1.1\";\n\n  src = fetchFromGitHub {\n    owner = \"BurntSushi\";\n    repo = \"ripgrep\";\n    tag = finalAttrs.version;\n    hash = \"sha256-gyWnahj1A+iXUQlQ1O1H1u7K5euYQOld9qWm99Vjaeg=\";\n  };\n\n  useFetchCargoVendor = true;\n  cargoHash = \"sha256-9atn5qyBDy4P6iUoHFhg+TV6Ur71fiah4oTJbBMeEy4=\";\n\n  # Tests require network access. Skipping.\n  doCheck = false;\n\n  meta = {\n    description = \"Fast line-oriented regex search tool, similar to ag and ack\";\n    homepage = \"https://github.com/BurntSushi/ripgrep\";\n    license = with lib.licenses; [\n      mit\n      unlicense\n    ];\n    maintainers = with lib.maintainers; [ ];\n  };\n})\n\n```\n\n----------------------------------------\n\nTITLE: Building Nim Package with buildNimPackage - Nix Expression - Nix\nDESCRIPTION: This snippet defines a Nix expression for building a Nim package named 'ttop' using the 'buildNimPackage' function. It uses 'fetchFromGitHub' to obtain sources and passes compilation flags, a lockfile, and package metadata. Dependencies: Nixpkgs, Nim compiler, 'buildNimPackage', and a proper lockfile in JSON format. Inputs: parameters like pname, version, src, lockFile, nimFlags. Output: A derivation yielding a built Nim package. Limitations: Nim defines must be plain strings; key-value tuples are not supported in nimDefines.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildNimPackage,\n  fetchFromGitHub,\n}:\n\nbuildNimPackage (finalAttrs: {\n  pname = \"ttop\";\n  version = \"1.2.7\";\n\n  src = fetchFromGitHub {\n    owner = \"inv2004\";\n    repo = \"ttop\";\n    rev = \"v${finalAttrs.version}\";\n    hash = lib.fakeHash;\n  };\n\n  lockFile = ./lock.json;\n\n  nimFlags = [\n    \"-d:NimblePkgVersion=${finalAttrs.version}\"\n  ];\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing a Dotnet SDK Environment Using Nix (Nix)\nDESCRIPTION: This Nix snippet demonstrates how to create a nix-shell environment configured with the Dotnet SDK. It uses the mkShell function and specifies the dotnet-sdk package to be included. This allows developers to enter a shell with Dotnet tooling pre-installed, suitable for local development. Dependencies: Nix, <nixpkgs> channel access, 'dotnet-sdk'. The environment is declared statically; only a single SDK version is specified.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n# shell.nix\nwith import <nixpkgs> { };\n\nmkShell {\n  name = \"dotnet-env\";\n  packages = [\n    dotnet-sdk\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Simple Qt6 Package - Nix\nDESCRIPTION: Demonstrates a basic Nix expression for packaging a Qt6-based application using mkDerivation. The snippet sets up mandatory inputs including qt6.qtbase in buildInputs for basic Qt runtime, and qt6.wrapQtAppsHook in nativeBuildInputs to enable post-build application wrapping for plugin and QML path configuration. Required dependencies are stdenv and qt6; no versioning or advanced settings are included. Expects output to be a wrapped, relocatable Qt app with environment variables set for plugin discovery.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/qt.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, qt6 }:\n\nstdenv.mkDerivation {\n  pname = \"myapp\";\n  version = \"1.0\";\n\n  buildInputs = [ qt6.qtbase ];\n  nativeBuildInputs = [ qt6.wrapQtAppsHook ];\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Files with concatText in Nix\nDESCRIPTION: This example demonstrates how to use concatText to concatenate multiple files into a single file in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\nconcatText\n  \"my-file\"\n  [ file1 file2 ]\n```\n\n----------------------------------------\n\nTITLE: Overriding a Nixpkgs Package for Emscripten Compilation - Nix\nDESCRIPTION: This snippet demonstrates how to override the zlib package in Nixpkgs for cross-compiling C code to JavaScript using Emscripten. It resets standard environment flags, rearranges build phases to support Emscripten tools (emconfigure, emmake, emcc), and sets up custom checks using Node.js to validate the output. Dependencies include pkgs.emscriptenStdenv, pkgs.nodejs, and pkg-config. Inputs define custom script phases (configure, build, install, check) to ensure deterministic builds and test execution. The snippet requires that HOME be set per phase for cache consistency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/emscripten.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n(pkgs.zlib.override {\n  stdenv = pkgs.emscriptenStdenv;\n}).overrideAttrs\n  (old: {\n    buildInputs = old.buildInputs ++ [ pkg-config ];\n    # we need to reset this setting!\n    env = (old.env or { }) // {\n      NIX_CFLAGS_COMPILE = \"\";\n    };\n\n    configurePhase = ''\n      # FIXME: Some tests require writing at $HOME\n      HOME=$TMPDIR\n      runHook preConfigure\n\n      #export EMCC_DEBUG=2\n      emconfigure ./configure --prefix=$out --shared\n\n      runHook postConfigure\n    '';\n\n    dontStrip = true;\n    outputs = [ \"out\" ];\n\n    buildPhase = ''\n      runHook preBuild\n\n      emmake make\n\n      runHook postBuild\n    '';\n\n    installPhase = ''\n      runHook preInstall\n\n      emmake make install\n\n      runHook postInstall\n    '';\n\n    checkPhase = ''\n      runHook preCheck\n\n      echo \"================= testing zlib using node =================\"\n\n      echo \"Compiling a custom test\"\n      set -x\n      emcc -O2 -s EMULATE_FUNCTION_POINTER_CASTS=1 test/example.c -DZ_SOLO \\\n      libz.so.${old.version} -I . -o example.js\n\n      echo \"Using node to execute the test\"\n      ${pkgs.nodejs}/bin/node ./example.js\n\n      set +x\n      if [ $? -ne 0 ]; then\n        echo \"test failed for some reason\"\n        exit 1;\n      else\n        echo \"it seems to work! very good.\"\n      fi\n      echo \"================= /testing zlib using node =================\"\n\n      runHook postCheck\n    '';\n\n    postPatch = pkgs.lib.optionalString pkgs.stdenv.hostPlatform.isDarwin ''\n      substituteInPlace configure \\\n        --replace-fail '/usr/bin/libtool' 'ar' \\\n        --replace-fail 'AR=\"libtool\"' 'AR=\"ar\"' \\\n        --replace-fail 'ARFLAGS=\"-o\"' 'ARFLAGS=\"-r\"'\n    '';\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring Lemmy Service in NixOS\nDESCRIPTION: This snippet demonstrates the minimal configuration required to start a Lemmy instance using NixOS. It enables the Lemmy service, sets the hostname, creates a local database, and enables Caddy for reverse proxying.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/lemmy.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.lemmy = {\n    enable = true;\n    settings = {\n      hostname = \"lemmy.union.rocks\";\n      database.createLocally = true;\n    };\n    caddy.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Nginx Service Module Options - NixOS Configuration - Markdown\nDESCRIPTION: This snippet summarizes several new or updated options in the services.nginx NixOS module. It covers enabling global redirects with exceptions, proxy cache path configuration, Brotli compression, improved proxy header handling, and enhanced gzip settings (compression for selected proxied requests, mime type updates, and length thresholds). The proper functioning of these options requires the nginx package and appropriate upstream modules (e.g., Brotli). Each parameter affects either the configuration file generation or nginx runtime behavior.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n- There are various new options in the \\`services.nginx\\` module:\n    - Enabling global redirect in \\`services.nginx.virtualHosts\\` now allows one to add exceptions with the \\`locations\\` option.\n    - The \\`proxyCachePath\\` option has been added to \\`services.nginx\\`. It allows configuring the [\\`proxy_cache_path\\`](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path), that configures the storage path and various other settings for the cache.\n    - A new option \\`recommendedBrotliSettings\\` has been added to \\`services.nginx\\`. Learn more about compression in Brotli format [here](https://github.com/google/ngx_brotli/blob/master/README.md).\n    - \\`services.nginx.recommendedProxySettings\\` now removes the \\`Connection\\` header preventing clients from closing backend connections.\n\n- The nginx module also received an update to \\`services.nginx.recommendedGzipSettings\\`:\n  - Enables gzip compression for only certain proxied requests.\n  - Allow checking and loading of precompressed files.\n  - Updated gzip mime-types.\n  - Increased the minimum length of a response that will be gzipped.\n```\n\n----------------------------------------\n\nTITLE: Configuring a Setup Hook with Substitutions and Dependencies - Nixpkgs - Nix\nDESCRIPTION: This snippet creates a setup hook named \"run-hello-hook\" using pkgs.makeSetupHook in the Nixpkgs context. It includes propagatedBuildInputs for runtime dependencies (hello and cowsay), and sets up a substitutions attribute to inject executable paths for bash and cowsay into the hook's shell script. The writeScript function defines the shell script, using these substitutions to ensure correct executable resolution when the hook is sourced (before the $PATH is set). The script appends a preConfigure hook that runs the hello binary, making it suitable for complex build phases with early dependency binding.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/makesetuphook.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\npkgs.makeSetupHook\n  {\n    name = \"run-hello-hook\";\n    # Put dependencies here if they have hooks or necessary dependencies propagated\n    # otherwise prefer direct paths to executables.\n    propagatedBuildInputs = [\n      pkgs.hello\n      pkgs.cowsay\n    ];\n    substitutions = {\n      shell = \"${pkgs.bash}/bin/bash\";\n      cowsay = \"${pkgs.cowsay}/bin/cowsay\";\n    };\n  }\n  (\n    writeScript \"run-hello-hook.sh\" ''\n      #!@shell@\n      # the direct path to the executable has to be here because\n      # this will be run when the file is sourced\n      # at which point '$PATH' has not yet been populated with inputs\n      @cowsay@ cow\n\n      _printHelloHook() {\n        hello\n      }\n      preConfigureHooks+=(_printHelloHook)\n    ''\n  )\n```\n\n----------------------------------------\n\nTITLE: Platform Configuration Example in Nix\nDESCRIPTION: Example showing how to specify platform support for a Linux-only package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/meta.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  meta.platforms = lib.platforms.linux;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Flat-File Binary Cache with mkBinaryCache (Nix)\nDESCRIPTION: This snippet demonstrates how to use the mkBinaryCache function to create a flat-file binary cache, which includes the full closure of the specified packages (e.g., hello). Dependencies are mkBinaryCache and the derivations listed in rootPaths. The main parameter is rootPaths, a list of derivations whose outputs and dependencies will be bundled. The output is a cache directory that can be copied and used on other machines as a Nix substituter.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/binarycache.section.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n{ mkBinaryCache, hello }:\nmkBinaryCache {\n  rootPaths = [ hello ];\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring NuGet Packages with dotnet CLI\nDESCRIPTION: Command to restore NuGet packages to a specified output directory using the dotnet CLI tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ dotnet restore --packages out\n  Determining projects to restore...\n  Restored /home/ggg/git-credential-manager/src/shared/Git-Credential-Manager/Git-Credential-Manager.csproj (in 1.21 sec).\n```\n\n----------------------------------------\n\nTITLE: Profile Loading Shell Script\nDESCRIPTION: Shell script for loading the Nix profile configuration, typically added to ~/.profile to ensure documentation access is properly set up.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\nif [ -d \"${HOME}/.nix-profile/etc/profile.d\" ]; then\n  for i in \"${HOME}/.nix-profile/etc/profile.d/\"*.sh; do\n    if [ -r \"$i\" ]; then\n      . \"$i\"\n    fi\n  done\nfi\n```\n\n----------------------------------------\n\nTITLE: Setting Firewall Options with Booleans - NixOS - nix\nDESCRIPTION: Configures NixOS firewall behavior by assigning Boolean values to enable firewall and control ping allowance. Used as a model for Boolean option definition. No external dependencies, but expects valid keys and Boolean values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.enable = true;\n  networking.firewall.allowPing = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Cargo.lock via Patches in Rust Build\nDESCRIPTION: Example showing how to add or update Cargo.lock file using cargoPatches attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  cargoPatches = [\n    # a patch file to add/update Cargo.lock in the source code\n    ./add-Cargo.lock.patch\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a Nix Shell with Tree Sitter Rust Grammar (Nix)\nDESCRIPTION: This snippet configures a Nix development shell that installs Python 3 and the py-tree-sitter library along with the Rust grammar. Dependencies include nixpkgs, python3.withPackages, tree-sitter, and tree-sitter-grammars.tree-sitter-rust. Users can drop into a shell with all the required interpreters and grammars ready for experimentation and code parsing. The configuration expects that the host has Nix installed and optionally accepts an override for the nixpkgs source.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/python-tree-sitter.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? <nixpkgs> { },\n}:\n\npkgs.mkShell {\n  name = \"py-tree-sitter-dev-shell\";\n\n  buildInputs = with pkgs; [\n    (python3.withPackages (\n      ps: with ps; [\n        tree-sitter\n        tree-sitter-grammars.tree-sitter-rust\n      ]\n    ))\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Meilisearch Service with NixOS Module - nix\nDESCRIPTION: This configuration snippet demonstrates the minimal setup required to enable the Meilisearch service via the NixOS module. Setting 'services.meilisearch.enable' to true will launch the Meilisearch HTTP server on port 7700. No additional configuration or dependencies are needed for this minimal setup, but further customization is possible through additional NixOS options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/search/meilisearch.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.meilisearch.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Vim with Basic Configuration in NixOS\nDESCRIPTION: Example showing how to create a customized Vim with personalized configuration. This code adds custom vimrc lines by creating a Vim derivative with a specified name.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nvim-full.customize {\n  # `name` optionally specifies the name of the executable and package\n  name = \"vim-with-plugins\";\n\n  vimrcConfig.customRC = ''\n    set hidden\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Crate Build Inputs and Features in Nix with crateOverrides (Nix)\nDESCRIPTION: This snippet demonstrates customizing external dependencies and build features for Rust crates using the `crateOverrides` attribute set within a Nix derivation. It shows how to use function overrides for the main crate or for a nested dependency (`libc`) by specifying build inputs (like `openssl`). This mechanism relies on Nixpkgs' function override system, allowing fine-grained tweaks to build environments and feature flags.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n((import ./hello.nix).hello { }).override {\n  crateOverrides = defaultCrateOverrides // {\n    hello = attrs: { buildInputs = [ openssl ]; };\n  };\n}\n\n```\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n((import ./hello.nix).hello { }).override {\n  crateOverrides = defaultCrateOverrides // {\n    hello =\n      attrs:\n      lib.optionalAttrs (lib.versionAtLeast attrs.version \"1.0\") {\n        postPatch = ''\n          substituteInPlace lib/zoneinfo.rs \\\n            --replace-fail \"/usr/share/zoneinfo\" \"${tzdata}/share/zoneinfo\"\n        '';\n      };\n  };\n}\n\n```\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n((import hello.nix).hello { }).override {\n  crateOverrides = defaultCrateOverrides // {\n    libc = attrs: { buildInputs = [ ]; };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Public Read-only Samba Share with NixOS Modules (Nix)\nDESCRIPTION: This snippet configures Samba in NixOS to provide a public, unauthenticated, and read-only file share. Under 'services.samba.settings', a share named 'public' is defined, specifying its filesystem path, access restrictions, and display comment. Required dependencies are the Samba module and that the directory '/public' exists on the system. Inputs involve customizing the share name and settings, while outputs deliver a browsable, guest-accessible share that can be mounted by clients without credentials.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/network-filesystems/samba.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.samba = {\n    enable = true;\n    settings = {\n      \"public\" = {\n        \"path\" = \"/public\";\n        \"read only\" = \"yes\";\n        \"browseable\" = \"yes\";\n        \"guest ok\" = \"yes\";\n        \"comment\" = \"Public samba share.\";\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Reindexing Documents and Creating Superuser with Paperless-ng - shell\nDESCRIPTION: This set of shell commands guides users through reindexing documents and creating a superuser with the paperless-ng service on NixOS. It assumes the user has switched to the service data directory and has the appropriate permissions. The expected inputs are standard command-line interactions, including entering a username, email, and passwords during the createsuperuser process. Paperless-ng must be started at least once for the management script to exist.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2111.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd /var/lib/paperless\n$ su paperless -s /bin/sh\n$ ./paperless-ng-manage document_index reindex\n# if not already done create a user account, paperless-ng requires a login\n$ ./paperless-ng-manage createsuperuser\nUsername (leave blank to use 'paperless'): my-user-name\nEmail address: me@example.com\nPassword: **********\nPassword (again): **********\nSuperuser created successfully.\n```\n\n----------------------------------------\n\nTITLE: Listing All User Sessions - loginctl - ShellSession\nDESCRIPTION: This snippet demonstrates running the loginctl command to list all currently active user sessions managed by systemd. The output includes session IDs, user IDs, usernames, and associated seats. This command requires systemd to be actively managing the system and is typically run from a shell with sufficient privileges. Input: None. Output: Tabular session listing; no session is modified.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/user-sessions.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ loginctl\n   SESSION        UID USER             SEAT\n        c1        500 eelco            seat0\n        c3          0 root             seat0\n        c4        500 alice\n```\n\n----------------------------------------\n\nTITLE: Enabling Jottacloud CLI Service - NixOS - Nix\nDESCRIPTION: This Nix code snippet demonstrates the fastest way to enable the jotta-cli user service on a NixOS system. By setting 'services.jotta-cli.enable' to true, it will ensure that jotta-cli is installed in 'environment.systemPackages' and the user service 'jottad' is automatically started with default parameters. No additional configuration is required. The only dependency is a NixOS installation with the 'jotta-cli' package available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/jotta-cli.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.jotta-cli.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring systemd-repart Images - NixOS Module - Nix\nDESCRIPTION: Demonstrates how to configure the image.repart option in a NixOS module to build a disk image using systemd-repart. Partitions for ESP and root are defined, each specifying contents, store paths, and repartConfig parameters. Requires the image/repart.nix module, and the primary inputs are configuration attributes controlling partition layout and image properties.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-images-via-systemd-repart.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, modulesPath, ... }: {\n\n  imports = [ \"${modulesPath}/image/repart.nix\" ];\n\n  image.repart = {\n    name = \"image\";\n    partitions = {\n      \"esp\" = {\n        contents = {\n          # ...\n        };\n        repartConfig = {\n          Type = \"esp\";\n          # ...\n        };\n      };\n      \"root\" = {\n        storePaths = [ config.system.build.toplevel ];\n        repartConfig = {\n          Type = \"root\";\n          Label = \"nixos\";\n          # ...\n        };\n      };\n    };\n  };\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Pingvin Share with Nginx Reverse Proxy on NixOS - Nix\nDESCRIPTION: This NixOS module configuration shows how to enable Pingvin Share behind an nginx reverse proxy, configuring a custom hostname and enabling HTTPS for secure access. By enabling 'nginx' through 'nginx.enable', it integrates Pingvin Share with Nginx and expects proper SSL configuration for secure connections. Dependencies: The NixOS 'services-pingvin-share' and 'nginx' modules must be available. Inputs include 'hostname', 'https', and nginx-related options. Intended for inclusion in /etc/nixos/configuration.nix or similar configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pingvin-share.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services-pingvin-share = {\n    enable = true;\n\n    hostname = \"pingvin-share.domain.tld\";\n    https = true;\n\n    nginx.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Switching MPI Implementation to MPICH\nDESCRIPTION: This overlay demonstrates how to change the default MPI implementation in Nixpkgs from Open MPI to MPICH.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nself: super:\n\n{\n  mpi = self.mpich;\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Installed Azure CLI Extensions - Shell\nDESCRIPTION: This shell command executes the Azure CLI executable resulting from the build, listing all installed extensions. It should be run from the output path ('./result/bin/az') generated by the Nix build. The command outputs extension information in JSON format, enabling verification of proper extension installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n./result/bin/az extension list\n```\n\n----------------------------------------\n\nTITLE: Configuring Neovim-Qt with Custom Settings in Nix\nDESCRIPTION: This snippet shows how to configure Neovim-Qt, a graphical Neovim editor, with custom settings by overriding Neovim in an overlay or passing an overridden Neovim configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/neovim.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nneovim-qt.override {\n  neovim = neovim.override {\n    configure = {\n      customRC = ''\n        # your custom configuration\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Ninja Build System in NixOS\nDESCRIPTION: This snippet describes how Ninja overrides the default build, install, and check phases in NixOS. It mentions options to disable this behavior using 'dontUseNinjaBuild', 'dontUseNinjaInstall', and 'dontUseNinjaCheck'. It also notes that parallel building is enabled by default in Ninja and that Meson's setup hook takes precedence for install and check phases if active.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/ninja.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n# ninja {#ninja}\n\nOverrides the build, install, and check phase to run ninja instead of make. You can disable this behavior with the `dontUseNinjaBuild`, `dontUseNinjaInstall`, and `dontUseNinjaCheck`, respectively. Parallel building is enabled by default in Ninja.\n\nNote that if the [Meson setup hook](#meson) is also active, Ninja's install and check phases will be disabled in favor of Meson's.\n```\n\n----------------------------------------\n\nTITLE: Switching to a Different NixOS Channel\nDESCRIPTION: This command demonstrates how to switch to a different NixOS channel, using the NixOS 24.11 stable channel as an example.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nix-channel --add https://channels.nixos.org/nixos-24.11 nixos\n```\n\n----------------------------------------\n\nTITLE: Configuring Taskserver with Declarative NixOS Services (ShellSession)\nDESCRIPTION: This snippet demonstrates how to configure the NixOS taskserver module declaratively. The configuration enables Taskserver, sets the server's FQDN and listening address, and creates an organization ('my-company') with a single user ('alice'). This is intended to be used in a NixOS configuration file (e.g., configuration.nix), and requires the NixOS module for Taskserver to be available. Inputs are the attribute sets for Taskserver configuration; outputs are an initialized Taskserver on the NixOS host as per the specification. The snippet assumes administrative access and applies only to NixOS environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/taskserver/default.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n{\n  services.taskserver.enable = true;\n  services.taskserver.fqdn = \"server\";\n  services.taskserver.listenHost = \"::\";\n  services.taskserver.organisations.my-company.users = [ \"alice\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Tailscale Routing Features Toggle - NixOS Service Option - Markdown\nDESCRIPTION: This describes the introduction of the services.tailscale.useRoutingFeatures option. It lets administrators configure Tailscale to act as an exit node, use exit nodes, or serve as a subnet router. Removing RPF strictness is handled automatically based on configuration. It requires the Tailscale service and correct role settings for the network endpoints.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_18\n\nLANGUAGE: markdown\nCODE:\n```\n- The new option \\`services.tailscale.useRoutingFeatures\\` controls various settings for using Tailscale features like exit nodes and subnet routers. If you wish to use your machine as an exit node, you can set this setting to \\`server\\`, otherwise if you wish to use an exit node you can set this setting to \\`client\\`. The strict RPF warning has been removed as the RPF will be loosened automatically based on the value of this setting.\n```\n\n----------------------------------------\n\nTITLE: Verifying Docker Image Archive Structure - Shell\nDESCRIPTION: This shell command uses `tar -tvf` with exclusions to list the top-level structure of the exported Docker image archive. It verifies the contents of the produced tarball, confirming directory layouts and symbolic links (such as `/bin/hello`). The command excludes certain paths to focus output and expects the specified tar file to exist. The output demonstrates file permissions, ownership, and structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ tar --exclude '*/share/*' --exclude 'nix/store/*/*' -tvf /nix/store/x6a5m7c6zdpqz1d8j7cnzpx9glzzvd2h-hello\ndrwxr-xr-x root/0            0 1979-12-31 16:00 ./\ndrwxr-xr-x root/0            0 1979-12-31 16:00 ./bin/\nlrwxrwxrwx root/0            0 1979-12-31 16:00 ./bin/hello -> /nix/store/h92a9jd0lhhniv2q417hpwszd4jhys7q-hello-2.12.1/bin/hello\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/05zbwhz8a7i2v79r9j21pl6m6cj0xi8k-libunistring-1.1/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/ayg5rhjhi9ic73hqw33mjqjxwv59ndym-xgcc-13.2.0-libgcc/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/h92a9jd0lhhniv2q417hpwszd4jhys7q-hello-2.12.1/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/m59xdgkgnjbk8kk6k6vbxmqnf82mk9s0-libidn2-2.3.4/\ndr-xr-xr-x root/0            0 1979-12-31 16:00 ./nix/store/p3jshbwxiwifm1py0yq544fmdyy98j8a-glibc-2.38-27/\ndrwxr-xr-x root/0            0 1979-12-31 16:00 ./share/\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Shell Package with resholve.mkDerivation in Nix\nDESCRIPTION: Example of packaging the dgoss tool using resholve.mkDerivation. This demonstrates how to properly declare dependencies for shell scripts within a Nix package, resolving external command references and setting the proper interpreter.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/misc/resholve/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ lib\n, fetchFromGitHub\n, resholve\n, bash\n, coreutils\n, goss\n, which\n}:\n\nresholve.mkDerivation rec {\n  pname = \"dgoss\";\n  version = \"0.4.2\";\n\n  src = fetchFromGitHub {\n    owner = \"goss-org\";\n    repo = \"goss\";\n    rev = \"refs/tags/v${version}\";\n    hash = \"sha256-FDn1OETkYIpMenk8QAAHvfNZcSzqGl5xrD0fAZPVmRM=\";\n  };\n\n  dontConfigure = true;\n  dontBuild = true;\n\n  installPhase = ''\n    sed -i '2i GOSS_PATH=${goss}/bin/goss' extras/dgoss/dgoss\n    install -D extras/dgoss/dgoss $out/bin/dgoss\n  '';\n\n  solutions = {\n    default = {\n      scripts = [ \"bin/dgoss\" ];\n      interpreter = \"${bash}/bin/bash\";\n      inputs = [ coreutils which ];\n      keep = {\n        \"$CONTAINER_RUNTIME\" = true;\n      };\n    };\n  };\n\n  meta = with lib; {\n    homepage = \"https://github.com/goss-org/goss/blob/v${version}/extras/dgoss/README.md\";\n    changelog = \"https://github.com/goss-org/goss/releases/tag/v${version}\";\n    description = \"Convenience wrapper around goss that aims to bring the simplicity of goss to docker containers\";\n    license = licenses.asl20;\n    platforms = platforms.linux;\n    maintainers = with maintainers; [ hyzual anthonyroussel ];\n    mainProgram = \"dgoss\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing root privileges in NixOS installer\nDESCRIPTION: Command to switch to root user in the NixOS installer environment. The 'nixos' user has an empty password, allowing sudo without a password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo -i\n```\n\n----------------------------------------\n\nTITLE: Package Attribute Override in NixOS\nDESCRIPTION: Demonstration of using overrideAttrs to modify package attributes like source code and name, showing an Emacs customization example.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/customizing-packages.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    (pkgs.emacs.overrideAttrs (oldAttrs: {\n      name = \"emacs-25.0-pre\";\n      src = /path/to/my/emacs/tree;\n    }))\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building the pyfftw Package with FFTW Library Variants - Nix\nDESCRIPTION: This snippet illustrates packaging pyfftw, a Python wrapper for FFTW, using buildPythonPackage in Nix. It highlights integration with multiple FFTW library variants (single, double, long-double) as buildInputs and configures LDFLAGS and CFLAGS for proper library and include paths. Prerequisites are multiple FFTW packages, numpy, scipy, setuptools, and environment support in nixpkgs. Tests are disabled (doCheck = false) due to incompatibility in the test environment, but import checks are specified. The output is a derivation configured to build against all FFTW variants, ensuring correct linking and compilation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_31\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildPythonPackage,\n  fetchPypi,\n\n  # build dependencies\n  setuptools,\n\n  # dependencies\n  fftw,\n  fftwFloat,\n  fftwLongDouble,\n  numpy,\n  scipy,\n}:\n\nbuildPythonPackage rec {\n  pname = \"pyfftw\";\n  version = \"0.9.2\";\n  pyproject = true;\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-9ru2r6kwhUCaskiFoaPNuJCfCVoUL01J40byvRt4kHQ=\";\n  };\n\n  build-system = [\n    setuptools\n  ];\n\n  buildInputs = [\n    fftw\n    fftwFloat\n    fftwLongDouble\n  ];\n\n  dependencies = [\n    numpy\n    scipy\n  ];\n\n  preConfigure = ''\n    export LDFLAGS=\"-L${fftw.dev}/lib -L${fftwFloat.out}/lib -L${fftwLongDouble.out}/lib\"\n    export CFLAGS=\"-I${fftw.dev}/include -I${fftwFloat.dev}/include -I${fftwLongDouble.dev}/include\"\n  '';\n\n  # Tests cannot import pyfftw. pyfftw works fine though.\n  doCheck = false;\n\n  pythonImportsCheck = [ \"pyfftw\" ];\n\n  meta = {\n    changelog = \"https://github.com/pyFFTW/pyFFTW/releases/tag/v${version}\";\n    description = \"Pythonic wrapper around FFTW, the FFT library, presenting a unified interface for all the supported transforms\";\n    homepage = \"http://hgomersall.github.com/pyFFTW\";\n    license = with lib.licenses; [\n      bsd2\n      bsd3\n    ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Selecting a Display Manager in NixOS - Nix\nDESCRIPTION: These lines demonstrate how to enable alternative display managers (sddm or gdm) by setting their enable attributes to true. It overrides the default LightDM configuration in NixOS, allowing enhanced management and graphical login customization. Only one display manager should be enabled at a time for correct behavior.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.displayManager.sddm.enable = true;\n  services.xserver.displayManager.gdm.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Idris with Library Support\nDESCRIPTION: Commands to start Idris with specific libraries using the -p flag to make libraries available at runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p 'idrisPackages.with-packages (with idrisPackages; [ contrib pruviloj ])'\n[nix-shell:~]$ idris -p contrib -p pruviloj\n```\n\n----------------------------------------\n\nTITLE: Enabling Emacs systemd User Service - NixOS - Nix\nDESCRIPTION: This Nix configuration enables the Emacs daemon as a systemd user service by setting 'services.emacs.enable = true' in configuration.nix. Optionally, a custom Emacs package can be set with services.emacs.package. Requires NixOS and that systemd is configured for user services. Output is the activation of the Emacs daemon across user sessions after nixos-rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.emacs.enable = true;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting JAVA_HOME in Wrapped Scripts (Bash)\nDESCRIPTION: Shows how to inject the JAVA_HOME variable into wrapper scripts using the --set argument to makeWrapper. Input: path to the JDK's home attribute. Output: a script with JAVA_HOME set at runtime, facilitating use by builds or tools that expect this environment variable. Requires makeWrapper and a JDK with a passthru home property.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n--set JAVA_HOME ${jdk.home}\n```\n\n----------------------------------------\n\nTITLE: Using unittestCheckHook for Python unittest Testing\nDESCRIPTION: Demonstrates how to use unittestCheckHook to run Python's unittest discovery. This hook configures the checkPhase to use unittest's built-in test discovery mechanism.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_40\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeCheckInputs = [\n    unittestCheckHook\n  ];\n\n  unittestFlags = [\n    \"-s\"\n    \"tests\"\n    \"-v\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging a Haskell Project with Nixpkgs CallPackage (Nix)\nDESCRIPTION: This Nix expression defines how to import the nixpkgs infrastructure and use callPackage to package a Haskell project generated by cabal2nix. It provides a default.nix entry point for building and developing the project with Nix. Dependencies: Nix, access to the nixpkgs, and a generated my-project.nix file. Inputs: optional Nixpkgs attribute; Output: derivation for the project.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n# Retrieve nixpkgs impurely from NIX_PATH for now, you can pin it instead, of course.\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\n# use the nixpkgs default haskell package set\npkgs.haskellPackages.callPackage ./my-project.nix { }\n```\n\n----------------------------------------\n\nTITLE: Adding Root Partition on GPT Disk Using parted (ShellSession)\nDESCRIPTION: Creates a root partition of type 'ext4', starting at 512MB and ending 8GB before the disk end, on /dev/sda using 'parted'. Requires a device with a GPT table. The partition will fill the disk except for reserved space at the start (for boot) and end (for swap). Parameters specify label, filesystem type, starting, and ending locations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mkpart root ext4 512MB -8GB\n```\n\n----------------------------------------\n\nTITLE: Assembling TeX Live Packages in an Environment - Nix - nix\nDESCRIPTION: Demonstrates using the experimental withPackages interface to build a TeX Live environment from individual packages, specifying them in a function that has access to all package sets. This approach requires embedding packages inside the environment function and does not allow referencing standalone packages directly. The code also illustrates how to include the Korean language collection and some common LaTeX packages. Dependencies: Nixpkgs, texliveSmall.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ntexliveSmall.withPackages (\n  ps: with ps; [\n    collection-langkorean\n    algorithms\n    cm-super\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Querying Dotnet SDK and Runtime Environment Details (ShellSession)\nDESCRIPTION: This shell session output demonstrates the use of 'dotnet --info' to inspect the SDK and runtime environment within a Nix-provided Dotnet setup. It displays installed SDK and runtime versions, environment variables, architecture, and project configuration details. This command requires that the Dotnet CLI is available in the environment. The outputs assist in environment verification and troubleshooting, and are read-only as no values are modified.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ dotnet --info\n.NET SDK:\n Version:           9.0.100\n Commit:            59db016f11\n Workload version:  9.0.100-manifests.3068a692\n MSBuild version:   17.12.7+5b8665660\n\nRuntime Environment:\n OS Name:     nixos\n OS Version:  25.05\n OS Platform: Linux\n RID:         linux-x64\n Base Path:   /nix/store/a03c70i7x6rjdr6vikczsp5ck3v6rixh-dotnet-sdk-9.0.100/share/dotnet/sdk/9.0.100/\n\n.NET workloads installed:\nThere are no installed workloads to display.\nConfigured to use loose manifests when installing new manifests.\n\nHost:\n  Version:      9.0.0\n  Architecture: x64\n  Commit:       9d5a6a9aa4\n\n.NET SDKs installed:\n  8.0.404 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/sdk]\n  9.0.100 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/sdk]\n\n.NET runtimes installed:\n  Microsoft.AspNetCore.App 8.0.11 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/shared/Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 9.0.0 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/shared/Microsoft.AspNetCore.App]\n  Microsoft.NETCore.App 8.0.11 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/shared/Microsoft.NETCore.App]\n  Microsoft.NETCore.App 9.0.0 [/nix/store/6wlrjiy10wg766490dcmp6x64zb1vc8j-dotnet-core-combined/share/dotnet/shared/Microsoft.NETCore.App]\n\nOther architectures found:\n  None\n\nEnvironment variables:\n  Not set\n\nglobal.json file:\n  Not found\n\nLearn more:\n  https://aka.ms/dotnet/info\n\nDownload .NET:\n  https://aka.ms/dotnet/download\n```\n\n----------------------------------------\n\nTITLE: Filtering Critical Journal Entries Since Last Reboot in NixOS\nDESCRIPTION: This command shows all journal entries since the last reboot that have at least a 'critical' severity level. It demonstrates how to combine time-based filtering (-b for 'since boot') with severity-level filtering (-p crit for 'critical and above').\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/logging.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ journalctl -b -p crit\nDec 17 21:08:06 mandark sudo[3673]: pam_unix(sudo:auth): auth could not identify password for [alice]\nDec 29 01:30:22 mandark kernel[6131]: [1053513.909444] CPU6: Core temperature above threshold, cpu clock throttled (total events = 1)\n```\n\n----------------------------------------\n\nTITLE: Checking DRI Device Permissions with getfacl for Troubleshooting (ShellSession)\nDESCRIPTION: Illustrates how to use getfacl to inspect permissions of a DRI device node for user access troubleshooting. Input is a DRI device node path (e.g., /dev/dri/card0). Output includes ownership and ACLs for the device, important for debugging GPU access issues.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ getfacl /dev/dri/card0\n# file: dev/dri/card0\n# owner: root\n# group: video\nuser::rw-\nuser:alice:rw-\ngroup::rw-\nmask::rw-\nother::---\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Text File with writeText in Nix\nDESCRIPTION: This example shows how to use the writeText function to create a simple text file in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nwriteText \"my-file\" ''\n  Contents of File\n''\n```\n\n----------------------------------------\n\nTITLE: Defining Python Environment in shell.nix - Nix Expression - Nix\nDESCRIPTION: Nix expression for shell.nix creates an environment with Python 3.12 and selected packages (numpy, toolz). Uses withPackages function to pass desired dependencies and prepares an environment object. Enables easy sharing and reproduction of development environments across teams or CI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n(python312.withPackages (\n  ps: with ps; [\n    numpy\n    toolz\n  ]\n)).env\n```\n\n----------------------------------------\n\nTITLE: Generating a Nix Expression from a Cabal File using cabal2nix (Console)\nDESCRIPTION: This snippet demonstrates generating a Nix build expression from an existing Cabal project using cabal2nix. It allows transforming a Haskell project's cabal file into a corresponding Nix expression for use with Nixpkgs. The command requires cabal2nix to be installed and a valid .cabal file present. Input: path to Haskell project root; Output: a .nix file representing the project derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ ls\nmy-project.cabal src …\n$ cabal2nix ./. > my-project.nix\n```\n\n----------------------------------------\n\nTITLE: Configuring Longhorn Storage Dependencies in NixOS\nDESCRIPTION: NixOS system configuration to enable required dependencies for Longhorn storage, including NFS utilities and iSCSI support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nenvironment.systemPackages = [ pkgs.nfs-utils ];\nservices.openiscsi = {\n  enable = true;\n  name = \"${config.networking.hostName}-initiatorhost\";\n};\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image with extraCommands Option using Nix dockerTools (nix)\nDESCRIPTION: This Nix expression builds a Docker image using the extraCommands attribute to set up directories and files. The extraCommands script runs in the image root but cannot reference absolute paths (e.g., no `/` prefix), so paths are relative. The example creates 'data' and writes 'my-file'; on image boot, /bin/hello is executed in /data. Prerequisites: dockerTools, buildEnv, hello.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  buildEnv,\n  hello,\n}:\ndockerTools.buildImage {\n  name = \"hello\";\n  tag = \"latest\";\n\n  copyToRoot = buildEnv {\n    name = \"image-root\";\n    paths = [ hello ];\n    pathsToLink = [ \"/bin\" ];\n  };\n\n  extraCommands = ''\n    mkdir -p data\n    echo \"some content\" > my-file\n  '';\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n    WorkingDir = \"/data\";\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing PostgreSQL Data Directory - NixOS Module - Nix\nDESCRIPTION: Sets a custom data directory for the PostgreSQL service in NixOS through configuration.nix, allowing database storage to be relocated from the default path. Requires NixOS, a properly mounted and permissioned directory. The key parameter is services.postgresql.dataDir, which should reference a valid directory path. The result is that PostgreSQL stores its database clusters in the specified directory. Ensure correct filesystem permissions and backup strategies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.dataDir = \"/data/postgresql\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Intel iHD VA-API Driver in NixOS Hardware Configuration (nix)\nDESCRIPTION: Configures Intel's modern VA-API (iHD) driver by including intel-media-driver in hardware.graphics.extraPackages. Intended for recent Intel GPUs. The configuration enables automatic detection and use of the iHD driver for hardware video acceleration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.extraPackages = [\n    intel-media-driver\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced Jitsi Meet Options - NixOS Module - Nix\nDESCRIPTION: This snippet extends the Jitsi Meet NixOS module configuration to include advanced options, such as enabling prosody lockdown for limiting XMPP server features, customizing Jitsi Meet configuration values (e.g., default language, welcome page, prejoin page), and adjusting interface presentation settings (e.g., watermark visibility). The configuration retains required network and certificate parameters and expects administrators to tune boolean and string values per site needs. Dependencies include the Jitsi Meet and Jitsi Videobridge NixOS modules and ACME configuration. Inputs are nested attribute sets for service customization; output is a tailored and secure Jitsi Meet deployment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/jitsi-meet.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.jitsi-meet = {\n    enable = true;\n    hostName = \"jitsi.example.com\";\n    prosody.lockdown = true;\n    config = {\n      enableWelcomePage = false;\n      prejoinPageEnabled = true;\n      defaultLang = \"fi\";\n    };\n    interfaceConfig = {\n      SHOW_JITSI_WATERMARK = false;\n      SHOW_WATERMARK_FOR_GUESTS = false;\n    };\n  };\n  services.jitsi-videobridge.openFirewall = true;\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  security.acme.email = \"me@example.com\";\n  security.acme.acceptTerms = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OpenCL Installation with clinfo Command (ShellSession)\nDESCRIPTION: Demonstrates using the clinfo command, piped to head, to quickly display information about OpenCL platforms and devices detected by the loader. Requires the clinfo package to be installed and OpenCL drivers set up. Input: no arguments (just runs clinfo). Output: summarized platform information to standard output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ clinfo | head -n3\nNumber of platforms  1\nPlatform Name        AMD Accelerated Parallel Processing\nPlatform Vendor      Advanced Micro Devices, Inc.\n```\n\n----------------------------------------\n\nTITLE: Creating Pleroma Admin User\nDESCRIPTION: Command to create an administrator user in Pleroma with both admin and moderator privileges using the pleroma_ctl utility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ pleroma_ctl user new <nickname> <email>  --admin --moderator --password <password>\n```\n\n----------------------------------------\n\nTITLE: Configuring Akkoma for Pleroma Data Reuse - Nix\nDESCRIPTION: This snippet shows how to configure the Akkoma service module in NixOS to point to an existing Pleroma PostgreSQL database and upload directory, effectively reusing Pleroma data in a seamless migration. It updates composite configuration attributes for 'database' and 'upload_dir' using paths specific to the Pleroma setup. No additional dependencies are required, but the configuration should match the actual database and upload paths used by Pleroma. Input: configuration settings (database name and upload directory path); Output: Akkoma service uses Pleroma data. Limitations: After Akkoma is started, any migrations must be rolled back before returning to Pleroma.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Adjust these settings according to the database name and upload directory path used by Pleroma\n  services.akkoma.config.\":pleroma\".\"Pleroma.Repo\".database = \"pleroma\";\n  services.akkoma.config.\":pleroma\".\":instance\".upload_dir = \"/var/lib/pleroma/uploads\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom TeX Package Derivation and Testing Compilation - Nix - nix\nDESCRIPTION: Defines a verbose example of a custom TeX package (foiltex) as a Nix derivation with multiple outputs, custom build and install phases, and TeX/LaTeX rebuild from sources. Demonstrates downloading sources, preparing inputs, building style and docs, installing files in TDS layout, and packaging as a dependency for use with texliveSmall. The snippet also shows how to test the resulting package via runCommand generating a test PDF document. Requirements: `stdenvNoCC`, `texliveSmall`, multiple builting tools, understanding of Nix build phases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  foiltex = stdenvNoCC.mkDerivation {\n    pname = \"latex-foiltex\";\n    version = \"2.1.4b\";\n\n    outputs = [\n      \"tex\"\n      \"texdoc\"\n    ];\n    passthru.tlDeps = with texlive; [ latex ];\n\n    srcs = [\n      (fetchurl {\n        url = \"http://mirrors.ctan.org/macros/latex/contrib/foiltex/foiltex.dtx\";\n        hash = \"sha256-/2I2xHXpZi0S988uFsGuPV6hhMw8e0U5m/P8myf42R0=\";\n      })\n      (fetchurl {\n        url = \"http://mirrors.ctan.org/macros/latex/contrib/foiltex/foiltex.ins\";\n        hash = \"sha256-KTm3pkd+Cpu0nSE2WfsNEa56PeXBaNfx/sOO2Vv0kyc=\";\n      })\n    ];\n\n    unpackPhase = ''\n      runHook preUnpack\n\n      for _src in $srcs; do\n        cp \"$__src\" $(stripHash \"$__src\")\n      done\n\n      runHook postUnpack\n    '';\n\n    nativeBuildInputs = [\n      (texliveSmall.withPackages (\n        ps: with ps; [\n          cm-super\n          hypdoc\n          latexmk\n        ]\n      ))\n      # multiple-outputs.sh fails if $out is not defined\n      (writeShellScript \"force-tex-output.sh\" ''\n        out=\"''${tex-}\"\n      '')\n      writableTmpDirAsHomeHook # Need a writable $HOME for latexmk\n    ];\n\n    dontConfigure = true;\n\n    buildPhase = ''\n      runHook preBuild\n\n      # Generate the style files\n      latex foiltex.ins\n\n      # Generate the documentation\n      latexmk -pdf foiltex.dtx\n\n      runHook postBuild\n    '';\n\n    installPhase = ''\n      runHook preInstall\n\n      path=\"$tex/tex/latex/foiltex\"\n      mkdir -p \"$path\"\n      cp *.{cls,def,clo,sty} \"$path/\"\n\n      path=\"$texdoc/doc/tex/latex/foiltex\"\n      mkdir -p \"$path\"\n      cp *.pdf \"$path/\"\n\n      runHook postInstall\n    '';\n\n    meta = {\n      description = \"LaTeX2e class for overhead transparencies\";\n      license = lib.licenses.unfreeRedistributable;\n      maintainers = with lib.maintainers; [ veprbl ];\n      platforms = lib.platforms.all;\n    };\n  };\n\n  latex_with_foiltex = texliveSmall.withPackages (_: [ foiltex ]);\nin\nrunCommand \"test.pdf\"\n  {\n    nativeBuildInputs = [ latex_with_foiltex ];\n  }\n  ''\n    cat >test.tex <<EOF\n    \\documentclass{foils}\n\n    \\title{Presentation title}\n    \\date{}\n\n    \\begin{document}\n    \\maketitle\n    \\end{document}\n    EOF\n      pdflatex test.tex\n      cp test.pdf $out\n  ''\n```\n\n----------------------------------------\n\nTITLE: Isolating Android Platform Tools Package - Nix\nDESCRIPTION: Shows how to use a Nix expression to deploy only the Android platform-tools package using a custom Android composition. By referencing 'androidComposition.platform-tools', the resulting environment includes just the command line platform tools, minimizing disk usage. This snippet is suitable for lightweight builds or CI environments needing only adb or fastboot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  androidComposition = androidenv.composeAndroidPackages {\n    # ...\n  };\nin\nandroidComposition.platform-tools\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Module to Replace an Existing NixOS Module in Nix\nDESCRIPTION: Shows how to define a custom replacement module that disables the original (manpages) module by referencing its path in disabledModules, and re-implements or augments configuration options such as programs.man.enable. This snippet uses lib helper functions (mkIf, mkOption, types) and creates a custom config block that displays a warning for production deployments when the module is enabled. Dependencies include Nixpkgs lib, the Nix evaluation environment, and a NixOS module file configuration context. The replacement maintains or overrides the original option structure, allowing flexible deployment behaviors via warnings or other configuration changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/replace-modules.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n\nlet\n  inherit (lib) mkIf mkOption types;\n  cfg = config.programs.man;\nin\n\n{\n  disabledModules = [ \"services/programs/man.nix\" ];\n\n  options = {\n    programs.man.enable = mkOption {\n      type = types.bool;\n      default = true;\n      description = \"Whether to enable manual pages.\";\n    };\n  };\n\n  config = mkIf cfg.enabled {\n    warnings = [ \"disabled manpages for production deployments.\" ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Digital Bitbox Module - NixOS - Nix\nDESCRIPTION: This snippet demonstrates how to activate the Digital Bitbox module in a NixOS configuration by setting \"programs.digitalbitbox.enable\" to true. This enables the required services and rules for the device on the system. The only prerequisite is a NixOS system where module configuration is available; no parameters are needed besides the enablement flag.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/digitalbitbox/default.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.digitalbitbox.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating GPT Partition Table Using parted (ShellSession)\nDESCRIPTION: Initializes a new GPT partition table on the specified device (here, /dev/sda) using the 'parted' CLI tool. Requires 'parted' to be installed and executed as root. Input is the device path; output is a disk prepared to receive GPT partitions. No partitions are created at this stage; all data on the device will be lost.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mklabel gpt\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Downstream with HTTPS Protocol - Nix\nDESCRIPTION: This configuration sets up crab-hole with a downstream HTTPS protocol, enabling DNS-over-HTTPS. It is similar to TLS but includes an additional 'dns_hostname' parameter, and again requires certificate and key file paths. The service process must have file access rights. The config also allows setting a custom API timeout. Inputs are protocol, address, port, certificate, key, optional hostname, and timeout, producing a DNS-over-HTTPS endpoint.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.downstream = [\n    {\n      protocol = \"https\";\n      listen = \"[::]\";\n      port = 443;\n      certificate = ./dns.example.com.crt;\n      key = \"/dns.example.com.key\";\n      # optional\n      dns_hostname = \"dns.example.com\";\n      # optional (default = 3000)\n      timeout_ms = 3000;\n    }\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Shell Environment with Multiple Packages using python3.withPackages.env (Nix)\nDESCRIPTION: This example employs python3.withPackages with the env attribute in Nix to enter a developer shell containing numpy and requests for Python 3. It highlights providing packages via the ps argument and demonstrates environment instantiation with developer tooling. Requires compatible Nixpkgs and the python3.withPackages function. Useful for scenarios where an application shell needs multiple dependencies outside of build-time control.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(python3.withPackages (\n  ps: with ps; [\n    numpy\n    requests\n  ]\n)).env\n```\n\n----------------------------------------\n\nTITLE: Custom Grocy Settings Configuration in NixOS\nDESCRIPTION: Example configuration for customizing Grocy settings including currency, culture (language/locale), and calendar display options. These settings define the default appearance and behavior of the Grocy application.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/grocy.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  services.grocy.settings = {\n    # The default currency in the system for invoices etc.\n    # Please note that exchange rates aren't taken into account, this\n    # is just the setting for what's shown in the frontend.\n    currency = \"EUR\";\n\n    # The display language (and locale configuration) for grocy.\n    culture = \"de\";\n\n    calendar = {\n      # Whether or not to show the week-numbers\n      # in the calendar.\n      showWeekNumber = true;\n\n      # Index of the first day to be shown in the calendar (0=Sunday, 1=Monday,\n      # 2=Tuesday and so on).\n      firstDayOfWeek = 2;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Converting a Python Library to an Application using toPythonApplication in Nix\nDESCRIPTION: Illustrates the use of toPythonApplication to wrap an existing Python library derivation as a Nix application. This enables reuse of a library package's build logic for application deployment without duplication. The snippet expects a functional python3Packages set and a pre-existing library derivation, here referenced as python3Packages.youtube-dl. Output is an executable package suited for pkgs/by-name, abstracting module vs. application distinctions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  python3Packages,\n}:\n\npython3Packages.toPythonApplication python3Packages.youtube-dl\n```\n\n----------------------------------------\n\nTITLE: Building and Unpacking Docker Image Filesystem - Shell\nDESCRIPTION: This shell command builds the Nix package described previously and outputs the lines shown when the exported Docker image's layers are unpacked. It demonstrates how `nix-build` produces the .tar or .tar.gz file, as well as the unpacking process and the output path in the Nix store. No explicit parameters are set; the command expects a Nix derivation in the working directory. Output is illustrative and may vary between runs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\nUnpacking base image...\nFrom-image name or tag wasn't set. Reading the first ID.\nUnpacking layer 5731199219418f175d1580dbca05677e69144425b2d9ecb60f416cd57ca3ca42/layer.tar\ntar: Removing leading `/' from member names\nUnpacking layer e2897bf34bb78c4a65736510204282d9f7ca258ba048c183d665bd0f3d24c5ec/layer.tar\ntar: Removing leading `/' from member names\nUnpacking layer 420aa5876dca4128cd5256da7dea0948e30ef5971712f82601718cdb0a6b4cda/layer.tar\ntar: Removing leading `/' from member names\nUnpacking layer ea5f4e620e7906c8ecbc506b5e6f46420e68d4b842c3303260d5eb621b5942e5/layer.tar\ntar: Removing leading `/' from member names\nUnpacking layer 65807b9abe8ab753fa97da8fb74a21fcd4725cc51e1b679c7973c97acd47ebcf/layer.tar\ntar: Removing leading `/' from member names\nUnpacking layer b7da2076b60ebc0ea6824ef641978332b8ac908d47b2d07ff31b9cc362245605/layer.tar\nExecuting post-mount steps...\nPacking raw image...\n[    1.660036] reboot: Power down\n/nix/store/x6a5m7c6zdpqz1d8j7cnzpx9glzzvd2h-hello\n\n```\n\n----------------------------------------\n\nTITLE: Resulting Script after substituteAll Variable Interpolation\nDESCRIPTION: Illustrates the output of a file processed by substituteAll, showing all matched placeholders replaced with values from the Nix store or hardcoded strings. No additional transformation is performed on unchanged placeholders. Expected output is a fully inlined executable script ready for runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n#! /nix/store/s30jrpgav677fpc9yvkqsib70xfmx7xi-bash-5.2p26/bin/bash\n\necho @unchanged@\n/nix/store/566f5isbvw014h7knmzmxa5l6hshx43k-hello-2.12.1/bin/hello --greeting goodbye\n```\n\n----------------------------------------\n\nTITLE: Configuring Optional CUDA in Nix Derivation Expressions - Nix\nDESCRIPTION: This Nix snippet demonstrates how to define a derivation with optional CUDA support by parameterizing with 'cudaSupport' and 'cudaPackages'. It allows expression consumers to specify whether CUDA is enabled and to provide custom CUDA package sets, enhancing modularity and support for multiple CUDA versions. Expected input parameters include 'config' (build configuration), 'cudaSupport' (boolean, defaults to config), and 'cudaPackages' (an attribute set), with an empty output set. No external dependencies are required beyond standard Nixpkgs facilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config,\n  cudaSupport ? config.cudaSupport,\n  cudaPackages ? { },\n  ...\n}:\n{ }\n\n```\n\n----------------------------------------\n\nTITLE: Unmounting USB Device on macOS using diskutil - ShellSession\nDESCRIPTION: This snippet dismounts all partitions on a USB device on macOS in preparation for imaging. 'diskutil unmountDisk' unmounts all volumes on the device specified by 'diskX'. Device identifier is obtained using 'diskutil list'. This step prevents write conflicts with dd during the imaging process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-usb.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\ndiskutil unmountDisk diskX\n```\n\n----------------------------------------\n\nTITLE: Configuring uMurmur Mumble Server in NixOS\nDESCRIPTION: Basic configuration for enabling uMurmur, a minimalistic Mumble server. This snippet sets up the server port, configures root and lobby channels, sets access permissions, and opens the firewall for the specified port.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/umurmur.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.umurmur = {\n    enable = true;\n    openFirewall = true;\n    settings = {\n      port = 7365;\n      channels = [\n        {\n          name = \"root\";\n          parent = \"\";\n          description = \"Root channel. No entry.\";\n          noenter = true;\n        }\n        {\n          name = \"lobby\";\n          parent = \"root\";\n          description = \"Lobby channel\";\n        }\n      ];\n      default_channel = \"lobby\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Extra Nextcloud Apps using NixOS Module - Nix\nDESCRIPTION: This snippet demonstrates how to declaratively specify additional Nextcloud applications to be managed by NixOS using the services.nextcloud.extraApps option. The snippet uses the Nix expression language to inherit apps from the pre-defined set available in the Nextcloud package. The required dependencies are the NixOS configuration module, Nextcloud, and specified apps such as user_oidc, calendar, and contacts. Parameters include config, pkgs, and the extraApps list. Inputs are NixOS configuration overlays, and the output is an updated configuration that manages Nextcloud apps declaratively. Limitations: Once this option is used, apps can no longer be managed through the Nextcloud web interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/nextcloud.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }: {\n  services.nextcloud.extraApps = with config.services.nextcloud.package.packages.apps; [\n    inherit user_oidc calendar contacts;\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions in postStart as Superuser - NixOS systemd Service - Nix\nDESCRIPTION: Illustrates assigning extra PostgreSQL table and sequence permissions to a specific user by injecting SQL statements in the postStart phase of the postgresql systemd service. Utilizes lib.mkAfter to ensure actions occur after database and user creation. Requires access to $PSQL, proper service ordering, and privileges as the 'postgres' superuser. Inputs are SQL GRANT commands; output is additional privileges granted at service startup. Useful for legacy or complex migration cases but demands careful order management.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n  {\n    systemd.services.postgresql.postStart = lib.mkAfter ''\n      $PSQL service1 -c 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"extraUser1\"'\n      $PSQL service1 -c 'GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO \"extraUser1\"'\n      # ....\n    '';\n  }\n```\n\n----------------------------------------\n\nTITLE: Building the Android SDK via nix-build - Bash\nDESCRIPTION: Illustrates deploying the Android SDK and its components using the Nix build system. Running 'nix-build' at the shell invokes the previously defined Nix expressions to perform a reproducible build of the requested SDK derivation. Precondition: all referenced .nix files and attributes must be correctly defined and accessible.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-build\n```\n\n----------------------------------------\n\nTITLE: Building Octave Package with nix-build in Shell (ShellSession)\nDESCRIPTION: This shell command demonstrates how to use the nix-build tool to build the 'symbolic' Octave package from the available Nixpkgs attribute set. It requires Nix and an up-to-date checkout of the repo, with relevant permissions. The -A flag specifies the attribute path (octavePackages.symbolic), and the output will be a build artifact stored in the Nix store. No direct input parameters are necessary beyond the command-line argument, and the command returns a path to the built package or an error if it fails.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/octave.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A octavePackages.symbolic\n```\n\n----------------------------------------\n\nTITLE: Configuring c2FmZQ Server with Nginx Reverse Proxy – Nix\nDESCRIPTION: This Nix snippet configures both the c2FmZQ server and an Nginx reverse proxy. The c2FmZQ service is explicitly bound to localhost and port 8080, while Nginx is enabled with proxy settings, HTTPS via ACME, and forced SSL. A virtual host is defined for 'example.com', forwarding requests to the c2FmZQ backend. Key parameters include 'bindIP', 'port', and Nginx locations; expected input is the NixOS module options. Outputs are the running services. Dependencies include Nginx with ACME SSL certificate support and c2FmZQ installed. The configuration assumes that the domain and DNS setup are correct.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/c2fmzq-server.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  services.c2fmzq-server = {\\n    enable = true;\\n    bindIP = \\\"127.0.0.1\\\"; # default\\n    port = 8080; # default\\n  };\\n\\n  services.nginx = {\\n    enable = true;\\n    recommendedProxySettings = true;\\n    virtualHosts.\\\"example.com\\\" = {\\n      enableACME = true;\\n      forceSSL = true;\\n      locations.\\\"/\\\" = {\\n        proxyPass = \\\"http://127.0.0.1:8080\\\";\\n      };\\n    };\\n  };\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Infinite Recursion with Attribute Dependencies in Freeform Modules (Nix)\nDESCRIPTION: This example demonstrates a pitfall of NixOS freeform modules: defining a freeform attribute ('logLevel') to depend on another attribute of the same set ('settings.port') results in infinite recursion, as the associated attributes are not evaluated independently. The snippet advises declaring all interdependent attributes as proper options to avoid such evaluation cycles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/freeform-modules.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # This throws infinite recursion encountered\n  settings.logLevel = lib.mkIf (config.settings.port == 80) \"debug\";\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Version Requirement for Darwin\nDESCRIPTION: Demonstrates how to set the minimum macOS version requirement using darwinMinVersionHook.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\"; # Upstream specifies the minimum supported version as 12.5.\n  buildInputs = [ (darwinMinVersionHook \"12.5\") ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maven JAR Plugin Manifest\nDESCRIPTION: Maven plugin configuration to create a JAR with proper CLASSPATH manifest entries. Sets up repository-style classpath layout and main class declaration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_13\n\nLANGUAGE: xml\nCODE:\n```\n<build>\n  <plugins>\n    <plugin>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>../../repository/</classpathPrefix>\n                    <classpathLayoutType>repository</classpathLayoutType>\n                    <mainClass>Main</mainClass>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>.</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n  </plugins>\n</build>\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom XKB Layout in NixOS Configuration (Nix)\nDESCRIPTION: Adds the custom 'us-greek' XKB layout to the NixOS configuration using the services.xserver.xkb.extraLayouts attribute. The snippet specifies a description, language, and path to the custom symbols file. Inputs include a Nix attribute set, outputs are integrated configuration changes upon `nixos-rebuild`; ensure the file paths are correct.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.xkb.extraLayouts.us-greek = {\n    description = \"US layout with alt-gr greek\";\n    languages   = [ \"eng\" ];\n    symbolsFile = /yourpath/symbols/us-greek;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging a Simple Perl Module via buildPerlPackage - Nix\nDESCRIPTION: This Nix code declaratively packages a CPAN Perl module ('Class-C3') using buildPerlPackage. Dependencies are buildPerlPackage and fetchurl. Parameters include 'pname', 'version', and 'src' (fetched from CPAN mirrors). It requires a standard Makefile.PL and produces a Nix package derivation with the specified Perl module as output. This pattern is standard for most Perl modules in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  ClassC3 = buildPerlPackage rec {\n    pname = \"Class-C3\";\n    version = \"0.21\";\n    src = fetchurl {\n      url = \"mirror://cpan/authors/id/F/FL/FLORA/Class-C3-${version}.tar.gz\";\n      hash = \"sha256-/5GE5xHT0uYGOQxroqj6LMU7CtKn2s6vMVoSXxL4iK4=\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Options for All Anubis Instances - Nix\nDESCRIPTION: This snippet sets default options for all Anubis instances using the services.anubis.defaultOptions attribute. It specifies a custom bot policy and the DIFFICULTY setting, affecting the behavior of all managed Anubis instances unless explicitly overridden. Prerequisites include the Anubis module defined in the NixOS configuration. The input is a Nix attribute set, and the effect is modification of instance-wide defaults for the service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/anubis.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.anubis.defaultOptions = {\n    botPolicy = { dnsbl = false; };\n    settings.DIFFICULTY = 3;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Network Manager from Managing Container Interfaces in NixOS\nDESCRIPTION: This configuration explicitly prevents Network Manager from managing container network interfaces by adding them to the unmanaged list using a wildcard pattern.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/container-networking.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.networkmanager.unmanaged = [ \"interface-name:ve-*\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Enabling Kerberos Server Module in NixOS (Nix Expression)\nDESCRIPTION: This snippet demonstrates how to enable and configure the Kerberos server and client options in NixOS using the Nix expression language. It allows choosing between the MIT and Heimdal Kerberos implementations by setting the security.krb5.package option, and specifies server realm settings and access control lists. Dependencies include the Nixpkgs package set (pkgs.krb5 or pkgs.heimdal) and the NixOS configuration module infrastructure. Key parameters include the realm name, location of the KDC and admin server, and access control for the admin principal. Inputs are NixOS module options and server/client configuration attributes, and output is the declarative service configuration for deployment. The configuration assumes an existing NixOS environment and appropriate Kerberos packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/system/kerberos/kerberos-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.krb5 = {\n    # Here you can choose between the MIT and Heimdal implementations.\n    package = pkgs.krb5;\n    # package = pkgs.heimdal;\n\n    # Optionally set up a client on the same machine as the server\n    enable = true;\n    settings = {\n      libdefaults.default_realm = \"EXAMPLE.COM\";\n      realms.\"EXAMPLE.COM\" = {\n        kdc = \"kerberos.example.com\";\n        admin_server = \"kerberos.example.com\";\n      };\n    };\n  }\n\n  services.kerberos-server = {\n    enable = true;\n    settings = {\n      realms.\"EXAMPLE.COM\" = {\n        acl = [{ principal = \"adminuser\"; access=  [\"add\" \"cpw\"]; }];\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring vwifi Access Point (AP) Node with hostapd - NixOS - Nix\nDESCRIPTION: This NixOS configuration snippet makes a node behave as a wireless access point (AP) in infrastructure mode, using hostapd backed by a virtual Wi-Fi interface via vwifi. It sets a static IP, configures hostapd for WPA3-SAE authentication, and sets SSID and password parameters. Required dependencies include the NixOS vwifi and hostapd modules. Inputs cover interface assignment, Wi-Fi security protocols, and MAC prefix; outputs are an AP-active node ready for client association. Limitations may result from incomplete emulation or the underlying vwifi/hostapd capabilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-hardware-features.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nap =\n  { config, ... }:\n  {\n    networking.interfaces.eth1.ipv4.addresses = lib.mkForce [\n      {\n        address = \"192.168.1.3\";\n        prefixLength = 24;\n      }\n    ];\n    services.hostapd = {\n      enable = true;\n      radios.wlan0 = {\n        channel = 1;\n        networks.wlan0 = {\n          ssid = \"NixOS Test Wi-Fi Network\";\n          authentication = {\n            mode = \"wpa3-sae\";\n            saePasswords = [ { password = \"supersecret\"; } ];\n            enableRecommendedPairwiseCiphers = true;\n          };\n        };\n      };\n    };\n    services.vwifi = {\n      module = {\n        enable = true;\n        macPrefix = \"74:F8:F6:00:01\";\n      };\n      client = {\n        enable = true;\n        serverAddress = \"192.168.1.2\";\n      };\n    };\n  };\n```\n\n----------------------------------------\n\nTITLE: Enabling Incremental Builds for Haskell Packages in Nixpkgs (Nix)\nDESCRIPTION: This snippet demonstrates how to configure incremental builds for a Haskell package ('turtle') using Nix. It utilizes Nixpkgs' haskellPackages.mkDerivation along with overrideCabal to set up both a full build that outputs intermediate compilation artifacts and a subsequent incremental build that reuses those artifacts for faster compilation. Dependencies include a Nix environment with access to <nixpkgs>, and requires GHC version 9.4 or newer. Key parameters: doInstallIntermediates, enableSeparateIntermediatesOutput, and previousIntermediates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  inherit (pkgs) haskell;\n  inherit (haskell.lib.compose) overrideCabal;\n\n  # Incremental builds work with GHC >=9.4.\n  turtle = haskell.packages.ghc944.turtle;\n\n  # This will do a full build of `turtle`, while writing the intermediate build products\n  # (compiled modules, etc.) to the `intermediates` output.\n  turtle-full-build-with-incremental-output = overrideCabal (drv: {\n    doInstallIntermediates = true;\n    enableSeparateIntermediatesOutput = true;\n  }) turtle;\n\n  # This will do an incremental build of `turtle` by copying the previously\n  # compiled modules and intermediate build products into the source tree\n  # before running the build.\n  #\n  # GHC will then naturally pick up and reuse these products, making this build\n  # complete much more quickly than the previous one.\n  turtle-incremental-build = overrideCabal (drv: {\n    previousIntermediates = turtle-full-build-with-incremental-output.intermediates;\n  }) turtle;\nin\nturtle-incremental-build\n```\n\n----------------------------------------\n\nTITLE: Installing nix-generate-from-cpan Tool - ShellSession\nDESCRIPTION: This ShellSession snippet shows how to install the nix-generate-from-cpan tool from a Nix channel or clone. Requires a working Nix system and a nixpkgs path or channel. Takes the package attribute as input and installs it for the user. This tool automates generation of Nix expressions for CPAN Perl modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f \"<nixpkgs>\" -iA nix-generate-from-cpan\n```\n\n----------------------------------------\n\nTITLE: Creating a Full NixOS Installation Disk Image with UEFI using Nixpkgs (Nix)\nDESCRIPTION: This snippet illustrates how to generate a full-featured NixOS installation disk image with UEFI and a bootloader using the make-disk-image function. It leverages evalConfig for configuration composition and supplies parameters enabling bootloader installation, GPT partitions, EFI variable handling, and specifies the disk format (qcow2). Important dependencies include <nixpkgs/nixos/lib/eval-config.nix> and Nixpkgs itself. Expected input is a set of module configurations for NixOS, and the output is a bootable image ready for use in virtual machines with UEFI support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/makediskimage.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  lib = pkgs.lib;\n  make-disk-image = import <nixpkgs/nixos/lib/make-disk-image.nix>;\n  evalConfig = import <nixpkgs/nixos/lib/eval-config.nix>;\nin\nmake-disk-image {\n  inherit pkgs lib;\n  inherit\n    (evalConfig {\n      modules = [\n        {\n          fileSystems.\"/\" = {\n            device = \"/dev/vda\";\n            fsType = \"ext4\";\n            autoFormat = true;\n          };\n          boot.grub.device = \"/dev/vda\";\n        }\n      ];\n    })\n    config\n    ;\n  format = \"qcow2\";\n  onlyNixStore = false;\n  partitionTableType = \"legacy+gpt\";\n  installBootLoader = true;\n  touchEFIVars = true;\n  diskSize = \"auto\";\n  additionalSpace = \"0M\"; # Defaults to 512M.\n  copyChannel = false;\n  memSize = 2048; # Qemu VM memory size in megabytes. Defaults to 1024M.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring /etc as Read-Only with Overlay Filesystem\nDESCRIPTION: Sets the /etc overlay filesystem to be mounted as read-only (immutable) rather than the default writable mode. This prevents runtime modifications to /etc.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/etc-overlay.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.etc.overlay.mutable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Cabal Derivations in Nix\nDESCRIPTION: The base function for overriding Haskell packages in Nixpkgs. It takes a function and a derivation, applies the function to the derivation's arguments, and returns a recomputed version of the derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\noverrideCabal f drv\n```\n\n----------------------------------------\n\nTITLE: Building Configuration Without Applying - ShellSession\nDESCRIPTION: Runs 'nixos-rebuild build', which builds the configuration but does not apply, activate, or set it as boot default. Useful for syntax checking or building derivations only. Returns standard build output. Can be executed by any user with correct permissions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nixos-rebuild build\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic GNOME Wrapping for Python Application Build (Nix)\nDESCRIPTION: Provides a configuration for a Python application built with `buildPythonApplication` in Nix where automatic wrapping by `wrapGApps*` hooks is disabled via `dontWrapGApps = true`. Instead, arguments for `makeWrapper` are explicitly propagated using `makeWrapperArgs+=`, accommodating complex build environments or preventing double-wrapping. Dependencies include `wrapGAppsHook3`, `gobject-introspection`, and other GTK/Introspection dependencies. Inputs are Python app properties (`pname`, `version`), and the output is a Python package correctly wrapped for GNOME environment initialization. This approach is useful when buildPythonApplication does its own wrapping and manual coordination with other wrappers is needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gnome.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\npython3.pkgs.buildPythonApplication {\n  pname = \"gnome-music\";\n  version = \"3.32.2\";\n\n  nativeBuildInputs = [\n    wrapGAppsHook3\n    gobject-introspection\n    # ...\n  ];\n\n  dontWrapGApps = true;\n\n  # Arguments to be passed to `makeWrapper`, only used by buildPython*\n  preFixup = ''\n    makeWrapperArgs+=(\"''${gappsWrapperArgs[@]}\")\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building Wrapped Firefox with Extensions and Policies - Nix\nDESCRIPTION: This snippet demonstrates how to use the wrapFirefox function to create a custom Firefox build with pre-installed extensions, enterprise policies, and custom preferences in the Nix language. Dependencies include the firefox-esr-unwrapped package, wrapFirefox, fetchFirefoxAddon, and pkgs.p11-kit. Required parameters include nixExtensions (the add-on list), extraPolicies (enterprise-level controls), and extraPrefs (user.js style settings). The input is a Nix attribute set, and the output is a fully wrapped Firefox derivation. The configuration disables Firefox signature checks (handled securely with hash verification), and assumes proper package privileges and file access. Ensure that the name fields for add-ons are unique to avoid state conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/firefox.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Nix firefox addons only work with the firefox-esr package.\n  myFirefox = wrapFirefox firefox-esr-unwrapped {\n    nixExtensions = [\n      (fetchFirefoxAddon {\n        name = \"ublock\"; # Has to be unique!\n        url = \"https://addons.mozilla.org/firefox/downloads/file/3679754/ublock_origin-1.31.0-an+fx.xpi\";\n        hash = \"sha256-2e73AbmYZlZXCP5ptYVcFjQYdjDp4iPoEPEOSCVF5sA=\";\n      })\n    ];\n\n    extraPolicies = {\n      CaptivePortal = false;\n      DisableFirefoxStudies = true;\n      DisablePocket = true;\n      DisableTelemetry = true;\n      DisableFirefoxAccounts = true;\n      FirefoxHome = {\n        Pocket = false;\n        Snippets = false;\n      };\n      UserMessaging = {\n        ExtensionRecommendations = false;\n        SkipOnboarding = true;\n      };\n      SecurityDevices = {\n        # Use a proxy module rather than `nixpkgs.config.firefox.smartcardSupport = true`\n        \"PKCS#11 Proxy Module\" = \"${pkgs.p11-kit}/lib/p11-kit-proxy.so\";\n      };\n    };\n\n    extraPrefs = ''\n      // Show more ssl cert infos\n      lockPref(\"security.identityblock.show_extended_validation\", true);\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Python Script with Embedded nix-shell Shebang - Shell - Shell\nDESCRIPTION: Demonstrates direct execution of a Python script with an embedded nix-shell shebang, resulting in transparent environment setup. The script prints the dot product of two arrays, proving dependencies (numpy) were loaded by Nix. No preparatory environment setup is required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_20\n\nLANGUAGE: sh\nCODE:\n```\n$ ./foo.py\nThe dot product of [1 2] and [3 4] is: 11\n```\n\n----------------------------------------\n\nTITLE: Customizing Python Plugin with Extra Packages - WeeChat Nix Override - Nix\nDESCRIPTION: This Nix snippet customizes the WeeChat Python plugin by adding additional Python libraries (via 'withPackages'), for example to satisfy dependencies like 'pycrypto' and 'python-dbus' needed by certain WeeChat scripts. It overrides the 'plugins' list to include only a custom Python instance. Requires 'availablePlugins', Nix's standard python packages set, and existing dependencies in Nixpkgs. Returns a WeeChat build with the Python plugin pre-bundled with given packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nweechat.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      plugins = with availablePlugins; [\n        (python.withPackages (\n          ps: with ps; [\n            pycrypto\n            python-dbus\n          ]\n        ))\n      ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PHP with Extensions and Extra Settings in Nix\nDESCRIPTION: Shows how to use php.buildEnv to create a PHP package with specific extensions and additional php.ini configuration, such as setting memory_limit.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nphp.buildEnv {\n  extensions =\n    { all, ... }:\n    with all;\n    [\n      imagick\n      opcache\n    ];\n  extraConfig = \"memory_limit=256M\";\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Vim Plugins with Native Vim Packages in NixOS\nDESCRIPTION: Example demonstrating how to manage Vim plugins using the native Vim package system. It shows how to specify plugins that load at startup and plugins that load on demand.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nvim-full.customize {\n  vimrcConfig.packages.myVimPackage = with pkgs.vimPlugins; {\n    # loaded on launch\n    start = [\n      youcompleteme\n      fugitive\n    ];\n    # manually loadable by calling `:packadd $plugin-name`\n    # however, if a Vim plugin has a dependency that is not explicitly listed in\n    # opt that dependency will always be added to start to avoid confusion.\n    opt = [\n      phpCompletion\n      elm-vim\n    ];\n    # To automatically load a plugin when opening a filetype, add vimrc lines like:\n    # autocmd FileType php :packadd phpCompletion\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating signald Data - Bash Command\nDESCRIPTION: This snippet demonstrates how to run the signald migration process using command-line arguments before starting its service. The command specifies the data directory and the new SQLite database location, and invokes --migrate-data to perform data migration. Dependencies include having signald installed and system permissions to access /var/lib/signald/db. The expected input is the existing signald data; output is the migrated database in the specified location. This step may be a prerequisite for signald upgrades.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsignald -d /var/lib/signald/db \\\n  --database sqlite:/var/lib/signald/db \\\n  --migrate-data\n```\n\n----------------------------------------\n\nTITLE: Building and Linting nixos-rebuild-ng with nix-build - Console\nDESCRIPTION: This shell command demonstrates how to run the nix-build tool to build the nixos-rebuild-ng package along with its linter and test suite attributes. The command ensures a full build, runs unit tests, applies linters, and verifies code formatting. Requires Nix and a suitable flake or package definition supporting these attributes. Input: No direct parameters. Output: Build artifacts and test results as per your NixOS setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-rebuild-ng/README.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nnix-build -A nixos-rebuild-ng -A nixos-rebuild-ng.tests.linters\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Build Error from Format Hardening with GCC/Clang (C/C++ Compiler Output)\nDESCRIPTION: This snippet shows a compiler error triggered by passing a non-literal, unparameterized format string to printf when the 'format' hardening flag is enabled. No external dependencies are required beyond a GCC or Clang-based build system. The output demonstrates how improper format string usage, enforced by the '-Werror=format-security' flag, results in a build failure, and indicates that disabling the format hardening or fixing the format string is required. The input is C/C++ code with improper printf usage and the output is an error during compilation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_42\n\nLANGUAGE: text\nCODE:\n```\n/tmp/nix-build-zynaddsubfx-2.5.2.drv-0/zynaddsubfx-2.5.2/src/UI/guimain.cpp:571:28: error: format not a string literal and no format arguments [-Werror=format-security]\\n         printf(help_message);\\n                            ^\\ncc1plus: some warnings being treated as errors\n```\n\n----------------------------------------\n\nTITLE: Setting Up BorgBackup with BorgBase Hosting Service\nDESCRIPTION: Terminal commands to initialize a BorgBackup repository on the BorgBase hosting service. It generates an SSH key and initializes a new encrypted repository using the borg init command.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/backup/borgbackup.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo ssh-keygen -N '' -t ed25519 -f /run/keys/id_ed25519_borgbase\n\nsudo borg init --encryption=repokey-blake2  \\\n    --rsh \"ssh -i /run/keys/id_ed25519_borgbase\" \\\n    zzz2aaaaa@zzz2aaaaa.repo.borgbase.com:repo\n```\n\n----------------------------------------\n\nTITLE: Building an Appliance Image with Unified Kernel - NixOS System - Nix\nDESCRIPTION: Illustrates advanced appliance image configuration in NixOS using image/repart.nix, targeting self-contained systems. Includes custom GRUB bootloader handling, EFI boot partition setup, a unified kernel image deployment, and multiple partition configurations. Prerequisites are the nixpkgs set, an understanding of NixOS module imports, and knowledge of EFI architectures. Inputs reflect system toolchain, image module, and intended image outputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-images-via-systemd-repart.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  efiArch = pkgs.stdenv.hostPlatform.efiArch;\nin\n(pkgs.nixos [\n  ({ config, lib, pkgs, modulesPath, ... }: {\n\n    imports = [ \"${modulesPath}/image/repart.nix\" ];\n\n    boot.loader.grub.enable = false;\n\n    fileSystems.\"/\".device = \"/dev/disk/by-label/nixos\";\n\n    image.repart = {\n      name = \"image\";\n      partitions = {\n        \"esp\" = {\n          contents = {\n            \"/EFI/BOOT/BOOT${lib.toUpper efiArch}.EFI\".source =\n              \"${pkgs.systemd}/lib/systemd/boot/efi/systemd-boot${efiArch}.efi\";\n\n            \"/EFI/Linux/${config.system.boot.loader.ukiFile}\".source =\n              \"${config.system.build.uki}/${config.system.boot.loader.ukiFile}\";\n          };\n          repartConfig = {\n            Type = \"esp\";\n            Format = \"vfat\";\n            SizeMinBytes = \"96M\";\n          };\n        };\n        \"root\" = {\n          storePaths = [ config.system.build.toplevel ];\n          repartConfig = {\n            Type = \"root\";\n            Format = \"ext4\";\n            Label = \"nixos\";\n            Minimize = \"guess\";\n          };\n        };\n      };\n    };\n\n  })\n]).image\n\n```\n\n----------------------------------------\n\nTITLE: Creating Pleroma Secrets Configuration File\nDESCRIPTION: Example of a secrets configuration file for Pleroma containing sensitive information like database passwords and encryption keys. This file should be placed at the location specified in secretConfigFile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_5\n\nLANGUAGE: elixir\nCODE:\n```\n# Pleroma instance passwords\n\nimport Config\n\nconfig :pleroma, Pleroma.Web.Endpoint,\n   secret_key_base: \"<the secret generated by pleroma_ctl>\",\n   signing_salt: \"<the secret generated by pleroma_ctl>\"\n\nconfig :pleroma, Pleroma.Repo,\n  password: \"<the secret generated by pleroma_ctl>\"\n\n# Configure web push notifications\nconfig :web_push_encryption, :vapid_details,\n  public_key: \"<the secret generated by pleroma_ctl>\",\n  private_key: \"<the secret generated by pleroma_ctl>\"\n\n# ... TO CONTINUE ...\n```\n\n----------------------------------------\n\nTITLE: Rebooting the System with ShellSession and systemctl - ShellSession\nDESCRIPTION: This snippet shows how to reboot a NixOS system from a shell session using the 'reboot' command. This is equivalent to running 'systemctl reboot'. Prerequisites include necessary permissions to execute reboot operations. No parameters are required, and the output is a system reboot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rebooting.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# reboot\n```\n\n----------------------------------------\n\nTITLE: Docker Container Profile Section Header\nDESCRIPTION: Markdown section header defining the Docker container profile documentation with a section reference identifier.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/profiles/docker-container.section.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Docker Container {#sec-profile-docker-container}\n```\n\n----------------------------------------\n\nTITLE: Defining a Submodule Option (Nix)\nDESCRIPTION: Defines a single option 'mod' whose type is a submodule with two fields: an integer 'foo' and a string 'bar'. Requires access to 'mkOption' and 'types' utilities from the NixOS module system. Useful for encapsulating option schemas as submodules within modules, primarily accepting an attribute set value whose fields match the specified types.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options.mod = mkOption {\n    description = \"submodule example\";\n    type = with types; submodule {\n      options = {\n        foo = mkOption {\n          type = int;\n        };\n        bar = mkOption {\n          type = str;\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Prometheus Exporter Module for Postfix\nDESCRIPTION: This snippet shows the implementation of a Prometheus exporter module for Postfix, defining the default port, additional configuration options, and systemd service configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/prometheus/exporters.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n# nixpkgs/nixos/modules/services/prometheus/exporters/postfix.nix\n{ config, lib, pkgs, options }:\nlet\n  # for convenience we define cfg here\n  cfg = config.services.prometheus.exporters.postfix;\nin\n{\n  port = 9154; # The postfix exporter listens on this port by default\n\n  # `extraOpts` is an attribute set which contains additional options\n  # (and optional overrides for default options).\n  # Note that this attribute is optional.\n  extraOpts = {\n    telemetryPath = lib.mkOption {\n      type = lib.types.str;\n      default = \"/metrics\";\n      description = ''\n        Path under which to expose metrics.\n      '';\n    };\n    logfilePath = lib.mkOption {\n      type = lib.types.path;\n      default = /var/log/postfix_exporter_input.log;\n      example = /var/log/mail.log;\n      description = ''\n        Path where Postfix writes log entries.\n        This file will be truncated by this exporter!\n      '';\n    };\n    showqPath = lib.mkOption {\n      type = lib.types.path;\n      default = /var/spool/postfix/public/showq;\n      example = /var/lib/postfix/queue/public/showq;\n      description = ''\n        Path at which Postfix places its showq socket.\n      '';\n    };\n  };\n\n  # `serviceOpts` is an attribute set which contains configuration\n  # for the exporter's systemd service. One of\n  # `serviceOpts.script` and `serviceOpts.serviceConfig.ExecStart`\n  # has to be specified here. This will be merged with the default\n  # service configuration.\n  # Note that by default 'DynamicUser' is 'true'.\n  serviceOpts = {\n    serviceConfig = {\n      DynamicUser = false;\n      ExecStart = ''\n        ${pkgs.prometheus-postfix-exporter}/bin/postfix_exporter \\\n          --web.listen-address ${cfg.listenAddress}:${toString cfg.port} \\\n          --web.telemetry-path ${cfg.telemetryPath} \\\n          ${lib.concatStringsSep \" \\\\\n  \" cfg.extraFlags}\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling GNOME Core Developer Tools - NixOS Module Configuration - Nix\nDESCRIPTION: This snippet sets up GNOME's suite of core developer tools by enabling the respective NixOS module option. Required dependency is 'services.gnome.core-developer-tools' in the NixOS module namespace. After inclusion, development utilities recommended for GNOME will be available. The key is setting 'enable' to true.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gnome.core-developer-tools.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Tar.gz Archives Without stripRoot Using fetchzip - Nix\nDESCRIPTION: Here, fetchzip is used with stripRoot set to false, which causes the Nix derivation to output the decompressed archive contents as-is (with the original directory structure from the archive preserved). Requires the Nix fetchzip function, a valid URL, the correct hash for this configuration, and the explicit stripRoot = false attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchzip }:\nfetchzip {\n  url = \"https://github.com/NixOS/patchelf/releases/download/0.18.0/patchelf-0.18.0.tar.gz\";\n  hash = \"sha256-uv3FuKE4DqpHT3yfE0qcnq0gYjDNQNKZEZt2+PUAneg=\";\n  stripRoot = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Journaling Filesystem Check at Boot - Nix\nDESCRIPTION: This configuration disables the checkJournalingFS option in the NixOS initrd stage to prevent the startup filesystem check. This is necessary in VirtualBox guests, as the check may always fail and impede automated boot. This snippet requires no explicit dependencies and should be placed within the configuration.nix file; the setting expects a boolean value.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-virtualbox-guest.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.initrd.checkJournalingFS = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Android SDK Environment with Gradle AAPT2 Override in Nix\nDESCRIPTION: Nix shell configuration for Android development with proper SDK/NDK paths and Gradle AAPT2 override. Sets up ANDROID_HOME, ANDROID_NDK_ROOT, and configures GRADLE_OPTS for build tools compatibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  buildToolsVersion = \"30.0.3\";\n\n  # Use buildToolsVersion when you define androidComposition\n  androidComposition = <...>;\nin\npkgs.mkShell rec {\n  ANDROID_HOME = \"${androidComposition.androidsdk}/libexec/android-sdk\";\n  ANDROID_NDK_ROOT = \"${ANDROID_HOME}/ndk-bundle\";\n\n  # Use the same buildToolsVersion here\n  GRADLE_OPTS = \"-Dorg.gradle.project.android.aapt2FromMavenOverride=${ANDROID_HOME}/build-tools/${buildToolsVersion}/aapt2\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IBus Input Method in NixOS\nDESCRIPTION: Configuration snippet for enabling IBus input method with Japanese (Anthy), Korean (Hangul), and Japanese (Mozc) engines. Demonstrates how to enable the input method system and specify additional input engines.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"ibus\";\n    ibus.engines = with pkgs.ibus-engines; [ anthy hangul mozc ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning, Checking Out, and Building a NixOS ISO Image - ShellSession\nDESCRIPTION: These shell commands demonstrate how to clone the NixOS/nixpkgs repository, switch to the \\'nixos-unstable\\' channel branch, and build a minimal ISO image using nix-build. Required dependencies include git, nix, and permission to run these commands. Inputs are the repository URL and NixOS configurations, while outputs are built ISO image artifacts inside the \\'result\\' folder. Environment variables and switch targets may be adjusted as needed based on user requirements.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-nixos.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git clone https://github.com/NixOS/nixpkgs.git\\n$ cd nixpkgs/nixos\\n$ git switch nixos-unstable\\n$ nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-minimal.nix default.nix\n```\n\n----------------------------------------\n\nTITLE: Checking NixOS Version and Creating Local Git Branches in ShellSession\nDESCRIPTION: This snippet queries the currently installed NixOS version and creates a new local Git branch based on a specified commit. 'nixos-version' outputs the current NixOS version, and 'git checkout -b' is used to branch from the provided commit hash. Requires NixOS and Git, and is intended for aligning development branches to the system state.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nixos-version\n17.09pre104379.6e0b727 (Hummingbird)\n\n$ git checkout -b local 6e0b727\n```\n\n----------------------------------------\n\nTITLE: Installing NixOS Installation Tools (Shell)\nDESCRIPTION: Installs the NixOS installation tool suite, including nixos-generate-config and nixos-install, via the nix-env command. This operation fetches the tools from the specified Nix expression. Prerequisites: Nix and nixpkgs channel configured. Output: NixOS installer utilities made available globally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f '<nixpkgs>' -iA nixos-install-tools\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Packages for PL/Python in PostgreSQL\nDESCRIPTION: Example of making Python packages available to the PL/Python procedural language in PostgreSQL. This demonstrates using the withPackages function to include the base58 Python package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.extensions = pgps: with pgps; [\n    (plpython3.withPackages (pyps: with pyps; [ base58 ]))\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Emacs Service Installation without Global Enable\nDESCRIPTION: NixOS configuration to install Emacs service without enabling it globally for all users.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.emacs.enable = false;\n  services.emacs.install = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding a Package to Add a Desktop Item Using makeDesktopItem - Nix\nDESCRIPTION: This code illustrates extending an existing package (`hello`) in Nixpkgs to include a desktop entry using the `makeDesktopItem` helper. By overriding the package's attributes, additional desktop items can be provided for desktop integration. The `copyDesktopItems` hook is used to ensure the desktop files are copied during the package build. This approach requires the relevant Nix packaging infrastructure and the desktop item helper functions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  copyDesktopItems,\n  hello,\n  makeDesktopItem,\n}:\n\nhello.overrideAttrs {\n  nativeBuildInputs = [ copyDesktopItems ];\n\n  desktopItems = [\n    (makeDesktopItem {\n      name = \"hello\";\n      desktopName = \"Hello\";\n      exec = \"hello\";\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Development Build with Custom Revision in Nix\nDESCRIPTION: Code snippet showing how to override cataclysm-dda-git to install a specific git revision of the game with custom version, revision number, and SHA256 checksum.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ncataclysm-dda-git.override {\n  version = \"YYYY-MM-DD\";\n  rev = \"YOUR_FAVORITE_REVISION\";\n  sha256 = \"CHECKSUM_OF_THE_REVISION\";\n}\n```\n\n----------------------------------------\n\nTITLE: Writing NixOS ISO to USB using dd on Linux - ShellSession\nDESCRIPTION: This code snippet uses the dd utility to copy a NixOS ISO image directly to a USB flash drive on Linux. It utilizes optimal settings (bs=4M for block size, conv=fsync for sync, oflag=direct for direct disk access, status=progress for feedback). 'if' should be the path to the NixOS ISO image, and 'of' the USB block device (e.g., /dev/sdb). Proper device selection is critical to avoid data loss. Requires sudo privileges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-usb.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\nsudo dd bs=4M conv=fsync oflag=direct status=progress if=<path-to-image> of=/dev/sdX\n```\n\n----------------------------------------\n\nTITLE: Running a Derivation in a Linux VM using Nixpkgs vmTools (Nix)\nDESCRIPTION: This snippet demonstrates how to use the `runInLinuxVM` utility from `vmTools` to build a package (`hello`) inside a Linux virtual machine via QEMU/KVM. Dependencies include the Nix package set and the inclusion of `vmTools`. No parameters are required, and it executes the build with default VM settings (512 MiB memory, tmpfs root). Input is a derivation, and the output is the result of building it inside the VM environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }: with pkgs; with vmTools; runInLinuxVM hello\n```\n\n----------------------------------------\n\nTITLE: Loading and Using a Nix Development Environment Docker Image\nDESCRIPTION: Commands demonstrating how to load a Docker image built with buildNixShellImage and use it to build the hello package inside the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_33\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/pkj1sgzaz31wl0pbvbg3yp5b3kxndqms-hello-2.12.1-env.tar.gz\n\n$ docker image load -i /nix/store/pkj1sgzaz31wl0pbvbg3yp5b3kxndqms-hello-2.12.1-env.tar.gz\n(some output removed for clarity)\nLoaded image: hello-2.12.1-env:latest\n```\n\n----------------------------------------\n\nTITLE: Invoking runCommand for Simple Build Commands - Nix\nDESCRIPTION: This example highlights usage of `runCommand` to create a trivial Nix derivation running basic shell commands including file creation, writing data to the Nix store, and listing system information. The derivation will be built in the `stdenvNoCC` environment, minimizing dependencies and requiring no compiler. Required parameters include the derivation name, arguments, and the build shell script. Output is a store path with created files such as a message file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nrunCommand \"my-example\" { } ''\n  echo My example command is running\n\n  mkdir $out\n\n  echo I can write data to the Nix store > $out/message\n\n  echo I can also run basic commands like:\n\n  echo ls\n  ls\n\n  echo whoami\n  whoami\n\n  echo date\n  date\n''\n```\n\n----------------------------------------\n\nTITLE: Building NixOS Manual Documentation in a Sandbox - Shell\nDESCRIPTION: This shell command builds the NixOS manual for the x86_64-linux architecture using the nix-build command. It requires a Nix environment, the nixos/release.nix file, and a proper release attribute. The command is used to test changes to module documentation (as referenced by the doc meta attribute) and verify that they do not break the documentation build. Output is a local build artifact or an error on failure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/meta-attributes.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build nixos/release.nix -A manual.x86_64-linux\n```\n\n----------------------------------------\n\nTITLE: Building a Java Maven Package with buildMavenPackage - Nix\nDESCRIPTION: Defines a Nix derivation using the maven.buildMavenPackage function to package the 'jd-cli' Java application. Specifies attributes like pname, version, src (GitHub fetcher), Maven dependency hash, build inputs, and a custom install phase that wraps the main JAR file for execution via a shell script. Useful for creating reproducible, isolated Java packages in Nix. Requires dependencies: lib, fetchFromGitHub, jre, makeWrapper, and maven.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchFromGitHub,\n  jre,\n  makeWrapper,\n  maven,\n}:\n\nmaven.buildMavenPackage rec {\n  pname = \"jd-cli\";\n  version = \"1.2.1\";\n\n  src = fetchFromGitHub {\n    owner = \"intoolswetrust\";\n    repo = \"jd-cli\";\n    tag = \"jd-cli-${version}\";\n    hash = \"sha256-rRttA5H0A0c44loBzbKH7Waoted3IsOgxGCD2VM0U/Q=\";\n  };\n\n  mvnHash = \"sha256-kLpjMj05uC94/5vGMwMlFzLKNFOKeyNvq/vmB6pHTAo=\";\n\n  nativeBuildInputs = [ makeWrapper ];\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/bin $out/share/jd-cli\n    install -Dm644 jd-cli/target/jd-cli.jar $out/share/jd-cli\n\n    makeWrapper ${jre}/bin/java $out/bin/jd-cli \\\n      --add-flags \"-jar $out/share/jd-cli/jd-cli.jar\"\n\n    runHook postInstall\n  '';\n\n  meta = {\n    description = \"Simple command line wrapper around JD Core Java Decompiler project\";\n    homepage = \"https://github.com/intoolswetrust/jd-cli\";\n    license = lib.licenses.gpl3Plus;\n    maintainers = with lib.maintainers; [ majiir ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Switching to NixOS Unstable Channel\nDESCRIPTION: This command demonstrates how to switch to the bleeding edge unstable channel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nix-channel --add https://channels.nixos.org/nixos-unstable nixos\n```\n\n----------------------------------------\n\nTITLE: Overriding BLAS and LAPACK Implementations for Python Packages in Nix\nDESCRIPTION: Shows advanced usage of the packageOverrides mechanism to override BLAS and LAPACK implementations (e.g., replace with Intel MKL) for all Python packages, using toPythonModule for correct module integration. This is helpful for scientific Python ecosystems needing consistent underlying math library providers across packages. Requires access to pkgs.python3 and the relevant BLAS/LAPACK providers. Ensures numpy, scipy, and others use the same optimized library, avoiding incompatibility issues.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  python3MyBlas = pkgs.python3.override {\n    packageOverrides = self: super: {\n      # We need toPythonModule for the package set to evaluate this\n      blas = super.toPythonModule (\n        super.pkgs.blas.override {\n          blasProvider = super.pkgs.mkl;\n        }\n      );\n      lapack = super.toPythonModule (\n        super.pkgs.lapack.override {\n          lapackProvider = super.pkgs.mkl;\n        }\n      );\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Podman container with CUDA support\nDESCRIPTION: This command demonstrates how to run a Podman container with CUDA support, using the --device flag to expose all NVIDIA GPUs to the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ podman run --rm -it --device=nvidia.com/gpu=all ubuntu:latest nvidia-smi -L\nGPU 0: NVIDIA GeForce RTX 4090 (UUID: <REDACTED>)\nGPU 1: NVIDIA GeForce RTX 2080 SUPER (UUID: <REDACTED>)\n```\n\n----------------------------------------\n\nTITLE: Using Overlays to Override Packages in Nixpkgs (Nix)\nDESCRIPTION: This snippet provides the modern, recommended way to apply package overrides using overlays in Nixpkgs as of release 17.03. The overlays approach wraps a package set import, passing a list of overlay functions. Inputs include `pkgs.path` and a list of overlay lambdas; outputs are customized package sets ready for use. This method is more composable and modular than `overridePackages`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1703.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> {};\nin\n  import pkgs.path { overlays = [(self: super: { /* ... */ })]; }\n```\n\n----------------------------------------\n\nTITLE: Customizing Discourse Site and Backend Settings - Nix\nDESCRIPTION: This snippet illustrates advanced customization by setting site (UI-level) and backend (internal) Discourse settings in Nix. It configures attributes to modify the Discourse instance's metadata, enable GitHub login, and adjust request limits. Secrets for sensitive values, such as the GitHub client secret, are referenced by file path. All fields must conform to the expected YAML structure for Discourse settings, and values such as numeric request limits are enforced as provided.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.discourse = {\n    enable = true;\n    hostname = \"discourse.example.com\";\n    sslCertificate = \"/path/to/ssl_certificate\";\n    sslCertificateKey = \"/path/to/ssl_certificate_key\";\n    admin = {\n      email = \"admin@example.com\";\n      username = \"admin\";\n      fullName = \"Administrator\";\n      passwordFile = \"/path/to/password_file\";\n    };\n    mail.outgoing = {\n      serverAddress = \"smtp.emailprovider.com\";\n      port = 587;\n      username = \"user@emailprovider.com\";\n      passwordFile = \"/path/to/smtp_password_file\";\n    };\n    mail.incoming.enable = true;\n    siteSettings = {\n      required = {\n        title = \"My Cats\";\n        site_description = \"Discuss My Cats (and be nice plz)\";\n      };\n      login = {\n        enable_github_logins = true;\n        github_client_id = \"a2f6dfe838cb3206ce20\";\n        github_client_secret._secret = /run/keys/discourse_github_client_secret;\n      };\n    };\n    backendSettings = {\n      max_reqs_per_ip_per_minute = 300;\n      max_reqs_per_ip_per_10_seconds = 60;\n      max_asset_reqs_per_ip_per_10_seconds = 250;\n      max_reqs_per_ip_mode = \"warn+block\";\n    };\n    secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiple Desktop and Window Managers - Nix\nDESCRIPTION: This comprehensive snippet shows enabling various desktop managers (plasma5, xfce, gnome, mate) and window managers (xmonad, twm, icewm, i3, herbstluftwm) within a single NixOS configuration. Each line sets the .enable property of a specific manager to true, allowing them to be chosen at login time. Dependencies: Relevant desktop/window manager packages must be available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.plasma5.enable = true;\n  services.xserver.desktopManager.xfce.enable = true;\n  services.xserver.desktopManager.gnome.enable = true;\n  services.xserver.desktopManager.mate.enable = true;\n  services.xserver.windowManager.xmonad.enable = true;\n  services.xserver.windowManager.twm.enable = true;\n  services.xserver.windowManager.icewm.enable = true;\n  services.xserver.windowManager.i3.enable = true;\n  services.xserver.windowManager.herbstluftwm.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring User Accounts as Attribute Set with Username Key - Nix\nDESCRIPTION: This recommended NixOS snippet shows how to define system users directly as attribute sets keyed by username. The user properties such as 'description' and 'isNormalUser' are now children of the corresponding username attribute (e.g., users.users.me). This improves clarity, avoids ambiguous array order, and aligns with modern NixOS module conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.me =\n    { description = \"My personal user.\";\n      isNormalUser = true;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying FoundationDB Operation via CLI - ShellSession - shell\nDESCRIPTION: This snippet shows how to check FoundationDB's status by invoking fdbcli under the foundationdb system user. It demonstrates verifying the database's availability, viewing runtime configuration, and cluster statistics interactively via the command prompt. No dependencies are needed beyond the FoundationDB CLI, which is provided by the NixOS module; the critical command is 'sudo -u foundationdb fdbcli' followed by execution of status. Inputs are user shell commands, and outputs are human-readable status reports in the console.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo -u foundationdb fdbcli\nUsing cluster file `/etc/foundationdb/fdb.cluster'.\n\nThe database is available.\n\nWelcome to the fdbcli. For help, type `help'.\nfdb> status\n\nUsing cluster file `/etc/foundationdb/fdb.cluster'.\n\nConfiguration:\n  Redundancy mode        - single\n  Storage engine         - memory\n  Coordinators           - 1\n\nCluster:\n  FoundationDB processes - 1\n  Machines               - 1\n  Memory availability    - 5.4 GB per process on machine with least available\n  Fault Tolerance        - 0 machines\n  Server time            - 04/20/18 15:21:14\n\n...\n\nfdb>\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up nginx as Reverse Proxy for strfry with ACME/SSL - Nix\nDESCRIPTION: This Nix configuration sets up nginx as a reverse proxy in front of the strfry relay, with ACME and SSL enabled. Required dependencies include the NixOS nginx and strfry services, as well as ACME support for SSL. Parameters such as the virtual host domain, ACME email, and proxyPass URL must be set or parameterized appropriately for deployment. The configuration ensures websocket support for nostr, and expects strfry to be running locally; input and output are handled via nginx's proxy mechanism. Limitations could include the need to adapt listening ports and firewall settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/strfry.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  security.acme = {\n    acceptTerms = true;\n    defaults.email = \"foo@bar.com\";\n  };\n\n  services.nginx.enable = true;\n  services.nginx.virtualHosts.\"strfry.example.com\" = {\n    addSSL = true;\n    enableACME = true;\n    locations.\"/\" = {\n      proxyPass = \"http://127.0.0.1:${toString config.services.strfry.settings.relay.port}\";\n      proxyWebsockets = true; # nostr uses websockets\n    };\n  };\n\n  services.strfry.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Local Pleroma Instance with SSH Port Forwarding\nDESCRIPTION: Command to create an SSH tunnel for testing the local Pleroma instance running on port 4000, allowing access from a remote machine through port forwarding.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ ssh -L 4000:localhost:4000 myuser@example.net\n```\n\n----------------------------------------\n\nTITLE: New Module Review Checklist Template - Markdown\nDESCRIPTION: This markdown code snippet gives a detailed checklist for reviewing new NixOS module submissions. It covers file path guidelines, testing, option configurations (type, default, example, and description), metadata, and package inclusion. Reviewers copy this template to ensure that all requirements for new modules are met and documented during the review process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/README.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n##### Reviewed points\n\n- [ ] module path fits the guidelines\n- [ ] module tests, if any, succeed on ARCHITECTURE\n- [ ] module tests, if any, are added to package `passthru.tests`\n- [ ] options have appropriate types\n- [ ] options have default\n- [ ] options have example\n- [ ] options have descriptions\n- [ ] No unneeded package is added to `environment.systemPackages`\n- [ ] `meta.maintainers` is set\n- [ ] module documentation is declared in `meta.doc`\n\n##### Possible improvements\n\n##### Comments\n```\n\n----------------------------------------\n\nTITLE: Copying Database and Uploads from Pleroma to Akkoma - ShellSession\nDESCRIPTION: These commands demonstrate migration from Pleroma to Akkoma by duplicating the PostgreSQL database and copying uploads to a new data directory. They require the postgresql client tools, appropriate user permissions, and an operational Nix shell environment. Inputs are source/destination directories and database names; outputs are functional Akkoma data stores.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n# Create a copy of the database\nnix-shell -p postgresql --run 'createdb -T pleroma akkoma'\n\n# Copy upload data\nmkdir /var/lib/akkoma\ncp -R --reflink=auto /var/lib/pleroma/uploads /var/lib/akkoma/\n```\n\n----------------------------------------\n\nTITLE: Booting Azure VM from Custom Image\nDESCRIPTION: Shell commands to boot an Azure VM using the previously created custom image. Uses the image path from the previous upload command to initialize a new VM instance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/maintainers/scripts/azure-new/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nimg=\"/subscriptions/.../...\" # use output from last command\n./boot-vm.sh \"${img}\"\n...\n=> booted\n```\n\n----------------------------------------\n\nTITLE: Exporting Docker Image without Explicit Name - Nix\nDESCRIPTION: This Nix snippet shows that when `dockerTools.exportImage` is used with a derivation as `fromImage`, the `name` attribute is optional. The output tarball's name inherits the extension from the source derivation, often `.tar.gz`. This may cause confusion since the archive is uncompressed, so specifying a `name` is recommended for clarity. The code requires `dockerTools` and `hello`; output is a Docker image tarball.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.exportImage {\n  fromImage = dockerTools.buildLayeredImage {\n    name = \"hello\";\n    contents = [ hello ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Provisioning a Full-featured Development Shell for Elixir Phoenix Projects with Nix - Nix Language\nDESCRIPTION: This shell.nix example provisions a comprehensive development shell for Phoenix projects, installing common tools like git, Elixir/BEAM, NodeJS, Postgres, and frontend-related programs. It also employs system-dependent conditional inclusion of Darwin and Linux-specific packages, and provides an extensive shellHook setup to ensure all environment variables, paths, and developer conveniences are in place. All major project variables and development hooks are defined for integration, supporting commands for database, Phoenix server, and frontend workflows. Requires an up-to-date Nixpkgs and the full project dependency tree.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  # define packages to install\n  basePackages = [\n    git\n    # replace with beam.packages.erlang.elixir_1_18 if you need\n    beam.packages.erlang.elixir\n    nodejs\n    postgresql_14\n    # only used for frontend dependencies\n    # you are free to use yarn2nix as well\n    nodePackages.node2nix\n    # formatting js file\n    nodePackages.prettier\n  ];\n\n  inputs =\n    basePackages\n    ++ lib.optionals stdenv.hostPlatform.isLinux [ inotify-tools ]\n    ++ lib.optionals stdenv.hostPlatform.isDarwin (\n      with darwin.apple_sdk.frameworks;\n      [\n        CoreFoundation\n        CoreServices\n      ]\n    );\n\n  # define shell startup command\n  hooks = ''\n    # this allows mix to work on the local directory\n    mkdir -p .nix-mix .nix-hex\n    export MIX_HOME=$PWD/.nix-mix\n    export HEX_HOME=$PWD/.nix-mix\n    # make hex from Nixpkgs available\n    # `mix local.hex` will install hex into MIX_HOME and should take precedence\n    export MIX_PATH=\"${beam.packages.erlang.hex}/lib/erlang/lib/hex/ebin\"\n    export PATH=$MIX_HOME/bin:$HEX_HOME/bin:$PATH\n    export LANG=C.UTF-8\n    # keep your shell history in iex\n    export ERL_AFLAGS=\"-kernel shell_history enabled\"\n\n    # postges related\n    # keep all your db data in a folder inside the project\n    export PGDATA=\"$PWD/db\"\n\n    # phoenix related env vars\n    export POOL_SIZE=15\n    export DB_URL=\"postgresql://postgres:postgres@localhost:5432/db\"\n    export PORT=4000\n    export MIX_ENV=dev\n    # add your project env vars here, word readable in the nix store.\n    export ENV_VAR=\"your_env_var\"\n  '';\n\nin\nmkShell {\n  buildInputs = inputs;\n  shellHook = hooks;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring COSMIC Application Packaging with libcosmicAppHook in Nix\nDESCRIPTION: This snippet demonstrates adding the libcosmicAppHook to the nativeBuildInputs of a Rust package using the Nix package manager. By including libcosmicAppHook, the build process automatically sets up library linking, XDG paths, environment variables, and Rust linker flags required for packaging COSMIC applications. Dependencies include the rustPlatform and libcosmicAppHook. The primary parameter to include is nativeBuildInputs, ensuring wrapping and configuration are handled for libcosmic/iced applications, with no additional output beyond build artifacts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cosmic.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  rustPlatform,\n  libcosmicAppHook,\n}:\nrustPlatform.buildRustPackage {\n  # ...\n  nativeBuildInputs = [ libcosmicAppHook ];\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building NixOS ISO with Custom GNOME MacBook Installer - ShellSession\nDESCRIPTION: This series of shell commands demonstrates building a custom NixOS installer ISO with additional (potentially non-free) drivers. It includes setting the NIXPKGS_ALLOW_UNFREE environment variable to enable unfree packages, cloning the repository, and running the build with a specific custom configuration file. All dependencies from the nix-build and initial setup apply. Inputs include the environment variable and custom configuration path, outputs are ISO images incorporating the extra MacBook and firmware support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-nixos.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git clone https://github.com/NixOS/nixpkgs.git\\n$ cd nixpkgs/nixos\\n$ export NIXPKGS_ALLOW_UNFREE=1\\n$ nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-graphical-gnome-macbook.nix default.nix\n```\n\n----------------------------------------\n\nTITLE: Running the NixOS VM with Port Forwarding via QEMU - ShellSession\nDESCRIPTION: This command runs the generated VM with QEMU and forwards host TCP port 2222 to guest port 22, enabling SSH access to the virtual machine via localhost. The 'QEMU_NET_OPTS' environment variable configures the network behavior. Requires previously built VM and QEMU installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ QEMU_NET_OPTS=\"hostfwd=tcp:127.0.0.1:2222-:22\" ./result/bin/run-*-vm\n```\n\n----------------------------------------\n\nTITLE: Configuring Yggdrasil-attached Container in NixOS\nDESCRIPTION: This snippet demonstrates how to set up a NixOS container attached to the Yggdrasil network via a node running on the host. It configures IPv6 forwarding, sets up a bridge interface, and defines a container with Yggdrasil networking. The container is configured with a web server accessible through the Yggdrasil network.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/yggdrasil.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  yggPrefix64 = \"310:5217:69c0:9afc\";\n    # Again, taken from the output of \"yggdrasilctl getself\".\nin\n{\n  boot.kernel.sysctl.\"net.ipv6.conf.all.forwarding\" = 1;\n  # Enable IPv6 forwarding.\n\n  networking = {\n    bridges.br0.interfaces = [ ];\n    # A bridge only to containers…\n\n    interfaces.br0 = {\n      # … configured with a prefix address.\n      ipv6.addresses = [{\n        address = \"${yggPrefix64}::1\";\n        prefixLength = 64;\n      }];\n    };\n  };\n\n  containers.foo = {\n    autoStart = true;\n    privateNetwork = true;\n    hostBridge = \"br0\";\n    # Attach the container to the bridge only.\n    config = { config, pkgs, ... }: {\n      networking.interfaces.eth0.ipv6 = {\n        addresses = [{\n          # Configure a prefix address.\n          address = \"${yggPrefix64}::2\";\n          prefixLength = 64;\n        }];\n        routes = [{\n          # Configure the prefix route.\n          address = \"200::\";\n          prefixLength = 7;\n          via = \"${yggPrefix64}::1\";\n        }];\n      };\n\n      services.httpd.enable = true;\n      networking.firewall.allowedTCPPorts = [ 80 ];\n    };\n  };\n\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package with Custom Rust Crate Location using Setuptools-Rust (Nix)\nDESCRIPTION: This snippet covers a scenario where the Rust crate is not located in the Python package's main source directory. The `cargoRoot` attribute is used to specify an alternate path, ensuring the Nix build system fetches and sets up dependencies from the correct subdirectory. This approach is shown for the cryptography package and demonstrates the use of `fetchPypi` for source and `fetchCargoVendor` for vendor dependencies. It is necessary to precisely specify the source roots and hashes for reproducibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_25\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildPythonPackage,\n  fetchPypi,\n  rustPlatform,\n  setuptools-rust,\n  openssl,\n}:\n\nbuildPythonPackage rec {\n  pname = \"cryptography\";\n  version = \"3.4.2\"; # Also update the hash in vectors.nix\n\n  src = fetchPypi {\n    inherit pname version;\n    hash = \"sha256-xGDilsjLOnls3MfVbGKnj80KCUCczZxlis5PmHzpNcQ=\";\n  };\n\n  cargoDeps = rustPlatform.fetchCargoVendor {\n    inherit pname version src;\n    sourceRoot = \"${pname}-${version}/${cargoRoot}\";\n    hash = \"sha256-ctUt8maCjnGddKPf+Ii++wKsAXA1h+JM6zKQNXXwJqQ=\";\n  };\n\n  cargoRoot = \"src/rust\";\n\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Manually Wrapping Qt Applications Using wrapQtApp - Nix\nDESCRIPTION: Illustrates manual control over the wrapping process for Qt applications by setting dontWrapQtApps to true and calling wrapQtApp during preFixup. This is recommended for advanced use cases where automatic wrapping is insufficient or scripts (e.g., non-ELF executables) must be handled individually. Dependencies include wrapQtAppsHook for providing wrapQtApp and standard mkDerivation inputs. Expects the application binary at $out/bin/myapp to be wrapped with an updated PATH prefix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/qt.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  lib,\n  wrapQtAppsHook,\n}:\n\nstdenv.mkDerivation {\n  # ...\n  nativeBuildInputs = [ wrapQtAppsHook ];\n  dontWrapQtApps = true;\n  preFixup = ''\n    wrapQtApp \"$out/bin/myapp\" --prefix PATH : /path/to/bin\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom XKB Keycodes for Multimedia Keys in Plain Text\nDESCRIPTION: Defines new keycodes for volume up and down multimedia keys in an XKB keycodes file. Required for custom hardware keys not mapped by default; must be placed in a file such as 'media-key'. Input: symbolic names like <volUp>; output: keycode assignments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_25\n\nLANGUAGE: plain text\nCODE:\n```\nxkb_keycodes \"media\"\n{\n <volUp>   = 123;\n <volDown> = 456;\n}\n```\n\n----------------------------------------\n\nTITLE: Uninstalling a Package via nix-env - ShellSession\nDESCRIPTION: Removes the specified package (thunderbird) from the current user or system profile using the nix-env -e flag. Prerequisites require the package be installed. The command's input is the package name, and successful execution results in its removal from the profile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-packages.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -e thunderbird\n```\n\n----------------------------------------\n\nTITLE: Building iOS Application with Nix\nDESCRIPTION: This Nix expression demonstrates how to build an iOS application using the xcodeenv.buildApp function. It includes various parameters for configuring the build process, such as SDK version, signing method, and distribution options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n\n  xcodeenv = import ./xcodeenv {\n    inherit (pkgs) stdenv;\n  };\nin\nxcodeenv.buildApp {\n  name = \"MyApp\";\n  src = ./myappsources;\n  sdkVersion = \"11.2\";\n\n  target = null; # Corresponds to the name of the app by default\n  configuration = null; # Release for release builds, Debug for debug builds\n  scheme = null; # -scheme will correspond to the app name by default\n  sdk = null; # null will set it to 'iphonesimulator` for simulator builds or `iphoneos` to real builds\n  xcodeFlags = \"\";\n\n  release = true;\n  certificateFile = ./mycertificate.p12;\n  certificatePassword = \"secret\";\n  provisioningProfile = ./myprovisioning.profile;\n  signMethod = \"ad-hoc\"; # 'enterprise' or 'store'\n  generateIPA = true;\n  generateXCArchive = false;\n\n  enableWirelessDistribution = true;\n  installURL = \"/installipa.php\";\n  bundleId = \"mycompany.myapp\";\n  appVersion = \"1.0\";\n\n  # Supports all xcodewrapper parameters as well\n  xcodeBaseDir = \"/Applications/Xcode.app\";\n}\n```\n\n----------------------------------------\n\nTITLE: Basic oCIS NixOS Configuration\nDESCRIPTION: A minimal NixOS configuration to enable and configure the oCIS service with a custom config directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/ocis.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  services.ocis = {\n    enable = true;\n    configDir = \"/etc/ocis/config\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Source Files for Tool Manpages with git and grep - Nix/Nixpkgs - ShellSession\nDESCRIPTION: A command-line pipeline example to locate manpage source files corresponding to NixOS tools using git ls and grep. Replace nixos-rebuild.8 with the appropriate tool name or file pattern. Requires git, bash, and a checked-out Nixpkgs tree. Outputs relative file paths matching the given name.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/contributing-to-this-manual.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ git ls | grep nixos-rebuild.8\\n```\n```\n\n----------------------------------------\n\nTITLE: Java Main Class Using emoji-java Library - Java\nDESCRIPTION: Implements a simple Java main class utilizing emoji-java to parse unicode emoji codes to emoji characters. Reads a hardcoded string, processes it via EmojiParser, and prints the result. Requires emoji-java (v5.1.1+) dependency to be available at compile and run time. The input string is inlined; outputs the unicode-version to standard output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nimport com.vdurmont.emoji.EmojiParser;\n\npublic class Main {\n  public static void main(String[] args) {\n    String str = \"NixOS :grinning: is super cool :smiley:!\";\n    String result = EmojiParser.parseToUnicode(str);\n    System.out.println(result);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Packages to Livebook Service - Nix\nDESCRIPTION: This snippet extends the Livebook service configuration by adding extra system packages that are required for specific features, such as machine learning Kinos (e.g., `gcc`, `gnumake`). Using the `extraPackages` attribute, users can supply a list of additional dependencies based on the available packages from the current environment (`pkgs`). The input is a list of packages, and the configuration will ensure these dependencies are available in the Livebook environment. This approach assumes prior setup of the `services.livebook` attribute and a proper Nix packages context.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/livebook.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.livebook.extraPackages = with pkgs; [ gcc gnumake ];\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching EDID Files from linuxhw Database with linuxhw-edid-fetcher - Nix\nDESCRIPTION: This snippet configures hardware.display.edid.linuxhw to fetch EDID files from the linuxhw database using the pkgs.linuxhw-edid-fetcher package. It assigns search strings or regex patterns to identify the desired display entry. Inputs are display identifiers and corresponding search criteria; output is a Nix derivation that fetches, prepares, and registers the necessary EDID files for use in NixOS. Dependencies include pkgs.linuxhw-edid-fetcher and internet access to github.com/linuxhw/EDID.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.display.edid.linuxhw.\"PG278Q_2014\" = [ \"PG278Q\" \"2014\" ];\n\n  /* equals:\n  hardware.display.edid.packages = [\n    (pkgs.linuxhw-edid-fetcher.override {\n      displays = {\n        \"PG278Q_2014\" = [ \"PG278Q\" \"2014\" ];\n      };\n    })\n  ];\n  */\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Suwayomi-Server Configuration in NixOS\nDESCRIPTION: Shows how to customize Suwayomi-Server settings, including changing the data directory, opening the firewall, and setting a custom port.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/suwayomi-server.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.suwayomi-server = {\n    enable = true;\n\n    dataDir = \"/var/lib/suwayomi\"; # Default is \"/var/lib/suwayomi-server\"\n    openFirewall = true;\n\n    settings = {\n      server.port = 4567;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Loading and Testing Layered Docker Image with Shell Access\nDESCRIPTION: Commands demonstrating how to load a layered Docker image built with dockerTools into Docker and test shell access.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/rpf47f4z5b9qr4db4ach9yr4b85hjhxq-env-helpers.tar.gz\n$ docker image load -i /nix/store/rpf47f4z5b9qr4db4ach9yr4b85hjhxq-env-helpers.tar.gz\n(output removed for clarity)\n$ docker container run --rm -it env-helpers:latest /bin/sh\nsh-5.2# help\nGNU bash, version 5.2.21(1)-release (x86_64-pc-linux-gnu)\n(rest of output removed for clarity)\n```\n\n----------------------------------------\n\nTITLE: Building an Idris Package with Nix-build\nDESCRIPTION: Command to build an Idris package directly from a Nix expression file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -E '(import <nixpkgs> {}).idrisPackages.callPackage ./yaml.nix {}'\n```\n\n----------------------------------------\n\nTITLE: Disabling IPv6 Globally in NixOS - Nix\nDESCRIPTION: This code snippet demonstrates how to globally disable IPv6 networking on a NixOS system by setting 'networking.enableIPv6' to false in your NixOS configuration. No additional dependencies are required, but this change will disable IPv6 functionality system-wide for all interfaces at boot. The input is a NixOS module attribute set; no outputs are generated apart from the effect on the network stack after applying the configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv6-config.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.enableIPv6 = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt 5 to Use GTK Theme - Nix\nDESCRIPTION: Enables Qt 5 integration with GTK themes by setting qt.enable to true and specifying both qt.platformTheme and qt.style as 'gtk2'. This makes Qt 5 application interface look like GTK-based counterparts, improving desktop consistency. Requires GTK and Qt packages installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n{\n  qt.enable = true;\n  qt.platformTheme = \"gtk2\";\n  qt.style = \"gtk2\";\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Redis Database for Peertube - Bash\nDESCRIPTION: Shows the step-by-step process to save the current Redis database, ensure a new directory exists for Peertube's Redis server, and copy the RDB snapshot there. Requires redis-cli and sudo access to create directories and permissions to read and write Redis storage files. Used for data migration during upgrades involving per-application Redis configuration; takes the operational Redis memory and produces a persistent file in the target directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nredis-cli save\nsudo mkdir /var/lib/redis-peertube\nsudo cp /var/lib/redis/dump.rdb /var/lib/redis-peertube/dump.rdb\n```\n\n----------------------------------------\n\nTITLE: Minimal Agda Library Derivation with mkDerivation - Nix - nix\nDESCRIPTION: Provides a sample default.nix for building an Agda library using agdaPackages.mkDerivation. Demonstrates setting pname, version, src, and buildInputs, and assumes a standard directory structure with an Everything.agda file present. Dependencies are nixpkgs, agdaPackages, and agdaPackages.standard-library. Outputs a Nix derivation providing the Agda library.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs ? <nixpkgs>,\n}:\nwith (import nixpkgs { });\nagdaPackages.mkDerivation {\n  version = \"1.0\";\n  pname = \"my-agda-lib\";\n  src = ./.;\n  buildInputs = [\n    agdaPackages.standard-library\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Kernel Runtime Parameters in NixOS\nDESCRIPTION: Demonstrates how to configure kernel runtime parameters (sysctl values) with the boot.kernel.sysctl option in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 120;\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Symlinked Maven Repository with buildMaven - Nix Language\nDESCRIPTION: Demonstrates using the buildMaven function in Nix to generate a Maven repository from a JSON manifest (project-info.json). This pattern yields a symlink farm of all resolved dependencies, improving rebuild efficiency by avoiding re-downloading unchanged packages. Requires project-info.json produced by the mvn2nix-maven-plugin, and will return a reference to the symlinked Maven repository for downstream use.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\nwith pkgs;\n(buildMaven ./project-info.json).repo\n\n```\n\n----------------------------------------\n\nTITLE: Enabling and Securing Livebook Service - Nix\nDESCRIPTION: This snippet shows how to enable the Livebook service using the NixOS module system. It demonstrates the configuration of user-level systemd services, environment variables for service customization, and specifies how to set a password securely by using an `environmentFile`. The `LIVEBOOK_PORT` and `LIVEBOOK_PASSWORD` parameters control access and interface port, while the note recommends not storing sensitive data directly in the configuration for security reasons. Inputs are NixOS configuration options; outputs are the running Livebook systemd unit. The setup assumes a working NixOS environment and access to the relevant packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/livebook.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.livebook = {\n    enableUserService = true;\n    environment = {\n      LIVEBOOK_PORT = 20123;\n      LIVEBOOK_PASSWORD = \"mypassword\";\n    };\n    # See note below about security\n    environmentFile = \"/var/lib/livebook.env\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Uploading Standard NixOS AMI\nDESCRIPTION: Commands to build a NixOS AMI from a local nixpkgs checkout and upload it to AWS. Requires AWS credentials and the upload-ami tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/maintainers/scripts/ec2/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnix-build nixos/release.nix -A amazonImage\n\nexport AWS_REGION=us-west-2\nexport AWS_PROFILE=my-profile\nnix run nixpkgs#upload-ami -- --image-info ./result/nix-support/image-info.json\n```\n\n----------------------------------------\n\nTITLE: Defining a Group Declaratively with GID - Nix - nix\nDESCRIPTION: This snippet illustrates how to declare a system group in NixOS using 'configuration.nix', explicitly setting its group ID (gid). The attribute 'users.groups.students.gid' specifies the numeric group identifier. This approach is used for group management automation, ensuring group existence and idempotence. Omit 'gid' to assign the group ID automatically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.groups.students.gid = 1000;\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Xcode Wrapper Package Contents\nDESCRIPTION: This bash snippet shows how to inspect the contents of the Xcode wrapper package created by Nix. It lists the executables exposed in the package's bin directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ls result/bin\nlrwxr-xr-x  1 sander  staff  94  1 jan  1970 Simulator -> /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app/Contents/MacOS/Simulator\nlrwxr-xr-x  1 sander  staff  17  1 jan  1970 codesign -> /usr/bin/codesign\nlrwxr-xr-x  1 sander  staff  17  1 jan  1970 security -> /usr/bin/security\nlrwxr-xr-x  1 sander  staff  21  1 jan  1970 xcode-select -> /usr/bin/xcode-select\nlrwxr-xr-x  1 sander  staff  61  1 jan  1970 xcodebuild -> /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild\nlrwxr-xr-x  1 sander  staff  14  1 jan  1970 xcrun -> /usr/bin/xcrun\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom gitignoreFilter in Nix\nDESCRIPTION: This snippet shows how to construct a custom gitignoreFilter function that applies gitignore patterns to a source directory using filterPattern and gitignoreToPatterns. It demonstrates how to combine a given ignore value (ign) and root path. It requires knowledge of internal helper functions: filterPattern and gitignoreToPatterns from the nix-gitignore package, and outputs a composable filtering function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/nix-gitignore.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  gitignoreFilter = ign: root: filterPattern (gitignoreToPatterns ign) root;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ReadWritePaths for PostgreSQL Tablespaces\nDESCRIPTION: Example of configuring systemd service settings to allow PostgreSQL access to tablespace locations. This is necessary when using custom tablespace locations with service hardening enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.postgresql.serviceConfig.ReadWritePaths = [\n    \"/path/to/tablespace/location\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Mix dependencies using Fixed Output Derivation\nDESCRIPTION: This Nix snippet shows how to fetch Mix dependencies using a Fixed Output Derivation (FOD). It uses fetchMixDeps to download the dependencies and ensures reproducibility by providing a hash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mixFodDeps = fetchMixDeps {\n    pname = \"mix-deps-${pname}\";\n    inherit src version;\n    hash = lib.fakeHash;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Agda with Standard Library Packages - Nix - nix\nDESCRIPTION: Demonstrates how to configure Agda with access to the standard library using agda.withPackages. It requires nixpkgs with agda and agdaPackages set, and assumes agdaPackages.standard-library is available. The snippet provides a simple list-based input to agda.withPackages, resulting in an Agda environment ready to use the standard library. Input is a list of Agda package derivations, and output is a wrapped Agda executable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages [ agdaPackages.standard-library ]\n```\n\n----------------------------------------\n\nTITLE: Agda Library Skeleton for Inclusion in Nixpkgs - Nix - nix\nDESCRIPTION: Gives an example skeleton for writing a mkDerivation for an Agda library suitable for Nixpkgs, showing extra attributes such as libraryFile, libraryName, and a custom buildPhase. The buildPhase allows arbitrary shell commands, for example patchShebangs and make, and references special hooks. Useful when nonstandard build steps or file naming conventions are needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nmkDerivation {\n  version = \"1.5.0\";\n  pname = \"iowa-stdlib\";\n\n  src = <...>;\n\n  libraryFile = \"\";\n  libraryName = \"IAL-1.3\";\n\n  buildPhase = ''\n    runHook preBuild\n\n    patchShebangs find-deps.sh\n    make\n\n    runHook postBuild\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Keyboard Layout and Variant for X Server - Nix\nDESCRIPTION: This snippet configures the default keyboard layout ('de' for German) and an optional variant ('neo') for the X server in NixOS. The settings affect input methods across graphical sessions. Requires correct language and variant options as per XKB configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.xkb.layout = \"de\";\n  services.xserver.xkb.variant = \"neo\";\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning 'master' Role to Node - NixOS Kubernetes Module - Nix\nDESCRIPTION: Assigns the 'master' role to a host in the Kubernetes cluster by setting 'services.kubernetes.roles' to [ \"master\" ]. This enables the appropriate master components (apiserver, controllerManager, scheduler, addonManager, kube-proxy, and etcd) automatically. This configuration simplifies cluster master initialization and reduces the need for enabling each component individually. Dependencies include the NixOS Kubernetes module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/kubernetes.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.kubernetes.roles = [ \"master\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Nix Development Environment Docker Image with buildNixShellImage\nDESCRIPTION: Example showing how to create a Docker image with buildNixShellImage that provides a development environment for building the hello package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_32\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildNixShellImage {\n  drv = hello;\n  tag = \"latest\";\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Python Virtual Environment Shell Hook\nDESCRIPTION: Implements a custom shell hook for Python virtual environment creation, supporting both Python 2 and 3 with manual virtualenv configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_52\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  venvDir = \"./.venv\";\n  pythonPackages = python3Packages;\nin\npkgs.mkShell rec {\n  name = \"impurePythonEnv\";\n  buildInputs = [\n    pythonPackages.python\n  ];\n\n  shellHook = ''\n    SOURCE_DATE_EPOCH=$(date +%s)\n\n    if [ -d \"${venvDir}\" ]; then\n      echo \"Skipping venv creation, '${venvDir}' already exists\"\n    else\n      echo \"Creating new venv environment in path: '${venvDir}'\"\n      ${pythonPackages.python.interpreter} -m venv \"${venvDir}\"\n    fi\n\n    source \"${venvDir}/bin/activate\"\n\n    pip install -r requirements.txt\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Install-Related Build Phases - Bash\nDESCRIPTION: This Bash command sets the phases environment variable to include all install-related phases, including fixup and installCheckPhase, before invoking genericBuild. It is used within nix-shell for verifying the install and post-processing steps. Environment constraints: proper definition of all involved phases and variables.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nphases=\"${preInstallPhases[*]:-} installPhase ${preFixupPhases[*]:-} fixupPhase installCheckPhase\" genericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Defining the structure of a NixOS Module – Nix\nDESCRIPTION: Demonstrates the canonical structure of a full NixOS module as a Nix expression function. Shows how to structure imports, option declarations, and option definitions. The file expects to be called as a Nix function receiving various arguments (e.g., config, pkgs), and defines the set of options and configuration values this module handles. Inputs are arguments to the function; output is an attribute set shaping the module's composition. Dependencies: The Nix language, part of a NixOS system, access to imported modules as needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-modules.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # paths of other modules\n    ];\n\n  options = {\n    # option declarations\n  };\n\n  config = {\n    # option definitions\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Forgejo to Reuse Gitea Resources - NixOS Module - Nix\nDESCRIPTION: This Nix configuration snippet shows how to enable the Forgejo service on NixOS while reusing the existing Gitea user, state directory, and database, effectively minimizing migration friction. Dependencies include a properly configured NixOS environment with both users and services modules enabled. It disables the old gitea service, sets up forgejo to run as `gitea`, and clearly specifies user, group, state directory, and database parameters required for continuity. Outputs are persistent across reboots; changes are declarative and must be applied via nixos-rebuild. This approach is limited to setups where continued reuse of Gitea's original resources is safe and intentional.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/forgejo.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gitea.enable = false;\n\n  services.forgejo = {\n    enable = true;\n    user = \"gitea\";\n    group = \"gitea\";\n    stateDir = \"/var/lib/gitea\";\n    database.name = \"gitea\";\n    database.user = \"gitea\";\n  };\n\n  users.users.gitea = {\n    home = \"/var/lib/gitea\";\n    useDefaultShell = true;\n    group = \"gitea\";\n    isSystemUser = true;\n  };\n\n  users.groups.gitea = {};\n}\n```\n\n----------------------------------------\n\nTITLE: Importing NixOS Profiles in Configuration - Nix\nDESCRIPTION: This Nix snippet demonstrates how to import one or more NixOS profile modules into a system's configuration.nix file using the 'imports' array. Profiles are predefined system configuration files provided by nixpkgs to enable specific system behaviors or features. Required dependency is access to the nixpkgs repository, and the syntax expects valid Nix expressions. The 'profile-name.nix' should be replaced with the desired profile file, and users can import multiple profiles as needed. This snippet should be placed in the /etc/nixos/configuration.nix file; it outputs a merged system configuration as defined by all imported modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/profiles.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  imports = [\n    <nixpkgs/nixos/modules/profiles/profile-name.nix>\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Notification Hook for Cert Spotter - Nix Language\nDESCRIPTION: This Nix code snippet configures a Cert Spotter hook that triggers a custom shell script in place of standard email notifications. The script constructs an email using environment variables (such as $SUMMARY and $TEXT_FILENAME) populated by Cert Spotter, formats headers, and sends the message via sendmail. Dependencies include pkgs.writeShellScript to create the script and a configured sendmail path in the NixOS configuration. The input is a certificate event; the output is a formatted email sent using the specified global config settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/certspotter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.certspotter.hooks = [\n    (pkgs.writeShellScript \"certspotter-hook\" ''\n      function print_email() {\n        echo \"Subject: [certspotter] $SUMMARY\"\n        echo \"Mime-Version: 1.0\"\n        echo \"Content-Type: text/plain; charset=US-ASCII\"\n        echo\n        cat \"$TEXT_FILENAME\"\n      }\n      print_email | ${config.services.certspotter.sendmailPath} -i webmaster@example.org\n    '')\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring nscd Service Caching in NixOS (Nix)\nDESCRIPTION: This snippet demonstrates how to override the default nscd service configuration within `services.nscd.config` to fine-tune caching behavior for `passwd`, `group`, and `hosts` databases. The example includes options for enabling and configuring time-to-live parameters, cache sizing, and persistence properties in the Nix language. This custom configuration should be placed in your NixOS configuration file and requires administrative privileges for changes to apply. The primary input is a multi-line string containing the nscd configuration, which is passed as a value to the `services.nscd.config` attribute set. Output consists of nscd applying the specified cache logic at runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1903.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nscd.config =\n  ''\n  server-user             nscd\n  threads                 1\n  paranoia                no\n  debug-level             0\n\n  enable-cache            passwd          yes\n  positive-time-to-live   passwd          600\n  negative-time-to-live   passwd          20\n  suggested-size          passwd          211\n  check-files             passwd          yes\n  persistent              passwd          no\n  shared                  passwd          yes\n\n  enable-cache            group           yes\n  positive-time-to-live   group           3600\n  negative-time-to-live   group           60\n  suggested-size          group           211\n  check-files             group           yes\n  persistent              group           no\n  shared                  group           yes\n\n  enable-cache            hosts           yes\n  positive-time-to-live   hosts           600\n  negative-time-to-live   hosts           5\n  suggested-size          hosts           211\n  check-files             hosts           yes\n  persistent              hosts           no\n  shared                  hosts           yes\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Hatsu Service via NixOS Module - Nix\nDESCRIPTION: This snippet demonstrates how to enable the Hatsu ActivityPub bridge server as a NixOS service. It sets required environment variables, such as HATSU_DOMAIN and HATSU_PRIMARY_ACCOUNT, and ensures the service is started on boot. Dependencies include NixOS with module support and appropriate permissions for writing to /var/lib/hatsu. The configuration expects domain and account strings as input, and on activation, the hatsu server will listen on port 3939 and use an SQLite database at /var/lib/hatsu/hatsu.sqlite3.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/hatsu.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.hatsu = {\n    enable = true;\n    settings = {\n      HATSU_DOMAIN = \"hatsu.local\";\n      HATSU_PRIMARY_ACCOUNT = \"example.com\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Basic usage of redisTestHook in NixOS package\nDESCRIPTION: Shows how to include the redisTestHook in a derivation's nativeCheckInputs to automatically start a Redis server during tests.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/redis-test-hook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  redis,\n  redisTestHook,\n}:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeCheckInputs = [\n    redisTestHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Neovim with Unstable Wrapper and Plugins in Nix\nDESCRIPTION: This snippet demonstrates the use of the unstable Neovim wrapper 'wrapNeovimUnstable' to configure Neovim with various options and plugins. It includes settings for autoconfiguration, runtime dependencies, Lua configuration, and plugin specification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/neovim.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nwrapNeovimUnstable neovim-unwrapped {\n  autoconfigure = true;\n  autowrapRuntimeDeps = true;\n  luaRcContent = ''\n    vim.o.sessionoptions = 'buffers,curdir,help,tabpages,winsize,winpos,localoptions'\n    vim.g.mapleader = ' '\n    vim.g.maplocalleader = ' '\n    vim.opt.smoothscroll = true\n    vim.opt.colorcolumn = { 100 }\n    vim.opt.termguicolors = true\n  '';\n  # plugins accepts a list of either plugins or { plugin = ...; config = ..vimscript.. };\n  plugins = with vimPlugins; [\n    {\n      plugin = vim-obsession;\n      config = ''\n        map <Leader>$ <Cmd>Obsession<CR>\n      '';\n    }\n    (nvim-treesitter.withPlugins (p: [ p.nix p.python ]))\n    hex-nvim\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating NIXOS and NIXOS_LUSTRATE Marker Files (Shell)\nDESCRIPTION: Creates the marker files /etc/NIXOS and /etc/NIXOS_LUSTRATE that signal to the NixOS boot scripts to recognize the system as NixOS and to perform lustration (moving existing root files to /old-root). No input required. Output: Two marker files created with sudo.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_12\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo touch /etc/NIXOS\\n$ sudo touch /etc/NIXOS_LUSTRATE\n```\n\n----------------------------------------\n\nTITLE: Setting and Accessing Passthru Attributes in Nix\nDESCRIPTION: An example showing how to define passthru attributes in a derivation and access them after definition. The example sets simple string values and nested attribute sets that can be referenced directly from the derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/passthru.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchGit }:\nlet\n  hello = stdenv.mkDerivation {\n    pname = \"hello\";\n    src = fetchGit {\n      # ...\n    };\n\n    passthru = {\n      foo = \"bar\";\n      baz = {\n        value1 = 4;\n        value2 = 5;\n      };\n    };\n  };\nin\nhello.baz.value1\n```\n\n----------------------------------------\n\nTITLE: Configuring X Server Keyboard Variant in NixOS\nDESCRIPTION: Shows how to set the Programmer Dvorak Keyboard Layout variant for the X server in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\nservices.xserver.xkbVariant = \"dvp\";\n```\n\n----------------------------------------\n\nTITLE: Composing Custom Android SDK with Specific Plugins - Nix\nDESCRIPTION: Demonstrates importing a Nix package set and composing a custom Android SDK using androidenv.composeAndroidPackages. Offers explicit control over platform versions, system image types, ABI versions, and plugin inclusion (e.g., NDK, extras). The output is 'androidComposition.androidsdk', an SDK derivation tailored for the specified parameters. Suitable for developers requiring repeatable and fine-tuned Android SDK environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlet\n  androidComposition = androidenv.composeAndroidPackages {\n    platformVersions = [\n      \"34\"\n      \"35\"\n    ];\n    systemImageTypes = [ \"google_apis_playstore\" ];\n    abiVersions = [\n      \"armeabi-v7a\"\n      \"arm64-v8a\"\n    ];\n    includeNDK = true;\n    includeExtras = [\n      \"extras;google;auto\"\n    ];\n  };\nin\nandroidComposition.androidsdk\n```\n\n----------------------------------------\n\nTITLE: Disabling NixOS Firewall - Nix\nDESCRIPTION: This snippet demonstrates how to disable the NixOS stateful firewall by setting the \\'networking.firewall.enable\\' attribute to false in a NixOS configuration file. There are no external dependencies apart from running within a NixOS system. Set this configuration in your /etc/nixos/configuration.nix, and after applying it (typically via \\'nixos-rebuild switch\\'), all firewall functionality will be turned off for both IPv4 and IPv6 interfaces.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/firewall.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading a File Using fetchurl - Nix Language\nDESCRIPTION: This snippet shows how to use the 'fetchurl' function in Nix to download a specific file from a remote URL and verify its integrity using a provided hash. Dependencies are minimal, requiring only the 'fetchurl' function. The key parameters are 'url' (the file location) and 'hash' (the fixed-output hash). The output is a path in the Nix store holding the downloaded file. This is the canonical way to fetch remote content in a Nix derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  url = \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\";\n  hash = \"sha256-BZqI7r0MNP29yGH5+yW2tjU9OOpOCEvwWKrWCv5CQ0I=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Gem-specific Build Settings in Ruby Derivation\nDESCRIPTION: Demonstrates how to override default gem configurations in a Ruby derivation. This is useful for gems with native extensions or specific build requirements.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pg_version ? \"10\",\n  pkgs ? import <nixpkgs> { },\n}:\nlet\n  myRuby = pkgs.ruby.override {\n    defaultGemConfig = pkgs.defaultGemConfig // {\n      pg = attrs: {\n        buildFlags = [ \"--with-pg-config=${pkgs.\"postgresql_${pg_version}\".pg_config}/bin/pg_config\" ];\n      };\n    };\n  };\nin\nmyRuby.withPackages (ps: with ps; [ pg ])\n```\n\n----------------------------------------\n\nTITLE: Configuring NixOS for Nvidia GPU Support with Docker\nDESCRIPTION: NixOS configuration to enable Nvidia GPU support via docker. This setup ensures the nvidia-container-runtime is accessible to the system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/NVIDIA.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nvirtualisation.docker = {\n  enable = true;\n  enableNvidia = true;\n};\nenvironment.systemPackages = with pkgs; [ docker runc ];\n```\n\n----------------------------------------\n\nTITLE: Migrating Redis Database for Mastodon - Bash\nDESCRIPTION: Demonstrates how to manually save the current Redis database to disk and copy the resulting RDB file to the new data directory dedicated for the Mastodon instance. Requires that the redis-cli tool is installed and proper permissions to access Redis data directories. Intended as a pre-upgrade migration step during changes to Redis server deployment; input is the current running state of Redis, output is a saved RDB snapshot moved to the new location.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nredis-cli save\ncp /var/lib/redis/dump.rdb \"/var/lib/redis-mastodon/dump.rdb\"\n```\n\n----------------------------------------\n\nTITLE: Defining Custom XKB Symbols for US-Greek Layout in Plain Text\nDESCRIPTION: Defines a custom XKB symbols file extending the standard US layout, adding a third-level switch to type Greek symbols with the right Alt key. Requires the base XKB infrastructure and proper file placement in the 'symbols' directory for Xorg to recognize it. Input keys like <LatA> and <LatB> are mapped to Latin and Greek characters; output is an XKB symbols file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_21\n\nLANGUAGE: plain text\nCODE:\n```\nxkb_symbols \"us-greek\"\n{\n  include \"us(basic)\"            // includes the base US keys\n  include \"level3(ralt_switch)\"  // configures right alt as a third level switch\n\n  key <LatA> { [ a, A, Greek_alpha ] };\n  key <LatB> { [ b, B, Greek_beta  ] };\n  key <LatG> { [ g, G, Greek_gamma ] };\n  key <LatD> { [ d, D, Greek_delta ] };\n  key <LatZ> { [ z, Z, Greek_zeta  ] };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and Enrolling a FIDO2 Key for LUKS Unlocking - ShellSession\nDESCRIPTION: This snippet illustrates creating a FIDO2 credential for unlocking a LUKS device and enrolling it using 'fido2luks'. The process involves exporting a label, generating the credential, and adding it as a key to the specified LUKS device with password prompts. Dependencies are 'fido2luks' and an eligible FIDO2 hardware token. Inputs are device paths and hardware token; output is the new credential associated with the encrypted volume.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# export FIDO2_LABEL=\"/dev/sda2 @ $HOSTNAME\"\\n# fido2luks credential \"$FIDO2_LABEL\"\\nf1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\\n\\n# fido2luks -i add-key /dev/sda2 f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\\nPassword:\\nPassword (again):\\nOld password:\\nOld password (again):\\nAdded to key to device /dev/sda2, slot: 2\n```\n\n----------------------------------------\n\nTITLE: Launching X with Custom XKB Directory Using xinit (ShellSession)\nDESCRIPTION: Provides a shell command to start the X server manually with a specified XKB directory, ensuring custom layouts are discoverable. Inputs: path to XKB directory; output: new X session launched; prerequisites: xinit and appropriate file placement under /etc/X11/xkb.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_29\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ xinit -- -xkbdir /etc/X11/xkb\n```\n\n----------------------------------------\n\nTITLE: Adding Plugins to JetBrains IDEs using Nix - Nix Expression - nix\nDESCRIPTION: Demonstrates how to augment a JetBrains IDE build with additional plugins by invoking the 'jetbrains.plugins.addPlugins' attribute in Nix. This approach supports specifying plugins by their IDs, names (as referenced in plugins.json), or direct derivation references to .jar or .zip files. This method is suitable in Nix-based workflows for customizing IDE builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jetbrains/readme.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\njetbrains.plugins.addPlugins jetbrains.pycharm-professional [ \"nixidea\" ]\n```\n\n----------------------------------------\n\nTITLE: Derivation Example for WeeChat Script Package - Nix\nDESCRIPTION: This derivation defines a build for a WeeChat script package using standard Nix syntax. It fetches sources, declares output scripts via 'passthru.scripts', and installs scripts into '$out/share'. Dependencies include Nix build tools and fetchurl, and scripts must be in '$out/share' to be recognized. Inputs are 'stdenv' and 'fetchurl', outputs are store paths with scripts. Intended for use within Nixpkgs for new WeeChat script packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchurl }:\n\nstdenv.mkDerivation {\n  name = \"exemplary-weechat-script\";\n  src = fetchurl {\n    url = \"https://scripts.tld/your-scripts.tar.gz\";\n    hash = \"...\";\n  };\n  passthru.scripts = [\n    \"foo.py\"\n    \"bar.lua\"\n  ];\n  installPhase = ''\n    mkdir $out/share\n    cp foo.py $out/share\n    cp bar.lua $out/share\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Importing Docker Image into Docker Daemon - Shell\nDESCRIPTION: This shell snippet demonstrates the full workflow of building a Docker image tarball with Nix, then importing it with `docker image import` and listing it via `docker image ls`. It expects a compatible tar archive and a local Docker daemon. Outputs include the new image's SHA ID and metadata. This workflow enables deployment of Nix-built images into Docker environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/x6a5m7c6zdpqz1d8j7cnzpx9glzzvd2h-hello\n$ docker image import /nix/store/x6a5m7c6zdpqz1d8j7cnzpx9glzzvd2h-hello\nsha256:1d42dba415e9b298ea0decf6497fbce954de9b4fcb2984f91e307c8fedc1f52f\n$ docker image ls\nREPOSITORY                              TAG                IMAGE ID       CREATED         SIZE\n<none>                                  <none>             1d42dba415e9   4 seconds ago   32.6MB\n\n```\n\n----------------------------------------\n\nTITLE: Granting File Access to crab-hole Service via supplementaryGroups - Nix\nDESCRIPTION: This snippet grants the crab-hole service access to files owned by an external group, such as those created by ACME for TLS certificates. It sets the 'supplementaryGroups' option to include the group name (e.g., 'acme'). Input is the list of group names; output is additional group privileges for the service process, required when file permissions do not match the service user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.supplementaryGroups = [ \"acme\" ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting the Default X11 Session in NixOS 20.03+ Using Nix - nix\nDESCRIPTION: This snippet shows the new recommended way to specify the default X11 session in NixOS releases 20.03 and later. By setting 'services.xserver.displayManager.defaultSession' to a combined session string such as 'xfce+icewm', the system will start both the xfce desktop manager and icewm window manager by default. This configuration, written in Nix, replaces older options and should be placed in the system's configuration.nix file. This requires the relevant desktop and window managers to be included in the configuration and installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.defaultSession = \"xfce+icewm\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Babeld Service in NixOS\nDESCRIPTION: Demonstrates the new configuration for the Babeld service in NixOS, which now runs as an unprivileged user and requires additional sysctls settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\nservices.babeld = {\n  enable = true;\n  interfaces = {\n    \"eth0\" = {};\n    \"wlan0\" = {};\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Building kexec Boot Artifacts with Nix - ShellSession\nDESCRIPTION: Runs a nix-build command targeting the kexec boot artifacts for x86_64-linux, using the release.nix from the nixpkgs project. Produces a result directory containing a kernel, initrd, and kexec-boot script necessary for launching NixOS via kexec. Dependency: Requires nix to be installed and a NixOS-compatible channel/environment. Input is the attribute path for the kexec builder; output is a ./result directory with symlinked boot files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-kexec.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-build -A kexec.x86_64-linux '<nixpkgs/nixos/release.nix>'\n```\n\n----------------------------------------\n\nTITLE: Configuring FileSender with SimpleSAMLphp in NixOS\nDESCRIPTION: A minimal working configuration for setting up FileSender with password authentication using SimpleSAMLphp. This example sets up the FileSender service with local database creation, Nginx configuration, and a basic SimpleSAMLphp auth source with a hardcoded admin user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/filesender.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.php {};\nin\n{\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  services.filesender = {\n    enable = true;\n    localDomain = \"filesender.example.com\";\n    configureNginx = true;\n    database.createLocally = true;\n\n    settings = {\n      auth_sp_saml_authentication_source = \"default\";\n      auth_sp_saml_uid_attribute = \"uid\";\n      storage_filesystem_path = \"<STORAGE PATH FOR UPLOADED FILES>\";\n      admin = \"admin\";\n      admin_email = \"admin@example.com\";\n      email_reply_to = \"noreply@example.com\";\n    };\n  };\n  services.simplesamlphp.filesender = {\n    settings = {\n      \"module.enable\".exampleauth = true;\n    };\n    authSources = {\n      admin = [ \"core:AdminPassword\" ];\n      default = format.lib.mkMixedArray [ \"exampleauth:UserPass\" ] {\n        \"admin:admin123\" = {\n          uid = [ \"admin\" ];\n          cn = [ \"admin\" ];\n          mail = [ \"admin@example.com\" ];\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Cargo Lock File for Dependencies\nDESCRIPTION: Example of using importCargoLock to import dependencies from a Cargo.lock file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{\n  cargoDeps = rustPlatform.importCargoLock {\n    lockFile = ./Cargo.lock;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Example of NixOS Option Type Error Message (Boolean Expected) - Plain Text - plain\nDESCRIPTION: Shows the error message given when an option value is of an incorrect type (for example, string instead of boolean). Helps users understand NixOS's type checking for option definitions. Output is plain text, used for reference/documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_4\n\nLANGUAGE: plain\nCODE:\n```\nThe option value `services.httpd.enable' in `/etc/nixos/configuration.nix' is not a boolean.\n```\n\n----------------------------------------\n\nTITLE: Setting Transmission RPC Bind Address - Nix\nDESCRIPTION: This configuration overrides the default local binding for Transmission's Remote Procedure Call interface, enabling it to listen on all network interfaces. It must be placed within the NixOS configuration and presumes that the 'services.transmission' module is enabled. The 'rpc-bind-address' key is set in the Transmission settings, and the value '0.0.0.0' is used to restore pre-20.09 behavior. Misconfiguration can expose the service beyond trusted networks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.transmission.settings.rpc-bind-address = \"0.0.0.0\";\n}\n```\n\n----------------------------------------\n\nTITLE: Testing XKB Layouts with Shell Commands (ShellSession)\nDESCRIPTION: Demonstrates how to use nix-shell to provide the xkbcomp utility and test the custom 'us-greek' layout. The commands set up the environment and compile the layout for the current X session without system-wide installation. Required dependencies: xorg.xkbcomp, setxkbmap; expected output is layout activation or error diagnostics.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_23\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p xorg.xkbcomp\n$ setxkbmap -I/yourpath us-greek -print | xkbcomp -I/yourpath - $DISPLAY\n```\n\n----------------------------------------\n\nTITLE: Packaging a Custom Vim Plugin in NixOS\nDESCRIPTION: Example showing how to package a custom Vim plugin that isn't already in nixpkgs. It demonstrates fetching the plugin from GitHub and adding it to a Neovim configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\nlet\n  easygrep = pkgs.vimUtils.buildVimPlugin {\n    name = \"vim-easygrep\";\n    src = pkgs.fetchFromGitHub {\n      owner = \"dkprice\";\n      repo = \"vim-easygrep\";\n      rev = \"d0c36a77cc63c22648e792796b1815b44164653a\";\n      hash = \"sha256-bL33/S+caNmEYGcMLNCanFZyEYUOUmSsedCVBn4tV3g=\";\n    };\n  };\nin\n{\n  environment.systemPackages = [\n    (pkgs.neovim.override {\n      configure = {\n        packages.myPlugins = with pkgs.vimPlugins; {\n          start = [\n            vim-go # already packaged plugin\n            easygrep # custom package\n          ];\n          opt = [ ];\n        };\n        # ...\n      };\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Build and Install Phases - Nix\nDESCRIPTION: This derivation replaces the default buildPhase and installPhase with custom multi-line shell scripts for packages lacking a standard makefile. The buildPhase compiles foo.c to foo, and installPhase installs the resulting binary to $out/bin. It demonstrates phase customization via ''-style string literals, leveraging runHook to insert hook logic. All variables such as $out are injected by stdenv during the build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  pname = \"fnord\";\n  version = \"4.5\";\n\n  # ...\n\n  buildPhase = ''\n    runHook preBuild\n\n    gcc foo.c -o foo\n\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/bin\n    cp foo $out/bin\n\n    runHook postInstall\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Authentication for Mosquitto in NixOS\nDESCRIPTION: Example configuration for setting up TLS authentication in Mosquitto. It changes the port to 8883 and specifies paths for CA file, certificate file, and key file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/mosquitto.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mosquitto = {\n    enable = true;\n    listeners = [ {\n      port = 8883; # port change is not required, but helpful to avoid mistakes\n      # ...\n      settings = {\n        cafile = \"/path/to/mqtt.ca.pem\";\n        certfile = \"/path/to/mqtt.pem\";\n        keyfile = \"/path/to/mqtt.key\";\n      };\n    } ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Exploration of Configuration with nix repl - Shell Session\nDESCRIPTION: This code sample shows how to use the Nix REPL to examine live configuration details such as network host names and virtual host mappings. Dependencies: The 'nix' command with repl support and system channel configured for <nixpkgs/nixos>. Inputs: Arbitrary attribute paths in the repl; Output: Current configuration attribute values. Useful for examining deeply merged or computed config values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_7\n\nLANGUAGE: shellsession\nCODE:\n```\n$ nix repl '<nixpkgs/nixos>'\n\nnix-repl> config.networking.hostName\n\"mandark\"\n\nnix-repl> map (x: x.hostName) config.services.httpd.virtualHosts\n[ \"example.org\" \"example.gov\" ]\n```\n\n----------------------------------------\n\nTITLE: Packaging a Rust Application with buildRustPackage - Nix Expressions - Nix\nDESCRIPTION: Demonstrates how to use the `buildRustPackage` function from `rustPlatform` to package a Rust application (here, `ripgrep`). The snippet sets source via `fetchFromGitHub`, manages dependencies with `useFetchCargoVendor` and `cargoHash`, and provides package metadata. Required before use: definitions of `lib`, `fetchFromGitHub`, and `rustPlatform` in the calling scope. Key parameters include package name, version, hash, and descriptions; output is a derivation of the built package. Limitations include the need to update hashes when sources or dependencies change.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchFromGitHub,\n  rustPlatform,\n}:\n\nrustPlatform.buildRustPackage (finalAttrs: {\n  pname = \"ripgrep\";\n  version = \"14.1.1\";\n\n  src = fetchFromGitHub {\n    owner = \"BurntSushi\";\n    repo = \"ripgrep\";\n    tag = finalAttrs.version;\n    hash = \"sha256-gyWnahj1A+iXUQlQ1O1H1u7K5euYQOld9qWm99Vjaeg=\";\n  };\n\n  useFetchCargoVendor = true;\n  cargoHash = \"sha256-9atn5qyBDy4P6iUoHFhg+TV6Ur71fiah4oTJbBMeEy4=\";\n\n  meta = {\n    description = \"Fast line-oriented regex search tool, similar to ag and ack\";\n    homepage = \"https://github.com/BurntSushi/ripgrep\";\n    license = lib.licenses.unlicense;\n    maintainers = [ ];\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Portable Service Image with pkgs.portableService (Nix)\nDESCRIPTION: This Nix code snippet demonstrates how to use pkgs.portableService to build a portable service image containing the hello package and its systemd unit. Dependencies include Nixpkgs functions such as lib, writeText, and portableService, as well as the hello package. The hello-service unit is defined as a oneshot service that executes the hello binary. The main output is a .raw disk image in the Nix store, suitable for attachment via systemd portablectl. The parameters are pname, version, and units, with the unit file name matching specification requirements. Input variables must be available in the build environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/portableservice.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  writeText,\n  portableService,\n  hello,\n}:\nlet\n  hello-service = writeText \"hello.service\" ''\n    [Unit]\n    Description=Hello world service\n\n    [Service]\n    Type=oneshot\n    ExecStart=${lib.getExe hello}\n  '';\nin\nportableService {\n  pname = \"hello\";\n  inherit (hello) version;\n  units = [ hello-service ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using Overlays to Override Package Versions in Nix Shells - Nix Language\nDESCRIPTION: This snippet demonstrates the use of Nix overlays to override package attributes, specifically altering the Elixir package version and hash for the development shell. It composes an overlay, inserts it into the overlays attribute upon importing Nixpkgs, and uses mkShell to inject the customized Elixir version into the environment. Dependencies are the overlay mechanism and mkShell; parameters include the desired version and sha256 hash. The output is a development shell with the overridden Elixir version in effect.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  elixir_1_18_1_overlay = (\n    self: super: {\n      elixir_1_18 = super.elixir_1_18.override {\n        version = \"1.18.1\";\n        sha256 = \"sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\";\n      };\n    }\n  );\n  pkgs = import <nixpkgs> { overlays = [ elixir_1_18_1_overlay ]; };\nin\nwith pkgs;\nmkShell {\n  buildInputs = [\n    elixir_1_18\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing gpg-agent for SSH Support - Shell\nDESCRIPTION: This snippet ensures gpg-agent is started for SSH support by running gpg-connect-agent, unsetting the old SSH_AGENT_PID, and exporting the new SSH_AUTH_SOCK path. Should be added to session initialization (e.g., displayManager.sessionCommands) so gpg-agent can manage SSH authentication keys. Assumes gpg-agent is properly configured and user's .gnupg directory exists.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ngpg-connect-agent /bye\nunset SSH_AGENT_PID\nexport SSH_AUTH_SOCK=\"''${HOME}/.gnupg/S.gpg-agent.ssh\"\n```\n\n----------------------------------------\n\nTITLE: Configuring pytestCheckHook with Test Paths and Flags\nDESCRIPTION: Shows comprehensive usage of pytestCheckHook attributes including enabling/disabling specific test paths, test method names, and adding pytest flags. This allows fine-grained control over which tests run during package testing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_34\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeCheckInputs = [\n    pytestCheckHook\n  ];\n\n  # Allow running the following test paths and test objects.\n  enabledTestPaths = [\n    # Find tests under the tests directory.\n    # The trailing slash is not necessary.\n    \"tests/\"\n\n    # Additionally run test_foo\n    \"other-tests/test_foo.py::Foo::test_foo\"\n  ];\n\n  # Override the above-enabled test paths and test objects.\n  disabledTestPaths = [\n    # Tests under tests/integration requires additional data.\n    \"tests/integration\"\n  ];\n\n  # Allow tests by keywords matching their class names or method names.\n  enabledTests = [\n    # pytest by default only runs test methods begin with \"test_\" or end with \"_test\".\n    # This includes all functions whose name contains \"test\".\n    \"test\"\n  ];\n\n  # Override the above-enabled tests by keywords matching their class names or method names.\n  disabledTests = [\n    # Tests touching networks.\n    \"upload\"\n    \"download\"\n  ];\n\n  # Additional pytest flags\n  pytestFlags = [\n    # Disable benchmarks and run benchmarking tests only once.\n    \"--benchmark-disable\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Both 'master' and 'node' Roles - NixOS Kubernetes Module - Nix\nDESCRIPTION: Assigns both 'master' and 'node' roles to a single host using 'services.kubernetes.roles = [ \"master\" \"node\" ];'. This allows the node to act as both a control plane and worker, enabling quick development or testing clusters. Dependencies are the NixOS Kubernetes module, and flannel and easyCerts options default to enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/kubernetes.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.kubernetes.roles = [ \"master\" \"node\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TigerBeetle Addresses and Firewall - Nix - Nix\nDESCRIPTION: This Nix code configures TigerBeetle to listen on all network interfaces at port 3001 by setting the addresses option and ensures the firewall allows traffic to that port by updating networking.firewall.allowedTCPPorts. The configuration enables TigerBeetle and customizes its network binding, while also modifying the system firewall. There are no external dependencies, but users must ensure external ports are explicitly opened as shown. Inputs are the addresses and allowedTCPPorts lists; output is an operational TigerBeetle instance listening externally. Care should be taken to only expose TigerBeetle in secure environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/tigerbeetle.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.tigerbeetle = {\n    enable = true;\n    addresses = [ \"0.0.0.0:3001\" ];\n  };\n\n  networking.firewall.allowedTCPPorts = [ 3001 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Scripting PostgreSQL Major Upgrade with Cluster Migration - NixOS Module/Script - Nix\nDESCRIPTION: Implements a full NixOS module fragment to add a system package for PostgreSQL cluster upgrades. The script stops the old cluster, initializes a new data directory, and invokes pg_upgrade with the proper PostgreSQL binaries and configuration. Dependencies include access to Nix package attributes for both new and old postgres, as well as systemd. Key parameters are new and old data/bin paths, and initdb args. Inputs are shell arguments for tuning pg_upgrade; outputs are a reusable upgrade-pg-cluster system command for safe, auditable upgrades. The upgrade requires manual invocation and careful management of service and data state.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n{\n  environment.systemPackages = [\n    (let\n      # XXX specify the postgresql package you'd like to upgrade to.\n      # Do not forget to list the extensions you need.\n      newPostgres = pkgs.postgresql_13.withPackages (pp: [\n        # pp.plv8\n      ]);\n      cfg = config.services.postgresql;\n    in pkgs.writeScriptBin \"upgrade-pg-cluster\" ''\n      set -eux\n      # XXX it's perhaps advisable to stop all services that depend on postgresql\n      systemctl stop postgresql\n\n      export NEWDATA=\"/var/lib/postgresql/${newPostgres.psqlSchema}\"\n      export NEWBIN=\"${newPostgres}/bin\"\n\n      export OLDDATA=\"${cfg.dataDir}\"\n      export OLDBIN=\"${cfg.finalPackage}/bin\"\n\n      install -d -m 0700 -o postgres -g postgres \"$NEWDATA\"\n      cd \"$NEWDATA\"\n      sudo -u postgres \"$NEWBIN/initdb\" -D \"$NEWDATA\" ${lib.escapeShellArgs cfg.initdbArgs}\n\n      sudo -u postgres \"$NEWBIN/pg_upgrade\" \\\n        --old-datadir \"$OLDDATA\" --new-datadir \"$NEWDATA\" \\\n        --old-bindir \"$OLDBIN\" --new-bindir \"$NEWBIN\" \\\n        \"$@\"\n    '')\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Tcl Derivations Using mkTclDerivation in Nix\nDESCRIPTION: This snippet illustrates the definition of a Nix expression that leverages mkTclDerivation to create a Tcl package. It expects lib, mkTclDerivation, and tcllib as input arguments, which are standard dependencies for Tcl package builds in the Nix ecosystem. The ellipsis inside mkTclDerivation indicates where specific package configuration and attributes should be added to customize the derivation. The output is a Nix expression ready for integration in a name-based Tcl package directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/tcl-modules/by-name/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ lib\\n# You can get tclPackages attributes directly\\n, mkTclDerivation\\n, tcllib\\n}:\\n\\nmkTclDerivation {\\n  # ...\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Generating DNS Keys and Secrets for ACME in NixOS\nDESCRIPTION: This snippet demonstrates how to create a systemd service to generate DNS keys and secrets for ACME configuration in NixOS. It includes creating dnskeys.conf and certs.secret files securely.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.dns-rfc2136-conf = {\n    requiredBy = [\"acme-example.com.service\" \"bind.service\"];\n    before = [\"acme-example.com.service\" \"bind.service\"];\n    unitConfig = {\n      ConditionPathExists = \"!/var/lib/secrets/dnskeys.conf\";\n    };\n    serviceConfig = {\n      Type = \"oneshot\";\n      UMask = 0077;\n    };\n    path = [ pkgs.bind ];\n    script = ''\n      mkdir -p /var/lib/secrets\n      chmod 755 /var/lib/secrets\n      tsig-keygen rfc2136key.example.com > /var/lib/secrets/dnskeys.conf\n      chown named:root /var/lib/secrets/dnskeys.conf\n      chmod 400 /var/lib/secrets/dnskeys.conf\n\n      # extract secret value from the dnskeys.conf\n      while read x y; do if [ \"$x\" = \"secret\" ]; then secret=\"${y:1:${#y}-3}\"; fi; done < /var/lib/secrets/dnskeys.conf\n\n      cat > /var/lib/secrets/certs.secret << EOF\n      RFC2136_NAMESERVER='127.0.0.1:53'\n      RFC2136_TSIG_ALGORITHM='hmac-sha256.'\n      RFC2136_TSIG_KEY='rfc2136key.example.com'\n      RFC2136_TSIG_SECRET='$secret'\n      EOF\n      chmod 400 /var/lib/secrets/certs.secret\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using PHP with Extensions in Nix Shell\nDESCRIPTION: Demonstrates how to create a temporary environment in nix-shell with a PHP interpreter that has specific extensions enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nnix-shell -p 'php.withExtensions ({ all, ... }: with all; [ imagick opcache ])'\n```\n\n----------------------------------------\n\nTITLE: Sudo Credential Installation Output - ShellSession\nDESCRIPTION: Example terminal output from running the darwin.linux-builder flake. Shows the invocation of a privileged script used to install SSH credentials, followed by a password prompt. Indicates that the process requires sudo privileges at this stage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n+ sudo --reset-timestamp /nix/store/…-install-credentials.sh ./keys\nPassword:\n\n```\n\n----------------------------------------\n\nTITLE: Forcing Display Modes with NixOS Hardware Options - Nix\nDESCRIPTION: This snippet demonstrates how to forcefully enable or disable specific video outputs by setting their modes in the NixOS hardware.display.outputs option. It directly manipulates the hardware configuration to skip certain graphics driver checks, such as those for 'amdgpu', and reflects equivalent kernel parameter changes made via boot.kernelParams. No external dependencies are required beyond standard NixOS Nix language support. Input is a Nix attribute set specifying output names and modes; output is integrated system configuration to enforce hardware behavior.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # force enabled output to skip `amdgpu` checks\n  hardware.display.outputs.\"DP-1\".mode = \"e\";\n  # completely disable output no matter what is connected to it\n  hardware.display.outputs.\"VGA-2\".mode = \"d\";\n\n  /* equals\n  boot.kernelParams = [ \"video=DP-1:e\" \"video=VGA-2:d\" ];\n  */\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nix Garbage Collector Manually (Shell - ShellSession)\nDESCRIPTION: This command runs the Nix garbage collector, which removes unreferenced packages from the Nix store to free up disk space. It takes no parameters and simply initiates garbage collection; the command must be run from a shell environment with the appropriate permissions. The output indicates what was cleaned up, and this operation does not remove garbage collection roots or system rollbacks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ nix-collect-garbage\\n```\n```\n\n----------------------------------------\n\nTITLE: Global Package Override in NixOS\nDESCRIPTION: Configuration for applying global package overrides that affect all dependent packages, demonstrated with an Emacs GTK version modification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/customizing-packages.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config.packageOverrides = pkgs:\n    { emacs = pkgs.emacs.override { gtk = pkgs.gtk3; };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Swaylock Systemd User Service with NixOS Module - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to enable the systemd-lock-handler service and define a user-level systemd service for swaylock that integrates with logind session events. The configuration sets the service to start on lock.target, manage dependencies and start order, and defines behavioral options such as automatic restart and service type. Required prerequisites are the NixOS environment with systemd, the swaylock package, and proper user-level systemd integration. Inputs include service attributes; outputs are the resulting service files and behaviors on session lock/unlock.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/system/systemd-lock-handler.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.systemd-lock-handler.enable = true;\n\n  systemd.user.services.swaylock = {\n    description = \"Screen locker for Wayland\";\n    documentation = [\"man:swaylock(1)\"];\n\n    # If swaylock exits cleanly, unlock the session:\n    onSuccess = [\"unlock.target\"];\n\n    # When lock.target is stopped, stops this too:\n    partOf = [\"lock.target\"];\n\n    # Delay lock.target until this service is ready:\n    before = [\"lock.target\"];\n    wantedBy = [\"lock.target\"];\n\n    serviceConfig = {\n      # systemd will consider this service started when swaylock forks...\n      Type = \"forking\";\n\n      # ... and swaylock will fork only after it has locked the screen.\n      ExecStart = \"${lib.getExe pkgs.swaylock} -f\";\n\n      # If swaylock crashes, always restart it immediately:\n      Restart = \"on-failure\";\n      RestartSec = 0;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Phases in Nix Derivation\nDESCRIPTION: Demonstrates the default value of the 'phases' variable, which specifies the order of execution for build phases in a Nix derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases\n```\n\n----------------------------------------\n\nTITLE: Enabling WeeChat Service in NixOS - Nix\nDESCRIPTION: This snippet demonstrates how to enable the 'weechat' system service by setting 'services.weechat.enable = true;' in a NixOS configuration block. It ensures that WeeChat runs as a background service managed by systemd in a detached screen session. There are no required parameters other than the attribute being set to true, and no additional dependencies beyond NixOS's system modules. The configuration expects the NixOS module system and takes effect after rebuilding the system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/weechat.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.weechat.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating NixOS Configuration Options Documentation in Markdown\nDESCRIPTION: This snippet defines parameters for generating a list of NixOS configuration options. It specifies the ID prefix, list ID, and the source JSON file for the options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/nixos-options.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} options\nid-prefix: opt-\nlist-id: configuration-variable-list\nsource: @NIXOS_OPTIONS_JSON@\n```\n```\n\n----------------------------------------\n\nTITLE: Erasing LuaLaTeX Font Cache - Shell Command - ShellSession\nDESCRIPTION: Shows the shell command for forcefully erasing the LuaLaTeX font cache using luaotfload-tool. This is used to resolve cache divergence between the user environment and the Nix store, which may lead to font problems. Prerequisite: The luaotfload-tool must be installed and available in PATH.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\nluaotfload-tool --cache=erase --flush-lookups --force\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Exporter Prometheus Endpoint\nDESCRIPTION: Example of a Prometheus scrape configuration URL for the JSON exporter's probe endpoint.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nhttp://some.json-exporter.host:7979/probe?target=https://example.com/some/json/endpoint\n```\n\n----------------------------------------\n\nTITLE: Enabling AppImage Support in Configuration (Nix, nix)\nDESCRIPTION: Configures NixOS to enable AppImage support by setting appropriate flags under programs.appimage in configuration.nix. Prerequisite: NixOS configuration context. Inputs: Boolean flags. Output: system-wide AppImage support after rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  programs.appimage.enable = true;\\n  programs.appimage.binfmt = true;\\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Debian Patch with fetchDebianPatch in buildPythonPackage - Nix\nDESCRIPTION: This example shows how to use fetchDebianPatch to retrieve and normalize a patch file from the Debian archive and apply it within a Nixpkgs buildPythonPackage expression. The snippet requires the lib, fetchDebianPatch, and buildPythonPackage attributes. Key parameters include the Debian revision, patch filename, hash, pnane, and version. The dependency must correspond to a still-available Debian package version, and hash must be computed after normalization. The result is a Python package where the specified patch is applied.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchDebianPatch,\n  buildPythonPackage,\n}:\n\nbuildPythonPackage rec {\n  pname = \"pysimplesoap\";\n  version = \"1.16.2\";\n  src = <...>;\n\n  patches = [\n    (fetchDebianPatch {\n      inherit pname version;\n      debianRevision = \"5\";\n      patch = \"Add-quotes-to-SOAPAction-header-in-SoapClient.patch\";\n      hash = \"sha256-xA8Wnrpr31H8wy3zHSNfezFNjUJt1HbSXn3qUMzeKc0=\";\n    })\n  ];\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Declaratively in NixOS Configuration - Nix - nix\nDESCRIPTION: This snippet shows how to define a user named 'alice' declaratively in the 'configuration.nix' file, assigning group memberships, home directory, a description, and SSH authorized keys. Dependencies include the NixOS user management system. Key keys are: 'isNormalUser' (enable regular account), 'home' (home directory path), 'extraGroups' (supplementary Unix groups), and SSH keys for secure, passwordless authentication. No password is set by default, so login via password requires setting a password manually or specifying a hashed password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.alice = {\n    isNormalUser = true;\n    home = \"/home/alice\";\n    description = \"Alice Foobar\";\n    extraGroups = [ \"wheel\" \"networkmanager\" ];\n    openssh.authorizedKeys.keys = [ \"ssh-dss AAAAB3Nza... alice@foobar\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maubot Admin User in YAML\nDESCRIPTION: This YAML snippet shows how to add an admin user to the Maubot configuration file. It includes the username and a bcrypt-hashed password for authentication to the Maubot web UI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/maubot.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nadmins:\n    admin_username: $2b$12$g.oIStUeUCvI58ebYoVMtO/vb9QZJo81PsmVOomHiNCFbh0dJpZVa\n```\n\n----------------------------------------\n\nTITLE: Downloading CUDA Redistributable Manifests Using Nix CLI - Bash\nDESCRIPTION: This Bash snippet demonstrates the use of 'nix run' to download CUDA redistributable manifests for a specified CUDA version. The script utilizes the 'cuda-redist-find-features' tool from GitHub with the 'download-manifests' command, logging at DEBUG level, and outputs manifests to a designated directory. Inputs required include the target CUDA version and the output path. Dependencies include 'nix' CLI, access to GitHub, and the 'cuda-redist-find-features' utility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnix run github:connorbaker/cuda-redist-find-features -- \\\n   download-manifests \\\n   --log-level DEBUG \\\n   --version <newest CUDA version> \\\n   https://developer.download.nvidia.com/compute/cuda/redist \\\n   ./pkgs/development/cuda-modules/cuda/manifests\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Mediatomb Media Directories in NixOS\nDESCRIPTION: Example configuration for declaring autoscan media directories in the Mediatomb service using the new mediaDirectories option. Allows specifying paths with recursive scanning and hidden files settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.mediatomb.mediaDirectories = [\n      { path = \"/var/lib/mediatomb/pictures\"; recursive = false; hidden-files = false; }\n      { path = \"/var/lib/mediatomb/audio\"; recursive = true; hidden-files = false; }\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding INDI Drivers in Nix\nDESCRIPTION: Example of how to override the indi-with-drivers package to include additional drivers after the removal of non-free drivers from indi-full.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\npkgs.indi-with-drivers.override {extraDrivers = with pkgs.indi-3rdparty; [indi-gphoto];}\n```\n\n----------------------------------------\n\nTITLE: Default PAM UID-limited Rule Example - Nix\nDESCRIPTION: This snippet provides the default LightDM PAM rule that restricts authentication to users with UID >= 1000 (excluding root and service accounts). Useful as a point of comparison with the custom rule allowing root login.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n auth required pam_succeed_if.so uid >= 1000 quiet\n```\n\n----------------------------------------\n\nTITLE: Overriding Kakoune Configuration to Autoload Plugins in NixOS\nDESCRIPTION: This Nix expression overrides the default Kakoune configuration to include autoloaded plugins. It specifically adds the 'parinfer-rust' plugin from the pkgs.kakounePlugins set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/kakoune.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n(kakoune.override {\n  plugins = with pkgs.kakounePlugins; [ parinfer-rust ];\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Mounted FileSystem Using a Nested Set and List - NixOS - nix\nDESCRIPTION: Shows how to define filesystem mount settings with a set containing string and list options. The 'options' attribute uses a list of strings for mount options. Useful for configuring mount points requiring several parameters grouped under one key.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems.\"/boot\" =\n    { device = \"/dev/sda1\";\n      fsType = \"ext4\";\n      options = [ \"rw\" \"data=ordered\" \"relatime\" ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting K3s and Related Data Directories - Shell Command - bash\nDESCRIPTION: This snippet provides commands to recursively delete K3s, node, and several related data directories. It uses 'rm -rf' to force-remove configuration and library directories for rancher, kubelet, longhorn, etcd, and CNI plugins. Dependencies: root privilege is required. Removes all K3s data; irreversible operation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n rm -rf /etc/rancher/{k3s,node};\n rm -rf /var/lib/{rancher/k3s,kubelet,longhorn,etcd,cni}\n```\n\n----------------------------------------\n\nTITLE: Building and Uploading NixOS Image to Azure\nDESCRIPTION: Shell command sequence for building a NixOS image using nix-build and uploading it to Azure. The script uses a basic image configuration from examples/basic/image.nix and creates an Azure-compatible VM image.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/maintainers/scripts/azure-new/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ ./upload-image.sh ./examples/basic/image.nix\n\n...\n+ attr=azbasic\n+ nix-build ./examples/basic/image.nix --out-link azure\n/nix/store/qdpzknpskzw30vba92mb24xzll1dqsmd-azure-image\n...\n95.5 %, 0 Done, 0 Failed, 1 Pending, 0 Skipped, 1 Total, 2-sec Throughput (Mb/s): 932.9565\n...\n/subscriptions/aff271ee-e9be-4441-b9bb-42f5af4cbaeb/resourceGroups/nixos-images/providers/Microsoft.Compute/images/azure-image-todo-makethisbetter\n```\n\n----------------------------------------\n\nTITLE: Allowing Specific TCP Ports via Firewall - NixOS - Nix\nDESCRIPTION: This configuration allows incoming traffic on TCP ports 80 and 443 by specifying them in the \\'networking.firewall.allowedTCPPorts\\' attribute. Intended for NixOS administrators who want to expose web services, the snippet should be added to your NixOS system configuration. No additional dependencies are required. After applying the configuration, the listed ports will be open to external connections, with all other ports still being governed by the firewall rules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/firewall.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Rust Support in Linux Kernel\nDESCRIPTION: Configuration to enable experimental Rust language support in Linux kernel version 6.7 or newer using boot.kernelPatches.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelPatches = [\n    {\n      name = \"Rust Support\";\n      patch = null;\n      features = {\n        rust = true;\n      };\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS Vulkan AMD Driver Configuration with Optional 32-bit Support (nix)\nDESCRIPTION: Provides a NixOS configuration fragment to add Vulkan support for AMD GPUs by setting extraPackages and extraPackages32, and forcing driver selection with environment.variables. Requires pkgs.amdvlk and pkgs.driversi686Linux.amdvlk. Inputs are the relevant pkgs.* attributes. The configuration allows switching between radv and amdvlk and supports 32-bit applications if needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.extraPackages = [\n    pkgs.amdvlk\n  ];\n\n  # To enable Vulkan support for 32-bit applications, also add:\n  hardware.graphics.extraPackages32 = [\n    pkgs.driversi686Linux.amdvlk\n  ];\n\n  # Force radv\n  environment.variables.AMD_VULKAN_ICD = \"RADV\";\n  # Or\n  environment.variables.VK_ICD_FILENAMES =\n    \"/run/opengl-driver/share/vulkan/icd.d/radeon_icd.x86_64.json\";\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a NixOS Container with Inline Configuration - ShellSession\nDESCRIPTION: Updates the 'foo' container with a new configuration provided in-line, enabling the HTTPD service, setting administrator email, and opening TCP port 80 in the firewall. Also demonstrates verifying HTTPD accessibility by curling the container's IP as retrieved with 'nixos-container show-ip'. Note: Inline update overwrites previous configuration.nix. All changes take effect after update.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container update foo --config '\n  services.httpd.enable = true;\n  services.httpd.adminAddr = \"foo@example.org\";\n  networking.firewall.allowedTCPPorts = [ 80 ];\n'\n\n# curl http://$(nixos-container show-ip foo)/\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">…\n```\n\n----------------------------------------\n\nTITLE: Enabling Flatpak Service via NixOS Module - Nix\nDESCRIPTION: This Nix code snippet enables the Flatpak service on NixOS by setting 'services.flatpak.enable' to true in the 'configuration.nix' file. This is the primary step to activate Flatpak support system-wide. No additional dependencies are required beyond NixOS with the Flatpak module present. There are no key parameters other than the boolean value, and the change takes effect after rebuilding the system configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/desktops/flatpak.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.flatpak.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Matrix Synapse Extra Config Files for Secrets - NixOS Modules - Nix\nDESCRIPTION: Configures NixOS to load an additional secrets file for matrix-synapse containing sensitive information such as the registration shared secret. The snippet expects the external secret file to exist and be deployed securely (e.g., using sops-nix or deployment.keys), and the file path to be readable by the matrix-synapse service. Input: the file path to the secret; Output: updated service configuration. Avoids putting secrets in the world-readable Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/synapse.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.matrix-synapse.extraConfigFiles = [\n    \"/run/secrets/matrix-shared-secret\"\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building Haskell Packages from Source Distribution\nDESCRIPTION: A function to build a Haskell package from its source distribution tarball, helping to catch packaging bugs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\nbuildFromSdist drv\n```\n\n----------------------------------------\n\nTITLE: Configuring LUKS Device in NixOS Configuration - nix\nDESCRIPTION: This configuration snippet demonstrates how to instruct NixOS to mount a previously set up LUKS-encrypted device as the root file system on boot. The settings use Nix syntax in 'configuration.nix' to add the device mapping and ensure file systems are mounted automatically. Dependencies are a valid LUKS setup and the correct device UUID/path. Inputs are hardware mapping information; outputs are persistent system boot-time mounts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.initrd.luks.devices.crypted.device = \"/dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d\";\\n  fileSystems.\"/\".device = \"/dev/mapper/crypted\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Session for Auto-login - Nix\nDESCRIPTION: This Nix snippet sets services.displayManager.defaultSession to specify that no desktop environment and the i3 window manager should be used in an auto-login scenario. Ensures that users are logged into i3 directly. Requires i3 window manager to be enabled/installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.displayManager.defaultSession = \"none+i3\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Multiuser Screen Support for WeeChat Sessions - Nix\nDESCRIPTION: This snippet shows how to configure the GNU screen utility for multiuser access by updating the 'screenrc' using the 'programs.screen.screenrc' option in a NixOS configuration block. It sets 'multiuser on' to enable multiuser mode and adds a specified user ('normal_user') to the access control list (ACL) with 'acladd'. This customization allows other users to reattach to the WeeChat screen session, provided they are specified in the ACL. It requires that the 'screen' program is installed and managed via the NixOS module system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/weechat.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.screen.screenrc = ''\n    multiuser on\n    acladd normal_user\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Pulling a Docker Image from a Specific Registry using dockerTools.pullImage - Nix\nDESCRIPTION: This Nix snippet shows how to pull a Docker image (\\\"coreos/etcd\\\") from a third-party registry (quay.io) using dockerTools.pullImage. By specifying the full registry in imageName and providing required attributes for digest, tagging, and hash, this enables custom registries integration with Nix builds. Prerequisites include access to dockerTools, and expected output is a reproducibly named image in the Nix store, adhering to registry and tag conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools }:\ndockerTools.pullImage {\n  imageName = \"quay.io/coreos/etcd\";\n  imageDigest = \"sha256:24a23053f29266fb2731ebea27f915bb0fb2ae1ea87d42d890fe4e44f2e27c5d\";\n  finalImageName = \"etcd\";\n  finalImageTag = \"v3.5.11\";\n  hash = \"sha256-Myw+85f2/EVRyMB3axECdmQ5eh9p1q77FWYKy8YpRWU=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Including Release Notes with Markdown Include Directive - Markdown\nDESCRIPTION: This code snippet demonstrates how to include multiple markdown section files into a master release notes document using the {=include=} directive within a fenced code block. The snippet relies on a Markdown preprocessor or documentation tool that recognizes the {=include=} syntax, and each listed file corresponds to a set of release notes for a specific NixOS release. Key parameters are the file names of each section, which must exist in the repository; the output is a compiled release notes document. The pattern is constrained by the capabilities and configuration of the documentation toolchain used.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/release-notes.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\\nrl-2505.section.md\\nrl-2411.section.md\\nrl-2405.section.md\\nrl-2311.section.md\\nrl-2305.section.md\\nrl-2211.section.md\\nrl-2205.section.md\\nrl-2111.section.md\\nrl-2105.section.md\\nrl-2009.section.md\\nrl-2003.section.md\\nrl-1909.section.md\\nrl-1903.section.md\\nrl-1809.section.md\\nrl-1803.section.md\\nrl-1709.section.md\\nrl-1703.section.md\\nrl-1609.section.md\\nrl-1603.section.md\\nrl-1509.section.md\\nrl-1412.section.md\\nrl-1404.section.md\\nrl-1310.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Complete NixOS Display Configuration Example for Asus PG278Q with AMDGPU - Nix\nDESCRIPTION: This complete configuration snippet combines modeline-based EDID generation and kernel mode forcing for the Asus PG278Q monitor using amdgpu drivers. It defines two modelines via hardware.display.edid.modelines and assigns the generated EDID to the DP-1 output with the mode forced enabled. The main prerequisites are pkgs.edid-generator and compatible amdgpu hardware. Inputs are modeline strings and output assignment; applied result is a NixOS configuration ensuring custom timings and consistent initialization for the monitor.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.display.edid.modelines.\"PG278Q_60\" = \"   241.50   2560 2608 2640 2720   1440 1443 1448 1481   -hsync +vsync\";\n  hardware.display.edid.modelines.\"PG278Q_120\" = \"  497.75   2560 2608 2640 2720   1440 1443 1448 1525   +hsync -vsync\";\n\n  hardware.display.outputs.\"DP-1\".edid = \"PG278Q_60.bin\";\n  hardware.display.outputs.\"DP-1\".mode = \"e\";\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing the checkPhase with Hooks - Nix\nDESCRIPTION: When overriding the default checkPhase in your Nix derivation, this snippet ensures proper setup and teardown of PostgreSQL using the runHook mechanism. 'runHook preCheck' sets up necessary pre-test environment, while 'runHook postCheck' performs any required cleanup. These calls are required when you provide your own checkPhase commands to maintain postgresqlTestHook functionality. The code is written in a Nix-style multiline string (for bash evaluation during build).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/postgresql-test-hook.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\ncheckPhase ''\n  runHook preCheck\n\n  # ... your tests\n\n  runHook postCheck\n''\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Dependencies to Urxvt Plugins in Nix\nDESCRIPTION: This snippet shows how to add extra dependencies to Urxvt plugins without installing them globally. It uses the 'extraDeps' option to provide 'xsel' as a dependency for the clipboard plugin.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nrxvt-unicode.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      pluginsDeps = [ xsel ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying a Custom GHC Compiler for Agda - Nix - nix\nDESCRIPTION: Shows how to override the GHC compiler provided to Agda by passing a custom ghc attribute (e.g., haskell.compiler.ghcHEAD) to agda.withPackages. This is especially useful when advanced features or newer compiler versions are necessary. The attribute set also allows specifying pkgs for additional build tools.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages {\n  pkgs = [\n    # ...\n  ];\n  ghc = haskell.compiler.ghcHEAD;\n}\n```\n\n----------------------------------------\n\nTITLE: Platform Identifiers in NixOS\nDESCRIPTION: List of primary supported platform identifiers in NixOS, showing the hierarchy of support levels from highest (x86_64-linux) to basic support (x86_64-darwin).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/platform-support.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `x86_64-linux`: Highest level of support.\n- `aarch64-linux`: Well supported, with most packages building successfully in CI.\n- `aarch64-darwin`: Receives better support than `x86_64-darwin`.\n- `x86_64-darwin`: Receives some support.\n```\n\n----------------------------------------\n\nTITLE: NixOS Configuration Example - Blender With Packages\nDESCRIPTION: Example showing the new syntax for installing Blender with additional packages using withPackages function\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nblender.withPackages (ps: [ps.bpycv])\n```\n\n----------------------------------------\n\nTITLE: Displaying NixOS Version with Configuration Revision - Shell Utility Option - Markdown\nDESCRIPTION: This entry indicates that the nixos-version utility can now be invoked with --configuration-revision to report the revision of the current system configuration, in addition to the standard version information. Useful inputs include the --configuration-revision flag; output is extra context to help with debugging or identifying running system state.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_21\n\nLANGUAGE: markdown\nCODE:\n```\n- \\`nixos-version\\` now accepts \\`--configuration-revision\\` to display more information about the current generation revision\n```\n\n----------------------------------------\n\nTITLE: Configuring Ignored Missing Dependencies with autoPatchcil in Nix Expressions (Nix)\nDESCRIPTION: Demonstrates how to use the autoPatchcilIgnoreMissingDeps environment variable in a Nix expression for .NET packaging. This allows specifying which missing shared libraries should be ignored by autoPatchcil rather than causing the build to fail, including patterns for ignoring all. This requires that autoPatchcil and the setup hook are available in the build environment, typically when using buildDotnetModule or a custom derivation with .NET support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/autopatchcil.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nautoPatchcilIgnoreMissingDeps = [ \"libcuda.so.1\" \"libcudart.so.1\" ];\n```\n\nLANGUAGE: nix\nCODE:\n```\nautoPatchcilIgnoreMissingDeps = [ \"*\" ];\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Warning Checks for Haskell Packages\nDESCRIPTION: A function to enable all GHC warnings and make the build fail if any are emitted, useful for strict quality control.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\nfailOnAllWarnings drv\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Upstream DNS Resolver Options - Nix\nDESCRIPTION: This snippet illustrates how to pass advanced DNS resolver options to upstream servers in crab-hole. It disables DNSSEC validation for all upstream queries, which is often required due to some servers lacking DNSSEC support. Requires only crab-hole service activation. Input is the options dictionary; output alters DNS validation behavior.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.upstream.options = {\n    validate = false;\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting a NixOS Container - ShellSession\nDESCRIPTION: This snippet shows how to boot the previously created 'foo' container using the 'start' operation. The command returns when the container reaches the systemd multi-user target. A successful start transforms the container into a systemd service unit accessible for further state inspection. Root privileges required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container start foo\n```\n\n----------------------------------------\n\nTITLE: Updating Discourse Plugins with Python Script - Bash\nDESCRIPTION: This bash command demonstrates how to invoke a Python script to update the Discourse plugins list using the Nixpkgs-provided update.py utility. The command requires Python and the script located at 'nixpkgs/pkgs/servers/web-apps/discourse/update.py'. It should be run from a shell with necessary permissions to update plugin metadata for future NixOS deployments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./update.py update-plugins\n```\n\n----------------------------------------\n\nTITLE: Listing available NVIDIA GPU devices\nDESCRIPTION: This command uses jq to parse the NVIDIA Container Toolkit CDI specification and list all available GPU devices that can be exposed to containers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix run nixpkgs#jq -- -r '.devices[].name' < /var/run/cdi/nvidia-container-toolkit.json\n0\n1\nall\n```\n\n----------------------------------------\n\nTITLE: Configuring Honk Service and Firewall on NixOS using Nix\nDESCRIPTION: This snippet demonstrates a minimal NixOS configuration for enabling the Honk ActivityPub server. It sets key service parameters including network address, port, authentication, and server name, requiring the password to be specified in an external file. The configuration also opens the specified port (8080) in the firewall. To use this, users must add it to their NixOS configuration and ensure that '/etc/honk/password.txt' exists and is readable. Limitations include the need to further secure the password file and to expand options for production environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/honk.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.honk = {\n    enable = true;\n    host = \"0.0.0.0\";\n    port = 8080;\n    username = \"username\";\n    passwordFile = \"/etc/honk/password.txt\";\n    servername = \"honk.example.com\";\n  };\n\n  networking.firewall.allowedTCPPorts = [ 8080 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning Nixpkgs and Navigating Repository (Shell, ShellSession)\nDESCRIPTION: This shell snippet demonstrates cloning the Nixpkgs repository from GitHub and changing directory into it. It is foundational for in-tree package development as described in the Nixpkgs manual. Required dependency: git. Command parameters: repository URL and desired directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git clone https://github.com/NixOS/nixpkgs\\n$ cd nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Creating an OCaml Development Shell in Nix\nDESCRIPTION: This snippet demonstrates how to create a Nix shell for OCaml development. It sets up an environment with OCaml 4.12, build tools like findlib and dune, and includes ocamlgraph as a dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ocaml.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  # choose the ocaml version you want to use\n  ocamlPackages = pkgs.ocaml-ng.ocamlPackages_4_12;\nin\npkgs.mkShell {\n  # build tools\n  nativeBuildInputs = with ocamlPackages; [\n    ocaml\n    findlib\n    dune_2\n    ocaml-lsp\n  ];\n  # dependencies\n  buildInputs = with ocamlPackages; [ ocamlgraph ];\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Downloaded Content with postFetch in fetchurl - Nix Language\nDESCRIPTION: This Nix snippet demonstrates enhancing file downloads with fetchurl by supplying a postFetch hook, allowing the content to be modified after downloading. Here, the 'hello' package output is appended to the file. It uses 'nativeBuildInputs' to provide build tools and 'lib.getExe' utility for executable resolution. The main parameters are 'url', 'nativeBuildInputs', 'postFetch', and 'hash'. Outputs are fixed-output derivations with custom-processed content.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fetchurl,\n  hello,\n  lib,\n}:\nfetchurl {\n  url = \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\";\n\n  nativeBuildInputs = [ hello ];\n\n  downloadToTemp = true;\n  postFetch = ''\n    ${lib.getExe hello} >> $downloadedFile\n    mv $downloadedFile $out\n  '';\n\n  hash = \"sha256-ceooQQYmDx5+0nfg40uU3NNI2yKrixP7HZ/xLZUNv+w=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom R Environment with rWrapper - Nix\nDESCRIPTION: This code snippet demonstrates how to create a custom R environment using Nix by defining 'packageOverrides' in the user's config.nix file. It uses 'super.rWrapper.override' to specify a set of desired R packages, allowing seamless installation via 'nix-env'. Dependencies include the Nix package manager, access to self.rPackages, and an up-to-date channel. The output is a new Nix package 'rEnv' containing the specified R libraries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/r.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    super:\n    let\n      self = super.pkgs;\n    in\n    {\n\n      rEnv = super.rWrapper.override {\n        packages = with self.rPackages; [\n          devtools\n          ggplot2\n          reshape2\n          yaml\n          optparse\n        ];\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Importing a Custom Typst Package in a Document - Typst\nDESCRIPTION: This snippet shows how to import a custom Typst package in a Typst document using the '@preview' scope. It uses the 'import' directive to bring all exported symbols from 'my-typst-package' version '0.0.1' into the document namespace. No external dependencies are needed beyond Typst itself and the package being available in the environment. The input parameter is the package identifier, and the output is access to its exported symbols. The code assumes the package was built and properly integrated using the previous Nix configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/typst.section.md#_snippet_3\n\nLANGUAGE: typst\nCODE:\n```\n#import \"@preview/my-typst-package:0.0.1\": *\n```\n\n----------------------------------------\n\nTITLE: Enabling 32-Bit OpenGL Support on 64-bit NixOS - Nix\nDESCRIPTION: Sets hardware.graphics.enable32Bit to true, allowing 32-bit OpenGL libraries for legacy software (e.g. Wine) on 64-bit systems. Ensures necessary 32-bit graphics support is provided system-wide. Requires multi-lib enabled in kernel and suitable graphics stack.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.enable32Bit = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom buildPhase for pnpm workspace projects\nDESCRIPTION: Example buildPhase implementation for pnpm workspace projects, showing how to build specific workspace packages using the --filter flag.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildPhase = ''\n    runHook preBuild\n\n    pnpm --filter=@astrojs/language-server build\n\n    runHook postBuild\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Declarative Nix shell for BEAM packages\nDESCRIPTION: This Nix expression creates a declarative shell environment with rebar3 installed. It imports the nixpkgs set and uses mkShell to define the environment with the specified packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> {\n    config = { };\n    overlays = [ ];\n  };\nin\npkgs.mkShell {\n  packages = [ pkgs.beamPackages.rebar3 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Required Environment Variables for Nvidia GPU Access in Pods\nDESCRIPTION: Environment variables that must be included in Kubernetes pod specifications to enable GPU access within containers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/NVIDIA.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n   - name: NVIDIA_VISIBLE_DEVICES\n     value: all\n   - name: NVIDIA_DRIVER_CAPABILITIES\n     value: all\n```\n\n----------------------------------------\n\nTITLE: Illustrating Infinite Platform Tuple in Nixpkgs Bootstrapping\nDESCRIPTION: This snippet extends the platform triple concept to an infinite tuple, representing the theoretical continuous chain of bootstrapping stages. It shows how native and foreign platforms are arranged in an infinite sequence, which forms the basis for the sliding window approach in determining bootstrap stages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n(native..., native, native, native, foreign, foreign, foreign...)\n```\n\n----------------------------------------\n\nTITLE: Defining Apache HTTPD Virtual Hosts in Nix\nDESCRIPTION: This snippet defines two Apache HTTPD virtual hosts with explicit configuration blocks in a NixOS configuration. Each host has nearly identical options except for the documentRoot value. No external dependencies are required beyond NixOS's module system. Parameters include the server name as the attribute key and settings such as documentRoot and adminAddr as values. Inputs are static strings, and outputs are the corresponding virtual host configurations within the NixOS module system. While functional, it contains duplication and should be refactored for maintainability when many hosts are present.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/abstractions.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.virtualHosts =\n    { \"blog.example.org\" = {\n        documentRoot = \"/webroot/blog.example.org\";\n        adminAddr = \"alice@example.org\";\n        forceSSL = true;\n        enableACME = true;\n      };\n      \"wiki.example.org\" = {\n        documentRoot = \"/webroot/wiki.example.org\";\n        adminAddr = \"alice@example.org\";\n        forceSSL = true;\n        enableACME = true;\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available TeX Live Packages Interactive Shell - Nix - ShellSession\nDESCRIPTION: Describes how to use nix repl to list all TeX Live packages available under texlive.pkgs. This is meant for discovery only, not direct usage within environments. The code is a shell interaction and does not execute package builds. Prerequisite: <nixpkgs> channel or flake.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix repl\nnix-repl> :l <nixpkgs>\nnix-repl> texlive.pkgs.[TAB]\n```\n\n----------------------------------------\n\nTITLE: Inspecting Maven Repository Output with tree - Bash Language\nDESCRIPTION: Provides an example bash command for inspecting the resulting Maven repository structure created by a Nix build. This example runs tree on the output directory returned by nix-build, displaying a hierarchical view of artifact files and their symlinks. Requires that tree, nix-build, and a build-maven-repository.nix file are available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n❯ tree $(nix-build --no-out-link build-maven-repository.nix) | head\n/nix/store/g87va52nkc8jzbmi1aqdcf2f109r4dvn-maven-repository\n├── antlr\n│   └── antlr\n│       └── 2.7.2\n│           ├── antlr-2.7.2.jar -> /nix/store/d027c8f2cnmj5yrynpbq2s6wmc9cb559-antlr-2.7.2.jar\n│           └── antlr-2.7.2.pom -> /nix/store/mv42fc5gizl8h5g5vpywz1nfiynmzgp2-antlr-2.7.2.pom\n├── avalon-framework\n│   └── avalon-framework\n│       └── 4.1.3\n│           ├── avalon-framework-4.1.3.jar -> /nix/store/iv5fp3955w3nq28ff9xfz86wvxbiw6n9-avalon-framework-4.1.3.jar\n\n```\n\n----------------------------------------\n\nTITLE: Setting Kernel Parameters for CGroup Support - NixOS Boot Configuration - nix\nDESCRIPTION: This snippet adds required kernel parameters to enable cpuset, memory cgroup v1, and memory extension for K3s compatibility, particularly on Raspberry Pi. Place inside the 'boot.kernelParams' attribute of your '/etc/nixos/configuration.nix'. Dependencies: NixOS bootloader support for kernel parameters; takes an array of strings as values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n  boot.kernelParams = [\n    \"cgroup_enable=cpuset\" \"cgroup_memory=1\" \"cgroup_enable=memory\"\n  ];\n```\n\n----------------------------------------\n\nTITLE: Testing Runnable JAR Package\nDESCRIPTION: Bash commands to verify the built package structure and test running the JAR through the generated wrapper script.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n❯ tree $(nix-build --no-out-link runnable-jar.nix)\n/nix/store/8d4c3ibw8ynsn01ibhyqmc1zhzz75s26-maven-demo-1.0\n├── bin\n│   └── maven-demo\n├── repository -> /nix/store/g87va52nkc8jzbmi1aqdcf2f109r4dvn-maven-repository\n└── share\n    └── java\n        └── maven-demo-1.0.jar\n\n❯ $(nix-build --no-out-link --option tarball-ttl 1 runnable-jar.nix)/bin/maven-demo\nNixOS 😀 is super cool 😃!\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Builder Script - Nix\nDESCRIPTION: This snippet assigns a custom shell script as the builder attribute in the derivation instead of using stdenv's default generic builder. The builder script (e.g., ./builder.sh) should perform the necessary build and installation tasks within a stdenv-initialized environment. Prerequisite: The specified shell script must exist and be executable, and $out and other standard build variables will be set up.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  pname = \"libfoo\";\n  version = \"1.2.3\";\n  # ...\n  builder = ./builder.sh;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Assigning a Static IPv6 Address to an Interface - Nix\nDESCRIPTION: This code assigns a static IPv6 address to the 'eth0' interface on NixOS, defining both the address and the prefix length. The 'networking.interfaces.<name>.ipv6.addresses' module option is used for manual address assignment; it accepts a list of address objects. Input parameters include the IPv6 address and subnet prefix. Depends on the NixOS module system and requires proper syntax in the configuration file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv6-config.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.interfaces.eth0.ipv6.addresses = [ {\n    address = \"fe00:aa:bb:cc::2\";\n    prefixLength = 64;\n  } ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Local Python Shell Environment with python.buildEnv.override.env (Nix)\nDESCRIPTION: This snippet describes using python3.buildEnv.override with the env attribute in Nix to build a local shell environment containing specified packages (numpy, requests). It is analogous to a Python virtualenv, providing a developer shell where the specified dependencies are present. Requires correct Nixpkgs imports and the targeted python3Packages. The main input is the list of extraLibs; output is an isolated Python shell via nix-shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(python3.buildEnv.override {\n  extraLibs = with python3Packages; [\n    numpy\n    requests\n  ];\n}).env\n```\n\n----------------------------------------\n\nTITLE: Installing GNOME Shell Extensions Packages - NixOS System Packages - Nix\nDESCRIPTION: Adds selected GNOME Shell extension packages (dash-to-dock, gsconnect, mpris-indicator-button) to the NixOS system profile using the 'environment.systemPackages' array. Requires the 'gnomeExtensions' package set to be available in the environment. Key parameter is the list of desired extension packages. This does not enable them automatically in the GNOME Shell UI; manual activation is still needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    gnomeExtensions.dash-to-dock\n    gnomeExtensions.gsconnect\n    gnomeExtensions.mpris-indicator-button\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying a User ID Manually in User Definition - Nix - nix\nDESCRIPTION: This snippet demonstrates how to explicitly set a UID (user ID) in a user specification block in the NixOS configuration. To use, nest this attribute in the user definition. The 'uid' key (integer) defines the system user ID instead of using an automatically assigned value. This can be important for consistent UID mapping; however, ensure the assigned UID is unique to prevent conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  uid = 1000;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Nix Values to Strings with devShellTools (Nix)\nDESCRIPTION: Demonstrates the use of devShellTools.valueToString to convert Nix values (such as files or booleans) into string representations, emulating the behavior of the built-in derivation function. Dependencies include the devShellTools library and Nix builtins. For a file, the function returns its store path; for booleans, it returns an empty string. Inputs are any Nix value, with output being their string representation suitable for environment variables.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/dev-shell-tools.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ndevShellTools.valueToString (builtins.toFile \"foo\" \"bar\")\n# => \"/nix/store/...-foo\"\n```\n\nLANGUAGE: nix\nCODE:\n```\ndevShellTools.valueToString false\n# => \"\"\n```\n\n----------------------------------------\n\nTITLE: Including Specific Package Outputs in TeX Live Environment - Nix - nix\nDESCRIPTION: Shows how to include only select outputs (e.g., TeX files, documentation) when assembling a TeX Live environment using texlive.withPackages. This allows for picking documentation and TeX files from particular packages, and demonstrates referencing both main and documentation outputs. Dependencies: Nixpkgs with TeX Live, texliveSmall.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\ntexlive.withPackages (\n  ps: with ps; [\n    texdoc # recommended package to navigate the documentation\n    perlPackages.LaTeXML.tex # tex files of LaTeXML, omit binaries\n    cm-super\n    cm-super.texdoc # documentation of cm-super\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Permitting Specific Insecure Packages by Name - Nix - nix\nDESCRIPTION: Permanently allows installation of explicit insecure package `hello-1.2.3` via `permittedInsecurePackages` list in the user's `config.nix`. Input is an array of strings matching desired package-version pairs; effect is limited to those packages only. No global insecure package access is allowed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  permittedInsecurePackages = [\n    \"hello-1.2.3\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom RStudio Environment with rstudioWrapper - Nix\nDESCRIPTION: This code configures a custom RStudio environment by overriding 'rstudioWrapper' using Nix. It lets the user specify exact R packages to be included in the RStudio session, ensuring consistency regardless of local/global package installations. Dependencies include the presence of super.rstudioWrapper, self.rPackages, and a valid Nix configuration. Installation is achieved through the 'nix-env' command, resulting in a profile entry named 'rstudioEnv' with the desired setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/r.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    super:\n    let\n      self = super.pkgs;\n    in\n    {\n\n      rstudioEnv = super.rstudioWrapper.override {\n        packages = with self.rPackages; [\n          dplyr\n          ggplot2\n          reshape2\n        ];\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Vim Plugins with vim-plug in NixOS\nDESCRIPTION: Example showing how to use vim-plug to manage Vim plugins in NixOS. This approach loads the specified plugins at launch time.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nvim-full.customize {\n  vimrcConfig.packages.myVimPackage = with pkgs.vimPlugins; {\n    # loaded on launch\n    plug.plugins = [\n      youcompleteme\n      fugitive\n      phpCompletion\n      elm-vim\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic NixOS Upgrades\nDESCRIPTION: This Nix configuration enables automatic upgrades for NixOS, including the option to allow reboots if necessary.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.autoUpgrade.enable = true;\n  system.autoUpgrade.allowReboot = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Goss Service in NixOS\nDESCRIPTION: Demonstrates a minimal configuration for enabling and configuring the Goss service in NixOS. Includes environment settings, network validation, command execution, DNS checks, file system validation, group/user existence verification, kernel parameter checks, and service status monitoring.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/goss.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.goss = {\n    enable = true;\n\n    environment = {\n      GOSS_FMT = \"json\";\n      GOSS_LOGLEVEL = \"TRACE\";\n    };\n\n    settings = {\n      addr.\"tcp://localhost:8080\" = {\n        reachable = true;\n        local-address = \"127.0.0.1\";\n      };\n      command.\"check-goss-version\" = {\n        exec = \"${lib.getExe pkgs.goss} --version\";\n        exit-status = 0;\n      };\n      dns.localhost.resolvable = true;\n      file.\"/nix\" = {\n        filetype = \"directory\";\n        exists = true;\n      };\n      group.root.exists = true;\n      kernel-param.\"kernel.ostype\".value = \"Linux\";\n      service.goss = {\n        enabled = true;\n        running = true;\n      };\n      user.root.exists = true;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Xcode Derived Data Cache\nDESCRIPTION: This bash command shows how to clear the Xcode derived data cache, which can be useful for troubleshooting when changes are not being picked up.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ rm -rf ~/Library/Developer/Xcode/DerivedData\n```\n\n----------------------------------------\n\nTITLE: Configuring Template Units\nDESCRIPTION: Example configuration for systemd template units allowing multiple instances of a service with different parameters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services = {\n    \"base-unit@\".serviceConfig = {\n      ExecStart = \"...\";\n      User = \"...\";\n    };\n    \"base-unit@instance-a\" = {\n      overrideStrategy = \"asDropin\"; # needed for templates to work\n      wantedBy = [ \"multi-user.target\" ]; # causes NixOS to manage the instance\n    };\n    \"base-unit@instance-b\" = {\n      overrideStrategy = \"asDropin\"; # needed for templates to work\n      wantedBy = [ \"multi-user.target\" ]; # causes NixOS to manage the instance\n      serviceConfig.User = \"root\"; # also override something for this specific instance\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Proxy Settings in NixOS Configuration - Nix\nDESCRIPTION: This code snippet defines proxy settings within the NixOS configuration file, specifying both the default proxy URL and addresses that bypass the proxy. It is typically placed in /mnt/etc/nixos/configuration.nix before running nixos-install, ensuring system-wide proxy access persists after installation and reboot. The parameters networking.proxy.default and networking.proxy.noProxy handle general proxy routing and exceptions, respectively.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-behind-a-proxy.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.proxy.default = \"http://user:password@proxy:port/\";\n  networking.proxy.noProxy = \"127.0.0.1,localhost,internal.domain\";\n}\n```\n\n----------------------------------------\n\nTITLE: Indexing Documents to Meilisearch via curl - bash\nDESCRIPTION: This bash command uses curl to add two sample documents to the 'movies' index in Meilisearch. It issues an HTTP POST request to the '/indexes/movies/documents' endpoint with a JSON payload containing document IDs and titles. This requires Meilisearch to be running on localhost:7700 and accessible to the client; the command depends on the curl utility and expects the endpoint to be reachable without authentication or custom headers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/search/meilisearch.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST 'http://127.0.0.1:7700/indexes/movies/documents' --data '[{\"id\": \"123\", \"title\": \"Superman\"}, {\"id\": 234, \"title\": \"Batman\"}]'\n```\n\n----------------------------------------\n\nTITLE: Adding a Recovery Key for LUKS Device Using systemd-cryptenroll - ShellSession\nDESCRIPTION: This shell command enrolls a text-based recovery key with a LUKS device using 'systemd-cryptenroll', allowing for password-based recovery if needed. The tool requires a device path and optionally keeps existing slots. Dependencies are 'systemd-cryptenroll' and a LUKS2 volume. Input is device path; output is an additional recovery key slot for secure storage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemd-cryptenroll --recovery-key /dev/sda2\n```\n\n----------------------------------------\n\nTITLE: Defining the nixpkgs Gradle Dependency Lockfile Format in JSON\nDESCRIPTION: This snippet showcases a representative JSON lockfile used by nixpkgs for Gradle dependency management. It contains metadata fields (\\\"!comment\\\" and \\\"!version\\\"), Maven/Gradle artifact URLs, and artifact hashes. Hashes (sha256) are provided for jar, pom, and module files, and there may also be subsidiary metadata for Maven artifacts. Consumers such as Nix builds and supporting scripts extract artifact coordinates, resolve artifact versions/classifiers, and validate integrity via provided hashes. Dependencies: None for parsing, but proper use requires Nix tooling and understanding of Maven artifact conventions. Inputs: artifact URLs and version metadata. Outputs: structured hash mapping for deterministic dependency resolution.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/tools/build-managers/gradle/README.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"!comment\\\": \\\"This is a nixpkgs Gradle dependency lockfile. For more details, refer to the Gradle section in the nixpkgs manual.\\\",\\n  \\\"!version\\\": 1,\\n  \\\"https://oss.sonatype.org/content/repositories/snapshots/com/badlogicgames/gdx-controllers\\\": {\\n    \\\"gdx-controllers#gdx-controllers-core/2.2.4-20231021.200112-6/SNAPSHOT\\\": {\\n\\n      \\\"jar\\\": \\\"sha256-Gdz2J1IvDJFktUD2XeGNS0SIrOyym19X/+dCbbbe3/U=\\\",\\n      \\\"pom\\\": \\\"sha256-90QW/Mtz1jbDUhKjdJ88ekhulZR2a7eCaEJoswmeny4=\\\"\\n    },\\n    \\\"gdx-controllers-core/2.2.4-SNAPSHOT/maven-metadata\\\": {\\n      \\\"xml\\\": {\\n        \\\"groupId\\\": \\\"com.badlogicgames.gdx-controllers\\\"\\n      }\\n    }\\n  },\\n  \\\"https://repo.maven.apache.org/maven2\\\": {\\n    \\\"com/badlogicgames/gdx#gdx-backend-lwjgl3/1.12.1\\\": {\\n      \\\"jar\\\": \\\"sha256-B3OwjHfBoHcJPFlyy4u2WJuRe4ZF/+tKh7gKsDg41o0=\\\",\\n      \\\"module\\\": \\\"sha256-9O7d2ip5+E6OiwN47WWxC8XqSX/mT+b0iDioCRTTyqc=\\\",\\n      \\\"pom\\\": \\\"sha256-IRSihaCUPC2d0QzB0MVDoOWM1DXjcisTYtnaaxR9SRo=\\\"\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Flutter Application with Nix - Nix\nDESCRIPTION: Demonstrates how to package a Flutter application (firmware-updater) using buildFlutterApplication via a pinned flutter package set (flutter322) in Nix. The snippet fetches the source from GitHub, allows optional targeting for web builds, and loads pubspec.lock as a JSON file. Requires flutter322, fetchFromGitHub, and lib.importJSON available in the environment, as well as the listed hash and revision of the source.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dart.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ flutter322, fetchFromGitHub }:\n\nflutter322.buildFlutterApplication {\n  pname = \"firmware-updater\";\n  version = \"0-unstable-2023-04-30\";\n\n  # To build for the Web, use the targetFlutterPlatform argument.\n  # targetFlutterPlatform = \"web\";\n\n  src = fetchFromGitHub {\n    owner = \"canonical\";\n    repo = \"firmware-updater\";\n    rev = \"6e7dbdb64e344633ea62874b54ff3990bd3b8440\";\n    hash = \"sha256-s5mwtr5MSPqLMN+k851+pFIFFPa0N1hqz97ys050tFA=\";\n    fetchSubmodules = true;\n  };\n\n  pubspecLock = lib.importJSON ./pubspec.lock.json;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling strfry Service Using NixOS Module - Nix\nDESCRIPTION: This Nix code snippet enables the strfry relay as a systemd service in a NixOS configuration. The primary dependency is the strfry module/service, and it requires that this module be available in the system. No input parameters are needed other than `{ ... }:`; enabling the service will start it automatically under systemd. There are no further custom settings in this basic usage sample.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/strfry.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.strfry.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Nextcloud PHP Options - NixOS Module System - Nix\nDESCRIPTION: This snippet demonstrates how to use lib.mkForce for overriding all default phpOptions in the services.nextcloud module within the NixOS module system. It is assumed the snippet is included in a NixOS configuration file. Key parameters are overwritten in the attribute set, and the use of mkForce ensures the user's options override any defaults. Expected input is a NixOS configuration attribute set, and the output is a fully overridden phpOptions configuration. This approach is necessary to comprehensively change Nextcloud's configuration beyond selective overrides, but users should be careful as all defaults are replaced.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nextcloud.phpOptions = lib.mkForce {\n    /* ... */\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Updating the NixOS Channel - ShellSession\nDESCRIPTION: Updates the NixOS channel with the latest packages and metadata from upstream using the nix-channel tool. This prepares the system for package upgrades so that subsequent nix-env operations can utilize the updated channel data. The required dependency is the existence of the 'nixos' channel. The expected output is an updated channel, enabling newer package versions to be installed or upgraded.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-packages.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-channel --update nixos\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL Galera Cluster in NixOS\nDESCRIPTION: Example configuration for setting up a MySQL Galera Cluster using the services.mysql.galeraCluster option in NixOS. This snippet demonstrates how to enable the cluster, set the local node name and address, and specify the addresses of all nodes in the cluster.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nservices.mysql = {\n  enable = true;\n  galeraCluster = {\n    enable = true;\n    localName = \"Node 1\";\n    localAddress = \"galera_01\";\n    nodeAddresses = [ \"galera_01\" \"galera_02\" \"galera_03\"];\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Deploying Entire Predefined Android SDK - Nix\nDESCRIPTION: Shows how to deploy a comprehensive, predefined Android SDK composition using androidenv.androidPkgs.androidsdk. This Nix expression gives access to most standard Android development tools with minimal configuration or customization required. It is useful for users who want a ready-made SDK setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nandroidenv.androidPkgs.androidsdk\n```\n\n----------------------------------------\n\nTITLE: Adding Swap Partition on GPT Disk Using parted (ShellSession)\nDESCRIPTION: Creates a Linux swap partition occupying the final 8GB of the disk on /dev/sda with 'parted'. Prerequisites include a GPT partitioned disk and sufficient unallocated space at the end. Specifies type as 'linux-swap', spanning from -8GB to 100% (disk end). The size can be adjusted based on memory requirements.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mkpart swap linux-swap -8GB 100%\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom or Headless JDK for JRE Builds (Nix)\nDESCRIPTION: Demonstrates use of the jdk attribute in jre_minimal.override to select a custom or headless JDK as the basis for a minimal JRE. Requires pkgs.jre_minimal and jdk11_headless as dependencies. Inputs: jdk to use for module extraction. Output: a tailored JRE without unnecessary GUI dependencies, reducing closure size for headless environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  my_jre = pkgs.jre_minimal.override {\n    jdk = jdk11_headless;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic X Server Startup - Nix\nDESCRIPTION: By setting services.xserver.autorun to false, this configuration prevents the X server from launching automatically at boot. Useful for server setups or custom graphical environment launching. The X server must then be started manually.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.autorun = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Manual GitLab Backup in NixOS\nDESCRIPTION: This command shows how to manually trigger a GitLab backup using systemctl.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/gitlab.md#_snippet_3\n\nLANGUAGE: shellsession\nCODE:\n```\n$ systemctl start gitlab-backup.service\n```\n\n----------------------------------------\n\nTITLE: Basic Python Test Script Commands\nDESCRIPTION: Example of basic Python test script commands for machine control and verification\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmachine.start()\nmachine.wait_for_unit(\"default.target\")\nif not \"Linux\" in machine.succeed(\"uname\"):\n  raise Exception(\"Wrong OS\")\n```\n\n----------------------------------------\n\nTITLE: Formatting Ext4 Partition with mkfs.ext4 and Label (ShellSession)\nDESCRIPTION: Initializes the specified partition (/dev/sda1) with the ext4 filesystem and assigns it the label 'nixos'. This makes the partition identifiable by label rather than device name, simplifying system configuration. The '-L' option sets the filesystem label, which should be unique.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkfs.ext4 -L nixos /dev/sda1\n```\n\n----------------------------------------\n\nTITLE: Streaming Layered Docker Image with Hello Package\nDESCRIPTION: Creates a script that streams a layered Docker image containing the hello executable. The image is built with name 'hello' and tag 'latest', streaming directly to Docker without storing in Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.streamLayeredImage {\n  name = \"hello\";\n  tag = \"latest\";\n\n  contents = [ hello ];\n\n  config.Cmd = [ \"/bin/hello\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative nix-shell Invocation Listing Packages Explicitly - Shell Command - sh\nDESCRIPTION: This shell snippet demonstrates launching a nix-shell with Lua and specific packages listed directly, rather than via a composed environment. While functional, it is not recommended as it may lack correct environment integration for all packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nnix-shell -p lua.pkgs.busted lua.pkgs.luafilesystem\n\n```\n\n----------------------------------------\n\nTITLE: Replacing a Core Service Module With Channel Import in Nix\nDESCRIPTION: Demonstrates how to use the disabledModules option to disable the built-in PostgreSQL module and import an alternative module from the nixos-unstable channel. This snippet requires access to the NixOS unstable channel (which can be added via nix-channel), and expects a NixOS configuration context with the standard parameter set ({ config, lib, pkgs, ... }). Key parameters include the list of disabled modules, the imports array specifying the new module source, and explicit service enabling (services.postgresql.enable = true). The output replaces only the module definition; it does not switch the package source itself. Limitations include the need for channel synchronization and manual control over package versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/replace-modules.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n\n{\n  disabledModules = [ \"services/databases/postgresql.nix\" ];\n\n  imports =\n    [ # Use postgresql service from nixos-unstable channel.\n      # sudo nix-channel --add https://nixos.org/channels/nixos-unstable nixos-unstable\n      <nixos-unstable/nixos/modules/services/databases/postgresql.nix>\n    ];\n\n  services.postgresql.enable = true;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Ejecting USB Device on macOS after Imaging using diskutil - ShellSession\nDESCRIPTION: This snippet cleanly ejects the USB device from macOS after writing the ISO image. 'diskutil eject' ensures all I/O is finished and the device can be safely removed. Replace 'diskX' with the corresponding identifier. Ensures data integrity after flashing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-usb.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\ndiskutil eject /dev/diskX\n```\n\n----------------------------------------\n\nTITLE: Using Multi-line String for Extra Hosts - NixOS - nix\nDESCRIPTION: Defines additional host mappings using a multi-line string in NixOS configuration. Demonstrates the syntax for multi-line strings, where indentation and special characters (\", \\) are not escaped. Useful for embedding configuration blocks like shell commands or host files. Requires understanding of Nix's multi-line string syntax.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.extraHosts =\n    ''\n      127.0.0.2 other-localhost\n      10.0.0.1 server\n    '';\n}\n```\n\n----------------------------------------\n\nTITLE: Shell script formatting validation with shfmt for single script\nDESCRIPTION: Example of using testers.shfmt to verify that a single shell script follows the expected formatting style. The build will fail if shfmt needs to reformat the file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\ntesters.shfmt {\n  name = \"script\";\n  src = ./script.sh;\n}\n```\n\n----------------------------------------\n\nTITLE: Entering Development Shell for nixos-rebuild-ng - Console\nDESCRIPTION: This shell command runs nix-shell with the nixos-rebuild-ng.devShell attribute, dropping the user into a development environment set up for nixos-rebuild-ng. The devShell usually includes Python and the necessary developer dependencies. Once inside, the directory is switched to src for immediate development. Prerequisites: a properly defined devShell in your Nix file. No direct parameters. Output: Interactive shell with configured environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-rebuild-ng/README.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nnix-shell -A nixos-rebuild-ng.devShell\n```\n\n----------------------------------------\n\nTITLE: Running iOS Simulator Script\nDESCRIPTION: These bash commands demonstrate how to run the iOS simulator script generated by the Nix expression. It shows how to list available simulators and launch a specific simulator instance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./result/bin/run-test-simulator\n```\n\nLANGUAGE: bash\nCODE:\n```\n./result/bin/run-test-simulator 5C93129D-CF39-4B1A-955F-15180C3BD4B8\n```\n\n----------------------------------------\n\nTITLE: Launching Linux Remote Builder via Nix Flake - ShellSession\nDESCRIPTION: Shows the shell command for launching the darwin.linux-builder using a flake-enabled 'nix run' command. This will prompt the user for sudo access to install credentials and start the Linux builder VM. Requires Nix with flakes enabled, a recent macOS, and the nixpkgs package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix run nixpkgs#darwin.linux-builder\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Maven Package Attributes with overrideMavenAttrs - Nix\nDESCRIPTION: Demonstrates use of the overrideMavenAttrs function to customize an existing buildMavenPackage derivation. This Nix snippet creates a customized version (1.2.0) of 'jd-cli', updating its src, disabling specific flaky tests using Maven parameters, and providing a new Maven dependency hash. Facilitates advanced package maintenance and test management. Depends on fetchFromGitHub and lib.escapeShellArgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\njd-cli.overrideMavenAttrs (old: rec {\n  version = \"1.2.0\";\n  src = fetchFromGitHub {\n    owner = old.src.owner;\n    repo = old.src.repo;\n    rev = \"${old.pname}-${version}\";\n    # old source hash of 1.2.0 version\n    hash = \"sha256-US7j6tQ6mh1libeHnQdFxPGoxHzbZHqehWSgCYynKx8=\";\n  };\n\n  # tests can be disabled by prefixing it with `!`\n  # see Maven documentation for more details:\n  # https://maven.apache.org/surefire/maven-surefire-plugin/examples/single-test.html#Multiple_Formats_in_One\n  mvnParameters = lib.escapeShellArgs [\n    \"-Dsurefire.failIfNoSpecifiedTests=false\"\n    \"-Dtest=!JavaDecompilerTest#basicTest,!JavaDecompilerTest#patternMatchingTest\"\n  ];\n\n  # old mvnHash of 1.2.0 maven dependencies\n  mvnHash = \"sha256-N9XC1pg6Y4sUiBWIQUf16QSXCuiAPpXEHGlgApviF4I=\";\n})\n\n```\n\n----------------------------------------\n\nTITLE: Extending GNOME Installer ISO with MacBook WiFi Drivers - Nix\nDESCRIPTION: This Nix expression shows how to extend the graphical GNOME-based NixOS installer ISO configuration by adding support for MacBook WiFi and virtualization drivers. It imports a base configuration and adds kernel modules and package dependencies. Dependencies include Nix, nixpkgs, and appropriate hardware packages. Inputs are configuration overlays for kernel modules, and outputs are a custom system configuration that builds an ISO with the listed hardware support. Use this as the value to the \\'nixos-config\\' input during a nix-build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-nixos.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ config, ... }:\\n\\n{\\n  imports = [ ./installation-cd-graphical-gnome.nix ];\\n\\n  boot.initrd.kernelModules = [ \\\"wl\\\" ];\\n\\n  boot.kernelModules = [ \\\"kvm-intel\\\" \\\"wl\\\" ];\\n  boot.extraModulePackages = [ config.boot.kernelPackages.broadcom_sta ];\\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SwiftPM Tests via doCheck Attribute in Nix\nDESCRIPTION: This Nix attribute set enables test execution for SwiftPM-based projects by setting `doCheck = true`. When used in a derivation that includes `swiftpm` in `nativeBuildInputs`, this triggers a `checkPhase` running `swift test -c release`. It is intended as a fragment for the build configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  doCheck = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nabi Korean Input Method in NixOS\nDESCRIPTION: Basic configuration for enabling Nabi, a Korean input method system that supports both hangul and hanja input.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"nabi\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing INI File Generation in Nix\nDESCRIPTION: Demonstrates how to create a custom INI file generator that uses specific formatting rules including custom boolean representations ('yes'/'no'), quoted strings, and ':' as key-value separator. The example shows configuration for a service with main and mergetool sections.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/generators.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  inherit (lib) generators isString;\n\n  customToINI = generators.toINI {\n    # specifies how to format a key/value pair\n    mkKeyValue = generators.mkKeyValueDefault {\n      # specifies the generated string for a subset of nix values\n      mkValueString =\n        v:\n        if v == true then\n          '\"yes\"'\n        else if v == false then\n          '\"no\"'\n        else if isString v then\n          '\"${v}\"'\n        # and delegates all other values to the default generator\n        else\n          generators.mkValueStringDefault { } v;\n    } \":\";\n  };\n\nin\n# the INI file can now be given as plain old nix values\ncustomToINI {\n  main = {\n    pushinfo = true;\n    autopush = false;\n    host = \"localhost\";\n    port = 42;\n  };\n  mergetool = {\n    merge = \"diff3\";\n  };\n}\n```\n\nLANGUAGE: ini\nCODE:\n```\n[main]\nautopush:\"no\"\nhost:\"localhost\"\nport:42\npushinfo:\"yes\"\nstr\\:ange:\"very::strange\"\n\n[mergetool]\nmerge:\"diff3\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Project Default R Environment - Nix\nDESCRIPTION: This snippet shows how to create a local Nix expression ('default.nix') for a reproducible R development environment. It defines a derivation named 'myProject' which includes specific R packages via 'buildInputs'. Necessary dependencies are the Nix package manager and access to <nixpkgs>. The expected use is to facilitate team collaboration with consistent environments by invoking 'nix-shell', providing reproducibility and isolation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/r.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n{\n  myProject = stdenv.mkDerivation {\n    name = \"myProject\";\n    version = \"1\";\n    src = if lib.inNixShell then null else nix;\n\n    buildInputs = with rPackages; [\n      R\n      ggplot2\n      knitr\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a User Password with passwd - ShellSession - ShellSession\nDESCRIPTION: This shell example shows how to assign a password to the user 'alice' using the 'passwd' utility. The process is interactive, prompting for password entry and confirmation. The command must be executed as root or with equivalent privileges. Essential for account activation when no password was assigned during user creation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n# passwd alice\nEnter new UNIX password: ***\nRetype new UNIX password: ***\n```\n\n----------------------------------------\n\nTITLE: Running and Using a Nix-derived Docker Image Container - Shell\nDESCRIPTION: This set of shell commands demonstrates running the generated Docker image in an interactive container, building the derivation inside the container, and executing the resulting binary. This assumes the user has already loaded the Docker image as shown previously. It requires Docker to be running and the image to exist locally. The expected output is the package's typical behavior, such as printing 'Hello, world!' for the hello package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_37\n\nLANGUAGE: shell\nCODE:\n```\n$ docker container run -it hello-2.12.1-env:latest\n[nix-shell:~]$ buildDerivation\nRunning phase: unpackPhase\nunpacking source archive /nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\nsource root is hello-2.12.1\n(some output removed for clarity)\nRunning phase: fixupPhase\nshrinking RPATHs of ELF executables and libraries in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1\nshrinking /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/bin/hello\nchecking for references to /build/ in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1...\ngzipping man pages under /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/share/man/\npatching script interpreter paths in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1\nstripping (with command strip and flags -S -p) in  /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/bin\n\n[nix-shell:~]$ $out/bin/hello\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Custom GNOME Flashback Session with XMonad - NixOS Module Configuration - Nix\nDESCRIPTION: This example demonstrates how to define a custom GNOME Flashback session with a window manager other than Metacity (here, XMonad) in NixOS. It configures an array under 'services.xserver.desktopManager.gnome.flashback.customSessions', specifying 'wmName', 'wmLabel', 'wmCommand', and whether to enable GNOME Panel. Dependencies include the 'xmonad' package in 'pkgs.haskellPackages'. Multiple sessions can be defined. Each session requires a unique combination of the window manager attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.gnome.flashback.customSessions = [\n    {\n      wmName = \"xmonad\";\n      wmLabel = \"XMonad\";\n      wmCommand = \"${pkgs.haskellPackages.xmonad}/bin/xmonad\";\n      enableGnomePanel = false;\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Service with UDP Downstream and Cloudflare Upstream - Nix\nDESCRIPTION: This snippet demonstrates a full configuration of the crab-hole service in NixOS with UDP as the downstream protocol and Cloudflare DNS over TLS as the upstream. It specifies ad blocklists, multiple listeners on both IPv4 and IPv6, and sets up upstream DNS servers with proper protocols and hostnames. All blocklist and networking parameters are customizable. Required dependencies include the crab-hole NixOS module and network access for DNS servers. Inputs include blocklist URLs, DNS server addresses, and related options; the output is a configured ad-blocking DNS instance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole = {\n    enable = true;\n\n    settings = {\n      blocklist = {\n        include_subdomains = true;\n        lists = [\n          \"https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews-gambling-porn/hosts\"\n          \"https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt\"\n        ];\n      };\n\n      downstream = [\n        {\n          protocol = \"udp\";\n          listen = \"127.0.0.1\";\n          port = 53;\n        }\n        {\n          protocol = \"udp\";\n          listen = \"::1\";\n          port = 53;\n        }\n      ];\n\n      upstream = {\n        name_servers = [\n          {\n            socket_addr = \"1.1.1.1:853\";\n            protocol = \"tls\";\n            tls_dns_name = \"1dot1dot1dot1.cloudflare-dns.com\";\n            trust_nx_responses = false;\n          }\n          {\n            socket_addr = \"[2606:4700:4700::1111]:853\";\n            protocol = \"tls\";\n            tls_dns_name = \"1dot1dot1dot1.cloudflare-dns.com\";\n            trust_nx_responses = false;\n          }\n        ];\n      };\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Formatting Hex, Octal, and Float Values with libconfig via Nix\nDESCRIPTION: Demonstrates converting standard values to libconfig-specific number formats (hexadecimal, octal, float notation) using the pkgs.formats.libconfig helper functions in Nix. This snippet supports numeric value serialization for advanced libconfig scenarios. Dependencies: pkgs.formats.libconfig. Input: standard number representations as strings. Output: Attrset keys with type-assured values for libconfig writing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.libconfig { };\nin {\n  myHexValue = format.lib.mkHex \"0x1FC3\";\n  myOctalValue = format.lib.mkOctal \"0027\";\n  myFloatValue = format.lib.mkFloat \"1.2E-3\";\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nix Build Output with fetchzip for .rar Archives - Shell\nDESCRIPTION: This shell snippet displays the output after fetching and extracting a .rar file using fetchzip with unrar. The resulting directory contains all files from the archive, providing a concrete illustration of the decompression process. The snippet does not require any dependencies and is for output exploration only.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/zpn7knxfva6rfjja2gbb4p3l9w1f0d36-source\n\n$ ls /nix/store/zpn7knxfva6rfjja2gbb4p3l9w1f0d36-source\nFONT.DAT      PINBALL.DAT  PINBALL.EXE\tPINBALL2.MID  TABLE.BMP    WMCONFIG.EXE\nMSCREATE.DIR  PINBALL.DOC  PINBALL.MID\tSounds\t     WAVEMIX.INF\n```\n\n----------------------------------------\n\nTITLE: Loading and Importing Layered Docker Image into Docker (shell)\nDESCRIPTION: Uses 'nix-build' to build the layered Docker image, followed by 'docker image load -i' to import it into Docker. Shows typical build output including individual layer construction. Expects the user to replace paths/names as generated by their environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\nbuilding '/nix/store/bk8bnrbw10nq7p8pvcmdr0qf57y6scha-hello.tar.gz.drv'...\nNo 'fromImage' provided\nCreating layer 1 from paths: ['/nix/store/i93s7xxblavsacpy82zdbn4kplsyq48l-libunistring-1.1']\nCreating layer 2 from paths: ['/nix/store/ji01n9vinnj22nbrb86nx8a1ssgpilx8-libidn2-2.3.4']\nCreating layer 3 from paths: ['/nix/store/ldrslljw4rg026nw06gyrdwl78k77vyq-xgcc-12.3.0-libgcc']\nCreating layer 4 from paths: ['/nix/store/9y8pmvk8gdwwznmkzxa6pwyah52xy3nk-glibc-2.38-27']\nCreating layer 5 from paths: ['/nix/store/zhl06z4lrfrkw5rp0hnjjfrgsclzvxpm-hello-2.12.1']\nCreating layer 6 with customisation...\nAdding manifests...\nDone.\n/nix/store/hxcz7snvw7f8rzhbh6mv8jq39d992905-hello.tar.gz\n\n$ docker image load -i /nix/store/hxcz7snvw7f8rzhbh6mv8jq39d992905-hello.tar.gz\n(some output removed for clarity)\nLoaded image: hello:latest\n\n```\n\n----------------------------------------\n\nTITLE: Temporarily Allowing Insecure Packages - Environment Variable - shell\nDESCRIPTION: Permits all insecure packages to be installed or built for a single nix tool invocation by exporting `NIXPKGS_ALLOW_INSECURE`. This has no effect beyond the lifespan of the shell session or command.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ export NIXPKGS_ALLOW_INSECURE=1\n```\n\n----------------------------------------\n\nTITLE: Managing GoToSocial User Accounts\nDESCRIPTION: Shell commands for creating and managing administrative users in GoToSocial. Includes commands for creating, confirming, and promoting user accounts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/gotosocial.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo gotosocial-admin account create --username <nickname> --email <email> --password <password>\n$ sudo gotosocial-admin account confirm --username <nickname>\n$ sudo gotosocial-admin account promote --username <nickname>\n```\n\n----------------------------------------\n\nTITLE: Configuring Uim Input Method in NixOS\nDESCRIPTION: Configuration for enabling Uim (Universal Input Method) framework, a multilingual input method system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"uim\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Perl Package Dependencies for Urxvt Plugins in Nix\nDESCRIPTION: This snippet shows how to specify that a Urxvt plugin is itself a Perl package that needs to be imported by other plugins or scripts. It uses the 'passthru' attribute to indicate the plugin as a Perl package dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  passthru.perlPackages = [ \"self\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Install Targets\nDESCRIPTION: Example showing how to specify custom make install targets for the installation phase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n{\n  installTargets = \"install-bin install-doc\";\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Zabbix Database Character Set and Collation\nDESCRIPTION: SQL query to check the character set and collation of the Zabbix database to ensure it meets the requirement of utf8 character set and utf8_bin collation in Zabbix 5.0.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  default_character_set_name,\n  default_collation_name\nFROM\n  information_schema.schemata\nWHERE\n  schema_name = 'zabbix';\n```\n\n----------------------------------------\n\nTITLE: Overriding Default GSettings for GNOME - Extra GSettings Overrides - Nix\nDESCRIPTION: This snippet demonstrates how to override GNOME's default GSettings values system-wide in NixOS. The 'extraGSettingsOverrides' attribute allows setting multiple key/value pairs, such as changing the default background and favorite apps. Binding these overrides to specific packages via 'extraGSettingsOverridePackages' ensures the correct schemas are present. Dependencies: 'pkgs.gsettings-desktop-schemas' and related component packages. Inputs are override strings in INI format; result is altered initial defaults for GSettings keys.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.gnome = {\n    extraGSettingsOverrides = ''\n      # Change default background\n      [org.gnome.desktop.background]\n      picture-uri='file://${pkgs.nixos-artwork.wallpapers.mosaic-blue.gnomeFilePath}'\n\n      # Favorite apps in gnome-shell\n      [org.gnome.shell]\n      favorite-apps=['org.gnome.Console.desktop', 'org.gnome.Nautilus.desktop']\n    '';\n\n    extraGSettingsOverridePackages = [\n      pkgs.gsettings-desktop-schemas # for org.gnome.desktop\n      pkgs.gnome-shell # for org.gnome.shell\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Source and Documentation Tarballs for Haskell Packages\nDESCRIPTION: Functions to create source distribution and documentation tarballs for Haskell packages, suitable for uploading to Hackage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\nsdistTarball drv\ndocumentationTarball drv\n```\n\n----------------------------------------\n\nTITLE: Importing a Package from a Separate Nix File (Nix, nix)\nDESCRIPTION: Shows how to import a Nix package expression (e.g., 'my-hello.nix') into the environment.systemPackages array, improving modularity of the configuration. Input: path to a Nix expression. Output: imports a Nix derivation. Dependency: Existing package file with a proper derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  environment.systemPackages = [ (import ./my-hello.nix) ];\\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding supported GHC versions for haskell-language-server - Nix Expression Language\nDESCRIPTION: Shows how to override the supportedGhcVersions attribute for pkgs.haskell-language-server to make binaries for multiple GHC versions available at once. By default, only one version is built to minimize closure size. The snippet is used to ensure compatibility with projects needing specific GHC versions and must be used within a Nix environment that includes pkgs from nixpkgs. The input is an attribute set specifying the desired GHC versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\npkgs.haskell-language-server.override {\n  supportedGhcVersions = [\n    \"90\"\n    \"94\"\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring pict-rs in NixOS\nDESCRIPTION: Minimal configuration to enable the pict-rs image hosting service in NixOS. This starts the HTTP server on port 8080 by default.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pict-rs.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.pict-rs.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Systemd Service Reload Trigger Configuration - Nix - Nix\nDESCRIPTION: Shows how to specify reload versus restart behavior in systemd service definitions by setting 'systemd.services.<name>.reloadTriggers', replacing the older 'reloadIfChanged' parameter for improved granularity. Usage is via Nix service module options; must reference service names when configuring.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nsystemd.services.<name>.reloadTriggers\nreloadIfChanged\n```\n\n----------------------------------------\n\nTITLE: Importing Local NixOS Module Configuration\nDESCRIPTION: Demonstrates how to import a local NixOS module definition from a directory and enable its service. The module is imported using the imports attribute and enabled through the services configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/importing-modules.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n\n{\n  imports =\n    [ # Use a locally-available module definition in\n      # ./example-module/default.nix\n        ./example-module\n    ];\n\n  services.exampleModule.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating JetBrains Plugins - Update Script Invocation - python\nDESCRIPTION: This snippet demonstrates updating plugins by running the 'plugins/update_plugins.py' Python script. The command fetches new plugin versions and integrates them into the repository, typically used after major IDE updates or when adding a new plugin. Ensure Python is available and any required libraries for the script are installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jetbrains/readme.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n./plugins/update_plugins.py\n```\n\n----------------------------------------\n\nTITLE: Running Julia Package Tests in Shell\nDESCRIPTION: Shell command examples for running the Julia package test suite. Shows basic usage for testing top 100 packages and mentions available configuration options including parallelism and package count settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/julia-modules/tests/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Test the top 100 Julia packages\n./run_tests.sh -n 100\n```\n\n----------------------------------------\n\nTITLE: Patching Shebangs for Build Scripts in Bash\nDESCRIPTION: Example of using the patchShebangs command with the build flag to update interpreter paths in a configure script during the build process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_40\n\nLANGUAGE: sh\nCODE:\n```\npatchShebangs --build configure\n```\n\n----------------------------------------\n\nTITLE: Configuring Attribute Sets of Submodules (Nix)\nDESCRIPTION: This snippet provides a concrete configuration for an option declared as an attrsOf submodule, supplying two keys ('one' and 'two'), each mapped to an attribute set with integer 'foo' and string 'bar'. It must correspond to an option declared with attrsOf and a compatible submodule schema. Allows for named, multi-instance configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config.mod.one = { foo = 1; bar = \"one\"; };\n  config.mod.two = { foo = 2; bar = \"two\"; };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Vim Configuration to NixOS Package Overrides\nDESCRIPTION: Example showing how to make customized Vim and Neovim configurations installable by adding them to packageOverrides in the Nix configuration file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    pkgs: with pkgs; {\n      myVim = vim-full.customize {\n        # `name` specifies the name of the executable and package\n        name = \"vim-with-plugins\";\n        # add here code from the example section\n      };\n      myNeovim = neovim.override {\n        configure = {\n          # add code from the example section here\n        };\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding AMD OpenCL Packages to NixOS Hardware Configuration (nix)\nDESCRIPTION: Provides a NixOS hardware configuration fragment to add AMD ROCm OpenCL drivers for GPU acceleration by assigning rocmPackages.clr.icd to hardware.graphics.extraPackages. Assumes NixOS system and nixpkgs available. Inputs: an attribute set for extraPackages. Output: the required package will be available to OpenCL loader.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.extraPackages = [\n    rocmPackages.clr.icd\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mailman with Exim on NixOS (Nix)\nDESCRIPTION: This Nix code snippet shows how to set up Mailman with Exim 4 as the MTA on NixOS. Mailman's Postfix integration is explicitly disabled, and instead, custom MTA parameters for Exim (such as LMTP host/port and SMTP host/port) are defined. The Exim configuration is loaded from an external file for modularity. Essential dependencies include the external Exim configuration file and the Mailman package. This example does not handle advanced or granular Exim settings, so administrators must consult Mailman documentation for full integration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/mail/mailman.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ config, ... }: {\n  services = {\n    mailman = {\n      enable = true;\n      siteOwner = \"mailman@example.org\";\n      enablePostfix = false;\n      settings.mta = {\n        incoming = \"mailman.mta.exim4.LMTP\";\n        outgoing = \"mailman.mta.deliver.deliver\";\n        lmtp_host = \"localhost\";\n        lmtp_port = \"8024\";\n        smtp_host = \"localhost\";\n        smtp_port = \"25\";\n        configuration = \"python:mailman.config.exim4\";\n      };\n    };\n    exim = {\n      enable = true;\n      # You can configure Exim in a separate file to reduce configuration.nix clutter\n      config = builtins.readFile ./exim.conf;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting System Packages and PostgreSQL Version Using Packages - NixOS - nix\nDESCRIPTION: Specifies system packages and overrides the PostgreSQL package/version in NixOS. Uses the 'pkgs' argument to reference official packages. Expects 'pkgs' to be present as a function argument and lists both direct attribute assignment and option modification for services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages =\n    [ pkgs.thunderbird\n      pkgs.emacs\n    ];\n\n  services.postgresql.package = pkgs.postgresql_14;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling GNOME Core Services (TinySPARQL) - NixOS Module Configuration - Nix\nDESCRIPTION: This snippet shows how to disable certain background services provided by GNOME, such as 'localsearch' and 'tinysparql'. These settings may reduce resource usage, but disabling them is unsupported and may break features (e.g., GNOME Music won't work without TinySPARQL). Requires NixOS modules for 'services.gnome'. Key parameters are 'localsearch.enable' and 'tinysparql.enable', set to false.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gnome.localsearch.enable = false;\n  services.gnome.tinysparql.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating shell Environment with Python Dependencies and Additional Tools using mkShell - Nix Expression - Nix\nDESCRIPTION: Combines Python environment (with numpy, toolz) with other development tools (black, mypy) and libraries (libffi, openssl) using mkShell. The pattern supports heterogeneous development environments—Python, tools, and libraries—all in a single reproducible context. Ideal for full-featured, cross-language/team development setups.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\nlet\n  pythonEnv = python312.withPackages (ps: [\n    ps.numpy\n    ps.toolz\n  ]);\nin\nmkShell {\n  packages = [\n    pythonEnv\n\n    black\n    mypy\n\n    libffi\n    openssl\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning an Android Emulator with Custom Configuration - Nix\nDESCRIPTION: Uses androidenv.emulateApp to declare a Nix derivation for generating a script that launches an Android emulator instance. Key parameters—such as 'name', 'platformVersion', 'abiVersion', and 'systemImageType'—define the resulting emulator's configuration. The output is an automated, reproducible emulator launch environment suitable for testing or CI pipelines.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nandroidenv.emulateApp {\n  name = \"emulate-MyAndroidApp\";\n  platformVersion = \"28\";\n  abiVersion = \"x86\"; # armeabi-v7a, mips, x86_64\n  systemImageType = \"google_apis_playstore\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a NixOS Container with Custom Configuration - ShellSession\nDESCRIPTION: This example creates a container named 'foo' with OpenSSH enabled and a specified root user's public key. The '--config' flag is used to pass an in-line NixOS configuration. Requires root permissions and a valid SSH public key string. Modifies container configuration on creation, allows custom services to be enabled from the command line.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container create foo --config '\n  services.openssh.enable = true;\n  users.users.root.openssh.authorizedKeys.keys = [\"ssh-dss AAAAB3N…\"];\n'\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx Reverse Proxy for GoToSocial\nDESCRIPTION: NixOS configuration for setting up nginx as a reverse proxy for GoToSocial with SSL/TLS support via ACME. Includes firewall configuration and proxy settings with websocket support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/gotosocial.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  services.nginx = {\n    enable = true;\n    clientMaxBodySize = \"40M\";\n    virtualHosts = with config.services.gotosocial.settings; {\n      \"${host}\" = {\n        enableACME = true;\n        forceSSL = true;\n        locations = {\n          \"/\" = {\n            recommendedProxySettings = true;\n            proxyWebsockets = true;\n            proxyPass = \"http://${bind-address}:${toString port}\";\n          };\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a LUKS-Encrypted Ext4 File System with Shell Commands - ShellSession\nDESCRIPTION: This snippet shows the step-by-step process for initializing a LUKS-encrypted partition, opening it as a mapped device, and formatting it with Ext4 using shell commands. The workflow uses cryptsetup to secure a physical device by UUID, prompts for a passphrase, opens the container for use, and creates the file system. Required dependencies include 'cryptsetup' and 'mkfs.ext4'. Inputs are physical disk paths; outputs are the logical encrypted device and the formatted file system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# cryptsetup luksFormat /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d\\n\\nWARNING!\\n========\\nThis will overwrite data on /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d irrevocably.\\n\\nAre you sure? (Type uppercase yes): YES\\nEnter LUKS passphrase: ***\\nVerify passphrase: ***\\n\\n# cryptsetup luksOpen /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d crypted\\nEnter passphrase for /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d: ***\\n\\n# mkfs.ext4 /dev/mapper/crypted\n```\n\n----------------------------------------\n\nTITLE: Configuring ACME Certificate Generation in NixOS\nDESCRIPTION: This snippet demonstrates how to configure ACME to generate a certificate in NixOS. It includes setting the webroot, email, group, and extra domain names for the certificate.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.acme.certs.\"foo.example.com\" = {\n    webroot = \"/var/lib/acme/.challenges\";\n    email = \"foo@example.com\";\n    # Ensure that the web server you use can read the generated certs\n    # Take a look at the group option for the web server you choose.\n    group = \"nginx\";\n    # Since we have a wildcard vhost to handle port 80,\n    # we can generate certs for anything!\n    # Just make sure your DNS resolves them.\n    extraDomainNames = [ \"mail.example.com\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting NIX_ETC_* Environment Variables in Nix Shell - Bash\nDESCRIPTION: This snippet demonstrates entering a Nix shell environment with the iana-etc package, and querying the environment for variables set by the setup hook (NIX_ETC_PROTOCOLS and NIX_ETC_SERVICES). Prerequisites: Nix package manager installed; bash or compatible shell. Key commands: 'nix-shell -p iana-etc' launches a shell with iana-etc in the environment, while 'env | grep NIX_ETC' filters environment variables to show paths to protocol and services files. Inputs: none required except environmental presence of Nix. Outputs: paths to protocol and services files provided by Nix store. Limitation: Only relevant within nix-shell, and only if iana-etc is in buildInputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/etc-files.section.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n> nix-shell -p iana-etc\\n\\n[nix-shell:~]$ env | grep NIX_ETC\\nNIX_ETC_SERVICES=/nix/store/aj866hr8fad8flnggwdhrldm0g799ccz-iana-etc-20210225/etc/services\\nNIX_ETC_PROTOCOLS=/nix/store/aj866hr8fad8flnggwdhrldm0g799ccz-iana-etc-20210225/etc/protocols\\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a VM Image Test Script for Fedora 27 with vmTools.makeImageTestScript (Nix)\nDESCRIPTION: This snippet uses `makeImageTestScript` from `vmTools` to produce a testing script for the Fedora 27 VM image. This script enables launching an interactive VM based on the supplied disk image and is useful for manual testing or debugging. Dependencies include Nixpkgs, `vmTools`, and the predefined `diskImages.fedora27x86_64` image. Input is the disk image attribute; output is a test script derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }: with pkgs; with vmTools; makeImageTestScript diskImages.fedora27x86_64\n```\n\n----------------------------------------\n\nTITLE: Disabling IPv6 on a Specific Interface with Sysctl - Nix\nDESCRIPTION: This snippet disables IPv6 on a specific network interface (here 'eth0') via sysctl configuration in a NixOS module. The setting 'boot.kernel.sysctl.\"net.ipv6.conf.eth0.disable_ipv6\"' is applied to /etc/sysctl.d during system activation. No dependencies beyond standard NixOS boot options. The input expects interface name and desired value (true); effect is limited to the named interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv6-config.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernel.sysctl.\"net.ipv6.conf.eth0.disable_ipv6\" = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Repairing System Configuration in NixOS - Shell Commands - ShellSession\nDESCRIPTION: This code snippet provides the command to repair a NixOS system configuration after Nix store corruption. By executing 'nixos-rebuild switch --repair', all paths in the system closure are checked for integrity, and any mismatched content will be rebuilt or redownloaded as necessary. Requires administrative privileges and a working Nix environment; errors or unrecoverable corruption may occur if paths are missing from caches.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/store-corruption.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch --repair\n```\n\n----------------------------------------\n\nTITLE: Deleting Etcd Data Directory - Shell Command - bash\nDESCRIPTION: This single-line command permanently deletes the main Etcd data directory using 'rm -rf', removing all stateful data. Required to ensure cluster reinitialization without remnants. Dependency: proper privileges. No output unless error occurs; dangerous operation if run accidentally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n rm -rf /var/lib/etcd/\n```\n\n----------------------------------------\n\nTITLE: Configuring Hostname in NixOS\nDESCRIPTION: This snippet demonstrates how to set the system hostname in NixOS. It sets the hostname to 'cartman', overriding the default 'nixos' hostname. Setting it to an empty string would allow the DHCP server to provide the hostname.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ipv4-config.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.hostName = \"cartman\";\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up a Development Nix Shell for Rust Projects (Nix)\nDESCRIPTION: This `shell.nix` expression facilitates development by providing the minimal development environment for building Rust projects with Cargo in a pure Nix shell. It includes `rustc`, `cargo`, and build/runtime dependencies like `pkg-config` and `openssl`, and sets necessary environment variables. This shell is intended for interactive use with `nix-shell`, supporting standard Rust workflows.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_31\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nstdenv.mkDerivation {\n  name = \"rust-env\";\n  nativeBuildInputs = [\n    rustc\n    cargo\n\n    # Example Build-time Additional Dependencies\n    pkg-config\n  ];\n  buildInputs = [\n    # Example Run-time Additional Dependencies\n    openssl\n  ];\n\n  # Set Environment Variables\n  RUST_BACKTRACE = 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Executable Script in a Bin Directory with writeTextFile in Nix\nDESCRIPTION: This example demonstrates how to use writeTextFile to create an executable script in a bin directory within the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nwriteTextFile {\n  name = \"my-script\";\n  text = ''\n    echo \"hi\"\n  '';\n  executable = true;\n  destination = \"/bin/my-script\";\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nix Build Output with fetchzip (stripRoot = false) - Shell\nDESCRIPTION: This shell snippet shows the result of running nix-build on a derivation using fetchzip with stripRoot = false. The final Nix store path contains the top-level archive directory, matching the original structure of the .tar.gz file. This helps visualize the effect of the stripRoot parameter.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/2hy5bxw7xgbgxkn0i4x6hjr8w3dbx16c-source\n\n$ ls /nix/store/2hy5bxw7xgbgxkn0i4x6hjr8w3dbx16c-source\npatchelf-0.18.0\n```\n\n----------------------------------------\n\nTITLE: Building Target Kernel Headers - Nix Expression - nix\nDESCRIPTION: Implements a Nix expression for building Linux kernel headers for the arm target platform. It asserts the build platform is i686-linux and fetches a specified kernel tarball to be processed by a custom builder.sh. Requires fetchurl and stdenv. Outputs the 'linux-headers-2.6.13.1-arm' package containing architecture-specific headers for use in subsequent cross-compilation steps. Assumes builder.sh sets up and installs only header files with required symbolic links.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/old/cross.txt#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{stdenv, fetchurl}:\n\nassert stdenv.buildPlatform.system == \"i686-linux\";\n\nstdenv.mkDerivation {\n  name = \"linux-headers-2.6.13.1-arm\";\n  builder = ./builder.sh;\n  src = fetchurl {\n    url = \"http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.13.1.tar.bz2\";\n    hash = \"sha256-qtICDjfiA1HxWBrHqtB5DCv9s9/HyznKV1C6IxCrHYs=\";\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building PHP Application with Individual Hooks and mkDerivation in Nix\nDESCRIPTION: Example showing how to build a PHP application using stdenvNoCC.mkDerivation with separate Composer hooks. This approach provides more flexibility when building PHP libraries within other derivations and allows fine-grained control over the build process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenvNoCC,\n  fetchFromGitHub,\n  php,\n}:\n\nstdenvNoCC.mkDerivation (\n  finalAttrs:\n  let\n    src = fetchFromGitHub {\n      owner = \"git-owner\";\n      repo = \"git-repo\";\n      rev = finalAttrs.version;\n      hash = \"sha256-VcQRSss2dssfkJ+iUb5qT+FJ10GHiFDzySigcmuVI+8=\";\n    };\n  in\n  {\n    inherit src;\n    pname = \"php-app\";\n    version = \"1.0.0\";\n\n    buildInputs = [ php ];\n\n    nativeBuildInputs = [\n      php.packages.composer\n      # This hook will use the attribute `composerRepository`\n      php.composerHooks.composerInstallHook\n    ];\n\n    composerRepository = php.mkComposerRepository {\n      inherit (finalAttrs) pname version src;\n      composerNoDev = true;\n      composerNoPlugins = true;\n      composerNoScripts = true;\n      # Specifying a custom composer.lock since it is not present in the sources.\n      composerLock = ./composer.lock;\n      # The composer vendor hash\n      vendorHash = \"sha256-86s/F+/5cBAwBqZ2yaGRM5rTGLmou5//aLRK5SA0WiQ=\";\n    };\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Setting LOCALE_ARCHIVE environment variable in Nixpkgs\nDESCRIPTION: Example showing how to set the LOCALE_ARCHIVE environment variable to point to the locale archive provided by glibcLocales. This is recommended for non-NixOS distributions to avoid locale-related issues.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/locales.section.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport LOCALE_ARCHIVE=${glibcLocales}/lib/locale/locale-archive\n```\n\n----------------------------------------\n\nTITLE: Template for Reviewing Package Updates - Markdown\nDESCRIPTION: Provides a checklist template in markdown format for reviewing package update pull requests in nixpkgs. Reviewers fill checkboxes as they verify naming, versioning, build success, testing, patch rationale, and dependency completeness. This ensures requirements are met and documents possible improvements or comments. Outputs are reviewer notes; manual completion is required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_24\n\nLANGUAGE: markdown\nCODE:\n```\n##### Reviewed points\n\n- [ ] package name fits guidelines\n- [ ] package version fits guidelines\n- [ ] package builds on ARCHITECTURE\n- [ ] executables tested on ARCHITECTURE\n- [ ] all depending packages build\n- [ ] patches have a comment describing either the upstream URL or a reason why the patch wasn't upstreamed\n- [ ] patches that are remotely available are fetched rather than vendored\n\n##### Possible improvements\n\n##### Comments\n```\n\n----------------------------------------\n\nTITLE: Loading Ruby Environment from Nix Expression\nDESCRIPTION: Shows how to create a Ruby environment with specific gems using a Nix expression in a shell.nix file. This approach provides a reproducible development environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\nruby.withPackages (\n  ps: with ps; [\n    nokogiri\n    pry\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Hydra Platform Configuration Example in Nix\nDESCRIPTION: Example showing how to configure platform support for Hydra builds while limiting actual build platforms.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/meta.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  meta.platforms = lib.platforms.linux;\n  meta.hydraPlatforms = [ ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MariaDB Authentication using mysql_native_password in NixOS\nDESCRIPTION: Initial script for configuring MariaDB to use traditional mysql_native_password authentication instead of the default unix_socket authentication method introduced in MariaDB 10.4. This sets a password for the root user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mysql.initialScript = pkgs.writeText \"mariadb-init.sql\" ''\n    ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(\"verysecret\");\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Running Perl Scripts with Ad-hoc Dependencies via nix-shell - ShellSession\nDESCRIPTION: This shell invocation snippet demonstrates using nix-shell to provide a Perl environment with specific packages for a script. It requires nix and Perl-related packages available as Nix derivations. Takes package specifications (e.g., 'perlPackages.DBFile') and a command, and outputs the script results with the required dependencies available. This method is ideal for temporarily providing libraries not installed globally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p perl perlPackages.DBFile --run ./myscript.pl\n```\n\n----------------------------------------\n\nTITLE: Fetching and Decompressing RAR Archives with fetchzip and unrar - Nix\nDESCRIPTION: This snippet demonstrates how to use fetchzip in conjunction with the unrar tool as a native build input for decompressing .rar archives. The nativeBuildInputs attribute injects unrar for use during the unpack phase. stripRoot is set to false as the archive has no enclosing directory. Requires fetchzip, unrar, the correct URL, and a valid SHA256 hash. Outputs decompressed files at the top level, mirroring the archive contents.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchzip, unrar }:\nfetchzip {\n  url = \"https://archive.org/download/SpaceCadet_Plus95/Space_Cadet.rar\";\n  hash = \"sha256-fC+zsR8BY6vXpUkVd6i1jF0IZZxVKVvNi6VWCKT+pA4=\";\n  stripRoot = false;\n  nativeBuildInputs = [ unrar ];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Dependency for HTTPd Service on PostgreSQL\nDESCRIPTION: Configuration snippet showing how to preserve the dependency between httpd and postgresql services after removal of automatic dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nsystemd.services.httpd.after = [ \"postgresql.service\" ];\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimal Anubis and Nginx Integration - Nix\nDESCRIPTION: This Nix snippet demonstrates a minimal configuration for integrating Anubis with nginx, using Unix domain sockets for inter-process communication. It sets the Anubis target backend, adjusts nginx's user group permissions for socket access, and adds a proxyPass mapping to nginx's configuration. Requirements include NixOS with the Anubis and nginx modules enabled. The inputs are various system configurations for Anubis and nginx, and the output is a NixOS system ready to run Anubis with nginx as its reverse proxy.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/anubis.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, ... }: {\n  services.anubis.instances.default.settings.TARGET = \"http://localhost:8000\";\n\n  # required due to unix socket permissions\n  users.users.nginx.extraGroups = [ config.users.groups.anubis.name ];\n  services.nginx.virtualHosts.\"example.com\" = {\n    locations = {\n      \"/\".proxyPass = \"http://unix:${config.services.anubis.instances.default.settings.BIND}\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build Directory in Nix\nDESCRIPTION: Sets the directory where CMake will store intermediate files during the build process. This can be useful for debugging multiple CMake builds in the same source directory, especially when building for different platforms.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/cmake.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ncmakeBuildDir = \"build\";\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Downstream with UDP Protocol - Nix\nDESCRIPTION: This example shows how to configure the crab-hole service to listen for DNS requests over the unencrypted UDP protocol. The configuration sets the protocol type, IP address, and port for the downstream. No certificate or key is required. Useful when encryption is not needed; otherwise, consider TLS or HTTPS. Requires only crab-hole installed on NixOS. Input parameters are the protocol, address, and port; output is a UDP listener.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.downstream = [\n    {\n      protocol = \"udp\";\n      listen = \"localhost\";\n      port = 53;\n    }\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Migrating Grafana Option to extraOptions Syntax in Nix\nDESCRIPTION: This snippet demonstrates how to set Grafana administrative environment variables using the now-deprecated services.grafana.extraOptions attribute set in Nix. This method allows passing arbitrary environment variables to the Grafana systemd service. The key services.grafana.extraOptions.SECURITY_ADMIN_USER defines an environment variable assigned to Grafana's runtime environment. Inputs are Nix attribute sets, output is the old-style extraOptions mapping; now replaced by the settings option requiring a different structure. Dependency: Grafana module for NixOS. Limitation: Deprecated; only for reference or migration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  services.grafana.extraOptions.SECURITY_ADMIN_USER = \\\"foobar\\\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Synapse, Nginx, and PostgreSQL for Matrix - NixOS Modules - Nix\nDESCRIPTION: Defines a NixOS configuration that sets up networking, Nginx as a reverse proxy for Synapse, PostgreSQL database management, and Synapse server settings for a custom FQDN. Dependencies include the pkgs, lib, and config NixOS module arguments, and a running PostgreSQL service. Key parameters are the domain settings, Nginx virtual hosts for federated Matrix API routing, and explicit linking of homeserver discovery via /.well-known locations. Input: appropriate NixOS config context; Output: full configuration for Matrix hosting. Ensure to adjust the FQDN and domain to match your deployment. Requires NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/synapse.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, lib, config, ... }:\nlet\n  fqdn = \"${config.networking.hostName}.${config.networking.domain}\";\n  baseUrl = \"https://${fqdn}\";\n  clientConfig.\"m.homeserver\".base_url = baseUrl;\n  serverConfig.\"m.server\" = \"${fqdn}:443\";\n  mkWellKnown = data: ''\n    default_type application/json;\n    add_header Access-Control-Allow-Origin *;\n    return 200 '${builtins.toJSON data}';\n  '';\nin {\n  networking.hostName = \"myhostname\";\n  networking.domain = \"example.org\";\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n\n  services.postgresql.enable = true;\n\n  services.nginx = {\n    enable = true;\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n    recommendedProxySettings = true;\n    virtualHosts = {\n      # If the A and AAAA DNS records on example.org do not point on the same host as the\n      # records for myhostname.example.org, you can easily move the /.well-known\n      # virtualHost section of the code to the host that is serving example.org, while\n      # the rest stays on myhostname.example.org with no other changes required.\n      # This pattern also allows to seamlessly move the homeserver from\n      # myhostname.example.org to myotherhost.example.org by only changing the\n      # /.well-known redirection target.\n      \"${config.networking.domain}\" = {\n        enableACME = true;\n        forceSSL = true;\n        # This section is not needed if the server_name of matrix-synapse is equal to\n        # the domain (i.e. example.org from @foo:example.org) and the federation port\n        # is 8448.\n        # Further reference can be found in the docs about delegation under\n        # https://element-hq.github.io/synapse/latest/delegate.html\n        locations.\"= /.well-known/matrix/server\".extraConfig = mkWellKnown serverConfig;\n        # This is usually needed for homeserver discovery (from e.g. other Matrix clients).\n        # Further reference can be found in the upstream docs at\n        # https://spec.matrix.org/latest/client-server-api/#getwell-knownmatrixclient\n        locations.\"= /.well-known/matrix/client\".extraConfig = mkWellKnown clientConfig;\n      };\n      \"${fqdn}\" = {\n        enableACME = true;\n        forceSSL = true;\n        # It's also possible to do a redirect here or something else, this vhost is not\n        # needed for Matrix. It's recommended though to *not put* element\n        # here, see also the section about Element.\n        locations.\"/\".extraConfig = ''\n          return 404;\n        '';\n        # Forward all Matrix API calls to the synapse Matrix homeserver. A trailing slash\n        # *must not* be used here.\n        locations.\"/_matrix\".proxyPass = \"http://[::1]:8008\";\n        # Forward requests for e.g. SSO and password-resets.\n        locations.\"/_synapse/client\".proxyPass = \"http://[::1]:8008\";\n      };\n    };\n  };\n\n  services.matrix-synapse = {\n    enable = true;\n    settings.server_name = config.networking.domain;\n    # The public base URL value must match the `base_url` value set in `clientConfig` above.\n    # The default value here is based on `server_name`, so if your `server_name` is different\n    # from the value of `fqdn` above, you will likely run into some mismatched domain names\n    # in client applications.\n    settings.public_baseurl = baseUrl;\n    settings.listeners = [\n      { port = 8008;\n        bind_addresses = [ \"::1\" ];\n        type = \"http\";\n        tls = false;\n        x_forwarded = true;\n        resources = [ {\n          names = [ \"client\" \"federation\" ];\n          compress = true;\n        } ];\n      }\n    ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling and Using Debug Symbols for GDB with Overlays and symlinkJoin - Nix\nDESCRIPTION: Sets up a reproducible shell environment for debugging with GDB by enabling debug symbols on specific packages via overlays, aggregating debug outputs using symlinkJoin, and setting 'NIX_DEBUG_INFO_DIRS' to point to the correct debug information path. Dependencies include that the 'symlinkJoin', 'getLib', and 'getBin' functions are available from the Nixpkgs 'lib', and that the shell is executed with compatible packages. Inputs include the shell definition; outputs are both a shell with debug information for select packages, and convenience hooks for launching GDB on the target binary. Limitations include that overlays must properly enable 'separateDebugInfo'; cross-platform quirks may apply.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_29\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import ./. {\n    config = { };\n    overlays = [\n      (final: prev: {\n        ncurses = prev.ncurses.overrideAttrs { separateDebugInfo = true; };\n        readline = prev.readline.overrideAttrs { separateDebugInfo = true; };\n      })\n    ];\n  };\n\n  myDebugInfoDirs = pkgs.symlinkJoin {\n    name = \"myDebugInfoDirs\";\n    paths = with pkgs; [\n      glibc.debug\n      ncurses.debug\n      openssl.debug\n      readline.debug\n    ];\n  };\nin\npkgs.mkShell {\n\n  NIX_DEBUG_INFO_DIRS = \"${pkgs.lib.getLib myDebugInfoDirs}/lib/debug\";\n\n  packages = [\n    pkgs.gdb\n    pkgs.socat\n  ];\n\n  shellHook = ''\n    ${pkgs.lib.getBin pkgs.gdb}/bin/gdb ${pkgs.lib.getBin pkgs.socat}/bin/socat\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Octave Package to User Profile with nix-env in Shell (ShellSession)\nDESCRIPTION: This shell command shows how to install the 'symbolic' Octave package from the current repository root into the user's Nix profile. It uses nix-env with the -f option to specify the current directory as the package source and -iA to denote installation by attribute path. The command assumes that the symbolic package and its dependencies are correctly defined in the Nix expressions and that the user has an available writable Nix profile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/octave.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f. -iA octavePackages.symbolic\n```\n\n----------------------------------------\n\nTITLE: Enabling Cargo-Nextest for Rust Package Testing\nDESCRIPTION: Configuration to enable cargo-nextest for running tests in a Rust package build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  useNextest = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Downstream with QUIC Protocol - Nix\nDESCRIPTION: This snippet sets up crab-hole to accept DNS-over-QUIC connections, an encrypted transport protocol. Options mirror the HTTPS protocol with protocol type, listen address, port, certificate, key, optional hostname, and timeout. No reverse proxy needed on typical ports. Service needs file access rights. Inputs are protocol, address, port, certificate, key, and optional arguments; output is a QUIC DNS server.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.downstream = [\n    {\n      protocol = \"quic\";\n      listen = \"127.0.0.1\";\n      port = 853;\n      certificate = ./dns.example.com.crt;\n      key = \"/dns.example.com.key\";\n      # optional\n      dns_hostname = \"dns.example.com\";\n      # optional (default = 3000)\n      timeout_ms = 3000;\n    }\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Runtime Secrets for Resilio Sync - NixOS Service Option - Markdown\nDESCRIPTION: This snippet introduces the ability to supply Resilio Sync secret keys at runtime via an external secrets file, avoiding persistence in the Nix store. This improves operational security and flexibility. Dependencies include the Resilio Sync service and a secure mechanism for secrets provision. The expected secret file path must be specified in the service configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n- Resilio sync secret keys can now be provided using a secrets file at runtime, preventing these secrets from ending up in the Nix store.\n```\n\n----------------------------------------\n\nTITLE: Generating a Nix Expression for npm Dependencies with node2nix - Shell\nDESCRIPTION: This shell command snippet shows how to generate a Nix expression for Node.js dependencies using node2nix with development and lock file options specified. It is intended for projects that require devDependencies and reproducibility. Required dependency is node2nix and a present package-lock.json. Output is a suite of Nix expressions for building the npm project in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nnode2nix --development -l package-lock.json\n```\n\n----------------------------------------\n\nTITLE: Configuring binfmt Emulated Systems in NixOS (Nix)\nDESCRIPTION: This code snippet shows how to set up support for additional binary formats by specifying emulated systems in the NixOS configuration. The option 'boot.binfmt.emulatedSystems' accepts a list of strings, each representing a system architecture to support using binfmt, such as 'wasm32-wasi', 'x86_64-windows', and 'aarch64-linux'. No external dependencies are needed except a NixOS system, and changes will configure the necessary interpreters to enable transparent execution of binaries for the listed systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nboot.binfmt.emulatedSystems = [ \"wasm32-wasi\" \"x86_64-windows\" \"aarch64-linux\" ];\n```\n\n----------------------------------------\n\nTITLE: Configuring pnpm workspaces in Nix\nDESCRIPTION: Example demonstrating how to work with pnpm workspaces in Nix, including specifying which workspace packages to include and how to build specific workspace packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n  pnpmWorkspaces = [ \"@astrojs/language-server\" ];\n  pnpmDeps = pnpm.fetchDeps {\n    inherit (finalAttrs) pnpmWorkspaces;\n    #...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Generating wpa_supplicant.conf File Directly\nDESCRIPTION: Command to directly generate a wpa_supplicant.conf file with the network credentials using wpa_passphrase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_4\n\nLANGUAGE: shellsession\nCODE:\n```\n# wpa_passphrase ESSID PSK > /etc/wpa_supplicant.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx with Custom Modules\nDESCRIPTION: Example of configuring Nginx with custom modules using the new modules argument syntax that replaced enable/disable flags.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nnginx.override {\n    modules = [ nginxModules.rtmp nginxModules.dav nginxModules.moreheaders ];\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Subversion with Apache HTTPD - NixOS VirtualHost (Nix)\nDESCRIPTION: This NixOS configuration snippet showcases enabling Subversion (SVN) support within Apache HTTPD, with focus on loading necessary modules (`mod_dav_svn`, `mod_authz_svn`) and defining a virtual host. It sets up repository access using DAV, configures parent repository path, access and password files, and restricts authentication to valid users only. All file paths and host/domain names must be set appropriately. Dependencies: Apache HTTPD, Subversion server, and correct file permissions; user must adjust paths and replace placeholders. Output: Declarative configuration managing both service and access for hosted SVN repositories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.extraModules = [\n      # note that order is *super* important here\n      { name = \"dav_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_dav_svn.so\"; }\n      { name = \"authz_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_authz_svn.so\"; }\n    ];\n    services.httpd.virtualHosts = {\n      \"svn\" = {\n         hostName = HOSTNAME;\n         documentRoot = DOCUMENTROOT;\n         locations.\"/svn\".extraConfig = ''\n             DAV svn\n             SVNParentPath REPO_PARENT\n             AuthzSVNAccessFile ACCESS_FILE\n             AuthName \"SVN Repositories\"\n             AuthType Basic\n             AuthUserFile PASSWORD_FILE\n             Require valid-user\n        '';\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding User to NetworkManager Group\nDESCRIPTION: Configuration to grant a user permission to modify network settings by adding them to the networkmanager group.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/network-manager.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.alice.extraGroups = [ \"networkmanager\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating curried argument overrides helper for Haskell packages - Nix Expression Language\nDESCRIPTION: Defines a reusable installManPage function using the curried form of haskell.lib.compose.overrideCabal. This helper takes a package derivation and overrides its postInstall phase to install a corresponding man page. Requires haskell.lib.compose from nixpkgs, and works with any Haskell derivation matching the expected structure. This promotes code reuse for package customizations across multiple packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  installManPage = haskell.lib.compose.overrideCabal (drv: {\n    postInstall = ''\n      ${drv.postInstall or \"\"}\n      install -Dm644 man/${drv.pname}.1 -t \"$out/share/man/man1\"\n    '';\n  });\nin\n\ninstallManPage haskellPackages.pnbackup\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Xrandr Heads in NixOS Configuration - Nix\nDESCRIPTION: This snippet demonstrates how to configure multiple X11 display heads in NixOS using the services.xserver.xrandrHeads option. The attribute set allows targeting specific outputs, designating primary heads, and providing custom monitor options such as screen rotation. The configuration requires the Nix expression language (nix), presumes X11/xserver module usage, and expects the contained attribute sets to correspond to actual hardware outputs. The main parameters include output names, primary head selection, and arbitrary monitor configuration options passed as strings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1709.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ services.xserver.xrandrHeads = [\n    \"HDMI-0\"\n    {\n      output = \"DVI-0\";\n      primary = true;\n      monitorConfig = ''\n        Option \"Rotate\" \"right\"\n      '';\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Runtime FUSE Library Load Errors on macOS - Shell\nDESCRIPTION: Demonstrates a runtime error message encountered when running a FUSE-based binary (sshfs) on macOS with missing FUSE libraries. Illustrates the typical library loading failure output, helping users recognize the root cause and linking the diagnostic output to the recommendation of installing macFUSE. There are no dependencies for this code as it is not meant for direct execution but to indicate common error patterns. The expected output is an error with 'Library not loaded: /usr/local/lib/libfuse.2.dylib' and related abort message.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/fuse.section.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndyld: Library not loaded: /usr/local/lib/libfuse.2.dylib\\nReferenced from: /nix/store/w8bi72bssv0bnxhwfw3xr1mvn7myf37x-sshfs-fuse-2.10/bin/sshfs\\nReason: image not found\\n[1]    92299 abort      /nix/store/w8bi72bssv0bnxhwfw3xr1mvn7myf37x-sshfs-fuse-2.10/bin/sshfs\n```\n\n----------------------------------------\n\nTITLE: Disabling K3s Service in NixOS Configuration - Nix Expression - nix\nDESCRIPTION: This snippet demonstrates how to disable the K3s service within the NixOS system configuration by setting the 'services.k3s.enable' option to false. This action stops the K3s systemd services on subsequent rebuilds. It does not remove persistent K3s data on disk. Prerequisite: Edit and rebuild your '/etc/nixos/configuration.nix' with NixOS tools.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n services.k3s.enable = false;\n```\n\n----------------------------------------\n\nTITLE: Adding EFI System Partition (ESP) Using parted (ShellSession)\nDESCRIPTION: Creates a 511 MiB EFI system (boot) partition at the start of /dev/sda, formatted as FAT32. Sets the ESP (EFI System Partition) flag on the appropriate partition (here partition 3). Assumes the disk uses GPT and sufficient space was reserved during earlier steps. The correct ESP partition number should be verified with 'parted --list' if modifications are made.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mkpart ESP fat32 1MB 512MB\n# parted /dev/sda -- set 3 esp on\n```\n\n----------------------------------------\n\nTITLE: Defining a Lua 5.2 Environment with Extra Packages - Nix Expression - nix\nDESCRIPTION: This snippet demonstrates how to define a Lua 5.2 interpreter environment using a Nix expression file (e.g., build.nix), bundling additional packages such as 'busted' and 'luafilesystem'. Dependencies include the Nixpkgs package set and relevant Lua packages. The main parameter is the Lua interpreter version and the package list. The resulting derivation can be installed into the user profile, providing both the Lua interpreter and the specified libraries within the environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nlua5_2.withPackages (\n  ps: with ps; [\n    busted\n    luafilesystem\n  ]\n)\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Zone DNS Query Limits in BIND - NixOS Service Option - Markdown\nDESCRIPTION: This details the addition of a per-zone allow-query setting in the bind module, allowing admins to restrict or expand DNS query permissions by zone. By default, any is retained for compatibility, but more granular controls can be specified. The feature requires the bind service and updated configuration structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_28\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`bind\\` module now allows the per-zone \\`allow-query\\` setting to be configured (previously it was hard-coded to \\`any\\`; it still defaults to \\`any\\` to retain compatibility).\n```\n\n----------------------------------------\n\nTITLE: Mounting VirtualBox Shared Folders using fileSystems - Nix\nDESCRIPTION: This snippet configures the automatic mounting of a VirtualBox shared folder in NixOS via the fileSystems attribute. It declares a mount point at /virtualboxshare with the fsType 'vboxsf' and the device set to the name of the shared folder. The options array includes 'rw' (read/write) and 'nofail' (system will not block boot if mounting fails). This is used in configuration.nix and assumes the shared folder has already been defined in the VirtualBox GUI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-virtualbox-guest.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ...} :\n{\n  fileSystems.\"/virtualboxshare\" = {\n    fsType = \"vboxsf\";\n    device = \"nameofthesharedfolder\";\n    options = [ \"rw\" \"nofail\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running OCI Container with runc in Shell\nDESCRIPTION: This shell snippet shows how to run the OCI container created by the previous Nix code using runc. It navigates to the build output directory, opens a nix-shell with runc, and then uses sudo to run the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/ocitools.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/7f9hgx0arvhzp2a3qphp28rxbn748l25-join\n\n$ cd /nix/store/7f9hgx0arvhzp2a3qphp28rxbn748l25-join\n$ nix-shell -p runc\n[nix-shell:/nix/store/7f9hgx0arvhzp2a3qphp28rxbn748l25-join]$ sudo runc run ocitools-example\nhelp\nGNU bash, version 5.2.26(1)-release (x86_64-pc-linux-gnu)\n(some output removed for clarity)\n```\n\n----------------------------------------\n\nTITLE: Packaging Ruby Application with bundlerApp in Nix\nDESCRIPTION: Nix expression using bundlerApp to package a Ruby application (mdl) with its dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{ bundlerApp }:\n\nbundlerApp {\n  pname = \"mdl\";\n  gemdir = ./.;\n  exes = [ \"mdl\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Docker Compose configuration for CUDA support (all GPUs)\nDESCRIPTION: This Docker Compose configuration demonstrates how to expose all NVIDIA GPUs to a service using the CDI driver and device reservations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  some-service:\n    image: ubuntu:latest\n    command: sleep infinity\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: cdi\n            device_ids:\n            - nvidia.com/gpu=all\n```\n\n----------------------------------------\n\nTITLE: Evaluating Nixpkgs Attributes with nix-build - Shell\nDESCRIPTION: This shell command invokes the Nix build tool to locally evaluate CI attributes within Nixpkgs. It demonstrates setting the number of parallel jobs, CPU cores per job, attribute chunk size, and target system platforms through command-line arguments. Key parameters include --max-jobs (parallel job count), --cores (CPU cores per job), --arg chunkSize (number of attributes per core at once), and --arg evalSystems (target evaluation platforms). The output depends on system resources and can be constrained by physical memory or CPU availability. Requires Nix installed, and execution within a compatible Nixpkgs repository clone.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/ci/eval/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnix-build ci -A eval.full \\\n  --max-jobs 4 \\\n  --cores 2 \\\n  --arg chunkSize 10000 \\\n  --arg evalSystems '[\"x86_64-linux\" \"aarch64-darwin\"]'\n```\n\n----------------------------------------\n\nTITLE: Configuring XDG Desktop Portals for Flatpak Apps - Nix\nDESCRIPTION: This Nix configuration snippet adds 'xdg-desktop-portal-gtk' as an extra portal and sets the default portal backend to GTK. It is required for non-GNOME environments to ensure Flatpak apps function with proper desktop integration. Dependencies include the 'pkgs.xdg-desktop-portal-gtk' package and the NixOS XDG portal configuration module. Specifies portal choices to enable features like file dialogs and notifications for sandboxed apps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/desktops/flatpak.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  xdg.portal.extraPortals = [ pkgs.xdg-desktop-portal-gtk ];\n  xdg.portal.config.common.default = \"gtk\";\n}\n```\n\n----------------------------------------\n\nTITLE: Docker Compose configuration for CUDA support (specific GPUs)\nDESCRIPTION: This Docker Compose configuration shows how to expose specific NVIDIA GPUs (GPU 0 and GPU 1) to a service using the CDI driver and device reservations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n  some-service:\n    image: ubuntu:latest\n    command: sleep infinity\n    deploy:\n      resources:\n        reservations:\n          devices:\n          - driver: cdi\n            device_ids:\n            - nvidia.com/gpu=0\n            - nvidia.com/gpu=1\n```\n\n----------------------------------------\n\nTITLE: Requiring Manual File Download in Nix\nDESCRIPTION: Demonstrates how to use the requireFile function to request files that cannot be fetched automatically. This example shows requesting a JDK file from Oracle's website, providing a hash for verification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\nrequireFile {\n  name = \"jdk-${version}_linux-x64_bin.tar.gz\";\n  url = \"https://www.oracle.com/java/technologies/javase-jdk11-downloads.html\";\n  hash = \"sha256-lL00+F7jjT71nlKJ7HRQuUQ7kkxVYlZh//5msD8sjeI=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Typst with Custom Packages - Nix\nDESCRIPTION: This snippet demonstrates how to set up a Typst environment using Nix by selecting specific packages from Typst Universe. It uses the withPackages function to include either the latest package versions or user-specified versions, such as 'polylux_0_4_0' and 'cetz_0_3_0'. Dependencies include the Nix package manager and available Typst packages in nixpkgs. The function expects a list of desired package attributes and outputs a customized Typst environment with those packages included.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/typst.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ntypst.withPackages (\n  p: with p; [\n    polylux_0_4_0\n    cetz_0_3_0\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Strip Hash Examples (Bash)\nDESCRIPTION: Examples showing how to strip the hash portion from store paths\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\n# prints coreutils-8.24\nstripHash \"/nix/store/9s9r019176g7cvn2nvcw41gsp862y6b4-coreutils-8.24\"\n\nname=\"/nix/store/9s9r019176g7cvn2nvcw41gsp862y6b4-coreutils-8.24\"\nsomeVar=$(stripHash $name)\n```\n\n----------------------------------------\n\nTITLE: Defining a Build Helper with Manual Attribute Removal Using stdenv.mkDerivation (Nix)\nDESCRIPTION: This Nix snippet demonstrates how to manually define a build helper by constructing a new attribute set, removing unwanted attributes, and passing others to stdenv.mkDerivation. The helper exposes parameters like preferLocalBuild, allowSubstitute, and specialArg (the latter omitted from mkDerivation). Relevant attributes are inherited, and conditional logic is used based on specialArg. Inputs are the attribute set passed to the lambda, and the output is a derivation built as specified. Requires Nixpkgs and access to stdenv.mkDerivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fixed-point-arguments.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  preferLocalBuild ? true,\n  allowSubstitute ? false,\n  specialArg ? (_: false),\n  ...\n}@args:\n\nstdenv.mkDerivation (\n  removeAttrs [\n    # Don\\'t pass specialArg into mkDerivation.\n    \"specialArg\"\n  ] args\n  // {\n    # Arguments to pass\n    inherit preferLocalBuild allowSubstitute;\n    # Some expressions involving specialArg\n    greeting = if specialArg \"hi\" then \"hi\" else \"hello\";\n  }\n)\n\n```\n\n----------------------------------------\n\nTITLE: Packaging a .NET Global Tool using buildDotnetGlobalTool - Nix\nDESCRIPTION: This Nix expression illustrates the usage of buildDotnetGlobalTool to package a third-party .NET global tool, leveraging a specific NuGet package version and hash for reproducible builds. It demonstrates metadata configuration, including homepage, changelog, license, and platforms. Required arguments include pname, version, nugetHash, and optional nugetName and dotnet-runtime. Inputs are Nix attributes for the tool; output is a Nix derivation for the global tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ buildDotnetGlobalTool, lib }:\n\nbuildDotnetGlobalTool {\n  pname = \"pbm\";\n  version = \"1.3.1\";\n\n  nugetHash = \"sha256-ZG2HFyKYhVNVYd2kRlkbAjZJq88OADe3yjxmLuxXDUo=\";\n\n  meta = {\n    homepage = \"https://cmd.petabridge.com/index.html\";\n    changelog = \"https://cmd.petabridge.com/articles/RELEASE_NOTES.html\";\n    license = lib.licenses.unfree;\n    platforms = lib.platforms.linux;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Printing the Contents of a Build Phase - Bash\nDESCRIPTION: This snippet prints the actual contents of the $buildPhase variable for inspection, useful for debugging or editing phases in an interactive build environment within nix-shell. It assumes $buildPhase is non-empty, such as when overridden by an inline shell script.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\necho \"$buildPhase\"\n\n```\n\n----------------------------------------\n\nTITLE: Enabling c2FmZQ Secure File Server – Nix\nDESCRIPTION: This snippet enables the c2FmZQ server service in the NixOS module system by setting its 'enable' option to true. This configuration starts the server process, making it accessible on the default interface and port unless further customized. The only dependency is the c2FmZQ server package present on the system; other network or proxy settings are assumed to be handled elsewhere.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/c2fmzq-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  services.c2fmzq-server.enable = true;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Building Julia Environment with Additional Packages via julia.withPackages (Nix)\nDESCRIPTION: This snippet demonstrates how to create a Julia environment that includes additional Julia packages using the `julia.withPackages` function in Nix. It accepts a list of package names (here, [ \"Plots\" ]) that will be available in the resulting Julia environment. No extra dependencies are required beyond julia and the Nix build environment. The input is a Nix list of package strings. The output is a derivation that generates a Julia environment with the specified packages preinstalled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/julia.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\njulia.withPackages [ \"Plots\" ]\n```\n\n----------------------------------------\n\nTITLE: Switching NixOS Profile During Configuration Build - ShellSession\nDESCRIPTION: This command uses the '-p' flag to specify a custom profile name when switching to a new configuration, causing that configuration (and others with the same profile) to appear in a distinct GRUB submenu. Useful for segregating stable and test configurations. Must be executed as root.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch -p test\n```\n\n----------------------------------------\n\nTITLE: Setting Nginx ProtectHome Option in NixOS\nDESCRIPTION: This code demonstrates how to configure the ProtectHome option for Nginx to allow read-only access to home directories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.nginx.serviceConfig.ProtectHome = \"read-only\";\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting SSHFS Interactively in NixOS\nDESCRIPTION: Commands for interactively mounting and unmounting an SSHFS file system in NixOS. This allows easy access to remote directories using SSH.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sshfs my-user@example.com:/my-dir /mnt/my-dir\n```\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ fusermount -u /mnt/my-dir\n```\n\n----------------------------------------\n\nTITLE: Enabling Trezor Service - NixOS Configuration - Nix\nDESCRIPTION: This Nix code snippet shows how to enable the Trezor Bridge service on NixOS by setting the services.trezord.enable option to true within the configuration.nix system configuration file. The change automatically manages dependency handling, sets up required udev rules to support Trezor hardware wallets, and ensures the Trezor Bridge service is started upon system activation. No external dependencies beyond a standard NixOS installation are required, and this setting is compatible with the module system that manages system services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/trezord.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nservices.trezord.enable = true;\n```\n\n----------------------------------------\n\nTITLE: Building a Layered Docker Image Using Nix dockerTools.buildLayeredImage (nix)\nDESCRIPTION: This example demonstrates use of dockerTools.buildLayeredImage to create a layered Docker image for improved disk efficiency and dependency sharing. The resulting image includes the hello binary and its chain of dependencies, with one layer per store object where possible. The config.Cmd parameter sets /bin/hello as the ENTRYPOINT. Requires dockerTools and hello inputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildLayeredImage {\n  name = \"hello\";\n  tag = \"latest\";\n\n  contents = [ hello ];\n\n  config.Cmd = [ \"/bin/hello\" ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing FoundationDB Backups via CLI (Shell)\nDESCRIPTION: This example shows how to initiate and verify a FoundationDB backup using the fdbbackup command-line utility. The commands are executed as the foundationdb system user and target a backup directory previously whitelisted via the extraReadWritePaths option. Successful usage requires prior configuration and directory creation, and outputs backup job status based on the specified tag and destination.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo -u foundationdb fdbbackup start  -t default -d file:///opt/fdb-backups\n$ sudo -u foundationdb fdbbackup status -t default\n```\n\n----------------------------------------\n\nTITLE: Exporting OpenCL ICD Vendor Path via Environment Variable in Shell (ShellSession)\nDESCRIPTION: This snippet shows how to set the OCL_ICD_VENDORS environment variable in a shell to point the OpenCL loader to ICD vendor files built via nix. It depends on having the specified OpenCL ICD driver built and available in the Nix store. The main parameter is the result of nix-build for rocmPackages.clr.icd, and this value configures where the OpenCL loader will look for available drivers. Input: nix-build for rocmPackages.clr.icd. Output: OpenCL applications use the correct ICD.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ export \\\n  OCL_ICD_VENDORS=`nix-build '<nixpkgs>' --no-out-link -A rocmPackages.clr.icd`/etc/OpenCL/vendors/\n```\n\n----------------------------------------\n\nTITLE: Building a Maven Repository via Double Invocation - Nix Language\nDESCRIPTION: Illustrates the double invocation pattern, using a Nix expression to build a Maven repository as a fixed-output derivation with stdenv.mkDerivation. The Nix definition executes mvn package with the local Maven repository overridden, then prunes transient files before finalizing the output. This approach is simple but may require outputHash changes and is best suited for immutable dependencies. Requires Maven, project source code, and may need a valid outputHash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  maven,\n}:\nstdenv.mkDerivation {\n  name = \"maven-repository\";\n  buildInputs = [ maven ];\n  src = ./.; # or fetchFromGitHub, cleanSourceWith, etc\n  buildPhase = ''\n    runHook preBuild\n\n    mvn package -Dmaven.repo.local=$out\n\n    runHook postBuild\n  '';\n\n  # keep only *.{pom,jar,sha1,nbm} and delete all ephemeral files with lastModified timestamps inside\n  installPhase = ''\n    runHook preInstall\n\n    find $out -type f \\\n      -name \\*.lastUpdated -or \\\n      -name resolver-status.properties -or \\\n      -name _remote.repositories \\\n      -delete\n\n    runHook postInstall\n  '';\n\n  # don't do any fixup\n  dontFixup = true;\n  outputHashAlgo = null;\n  outputHashMode = \"recursive\";\n  # replace this with the correct SHA256\n  outputHash = lib.fakeHash;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a NixOS Container with Custom Network Addresses - ShellSession\nDESCRIPTION: This command creates a 'test' container with configuration supplied by 'test-container.nix', and customizes the network by setting local and host IP addresses using the '--local-address' and '--host-address' flags. Requires root access and a valid configuration file. Enables deterministic network setups necessary for multi-container topologies or specific routing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container create test --config-file test-container.nix \\\n    --local-address 10.235.1.2 --host-address 10.235.1.1\n```\n\n----------------------------------------\n\nTITLE: mkPackageOption GHC Example\nDESCRIPTION: Shows mkPackageOption usage with explicit default and example values for GHC package configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nlib.mkPackageOption pkgs \"GHC\" {\n  default = [ \"ghc\" ];\n  example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.ghc;\n  defaultText = lib.literalExpression \"pkgs.ghc\";\n  example = lib.literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n  description = \"The GHC package to use.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding an Option Using mkForce - Nix\nDESCRIPTION: This snippet uses mkForce to forcefully set the services.httpd.adminAddr option, overriding values set in other modules. Dependencies: mkForce, usually available through pkgs.lib in Nixpkgs. Input: An explicit value; Output: The specified value takes precedence regardless of other module settings. Limitation: Should be used sparingly as it forcibly overrides all previous definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.adminAddr = pkgs.lib.mkForce \"bob@example.org\";\n}\n```\n\n----------------------------------------\n\nTITLE: Running NixOS Tests with nix-build - ShellSession\nDESCRIPTION: This snippet demonstrates how to initiate a NixOS integration/system test using the 'nix-build' command inside a git clone of the nixpkgs repository. It requires a Nix environment, a checkout of the nixpkgs git repository, and valid test attributes (e.g. 'nixosTests.login'). The command will build all dependencies and spin up a QEMU/KVM virtual machine configured to run the specified NixOS test. The expected input is the terminal command list, and the output is creation and execution of the VM test. The code assumes adequate virtualization support and correct repo structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ cd /my/git/clone/of/nixpkgs\n$ nix-build -A nixosTests.login\n```\n\n----------------------------------------\n\nTITLE: Let's Encrypt Configuration for Prosody in NixOS\nDESCRIPTION: Configuration for generating a Let's Encrypt TLS certificate covering the main Prosody endpoint, the MUC endpoint, and the HTTP Upload endpoint using the ACME module in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/prosody.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.acme = {\n    email = \"root@example.org\";\n    acceptTerms = true;\n    certs = {\n      \"example.org\" = {\n        webroot = \"/var/www/example.org\";\n        email = \"root@example.org\";\n        extraDomainNames = [ \"conference.example.org\" \"upload.example.org\" ];\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Demo User Profile in NixOS\nDESCRIPTION: This configuration creates a 'demo' user with password 'demo', uid 1000, adds them to the 'wheel' group, and enables autologin in the SDDM display manager. It's designed for demonstration purposes in a NixOS system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/profiles/demo.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n# Demo {#sec-profile-demo}\n```\n\n----------------------------------------\n\nTITLE: Conditional Packages Based on X Server Status - Nix\nDESCRIPTION: This module conditionally adds Firefox and Thunderbird to environment.systemPackages depending on whether X server is enabled in the merged configuration. Dependencies: Access to config argument and pkgs set. Inputs: Boolean value from config.services.xserver.enable; Output: Adds applications to the system packages only when X server is active. Useful for dynamic or role-based system configurations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ environment.systemPackages =\n    if config.services.xserver.enable then\n      [ pkgs.firefox\n        pkgs.thunderbird\n      ]\n    else\n      [ ];\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying APK Deployment in Emulator Instance - Nix\nDESCRIPTION: Details invoking androidenv.emulateApp in Nix to create a script that starts an emulator and deploys a specific APK, launching it directly by specifying its package and activity names. Supports test automation by ensuring the app is installed and started within the emulator after boot. The 'app', 'package', and 'activity' parameters define what gets launched; all referenced files must be present in the environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nandroidenv.emulateApp {\n  name = \"emulate-MyAndroidApp\";\n  platformVersion = \"24\";\n  abiVersion = \"armeabi-v7a\"; # mips, x86, x86_64\n  systemImageType = \"default\";\n  app = ./MyApp.apk;\n  package = \"MyApp\";\n  activity = \"MainActivity\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Containerd Configuration for Nvidia Runtime\nDESCRIPTION: Containerd configuration template that adds the Nvidia runtime. This file needs to be created at /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/NVIDIA.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n{{ template \"base\" . }}\n\n[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.nvidia]\n  privileged_without_host_devices = false\n  runtime_engine = \"\"\n  runtime_root = \"\"\n  runtime_type = \"io.containerd.runc.v2\"\n\n[plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.nvidia.options]\n  BinaryName = \"/run/current-system/sw/bin/nvidia-container-runtime\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping an AppImage with extra packages in Nix\nDESCRIPTION: This example shows how to wrap an AppImage with additional packages included in the FHS environment. It wraps the IRCCloud desktop client and adds the at-spi2-core package to fix runtime dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/appimagetools.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ appimageTools, fetchurl }:\nlet\n  pname = \"irccloud\";\n  version = \"0.16.0\";\n\n  src = fetchurl {\n    url = \"https://github.com/irccloud/irccloud-desktop/releases/download/v${version}/IRCCloud-${version}-linux-x86_64.AppImage\";\n    hash = \"sha256-/hMPvYdnVB1XjKgU2v47HnVvW4+uC3rhRjbucqin4iI=\";\n  };\nin\nappimageTools.wrapType2 {\n  inherit pname version src;\n  extraPkgs = pkgs: [ pkgs.at-spi2-core ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Userborn for Advanced User Management - Nix - nix\nDESCRIPTION: This snippet enables the Userborn experimental user and group management tool in NixOS via the 'services.userborn.enable' option in 'configuration.nix'. Userborn provides enhanced capabilities, including GID >=1000 users, support for password updates, and password hash security checks. Set 'enable' to true as shown; suitable for setups desiring advanced features or minimal Perl dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nservices.userborn.enable = true;\n```\n\n----------------------------------------\n\nTITLE: nftables-based Implementation for Firewall and NAT - NixOS Module Option - Markdown\nDESCRIPTION: This code describes enabling nftables-based firewalling and NAT by setting networking.nftables. It provides an alternative to the default iptables implementation. The modules affected are firewall and nat; their functionality depends on the nftables package and potentially compatibility with existing rules. Switching requires redesigning or auditing firewall/NAT rules for nftables syntax.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`firewall\\` and \\`nat\\` modules can now optionally rely on an nftables based implementation. Enable \\`networking.nftables\\` to use it.\n```\n\n----------------------------------------\n\nTITLE: Integrating Dhall Package into Nixpkgs using Overlays\nDESCRIPTION: This Nix code demonstrates how to incorporate a Dhall package into the pkgs.dhallPackages hierarchy using overlays. It fetches Nixpkgs, defines overlays, and imports the modified package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n# ./example.nix\n\nlet\n  nixpkgs = builtins.fetchTarball {\n    url = \"https://github.com/NixOS/nixpkgs/archive/94b2848559b12a8ed1fe433084686b2a81123c99.tar.gz\";\n    hash = \"sha256-B4Q3c6IvTLg3Q92qYa8y+i4uTaphtFdjp+Ir3QQjdN0=\";\n  };\n\n  dhallOverlay = self: super: {\n    true = self.callPackage ./true.nix { };\n  };\n\n  overlay = self: super: {\n    dhallPackages = super.dhallPackages.override (old: {\n      overrides = self.lib.composeExtensions (old.overrides or (_: _: { })) dhallOverlay;\n    });\n  };\n\n  pkgs = import nixpkgs {\n    config = { };\n    overlays = [ overlay ];\n  };\n\nin\npkgs\n```\n\n----------------------------------------\n\nTITLE: Accessing Shell in Virtual Machine from Interactive Test\nDESCRIPTION: Example of using shell_interact() to access a shell in a virtual machine from the interactive test environment. Shows how to interact with the VM's shell directly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> machine.shell_interact()\nmachine: Terminal is ready (there is no initial prompt):\n$ hostname\nmachine\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Instance Bitcoind in NixOS\nDESCRIPTION: This snippet shows how to adjust the bitcoind configuration for the new multi-instance setup using submodules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.bitcoind.mainnet = {\n    enable = true;\n    dataDir = \"/var/lib/bitcoind\";\n    user = \"bitcoin\";\n    extraConfig = \"...\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Alternative Java Compilers and Runtimes (Nix)\nDESCRIPTION: Provides an example Nix expression for specifying gcj and ant as build dependencies, enabling use of the GNU Java Compiler and interpreter (gij) instead of OpenJDK. Inputs: gcj and ant packages. Results in builds using the alternative GNU toolchain managed transparently by ant.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [\n    gcj\n    ant\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Container Service Status via systemctl - ShellSession\nDESCRIPTION: Retrieves the status of the systemd service unit backing the 'foo' container using the systemctl command. Useful for debugging, checking container uptime, and inspecting logs if startup fails. Requires host root access; the service unit follows the naming pattern container@container-name.service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemctl status container@foo\n```\n\n----------------------------------------\n\nTITLE: Joining Multiple Derivations via Symlinks - symlinkJoin - Nix\nDESCRIPTION: This snippet illustrates the use of symlinkJoin to collect several derivations (in this example, hello and stack) into a single directory structure with symlinks. It defines a custom name (myexample), a list of paths, and a postBuild shell action that prints a confirmation message. Dependencies include pkgs.hello and pkgs.stack. The output derivation symlinks binaries and resources from the input derivations, effectively aggregating their outputs for downstream usage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n# adds symlinks of hello and stack to current build and prints \"links added\"\nsymlinkJoin {\n  name = \"myexample\";\n  paths = [\n    pkgs.hello\n    pkgs.stack\n  ];\n  postBuild = \"echo links added\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Build and Install Phases in a Builder Script - Bash\nDESCRIPTION: This Bash script shows how to define buildPhase and installPhase functions within a builder script for Nix. The buildPhase compiles foo.c, and installPhase places the resulting binary into $out/bin. genericBuild is called to run the set phases in the prescribed order. The script requires that environment variables like $out are correctly set (by stdenv), and it runs inside the Nix build sandbox.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbuildPhase() {\n  echo \"... this is my custom build phase ...\"\n  gcc foo.c -o foo\n}\n\ninstallPhase() {\n  mkdir -p $out/bin\n  cp foo $out/bin\n}\n\ngenericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Zig Build Hook in Nixpkgs with Nix - nix\nDESCRIPTION: This code snippet demonstrates adding zig.hook to a Nixpkgs derivation. It includes zig.hook in nativeBuildInputs to override the default build, check, and install phases with Zig-specific logic, sets zigBuildFlags to enable man page generation, and uses dontUseZigCheck to skip the Zig check phase. Dependencies are lib, stdenv, and zig. Inputs: Nix derivation arguments; Outputs: Customized build environment. Requires familiarity with the Nix language and environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/zig.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  zig,\n}:\n\nstdenv.mkDerivation {\n  # . . .\n\n  nativeBuildInputs = [\n    zig.hook\n  ];\n\n  zigBuildFlags = [ \"-Dman-pages=true\" ];\n\n  dontUseZigCheck = true;\n\n  # . . .\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Dokuwiki Multi-Instance Service with SSL - Nix - Nix\nDESCRIPTION: Illustrates the updated configuration pattern for the Dokuwiki service using submodules for multi-instance support. The instance 'mywiki' is named explicitly, and SSL is enabled via the 'nginx' subattributes. Dependencies include Nixpkgs version supporting multi-instance Dokuwiki and nginx reverse proxying. Key parameters: instance name, 'enable', 'nginx.forceSSL', and 'nginx.enableACME'. The expected result is that Dokuwiki is served securely under the specified instance.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.dokuwiki.\"mywiki\" = {\n    enable = true;\n    nginx = {\n      forceSSL = true;\n      enableACME = true;\n    };\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building a new or updated Node.js package in Nix\nDESCRIPTION: Commands to build and test a new or updated Node.js package in nixpkgs using nix-build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnix-build -A nodePackages.<new-or-updated-package>\n```\n\nLANGUAGE: shell\nCODE:\n```\nnix-build -A nodePackages_latest.<new-or-updated-package>\n```\n\n----------------------------------------\n\nTITLE: Creating nixbld Group and User (Shell)\nDESCRIPTION: Creates a dedicated nixbld group and user with explicit IDs to ensure build user consistency across distributions. Uses groupadd and useradd with fixed UID/GID. Prerequisite: Administrative (sudo) privileges. Parameters: none needed. Output: Group and user added to the system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo groupadd -g 30000 nixbld\\n$ sudo useradd -u 30000 -g nixbld -G nixbld nixbld\n```\n\n----------------------------------------\n\nTITLE: Sample NuGet Dependencies JSON Output\nDESCRIPTION: Example JSON output generated by nuget-to-json tool showing package names, versions, and SHA256 hashes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"pname\": \"Avalonia\",\n    \"version\": \"11.1.3\",\n    \"hash\": \"sha256-kz+k/vkuWoL0XBvRT8SadMOmmRCFk9W/J4k/IM6oYX0=\"\n  },\n  {\n    \"pname\": \"Avalonia.Angle.Windows.Natives\",\n    \"version\": \"2.1.22045.20230930\",\n    \"hash\": \"sha256-RxPcWUT3b/+R3Tu5E5ftpr5ppCLZrhm+OTsi0SwW3pc=\"\n  },\n  {\n    \"pname\": \"Avalonia.BuildServices\",\n    \"version\": \"0.0.29\",\n    \"hash\": \"sha256-WPHRMNowRnYSCh88DWNBCltWsLPyOfzXGzBqLYE7tRY=\"\n  },\n  {\n    \"pname\": \"System.Runtime.CompilerServices.Unsafe\",\n    \"version\": \"6.0.0\",\n    \"hash\": \"sha256-bEG1PnDp7uKYz/OgLOWs3RWwQSVYm+AnPwVmAmcgp2I=\"\n  },\n  {\n    \"pname\": \"System.Security.Cryptography.ProtectedData\",\n    \"version\": \"4.5.0\",\n    \"hash\": \"sha256-Z+X1Z2lErLL7Ynt2jFszku6/IgrngO3V1bSfZTBiFIc=\"\n  },\n  {\n    \"pname\": \"Tmds.DBus.Protocol\",\n    \"version\": \"0.16.0\",\n    \"hash\": \"sha256-vKYEaa1EszR7alHj48R8G3uYArhI+zh2ZgiBv955E98=\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom PostgreSQL Package with Plugins using Overlay\nDESCRIPTION: Example of creating a custom PostgreSQL package with selected plugins using the withPackages function in a Nixpkgs overlay. This allows using PostgreSQL with plugins outside of NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nself: super: {\n  postgresql_custom = self.postgresql_17.withPackages (ps: [\n    ps.pg_repack\n    ps.postgis\n  ]);\n}\n```\n\n----------------------------------------\n\nTITLE: Patching SwiftPM Dependencies in Nix Build Derivation\nDESCRIPTION: This snippet augments the `configurePhase` in a Nix derivation, using Nix string concatenation to add commands for making a SwiftPM dependency directory writable (via `swiftpmMakeMutable`) and applying a patch. It is relevant for projects with dependencies packaged in the Nix store as read-only and requires patching for project builds. It relies on having `generated.configure`, project patch files, and appropriate permissions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  configurePhase = generated.configure ++ ''\n    # Replace the dependency symlink with a writable copy.\n    swiftpmMakeMutable swift-crypto\n    # Now apply a patch.\n    patch -p1 -d .build/checkouts/swift-crypto -i ${./some-fix.patch}\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Firewall for Mediatomb Service in NixOS with Nix - nix\nDESCRIPTION: This snippet enables the firewall for the Mediatomb service by setting the 'openFirewall' option to true in a NixOS configuration. The 'services.mediatomb.openFirewall' parameter controls whether the service opens required firewall ports. This should be used in a 'configuration.nix' file within a NixOS system. Expects boolean value; careful if firewall rules were previously added automatically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mediatomb.openFirewall = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating GPT Partition Scheme for UEFI-based NixOS Installation\nDESCRIPTION: Commands to create a GPT partition scheme with root, swap, and ESP partitions for UEFI-based systems. Sets the ESP flag on the boot partition for UEFI firmware recognition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_24\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mklabel gpt\n# parted /dev/sda -- mkpart root ext4 512MB -8GB\n# parted /dev/sda -- mkpart swap linux-swap -8GB 100%\n# parted /dev/sda -- mkpart ESP fat32 1MB 512MB\n# parted /dev/sda -- set 3 esp on\n```\n\n----------------------------------------\n\nTITLE: Adding HTTP/3 Alt-Svc Headers in Nginx - Nix\nDESCRIPTION: This snippet shows how to explicitly add Alt-Svc HTTP/3 headers within NixOS's nginx module configuration using Nix language. It demonstrates setting the 'extraConfig' for different 'locations' to manually advertise HTTP/3 support, reflecting the change that HTTP/3 is no longer advertised automatically. Requires NixOS with nginx service enabled. The input for each location's 'extraConfig' parameter is a multi-line string that sets the appropriate HTTP header. Input: Nix attribute set for nginx module configuration; Output: HTTP/3 Alt-Svc header in nginx response. Limitation: Must be applied per relevant location block.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2405.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  locations.\"/\".extraConfig = ''\n    add_header Alt-Svc 'h3=\":$server_port\"; ma=86400';\n  '';\n  locations.\"^~ /assets/\".extraConfig = ''\n    add_header Alt-Svc 'h3=\":$server_port\"; ma=86400';\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fixed-Point Arguments in mkDerivation in Nix\nDESCRIPTION: This example demonstrates how to use finalAttrs in mkDerivation to create self-referential attribute sets that are aware of overrides. It shows how to configure optional features that can be consistently modified with overrideAttrs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\nmkDerivation (finalAttrs: {\n  pname = \"hello\";\n  withFeature = true;\n  configureFlags = lib.optionals finalAttrs.withFeature [ \"--with-feature\" ];\n})\n```\n\n----------------------------------------\n\nTITLE: Wrapping an AppImage from GitHub using appimageTools in Nix\nDESCRIPTION: This example demonstrates how to wrap an AppImage file downloaded from GitHub using appimageTools.wrapType2. It fetches the Nuclear music player AppImage file and creates an FHS environment for it to run in.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/appimagetools.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ appimageTools, fetchurl }:\nlet\n  pname = \"nuclear\";\n  version = \"0.6.30\";\n\n  src = fetchurl {\n    url = \"https://github.com/nukeop/nuclear/releases/download/v${version}/nuclear-v${version}.AppImage\";\n    hash = \"sha256-he1uGC1M/nFcKpMM9JKY4oeexJcnzV0ZRxhTjtJz6xw=\";\n  };\nin\nappimageTools.wrapType2 {\n  inherit pname version src;\n}\n```\n\n----------------------------------------\n\nTITLE: Required NixOS Path Structure\nDESCRIPTION: Lists of essential filesystem paths that must remain persistent for NixOS to function properly, including the Nix store, boot configuration, and user management files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/nixos-state.section.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n/nix/store\n/nix/var/nix\n/boot\n/var/lib/nixos\n/etc/passwd\n/etc/group\n/etc/shadow\n/etc/gshadow\n/etc/subuid\n/etc/subgid\n```\n\n----------------------------------------\n\nTITLE: Installing a Custom Environment into the User Profile - Shell\nDESCRIPTION: Installs the 'myEnv' environment (as defined by a Nix overlay) into the user's profile using nix-env. This command queries the overlay/package, builds it if needed, and adds it to the current user environment. Requires a previously defined overlay with a 'myEnv' attribute. No parameters beyond the package attribute; will fail if 'myEnv' is not found. Used for globally installing a predefined environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_25\n\nLANGUAGE: sh\nCODE:\n```\nnix-env -iA myEnv\n```\n\n----------------------------------------\n\nTITLE: Building PHP Application with php.buildComposerProject2 in Nix\nDESCRIPTION: Example demonstrating how to build a PHP application using the php.buildComposerProject2 wrapper function, which handles Composer dependency management automatically. It includes configuration for custom PHP version with extensions and vendor hash management.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{ php, fetchFromGitHub }:\n\nphp.buildComposerProject2 (finalAttrs: {\n  pname = \"php-app\";\n  version = \"1.0.0\";\n\n  src = fetchFromGitHub {\n    owner = \"git-owner\";\n    repo = \"git-repo\";\n    tag = finalAttrs.version;\n    hash = \"sha256-VcQRSss2dssfkJ+iUb5qT+FJ10GHiFDzySigcmuVI+8=\";\n  };\n\n  # PHP version containing the `ast` extension enabled\n  php = php.buildEnv {\n    extensions = (\n      { enabled, all }:\n      enabled\n      ++ (with all; [\n        ast\n      ])\n    );\n  };\n\n  # The composer vendor hash\n  vendorHash = \"sha256-86s/F+/5cBAwBqZ2yaGRM5rTGLmou5//aLRK5SA0WiQ=\";\n\n  # If the composer.lock file is missing from the repository, add it:\n  # composerLock = ./path/to/composer.lock;\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Security Patches with fetchpatch - Nix Expression\nDESCRIPTION: Shows how to apply a security patch in a nix expression using the fetchpatch function, specifying the patch filename, URL, and hash for provenance and reproducibility. This is intended for package maintainers addressing CVEs. Requires Nix expressions with fetchpatch available and correct hashes; the result is an importable patch reference for the package definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n(fetchpatch {\n  name = \"CVE-2019-11068.patch\";\n  url = \"https://gitlab.gnome.org/GNOME/libxslt/commit/e03553605b45c88f0b4b2980adfbbb8f6fca2fd6.patch\";\n  hash = \"sha256-SEKe/8HcW0UBHCfPTTOnpRlzmV2nQPPeL6HOMxBZd14=\";\n})\n```\n\n----------------------------------------\n\nTITLE: Python Script with Reproducible nix-shell Shebang and Pinned nixpkgs - Python - Python\nDESCRIPTION: Script uses a nix-shell shebang and pins a specific nixpkgs git commit in the shebang metadata, ensuring fully reproducible environment regardless of when/where it is executed. Any run pulls dependencies exactly as specified by the URL, guaranteeing consistent package versions. Supports use on multiple machines/CI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env nix-shell\n#!nix-shell -i python3 -p \"python3.withPackages (ps: [ ps.numpy ])\"\n#!nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/e51209796c4262bfb8908e3d6d72302fe4e96f5f.tar.gz\nimport numpy as np\na = np.array([1,2])\nb = np.array([3,4])\nprint(f\"The dot product of {a} and {b} is: {np.dot(a, b)}\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Coq Library Derivation using mkCoqDerivation in Nix\nDESCRIPTION: This example demonstrates how to create a derivation for a Coq library called 'multinomials' using mkCoqDerivation. It specifies dependencies, version selection logic, and release information.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  mkCoqDerivation,\n  version ? null,\n  coq,\n  mathcomp,\n  mathcomp-finmap,\n  mathcomp-bigenough,\n}:\n\nmkCoqDerivation {\n  # namePrefix leads to e.g. `name = coq8.11-mathcomp1.11-multinomials-1.5.2`\n  namePrefix = [\n    \"coq\"\n    \"mathcomp\"\n  ];\n  pname = \"multinomials\";\n  owner = \"math-comp\";\n  inherit version;\n  defaultVersion =\n    with lib.versions;\n    lib.switch\n      [ coq.version mathcomp.version ]\n      [\n        {\n          cases = [\n            (range \"8.7\" \"8.12\")\n            (isEq \"1.11\")\n          ];\n          out = \"1.5.2\";\n        }\n        {\n          cases = [\n            (range \"8.7\" \"8.11\")\n            (range \"1.8\" \"1.10\")\n          ];\n          out = \"1.5.0\";\n        }\n        {\n          cases = [\n            (range \"8.7\" \"8.10\")\n            (range \"1.8\" \"1.10\")\n          ];\n          out = \"1.4\";\n        }\n        {\n          cases = [\n            (isEq \"8.6\")\n            (range \"1.6\" \"1.7\")\n          ];\n          out = \"1.1\";\n        }\n      ]\n      null;\n  release = {\n    \"1.5.2\".hash = \"sha256-mjCx9XKa38Nz9E6wNK7YSqHdJ7YTua5fD3d6J4e7WpU=\";\n    \"1.5.1\".hash = \"sha256-Q8tm0y2FQAt2V1kZYkDlHWRia/lTvXAMVjdmzEV11I4=\";\n    \"1.5.0\".hash = \"sha256-HIK0f21G69oEW8JG46gSBde/Q2LR3GiBCv680gHbmRg=\";\n    \"1.5.0\".rev = \"1.5\";\n    \"1.4\".hash = \"sha256-F9g3MSIr3B6UZ3p8QWjz3/Jpw9sudJ+KRlvjiHSO024=\";\n    \"1.3\".hash = \"sha256-BPJTlAL0ETHvLMBslE0KFVt3DNoaGuMrHt2SBGyJe1A=\";\n    \"1.2\".hash = \"sha256-mHXBXSLYO4BN+jfN50y/+XCx0Qq5g4Ac2Y/qlsbgAdY=\";\n    \"1.1\".hash = \"sha256-ejAsMQbB/LtU9j+g160VdGXULrCe9s0gBWzyhKqmCuE=\";\n    \"1.0\".hash = \"sha256-tZTOltEBBKWciDxDMs/Ye4Jnq/33CANrHJ4FBMPtq+I=\";\n  };\n\n  propagatedBuildInputs = [\n    mathcomp.ssreflect\n    mathcomp.algebra\n\n```\n\n----------------------------------------\n\nTITLE: Connecting Test VM Shell to Socat TCP Proxy\nDESCRIPTION: Python command to connect a test VM's shell to a socat TCP proxy. This enables better terminal control when interacting with the VM shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> machine.shell_interact(\"tcp:127.0.0.1:4444\")\n```\n\n----------------------------------------\n\nTITLE: Building JetBrains IDEA Community Edition from Source with Maven Artefacts - Build Command - shell\nDESCRIPTION: Illustrates how to build the JetBrains IDEA Community Edition from source and generate related Maven artefacts using a Nix build and a Python script. The first part, 'nix build .#jetbrains.idea-community-src.src.src', produces the required sources, followed by 'source/build_maven.py source/idea_maven_artefacts.json result/' to assemble artefacts. Requires Nix, Python, and dependencies specified in these scripts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jetbrains/readme.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnix build .#jetbrains.idea-community-src.src.src && ./source/build_maven.py source/idea_maven_artefacts.json result/\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Binary Cache via nixos-rebuild Command - ShellSession\nDESCRIPTION: This shell session command demonstrates configuring the nixos-rebuild operation to use a specified alternative binary cache instead of the default. By providing the --option binary-caches flag with a custom cache URL, users can direct Nix to pull build artifacts from another server. Dependencies include access to the chosen HTTP cache and standard nixos-rebuild usage. Inputs include the URL of the cache server, and output is the same as a standard rebuild, but potentially with faster downloads or alternate cache sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/network-problems.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch --option binary-caches http://my-cache.example.org/\n```\n\n----------------------------------------\n\nTITLE: Destroying a NixOS Container - ShellSession\nDESCRIPTION: Destroys the 'foo' container, removing its file system and any associated state, using the 'destroy' operation. This is a non-reversible action requiring root access. Used to completely remove all traces of a container, including disk usage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container destroy foo\n```\n\n----------------------------------------\n\nTITLE: Configuring Transmission Service BindPaths - Nix\nDESCRIPTION: This snippet demonstrates how to modify the NixOS systemd service configuration for Transmission to allow access to an alternative download directory. It assumes a NixOS environment with systemd as the init system and edits the 'BindPaths' setting for the Transmission daemon, increasing flexibility for torrent storage. The 'BindPaths' attribute should be a list containing additional directories the service is allowed to access; incorrect paths may result in restricted access or security concerns.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.transmission.serviceConfig.BindPaths = [ \"/path/to/alternative/download-dir\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging an OCaml Library (angstrom) with buildDunePackage\nDESCRIPTION: This example shows how to package the 'angstrom' OCaml library using buildDunePackage. It includes setting version constraints, fetching source from GitHub, specifying build and test dependencies, and configuring meta information.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ocaml.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchFromGitHub,\n  buildDunePackage,\n  ocaml,\n  ocaml-syntax-shims,\n  alcotest,\n  result,\n  bigstringaf,\n  ppx_let,\n}:\n\nbuildDunePackage rec {\n  pname = \"angstrom\";\n  version = \"0.15.0\";\n\n  minimalOCamlVersion = \"4.04\";\n\n  src = fetchFromGitHub {\n    owner = \"inhabitedtype\";\n    repo = \"angstrom\";\n    tag = version;\n    hash = \"sha256-MK8o+iPGANEhrrTc1Kz9LBilx2bDPQt7Pp5P2libucI=\";\n  };\n\n  checkInputs = [\n    alcotest\n    ppx_let\n  ];\n  buildInputs = [ ocaml-syntax-shims ];\n  propagatedBuildInputs = [\n    bigstringaf\n    result\n  ];\n  doCheck = lib.versionAtLeast ocaml.version \"4.05\";\n\n  meta = {\n    homepage = \"https://github.com/inhabitedtype/angstrom\";\n    description = \"OCaml parser combinators built for speed and memory efficiency\";\n    license = lib.licenses.bsd3;\n    maintainers = with lib.maintainers; [ sternenseemann ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building dependent packages using nixpkgs-review\nDESCRIPTION: Command to build and test all dependent packages for a pull request in nixpkgs\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/tools/package-management/nix/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnixpkgs-review pr <your-pull-request>\n```\n\n----------------------------------------\n\nTITLE: Creating Xcode Wrapper Package in Nix\nDESCRIPTION: This snippet demonstrates how to create a Nix package that exposes Xcode executables through symlinks. It uses the xcodeenv.composeXcodeWrapper function to create a wrapper for a specific Xcode version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n\n  xcodeenv = import ./xcodeenv {\n    inherit (pkgs) stdenv;\n  };\nin\nxcodeenv.composeXcodeWrapper {\n  version = \"9.2\";\n  xcodeBaseDir = \"/Applications/Xcode.app\";\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling realpath_cache for PHP in Nextcloud - Nix\nDESCRIPTION: This NixOS settings snippet shows how to disable PHP's realpath_cache for the Nextcloud service by setting the realpath_cache_size to 0 in phpOptions. This workaround prevents file-not-found errors after updates when using dynamic secrets with mechanisms like sops-nix. It requires the Nextcloud NixOS module and PHP as dependencies. The key parameter is 'realpath_cache_size', and output is a change in the PHP runtime behavior to disable realpath caching.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/nextcloud.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nservices.nextcloud.phpOptions.\"realpath_cache_size\" = \"0\";\n```\n\n----------------------------------------\n\nTITLE: Assigning Custom EDID Files to Video Outputs - Nix\nDESCRIPTION: This Nix snippet shows how to assign specific custom EDID binaries to hardware outputs by setting hardware.display.outputs.\"<NAME>\".edid. Each assignment results in corresponding drm.edid_firmware entries in boot.kernelParams. No external dependencies are required beyond valid custom EDID files, which must be made available via hardware.display.edid.packages. Inputs are output names and EDID filenames; output is a NixOS configuration instructing the kernel to apply custom EDIDs to selected display outputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.display.outputs.\"VGA-1\".edid = \"custom1.bin\";\n  hardware.display.outputs.\"VGA-2\".edid = \"custom2.bin\";\n  /* equals:\n  boot.kernelParams = [ \"drm.edid_firmware=VGA-1:edid/custom1.bin,VGA-2:edid/custom2.bin\" ];\n  */\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Python Script with Standard Shebang - Python - Python\nDESCRIPTION: Basic script using /usr/bin/env python3, demonstrating import of numpy and simple dot product calculation. Requires numpy to be available to the Python interpreter in PATH/environment. Inputs are hardcoded arrays, output is the dot product printed to stdout.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\nimport numpy as np\na = np.array([1,2])\nb = np.array([3,4])\nprint(f\"The dot product of {a} and {b} is: {np.dot(a, b)}\")\n```\n\n----------------------------------------\n\nTITLE: Shellcheck validation for multiple files in Nix\nDESCRIPTION: Shows how to run shellcheck on multiple shell script files using fileset to select specific files for testing. This approach allows for targeted validation of shell scripts within a directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  inherit (lib) fileset;\nin\ntesters.shellcheck {\n  name = \"nixbsd-activate\";\n  src = fileset.toSource {\n    root = ./.; \n    fileset = fileset.unions [\n      ./lib.sh\n      ./nixbsd-activate\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Netbird Server with Coturn and SSO in NixOS (Nix)\nDESCRIPTION: This snippet provides a minimal NixOS configuration for deploying the Netbird server, integrating it with Coturn for TURN relay functionality and specifying an OpenID Connect identity provider endpoint. The example illustrates how to enable services, set domain names, define secure paths to secret files for credentials, and configure TURN settings required by Netbird. The dependencies include a functional NixOS setup and valid file paths for sensitive information. Users should replace the sample values with environment-specific details before deployment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/netbird/server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nservices.netbird.server = {\n  enable = true;\n\n  domain = \"netbird.example.selfhosted\";\n\n  enableNginx = true;\n\n  coturn = {\n    enable = true;\n\n    passwordFile = \"/path/to/a/secret/password\";\n  };\n\n  management = {\n    oidcConfigEndpoint = \"https://sso.example.selfhosted/oauth2/openid/netbird/.well-known/openid-configuration\";\n\n    settings = {\n      TURNConfig = {\n        Turns = [\n          {\n            Proto = \"udp\";\n            URI = \"turn:netbird.example.selfhosted:3478\";\n            Username = \"netbird\";\n            Password._secret = \"/path/to/a/secret/password\";\n          }\n        ];\n      };\n    };\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Importing TensorRT Releases in Nix\nDESCRIPTION: This code snippet shows how to import the TensorRT releases file, which contains release expressions for TensorRT. It illustrates the use of relative imports in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/modules/README.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n../tensorrt/releases.nix\n```\n\n----------------------------------------\n\nTITLE: Enabling Rosetta Translation in Virtualised NixOS Guests - NixOS Module Configuration - Markdown\nDESCRIPTION: This snippet describes the introduction of a new virtualisation.rosetta option, allowing seamless execution of x86_64 binaries via Apple's Rosetta within Apple Silicon virtual machines. The feature works by default when using the UTM virtualization package. It requires an Apple Silicon host and installation of the UTM package for virtualization. Inputs and outputs are at the system configuration level, enabling transparent support for legacy binaries when configured.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n- A new \\`virtualisation.rosetta\\` module was added to allow running \\`x86_64\\` binaries through [Rosetta](https://developer.apple.com/documentation/apple-silicon/about-the-rosetta-translation-environment) inside virtualised NixOS guests on Apple Silicon. This feature works by default with the [UTM](https://docs.getutm.app/) virtualisation [package](https://search.nixos.org/packages?channel=23.05&show=utm&from=0&size=1&sort=relevance&type=packages&query=utm).\n```\n\n----------------------------------------\n\nTITLE: Running Podman container with multiple specific NVIDIA GPUs\nDESCRIPTION: This command shows how to run a Podman container with multiple specific NVIDIA GPUs (GPU 0 and GPU 1) exposed to the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_12\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ podman run --rm -it --device=nvidia.com/gpu=0 --device=nvidia.com/gpu=1 ubuntu:latest nvidia-smi -L\nGPU 0: NVIDIA GeForce RTX 4090 (UUID: <REDACTED>)\nGPU 1: NVIDIA GeForce RTX 2080 SUPER (UUID: <REDACTED>)\n```\n\n----------------------------------------\n\nTITLE: Generating EDID Files from XFree86 Modeline Definitions with edid-generator - Nix\nDESCRIPTION: This code snippet demonstrates using hardware.display.edid.modelines to specify custom modelines for EDID generation in NixOS. It uses pkgs.edid-generator, converting XFree86 Modeline strings into EDID binaries, which are then automatically registered via hardware.display.edid.packages. Inputs are modeline strings matching XFree86 format; output is a derivation with the corresponding EDID files. This approach assists in auto-generating EDIDs for non-standard display configurations without requiring extracted binaries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.display.edid.modelines.\"PG278Q_60\" = \"    241.50   2560 2608 2640 2720   1440 1443 1448 1481   -hsync +vsync\";\n  hardware.display.edid.modelines.\"PG278Q_120\" = \"   497.75   2560 2608 2640 2720   1440 1443 1448 1525   +hsync -vsync\";\n\n  /* equals:\n  hardware.display.edid.packages = [\n    (pkgs.edid-generator.overrideAttrs {\n      clean = true;\n      modelines = ''\n        Modeline \"PG278Q_60\"      241.50   2560 2608 2640 2720   1440 1443 1448 1481   -hsync +vsync\n        Modeline \"PG278Q_120\"     497.75   2560 2608 2640 2720   1440 1443 1448 1525   +hsync -vsync\n      '';\n    })\n  ];\n  */\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting with Deprecated Option Produces Error - SSHFS with Fuse3 3.15+ - Bash\nDESCRIPTION: This bash snippet illustrates the effect of Fuse3's stricter option handling as of version 3.15.0: attempting to mount with an unsupported option (e.g., -o atime) causes the operation to fail with an error. The command mounts a remote SSHFS filesystem using a now-unsupported mount option; expected output is an error and exit status 1 instead of silent acceptance. Users should verify which options are still allowed in their fuse3/git version when adapting automation scripts. The snippet is for demonstration and should be used cautiously on real systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sshfs 127.0.0.1:/home/test/testdir /home/test/sshfs_mnt -o atime\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nix Build Output with fetchzip (Default stripRoot) - Shell\nDESCRIPTION: This shell snippet displays the output of building a Nix derivation using fetchzip with stripRoot enabled (default). After running nix-build, it shows how the contents of the fetched and extracted archive are available directly at the top level in the Nix store. No dependencies are needed; this is purely for demonstrating the results of the fetchzip invocation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/1b7h3fvmgrcddvs0m299hnqxlgli1yjw-source\n\n$ ls /nix/store/1b7h3fvmgrcddvs0m299hnqxlgli1yjw-source\naclocal.m4  completions  configure.ac  m4           Makefile.in  patchelf.spec     README.md  tests\nbuild-aux   configure    COPYING       Makefile.am  patchelf.1   patchelf.spec.in  src        version\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables in NixOS\nDESCRIPTION: Demonstrates how to set environment variables in NixOS using the environment.variables option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nenvironment.variables = { EDITOR = \"your-editor\"; };\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Cue Validators in Nix\nDESCRIPTION: This snippet shows how to create generic Cue validators in Nix. It defines a function that generates validators for different versions of a schema, demonstrating schema evolution and reuse.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuelang.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\nlet\n  genericValidator =\n    version:\n    pkgs.writeCueValidator (pkgs.writeText \"schema.cue\" ''\n      #Version1: {\n        field1: string\n      }\n      #Version2: #Version1 & {\n        field1: \"unused\"\n      }'') { document = \"#Version${toString version}\"; };\nin\n{\n  validateV1 = genericValidator 1;\n  validateV2 = genericValidator 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Urxvt Plugins in Nix\nDESCRIPTION: This snippet demonstrates how to override the default Urxvt configuration to include specific plugins. It uses the 'configure' attribute to specify a list of desired plugins from the available options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nrxvt-unicode.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      plugins = with availablePlugins; [\n        perls\n        resize-font\n        vtwheel\n      ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Bundling Astal Application with ags in NixOS\nDESCRIPTION: This snippet demonstrates how to use the 'ags.bundle' function to package an Astal application in NixOS. It includes setting the package name, version, source, entry point, dependencies, and other optional configurations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/astal.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nags.bundle {\n  pname = \"hyprpanel\";\n  version = \"1.0.0\";\n\n  src = fetchFromGitHub {\n    #...\n  };\n\n  # change your entry file (default is `app.ts`)\n  entry = \"app.ts\";\n\n  dependencies = [\n    # list here astal modules, that your package depends on\n    # `astal3`, `astal4` and `astal.io` are automatically included\n    astal.apps\n    astal.battery\n    astal.bluetooth\n\n    # you can also list here other runtime dependencies\n    hypridle\n    hyprpicker\n    hyprsunset\n  ];\n\n  # GTK 4 support is opt-in\n  enableGtk4 = true;\n\n  meta = {\n    #...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Standalone Custom Package Expression (Nix, nix)\nDESCRIPTION: Defines a complete Nix derivation for GNU Hello inside a separate 'my-hello.nix' file, using standard environment (stdenv.mkDerivation) and fetchurl for downloading. Inputs are taken from Nixpkgs brought into scope. Outputs a buildable Nix derivation for the package. Prerequisites: Nix/nixpkgs, stdenv, fetchurl available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> {}; # bring all of Nixpkgs into scope\\n\\nstdenv.mkDerivation rec {\\n  name = \\\"hello-2.8\\\";\\n  src = fetchurl {\\n    url = \\\"mirror://gnu/hello/${name}.tar.gz\\\";\\n    hash = \\\"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\\\";\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Agda Library Source with Local Repository - Nix - nix\nDESCRIPTION: Illustrates overriding the src attribute of a standard Agda library package to use a local repository. By calling overrideAttrs within agda.withPackages, a custom version and src can be specified for development or testing, requiring local filesystem access and a valid Agda package directory. Inputs are a function argument p (agdaPackages) and the overridden attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages (p: [\n  (p.standard-library.overrideAttrs (oldAttrs: {\n    version = \"local version\";\n    src = /path/to/local/repo/agda-stdlib;\n  }))\n])\n```\n\n----------------------------------------\n\nTITLE: Testing Vulkan Installation with vulkaninfo Command (ShellSession)\nDESCRIPTION: Demonstrates running vulkaninfo and grepping for GPU entries to verify which devices and drivers are found by the Vulkan loader. This requires vulkan-tools (providing vulkaninfo) to be installed. The snippet shows parsing the output, relevant to confirming successful Vulkan driver setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ vulkaninfo | grep GPU\n                GPU id  : 0 (Unknown AMD GPU)\n                GPU id  : 1 (AMD RADV NAVI10 (LLVM 9.0.1))\n     ...\nGPU0:\n        deviceType     = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU\n        deviceName     = Unknown AMD GPU\nGPU1:\n        deviceType     = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU\n```\n\n----------------------------------------\n\nTITLE: Packaging a Factor Vocabulary with buildFactorVocab (Nix)\nDESCRIPTION: This Nix code snippet demonstrates how to use the 'buildFactorVocab' function to package a Factor vocabulary (in this case, implementing the Bresenham algorithm) for integration into Nixpkgs. It specifies the package name, version, and source (fetched from a GitHub repository), and relies on standard Factor packaging conventions and directory layouts covered in the surrounding documentation. Dependencies are 'factorPackages' (providing build utilities) and 'fetchFromGitHub' (sourcing code). Input keys such as 'pname', 'version', and 'src' must be specified, and additional attributes like 'extraLibs' or 'extraPaths' can be used if required. Outputs include a Nix derivation that installs the vocabulary under 'lib/factor/extra'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/factor.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  factorPackages,\n  fetchFromGitHub,\n}:\n\nfactorPackages.buildFactorVocab {\n  pname = \"bresenham\";\n  version = \"dev\";\n\n  src = fetchFromGitHub {\n    owner = \"Capital-EX\";\n    repo = \"bresenham\";\n    rev = \"58d76b31a17f547e19597a09d02d46a742bf6808\";\n    hash = \"sha256-cfQOlB877sofxo29ahlRHVpN3wYTUc/rFr9CJ89dsME=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Android SDK Repository Sources - Nix\nDESCRIPTION: Presents an attribute set used to specify custom XML repository files for packages, images, and addons. Used as an argument to composeAndroidPackages, this setup enables building the Android SDK against local or non-standard repositories. Implemented by referencing XML files from the working directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  repoXmls = {\n    packages = [ ./xml/repository2-1.xml ];\n    images = [\n      ./xml/android-sys-img2-1.xml\n      ./xml/android-tv-sys-img2-1.xml\n      ./xml/android-wear-sys-img2-1.xml\n      ./xml/android-wear-cn-sys-img2-1.xml\n      ./xml/google_apis-sys-img2-1.xml\n      ./xml/google_apis_playstore-sys-img2-1.xml\n    ];\n    addons = [ ./xml/addon2-1.xml ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding BLAS/LAPACK with Reference Implementations\nDESCRIPTION: This overlay configures Nixpkgs to use the reference implementations for BLAS and LAPACK, which can be useful for development purposes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nself: super:\n\n{\n  blas = super.blas.override {\n    blasProvider = self.lapack-reference;\n  };\n\n  lapack = super.lapack.override {\n    lapackProvider = self.lapack-reference;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Upload Filters for Metadata Removal and Deduplication - Nix\nDESCRIPTION: This configuration enables a sequence of upload filters in Akkoma to strip GPS/location metadata, deduplicate uploads, and anonymize file names upon user file upload. The implementation expects pkgs.formats.elixirConf and mkRaw utilities, with input as a list of filter module names. Output is privacy-enhanced, deduplicated uploads.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.config.\":pleroma\".\"Pleroma.Upload\".filters =\n    map (pkgs.formats.elixirConf { }).lib.mkRaw [\n      \"Pleroma.Upload.Filter.Exiftool\"\n      \"Pleroma.Upload.Filter.Dedupe\"\n      \"Pleroma.Upload.Filter.AnonymizeFilename\"\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding WeeChat Plugins List with selected plugins - Nix\nDESCRIPTION: This Nix snippet demonstrates how to override the default plugins loaded by WeeChat, reducing the closure size by specifying a subset through the 'plugins' attribute. Requires an available WeeChat attrset with plugins such as python or perl. Input parameters include 'availablePlugins', from which desired plugins are selected. Returns an attrset with the 'plugins' attribute set to only those explicitly listed. Outputs a tailored build of WeeChat including only specified plugins.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nweechat.override {\n  configure = (\n    { availablePlugins, ... }:\n    {\n      plugins = with availablePlugins; [\n        python\n        perl\n      ];\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Hy Shell with Python Packages using Nix Shell - ShellSession\nDESCRIPTION: This snippet shows how to launch an interactive shell where Hy is available with numpy and matplotlib installed, using the Nix package manager. The command uses hy.withPackages to specify additional Python packages required in the shell session. It requires nix to be installed and relies on the presence of Hy and the specified Python packages in the Nix packages collection.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/hy.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p \"hy.withPackages (ps: with ps; [ numpy matplotlib ])\"\n```\n\n----------------------------------------\n\nTITLE: Switching to Previous Configuration via boot (NixOS - Shell)\nDESCRIPTION: Runs the switch-to-configuration script with the 'boot' argument to activate a previous system configuration on the next boot. Requires root privileges and access to a valid configuration profile under /run/current-system/bin. No parameters are needed other than 'boot', and the command must be executed in a root shell. This enables the system to boot into the selected configuration; use with caution on multi-user systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rollback.section.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# /run/current-system/bin/switch-to-configuration boot\n```\n\n----------------------------------------\n\nTITLE: Entering Kernel Config Environment and Running make nconfig - ShellSession\nDESCRIPTION: This set of Shell session commands shows how to enter a Nix shell for kernel configuration, unpack the kernel sources, navigate to their directory, and invoke make nconfig for interactive configuration. It presumes nixpkgs are properly referenced and present, and the user has access to the kernel source and build tools within the shell. Inputs are shell targets and make is run interactively; outputs are updated configuration files for the kernel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/linux.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell '<nixpkgs>' -A linuxKernel.kernels.linux_X_Y.configEnv\n$ unpackPhase\n$ cd linux-*\n$ make nconfig\n```\n\n----------------------------------------\n\nTITLE: Enabling User Service\nDESCRIPTION: Commands for enabling a user-level systemd service with proper symlinks to survive garbage collection.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ mkdir -p ~/.config/systemd/user/default.target.wants\n$ ln -s /run/current-system/sw/lib/systemd/user/syncthing.service ~/.config/systemd/user/default.target.wants/\n$ systemctl --user daemon-reload\n$ systemctl --user enable syncthing.service\n```\n\n----------------------------------------\n\nTITLE: Enabling Unfree Packages - Nix - nix\nDESCRIPTION: Configures the Nixpkgs user environment to permanently allow installation of all unfree packages. Requires a valid `~/.config/nixpkgs/config.nix` file. When `allowUnfree` is set to `true`, Nixpkgs will not block unfree software, allowing related expressions to evaluate and build successfully. No additional input parameters are required; output effect is system-wide user configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowUnfree = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Nim Lockfiles with nim_lk - Shell Command - sh\nDESCRIPTION: This shell snippet demonstrates generating a Nim package lockfile with the 'nim_lk' utility for use with Nix. The process consists of fetching the package source and running 'nim_lk' with the result directory, piping its output through 'jq' and saving to a specific JSON file. Dependencies: Nim toolchain, nim_lk utility, jq. Inputs: checked out Nim package directory. Output: A JSON lockfile capturing dependency metadata. Limitation: Assumes correct setup and presence of nim_lk, jq utilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ cd nixpkgs\n$ nix build -f . ttop.src\n$ nix run -f . nim_lk ./result | jq --sort-keys > pkgs/by-name/tt/ttop/lock.json\n```\n\n----------------------------------------\n\nTITLE: Package Override Example with Version Update\nDESCRIPTION: Example showing how to override a package's version and update its vendorHash using overrideAttrs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pet_0_4_0 = pet.overrideAttrs (\n    finalAttrs: previousAttrs: {\n      version = \"0.4.0\";\n      src = fetchFromGitHub {\n        inherit (previousAttrs.src) owner repo;\n        rev = \"v${finalAttrs.version}\";\n        hash = \"sha256-gVTpzmXekQxGMucDKskGi+e+34nJwwsXwvQTjRO6Gdg=\";\n      };\n      vendorHash = \"sha256-dUvp7FEW09V0xMuhewPGw3TuAic/sD7xyXEYviZ2Ivs=\";\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling nginx Media Proxy and Persistent Caching for Akkoma - Nix\nDESCRIPTION: This configuration snippet sets up persistent media caching for Akkoma using the nginx slice module and configures Akkoma's media proxy settings. It adjusts the nginx package to Tengine for slice support, defines cache path and memory sizing, and customizes the /proxy location for advanced caching. Required dependencies include pkgs.tengine for nginx, correctly set cache directories, and integration with Akkoma's config. Inputs are service options; output is optimized proxying and caching of remote media for instances.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Enable nginx slice module distributed with Tengine\n  services.nginx.package = pkgs.tengine;\n\n  # Enable media proxy\n  services.akkoma.config.\":pleroma\".\":media_proxy\" = {\n    enabled = true;\n    proxy_opts.redirect_on_failure = true;\n  };\n\n  # Adjust the persistent cache size as needed:\n  #  Assuming an average object size of 128 KiB, around 1 MiB\n  #  of memory is required for the key zone per GiB of cache.\n  # Ensure that the cache directory exists and is writable by nginx.\n  services.nginx.commonHttpConfig = ''\n    proxy_cache_path /var/cache/nginx/cache/akkoma-media-cache\n      levels= keys_zone=akkoma_media_cache:16m max_size=16g\n      inactive=1y use_temp_path=off;\n  '';\n\n  services.akkoma.nginx = {\n    locations.\"/proxy\" = {\n      proxyPass = \"http://unix:/run/akkoma/socket\";\n\n      extraConfig = ''\n        proxy_cache akkoma_media_cache;\n\n        # Cache objects in slices of 1 MiB\n        slice 1m;\n        proxy_cache_key $host$uri$is_args$args$slice_range;\n        proxy_set_header Range $slice_range;\n\n        # Decouple proxy and upstream responses\n        proxy_buffering on;\n        proxy_cache_lock on;\n        proxy_ignore_client_abort on;\n\n        # Default cache times for various responses\n        proxy_cache_valid 200 1y;\n        proxy_cache_valid 206 301 304 1h;\n\n        # Allow serving of stale items\n        proxy_cache_use_stale error timeout invalid_header updating;\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing pkg-config modules with default values in Nix\nDESCRIPTION: Demonstrates how to check that a package exposes its pkg-config modules using the testers.hasPkgConfigModules function with default values. The test will use meta.pkgConfigModules as the list of modules to check.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  passthru.tests.pkg-config = testers.hasPkgConfigModules {\n    package = finalAttrs.finalPackage;\n  };\n\n  meta.pkgConfigModules = [ \"libfoo\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Gitea Module Options to Freeform Attribute Set - NixOS Service Option - Markdown\nDESCRIPTION: This snippet documents the migration of individual Gitea module options under the umbrella of services.gitea.settings, organizing configuration as a freeform attribute set. This increases structural flexibility and future compatibility. It requires careful conversion of older configuration formats.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_26\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`gitea\\` module options have been moved into a freeform attribute set below \\`services.gitea.settings\\`.\n```\n\n----------------------------------------\n\nTITLE: Verifying Rust Nightly Shell Setup via rustc - ShellSession\nDESCRIPTION: This snippet verifies the Rust nightly environment by running `rustc --version` in the configured shell. It confirms that `rustc` is properly installed from the nightly channel (here, version 1.69.0-nightly). This ensures a valid toolchain setup for development. Requires the shell to be set up as described in the corresponding Nix file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_34\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ rustc --version\nrustc 1.69.0-nightly (13471d3b2 2023-03-02)\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Perlless Profile in NixOS System Configuration - Nix - nix\nDESCRIPTION: This declarative Nix snippet demonstrates how to configure a NixOS system to use the perlless profile for eliminating Perl dependencies. The 'imports' list includes the perlless profile path using the '${modulesPath}' variable, which must be available in the environment. The dependency is on the location of 'profiles/perlless.nix' within the NixOS modules tree. This code expects to be run in a NixOS flake or configuration.nix context, and its output is a system that no longer requires Perl for activation scripts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2405.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ modulesPath, ... }: {\n  imports = [ \"${modulesPath}/profiles/perlless.nix\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Caddy with Plugins in NixOS\nDESCRIPTION: Example of how to build Caddy with custom plugins using the caddy.withPlugins function in NixOS. This configuration enables Caddy and specifies plugins to be included, along with their versions and a hash for vendored dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nservices.caddy = {\n  enable = true;\n  package = pkgs.caddy.withPlugins {\n    plugins = [\n      # tagged upstream\n      \"github.com/caddy-dns/powerdns@v1.0.1\"\n      # pseudo-version number generated by Go\n      \"github.com/caddy-dns/cloudflare@v0.0.0-20240703190432-89f16b99c18e\"\n      \"github.com/mholt/caddy-webdav@v0.0.0-20241008162340-42168ba04c9d\"\n    ];\n    hash = \"sha256-wqXSd1Ep9TVpQi570TTb96LwzNYvWL5EBJXMJfYWCAk=\";\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Media Preview Proxy for Akkoma - Nix\nDESCRIPTION: This configuration enables Akkoma's media_preview_proxy feature, specifying maximum thumbnail width and height for previews. It adjusts the relevant configuration subtree under Akkoma, requires no direct dependencies beyond functional Akkoma deployment, and expects integer inputs for preview sizing. Output is the activation of media preview thumbnails, up to the specified dimensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.config.\":pleroma\".\":media_preview_proxy\" = {\n    enabled = true;\n    thumbnail_max_width = 1920;\n    thumbnail_max_height = 1080;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Long Perl Shebang Lines on Darwin - Nix\nDESCRIPTION: This Nix derivation demonstrates handling platforms (Darwin) where long shebang lines cause failure by using the shortenPerlShebang function in postInstall. Dependencies are shortenPerlShebang, buildPerlPackage, fetchurl, and platform detection via stdenv. Key parameters include package metadata and conditional build hooks. Input is the ExifTool source and platform context; output is a working Perl binary for Darwin. This avoids system limits on interpreter line lengths.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  buildPerlPackage,\n  fetchurl,\n  shortenPerlShebang,\n}:\n\n{\n  ImageExifTool = buildPerlPackage {\n    pname = \"Image-ExifTool\";\n    version = \"12.50\";\n\n    src = fetchurl {\n      url = \"https://exiftool.org/Image-ExifTool-${version}.tar.gz\";\n      hash = \"sha256-vOhB/FwQMC8PPvdnjDvxRpU6jAZcC6GMQfc0AH4uwKg=\";\n    };\n\n    nativeBuildInputs = lib.optional stdenv.hostPlatform.isDarwin shortenPerlShebang;\n    postInstall = lib.optionalString stdenv.hostPlatform.isDarwin ''\n      shortenPerlShebang $out/bin/exiftool\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Launching Julia with Additional Packages via nix-shell (Shell)\nDESCRIPTION: This snippet demonstrates running an ephemeral Julia environment in the shell using Nix. It utilizes `nix-shell` to create an environment where Julia is preconfigured with the listed packages ([\"Plots\"]). The command passes the arguments to the shell, sets up the dependencies, and executes `julia`. The only requirements are that Nix and Nixpkgs are installed. Inputs are the list of requested Julia packages and the command to run. Outputs are a Julia REPL launched with all specified packages accessible.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/julia.section.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnix-shell -p 'julia.withPackages [\"Plots\"]' --run julia\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL ProtectHome for File Import Operations in NixOS\nDESCRIPTION: Configuration to modify MySQL's systemd service to allow reading from /home and /tmp directories when using LOAD DATA INFILE operations. This overrides the default sandboxing restrictions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.mysql.serviceConfig.ProtectHome = lib.mkForce \"read-only\";\n}\n```\n\n----------------------------------------\n\nTITLE: Locating Predefined XKB Files with nix-build (ShellSession)\nDESCRIPTION: Shows a command to echo the path where predefined XKB files are located in the system, useful for reference or template purposes. Dependency: nix-build with access to the nixpkgs channel and xorg.xkeyboardconfig attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_24\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ echo \"$(nix-build --no-out-link '<nixpkgs>' -A xorg.xkeyboardconfig)/etc/X11/xkb/\"\n```\n\n----------------------------------------\n\nTITLE: Integrating Memcached Test Hook - Nix\nDESCRIPTION: This snippet demonstrates how to include the memcachedTestHook in the nativeCheckInputs attribute of a Nix derivation to automatically start a Memcached server during checkPhase. Dependencies include stdenv and memcachedTestHook. There are no required parameters, but this setup provides a template for packages needing Memcached for their tests; no custom inputs or outputs are shown in the minimal example. Limitations: Requires the memcachedTestHook to be available in the environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/memcached-test-hook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  memcachedTestHook,\n}:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeCheckInputs = [\n    memcachedTestHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ACME Defaults for Nginx Web Server - Nix - Nix\nDESCRIPTION: Illustrates the use of the new 'security.acme.defaults' option to simplify mass-configuration of certificate settings in NixOS. Allows configuration of DNS-01 validation for ACME certificates in web server virtual hosts, intended for use with 'enableACME' on Nginx service definitions. Key parameters include 'services.nginx.virtualHosts.*.enableACME', which must be set per virtual host, and configuring 'security.acme.defaults' for shared defaults.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nsecurity.acme.defaults\nservices.nginx.virtualHosts.*.enableACME\n```\n\n----------------------------------------\n\nTITLE: Sample JSON for Cue Validation\nDESCRIPTION: This snippet provides a simple JSON example that can be used to test the Cue validators created in the previous snippets. It defines a single field 'field1' with a string value.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuelang.section.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{ \"field1\": \"abc\" }\n```\n\n----------------------------------------\n\nTITLE: Escaping Arguments in systemd Exec Directives – Nix\nDESCRIPTION: Shows robust handling of shell arguments and substitution dangers when generating Exec* fields for systemd service units in NixOS. Demonstrates use of utility functions (utils.escapeSystemdExecArgs) to prevent unwanted interpretation of variables, percent-escapes, and shell metacharacters in command arguments. Inputs include an argument list potentially containing sensitive characters; output is a systemd service definition that will execute a safe, properly-escaped script. Dependencies: pkgs, utils, a shell-invoking environment, and the written script being available in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-modules.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, utils, ... }:\n\nlet\n  cfg = config.services.echo;\n  echoAll = pkgs.writeScript \"echo-all\" ''\n    #! ${pkgs.runtimeShell}\n    for s in \"$@\"; do\n      printf '%s\\n' \"$s\"\n    done\n  '';\n  args = [ \"a%Nything\" \"lang=\\${LANG}\" \";\" \"/bin/sh -c date\" ];\nin {\n  systemd.services.echo =\n    { description = \"Echo to the journal\";\n      wantedBy = [ \"multi-user.target\" ];\n      serviceConfig.Type = \"oneshot\";\n      serviceConfig.ExecStart = ''\n        ${echoAll} ${utils.escapeSystemdExecArgs args}\n      '';\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Source Root in Nix Derivation\nDESCRIPTION: Examples of how to set the sourceRoot variable in a Nix derivation to control the directory where the build starts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\nsourceRoot = \"${src.name}/my-sub-directory\";\n```\n\nLANGUAGE: nix\nCODE:\n```\nsetSourceRoot = \"sourceRoot=$(echo */my-sub-directory)\";\n```\n\nLANGUAGE: nix\nCODE:\n```\nsetSourceRoot = \"sourceRoot=$(echo ${pname}-*/my-sub-directory)\";\n```\n\n----------------------------------------\n\nTITLE: Writing Nix Expression for Perl Package Assignment in Bash\nDESCRIPTION: This Bash script takes a Perl module name in the 'Group::Module::Submodule' format as input and outputs a corresponding Nix assignment, suitable for inclusion in all-packages.nix among Perl packages. It queries search.cpan.org for source metadata, attempts to resolve dependencies, and emits an initial Nix expression. Dependencies with incomplete CPAN metadata or unconventional naming may require manual post-processing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/perl-modules/expression-generator/usage.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# /path/to/write-nix-expression.sh Group::Module::Submodule\n\n# It will output Nix assignment formatted for placing into \n# all-packages.nix amongst all the perl packages, like perlAlgorithmDiff.\n# Actually it will grab distribution unit Group-Module-Submodule via\n# search.cpan.org, and make some effort to write correct dependencies.\n# If among requirements there are some that have empty META.yml, or if \n# any of requirements acannot be installed by just getting distribution\n# unit whose name can be guessed by replacing :: with -, manual editing\n# will be needed. \n```\n\n----------------------------------------\n\nTITLE: Creating Nix Derivation for Runnable JAR\nDESCRIPTION: Nix derivation that builds a Maven project and creates a wrapper script for running the JAR with proper classpath configuration. Includes repository symlink setup and JRE dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  maven,\n  callPackage,\n  makeWrapper,\n  jre,\n}:\nlet\n  # pick a repository derivation, here we will use buildMaven\n  repository = callPackage ./build-maven-repository.nix { };\nin\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"maven-demo\";\n  version = \"1.0\";\n\n  src = builtins.fetchTarball \"https://github.com/fzakaria/nixos-maven-example/archive/main.tar.gz\";\n  nativeBuildInputs = [ makeWrapper ];\n  buildInputs = [ maven ];\n\n  buildPhase = ''\n    runHook preBuild\n\n    echo \"Using repository ${repository}\"\n    mvn --offline -Dmaven.repo.local=${repository} package;\n\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/bin\n\n    # create a symbolic link for the repository directory\n    ln -s ${repository} $out/repository\n\n    install -Dm644 target/maven-demo-${finalAttrs.version}.jar $out/share/java\n    # create a wrapper that will automatically set the classpath\n    # this should be the paths from the dependency derivation\n    makeWrapper ${jre}/bin/java $out/bin/maven-demo \\\n          --add-flags \"-jar $out/share/java/maven-demo-${finalAttrs.version}.jar\"\n\n    runHook postInstall\n  '';\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Apache HTTPD with Required Ports - NixOS Configuration (Nix)\nDESCRIPTION: This Nix language snippet enables the Apache HTTP server and opens necessary firewall ports (80 for HTTP, 443 for HTTPS) via the NixOS configuration.nix structure. The admin email address must be set for proper server operation. Prerequisites: NixOS with nixpkgs configured, and elevated permissions to write to configuration.nix. This snippet is a foundational step for hosting web services on the system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.enable = true;\n  services.httpd.adminAddr = \"...\";\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sysinit Reactivation Using systemd Module - Nix\nDESCRIPTION: This Nix snippet demonstrates how to configure a systemd service to participate in the artificial sysinit-reactivation.target for proper restarting order of early boot 'sysinit' units. It sets the 'requiredBy' and 'before' attributes for the service to depend on 'sysinit-reactivation.target', and assigns 'restartTriggers' based on changes in a configuration location. Dependencies include NixOS, systemd, and the proper context of 'config.environment.etc'. The input is an attribute set for systemd.services, while the output is the adjusted activation order and restart triggers for the target service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/unit-handling.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.my-sysinit = {\n    requiredBy = [ \"sysinit-reactivation.target\" ];\n    before = [ \"sysinit-reactivation.target\" ];\n    restartTriggers = [ config.environment.etc.\"my-sysinit.d\".source ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging Perl Module with Runtime Dependencies - Nix\nDESCRIPTION: This Nix snippet defines a Perl module ('Class-C3-Componentised') with explicit runtime dependencies using propagatedBuildInputs. Requires buildPerlPackage, fetchurl, and dependent Perl packages (ClassC3, ClassInspector, TestException, MROCompat). The key parameters are the dependency modules and metadata. Inputs are the CPAN tarball and dependency derivations; output is a self-contained Perl package. Suitable for complex modules needing multiple runtime libraries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  ClassC3Componentised = buildPerlPackage rec {\n    pname = \"Class-C3-Componentised\";\n    version = \"1.0004\";\n    src = fetchurl {\n      url = \"mirror://cpan/authors/id/A/AS/ASH/Class-C3-Componentised-${version}.tar.gz\";\n      hash = \"sha256-ASO9rV/FzJYZ0BH572Fxm2ZrFLMZLFATJng1NuU4FHc=\";\n    };\n    propagatedBuildInputs = [\n      ClassC3\n      ClassInspector\n      TestException\n      MROCompat\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Anki Sync Server in NixOS Configuration\nDESCRIPTION: This snippet shows how to enable the Anki Sync Server service in a NixOS configuration file. It sets the 'enable' option to true.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/anki-sync-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.anki-sync-server.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Message of the Day - NixOS Option - Markdown\nDESCRIPTION: This snippet introduces the users.motdFile option in NixOS, allowing system administrators to set or update the Message Of The Day (MOTD) file dynamically. The option's main dependency is the NixOS users module and systemd or init handling of MOTD. Inputs include the path to the MOTD file; the output is the dynamically updated file displayed at login. For full functionality, the MOTD file must be maintained or updated by scripts or automation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n- The new option \\`users.motdFile\\` allows configuring a Message Of The Day that can be updated dynamically.\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling Rust Projects with Custom Target - Nix Shell & Nix Expressions\nDESCRIPTION: This block describes importing nixpkgs with a modified cross-compilation target for Rust by altering the host platform configuration. The `crossSystem` attribute sets the cross target and optionally sets a custom target name, using Nix \"import\" syntax. Required: Nix, nixpkgs, and a valid cross platform definition. Output is a Nixpkgs package set configured for the specified target; may be limited by support for experimental or uncommon Rust targets.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nimport <nixpkgs> {\n  crossSystem = (import <nixpkgs/lib>).systems.examples.armhf-embedded // {\n    rust.rustcTarget = \"thumbv7em-none-eabi\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing RIME Data Packages in Fcitx5-Rime - Nix\nDESCRIPTION: This Nix code snippet illustrates how to customize RIME data used in Fcitx5 via the fcitx5-rime.override pattern. It sets the rimeDataPkgs attribute to specify custom or additional RIME data packages as a Nix list, relying on pkgs.rime-data and potentially other Nix store sources. Inputs are Nix packages, and the modification affects the input method subsystem's dictionary and behavior.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nfcitx5-rime.override {\n  rimeDataPkgs = [\n    pkgs.rime-data\n    # ...\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Secrets to K3s via EnvironmentFile - NixOS Systemd Configuration - Markdown\nDESCRIPTION: This item describes how the k3s service can now make use of an EnvironmentFile for its systemd service, which facilitates passing secrets without storing them in the immutable Nix Store. The feature depends on properly configuring the EnvironmentFile path and the k3s systemd unit.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_25\n\nLANGUAGE: markdown\nCODE:\n```\n- \\`k3s\\` can now be configured with an \\`EnvironmentFile\\` for its systemd service, allowing secrets to be provided without ending up in the Nix Store.\n```\n\n----------------------------------------\n\nTITLE: Configuring pkg-config Modules in NixOS Package\nDESCRIPTION: Example showing how to properly configure a package with pkg-config modules in Nixpkgs. Demonstrates setting up meta.pkgConfigModules, using validation hooks, and implementing package tests.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/pkg-config.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkg-config, testers, ... }:\n\nstdenv.mkDerivation (finalAttrs: {\n  # ...\n\n  nativeBuildInputs = [\n    pkg-config\n    validatePkgConfig\n  ];\n\n  passthru.tests.pkg-config = testers.hasPkgConfigModules {\n    package = finalAttrs.finalPackage;\n    versionCheck = true;\n  };\n\n  meta = {\n    # ...\n    pkgConfigModules = [ \"miniz\" ];\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Binary Caches via nixos-rebuild Command - ShellSession\nDESCRIPTION: This shell snippet shows how to run the nixos-rebuild command with the binary caches disabled by adding the --option use-binary-caches false flag. It is intended for situations where the default binary cache is unreachable or network issues are causing excessive timeouts. The command expects no arguments beyond standard nixos-rebuild input, and disables all binary cache downloads, forcing local source builds. There are no specific dependencies beyond having nixos-rebuild available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/network-problems.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch --option use-binary-caches false\n```\n\n----------------------------------------\n\nTITLE: Extending startx xinitrc Script with Custom Commands - Nix\nDESCRIPTION: Illustrates setting services.xserver.displayManager.startx.generateScript to true and providing extraCommands using inline shell syntax. Adds custom X initialization commands like loading .Xresources and setting up cursor/root color. Extendable for further personal preferences. Shell commands are evaluated as part of xinitrc script.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.startx = {\n    generateScript = true;\n    extraCommands = ''\n      xrdb -load .Xresources\n      xsetroot -solid '#666661'\n      xsetroot -cursor_name left_ptr\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Shutting Down the System with ShellSession and systemctl - ShellSession\nDESCRIPTION: This snippet demonstrates shutting down (powering off) a NixOS system using the 'shutdown' command in a shell session. It is functionally equivalent to executing 'systemctl poweroff'. To run this command, user must have appropriate privileges (e.g., be logged in locally or provide authentication if required). Inputs: no additional parameters beyond executing the command. Output: system will begin shutdown and power-off sequence.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rebooting.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# shutdown\n```\n\n----------------------------------------\n\nTITLE: Configuring PHP-FPM Pool with Custom PHP and Extra Settings in NixOS\nDESCRIPTION: Shows how to set up a PHP-FPM pool named 'foo' using a custom PHP configuration with specific extensions and additional php.ini settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  myPhp = php.buildEnv {\n    extensions =\n      { all, ... }:\n      with all;\n      [\n        imagick\n        opcache\n      ];\n    extraConfig = \"memory_limit=256M\";\n  };\nin\n{\n  services.phpfpm.pools.\"foo\".phpPackage = myPhp;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Nim Package from SBOM with buildNimSbom - Nix Expression - Nix\nDESCRIPTION: This Nix expression demonstrates building a Nim package using 'buildNimSbom' with package metadata and dependencies provided via a CycloneDX SBOM file. It fetches sources from SourceHut and specifies 'openssl' as a build input. Dependencies: Nixpkgs, 'buildNimSbom', SBOM JSON file, and required build inputs. Inputs: src derivation, buildInputs, path to SBOM JSON. Output: A Nix derivation for the Nim package built using the SBOM. Limitation: Metadata such as pname and version must be provided by the SBOM.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n# pkgs/by-name/ni/nim_lk/package.nix\n{\n  lib,\n  buildNimSbom,\n  fetchFromSourcehut,\n  openssl,\n}:\n\nbuildNimSbom (finalAttrs: {\n  src = fetchFromSourcehut {\n    owner = \"~ehmry\";\n    repo = \"nim_lk\";\n    rev = finalAttrs.version;\n    hash = lib.fakeHash;\n  };\n  buildInputs = [ openssl ];\n}) ./sbom.json\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enable Tests with stdenv.buildPlatform.canExecute - Nix\nDESCRIPTION: This configuration demonstrates how to determine if build-time tests can be run by checking if code built for the host can be executed on the build platform. It sets 'doCheck' based on 'canExecute', helping avoid test execution errors in cross builds. Suitable for scenarios where the host and build platforms differ.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  doCheck = stdenv.buildPlatform.canExecute stdenv.hostPlatform;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Digital Bitbox udev Rules - Customization in NixOS - Nix\nDESCRIPTION: This snippet demonstrates how to override udev rule attributes for Digital Bitbox devices by customizing the package via the \"override\" function. By providing values such as \"udevRule51\", users can fine-tune device access rules. The \"package\" attribute must reference a valid pkgs.digitalbitbox derivation that supports attribute overrides. Parameters include enablement and package overrides; outputs are the customized package in the NixOS system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/digitalbitbox/default.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.digitalbitbox = {\n    enable = true;\n    package = pkgs.digitalbitbox.override {\n      udevRule51 = \"something else\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building LuaLaTeX Document Using Temporary Writable HOME - Nix - nix\nDESCRIPTION: Provides a Nix expression for running LuaLaTeX in a derivation where HOME is set to a temporary (writable) directory, necessary for correct font cache handling. Writes a minimal TeX document and builds it into a PDF in a sandboxed build environment. Ensures reproducibility by isolating user-specific caches. Prerequisites: texliveFull, basic knowledge of Nix build sandboxing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nrunCommandNoCC \"lualatex-hello-world\"\n  {\n    buildInputs = [ texliveFull ];\n  }\n  ''\n    mkdir $out\n    echo '\\\\documentclass{article} \\\\begin{document} Hello world \\\\end{document}' > main.tex\n    env HOME=$(mktemp -d) lualatex  -interaction=nonstopmode -output-format=pdf -output-directory=$out ./main.tex\n  ''\n```\n\n----------------------------------------\n\nTITLE: Building a Dart Application with Nix - Nix\nDESCRIPTION: Demonstrates how to package a Dart application (dart-sass) using the buildDartApplication function in Nix. This snippet shows specifying Dart app metadata, fetching sources from GitHub, and importing the pubspec.lock file as JSON for dependency management. Requires buildDartApplication, lib, and fetchFromGitHub in scope; expects a pre-generated pubspec.lock.json file next to the Nix file. Outputs a Nix derivation for the Dart app.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dart.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildDartApplication,\n  fetchFromGitHub,\n}:\n\nbuildDartApplication rec {\n  pname = \"dart-sass\";\n  version = \"1.62.1\";\n\n  src = fetchFromGitHub {\n    owner = \"sass\";\n    repo = \"dart-sass\";\n    tag = version;\n    hash = \"sha256-U6enz8yJcc4Wf8m54eYIAnVg/jsGi247Wy8lp1r1wg4=\";\n  };\n\n  pubspecLock = lib.importJSON ./pubspec.lock.json;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image with Custom Creation Date using Nix dockerTools (nix)\nDESCRIPTION: This Nix snippet builds a Docker image with the 'created' attribute set to 'now', causing the image to be marked with the current time rather than a reproducible timestamp. The image runs /bin/hello at startup. This breaks reproducibility – repeated builds yield different digests. Requires dockerTools, buildEnv, hello, and produces a Docker-loadable .tar.gz.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  buildEnv,\n  hello,\n}:\ndockerTools.buildImage {\n  name = \"hello\";\n  tag = \"latest\";\n\n  created = \"now\";\n\n  copyToRoot = buildEnv {\n    name = \"image-root\";\n    paths = [ hello ];\n    pathsToLink = [ \"/bin\" ];\n  };\n\n  config.Cmd = [ \"/bin/hello\" ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Suwayomi-Server Configuration with System Tray in NixOS\nDESCRIPTION: Demonstrates how to enable the system tray option for Suwayomi-Server, which creates a desktop icon.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/suwayomi-server.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.suwayomi-server = {\n    enable = true;\n\n    dataDir = \"/var/lib/suwayomi\"; # Default is \"/var/lib/suwayomi-server\"\n    openFirewall = true;\n\n    settings = {\n      server.port = 4567;\n      server.enableSystemTray = true;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Tcl Package Derivation in NixOS\nDESCRIPTION: Example of a Tcl package definition using mkTclDerivation. This example demonstrates how to package tcltls, a Tcl extension for OpenSSL, with proper dependencies, configuration flags for enabling stubs, and metadata for the Nix ecosystem.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/tcl.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ lib, fetchzip, mkTclDerivation, openssl }:\n\nmkTclDerivation rec {\n  pname = \"tcltls\";\n  version = \"1.7.22\";\n\n  src = fetchzip {\n    url = \"https://core.tcl-lang.org/tcltls/uv/tcltls-${version}.tar.gz\";\n    hash = \"sha256-TOouWcQc3MNyJtaAGUGbaQoaCWVe6g3BPERct/V65vk=\";\n  };\n\n  buildInputs = [ openssl ];\n\n  configureFlags = [\n    \"--with-ssl-dir=${openssl.dev}\"\n    \"--enable-stubs\"\n  ];\n\n  meta = {\n    homepage = \"https://core.tcl-lang.org/tcltls/index\";\n    description = \"OpenSSL / RSA-bsafe Tcl extension\";\n    maintainers = [ lib.maintainers.agbrooks ];\n    license = lib.licenses.tcltk;\n    platforms = lib.platforms.unix;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Platform Attributes in Nixpkgs Derivation - Nix\nDESCRIPTION: This snippet demonstrates how to access standard platform parameters (such as buildPlatform) within a Nix derivation. It assumes a function argument list including build dependencies like stdenv, and shows that one can reference the platform attribute as stdenv.buildPlatform (or similar). The snippet highlights the idiomatic way to pass and reference attribute sets in Nix expressions for effective cross-platform package management. The code expects stdenv and possibly other dependencies (fooDep, barDep), and typically yields a derivation attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  fooDep,\n  barDep,\n  ...\n}:\n{\n  # ...stdenv.buildPlatform...\n}\n```\n\n----------------------------------------\n\nTITLE: Using lib.forEach for List Mapping in Nix\nDESCRIPTION: This example demonstrates the usage of lib.forEach, which is a preferred alternative to lib.flip map for improved readability when mapping over lists in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nlib.forEach\n```\n\n----------------------------------------\n\nTITLE: Overriding Packages using packageOverrides - Nix - nix\nDESCRIPTION: Demonstrates extending or modifying existing packages using the `packageOverrides` function in `~/.config/nixpkgs/config.nix`. Overrides the `foo` package with custom arguments, which may be supplied in the commented section. Input is a function of `pkgs`; output is a new or altered package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: rec {\n    foo = pkgs.foo.override {\n      # ...\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Session Status - loginctl session-status - ShellSession\nDESCRIPTION: This snippet shows how to query detailed information about a specified user session using loginctl session-status <session_id>. It outputs details such as session start time, TTY, service, state, related processes, and control groups. Input: the session ID to check (here 'c3'). Output: Multi-line status report of the session and its processes. No system changes occur.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/user-sessions.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ loginctl session-status c3\nc3 - root (0)\n           Since: Tue, 2013-01-08 01:17:56 CET; 4min 42s ago\n          Leader: 2536 (login)\n            Seat: seat0; vc3\n             TTY: /dev/tty3\n         Service: login; type tty; class user\n           State: online\n          CGroup: name=systemd:/user/root/c3\n                  ├─ 2536 /nix/store/10mn4xip9n7y9bxqwnsx7xwx2v2g34xn-shadow-4.1.5.1/bin/login --\n                  ├─10339 -bash\n                  └─10355 w3m nixos.org\n```\n\n----------------------------------------\n\nTITLE: Configuring Blackfire Agent and Probe for PHP-FPM with NixOS (Nix)\nDESCRIPTION: This snippet provides a sample NixOS configuration that enables and sets up the Blackfire agent and probe for PHP-FPM. It demonstrates how to configure the PHP package to include the Blackfire extension, how to enable and set credential parameters for the agent, and how to ensure the agent is started alongside your PHP-FPM unit. Required dependencies include the Nixpkgs package set with PHP and Blackfire extensions and valid credentials obtainable from the Blackfire account portal. Inputs include a PHP-FPM server that needs profiling and valid Blackfire credentials; outputs are a NixOS configuration fragment for profiling PHP applications. Ensure you have proper access to the referenced packages and that the server and agent credentials are correct.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/blackfire.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  php = pkgs.php.withExtensions ({ enabled, all }: enabled ++ (with all; [\n    blackfire\n  ]));\nin {\n  # Enable the probe extension for PHP-FPM.\n  services.phpfpm = {\n    phpPackage = php;\n  };\n\n  # Enable and configure the agent.\n  services.blackfire-agent = {\n    enable = true;\n    settings = {\n      # You will need to get credentials at https://blackfire.io/my/settings/credentials\n      # You can also use other options described in https://blackfire.io/docs/up-and-running/configuration/agent\n      server-id = \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\";\n      server-token = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n    };\n  };\n\n  # Make the agent run on start-up.\n  # (WantedBy= from the upstream unit not respected: https://github.com/NixOS/nixpkgs/issues/81138)\n  # Alternately, you can start it manually with `systemctl start blackfire-agent`.\n  systemd.services.blackfire-agent.wantedBy = [ \"phpfpm-foo.service\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Platform Triple Progression in Nixpkgs Bootstrapping\nDESCRIPTION: This code snippet illustrates the conceptual progression of platform triples in the Nixpkgs bootstrapping process. It shows how the native and foreign platforms are arranged in a sequence, demonstrating the 'sliding window' concept for determining bootstrap stages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n(native, native, native, foreign, foreign)\n```\n\n----------------------------------------\n\nTITLE: Setting Empty Root Password in NixOS Configuration (Nix)\nDESCRIPTION: A snippet in configuration.nix that sets the initialHashedPassword for the root user to an empty string, allowing passwordless login for first boot. Intended to be updated immediately after initial login for security reasons. Dependency: NixOS configuration closure. Input: None. Output: Root user initialized with no password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  users.users.root.initialHashedPassword = \\\"\\\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Including Multiple Hook Documentation Sections - Markdown\nDESCRIPTION: This Markdown code snippet demonstrates how to aggregate content from multiple documentation files using a custom include directive. It lists a sequence of section markdown files—each documenting a specific hook or build system used in Nixpkgs—and incorporates their contents when the documentation is built. This method requires a documentation tool or renderer capable of processing the {=include=} directive. Inputs are section filenames, and the output injects the corresponding file contents into the final document at the snippet's position. Limitations include dependency on correct toolchain support for this include syntax.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/index.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\\nautoconf.section.md\\nautomake.section.md\\nautopatchcil.section.md\\nautopatchelf.section.md\\naws-c-common.section.md\\nbmake.section.md\\nbreakpoint.section.md\\ncernlib.section.md\\ncmake.section.md\\ndesktop-file-utils.section.md\\ngdk-pixbuf.section.md\\nghc.section.md\\ngnome.section.md\\nharedo.section.md\\ninstallShellFiles.section.md\\njust.section.md\\nlibiconv.section.md\\nlibxml2.section.md\\nmeson.section.md\\nmpi-check-hook.section.md\\nninja.section.md\\npatch-rc-path-hooks.section.md\\nperl.section.md\\npkg-config.section.md\\npostgresql-test-hook.section.md\\npremake.section.md\\npython.section.md\\nscons.section.md\\ntauri.section.md\\ntetex-tex-live.section.md\\nunzip.section.md\\nvalidatePkgConfig.section.md\\nversionCheckHook.section.md\\nwaf.section.md\\nzig.section.md\\nxcbuild.section.md\\nxfce4-dev-tools.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Defining HOCON Substitutions in Nix Expressions\nDESCRIPTION: Shows how to create variable substitutions in HOCON configuration files using mkSubstitution in pkgs.formats.hocon's lib from Nix. The snippet highlights both shorthand and option-rich forms for optional substitutions. Dependencies: pkgs.formats.hocon. Inputs: variable names or attribute sets for substitution. Output: Nix attrset suitable for generating compliant HOCON with variable substitution syntax.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.hocon { };\nin {\n  a = 1;\n  b = format.lib.mkSubstitution \"a\";\n  c = format.lib.mkSubstitution \"SOME_ENVVAR\";\n  d = format.lib.mkSubstitution {\n    value = \"SOME_OPTIONAL_ENVVAR\";\n    optional = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Shell Scripts with resholve.writeScript and resholve.writeScriptBin\nDESCRIPTION: Examples of using resholve.writeScript and resholve.writeScriptBin to create standalone shell scripts with properly resolved dependencies. These functions help ensure that commands like 'file' are available at runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/misc/resholve/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  resholvedScript = resholve.writeScript \"name\" {\n    inputs = [ file ];\n    interpreter = \"${bash}/bin/bash\";\n  } ''\n    echo \"Hello\"\n    file .\n  '';\n  resholvedScriptBin = resholve.writeScriptBin \"name\" {\n    inputs = [ file ];\n    interpreter = \"${bash}/bin/bash\";\n  } ''\n    echo \"Hello\"\n    file .\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NixOS Swap Device with Random Encryption - Nix - nix\nDESCRIPTION: This snippet demonstrates how to define a swap device in NixOS that uses random encryption with user-specified cipher, key size, and sector size. Dependencies include NixOS with the 'swapDevices' configuration available, and support for 'cryptsetup(8)' on the system. Key parameters include the device path, cipher ('aes-xts-plain64'), key size in bits, and sector size in bytes. The expected effect is to set up the swap partition at '/dev/disk/by-partlabel/swapspace' with strong random encryption, enhancing system security. Limitations include dependence on hardware compatibility and ensuring that cryptsetup supports the configured options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  swapDevices = [ {\n    device = \"/dev/disk/by-partlabel/swapspace\";\n    randomEncryption = {\n      enable = true;\n      cipher = \"aes-xts-plain64\";\n      keySize = 512;\n      sectorSize = 4096;\n    };\n  } ];\n}\n```\n\n----------------------------------------\n\nTITLE: Slashy Systems Package Configuration\nDESCRIPTION: Example of configuring slashy (secondary) systems using overrideLispAttrs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\necl.pkgs.alexandria.overrideLispAttrs (oldAttrs: {\n  systems = oldAttrs.systems ++ [ \"alexandria/tests\" ];\n  lispLibs = oldAttrs.lispLibs ++ [ ecl.pkgs.rt ];\n})\n```\n\n----------------------------------------\n\nTITLE: Checking Detailed Service Status\nDESCRIPTION: Demonstrates how to get detailed status information for a specific service (PostgreSQL example) including processes and recent logs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ systemctl status postgresql.service\npostgresql.service - PostgreSQL Server\n          Loaded: loaded (/nix/store/pn3q73mvh75gsrl8w7fdlfk3fq5qm5mw-unit/postgresql.service)\n          Active: active (running) since Mon, 2013-01-07 15:55:57 CET; 9h ago\n        Main PID: 2390 (postgres)\n          CGroup: name=systemd:/system/postgresql.service\n                  ├─2390 postgres\n                  ├─2418 postgres: writer process\n                  ├─2419 postgres: wal writer process\n                  ├─2420 postgres: autovacuum launcher process\n                  ├─2421 postgres: stats collector process\n                  └─2498 postgres: zabbix zabbix [local] idle\n\nJan 07 15:55:55 hagbard postgres[2394]: [1-1] LOG:  database system was shut down at 2013-01-07 15:55:05 CET\nJan 07 15:55:57 hagbard postgres[2390]: [1-1] LOG:  database system is ready to accept connections\nJan 07 15:55:57 hagbard postgres[2420]: [1-1] LOG:  autovacuum launcher started\nJan 07 15:55:57 hagbard systemd[1]: Started PostgreSQL Server.\n```\n\n----------------------------------------\n\nTITLE: Checking NVIDIA Container Toolkit CDI generator service status\nDESCRIPTION: This command checks the status of the NVIDIA Container Toolkit CDI generator service, which creates the necessary specifications for CUDA support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ systemctl status nvidia-container-toolkit-cdi-generator.service\n```\n\n----------------------------------------\n\nTITLE: Allowing Build of Unsupported Package via Environment Variable - Nix Tools - shell\nDESCRIPTION: Temporarily bypasses Nixpkgs checks for unsupported operating systems or platforms by exporting `NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM`. This applies to a single shell or nix invocation only, does not persist, and enables experimentation or debugging on non-target platforms.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ export NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM=1\n```\n\n----------------------------------------\n\nTITLE: Extensible Option Type GDM Backend\nDESCRIPTION: Demonstrates extending the display manager option type in the GDM backend module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.enable = mkOption {\n    type = with types; nullOr (enum [ \"gdm\" ]);\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building an npm Package via importNpmLock - Nix\nDESCRIPTION: This Nix snippet demonstrates the usage of buildNpmPackage with importNpmLock to generate npmDeps for reproducible builds. It configures the npmDeps attribute by invoking importNpmLock with npmRoot and sets the compatible npmConfigHook. Required dependencies are buildNpmPackage and importNpmLock. The main inputs are source location and minimal package metadata; outputs include a Nix derivation that resolves all dependencies in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{ buildNpmPackage, importNpmLock }:\n\nbuildNpmPackage {\n  pname = \"hello\";\n  version = \"0.1.0\";\n  src = ./.;\n\n  npmDeps = importNpmLock {\n    npmRoot = ./.;\n  };\n\n  npmConfigHook = importNpmLock.npmConfigHook;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Intel MKL with Octave via LD_LIBRARY_PATH\nDESCRIPTION: This shell command demonstrates how to use Intel's MKL library with Octave at runtime by setting the LD_LIBRARY_PATH environment variable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ LD_LIBRARY_PATH=$(nix-build -A mkl)/lib${LD_LIBRARY_PATH:+:}$LD_LIBRARY_PATH nix-shell -p octave --run octave\n```\n\n----------------------------------------\n\nTITLE: Enabling GNOME Flashback with Metacity - NixOS Module Configuration - Nix\nDESCRIPTION: Enables the GNOME Flashback session using the Metacity window manager in NixOS by setting 'services.xserver.desktopManager.gnome.flashback.enableMetacity' to true. Needs the pertinent NixOS modules. This provides a session with a classic GNOME 2 layout. Only the 'enableMetacity' parameter is required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.gnome.flashback.enableMetacity = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Discourse SMTP and Incoming Mail - Nix\nDESCRIPTION: This example demonstrates configuring Discourse with SMTP and optional receiving (incoming) email using the NixOS module. Both outgoing and incoming mail are configured using the appropriate options and parameters such as SMTP server, port, credentials (file paths), and enable flags. All paths and secrets must be provided; the configuration is suitable for enabling user notifications and reply-by-email features.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.discourse = {\n    enable = true;\n    hostname = \"discourse.example.com\";\n    sslCertificate = \"/path/to/ssl_certificate\";\n    sslCertificateKey = \"/path/to/ssl_certificate_key\";\n    admin = {\n      email = \"admin@example.com\";\n      username = \"admin\";\n      fullName = \"Administrator\";\n      passwordFile = \"/path/to/password_file\";\n    };\n    mail.outgoing = {\n      serverAddress = \"smtp.emailprovider.com\";\n      port = 587;\n      username = \"user@emailprovider.com\";\n      passwordFile = \"/path/to/smtp_password_file\";\n    };\n    mail.incoming.enable = true;\n    secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Meta Attributes in NixOS Modules - Nix\nDESCRIPTION: This snippet demonstrates how to define module-level meta attributes in a NixOS module using the Nix language. It sets the maintainers (as a list), specifies a documentation file, and sets buildDocsInSandbox to true. Required dependencies include the lib attribute (for maintainers), a markdown documentation file, and understanding of the module system. Main parameters are maintainers (list of maintainers), doc (path to markdown file), and buildDocsInSandbox (boolean to control sandboxed doc building). The code outputs a Nix attribute set for integration into larger NixOS module systems. Only one set of meta attributes may be defined per module file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/meta-attributes.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, ... }:\n{\n  options = {\n    # ...\n  };\n\n  config = {\n    # ...\n  };\n\n  meta = {\n    maintainers = with lib.maintainers; [ ericsagnes ];\n    doc = ./default.md;\n    buildDocsInSandbox = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Handling pnpm projects in subdirectories with sourceRoot\nDESCRIPTION: Example showing how to configure pnpm for projects located in subdirectories by setting sourceRoot and pnpmRoot attributes in the Nix derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n  pnpmDeps = pnpm.fetchDeps {\n    # ...\n    sourceRoot = \"${finalAttrs.src.name}/frontend\";\n  };\n\n  # by default the working directory is the extracted source\n  pnpmRoot = \"frontend\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Text File in the Nix Store with writeTextFile - Nix\nDESCRIPTION: This example demonstrates the use of `writeTextFile` in a Nix attribute set to generate a text file at a specific directory within the store. The produced file can then be accessed by concatenating the appropriate subpath to the derivation's store path. Parameters include the file name, content, and destination path. This approach is useful when you need to ensure generated files are organized and accessible across derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  my-file = writeTextFile {\n    name = \"my-file\";\n    text = ''\n      Contents of File\n    '';\n    destination = \"/share/my-file\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Oh My Zsh with Plugins and Theme - Nix Programming Language\nDESCRIPTION: This Nix expression enables the Oh My Zsh framework for the Zsh shell, specifying active plugins and a prompt theme. The 'programs.zsh.ohMyZsh' attribute set is configured to enable oh-my-zsh, set three plugins (git, python, man), and select the \"agnoster\" theme. Dependencies: the oh-my-zsh package is required and managed automatically by the module. Inputs are set via attribute assignment; outputs are integrated into the system Zsh configuration at /etc/zshrc. Only Nix expressions and proper module load context are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/zsh/oh-my-zsh.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.zsh.ohMyZsh = {\n    enable = true;\n    plugins = [ \"git\" \"python\" \"man\" ];\n    theme = \"agnoster\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive gitignore Filtering in Nix with gitignoreFilterRecursiveSource and gitignoreRecursiveSource\nDESCRIPTION: This snippet demonstrates two approaches for recursively searching and applying gitignore files in subdirectories—a custom gitignoreFilterRecursiveSource or the more direct gitignoreRecursiveSource using an always-true filter. These functions help filter sources more closely emulating git's default recursive ignore behavior. Requires nix-gitignore functions within the nixpkgs context.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/nix-gitignore.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # gitignoreFilterRecursiveSource = filter: patterns: root:\n  # OR\n  gitignoreRecursiveSource = gitignoreFilterSourcePure (_: _: true);\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Fake Cargo Hash for Build Bootstrapping - Nix Attribute Expression - Nix\nDESCRIPTION: Replaces the cargo hash with `lib.fakeHash` as a stub value when the actual hash is unknown, which will intentionally cause a build failure and output the real hash needed. This method is part of the bootstrapping workflow for new or changed dependencies. `lib` must be in the closure; outputs a build failure message with the correct hash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  cargoHash = lib.fakeHash;\n}\n```\n\n----------------------------------------\n\nTITLE: Granting Permissions via Intermediate Oneshot Service as Superuser - NixOS systemd Service - Nix\nDESCRIPTION: Defines a separate oneshot systemd service for database migration, running as the postgres superuser, to grant SELECT privileges to another user post-backend startup but before dependent services run. Requires configuring service ordering and dependencies, ensuring access to the correct version of PostgreSQL CLI tools via environment variables and paths. Key parameters include serviceConfig.Type, requiredBy, service ordering, and SQL commands. The result is a repeatable, orchestrated permission migration during system activation. This approach is robust across PostgreSQL versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n  {\n    systemd.services.\"migrate-service1-db1\" = {\n      serviceConfig.Type = \"oneshot\";\n      requiredBy = \"service1.service\";\n      before = \"service1.service\";\n      after = \"postgresql.service\";\n      serviceConfig.User = \"postgres\";\n      environment.PSQL = \"psql --port=${toString services.postgresql.settings.port}\";\n      path = [ postgresql ];\n      script = ''\n        $PSQL service1 -c 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO \"extraUser1\"'\n        $PSQL service1 -c 'GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO \"extraUser1\"'\n        # ....\n      '';\n    };\n  }\n```\n\n----------------------------------------\n\nTITLE: Composing multiple Haskell package transformations with lib.pipe - Nix Expression Language\nDESCRIPTION: Combines multiple override and transformation functions for a Haskell package derivation using lib.pipe. Operations such as doJailbreak, dontHaddock, and enabling a specific Cabal flag are applied in sequence. Dependencies include lib.pipe and haskell.lib.compose from nixpkgs. The input is a package derivation, and the output is a new derivation with all transformations applied, allowing for modular and reusable build logic.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nlib.pipe my-haskell-package [\n  # lift version bounds on dependencies\n  haskell.lib.compose.doJailbreak\n  # disable building the haddock documentation\n  haskell.lib.compose.dontHaddock\n  # pass extra package flag to Cabal's configure step\n  (haskell.lib.compose.enableCabalFlag \"myflag\")\n]\n\n```\n\n----------------------------------------\n\nTITLE: Generating WPA2 PSK Raw Key with wpa_passphrase\nDESCRIPTION: Shows how to use the wpa_passphrase utility to generate a raw PSK key for WPA2 networks from an ESSID and passphrase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\n$ wpa_passphrase ESSID PSK\nnetwork={\n        ssid=\"echelon\"\n        #psk=\"abcdefgh\"\n        psk=dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Firejail Wrapped Binaries in NixOS (Nix)\nDESCRIPTION: This Nix code snippet demonstrates how to enable Firejail and wrap specific binaries (such as Firefox and mpv) using the 'programs.firejail' attribute set in a NixOS configuration file. 'enable' toggles Firejail support, and 'wrappedBinaries' specifies which applications should be wrapped (run inside the Firejail sandbox) using absolute paths resolved via the 'lib.getBin' function. The result is that named binaries are placed in the global path, automatically protected by Firejail when run. Dependencies include a NixOS system and the specified applications present in the package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1809.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.firejail = {\n    enable = true;\n    wrappedBinaries = {\n      firefox = \"${lib.getBin pkgs.firefox}/bin/firefox\";\n      mpv = \"${lib.getBin pkgs.mpv}/bin/mpv\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Overridable Functions with lib.makeOverridable (Nix Language)\nDESCRIPTION: Shows usage of lib.makeOverridable to create a function that provides an overridable interface for its result. The example demonstrates a function f adding two arguments a and b, and then constructing c as an overridable version with defaults. This allows further modifications via .override. Requires lib.makeOverridable utility and a function compatible with argument sets. Input is a function and default args, output is an overridable value supporting .override.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  f =\n    { a, b }:\n    {\n      result = a + b;\n    };\n  c = lib.makeOverridable f {\n    a = 1;\n    b = 2;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Anubis with TCP Sockets - Nix\nDESCRIPTION: This example configures Anubis to use only TCP sockets instead of Unix sockets. It sets various attributes such as BIND, BIND_NETWORK, and METRICS_BIND settings to designated TCP addresses. Dependencies include the NixOS module system and a service backend available on the specified target port. The input is a NixOS configuration block for Anubis and the output is a TCP-based configuration suitable for environments where Unix sockets are not practical.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/anubis.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.anubis = {\n    instances.default = {\n      settings = {\n        TARGET = \"http://localhost:8080\";\n        BIND = \":9000\";\n        BIND_NETWORK = \"tcp\";\n        METRICS_BIND = \"127.0.0.1:9001\";\n        METRICS_BIND_NETWORK = \"tcp\";\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Vendoring Cargo Dependencies with Hash\nDESCRIPTION: Example of using fetchCargoVendor to vendor dependencies with a specified hash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n{\n  cargoDeps = rustPlatform.fetchCargoVendor {\n    inherit src;\n    hash = \"sha256-BoHIN/519Top1NUBjpB/oEMqi86Omt3zTQcXFWqrek0=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Neovim with Custom Plugins in Nix\nDESCRIPTION: This snippet demonstrates how to configure Neovim with custom plugins and settings using the 'neovim.override' function in Nix. It allows for adding custom configuration and specifying plugins to be loaded at startup or optionally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/neovim.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nneovim.override {\n  configure = {\n    customRC = ''\n      # here your custom configuration goes!\n    '';\n    packages.myVimPackage = with pkgs.vimPlugins; {\n      # See examples below on how to use custom packages.\n      start = [ ];\n      # If a Vim plugin has a dependency that is not explicitly listed in\n      # `opt`, that dependency will always be added to `start` to avoid confusion.\n      opt = [ ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling LightDM for Pantheon in NixOS\nDESCRIPTION: Configuration to disable LightDM and Pantheon's LightDM greeter. Note that using Pantheon without LightDM will break screenlocking from the UI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.lightdm.greeters.pantheon.enable = false;\n  services.xserver.displayManager.lightdm.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Borg backup extraArgs as Bash array in preHook\nDESCRIPTION: This diff shows how to properly modify Borg backup extra arguments in preHook scripts. The syntax has changed as arguments are now represented as Bash arrays instead of space-separated strings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n-extraCreateArgs=\"$extraCreateArgs --exclude /some/path\"\n+extraCreateArgs+=(\"--exclude\" \"/some/path\")\n```\n\n----------------------------------------\n\nTITLE: Invoking Cross-Compilation Builds with nix-build (ShellSession)\nDESCRIPTION: This code snippet demonstrates how to invoke a cross-build using the `nix-build` command-line tool, targeting a specific cross-compilation platform defined in `lib.systems.examples`. The command passes the desired crossSystem attribute to Nixpkgs, allowing package builds for a requested target system. Requires a Nixpkgs setup that includes the referenced `lib.systems.examples.fooBarBaz` system. The primary parameter is `crossSystem` (the target specification); the intention is to build package 'whatever' for the cross target. Output will be the result path of the derivation for the specified cross-compiled system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build '<nixpkgs>' --arg crossSystem '(import <nixpkgs/lib>).systems.examples.fooBarBaz' -A whatever\n```\n\n----------------------------------------\n\nTITLE: Enabling Grafana, GeoIP, and Nginx for Parsedmarc Visualization - Nix\nDESCRIPTION: Presents a comprehensive NixOS configuration integrating Parsedmarc with Grafana for DMARC visualization, provisioning local mail and necessary Grafana dashboards, and enabling GeoIP updates for extended reporting accuracy. The snippet configures Elasticsearch datasource and dashboard provisioning, sets up secure Grafana with socket-based access, and configures nginx as a secure reverse proxy with recommended settings. Dependencies include a functioning Parsedmarc setup, Grafana, GeoIP database update credentials, secure password management, and properly set DNS/MX records. Input parameters include various service options and their secrets, resulting in a fully integrated reporting and visualization stack.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/parsedmarc.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.parsedmarc = {\n    enable = true;\n    provision = {\n      localMail = {\n        enable = true;\n        hostname = url;\n      };\n      grafana = {\n        datasource = true;\n        dashboard = true;\n      };\n    };\n  };\n\n  # Not required, but recommended for full functionality\n  services.geoipupdate = {\n    settings = {\n      AccountID = 000000;\n      LicenseKey = \"/path/to/license_key_file\";\n    };\n  };\n\n  services.grafana = {\n    enable = true;\n    addr = \"0.0.0.0\";\n    domain = url;\n    rootUrl = \"https://\" + url;\n    protocol = \"socket\";\n    security = {\n      adminUser = \"admin\";\n      adminPasswordFile = \"/path/to/admin_password_file\";\n      secretKeyFile = \"/path/to/secret_key_file\";\n    };\n  };\n\n  services.nginx = {\n    enable = true;\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n    recommendedProxySettings = true;\n    upstreams.grafana.servers.\"unix:/${config.services.grafana.socket}\" = {};\n    virtualHosts.${url} = {\n      root = config.services.grafana.staticRootPath;\n      enableACME = true;\n      forceSSL = true;\n      locations.\"/\".tryFiles = \"$uri @grafana\";\n      locations.\"@grafana\".proxyPass = \"http://grafana\";\n    };\n  };\n  users.users.nginx.extraGroups = [ \"grafana\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Jailbreak for Haskell Packages\nDESCRIPTION: Functions to enable or disable jailbreaking (ignoring version bounds) for Haskell package dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\ndoJailbreak drv\ndontJailbreak drv\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx ReadWritePaths in NixOS\nDESCRIPTION: This snippet shows how to allow Nginx write access to additional folders using the systemd.services.nginx.serviceConfig.ReadWritePaths option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.nginx.serviceConfig.ReadWritePaths = [ \"/var/www\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring xcrun Binary Path\nDESCRIPTION: Shows how to properly configure xcrun binary dependencies in build inputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  # ...\n  nativeBuildInputs = [ bison ];\n  buildCommand = ''\n    xcrun bison foo.y # produces foo.tab.c\n    # ...\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Including Chapters with Markdown {=include=} Directives - Markdown\nDESCRIPTION: This snippet demonstrates the use of a special Markdown syntax ('{=include=}') to include multiple chapter files into a single documentation section. Dependencies include the Markdown preprocessor or tooling that recognizes and processes the '{=include=}' directive. The snippet expects a series of chapter filenames (e.g., sources.chapter.md, writing-modules.chapter.md) as parameters, and when processed, their contents will be inserted into the resulting documentation. The input is a hardcoded list of file paths, and the output will be the aggregated contents at render or build time. This approach requires a Markdown toolchain with support for custom include directives.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/development.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\nsources.chapter.md\nwriting-modules.chapter.md\nbuilding-parts.chapter.md\nbootspec.chapter.md\nwhat-happens-during-a-system-switch.chapter.md\nwriting-documentation.chapter.md\nnixos-tests.chapter.md\ndeveloping-the-test-driver.chapter.md\ntesting-installer.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Using Fixed-Output Derivations for Remote Imports\nDESCRIPTION: Demonstrates using the --fixed-output-derivations flag with dhall-to-nixpkgs to fetch and build remote imports as fixed-output derivations. This approach uses Dhall integrity checks instead of requiring manual packaging of dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ dhall-to-nixpkgs directory --fixed-output-derivations ~/proj/dhall-semver\n{ buildDhallDirectoryPackage, buildDhallUrl }:\n  buildDhallDirectoryPackage {\n    name = \"proj\";\n    src = ~/proj/dhall-semver;\n    file = \"package.dhall\";\n    source = false;\n    document = false;\n    dependencies = [\n      (buildDhallUrl {\n        url = \"https://prelude.dhall-lang.org/v17.0.0/package.dhall\";\n        hash = \"sha256-ENs8kZwl6QRoM9+Jeo/+JwHcOQ+giT2VjDQwUkvlpD4=\";\n        dhallHash = \"sha256:10db3c919c25e9046833df897a8ffe2701dc390fa0893d958c3430524be5a43e\";\n        })\n      ];\n    }\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic System Upgrades - NixOS Configuration - Nix\nDESCRIPTION: This NixOS module snippet enables automatic system upgrades by setting the 'system.autoUpgrade.enable' option to true within the configuration file. Required dependency: NixOS system configuration environment. No specific input is needed except being placed in a relevant NixOS configuration file (typically configuration.nix). This setting periodically checks the Nix channel for updates and initiates 'nixos-rebuild', helping to keep the OS up-to-date automatically without user intervention.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.autoUpgrade.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Available Libraries in Idris\nDESCRIPTION: Command to list all available libraries that the Idris binary has access to using the --listlibs flag.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ idris --listlibs\n00prelude-idx.ibc\npruviloj\nbase\ncontrib\nprelude\n00pruviloj-idx.ibc\n00base-idx.ibc\n00contrib-idx.ibc\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Text File with writeTextFile in Nix\nDESCRIPTION: This example shows how to use writeTextFile to create a simple text file in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nwriteTextFile {\n  name = \"my-file\";\n  text = ''\n    Contents of File\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Pulling a Docker Image from Default Registry using dockerTools.pullImage - Nix\nDESCRIPTION: This Nix snippet demonstrates how to use dockerTools.pullImage to fetch a Docker image (\\\"nixos/nix\\\") from the default Docker registry (docker.io). It specifies all required parameters including imageName, imageDigest, and hash, as well as optional parameters finalImageName and finalImageTag to set local naming. This pattern requires Nix and dockerTools, ensures repository consistency by using immutable digests, and outputs the image into the Nix store with the given tags and hash for reproducibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools }:\ndockerTools.pullImage {\n  imageName = \"nixos/nix\";\n  imageDigest = \"sha256:b8ea88f763f33dfda2317b55eeda3b1a4006692ee29e60ee54ccf6d07348c598\";\n  finalImageName = \"nix\";\n  finalImageTag = \"2.19.3\";\n  hash = \"sha256-zRwlQs1FiKrvHPaf8vWOR/Tlp1C5eLn1d9pE4BZg3oA=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Haskell package input versions using override - Nix Expression Language\nDESCRIPTION: Demonstrates overriding specific dependencies of a Haskell package using the override function in nixpkgs. In this snippet, the brick dependency is overridden to use a specific version while building haskellPackages.nix-tree. This approach enables fine-grained control over transitive dependencies but may create inconsistent dependency graphs if other packages require different versions. The input is a Nix derivation and the output is the overridden package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nhaskellPackages.nix-tree.override {\n  brick = haskellPackages.brick_0_67;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Support for Multiple GPS Devices in GPSD - NixOS Service Option - Markdown\nDESCRIPTION: This snippet notes that services.gpsd.device has been replaced by services.gpsd.devices, which can accept multiple devices. This change introduces multi-device support and requires updated configuration when running GPSD with more than one GPS input. It relies on the GPSD daemon.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_24\n\nLANGUAGE: markdown\nCODE:\n```\n- The option \\`services.gpsd.device\\` has been replaced with  \\`services.gpsd.devices\\`, which supports multiple devices.\n```\n\n----------------------------------------\n\nTITLE: New tryEmptyPassphrase Option for LUKS Devices in Initrd - NixOS Boot Option - Markdown\nDESCRIPTION: This entry introduces the tryEmptyPassphrase option for boot.initrd.luks.device.<name>, allowing encrypted disk installs with an unset passphrase for later registration, intended mainly for OEM scenarios. It requires that the LUKS-enabled device be set up during the initrd phase of booting.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_27\n\nLANGUAGE: markdown\nCODE:\n```\n- \\`boot.initrd.luks.device.<name>\\` has a new \\`tryEmptyPassphrase\\` option, this is useful for OEMs who need to install an encrypted disk with a future settable passphrase\n```\n\n----------------------------------------\n\nTITLE: Basic Package Definition Structure in Nix\nDESCRIPTION: Example of a basic package definition function in Nix that takes dependencies and configuration options as arguments and returns a derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  libbar,\n\n  enableBar ? false,\n}:\n\nstdenv.mkDerivation {\n  # ...\n  buildInputs =\n    lib.optional enableBar libbar;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Chromecast Support for VLC in NixOS Configuration\nDESCRIPTION: This snippet demonstrates how to open TCP port 8010 in the NixOS firewall configuration to enable Chromecast streaming support for VLC.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nnetworking.firewall.allowedTCPPorts = [ 8010 ];\n```\n\n----------------------------------------\n\nTITLE: Running Evaluation Unit Tests with nix-instantiate - Bash\nDESCRIPTION: Explains how to quickly evaluate unit tests defined in 'tests/misc.nix' using 'nix-instantiate'. If the returned list is empty, it indicates all tests passed. Requires the Nix package manager and an existing 'tests/misc.nix' file; outputs evaluation results to standard output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnix-instantiate --eval --strict tests/misc.nix\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Eclipse Environment with Plugins in NixOS\nDESCRIPTION: This Nix expression creates a custom Eclipse environment with additional memory allocation and the Color Theme plugin. It demonstrates how to use the eclipseWithPlugins function to declaratively configure Eclipse.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/eclipse.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: {\n    myEclipse =\n      with pkgs.eclipses;\n      eclipseWithPlugins {\n        eclipse = eclipse-platform;\n        jvmArgs = [ \"-Xmx2048m\" ];\n        plugins = [ plugins.color-theme ];\n      };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Coverage for Haskell Packages\nDESCRIPTION: Functions to enable or disable coverage generation for Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_32\n\nLANGUAGE: nix\nCODE:\n```\ndoCoverage drv\ndontCoverage drv\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Cross-Compilation Configurations in nix-build (ShellSession)\nDESCRIPTION: This snippet shows an alternative way to invoke `nix-build` by specifying an explicit crossSystem configuration dictionary with custom architecture/OS/vendor/ABI fields. The command bypasses the convenience platforms with a manual config, which lets advanced users target arbitrary platforms. The required field is `config`, which should be filled with the desired platform tuple. The output is similar to standard builds but targets a custom cross-compiled system. This can fail if other relevant configuration settings are required and not provided.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build '<nixpkgs>' --arg crossSystem '{ config = \"<arch>-<os>-<vendor>-<abi>\"; }' -A whatever\n```\n\n----------------------------------------\n\nTITLE: Basic Meta-attributes Example in Nix\nDESCRIPTION: Example showing basic meta-attributes declaration for the GNU Hello package, including description, homepage, license, maintainers and platform support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/meta.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  meta = {\n    description = \"Program that produces a familiar, friendly greeting\";\n    longDescription = ''\n      GNU Hello is a program that prints \"Hello, world!\" when you run it.\n      It is fully customizable.\n    '';\n    homepage = \"https://www.gnu.org/software/hello/manual/\";\n    license = lib.licenses.gpl3Plus;\n    maintainers = with lib.maintainers; [ eelco ];\n    platforms = lib.platforms.all;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Overlays with override in Package Set (Nix Language)\nDESCRIPTION: Illustrates the use of Nix overlays to apply argument overrides across an entire package set. Here, an overlay is defined as a function taking self and super, overriding the barSupport attribute for foo. Requires the import of pkgs.path with an overlays list. Key input is the overlay list, output is a modified package set with overridden subpackages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nimport pkgs.path {\n  overlays = [\n    (self: super: {\n      foo = super.foo.override { barSupport = true; };\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building Ant-based Java Projects with Nix (Nix)\nDESCRIPTION: Demonstrates how to build Java projects using Ant within Nix, including recommended build and install phases. Relies on dependencies such as ant, jdk, and stripJavaArchivesHook for deterministic JAR files. Shows structure for fetching sources and installing JARs into the correct directory. Outputs built JARs for later reuse in share/java. Limitations: reproducibility is improved with stripJavaArchivesHook but not always guaranteed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  pname = \"...\";\n  version = \"...\";\n\n  src = fetchurl {\n    # ...\n  };\n\n  nativeBuildInputs = [\n    ant\n    jdk\n    stripJavaArchivesHook # removes timestamp metadata from jar files\n  ];\n\n  buildPhase = ''\n    runHook preBuild\n    ant # build the project using ant\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    # copy generated jar file(s) to an appropriate location in $out\n    install -Dm644 build/foo.jar $out/share/java/foo.jar\n\n    runHook postInstall\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Settings for Anki Sync Server in NixOS\nDESCRIPTION: This snippet demonstrates how to configure Anki Sync Server to listen on all interfaces and open the firewall for external access.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/anki-sync-server.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.anki-sync-server.address = \"0.0.0.0\";\n  services.anki-sync-server.openFirewall = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Python Environment to NixOS System Configuration - Nix\nDESCRIPTION: Demonstrates how to declare system-wide Python packages for NixOS via /etc/nixos/configuration.nix. This snippet appends a Python environment with numpy and toolz to environment.systemPackages, making these tools available on the system for all users after rebuilding. Requires NixOS and appropriate permissions to edit configuration.nix. Important parameters: interpreter version, package list. All listed packages will be globally present.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # ...\n\n  environment.systemPackages = with pkgs; [\n    (python310.withPackages (\n      ps: with ps; [\n        numpy\n        toolz\n      ]\n    ))\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating NixOS Configuration on Target Root (Shell)\nDESCRIPTION: Uses nixos-generate-config to generate initial configuration files for a NixOS installation targeting an existing mount point. This enables bootstrapping of the system configuration in preparation for installation. Prerequisites: Target partition mounted at /mnt, nixos-generate-config installed. Output: Populates /mnt/etc/nixos with hardware and base configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo `which nixos-generate-config` --root /mnt\n```\n\n----------------------------------------\n\nTITLE: Configuring preFixup to Manually Wrap GNOME/GTK Executables (Nix)\nDESCRIPTION: Demonstrates a custom `preFixup` script in a Nix package expression to manually wrap all executables found in the `bin` and `libexec` directories, setting up environment variables required by GNOME/GTK applications. Dependencies include utilities/functions like `find`, `wrapProgram`, `getLib`, and Nix package variables such as `dconf` and `gsettings-desktop-schemas`. The snippet expects variables like `lib`, `pango`, and `json-glib` to be defined in the surrounding scope. Input is a set of named package variables; output is a shell script run during the Nix build to ensure executables have correct runtime wrappers. Limitations: Script assumes all executables require identical environment variable setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gnome.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  preFixup = ''\n    for f in $(find $out/bin/ $out/libexec/ -type f -executable); do\n      wrapProgram \"$f\" \\\n        --prefix GIO_EXTRA_MODULES : \"${getLib dconf}/lib/gio/modules\" \\\n        --prefix XDG_DATA_DIRS : \"$out/share\" \\\n        --prefix XDG_DATA_DIRS : \"$out/share/gsettings-schemas/${name}\" \\\n        --prefix XDG_DATA_DIRS : \"${gsettings-desktop-schemas}/share/gsettings-schemas/${gsettings-desktop-schemas.name}\" \\\n        --prefix XDG_DATA_DIRS : \"${hicolor-icon-theme}/share\" \\\n        --prefix GI_TYPELIB_PATH : \"${\n          lib.makeSearchPath \"lib/girepository-1.0\" [\n            pango\n            json-glib\n          ]\n        }\"\n    done\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Options for Idris Packages\nDESCRIPTION: Example of setting build options for the Idris compiler when building a package, demonstrating how to configure logging and verbosity.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nbuild-idris-package {\n  idrisBuildOptions = [\n    \"--log\"\n    \"1\"\n    \"--verbose\"\n  ];\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using binSh Helper with buildImage in NixOS\nDESCRIPTION: Example showing how to add the binSh helper to a Docker image built with dockerTools.buildImage, which enables shell access inside the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_26\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildImage {\n  name = \"env-helpers\";\n  tag = \"latest\";\n\n  copyToRoot = [\n    hello\n    dockerTools.binSh\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Importing a Single File With Root and Empty Fileset (Nix)\nDESCRIPTION: This Nix code snippet exemplifies using toSource with a single file root and an empty fileset. It is used to illustrate an edge case in the library's design, questioning reasonable behavior when requesting to import a single file while filtering out all contents. The example is not meant for direct use, but supports discussion about the lack of meaningful results when applying the file set abstraction to a single file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_4\n\nLANGUAGE: Nix\nCODE:\n```\n\"toSource { root = ./file.nix; fileset = <empty>; }\"\n```\n\n----------------------------------------\n\nTITLE: Running lib.sources Tests with Bash Script - Bash\nDESCRIPTION: Illustrates invoking 'tests/sources.sh' to run the 'lib.sources' tests using a bash script. Assumes test scripts are in the proper location and have required permissions. Output and artifacts depend on script internals.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\ntests/sources.sh\n```\n\n----------------------------------------\n\nTITLE: Customizing SSH Command for SSHFS in NixOS\nDESCRIPTION: Example of modifying the SSH command used by SSHFS to connect to the server, including additional options like verbose output and port forwarding.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options =\n    [ (builtins.replaceStrings [\" \"] [\"\\\\040\"]\n        \"ssh_command=${pkgs.openssh}/bin/ssh -v -L 8080:localhost:80\")\n    ];\n\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Userborn Password File Location - Nix - nix\nDESCRIPTION: This Nix snippet configures Userborn to store password files outside the default '/etc' path by setting 'services.userborn.passwordFilesLocation'. This is useful for systems with '/etc' on tmpfs or immutable overlay setups, ensuring persistence of user data. The value should be a string path; here it is set to '/persistent/etc'. Userborn will create and symlink required files accordingly. Requires that Userborn is enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nservices.userborn.passwordFilesLocation = \"/persistent/etc\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Agda with Package Function - Nix - nix\nDESCRIPTION: Shows an alternative way to provide packages to agda.withPackages by passing a function, allowing more dynamic or programmatic selection of packages. The function receives agdaPackages as its argument and returns the desired packages. This is particularly useful for reusing package references or constructing lists based on attributes. Dependencies remain agda and agdaPackages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages (p: [ p.standard-library ])\n```\n\n----------------------------------------\n\nTITLE: Listing Available Eclipse Packages in NixOS\nDESCRIPTION: This command lists all available Eclipse packages in Nixpkgs, including their descriptions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/eclipse.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f '<nixpkgs>' -qaP -A eclipses --description\n```\n\n----------------------------------------\n\nTITLE: Building a fetchurl Package with nix-build - Shell\nDESCRIPTION: This shell snippet illustrates the build process using 'nix-build' for a Nix package that downloads a file with 'fetchurl'. After building, the resulting file resides in the Nix store, and its contents can be printed with 'cat'. No extra dependencies are required beyond a working Nix installation. The output demonstrates where the file is placed and shows the file content.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/4g9y3x851wqrvim4zcz5x2v3zivmsq8n-version\n\n$ cat /nix/store/4g9y3x851wqrvim4zcz5x2v3zivmsq8n-version\n23.11\n```\n\n----------------------------------------\n\nTITLE: Building a Perl Package with nix-build - ShellSession\nDESCRIPTION: This snippet shows how to build a specified Perl package from the perlPackages set using nix-build. Requires a valid Nix environment and the package attribute (e.g., 'perlPackages.ClassC3'). Input is the package attribute; output is a built derivation in the local Nix store. This is an essential step for testing and building custom Perl modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A perlPackages.ClassC3\n```\n\n----------------------------------------\n\nTITLE: Configuring OCR Languages for Paperless-ng Using NixOS Module - nix\nDESCRIPTION: This snippet demonstrates how to set OCR language options in the paperless-ng module on NixOS. It uses the extraConfig attribute to specify languages via the PAPERLESS_OCR_LANGUAGE environment variable in ISO 639-2 codes, separated by plus (+) signs. Users must include this block in their NixOS configuration, and no external dependencies are required beyond the paperless-ng service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2111.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.paperless-ng.extraConfig = {\n    # Provide languages as ISO 639-2 codes\n    # separated by a plus (+) sign.\n    # https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes\n    PAPERLESS_OCR_LANGUAGE = \"deu+eng+jpn\"; # German & English & Japanse\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a C++ Build Environment - CMake - Plain Text\nDESCRIPTION: This snippet defines the minimum CMake version required (3.10), creates a new C++ project, adds an executable target from the 'main.cpp' source file, and specifies installation instructions for that target. There are no external dependencies beyond CMake and a working C++ compiler; 'main.cpp' must be present. Parameters like the project and target name must be manually updated if the project changes. The output is a configured CMake project ready for building and installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/he/hello-cpp/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10)\nproject(hello-cpp)\n\nadd_executable(hello-cpp main.cpp)\n\ninstall(TARGETS hello-cpp)\n```\n\n----------------------------------------\n\nTITLE: Example Dhall File with Prelude Dependency\nDESCRIPTION: A simple Dhall file that imports the Prelude package (version 19.0.0) and uses it to negate a boolean value. This example is used to demonstrate dependency version conflicts and overrides.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_9\n\nLANGUAGE: dhall\nCODE:\n```\n-- ./true.dhall\n\nlet Prelude =\n      https://prelude.dhall-lang.org/v19.0.0/package.dhall\n        sha256:eb693342eb769f782174157eba9b5924cf8ac6793897fc36a31ccbd6f56dafe2\n\nin  Prelude.Bool.not False\n```\n\n----------------------------------------\n\nTITLE: Stratis Pool Boot Support via fileSystems Attribute - NixOS Boot Option - Markdown\nDESCRIPTION: This entry notes that systems can now boot from a Stratis-managed pool, with configuration placed under fileSystems.<name>.stratis.poolUuid. It enables advanced storage and boot management provided by Stratis, provided the relevant UUID and pool are available and configured.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_30\n\nLANGUAGE: markdown\nCODE:\n```\n- Booting from a volume managed by the Stratis storage management daemon is now supported. Use \\`fileSystems.<name>.stratis.poolUuid\\` to configure the pool containing the fs.\n```\n\n----------------------------------------\n\nTITLE: Variable Manipulation Examples (Shell)\nDESCRIPTION: Examples showing prepend and append operations on shell variables\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_37\n\nLANGUAGE: shellSession\nCODE:\n```\n$ configureFlags=\"--disable-static\"\n$ prependToVar configureFlags --disable-dependency-tracking --enable-foo\n$ echo $configureFlags\n--disable-dependency-tracking --enable-foo --disable-static\n```\n\nLANGUAGE: shellSession\nCODE:\n```\n$ configureFlags=\"--disable-static\"\n$ appendToVar configureFlags --disable-dependency-tracking --enable-foo\n$ echo $configureFlags\n--disable-static --disable-dependency-tracking --enable-foo\n```\n\n----------------------------------------\n\nTITLE: Defining a Nix Store Partition - NixOS Module - Nix\nDESCRIPTION: Shows configuration of a NixOS system to create a dedicated partition for /nix/store using systemd-repart. Sets device paths, populates storePaths, and uses stripNixStorePrefix to avoid duplicating the mount prefix. Example demonstrates repartConfig attributes for a specialized partition, and requires image/repart.nix along with system device mapping.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-images-via-systemd-repart.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems.\"/nix/store\".device = \"/dev/disk/by-partlabel/nix-store\";\n\n  image.repart.partitions = {\n    \"store\" = {\n      storePaths = [ config.system.build.toplevel ];\n      stripNixStorePrefix = true;\n      repartConfig = {\n        Type = \"linux-generic\";\n        Label = \"nix-store\";\n        # ...\n      };\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx as Reverse Proxy for Pleroma\nDESCRIPTION: NixOS configuration for Nginx as a reverse proxy for Pleroma, including ACME/Let's Encrypt SSL certificate setup, security headers, and proxy settings for WebSockets support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.acme = {\n    email = \"root@example.net\";\n    acceptTerms = true;\n  };\n\n  services.nginx = {\n    enable = true;\n    addSSL = true;\n\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n\n    recommendedProxySettings = false;\n    # NOTE: if enabled, the NixOS proxy optimizations will override the Pleroma\n    # specific settings, and they will enter in conflict.\n\n    virtualHosts = {\n      \"pleroma.example.net\" = {\n        http2 = true;\n        enableACME = true;\n        forceSSL = true;\n\n        locations.\"/\" = {\n          proxyPass = \"http://127.0.0.1:4000\";\n\n          extraConfig = ''\n            etag on;\n            gzip on;\n\n            add_header 'Access-Control-Allow-Origin' '*' always;\n            add_header 'Access-Control-Allow-Methods' 'POST, PUT, DELETE, GET, PATCH, OPTIONS' always;\n            add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, Idempotency-Key' always;\n            add_header 'Access-Control-Expose-Headers' 'Link, X-RateLimit-Reset, X-RateLimit-Limit, X-RateLimit-Remaining, X-Request-Id' always;\n            if ($request_method = OPTIONS) {\n              return 204;\n            }\n            add_header X-XSS-Protection \"1; mode=block\";\n            add_header X-Permitted-Cross-Domain-Policies none;\n            add_header X-Frame-Options DENY;\n            add_header X-Content-Type-Options nosniff;\n            add_header Referrer-Policy same-origin;\n            add_header X-Download-Options noopen;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n            proxy_set_header Host $host;\n\n            client_max_body_size 16m;\n            # NOTE: increase if users need to upload very big files\n          '';\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Haskell package dependencies globally using overrideScope - Nix Expression Language\nDESCRIPTION: This snippet uses overrideScope to globally override a package dependency (Cabal) for a Haskell derivation and its closure. By applying the override at the scope level for haskellPackages.haskell-ci, it ensures all dependencies use a consistent version, preventing configuration-time errors from multiple conflicting versions. It depends on the self and super package sets from nixpkgs. The result is a new package set with the global override applied.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nhaskellPackages.haskell-ci.overrideScope (self: super: {\n  Cabal = self.Cabal_3_14_1_0;\n})\n\n```\n\n----------------------------------------\n\nTITLE: Propagating Dependencies with nimOverrides in Lockfile - Nix Expression - Nix\nDESCRIPTION: This snippet shows how to define an override function in a 'nimOverrides' attrset to inject additional dependencies, such as SDL2, based on the libraries listed in a lockfile. The override function receives the current lock and previous attributes, and appends the dependency. Dependencies: Nix, 'nimOverrides', the dependency (e.g., SDL2). Inputs: lockAttrs, previous derivation attributes. Output: Modified attribute set including the extra dependency. Limitation: Requires editing or overlaying the nimOverrides attrset.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  # …\n  SDL2,\n# …\n}:\n\n{\n  # …\n  sdl2 =\n    lockAttrs:\n    {\n      buildInputs ? [ ],\n      ...\n    }:\n    {\n      buildInputs = buildInputs ++ [ SDL2 ];\n    };\n  # …\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Explicit Vergen Environment Variables for COSMIC Builds in Nix\nDESCRIPTION: This code gives an example of setting explicit Vergen-build environment variables in the Nix build to ensure successful Rust-based COSMIC application builds. By defining VERGEN_GIT_COMMIT_DATE and VERGEN_GIT_SHA in the env attribute, the build process avoids errors related to missing git metadata when Vergen is needed. Required parameters are the environment variable names and values (such as the commit date and SHA-1 hash). This technique is necessary when automatic environment injection isn't sufficient for the application's build logic.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cosmic.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  rustPlatform,\n  libcosmicAppHook,\n}:\nrustPlatform.buildRustPackage {\n  # ...\n  env = {\n    VERGEN_GIT_COMMIT_DATE = \"2025-01-01\";\n    VERGEN_GIT_SHA = \"0000000000000000000000000000000000000000\"; # SHA-1 hash of the commit\n  };\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring PHP Build Options in NixOS (New Method)\nDESCRIPTION: Current method of configuring PHP build options by directly setting support flags on the php attribute. This replaces the previous config-based approach with a more straightforward configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nphp.override {\n  embedSupport = true;\n  apxs2Support = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Android Studio with Custom SDK Packages - Nix\nDESCRIPTION: Utilizes the android-studio.withSdk functionality along with androidenv.composeAndroidPackages to include a customizable Android SDK in buildInputs. The configuration sets 'includeNDK' to true, adding the Android NDK for native code compilation. This approach allows fine-grained control over SDK components included in the Nix environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    (android-studio.withSdk\n      (androidenv.composeAndroidPackages {\n        includeNDK = true;\n      }).androidsdk\n    )\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Multi-Node K3s Cluster (First Node) - NixOS Module - Nix\nDESCRIPTION: Configures the first control-plane node of a highly available multi-node K3s cluster on NixOS. The snippet initializes the cluster via the 'clusterInit' flag and sets a shared secret token for joining additional members. Dependencies include network/firewall settings to allow inter-node communication and the NixOS k3s service module. Required inputs are the token value and the assurance that necessary ports are open; outputs are a bootstrapped K3s control-plane ready for further nodes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/USAGE.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.k3s = {\n    enable = true;\n    role = \"server\";\n    token = \"<randomized common secret>\";\n    clusterInit = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Self-contained RStudio Shell Environment - Nix\nDESCRIPTION: This Nix code defines a 'shell.nix' that creates a standalone RStudio development environment without needing changes to global configuration files. It exposes a parameterized setup for 'rstudioWrapper', allowing contributors to quickly spin up a matching development shell. Dependencies are the Nix package manager and access to pkgs.rPackages. The resulting shell enables development with the specified R packages on entry to the shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/r.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\npkgs.rstudioWrapper.override {\n  packages = with pkgs.rPackages; [\n    dplyr\n    ggplot2\n    reshape2\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Primary Root Partition for MBR Disk Using parted (ShellSession)\nDESCRIPTION: Creates a primary root partition starting at 1MB and ending 8GB before the end of the disk. Used for Legacy boot setups on a disk prepared with MBR. The command specifies the 'primary' type and size range for the root file system partition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mkpart primary 1MB -8GB\n```\n\n----------------------------------------\n\nTITLE: Nix REPL Usage Example for Listing Attribute Names - Shell\nDESCRIPTION: This snippet demonstrates how to show inputs and outputs as seen in a Nix REPL session in documentation. Input begins with 'nix-repl>' and is followed by the command and its output. This example lists the attribute names of a Nix set and the output is a list of the attribute names.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nnix-repl> builtins.attrNames { a = 1; b = 2; }\\n[ \\\"a\\\" \\\"b\\\" ]\n```\n\n----------------------------------------\n\nTITLE: Listing Available Urxvt Plugins in Nix REPL\nDESCRIPTION: This shell session demonstrates how to list all available Urxvt plugins using the Nix REPL. It loads the nixpkgs set and maps over the plugins to extract their names.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix repl\n:l <nixpkgs>\nmap (p: p.name) pkgs.rxvt-unicode.plugins\n```\n\n----------------------------------------\n\nTITLE: Configuring vwifi Station (Client) Node - NixOS - Nix\nDESCRIPTION: This configuration snippet allows a node to act as a Wi-Fi station (client), connecting to a virtual AP using a static IP via vwifi simulation. Wireless networking is enabled and forced via mkOverride for reliability in test contexts; the configuration includes SSID, pre-shared key, and authentication protocols (SAE). Dependencies include the NixOS vwifi and wireless modules. Inputs include wireless parameters and MAC assignment. Outputs are a test client connecting to a simulated AP; it assumes server and AP nodes are operational.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-hardware-features.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nstation =\n  { config, ... }:\n  {\n    networking.interfaces.eth1.ipv4.addresses = lib.mkForce [\n      {\n        address = \"192.168.1.3\";\n        prefixLength = 24;\n      }\n    ];\n    networking.wireless = {\n      # No, really, we want it enabled!\n      enable = lib.mkOverride 0 true;\n      interfaces = [ \"wlan0\" ];\n      networks = {\n        \"NixOS Test Wi-Fi Network\" = {\n          psk = \"supersecret\";\n          authProtocols = [ \"SAE\" ];\n        };\n      };\n    };\n    services.vwifi = {\n      module = {\n        enable = true;\n        macPrefix = \"74:F8:F6:00:02\";\n      };\n      client = {\n        enable = true;\n        serverAddress = \"192.168.1.2\";\n      };\n    };\n  };\n```\n\n----------------------------------------\n\nTITLE: Installing Emoji Font for Typing Booster Emoji Picker (Nix)\nDESCRIPTION: The snippet installs the 'noto-fonts-color-emoji' font package required by the emoji-picker included with ibus-engines.typing-booster. It demonstrates how to add a font to the NixOS system configuration using the fonts.packages option. This is necessary for displaying emojis correctly with the booster. Requires access to the Nix package set and must be included in NixOS configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/ibus.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  fonts.packages = with pkgs; [ noto-fonts-color-emoji ];\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent runCommandWith for runCommandCC - Nix\nDESCRIPTION: This code sample provides the canonical translation of `runCommandCC` calls into a `runCommandWith` invocation, demonstrating how environments are handled when compilation is needed (default compiler). Use this form when a build script requires a C compiler or additional flexibility in specifying build attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nrunCommandWith {\n  inherit name derivationArgs;\n} buildCommand\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Activation Script Snippet in NixOS\nDESCRIPTION: This snippet demonstrates how to create a custom activation script in NixOS. It defines a snippet that depends on the 'etc' snippet and can optionally support dry activation. The script simply echoes a message.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/activation-script.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.activationScripts.my-activation-script = {\n    deps = [ \"etc\" ];\n    # supportsDryActivation = true;\n    text = ''\n      echo \"Hallo i bims\"\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Available Packages with nix-env - Shell Command - Shell\nDESCRIPTION: This shell snippet provides a command-line example for listing available Nix packages with their descriptions using the nix-env tool. The command queries all attributes matching '*' and prints package names, versions, and descriptions. Dependencies include the Nix package manager and a configured channel (e.g., nixos). Inputs are wildcard queries and optional filters, while the expected output is a formatted package listing. Limitations are that attribute prefixes (e.g., nixos.) apply to CLI tools only, and package availability depends on the current channel and system configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/declarative-packages.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-env -qaP '*' --description\nnixos.firefox   firefox-23.0   Mozilla Firefox - the browser, reloaded\n...\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image with Nix dockerTools (nix)\nDESCRIPTION: This Nix expression builds a Docker image named 'redis' (tagged 'latest') which runs the 'redis-server' from the redis package. It uses dockerTools.buildImage, copying the redis binary to /bin in the image and setting up a persistent /data directory. The config configures the image to start redis-server, sets its working directory, and mounts /data as a volume. Dependencies: dockerTools, buildEnv, and a valid redis package. Inputs are Nix packages; output is a .tar.gz Docker image.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  buildEnv,\n  redis,\n}:\ndockerTools.buildImage {\n  name = \"redis\";\n  tag = \"latest\";\n\n  copyToRoot = buildEnv {\n    name = \"image-root\";\n    paths = [ redis ];\n    pathsToLink = [ \"/bin\" ];\n  };\n\n  runAsRoot = ''\n    mkdir -p /data\n  '';\n\n  config = {\n    Cmd = [ \"/bin/redis-server\" ];\n    WorkingDir = \"/data\";\n    Volumes = {\n      \"/data\" = { };\n    };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Invoking Prebuilt Cross GCC with nix-build - Shell\nDESCRIPTION: This command utilizes Nix to build a package using a prebuilt cross-compiler for the Raspberry Pi platform, thus avoiding building GCC from source. It fetches a prebuilt cross-compiled GCC and then compiles the 'hello' package for the specified cross-target. Requires a properly configured Nixpkgs channel with cross packages. Input is the Nix expression path ('<nixpkgs>'); output is the derivation for GNU Hello.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build '<nixpkgs>' -A pkgsCross.raspberryPi.hello\n```\n\n----------------------------------------\n\nTITLE: Customizing Qt Wrapper Arguments - Nix\nDESCRIPTION: Shows how to extend the environment of a wrapped Qt application by modifying qtWrapperArgs. This snippet adds a prefix to the PATH variable for the wrapped executable, allowing additional runtime dependencies to be discovered in /path/to/bin. Requires qt6.wrapQtAppsHook in nativeBuildInputs. The augmented qtWrapperArgs are passed to wrapProgram, which is used internally by wrapQtAppsHook during the wrapping phase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/qt.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, qt6 }:\n\nstdenv.mkDerivation {\n  # ...\n  nativeBuildInputs = [ qt6.wrapQtAppsHook ];\n  qtWrapperArgs = [ ''--prefix PATH : /path/to/bin'' ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using JIT-Enabled PostgreSQL with Custom Attributes via Overlay\nDESCRIPTION: Shows how to work with a JIT-enabled PostgreSQL package that has been customized via an overlay. Demonstrates the propagation of attributes when using the withJIT function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> {\n  overlays = [\n    (self: super: {\n      postgresql = super.postgresql.overrideAttrs (_: { pname = \"foobar\"; });\n    })\n  ];\n};\npostgresql.withJIT.pname\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-01 Validation for ACME in NixOS\nDESCRIPTION: This snippet shows how to manually configure HTTP-01 validation for ACME in NixOS. It includes setting up a virtual host for serving ACME challenges and configuring Nginx or Apache to handle the challenges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.acme.acceptTerms = true;\n  security.acme.defaults.email = \"admin+acme@example.com\";\n\n  # /var/lib/acme/.challenges must be writable by the ACME user\n  # and readable by the Nginx user. The easiest way to achieve\n  # this is to add the Nginx user to the ACME group.\n  users.users.nginx.extraGroups = [ \"acme\" ];\n\n  services.nginx = {\n    enable = true;\n    virtualHosts = {\n      \"acmechallenge.example.com\" = {\n        # Catchall vhost, will redirect users to HTTPS for all vhosts\n        serverAliases = [ \"*.example.com\" ];\n        locations.\".well-known/acme-challenge\" = {\n          root = \"/var/lib/acme/.challenges\";\n        };\n        locations.\"/\" = {\n          return = \"301 https://$host$request_uri\";\n        };\n      };\n    };\n  };\n  # Alternative config for Apache\n  users.users.wwwrun.extraGroups = [ \"acme\" ];\n  services.httpd = {\n    enable = true;\n    virtualHosts = {\n      \"acmechallenge.example.com\" = {\n        # Catchall vhost, will redirect users to HTTPS for all vhosts\n        serverAliases = [ \"*.example.com\" ];\n        # /var/lib/acme/.challenges must be writable by the ACME user and readable by the Apache user.\n        # By default, this is the case.\n        documentRoot = \"/var/lib/acme/.challenges\";\n        extraConfig = ''\n          RewriteEngine On\n          RewriteCond %{HTTPS} off\n          RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge [NC]\n          RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [R=301]\n        '';\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing a Custom Agda Library from GitHub - Nix - nix\nDESCRIPTION: Expands on agda.withPackages by packaging an external or custom Agda library directly from a GitHub repository using fetchFromGitHub. The snippet specifies pname, version, and all necessary fetch attributes. This enables rapid integration of external contributions or custom forks for use in Agda sessions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages (p: [\n  (p.mkDerivation {\n    pname = \"your-agda-lib\";\n    version = \"1.0.0\";\n    src = fetchFromGitHub {\n      repo = \"repo\";\n      owner = \"owner\";\n      version = \"...\";\n      rev = \"...\";\n      hash = \"...\";\n    };\n  })\n])\n```\n\n----------------------------------------\n\nTITLE: Disabling nsncd Service in NixOS Configuration - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to disable the nsncd service, reverting to the previous NSS lookups backend instead of the new default Rust-based nsncd. Place this fragment in your NixOS configuration file to override the new release default. The structure expects a Nix attribute set with 'services.nscd.enableNsncd = false;', and requires no additional dependencies. There are no input parameters; the effect is a system-wide config change. Output is a system with nsncd disabled upon rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nscd.enableNsncd = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Custom Network Interface Names with udev Rules in NixOS (nix)\nDESCRIPTION: This snippet implements a udev rule via NixOS configuration to assign the name 'wan' to a network interface with a specific MAC address during early boot (initrd phase). It should be placed under 'boot.initrd.services.udev.rules' to ensure the rule is applied early without race conditions. Dependencies include NixOS with a configured initrd setup and the udev service. The rule expects devices matching the MAC address and kernel name pattern ('eth*'); output is the renamed interface at boot time. Placement outside of initrd is not recommended due to potential races.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/renaming-interfaces.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.initrd.services.udev.rules = ''\n    SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", \\\n    ATTR{address}==\"52:54:00:12:01:01\", KERNEL==\"eth*\", NAME=\"wan\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing Insecure Packages by Predicate - Nix - nix\nDESCRIPTION: Configures `allowInsecurePredicate` as a function to permit all packages whose name matches 'ovftool', regardless of version. This enables flexible policies based on derived package attributes. Relies on builtins and `lib.getName` utilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowInsecurePredicate =\n    pkg:\n    builtins.elem (lib.getName pkg) [\n      \"ovftool\"\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Image Digest and Hash using nix-prefetch-docker - Shell\nDESCRIPTION: This shell snippet illustrates how to use nix-prefetch-docker to discover and extract digest and hash values required for dockerTools.pullImage. The first command fetches the image metadata based on specified arguments, and the second command provides help for all supported arguments. Input parameters include image name, tag, architecture, and OS; output is a set of Nix attribute values suitable for direct copy-paste into a Nix expression. This approach ensures correct hash and digest attribution for reproducible pulls and is essential for maintaining build integrity with Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n$ nix run nixpkgs#nix-prefetch-docker -- --image-name nixos/nix --image-tag 2.19.3 --arch amd64 --os linux\n(some output removed for clarity)\nWriting manifest to image destination\n-> ImageName: nixos/nix\n-> ImageDigest: sha256:498fa2d7f2b5cb3891a4edf20f3a8f8496e70865099ba72540494cd3e2942634\n-> FinalImageName: nixos/nix\n-> FinalImageTag: latest\n-> ImagePath: /nix/store/4mxy9mn6978zkvlc670g5703nijsqc95-docker-image-nixos-nix-latest.tar\n-> ImageHash: 1q6cf2pdrasa34zz0jw7pbs6lvv52rq2aibgxccbwcagwkg2qj1q\n{\n  imageName = \"nixos/nix\";\n  imageDigest = \"sha256:498fa2d7f2b5cb3891a4edf20f3a8f8496e70865099ba72540494cd3e2942634\";\n  hash = \"sha256-OEgs3uRPMb4Y629FJXAWZW9q9LqHS/A/GUqr3K5wzOA=\";\n  finalImageName = \"nixos/nix\";\n  finalImageTag = \"latest\";\n}\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ nix run nixpkgs#nix-prefetch-docker -- --help\n(output removed for clarity)\n```\n\n----------------------------------------\n\nTITLE: Declarative Package Management with buildEnv - Nix - nix\nDESCRIPTION: Defines a custom package group 'myPackages' in `packageOverrides` as a derivation of essential utilities via `pkgs.buildEnv`. The `paths` array lists all included packages and this configuration is invoked from `~/.config/nixpkgs/config.nix`. Inputs are declarative; output is a single environment package for user installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    pkgs: with pkgs; {\n      myPackages = pkgs.buildEnv {\n        name = \"my-packages\";\n        paths = [\n          aspell\n          bc\n          coreutils\n          gdb\n          ffmpeg\n          nix\n          emscripten\n          jq\n          nox\n          silver-searcher\n        ];\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Suwayomi-Server Configuration in NixOS\nDESCRIPTION: Demonstrates how to configure additional Suwayomi-Server options not directly available in the module, such as auto-downloading new chapters and setting custom extension repositories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/suwayomi-server.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.suwayomi-server = {\n    enable = true;\n\n    openFirewall = true;\n\n    settings = {\n      server = {\n        port = 4567;\n        autoDownloadNewChapters = false;\n        maxSourcesInParallel = 6;\n        extensionRepos = [\n          \"https://raw.githubusercontent.com/MY_ACCOUNT/MY_REPO/repo/index.min.json\"\n        ];\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using sphinxHook for Documentation Generation\nDESCRIPTION: Shows how to use sphinxHook to build documentation using Sphinx. This hook automatically finds and builds documentation, placing it in the specified output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_41\n\nLANGUAGE: nix\nCODE:\n```\n{\n  outputs = [\n    \"out\"\n    \"doc\"\n  ];\n\n  nativeBuildInputs = [\n    sphinxHook\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Netbird Service Configuration in NixOS\nDESCRIPTION: The minimal configuration required to enable the Netbird client daemon, which sets up a service listening on port 51820 associated with the wt0 interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/netbird.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.netbird.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Pantheon Desktop Environment in NixOS\nDESCRIPTION: Configuration setting to enable the Pantheon desktop environment through xserver service configuration in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1903.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nservices.xserver.desktopManager.pantheon.enable\n```\n\n----------------------------------------\n\nTITLE: Example of Propagated Dependencies in Nix\nDESCRIPTION: A practical example demonstrating how propagated dependencies work in Nix. It shows how a dependency (hello) propagated by one package (bar) becomes implicitly available to downstream packages (foo) without being directly specified.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\nlet\n  bar = stdenv.mkDerivation {\n    name = \"bar\";\n    dontUnpack = true;\n    # `hello` is also made available to dependents, such as `foo`\n    propagatedBuildInputs = [ hello ];\n    postInstall = \"mkdir $out\";\n  };\n  foo = stdenv.mkDerivation {\n    name = \"foo\";\n    dontUnpack = true;\n    # `bar` is a direct dependency, which implicitly includes the propagated `hello`\n    buildInputs = [ bar ];\n    # The `hello` binary is available!\n    postInstall = \"hello > $out\";\n  };\nin\nfoo\n```\n\n----------------------------------------\n\nTITLE: Rebooting into the Installed NixOS System\nDESCRIPTION: Command to reboot the system after successful installation to start using the newly installed NixOS system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_22\n\nLANGUAGE: ShellSession\nCODE:\n```\n# reboot\n```\n\n----------------------------------------\n\nTITLE: Configuring mitmCache using pkg Input in Gradle/Nix - Nix Expressions\nDESCRIPTION: This snippet shows how to configure gradle.fetchDeps to take an explicit pkg argument instead of pname, enabling attribute overrides in package-specific update scripts. This is useful when the package cannot be identified only by pname, such as when overriding attributes of a derivation. Requirements: existing package argument (pdftk) and a deps.json file. The output is a mitmCache derivation bound to a specifically-configured package input.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gradle.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  gradle,\n  # ...\n  pdftk,\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  # ...\n  mitmCache = gradle.fetchDeps {\n    pkg = pdftk;\n    data = ./deps.json;\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Building Idris Package from Default.nix\nDESCRIPTION: Command to build an Idris package specified in a default.nix file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A yaml\n```\n\n----------------------------------------\n\nTITLE: Customizing Emacs Build Features - GTK Version and Post-Install Hook - Nix\nDESCRIPTION: This advanced Nix expression shows how to override Emacs' build options to use GTK3 instead of GTK2 and remove the emacs.desktop file post-installation, which is useful when only emacsclient is needed. The 'override' and 'overrideAttrs' functions are used to tweak package options and the build process. Prerequisites are Nix, nixpkgs, and knowledge of overriding packages. Output is a modified Emacs derivation, ready to include in a user or system environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs ? import <nixpkgs> {} }:\nlet\n  myEmacs = (pkgs.emacs.override {\n    # Use gtk3 instead of the default gtk2\n    withGTK3 = true;\n    withGTK2 = false;\n  }).overrideAttrs (attrs: {\n    # I don't want emacs.desktop file because I only use\n    # emacsclient.\n    postInstall = (attrs.postInstall or \"\") + ''\n      rm $out/share/applications/emacs.desktop\n    '';\n  });\nin [ /* ... */ ]\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Dependencies with override in callPackage (Nix Language)\nDESCRIPTION: Shows how to override dependencies of a package in place, using callPackage with custom attributes for dependencies. Specifically, mydep is overridden before being passed into mypkg. Relies on pkgs.callPackage and the presence of a compatible ./mypkg.nix file. Input is an attribute set mapping dependency overrides, output is a derivation with modified dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mypkg = pkgs.callPackage ./mypkg.nix {\n    mydep = pkgs.mydep.override {\n      # ...\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Full NixOS Manual in ShellSession\nDESCRIPTION: This code snippet demonstrates how to build the complete NixOS manual before committing changes. It uses nix-build with specific arguments to generate the manual, and provides information on where to find the resulting HTML output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-documentation.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-build nixos/release.nix -A manual.x86_64-linux\n```\n\n----------------------------------------\n\nTITLE: Executing Default Build Phases in Nix Shell\nDESCRIPTION: Shows how to run all build phases in the order they would be executed in an actual build while inside an interactive nix-shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ngenericBuild\n```\n\n----------------------------------------\n\nTITLE: Auto-Generating Nix Expressions from CPAN via nix-generate-from-cpan - ShellSession and Nix\nDESCRIPTION: This example shows a shell invocation of nix-generate-from-cpan followed by its generated Nix expression for the XMLSimple Perl module. Dependencies: Nix, nix-generate-from-cpan. Inputs: module name (XML::Simple). Output: a buildPerlPackage expression using the discovered source and dependencies. The generated code includes propagatedBuildInputs and meta attributes, ready for direct inclusion in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-generate-from-cpan XML::Simple\n  XMLSimple = buildPerlPackage rec {\n    pname = \"XML-Simple\";\n    version = \"2.22\";\n    src = fetchurl {\n      url = \"mirror://cpan/authors/id/G/GR/GRANTM/XML-Simple-2.22.tar.gz\";\n      hash = \"sha256-uUUO8i6pZErl1q2ghtxDAPoQW+BQogMOvU79KMGY60k=\";\n    };\n    propagatedBuildInputs = [ XMLNamespaceSupport XMLSAX XMLSAXExpat ];\n    meta = {\n      description = \"API for simple XML files\";\n      license = with lib.licenses; [ artistic1 gpl1Plus ];\n    };\n  };\n```\n\n----------------------------------------\n\nTITLE: Basic NixOS Option Definition\nDESCRIPTION: Simple example showing how to enable a service using basic option definition syntax.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = {\n    services.httpd.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Integer Type with an Additional Check (Nix)\nDESCRIPTION: Demonstrates how to define an option 'byte', extending the integer type to restrict values between 0 and 255 using 'addCheck'. Requires access to 'mkOption', 'types', and a predicate function. The option expects an integer within the specified range. Useful for custom range validation, but may require explicit error handling for out-of-bounds values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  byte = mkOption {\n    description = \"An integer between 0 and 255.\";\n    type = types.addCheck types.int (x: x >= 0 && x <= 255);\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Nix Expressions with bower2nix\nDESCRIPTION: Output of bower2nix command, which generates a Nix expression for fetching and building Bower packages based on the bower.json file. It uses fetchbower and buildEnv functions to create a Bower environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/bower.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchbower, buildEnv }:\nbuildEnv {\n  name = \"bower-env\";\n  ignoreCollisions = true;\n  paths = [\n    (fetchbower \"angular\" \"1.5.3\" \"~1.5.0\" \"1749xb0firxdra4rzadm4q9x90v6pzkbd7xmcyjk6qfza09ykk9y\")\n    (fetchbower \"bootstrap\" \"3.3.6\" \"~3.3.6\" \"1vvqlpbfcy0k5pncfjaiskj3y6scwifxygfqnw393sjfxiviwmbv\")\n    (fetchbower \"jquery\" \"2.2.2\" \"1.9.1 - 2\" \"10sp5h98sqwk90y4k6hbdviwqzvzwqf47r3r51pakch5ii2y7js1\")\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Example of NixOS Option Error Message (Nonexistent Option) - Plain Text - plain\nDESCRIPTION: Demonstrates the error message produced by nixos-rebuild when a non-existent option is defined in the configuration file. Provides context for how errors are reported in NixOS. Output is plain text and should not be included in configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_3\n\nLANGUAGE: plain\nCODE:\n```\nThe option `services.httpd.enable' defined in `/etc/nixos/configuration.nix' does not exist.\n```\n\n----------------------------------------\n\nTITLE: Declarative Environment with buildEnv and pathsToLink - Nix - nix\nDESCRIPTION: A more refined `myPackages` using `buildEnv`, specifying `pathsToLink` to only symlink specific subdirectories such as `/share` and `/bin`. This minimizes clutter in the user's profile and is tailored for clarity, especially on MacOS by potentially adding `/Applications`. Inputs are as above, with narrower links; output is a tidier user environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    pkgs: with pkgs; {\n      myPackages = pkgs.buildEnv {\n        name = \"my-packages\";\n        paths = [\n          aspell\n          bc\n          coreutils\n          gdb\n          ffmpeg\n          nix\n          emscripten\n          jq\n          nox\n          silver-searcher\n        ];\n        pathsToLink = [\n          \"/share\"\n          \"/bin\"\n        ];\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CSRF Trusted Origins for Seafile in NixOS\nDESCRIPTION: Configures the CSRF trusted origins for Seafile to allow specific origin addresses to log in after the CSRF protection update.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nservices.seafile.seahubExtraConf = ''CSRF_TRUSTED_ORIGINS = [\"https://example.com\"]'';\n```\n\n----------------------------------------\n\nTITLE: Performing String Replacement Using substitute in Nix\nDESCRIPTION: Shows the Nix functional equivalent of the Bash substitute command: invoking the substitute function and supplying a source file and a list of string substitutions. Dependencies include the substitute function and any replacement paths. Inputs are defined by the src and substitutions attributes; output is the result of applying all replacements to the source file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ substitute, foopkg }:\nsubstitute {\n  src = ./sourcefile.txt;\n  substitutions = [\n    \"--replace\"\n    \"@foo@\"\n    \"${foopkg}/bin/foo\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Values and Substitutions in HOCON Files via Nix\nDESCRIPTION: Illustrates advanced manipulation in HOCON-formatted settings using the pkgs.formats HOCON library from Nix. The code shows how to include external lists and then append new items or substitutions using mkAppend and mkSubstitution. Dependencies: pkgs.formats.hocon and Nixpkgs. Inputs are attribute sets with keys to be appended or substituted. Output is an attrset for HOCON generation, suitable for configuration files requiring reference and list update patterns.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.hocon { };\n  hocon_file = pkgs.writeText \"to_include.hocon\" ''\n    a = [ 1 ];\n    b = [ 2 ];\n  '';\nin {\n  _includes = [\n    (format.lib.mkInclude hocon_file)\n  ];\n\n  c = 3;\n  a = format.lib.mkAppend 3;\n  b = format.lib.mkAppend (format.lib.mkSubstitution \"c\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Android Studio Full SDK as Build Input - Nix\nDESCRIPTION: Declares the android-studio-full attribute as a build input, providing a comprehensive Android SDK environment for use in Nix derivations. No extra parameters are required as this attribute includes system images and all necessary tools for typical Android development. The 'buildInputs' attribute determines the included packages for the derivation's environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [ android-studio-full ];\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning Nixpkgs Repository in Bash\nDESCRIPTION: Commands to clone the Nixpkgs repository and navigate to the project directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/NixOS/nixpkgs\n$ cd nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Configuring Mediatomb Package in NixOS with Nix - nix\nDESCRIPTION: This snippet shows how to specify the legacy 'mediatomb' package for the Mediatomb service using the Nix expression language. You must set the 'services.mediatomb.package' option to 'pkgs.mediatomb' in your system configuration ('configuration.nix'). Requires a NixOS environment with access to the relevant packages. Expects inputs to be written in Nix language; applies the chosen package only for Mediatomb service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.mediatomb.package = pkgs.mediatomb;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a VM Image Test Script for Ubuntu 20.04 with vmTools.makeImageTestScript (Nix)\nDESCRIPTION: This code shows how to generate a test script for an Ubuntu 20.04 VM using the `makeImageTestScript` function from `vmTools`. The required dependency is the Ubuntu 20.04 disk image from `diskImages.ubuntu2004x86_64`. The output is a derivation representing a launchable, interactive VM script based on the supplied image.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }: with pkgs; with vmTools; makeImageTestScript diskImages.ubuntu2004x86_64\n```\n\n----------------------------------------\n\nTITLE: Allowing Ranges of TCP Ports via Firewall - NixOS - Nix\nDESCRIPTION: This snippet shows how to define ranges of permissible incoming TCP ports using the \\'networking.firewall.allowedTCPPortRanges\\' attribute. Each range is represented by an attribute set specifying 'from' and 'to' port numbers. Intended for advanced use cases where sequential ports need to be accessible, such as clustered applications, this should be incorporated into your /etc/nixos/configuration.nix file. After activation, all specified port ranges between 'from' and 'to' (inclusive) will be open on the firewall. No additional dependencies beyond base NixOS are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/firewall.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.allowedTCPPortRanges = [\n    { from = 4000; to = 4007; }\n    { from = 8000; to = 8010; }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Abstracting Common Virtual Host Configuration with Let and Attribute Set Merge in Nix\nDESCRIPTION: This snippet demonstrates abstraction by defining shared options in a let-bound attribute set (commonConfig), and using the // operator to merge these common attributes with specific documentRoot values per host. The pattern reduces duplication and enhances maintainability in Nix configurations. Prerequisites are understanding of Nix attribute set merging; no external dependencies are necessary. Key parameters include commonConfig and the per-host documentRoot. The input is a set of hostnames, and output is a virtualHosts attribute set for NixOS. Constraints: the merged attribute sets must not have conflicting keys.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/abstractions.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  commonConfig =\n    { adminAddr = \"alice@example.org\";\n      forceSSL = true;\n      enableACME = true;\n    };\nin\n{\n  services.httpd.virtualHosts =\n    { \"blog.example.org\" = (commonConfig // { documentRoot = \"/webroot/blog.example.org\"; });\n      \"wiki.example.org\" = (commonConfig // { documentRoot = \"/webroot/wiki.example.org\"; });\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Custom Oh My Zsh Environment with Nix Packages - Nix Programming Language\nDESCRIPTION: This example demonstrates using a list of Nix packages to assemble a custom $ZSH_CUSTOM environment for Oh My Zsh. The customPkgs array assigns one or more package derivations (e.g., pkgs.nix-zsh-completions), and the module generates an immutable store path for Zsh customizations. Input is a list of Nix package expressions; the output is a merged path used by Oh My Zsh. Limitation: Cannot be used simultaneously with the 'custom' attribute, as noted in documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/zsh/oh-my-zsh.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  programs.zsh.ohMyZsh.customPkgs = [\n    pkgs.nix-zsh-completions\n    # and even more...\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Cue Validator Script in Nix\nDESCRIPTION: This snippet demonstrates how to use the writeCueValidator function from Nixpkgs to create a validation script based on a Cuelang schema. It defines a simple schema with a single string field and creates a validator for it.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuelang.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\npkgs.writeCueValidator (pkgs.writeText \"schema.cue\" ''\n  #Def1: {\n    field1: string\n  }\n'') { document = \"#Def1\"; }\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite3 Flutter Plugin Build with CMake - CMake\nDESCRIPTION: This CMake script sets up the build environment for the sqlite3_flutter_libs plugin by declaring project metadata, finding and linking against the sqlite3 dependency, and configuring compilation features, optimizations, visibility, and linker targets. It depends on CMake version 3.14 or higher and requires pkg-config for sqlite3 detection. Inputs include plugin and project names, and configurations are set for both Debug and Release builds. The output is a shared library linked with Flutter, suitable for integration in a Flutter project using native code. Limitations include a fixed plugin name, a requirement for a compatible development environment, and no cross-platform logic.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/compilers/dart/package-source-builders/sqlite3_flutter_libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.14)\nset(PROJECT_NAME \"sqlite3_flutter_libs\")\nproject(${PROJECT_NAME} LANGUAGES C CXX)\n\n# This value is used when generating builds using this plugin, so it must\n# not be changed\nset(PLUGIN_NAME \"sqlite3_flutter_libs_plugin\")\n\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(SQLITE REQUIRED sqlite3)\n\nadd_library(${PLUGIN_NAME} SHARED\n  \"sqlite3_flutter_libs_plugin.cc\"\n)\n\ntarget_compile_features(${PLUGIN_NAME} PUBLIC cxx_std_14)\ntarget_compile_options(${PLUGIN_NAME} PRIVATE \"$<$<NOT:$<CONFIG:Debug>>:-O3>\")\n\nset_target_properties(${PLUGIN_NAME} PROPERTIES\n  CXX_VISIBILITY_PRESET hidden)\ntarget_compile_definitions(${PLUGIN_NAME} PRIVATE FLUTTER_PLUGIN_IMPL)\ntarget_include_directories(${PLUGIN_NAME} INTERFACE\n  \"${CMAKE_CURRENT_SOURCE_DIR}/include\")\ntarget_link_libraries(${PLUGIN_NAME} PRIVATE flutter)\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Dart Development Shell with Pubspec and Package Config - Bash\nDESCRIPTION: Provides shell commands for copying the pubspec.lock and package_config.json to the source directory, allowing Dart to resolve dependencies provided by Nix instead of via pub get. This setup is necessary for interactive development in a nix-shell environment. Requires $pubspecLockFilePath and $packageConfig environment variables set to the lock and config files. Overwrites pubspec.lock and .dart_tool/package_config.json in the working directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dart.section.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncp --no-preserve=all \"$pubspecLockFilePath\" pubspec.lock\nmkdir -p .dart_tool && cp --no-preserve=all \"$packageConfig\" .dart_tool/package_config.json\n\n```\n\n----------------------------------------\n\nTITLE: Regenerating Nextcloud Package Set - Shell\nDESCRIPTION: This shell snippet demonstrates how to regenerate the nextcloudPackages set by executing the generate.sh script. Running this script is necessary before committing changes to ensure the package set is up to date. The script must be executable and available in the current directory; its output updates the relevant Nix expressions or JSON files. Expected input: none; output: updated files in the repository. Ensure all prerequisites defined in the script are satisfied.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/nextcloud/packages/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./generate.sh\n```\n\n----------------------------------------\n\nTITLE: Overriding Specific CUDA Components in a Package Set - Nix\nDESCRIPTION: This Nix snippet demonstrates advanced customization of the CUDA package set by overriding a specific component (e.g., 'cudnn') with a custom version before passing it as a parameter. It uses the 'overrideScope' method to replace 'cudnn' in the 'cudaPackages_11_5' set with 'cudnn_8_3', ensuring a consistent package environment when building dependent packages. Dependencies include access to the Nixpkgs 'cudaPackages' sets and the 'overrideScope' function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mypkg =\n    let\n      cudaPackages = cudaPackages_11_5.overrideScope (\n        final: prev: {\n          cudnn = prev.cudnn_8_3;\n        }\n      );\n    in\n    callPackage { inherit cudaPackages; };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Sections via Markdown Directives - Markdown\nDESCRIPTION: This snippet demonstrates how to include external Markdown section files (nixos-state.section.md, systemd-state.section.md, zfs-state.section.md) into the current documentation using a syntax block with an 'include' directive. This approach organizes related documentation by aggregating content from multiple sources, facilitating modular and maintainable documentation. No additional dependencies are required beyond a Markdown processor or static site generator that supports the '{=include=}' syntax; inputs are relative paths to documentation section files, and output is rendered Markdown content with the included files' contents inlined.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/system-state.chapter.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} sections\\nnixos-state.section.md\\nsystemd-state.section.md\\nzfs-state.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying GCC Prefix with makeFlags in Nixpkgs - Nix\nDESCRIPTION: This Nix expression shows how to set the GCC compiler explicitly for patched build systems that expect 'cc' rather than a prefixed tool. It overrides the 'CC' make flag with the correct Nixpkgs environment variable to ensure cross-building works. This approach avoids build failures due to unprefixed binary assumptions. Requires access to 'stdenv.cc.targetPrefix' in the derivation's scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  makeFlags = [ \"CC=${stdenv.cc.targetPrefix}cc\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image with runAsRoot Option using Nix dockerTools (nix)\nDESCRIPTION: This Nix expression builds a Docker image named 'hello' that runs the 'hello' executable, leveraging the runAsRoot option to create the /data directory and a file named my-file with custom content as root during the build. Relies on dockerTools and buildEnv to collect the hello package and link its binary to /bin. Inputs are dockerTools, buildEnv, hello; output is a Docker image tarball that, when executed, starts /bin/hello in /data.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  buildEnv,\n  hello,\n}:\ndockerTools.buildImage {\n  name = \"hello\";\n  tag = \"latest\";\n\n  copyToRoot = buildEnv {\n    name = \"image-root\";\n    paths = [ hello ];\n    pathsToLink = [ \"/bin\" ];\n  };\n\n  runAsRoot = ''\n    mkdir -p /data\n    echo \"some content\" > my-file\n  '';\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n    WorkingDir = \"/data\";\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Scripts Directory for Oh My Zsh - Nix Programming Language\nDESCRIPTION: This Nix snippet configures a custom scripts directory for Oh My Zsh by setting the 'custom' attribute to a user path. The value assigned (~/path/to/custom/scripts) is made available via the $ZSH_CUSTOM environment variable, enabling automatic loading of additional themes, plugins, or scripts. Input is a filesystem path string; output modifies Zsh environment setup. Prerequisite: the path must exist and be readable at shell initialization.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/zsh/oh-my-zsh.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  programs.zsh.ohMyZsh.custom = \"~/path/to/custom/scripts\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling IBus Typing Booster Engine in NixOS Configuration (Nix)\nDESCRIPTION: This snippet demonstrates how to enable the ibus input method on NixOS and activate the typing-booster engine. It uses Nix module configuration with the required parameters: setting i18n.inputMethod.enable to true, specifying the type as 'ibus', and including 'typing-booster' in the list of engines. This configuration must be placed in the NixOS system configuration and requires the package set (pkgs) to provide ibus-engines.typing-booster. Inputs and outputs are standard NixOS options; no additional dependencies beyond NixOS’s package set are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/ibus.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"ibus\";\n    ibus.engines = with pkgs.ibus-engines; [ typing-booster ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Bad Platforms Configuration Example in Nix\nDESCRIPTION: Example showing how to exclude platforms where a package cannot be built, specifically for packages requiring dynamic linking.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/meta.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  meta.platforms = lib.platforms.all;\n  meta.badPlatforms = [ lib.systems.inspect.platformPatterns.isStatic ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Repository Permissions for Apache User - Command Line (Shell)\nDESCRIPTION: This shell command recursively assigns ownership of the repository parent directory to the wwwrun user and group, ensuring that the Apache HTTP server can access SVN repositories for serving. Prerequisite: Administrative privileges to execute chown. Key parameter: REPO_PARENT specifies the actual path to the repository parent folder.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ chown -R wwwrun:wwwrun REPO_PARENT\n```\n\n----------------------------------------\n\nTITLE: Defining Settings and Configuration Generation for a Service with pkgs.formats.json in Nix\nDESCRIPTION: This Nix snippet demonstrates how to write a module for a service (foo) that uses a JSON configuration file, leveraging pkgs.formats.json for type-safe option definitions and automatic config file generation. Dependencies include pkgs.formats.json for format definitions, and core Nixpkgs module utilities like mkEnableOption and mkOption for configuration schema. The snippet sets up default values, shows how to correctly use merging/defaulting behaviors, and explains integration of the generated config with the system via environment.etc. Expected input is the module argument set; output includes correct options, generated config files, and user assignments, with the limitation that secrets should not be stored this way.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{ options, config, lib, pkgs, ... }:\nlet\n  cfg = config.services.foo;\n  # Define the settings format used for this program\n  settingsFormat = pkgs.formats.json {};\nin {\n\n  options.services.foo = {\n    enable = lib.mkEnableOption \"foo service\";\n\n    settings = lib.mkOption {\n      # Setting this type allows for correct merging behavior\n      type = settingsFormat.type;\n      default = {};\n      description = ''\n        Configuration for foo, see\n        <link xlink:href=\"https://example.com/docs/foo\"/>\n        for supported settings.\n      '';\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    # We can assign some default settings here to make the service work by just\n    # enabling it. We use `mkDefault` for values that can be changed without\n    # problems\n    services.foo.settings = {\n      # Fails at runtime without any value set\n      log_level = lib.mkDefault \"WARN\";\n\n      # We assume systemd's `StateDirectory` is used, so we require this value,\n      # therefore no mkDefault\n      data_path = \"/var/lib/foo\";\n\n      # Since we use this to create a user we need to know the default value at\n      # eval time\n      user = lib.mkDefault \"foo\";\n    };\n\n    environment.etc.\"foo.json\".source =\n      # The formats generator function takes a filename and the Nix value\n      # representing the format value and produces a filepath with that value\n      # rendered in the format\n      settingsFormat.generate \"foo-config.json\" cfg.settings;\n\n    # We know that the `user` attribute exists because we set a default value\n    # for it above, allowing us to use it without worries here\n    users.users.${cfg.settings.user} = { isSystemUser = true; };\n\n    # ...\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Pipewire Configuration Using JSON Drop-In - JSON\nDESCRIPTION: This JSON snippet illustrates how to override or extend Pipewire configuration by creating a drop-in configuration file matching the NixOS module semantics. It includes various top-level keys such as \\\"context.properties\\\", \\\"context.modules\\\", and others, with illustrative configurations for each. Dependencies include the Pipewire daemon and an existing /etc/pipewire/ drop-in directory. Key parameters are custom property settings, module loading, object factories, and ALSA rules. The input is the customized JSON file placed in /etc/pipewire/<config file name>.d/ and the output is adjustment of Pipewire's behavior on service reload. The snippet is constrained to the available settings and may require further consultation with upstream documentation for advanced use cases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_31\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"context.properties\\\": {\\n    \\\"your.property.name\\\": \\\"your.property.value\\\"\\n  },\\n  \\\"context.modules\\\": [\\n    { \\\"name\\\": \\\"libpipewire-module-my-cool-thing\\\" }\\n  ],\\n  \\\"context.objects\\\": [\\n    { \\\"factory\\\": { ... } }\\n  ],\\n  \\\"alsa.rules\\\": [\\n    { \\\"matches: { ... }, \\\"actions\\\": { ... } }\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Haskell Updates PR\nDESCRIPTION: Command to execute the script for merging current haskell-updates PR and creating a new one.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/merge-and-open-pr.sh PR_NUM_OF_CURRENT_HASKELL_UPDATES_PR\n```\n\n----------------------------------------\n\nTITLE: Listing TeX Live Collections Interactive Shell - Nix - ShellSession\nDESCRIPTION: Demonstrates using nix repl with tab completion to discover TeX Live collections. This shell session helps users find available collections for inclusion in custom environments. Prerequisites: Nix is installed and <nixpkgs> channel is present.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix repl\nnix-repl> :l <nixpkgs>\nnix-repl> texlive.collection-[TAB]\n```\n\n----------------------------------------\n\nTITLE: Running Menuconfig for Kernel Configuration - Nix Build Utilities - ShellSession\nDESCRIPTION: This snippet shows how to install menuconfig dependencies (ncurses and pkg-config) in your Nix shell environment and then run make menuconfig for a specified architecture. These commands customize kernel configuration interactively and require proper 'ARCH' environment variable assignment. Intended for incremental kernel configuration updates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/README.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p ncurses pkg-config\n$ make menuconfig ARCH=arch\n```\n\n----------------------------------------\n\nTITLE: Shell Argument using JSON Platform for Cross-Compilation - Shell Command - Shell\nDESCRIPTION: Indicates a shell argument referencing a generated JSON configuration, which is passed to rustc/cargo as a custom target. The file's path contains platform-specific settings as per the Nix cross-compilation configuration. This is used for advanced cross builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n--target /nix/store/asdfasdfsadf-thumb-crazy.json # contains {\"foo\":\"\",\"bar\":\"\"}\n```\n\n----------------------------------------\n\nTITLE: Invoking Perl Scripts Directly From Shell - ShellSession\nDESCRIPTION: This ShellSession snippet demonstrates how to directly invoke the Perl interpreter to run a script, which circumvents shebang path issues. Requires Perl to be accessible in the current environment. Accepts the path to the script as a parameter (here, './myscript.pl'). Outputs the result of script execution. Useful when shebang lines are incompatible with the environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ perl ./myscript.pl\n```\n\n----------------------------------------\n\nTITLE: Demonstrating types.anything Option Merge in Nix\nDESCRIPTION: This snippet showcases how two attribute sets of type types.anything are merged in Nix module definitions. The code provides example values with attributes (str, pkg, fun) using lib.mkDefault and lib.mkIf for value selection and precedence, as well as function assignment with mkForce. Dependencies include the Nixpkgs lib and pkgs attributes, and the context assumes being used within a module definition where option merging applies. The merged result demonstrates value overriding and recursive merging, resulting in combined attributes and prioritizing mkIf/mkForce as appropriate. Inputs are attribute sets and outputs are their merged result as injected by the module system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  str = lib.mkDefault \"foo\";\n  pkg.hello = pkgs.hello;\n  fun.fun = x: x + 1;\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  str = lib.mkIf true \"bar\";\n  pkg.gcc = pkgs.gcc;\n  fun.fun = lib.mkForce (x: x + 2);\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  str = \"bar\";\n  pkg.gcc = pkgs.gcc;\n  pkg.hello = pkgs.hello;\n  fun.fun = x: x + 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nix Shell in Bash\nDESCRIPTION: This snippet provides instructions for running regression tests using a Bash shell within the Nix development environment. The steps involve navigating to the test directory, initiating the Nix shell (which ensures all dependencies are loaded), and executing the run.sh script within that environment. The approach ensures consistent test results across different systems as dependencies are managed declaratively by Nix. Outputs and errors from the test script can be inspected by contributors as part of their development workflow.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/scripts/auto-rebase/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd test\\n$ nix-shell\\nnix-shell> ./run.sh\n```\n\n----------------------------------------\n\nTITLE: Mounting the Target File System for NixOS Installation\nDESCRIPTION: Command to mount the target file system where NixOS will be installed to the /mnt directory. This is the first step in the installation process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_14\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mount /dev/disk/by-label/nixos /mnt\n```\n\n----------------------------------------\n\nTITLE: Querying Emacs Packages in nixpkgs - Shell Commands - Shell\nDESCRIPTION: These shell commands query the available Emacs packages from each package set (elpa, melpa, melpaStable, org) in the nixpkgs channel using nix-env. Output lists all package attributes under each set. Requires Nix installed and nixpkgs accessible on the system. Adjust attribute path to search for custom sets or overlays as needed. Outputs a formatted list for each package group.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.elpaPackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.melpaPackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.melpaStablePackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.orgPackages\n\n```\n\n----------------------------------------\n\nTITLE: Filtering Journal Entries for PostgreSQL Service in NixOS\nDESCRIPTION: This command filters the journal to show only entries related to the PostgreSQL service. It demonstrates how to use journalctl to focus on logs from a specific system service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/logging.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ journalctl -u postgresql.service\n-- Logs begin at Mon, 2013-01-07 13:28:01 CET, end at Tue, 2013-01-08 01:09:57 CET. --\n...\nJan 07 15:44:14 hagbard postgres[2681]: [2-1] LOG:  database system is shut down\n-- Reboot --\nJan 07 15:45:10 hagbard postgres[2532]: [1-1] LOG:  database system was shut down at 2013-01-07 15:44:14 CET\nJan 07 15:45:13 hagbard postgres[2500]: [1-1] LOG:  database system is ready to accept connections\n```\n\n----------------------------------------\n\nTITLE: Setting Install Name Using install_name_tool Post-Fixup in Nix Derivation (Nix)\nDESCRIPTION: This snippet shows how to modify the install name of a produced dynamic library after building by using install_name_tool in the postFixup phase of a Nix mkDerivation. The script runs only on Darwin and leverages stdenv.cc.targetPrefix for the correct tool invocation. The chunk in postFixup updates the 'id' (install_name) of the produced dylib, ensuring runtime linkage uses the expected path. Needed dependencies include mkDerivation, stdenv.cc, and having the dynamic library present at postFixup time. Inputs are derivation context, output is a patched dylib with a new install_name.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  # ...\n  postFixup = ''\n    # `-id <install_name>` takes the install name. The last parameter is the path to the library.\n    ${stdenv.cc.targetPrefix}install_name_tool -id \"$out/lib/libfoo.dylib\" \"$out/lib/libfoo.dylib\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding fakeNss attributes to add custom user and group entries in Nix\nDESCRIPTION: This example shows how to use the override method with fakeNss to add custom entries to /etc/passwd and /etc/group files, creating a new user and group with ID 9001.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/fakenss.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ fakeNss }:\nfakeNss.override {\n  extraPasswdLines = [ \"newuser:x:9001:9001:new user:/var/empty:/bin/sh\" ];\n  extraGroupLines = [ \"newuser:x:9001:\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Outputs in Nix Derivation\nDESCRIPTION: This snippet shows how to define multiple outputs for a Nix derivation. It specifies four outputs: bin, dev, out, and doc. Each output will have a corresponding environment variable passed to the builder containing the path in the Nix store for that output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/multiple-output.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  outputs = [\n    \"bin\"\n    \"dev\"\n    \"out\"\n    \"doc\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pnpm install flags in Nix\nDESCRIPTION: Example of how to add additional flags to pnpm install command when using pnpm in a Nix derivation, such as the --shamefully-hoist option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pnpm,\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"foo\";\n  version = \"0-unstable-1980-01-01\";\n\n  src = {\n    # ...\n  };\n\n  pnpmInstallFlags = [ \"--shamefully-hoist\" ];\n\n  pnpmDeps = pnpm.fetchDeps {\n    inherit (finalAttrs) pnpmInstallFlags;\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Media Keys with actkbd in NixOS\nDESCRIPTION: NixOS configuration snippet for handling media key bindings using actkbd service as a replacement for the removed sound.mediaKeys option. Sets up volume control and mic mute functionality.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nservices.actkbd = let\n  volumeStep = \"1%\";\nin {\n  enable = true;\n  bindings = [\n    # \"Mute\" media key\n    { keys = [ 113 ]; events = [ \"key\" ];       command = \"${alsa-utils}/bin/amixer -q set Master toggle\"; }\n\n    # \"Lower Volume\" media key\n    { keys = [ 114 ]; events = [ \"key\" \"rep\" ]; command = \"${alsa-utils}/bin/amixer -q set Master ${volumeStep}- unmute\"; }\n\n    # \"Raise Volume\" media key\n    { keys = [ 115 ]; events = [ \"key\" \"rep\" ]; command = \"${alsa-utils}/bin/amixer -q set Master ${volumeStep}+ unmute\"; }\n\n    # \"Mic Mute\" media key\n    { keys = [ 190 ]; events = [ \"key\" ];       command = \"${alsa-utils}/bin/amixer -q set Capture toggle\"; }\n  ];\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Builders in nix.conf - Nix - Configuration Snippet\nDESCRIPTION: Configuration block for the nix.conf file to add a Linux remote builder accessible via SSH, specifying the transport, architecture, SSH key, and job limit. Includes detailed comments for customization. Also enables use of binary substitutes to save disk space. Proper configuration here is essential for Nix to delegate builds to the VM. Requires the proper SSH key and matching architecture.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n# - Replace ${ARCH} with either aarch64 or x86_64 to match your host machine\n# - Replace ${MAX_JOBS} with the maximum number of builds (pick 4 if you're not sure)\nbuilders = ssh-ng://builder@linux-builder ${ARCH}-linux /etc/nix/builder_ed25519 ${MAX_JOBS} - - - c3NoLWVkMjU1MTkgQUFBQUMzTnphQzFsWkRJMU5URTVBQUFBSUpCV2N4Yi9CbGFxdDFhdU90RStGOFFVV3JVb3RpQzVxQkorVXVFV2RWQ2Igcm9vdEBuaXhvcwo=\n\n# Not strictly necessary, but this will reduce your disk utilization\nbuilders-use-substitutes = true\n\n```\n\n----------------------------------------\n\nTITLE: Overrideable Package Test Setup in Nix\nDESCRIPTION: Implementation of package tests that work correctly with overrideAttrs, showing both the package definition and test implementation files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n# my-package/default.nix\n{ stdenv, callPackage }:\nstdenv.mkDerivation (finalAttrs: {\n  # ...\n  passthru.tests.example = callPackage ./example.nix { my-package = finalAttrs.finalPackage; };\n})\n```\n\nLANGUAGE: nix\nCODE:\n```\n# my-package/example.nix\n{ runCommand, lib, my-package, ... }:\nrunCommand \"my-package-test\" {\n  nativeBuildInputs = [ my-package ];\n  src = lib.sources.sourcesByRegex ./. [ \".*.in\" \".*.expected\" ];\n} ''\n  my-package --help\n  my-package <example.in >example.actual\n  diff -U3 --color=auto example.expected example.actual\n  mkdir $out\n''\n```\n\n----------------------------------------\n\nTITLE: Mounting the Boot File System for UEFI Systems\nDESCRIPTION: Commands to create and mount the boot filesystem for UEFI systems. The umask=077 parameter sets restrictive permissions for security purposes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_15\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkdir -p /mnt/boot\n# mount -o umask=077 /dev/disk/by-label/boot /mnt/boot\n```\n\n----------------------------------------\n\nTITLE: Permanently Allowing Broken Packages - User Configuration - nix\nDESCRIPTION: Updates the user's `config.nix` file to allow installing or building packages marked as broken on a permanent basis. Setting `allowBroken = true` disables the default check blocking broken packages across all nix user sessions. No runtime inputs or outputs except for evaluation of new user configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowBroken = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Automatic Database Migrations for Akkoma - ShellSession\nDESCRIPTION: This shell command instructs Akkoma to run pending database migrations, making it suitable for manual upgrades or post-migration scenarios from Pleroma. It requires the Akkoma CLI (pleroma_ctl) and the database to be accessible. Output is a migrated, up-to-date Akkoma schema.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\npleroma_ctl migrate\n```\n\n----------------------------------------\n\nTITLE: Manually Testing a Built systemd Unit - ShellSession\nDESCRIPTION: This code block provides steps to manually copy a built systemd unit to the /run/systemd/system directory and start it immediately. It first uses nix-build to build the specified unit, then copies the resulting .service file to a temporary filename to avoid naming conflicts. Finally, systemctl daemon-reload and systemctl start are used to load and activate the service. It assumes root privileges for the copy and starting service steps, and highlights the need for unique naming to prevent precedence issues with units in /etc/systemd/system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/building-parts.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ cp $(nix-build -A 'config.systemd.units.\"httpd.service\".unit')/httpd.service \\\\n    /run/systemd/system/tmp-httpd.service\\n# systemctl daemon-reload\\n# systemctl start tmp-httpd.service\n```\n\n----------------------------------------\n\nTITLE: Starting Nix Garbage Collection via Systemd Unit (Shell - ShellSession)\nDESCRIPTION: This command starts the Nix garbage collector as a systemd-managed service, allowing background or scheduled garbage collection. It should be executed on a system using systemd with the relevant unit (nix-gc.service) available. The command is useful for integrating garbage collection into system maintenance routines without manual intervention.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n# systemctl start nix-gc.service\\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing PHP Installation with Selected Extensions in NixOS\nDESCRIPTION: Configuration to create a smaller PHP installation with only specific extensions enabled. This example adds imagick, opcache, pdo, and pdo_mysql extensions to a minimal PHP installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    (pkgs.php.withExtensions\n      ({ all, ... }: with all; [\n        imagick\n        opcache\n        pdo\n        pdo_mysql\n      ])\n    )\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PHP Build Options in NixOS (Old Method)\nDESCRIPTION: Deprecated method of configuring PHP build options using config flags. This approach has been replaced with a more direct configuration method in NixOS 20.09.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nphp.override {\n  config.php.embed = true;\n  config.php.apxs2 = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole Downstream with TLS Protocol - Nix\nDESCRIPTION: This snippet configures crab-hole to serve DNS with downstream TLS encryption. It sets protocol, address, port, and specifies the required certificate and key files, with an optional timeout. The crab-hole service user must have access to certificate and key files, which may be generated by ACME or other CAs. Inputs are the protocol type, listen address, port, paths to certificate and key, and (optionally) timeout; output is an encrypted DNS-over-TLS endpoint.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.downstream = [\n    {\n      protocol = \"tls\";\n      listen = \"[::]\";\n      port = 853;\n      certificate = ./dns.example.com.crt;\n      key = \"/dns.example.com.key\";\n      # optional (default = 3000)\n      timeout_ms = 3000\n    }\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Substituting Environment Variables in a Shell Script using substituteAll in Bash\nDESCRIPTION: Provides an example Bash script that contains placeholders meant to be replaced (e.g., @bash@, @hello@, @greeting@) by the Nixpkgs build system using substituteAll. This script is a template; variables are not replaced until processed by the function. Requires a Nix build environment where environment variables are set for each placeholder.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n#! @bash@/bin/bash\n\necho @unchanged@\n@hello@/bin/hello --greeting @greeting@\n```\n\n----------------------------------------\n\nTITLE: Reading a Generated File in Scripts Using writeShellScript - Nix\nDESCRIPTION: This snippet exemplifies using `writeShellScript` to create a shell script that reads the content of a generated file by referencing it at its precise path within the Nix store. The script uses Nix string interpolation to insert the correct store path of the previously created file. Care must be taken to align subpaths with those specified during file creation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nwriteShellScript \"evaluate-my-file.sh\" ''\n  cat ${my-file}/share/my-file\n''\n```\n\n----------------------------------------\n\nTITLE: Importing Cargo Lock with Git Dependencies\nDESCRIPTION: Example of using importCargoLock with git dependencies and their output hashes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\n{\n  cargoDeps = rustPlatform.importCargoLock {\n    lockFile = ./Cargo.lock;\n    outputHashes = {\n      \"rand-0.8.3\" = \"0ya2hia3cn31qa8894s3av2s8j5bjwb6yq92k0jsnlx7jid0jwqa\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Modular Troubleshooting Sections - Markdown\nDESCRIPTION: This Markdown snippet demonstrates the use of the special {=include=} directive to insert external troubleshooting sections into the main documentation. Each filename corresponds to a module covering a specific type of NixOS problem, allowing maintainers to structure content modularly and reuse or update sections independently. No additional dependencies are required beyond support for the {=include=} directive in the processing toolchain, and the expected input is a list of Markdown section files for dynamic inclusion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/troubleshooting.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\nboot-problems.section.md\nmaintenance-mode.section.md\nrollback.section.md\nstore-corruption.section.md\nnetwork-problems.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Final Natural Deduction Rule for Dependency Propagation\nDESCRIPTION: The last rule in the formal specification of dependency propagation, stating that propagated dependencies are also counted as regular dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\npropagated-dep(h, t, A, B)\n----------------------------- Propagated dependencies count as dependencies\ndep(h, t, A, B)\n```\n\n----------------------------------------\n\nTITLE: Configuring Legacy Nginx Privilege Model in NixOS\nDESCRIPTION: NixOS configuration to revert Nginx to the old privilege model where the master process runs as root. This is useful if you need to maintain compatibility with setups requiring root access for Nginx.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nginx.appendConfig = let cfg = config.services.nginx; in ''user ${cfg.user} ${cfg.group};'';\n  systemd.services.nginx.serviceConfig.User = lib.mkForce \"root\";\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Manual to Preview configuration.nix Option Changes - Nix/Nixpkgs - ShellSession\nDESCRIPTION: This ShellSession command demonstrates how to rebuild the NixOS manual after modifying option descriptions in nixos/modules. Running this command regenerates the documentation, allowing the contributor to verify changes in the HTML appendix. The prerequisites include an updated repository and necessary Nix tools. It targets the same manual.x86_64-linux attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/contributing-to-this-manual.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ nix-build nixos/release.nix -A manual.x86_64-linux\\n```\n```\n\n----------------------------------------\n\nTITLE: Including NixOS Options Appendix\nDESCRIPTION: Defines an appendix for NixOS options that will be processed into a separate HTML file with the path //options.html.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/manual.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} appendix html:into-file=//options.html\nnixos-options.md\n```\n```\n\n----------------------------------------\n\nTITLE: Updating a NixOS Container from Host Configuration - ShellSession\nDESCRIPTION: This command rebuilds and activates the 'foo' container's configuration after modifying its configuration.nix on the host. Triggers service reload, applies changes live, and requires root access. Ensures the container stays in sync with host-edited configuration files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container update foo\n```\n\n----------------------------------------\n\nTITLE: Packaging Swift Projects with swiftpm2nix and Nix Derivation in Shell\nDESCRIPTION: This shell snippet outlines the steps required to update dependencies for a Swift project and generate Nix expressions using the `swiftpm2nix` helper. It assumes a Unix-like environment with Nix installed, alongside the `swift`, `swiftpm`, and `swiftpm2nix` packages. The commands update the Swift package workspace, then generate required Nix files for dependency management, typically executed in the root of a Swift project. Inputs are the Swift project workspace and outputs are Nix expressions in the newly-created `nix` directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd /path/to/my/project\n# Enter a Nix shell with the required tools.\nnix-shell -p swift swiftpm swiftpm2nix\n# First, make sure the workspace is up-to-date.\nswift package resolve\n# Now generate the Nix code.\nswiftpm2nix\n```\n\n----------------------------------------\n\nTITLE: CMake Module Path Configuration Reference\nDESCRIPTION: Documents the CMake module path configuration that points to a non-standard lib/cmake directory to work around an upstream issue in aws-c-common\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/aws-c-common.section.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# `aws-c-common` {#aws-c-common}\n\nThis hook exposes its own [CMake](#cmake) modules by setting [`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html) through [the `cmakeFlags` variable](#cmake-flags)\nto the nonstandard `$out/lib/cmake` directory, as a workaround for [an upstream bug](https://github.com/awslabs/aws-c-common/issues/844).\n```\n\n----------------------------------------\n\nTITLE: Adding Swap Partition on MBR Disk Using parted (ShellSession)\nDESCRIPTION: Creates a primary partition for swap usage, occupying the final 8GB of the disk. Uses 'linux-swap' as the type, spanning from -8GB to 100% of the disk. The swap partition size is customizable according to system requirements.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- mkpart primary linux-swap -8GB 100%\n```\n\n----------------------------------------\n\nTITLE: Running Package Tests Command in Shell\nDESCRIPTION: A shell command showing how to run tests defined in a package's passthru.tests attribute from the Nixpkgs repository. This is useful for testing package functionality without rebuilding.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/passthru.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ cd path/to/nixpkgs\n$ nix-build -A your-package.tests\n```\n\n----------------------------------------\n\nTITLE: Entering Nix Shell for Kernel Development - Nix - ShellSession\nDESCRIPTION: This snippet demonstrates how to enter a development shell for a specific Linux kernel version package in Nixpkgs using the nix-shell command. It requires a working Nixpkgs checkout and correct attribute naming, and prepares the environment for kernel-related build or configuration operations. The input parameter 'linuxKernel.kernels.linux_2_6_22' specifies the kernel version's derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/README.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -A linuxKernel.kernels.linux_2_6_22\n```\n\n----------------------------------------\n\nTITLE: Configuring DNSCrypt-Proxy2 and Dnsmasq Integration - Nix\nDESCRIPTION: This comprehensive snippet defines how to enable DNSCrypt-Proxy2 and configure DNSMasq to forward queries in a NixOS environment. It provides a detailed attribute set for DNSCrypt-Proxy2 settings (e.g., listen_addresses, resolver sources), demonstrates enabling DNSMasq, and establishes communication between the two services. The configuration assumes required packages are available and all specified files/URLs are accessible during build/apply time.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Example configuration:\n  services.dnscrypt-proxy2.enable = true;\n  services.dnscrypt-proxy2.settings = {\n    listen_addresses = [ \"127.0.0.1:43\" ];\n    sources.public-resolvers = {\n      urls = [ \"https://download.dnscrypt.info/resolvers-list/v2/public-resolvers.md\" ];\n      cache_file = \"public-resolvers.md\";\n      minisign_key = \"RWQf6LRCGA9i53mlYecO4IzT51TGPpvWucNSCh1CBM0QTaLn73Y7GFO3\";\n      refresh_delay = 72;\n    };\n  };\n\n  services.dnsmasq.enable = true;\n  services.dnsmasq.servers = [ \"127.0.0.1#43\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Docker Image Load Shell Command Example\nDESCRIPTION: Demonstrates the process of building and loading the streamed Docker image using nix-build and docker image load commands.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/wsz2xl8ckxnlb769irvq6jv1280dfvxd-stream-hello\n\n$ /nix/store/wsz2xl8ckxnlb769irvq6jv1280dfvxd-stream-hello | docker image load\nNo 'fromImage' provided\nCreating layer 1 from paths: ['/nix/store/i93s7xxblavsacpy82zdbn4kplsyq48l-libunistring-1.1']\nCreating layer 2 from paths: ['/nix/store/ji01n9vinnj22nbrb86nx8a1ssgpilx8-libidn2-2.3.4']\nCreating layer 3 from paths: ['/nix/store/ldrslljw4rg026nw06gyrdwl78k77vyq-xgcc-12.3.0-libgcc']\nCreating layer 4 from paths: ['/nix/store/9y8pmvk8gdwwznmkzxa6pwyah52xy3nk-glibc-2.38-27']\nCreating layer 5 from paths: ['/nix/store/zhl06z4lrfrkw5rp0hnjjfrgsclzvxpm-hello-2.12.1']\nCreating layer 6 with customisation...\nAdding manifests...\nDone.\n(some output removed for clarity)\nLoaded image: hello:latest\n```\n\n----------------------------------------\n\nTITLE: Quick Reboot Using systemctl kexec - ShellSession\nDESCRIPTION: This snippet demonstrates a quick system reboot using 'systemctl kexec', which reloads a new kernel directly into memory without going through the BIOS. Dependencies include systemd support and typically superuser privileges. It is used for faster reboots. Input: execution of command. Output: system restarts into a new kernel image.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/rebooting.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemctl kexec\n```\n\n----------------------------------------\n\nTITLE: Building a fetchurl Package with postFetch Content Manipulation - Shell\nDESCRIPTION: This shell example displays the output of building a Nix derivation where the downloaded file is modified by appending output from the 'hello' package via the postFetch script. It confirms the modification by printing the file's content in the Nix store, which now includes 'Hello, world!' after the version number. Prerequisites include Nix, the 'hello' package, and proper hash adjustment due to content changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/ifi6pp7q0ag5h7c5v9h1c1c7bhd10c7f-version\n\n$ cat /nix/store/ifi6pp7q0ag5h7c5v9h1c1c7bhd10c7f-version\n23.11\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Adding a Maintainer with GPG Key in Nixpkgs\nDESCRIPTION: Example of a maintainer entry in maintainer-list.nix that includes email, name, and GPG key information. The GPG key fingerprint is required for verification of signed commits.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  example = {\n    email = \"user@example.com\";\n    name = \"Example User\";\n    keys = [{\n      fingerprint = \"0000 0000 2A70 6423 0AED  3C11 F04F 7A19 AAA6 3AFE\";\n    }];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Separate Binary Output for Haskell Packages\nDESCRIPTION: A function to install executables to a separate 'bin' output, preserving libraries and documentation in the 'out' output. This reduces closure size while maintaining full package functionality.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\nenableSeparateBinOutput drv\n```\n\n----------------------------------------\n\nTITLE: Updating R Packages with Generation Scripts - Bash\nDESCRIPTION: This sequence of bash commands describes the process for regenerating and synchronizing the available R packages set to match versions from CRAN and Bioconductor. It uses 'nix-shell' to initialize the appropriate environment and then leverages 'Rscript' to produce new package set JSON files, followed by 'mv' to replace old files. Dependencies include a working Rscript interpreter, access to needed .R scripts, and permissions to write to package set directories. Output files are used by Nix to define package derivations for each R library specified; input and output file names must follow the convention detailed in comments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/r.section.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnix-shell generate-shell.nix\n\nRscript generate-r-packages.R cran  > cran-packages.json.new\nmv cran-packages.json.new cran-packages.json\n\nRscript generate-r-packages.R bioc  > bioc-packages.json.new\nmv bioc-packages.json.new bioc-packages.json\n\nRscript generate-r-packages.R bioc-annotation > bioc-annotation-packages.json.new\nmv bioc-annotation-packages.json.new bioc-annotation-packages.json\n\nRscript generate-r-packages.R bioc-experiment > bioc-experiment-packages.json.new\nmv bioc-experiment-packages.json.new bioc-experiment-packages.json\n```\n\n----------------------------------------\n\nTITLE: Enabling Meson Host Binary Execution with mesonEmulatorHook - Nix\nDESCRIPTION: This Nix snippet conditionally adds 'mesonEmulatorHook' to 'nativeBuildInputs' if host binaries cannot be executed on the build platform. This allows Meson to execute host binaries (via emulation if needed) during cross builds. It works in tandem with the Meson build system and the 'lib.optionals' helper. Prerequisites: 'meson', 'mesonEmulatorHook', and 'lib' must be available in scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs =\n    [\n      meson\n    ]\n    ++ lib.optionals (!stdenv.buildPlatform.canExecute stdenv.hostPlatform) [\n      mesonEmulatorHook\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding mkDerivation arguments with overrideCabal - Nix Expression Language\nDESCRIPTION: Uses haskell.lib.compose.overrideCabal to customize the postInstall hook of a Haskell package, such as installing a man page. The function takes the original derivation and augments the postInstall phase. Required dependencies include the haskell.lib.compose module and the haskellPackages set. This pattern can be used to inject additional build steps or outputs without mutating the source. Input is the derivation to override, and the output is a new derivation with modified hooks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nhaskell.lib.compose.overrideCabal (drv: {\n  postInstall = ''\n    ${drv.postInstall or \"\"}\n    install -Dm644 man/pnbackup.1 -t $out/share/man/man1\n  '';\n}) haskellPackages.pnbackup\n\n```\n\n----------------------------------------\n\nTITLE: Launching Lua Interpreter in nix-shell Session - Shell Command - sh\nDESCRIPTION: This shell snippet illustrates running the Lua interpreter inside a nix-shell session. Assumes that the session includes Lua (as in the previous snippet). The result is an interactive Lua prompt with access to installed packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n[nix-shell:~] lua\n\n```\n\n----------------------------------------\n\nTITLE: Specifying depsBuildBuild for Build-Time C Programs in mkDerivation - Nix\nDESCRIPTION: This Nix expression extends 'mkDerivation' with an entry to 'depsBuildBuild', ensuring a C compiler is available for building helper programs needed at build time. It adds the build-time stdenv C compiler as a dependency. Allows execution of natively built binaries during the build on the build platform. Must be used within the derivation definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  depsBuildBuild = [ buildPackages.stdenv.cc ];\n}\n```\n\n----------------------------------------\n\nTITLE: Switching to NixOS Small Channel\nDESCRIPTION: This command shows how to switch to the 'small' channel, which is suitable for server environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nix-channel --add https://channels.nixos.org/nixos-24.11-small nixos\n```\n\n----------------------------------------\n\nTITLE: Configuring Gem-specific Build Settings via Overlays\nDESCRIPTION: Demonstrates how to use Nix overlays to override default gem configurations. This method allows for system-wide gem configuration changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pg_version ? \"10\",\n}:\nlet\n  pkgs = import <nixpkgs> {\n    overlays = [\n      (self: super: {\n        defaultGemConfig = super.defaultGemConfig // {\n          pg = attrs: {\n            buildFlags = [\n              \"--with-pg-config=${pkgs.\"postgresql_${pg_version}\".pg_config}/bin/pg_config\"\n            ];\n          };\n        };\n      })\n    ];\n  };\nin\npkgs.ruby.withPackages (ps: with ps; [ pg ])\n```\n\n----------------------------------------\n\nTITLE: Python Package Override in configuration.nix\nDESCRIPTION: Demonstrates how to override Python package attributes in configuration.nix, specifically showing how to modify package sources and versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_53\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config.packageOverrides = super: {\n    python3 = super.python3.override {\n      packageOverrides = python-self: python-super: {\n        twisted = python-super.twisted.overridePythonAttrs (oldAttrs: {\n          src = super.fetchPypi {\n            pname = \"Twisted\";\n            version = \"19.10.0\";\n            hash = \"sha256-c5S6fycq5yKnTz2Wnc9Zm8TvCTvDkgOHSKSQ8XJKUV0=\";\n            extension = \"tar.bz2\";\n          };\n        });\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Additional Sources with HOCON in Nix\nDESCRIPTION: Demonstrates how to use the HOCON format helper library within pkgs.formats to include additional configuration sources in HOCON files from Nix expressions. The snippet uses mkInclude to reference external files or URLs, supports advanced inclusion parameters, and shows nested configuration attributes. Dependencies: pkgs.formats.hocon and Nixpkgs. Required parameters: attribute sets for sources. Expected input: attribute set specifying HOCON structure with _includes key. Output: HOCON-compatible configuration for use in deployments or service configurations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.hocon { };\n  hocon_file = pkgs.writeText \"to_include.hocon\" ''\n    a = 1;\n  '';\nin {\n  some.nested.hocon.attrset = {\n    _includes = [\n      (format.lib.mkInclude hocon_file)\n      (format.lib.mkInclude \"https://example.com/to_include.hocon\")\n      (format.lib.mkInclude {\n        required = true;\n        type = \"file\";\n        value = include_file;\n      })\n    ];\n    ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Definition List Syntax in Markdown - Markdown\nDESCRIPTION: This example illustrates how to format a definition list in Markdown for grouping terms with their definitions. Each term is followed by a colon and its description. Expected input is one or more term-description pairs; the output is rendered as definition lists where supported. This requires a Markdown extension for definition lists.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_5\n\nLANGUAGE: Markdown\nCODE:\n```\npear\\n:   green or yellow bulbous fruit\\n\\nwatermelon\\n:   green fruit with red flesh\n```\n\n----------------------------------------\n\nTITLE: Attaching, Running and Detaching Portable Service Image via portablectl (Shell)\nDESCRIPTION: This shell session demonstrates how to build, attach, run, monitor, and detach a portable systemd service image generated by pkgs.portableService. The commands use nix-build to create the image, portablectl to attach and detach it, and systemctl/journalctl to start and observe the service. Outputs and logs indicate the complete lifecycle of the portable service within systemd. Required preconditions include systemd version 239+ and permission to run these commands.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/portableservice.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/8c20z1vh7z8w8dwagl8w87b45dn5k6iq-hello-img-2.12.1\n\n$ portablectl attach /nix/store/8c20z1vh7z8w8dwagl8w87b45dn5k6iq-hello-img-2.12.1/hello_2.12.1.raw\nCreated directory /etc/systemd/system.attached.\nCreated directory /etc/systemd/system.attached/hello.service.d.\nWritten /etc/systemd/system.attached/hello.service.d/20-portable.conf.\nCreated symlink /etc/systemd/system.attached/hello.service.d/10-profile.conf → /usr/lib/systemd/portable/profile/default/service.conf.\nCopied /etc/systemd/system.attached/hello.service.\nCreated symlink /etc/portables/hello_2.12.1.raw → /nix/store/8c20z1vh7z8w8dwagl8w87b45dn5k6iq-hello-img-2.12.1/hello_2.12.1.raw.\n\n$ systemctl start hello\n$ journalctl -u hello\nFeb 28 22:39:16 hostname systemd[1]: Starting Hello world service...\nFeb 28 22:39:16 hostname hello[102887]: Hello, world!\nFeb 28 22:39:16 hostname systemd[1]: hello.service: Deactivated successfully.\nFeb 28 22:39:16 hostname systemd[1]: Finished Hello world service.\n\n$ portablectl detach hello_2.12.1\nRemoved /etc/systemd/system.attached/hello.service.\nRemoved /etc/systemd/system.attached/hello.service.d/10-profile.conf.\nRemoved /etc/systemd/system.attached/hello.service.d/20-portable.conf.\nRemoved /etc/systemd/system.attached/hello.service.d.\nRemoved /etc/portables/hello_2.12.1.raw.\nRemoved /etc/systemd/system.attached.\n```\n\n----------------------------------------\n\nTITLE: Example Agda .agda-lib Configuration File - ini - ini\nDESCRIPTION: Shows the minimal structure required for a .agda-lib file, used to define a local Agda library's name, source directories, and dependencies. No dependencies are required other than an Agda installation. Parameters are name (of the library), include (directories to include), and depend (external libraries). The file must have a .agda-lib extension.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_7\n\nLANGUAGE: ini\nCODE:\n```\nname: my-library\ninclude: .\ndepend: standard-library\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Nightly Shell Environment with fenix Overlay - Nix\nDESCRIPTION: This Nix snippet demonstrates how to create a `shell.nix` using the fenix overlay to provide a Rust nightly toolchain. Fenix is fetched by commit hash and integrated, then Rust and dependencies (`pkg-config`, `openssl`) are set up for development. The environment variable `RUST_BACKTRACE` is set for debugging. To use, save as `shell.nix` and invoke with nix-shell; Rust and associated utilities will be available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_33\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\nlet\n  fenix = callPackage (fetchFromGitHub {\n    owner = \"nix-community\";\n    repo = \"fenix\";\n    # commit from: 2023-03-03\n    rev = \"e2ea04982b892263c4d939f1cc3bf60a9c4deaa1\";\n    hash = \"sha256-AsOim1A8KKtMWIxG+lXh5Q4P2bhOZjoUhFWJ1EuZNNk=\";\n  }) { };\nin\nmkShell {\n  name = \"rust-env\";\n  nativeBuildInputs = [\n    # Note: to use stable, just replace `default` with `stable`\n    fenix.default.toolchain\n\n    # Example Build-time Additional Dependencies\n    pkg-config\n  ];\n  buildInputs = [\n    # Example Run-time Additional Dependencies\n    openssl\n  ];\n\n  # Set Environment Variables\n  RUST_BACKTRACE = 1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Linker Error from Incompatible Bindnow Hardening Flag in ELF Linking (Linker Output)\nDESCRIPTION: This output fragment presents a runtime linker error where the 'bindnow' (-z now) hardening flag conflicts with some dynamic shared object systems (e.g., Xorg, PHP), resulting in unresolved symbols. This error is commonly encountered when the linker attempts immediate symbol resolution but external modules expect lazy resolution. The input trigger is linking shared objects with the -z now flag enabled; the output is an undefined symbol error at runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_46\n\nLANGUAGE: text\nCODE:\n```\nintel_drv.so: undefined symbol: vgaHWFreeHWRec\n```\n\n----------------------------------------\n\nTITLE: Automated git bisect Workflow for Rust Compiler Debugging - Bash\nDESCRIPTION: This Bash command loop is designed for automating git bisect on the rustc source tree. It marks bisect states, updates git submodules, vendors dependencies (`cargo vendor` with multiple manifests), and triggers a Nix build for the affected package. Ensures that relevant submodules and dependencies are current before building. Generally executed manually in the rustc git checkout, with network access required for submodule and cargo vendor steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\ngit bisect {good,bad}  # depending on result of last build\ngit submodule update --init\nCARGO_NET_OFFLINE=false cargo vendor \\\n  --sync ./src/tools/cargo/Cargo.toml \\\n  --sync ./src/tools/rust-analyzer/Cargo.toml \\\n  --sync ./compiler/rustc_codegen_cranelift/Cargo.toml \\\n  --sync ./src/bootstrap/Cargo.toml\nnix-build $NIXPKGS -A package-broken-by-rust-changes\n\n```\n\n----------------------------------------\n\nTITLE: Listing Available Idris Packages\nDESCRIPTION: Commands to list all available Idris packages in the Nix package repository, with variations for NixOS and non-NixOS systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ # On NixOS\n$ nix-env -qaPA nixos.idrisPackages\n$ # On non-NixOS\n$ nix-env -qaPA nixpkgs.idrisPackages\n```\n\n----------------------------------------\n\nTITLE: Template Output Example (Bash)\nDESCRIPTION: Example showing the result of variable substitution in a template file\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\n#! /nix/store/bmwp0q28cf21...-bash-3.2-p39/bin/sh\nPATH=/nix/store/68afga4khv0w...-coreutils-6.12/bin\necho @foo@\n```\n\n----------------------------------------\n\nTITLE: Editing the NixOS Configuration File\nDESCRIPTION: Command to edit the generated configuration file using the nano text editor. This file needs to be customized with the desired system settings before installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_18\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nano /mnt/etc/nixos/configuration.nix\n```\n\n----------------------------------------\n\nTITLE: Running Docker container with CUDA support\nDESCRIPTION: This command shows how to run a Docker container with CUDA support, using the --device flag to expose all NVIDIA GPUs to the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ docker run --rm -it --device=nvidia.com/gpu=all ubuntu:latest nvidia-smi -L\nGPU 0: NVIDIA GeForce RTX 4090 (UUID: <REDACTED>)\nGPU 1: NVIDIA GeForce RTX 2080 SUPER (UUID: <REDACTED>)\n```\n\n----------------------------------------\n\nTITLE: Entering Rescue Mode with systemctl on NixOS - Shell\nDESCRIPTION: Demonstrates the command to activate rescue mode, providing a root shell by stopping most systemd services. Requires systemd and root privileges. Running `systemctl rescue` initiates single-user mode; exit the shell to return to normal operation. Suitable for emergency or maintenance scenarios on NixOS systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/maintenance-mode.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemctl rescue\n```\n\n----------------------------------------\n\nTITLE: Android CMake Configuration in Nix Shell\nDESCRIPTION: Nix shell configuration that properly sets up CMake for Android development by adding it to PATH using shell hook. Ensures CMake is accessible with correct version paths.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  cmakeVersion = \"3.10.2\";\n\n  # Use cmakeVersion when you define androidComposition\n  androidComposition = <...>;\nin\npkgs.mkShell rec {\n  ANDROID_HOME = \"${androidComposition.androidsdk}/libexec/android-sdk\";\n  ANDROID_NDK_ROOT = \"${ANDROID_HOME}/ndk-bundle\";\n\n  # Use the same cmakeVersion here\n  shellHook = ''\n    export PATH=\"$(echo \"$ANDROID_HOME/cmake/${cmakeVersion}\".*/bin):$PATH\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Rebasing Feature Branch onto Staging with Git (Git)\nDESCRIPTION: This snippet covers the process of rebasing a feature branch from master to staging in a multi-branch repository setup. It requires a typical Git environment with the 'upstream' remote set to NixOS/nixpkgs.git and 'origin' set to the contributor's fork. The 'git rebase --onto' command rebases the feature branch onto the correct base, and a force push ('--force-with-lease') updates the remote feature branch. This is required when changing base branches for a GitHub PR with differing merge histories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\n# Rebase your commits onto the common merge base\ngit rebase --onto upstream/staging... upstream/master\n# Force push your changes\ngit push origin feature --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Creating Ephemeral Idris Environment with Nix-shell\nDESCRIPTION: Command to create a temporary shell environment with Idris and specified libraries using nix-shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p 'idrisPackages.with-packages (with idrisPackages; [ contrib pruviloj ])'\n```\n\n----------------------------------------\n\nTITLE: Permanently Allowing Unsupported System Packages - User Configuration - nix\nDESCRIPTION: Configures `~/.config/nixpkgs/config.nix` to permit the building of any package flagged as unsupported on the current system. Setting `allowUnsupportedSystem = true` disables normal Nixpkgs constraints and can be used for cross-compilation or porting scenarios.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowUnsupportedSystem = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing ILP64 BLAS/LAPACK Usage in Nix Derivation\nDESCRIPTION: This snippet shows how to add an assertion to a Nix derivation to prevent the use of ILP64 versions of BLAS and LAPACK, which some software may not be compatible with.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  blas,\n  lapack,\n  ...\n}:\n\nassert (!blas.isILP64) && (!lapack.isILP64);\n\nstdenv.mkDerivation {\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring node-gyp in yarn2nix build\nDESCRIPTION: A Nix configuration snippet that solves node-gyp issues by setting up the necessary environment. It creates required directories, sets the installation version, links to NodeJS headers, and exports the node directory configuration for npm.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{\n  yarnPreBuild = ''\n    mkdir -p $HOME/.node-gyp/${nodejs.version}\n    echo 9 > $HOME/.node-gyp/${nodejs.version}/installVersion\n    ln -sfv ${nodejs}/include $HOME/.node-gyp/${nodejs.version}\n    export npm_config_nodedir=${nodejs}\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing NixOS Test Logs with nix-store - ShellSession\nDESCRIPTION: This snippet shows how to inspect the build log of an executed NixOS test using 'nix-store --read-log'. It requires that a previous nix-build result is available with a valid output path ('result'). The primary parameter is the output directory (here, 'result'), and the output is a textual log of the test execution. This step aids debugging and validation of automated tests run in the virtualized NixOS environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-store --read-log result\n```\n\n----------------------------------------\n\nTITLE: Overriding PostgreSQL Plugin through Nixpkgs Overlay\nDESCRIPTION: Demonstrates how to override a specific PostgreSQL plugin using a Nixpkgs overlay. The example customizes the pg_repack plugin for PostgreSQL 15 with a specific version from GitHub.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nself: super: {\n  postgresql_15 = super.postgresql_15// {\n    pkgs = super.postgresql_15.pkgs // {\n      pg_repack = super.postgresql_15.pkgs.pg_repack.overrideAttrs (_: {\n        name = \"pg_repack-v20181024\";\n        src = self.fetchzip {\n          url = \"https://github.com/reorg/pg_repack/archive/923fa2f3c709a506e111cc963034bf2fd127aa00.tar.gz\";\n          sha256 = \"17k6hq9xaax87yz79j773qyigm4fwk8z4zh5cyp6z0sxnwfqxxw5\";\n        };\n      });\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating OpenLDAP Configuration to OLC Format with Shell Commands - ShellSession\nDESCRIPTION: This sequence of shell commands migrates an OpenLDAP 'slapd.conf' configuration file to the OLC (On-Line Configuration) directory format. Executes 'slaptest' to convert, using a temporary directory, then extracts (minus schemas) the configuration with 'slapcat'. Requires OpenLDAP tools ('slaptest', 'slapcat') and access to the configuration file; outputs LDIF for import or conversion. $TMPDIR must be unique; replace '/path/to/slapd.conf' with the correct file path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ TMPDIR=$(mktemp -d)\n$ slaptest -f /path/to/slapd.conf -F $TMPDIR\n$ slapcat -F $TMPDIR -n0 -H 'ldap:///???(!(objectClass=olcSchemaConfig))'\n```\n\n----------------------------------------\n\nTITLE: Terminating a User Session - loginctl terminate-session - ShellSession\nDESCRIPTION: This snippet shows how to terminate a user session by invoking loginctl terminate-session <session_id>. It ends the specified session and ensures all related processes are terminated. Requires sudo/root permissions. Input: session ID (here 'c3'). Output: No printed output on success; session processes will be killed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/user-sessions.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# loginctl terminate-session c3\n```\n\n----------------------------------------\n\nTITLE: Viewing Journal Entries Since Last Reboot in NixOS\nDESCRIPTION: This command shows all journal entries since the last system reboot using journalctl. The output is automatically piped into the 'less' pager for easier navigation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/logging.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ journalctl -b\n```\n\n----------------------------------------\n\nTITLE: Copying the Cache Directory to Another Machine (ShellSession)\nDESCRIPTION: Uses scp to copy the built binary cache directory (result) to another machine (host2) under the target path /tmp/hello-cache. The dependency is scp and SSH access between machines. The expected input is the local result directory and the remote destination. Output is the cache directory on the remote machine. Permissions and network configuration may restrict usage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/binarycache.section.md#_snippet_2\n\nLANGUAGE: shellSession\nCODE:\n```\n$ scp result host2:/tmp/hello-cache\n```\n\n----------------------------------------\n\nTITLE: Packaging an OCaml Library (wtf8) with Source Archive\nDESCRIPTION: This example demonstrates packaging the 'wtf8' OCaml library using a source archive. It shows how to fetch the source using fetchurl, set minimal OCaml version, and specify meta information for the package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ocaml.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchurl,\n  buildDunePackage,\n}:\n\nbuildDunePackage rec {\n  pname = \"wtf8\";\n  version = \"1.0.2\";\n\n  minimalOCamlVersion = \"4.02\";\n\n  src = fetchurl {\n    url = \"https://github.com/flowtype/ocaml-wtf8/releases/download/v${version}/wtf8-v${version}.tbz\";\n    hash = \"sha256-d5/3KUBAWRj8tntr4RkJ74KWW7wvn/B/m1nx0npnzyc=\";\n  };\n\n  meta = {\n    homepage = \"https://github.com/flowtype/ocaml-wtf8\";\n    description = \"WTF-8 is a superset of UTF-8 that allows unpaired surrogates\";\n    license = lib.licenses.mit;\n    maintainers = [ lib.maintainers.eqyiel ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Failing to Import Unspecified Package in nix-shell - Python Console - Python Console\nDESCRIPTION: Shows how attempting to import a package (requests) not included in the nix-shell's Python environment results in a ModuleNotFoundError. Demonstrates the environment's isolation, as only explicitly specified packages are in scope. Useful for understanding precise dependency management under Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_15\n\nLANGUAGE: Python console\nCODE:\n```\n>>> import requests\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nModuleNotFoundError: No module named 'requests'\n```\n\n----------------------------------------\n\nTITLE: Overriding Final Derivation Attributes with overrideDerivation (Nix Language)\nDESCRIPTION: Shows how to use overrideDerivation to modify the attributes of a derivation after it has been evaluated. The code overrides name, src, and patches attributes of pkgs.gnused, demonstrating direct customization of the final derivation attribute set. Typically requires the fetchurl function and that pkgs.gnused exposes .overrideDerivation. Inputs are an attribute-modifying lambda, outputs are new derivations. Not suitable for use within nixpkgs due to evaluation penalties and breaking abstraction.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overrides.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mySed = pkgs.gnused.overrideDerivation (oldAttrs: {\n    name = \"sed-4.2.2-pre\";\n    src = fetchurl {\n      url = \"ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2\";\n      hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\";\n    };\n    patches = [ ];\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Rust Code with Tree Sitter Python Bindings (Python)\nDESCRIPTION: This snippet demonstrates how to use Python bindings to Tree Sitter and the Rust grammar to parse a piece of Rust code in-memory. Dependencies are the tree_sitter and tree_sitter_rust modules, both provided by the Nix shell configuration. The snippet loads the grammar, initializes a parser, parses a simple Rust function, and prints the syntax tree. Inputs include the Rust source as a bytes object; outputs include the printed syntax tree for analysis, with the main limitation being that grammars must be correctly installed and available in the Python environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/python-tree-sitter.section.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Import the Tree Sitter library and Rust grammar\nimport tree_sitter\nimport tree_sitter_rust\n\n# Load the Rust grammar and initialize the parser\nrust = tree_sitter.Language(tree_sitter_rust.language())\nparser = tree_sitter.Parser(rust)\n\n# Parse a Rust snippet\ntree = parser.parse(\n    bytes(\n        \"\"\"\n        fn main() {\n          println!(\"Hello, world!\");\n        }\n        \"\"\",\n        \"utf8\"\n    )\n)\n\n# Display the resulting syntax tree\nprint(tree.root_node)\n\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Build Mode for Rust Package\nDESCRIPTION: Configuration to build a Rust package in debug mode instead of release mode.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  buildType = \"debug\";\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Portunus and LDAP Package Hashes for Legacy Compatibility (Nix)\nDESCRIPTION: This snippet shows how to override the libxcrypt dependency for both Portunus and LDAP packages in user configurations to maintain compatibility with weak password hashes during a migration period. It leverages the Nixpkgs override mechanism, requiring that pkgs.portunus, pkgs.libxcrypt-legacy, and pkgs.openldap are available in your environment. Set these overrides as attributes in your configuration.nix to bridge security migrations before upgrading all user accounts to strong hashes; note that this is a temporary workaround with security risks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nservices.portunus.package      = pkgs.portunus.override { libxcrypt = pkgs.libxcrypt-legacy; };\nservices.portunus.ldap.package = pkgs.openldap.override { libxcrypt = pkgs.libxcrypt-legacy; };\n```\n\n----------------------------------------\n\nTITLE: Creating a Lua Environment with withPackages - Nix Expression - nix\nDESCRIPTION: This Nix code demonstrates usage of lua.withPackages (or lua5_1.withPackages) to generate a Lua environment with specified packages, referencing the package set provided by ps. Inputs are the interpreter and a function selecting packages from the set. Output is a custom environment derivation containing the interpreter and selected packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nlua.withPackages (ps: [ ps.luafilesystem ])\n\n```\n\nLANGUAGE: nix\nCODE:\n```\nlua5_1.withPackages (ps: [ ps.lua ])\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Emacs Package Override in config.nix - User Profile - Nix\nDESCRIPTION: This Nix snippet allows per-user installation of a custom Emacs build by using packageOverrides in ~/.config/nixpkgs/config.nix. It defines 'myemacs' in the user's package set, using the previously defined emacs.nix derivation. Subsequent nix-env operations can install or update this user-level Emacs. Requires that emacs.nix be present in the same directory and a working Nix installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = super: let self = super.pkgs; in {\n    myemacs = import ./emacs.nix { pkgs = self; };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating SSH Key for Non-Interactive SSHFS Mounting\nDESCRIPTION: Command to generate a new SSH key without a passphrase for non-interactive SSHFS mounting. This is necessary for mounting at boot time or under different users.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ ssh-keygen -t ed25519 -P '' -f example-key\nGenerating public/private ed25519 key pair.\nYour identification has been saved in example-key\nYour public key has been saved in example-key.pub\nThe key fingerprint is:\nSHA256:yjxl3UbTn31fLWeyLYTAKYJPRmzknjQZoyG8gSNEoIE my-user@workstation\n```\n\n----------------------------------------\n\nTITLE: Setting Boot Flag on MBR Root Partition Using parted (ShellSession)\nDESCRIPTION: Sets the bootable flag on the first partition of /dev/sda, marking it as bootable in MBR/BIOS systems. Requires the partition to be created beforehand. Enables legacy BIOS firmware to recognize and boot from this partition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\n# parted /dev/sda -- set 1 boot on\n```\n\n----------------------------------------\n\nTITLE: Using shadowSetup with buildImage in NixOS\nDESCRIPTION: Example showing how to use shadowSetup with dockerTools.buildImage to create users and groups during image creation. The shadowSetup script provides access to user management commands.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_30\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildImage {\n  name = \"shadow-basic\";\n  tag = \"latest\";\n\n  copyToRoot = [ hello ];\n\n  runAsRoot = ''\n    ${dockerTools.shadowSetup}\n    groupadd -r hello\n    useradd -r -g hello hello\n    mkdir /data\n    chown hello:hello /data\n  '';\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n    WorkingDir = \"/data\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating NixOS Shell Environment with SBCL\nDESCRIPTION: Demonstrates how to create a shell environment with SBCL and Alexandria package using mkShell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  sbcl' = sbcl.withPackages (ps: [ ps.alexandria ]);\nin\nmkShell {\n  packages = [ sbcl' ];\n}\n```\n\n----------------------------------------\n\nTITLE: Modern Kodi Addon Configuration\nDESCRIPTION: Current method of configuring Kodi with addons using withPackages function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    (pkgs.kodi.withPackages (p: with p; [\n      inputstream-adaptive\n      vfs-sftp\n    ]))\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using In-Memory Cargo.lock File Contents - buildRustPackage - Nix\nDESCRIPTION: Shows setting `cargoLock.lockFileContents` to a string read from a local file, suitable when the lockfile needs patching or does not exist in the upstream source. Uses a let-bound helper to read and inject the file content. Required dependencies: `builtins.readFile`, a helper function (`f`), and the correct path. Outputs a package with dependencies derived from the supplied lockfile content.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  pname = \"myproject\";\n  version = \"1.0.0\";\n\n  cargoLock =\n    let\n      fixupLockFile = path: f (builtins.readFile path);\n    in\n    {\n      lockFileContents = fixupLockFile ./Cargo.lock;\n    };\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting NixOS Config and VM Options via nix repl - ShellSession\nDESCRIPTION: Demonstrates usage of the nix repl command to inspect the configuration and options of darwin.linux-builder, including the package derivation used and the source location for memory size configuration values. Useful for troubleshooting and inspecting generated configurations without redeploying.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix repl --file ~/src/nixpkgs --argstr system aarch64-darwin\n\nnix-repl> darwin.linux-builder.nixosConfig.nix.package\n«derivation /nix/store/...-nix-2.17.0.drv»\n\nnix-repl> :p darwin.linux-builder.nixosOptions.virtualisation.memorySize.definitionsWithLocations\n[ { file = \"/home/user/src/nixpkgs/nixos/modules/profiles/nix-builder-vm.nix\"; value = 3072; } ]\n\n```\n\n----------------------------------------\n\nTITLE: Allowing Broken Package Build via Environment Variable - Nix Tools - shell\nDESCRIPTION: Exports the `NIXPKGS_ALLOW_BROKEN` environment variable to permit the building of packages marked as broken during a single shell session or command. No dependencies beyond a working `nix` environment are necessary. Input is the shell variable export; output is the one-time permission for broken package builds in invoked nix tools, with no persistent system effect.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ export NIXPKGS_ALLOW_BROKEN=1\n```\n\n----------------------------------------\n\nTITLE: Packaging a Factor Application with Runtime Dependencies (painter) - Nix\nDESCRIPTION: This Nix snippet shows how to package a Factor application with additional runtime dependencies and vocabularies. It uses buildFactorApplication to package the 'painter' app, specifying fetchFromGitHub for the source, enabling a GUI, and providing extra vocabularies and binaries. Key parameters include customizing the Factor runtime, sourceRoot, and runtime PATH. Dependencies required are nixpkgs.lib, fetchFromGitHub, factorPackages, and curl.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/factor.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchFromGitHub,\n  factorPackages,\n  curl,\n}:\n\nfactorPackages.buildFactorApplication (finalAttrs: {\n  pname = \"painter\";\n  version = \"1\";\n\n  factor-lang = factorPackages.factor-minimal-gui;\n\n  src = fetchFromGitHub {\n    name = finalAttrs.vocabName;\n    owner = \"Capital-EX\";\n    repo = \"painter\";\n    rev = \"365797be8c4f82440bec0ad0a50f5a858a06c1b6\";\n    hash = \"sha256-VdvnvKNGcFAtjWVDoxyYgRSyyyy0BEZ2MZGQ71O8nUI=\";\n  };\n\n  sourceRoot = \".\";\n\n  enableUI = true;\n  extraVocabs = [ factorPackages.bresenham ];\n\n  extraPaths = with finalAttrs.factor-lang; binPackages ++ defaultBins ++ [ curl ];\n\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Crystal Dependencies with crystal2nix\nDESCRIPTION: This bash script clones the Mint project, checks out a specific version, ensures the shard.lock file exists by creating it if needed, and runs crystal2nix to generate the shards.nix file for Nix packaging.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/crystal.section.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/mint-lang/mint\n$ cd mint\n$ git checkout 0.5.0\n$ if [ ! -f shard.lock ]; then nix-shell -p shards --run \"shards lock\"; fi\n$ nix-shell -p crystal2nix --run crystal2nix\n```\n\n----------------------------------------\n\nTITLE: Mapping CycloneDX FOD Properties to Nix Derivations - Nix\nDESCRIPTION: This snippet demonstrates how to extract 'nix:fod' properties from a property list and map them to an appropriate Nixpkgs function (here, 'fetchzip') for deriving build artifacts from fixed-output derivation information encoded in CycloneDX SBOM properties. Dependencies include a 'filterPropertiesToAttrs' function, a set of available methods (here, limited to 'fetchzip'), access to the 'pkgs' set, and a property list input. The code expects a compatible properties attribute set and requires the method to match a key in 'methods'; it returns the result of invoking the mapped fetch function with the filtered attributes. Limitations: assumes existence of supporting helper function(s) and only covers 'fetchzip' in this example.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/interoperability/cyclonedx.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  pkgs,\n  filterPropertiesToAttrs,\n  properties,\n}:\nlet\n  fodProps = filterPropertiesToAttrs \"nix:fod:\" properties;\n\n  methods = {\n    fetchzip =\n      {\n        name,\n        url,\n        sha256,\n        ...\n      }:\n      pkgs.fetchzip {\n        inherit name url sha256;\n      };\n  };\n\nin\nmethods.${fodProps.method} fodProps\n```\n\n----------------------------------------\n\nTITLE: Running Dart Tools from Package Cache - Bash\nDESCRIPTION: Shows how to run an executable (build_runner) directly from the Dart package cache using the packageRun utility from dartConfigHook. This bypasses Pub and does not fetch dependencies, making it suitable for build tooling in Nix environments. Requires a configured package cache and the packageRun script available in shell. Expects the first argument to be the tool name, followed by arguments for the tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dart.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npackageRun build_runner build\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Grsecurity in NixOS Configuration - Nix Expression - Nix\nDESCRIPTION: This code snippet demonstrates how to enable the Grsecurity kernel patches for system-wide security in a NixOS configuration file using a concise Nix attribute set. To apply, place this configuration in the NixOS configuration file, such as configuration.nix, under the top-level attribute set. The key parameter, security.grsecurity.enable, activates enhancements without requiring additional arguments. The expected result is an improved security profile for the system kernel, but some kernel or user-space features may be restricted by Grsecurity constraints.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1609.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.grsecurity.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cert Spotter and SMTP Client - Nix Language\nDESCRIPTION: This Nix code snippet enables the Cert Spotter monitoring service in NixOS, sets up a domain watchlist (including all its subdomains via a leading dot), and specifies email recipients for notifications. It also shows how to enable an SMTP client with msmtp or alternative sendmail-providing modules like nullmailer, opensmtpd, or postfix. Parameters include the domains to monitor, recipient emails, and SMTP client module selection. Inputs are declarative options in the NixOS configuration, and the output is a generated system configuration that runs Cert Spotter according to the specified policy.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/certspotter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.certspotter = {\n    enable = true;\n    # replace example.org with your domain name\n    watchlist = [ \".example.org\" ];\n    emailRecipients = [ \"webmaster@example.org\" ];\n  };\n\n  # Configure an SMTP client\n  programs.msmtp.enable = true;\n  # Or you can use any other module that provides sendmail, like\n  # services.nullmailer, services.opensmtpd, services.postfix\n}\n```\n\n----------------------------------------\n\nTITLE: Building NixOS System Top-Level Derivation - ShellSession\nDESCRIPTION: This command provides a shortcut to build the entire NixOS system derivation, which aggregates all system components. Running nix-build -A system in the NixOS directory builds the system.toplevel target, matching the behavior of nixos-rebuild. Requires a valid NixOS configuration. Outputs a completed system build in the result directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/building-parts.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A system\n```\n\n----------------------------------------\n\nTITLE: Manual Reversion to Previous Linux Distribution Using Shell Commands - ShellSession\nDESCRIPTION: This sequential set of shell commands allows users to revert to a previously installed Linux distribution by relocating partitions and restoring old system files. It includes mounting the old system volume, moving current root file contents to a subfolder, restoring the prior root and boot backup, then unmounting and rebooting. The commands assume access to physical or virtual partitions (/dev/sdaX) and root privileges. Proper backup naming and integrity is required for the restoration to function correctly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_16\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkdir root\n# mount /dev/sdaX root\n# mkdir root/nixos-root\n# mv -v root/* root/nixos-root/\n# mv -v root/nixos-root/old-root/* root/\n# mv -v root/boot.bak root/boot  # We had renamed this by hand earlier\n# umount root\n# reboot\n```\n\n----------------------------------------\n\nTITLE: Setting Supported Locales Configuration in NixOS\nDESCRIPTION: Example of setting i18n.supportedLocales to install all locales in the system. This configuration affects system closure size and locale availability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n[ \"all\" ]\n```\n\n----------------------------------------\n\nTITLE: Advanced Fixed-Point Attributes with passthru in Nix mkDerivation\nDESCRIPTION: This more elaborate example demonstrates various ways to use finalAttrs in a package definition, including implementing test functions, creating override helpers, and exposing internal attributes for debugging or extension purposes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n# `pkg` is the _original_ definition (for illustration purposes)\nlet\n  pkg = mkDerivation (finalAttrs: {\n    # ...\n\n    # An example attribute\n    packages = [ ];\n\n    # `passthru.tests` is a commonly defined attribute.\n    passthru.tests.simple = f finalAttrs.finalPackage;\n\n    # An example of an attribute containing a function\n    passthru.appendPackages =\n      packages':\n      finalAttrs.finalPackage.overrideAttrs (\n        newSelf: super: {\n          packages = super.packages ++ packages';\n        }\n      );\n\n    # For illustration purposes; referenced as\n    # `(pkg.overrideAttrs(x)).finalAttrs` etc in the text below.\n    passthru.finalAttrs = finalAttrs;\n    passthru.original = pkg;\n  });\nin\npkg\n```\n\n----------------------------------------\n\nTITLE: Running a Docker Container to Display Custom shellHook Output - Shell\nDESCRIPTION: This shell snippet demonstrates running an interactive shell within the custom Docker image to see the effect of a custom shellHook (which echoes 'Hello, world!'). It is primarily used for verification that image initialization logic is working. This requires the built and loaded Docker image incorporating the shellHook changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_43\n\nLANGUAGE: shell\nCODE:\n```\n$ docker container run -it hello-2.12.1-env:latest\nHello, world!\n\n[nix-shell:~]$\n```\n\n----------------------------------------\n\nTITLE: Setting Keyboard Layout in NixOS Console\nDESCRIPTION: Demonstrates how to set the Programmer Dvorak Keyboard Layout for the console in NixOS after the removal of the kbdKeymaps package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\nconsole.keyMap = \"dvorak-programmer\";\n```\n\n----------------------------------------\n\nTITLE: Overriding CUDA Package Set Version in Nix - Nix\nDESCRIPTION: This Nix code shows how to use 'callPackage' to override dependencies, specifically to use an alternative CUDA toolkit version via the 'cudaPackages' parameter. By injecting a specific package set such as 'cudaPackages_11_5', this pattern allows per-package control over CUDA versions and dependencies. It requires that the desired CUDA package set (e.g., 'cudaPackages_11_5') is available within the Nixpkgs context.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mypkg = callPackage { cudaPackages = cudaPackages_11_5; };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Root Login to a NixOS Container - ShellSession\nDESCRIPTION: This snippet illustrates root login into the 'foo' container from the host without authentication using the root-login operation. Only host root can use this operation. Provides a root shell prompt inside the container, bypassing login mechanisms.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container root-login foo\n[root@foo:~]#\n```\n\n----------------------------------------\n\nTITLE: Deleting Old Generations from a Nix Profile (Shell - ShellSession)\nDESCRIPTION: This command deletes old generations from a specific Nix profile to conserve disk space and clean up user or system environments. It specifies the profile path with -p and removes all generations labeled 'old'. Requires the profile path and appropriate permissions. Outputs a summary of what was deleted.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ nix-env -p /nix/var/nix/profiles/per-user/eelco/profile --delete-generations old\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Dokuwiki Single-Instance Service - Nix - Nix\nDESCRIPTION: Shows the original way of configuring the Dokuwiki service as a single instance prior to the multi-instancing change. The snippet requires the NixOS module system, and the parameter 'enable' controls service activation. The configuration should fit within a larger NixOS configuration file. Outputs a working Dokuwiki service using default SSL and web options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.dokuwiki = {\n    enable = true;\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple SOCKS Proxies Named Instances with NixOS Services (Nix)\nDESCRIPTION: This snippet illustrates how to declare named SOCKS proxy instances with the `services.nylon` module in a NixOS configuration, as required from release 17.03. Each proxy is now defined by a distinct attribute, allowing multiple proxies. Inputs are the instance names and option sets for each; outputs are systemd service declarations corresponding to each instance. Requires NixOS 17.03 or later. The format is more flexible, supporting multiple proxies per system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1703.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nylon.myvpn = {\n    enable = true;\n    acceptInterface = \"br0\";\n    bindInterface = \"tun1\";\n    port = 5912;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Systemd Service Options (Nix - nix)\nDESCRIPTION: Shows how to override systemd service unit options within your NixOS configuration. It requires knowledge of systemd services and Nix attribute sets. The foo refers to the service name being customized. Input: Attribute set for a specific service. Output: Adjusted service dependencies and configuration such as startup targets and memory limits.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.foo.wantedBy = [ \"multi-user.target\" ];\n  systemd.services.foo.serviceConfig.MemoryLimit = \"512M\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Nix Flake for Darwin Builder and NixOS VM - Nix\nDESCRIPTION: Comprehensive Nix flake example specifying inputs, outputs, and configuration for a darwin.linux-builder VM and darwinSystem. Shows how to customize VM, set up build machines, and create a launchd daemon for the builder. Dependencies include nixpkgs and nix-darwin. Required for advanced users wanting automatic build delegation and VM lifecycle management in a reproducible way.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixpkgs-22.11-darwin\";\n    darwin.url = \"github:lnl7/nix-darwin/master\";\n    darwin.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs =\n    {\n      self,\n      darwin,\n      nixpkgs,\n      ...\n    }@inputs:\n    let\n\n      inherit (darwin.lib) darwinSystem;\n      system = \"aarch64-darwin\";\n      pkgs = nixpkgs.legacyPackages.\"${system}\";\n      linuxSystem = builtins.replaceStrings [ \"darwin\" ] [ \"linux\" ] system;\n\n      darwin-builder = nixpkgs.lib.nixosSystem {\n        system = linuxSystem;\n        modules = [\n          \"${nixpkgs}/nixos/modules/profiles/nix-builder-vm.nix\"\n          {\n            virtualisation = {\n              host.pkgs = pkgs;\n              darwin-builder.workingDirectory = \"/var/lib/darwin-builder\";\n              darwin-builder.hostPort = 22;\n            };\n          }\n        ];\n      };\n    in\n    {\n\n      darwinConfigurations = {\n        machine1 = darwinSystem {\n          inherit system;\n          modules = [\n            {\n              nix.distributedBuilds = true;\n              nix.buildMachines = [\n                {\n                  hostName = \"localhost\";\n                  sshUser = \"builder\";\n                  sshKey = \"/etc/nix/builder_ed25519\";\n                  system = linuxSystem;\n                  maxJobs = 4;\n                  supportedFeatures = [\n                    \"kvm\"\n                    \"benchmark\"\n                    \"big-parallel\"\n                  ];\n                }\n              ];\n\n              launchd.daemons.darwin-builder = {\n                command = \"${darwin-builder.config.system.build.macos-builder-installer}/bin/create-builder\";\n                serviceConfig = {\n                  KeepAlive = true;\n                  RunAtLoad = true;\n                  StandardOutPath = \"/var/log/darwin-builder.log\";\n                  StandardErrorPath = \"/var/log/darwin-builder.log\";\n                };\n              };\n            }\n          ];\n        };\n      };\n\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Migrating SSMTP to MSMTP in NixOS Configuration - Nix\nDESCRIPTION: This snippet demonstrates how to migrate a mail delivery agent configuration from the deprecated ssmtp service to the recommended msmtp implementation in a NixOS configuration block. It shows both the original ssmtp configuration and its equivalent using the msmtp declarative module. Dependencies include the 'programs.msmtp' and 'services.ssmtp' NixOS modules. Input parameters such as 'enable', 'hostName', and authentication credentials are provided. Outputs are changed system mail settings; care should be taken to update any secret file references and adapt options such as TLS/STARTTLS according to new parameter names.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Original ssmtp configuration:\n  services.ssmtp = {\n    enable = true;\n    useTLS = true;\n    useSTARTTLS = true;\n    hostName = \"smtp.example:587\";\n    authUser = \"someone\";\n    authPassFile = \"/secrets/password.txt\";\n  };\n\n  # Equivalent msmtp configuration:\n  programs.msmtp = {\n    enable = true;\n    accounts.default = {\n      tls = true;\n      tls_starttls = true;\n      auth = true;\n      host = \"smtp.example\";\n      port = 587;\n      user = \"someone\";\n      passwordeval = \"cat /secrets/password.txt\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Kernel dmesg Restrictions in NixOS\nDESCRIPTION: Sets a kernel sysctl parameter to disable restrictions on unprivileged access to the kernel syslog via dmesg.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nboot.kernel.sysctl.\"kernel.dmesg_restrict\" = false;\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions Workflow for PR Mergeability Check - YAML\nDESCRIPTION: This YAML snippet is a reusable GitHub Actions workflow configuration that triggers on pull_request_target events to check if a pull request can be merged and subsequently builds the merged commit. The workflow requires minimal permissions and uses job dependencies and output propagation (using outputs.mergedSha) to control build execution. Key parameters include specifying the workflow YAML path, referencing the merged commit SHA, and conditional step execution. This workflow ensures that CI jobs run against the actual merge result, improving reliability of tests and checks. Required dependency: a valid GitHub Actions runner with access to the specified workflow and repository.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/ci/README.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\non: pull_request_target\\n\\n# We need a token to query the API, but it doesn't need any special permissions\\npermissions: {}\\n\\njobs:\\n  get-merge-commit:\\n    # use the relative path of the get-merge-commit workflow yaml here\\n    uses: ./.github/workflows/get-merge-commit.yml\\n\\n  build:\\n    name: Build\\n    runs-on: ubuntu-24.04\\n    needs: get-merge-commit\\n    steps:\\n      - uses: actions/checkout@<VERSION>\\n        # Add this to _all_ subsequent steps to skip them\\n        if: needs.get-merge-commit.outputs.mergedSha\\n        with:\\n          ref: ${{ needs.get-merge-commit.outputs.mergedSha }}\\n      - ...\\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Emacs Package in configuration.nix - NixOS - Nix\nDESCRIPTION: This Nix code adds a custom Emacs built via emacs.nix as a system package within NixOS by modifying configuration.nix. The 'import ./emacs.nix { inherit pkgs; }' expression builds the previously defined Emacs derivation and includes it in environment.systemPackages. This approach integrates custom-built Emacs globally for all users via nixos-rebuild. Requires NixOS and an emacs.nix file in the specified directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n environment.systemPackages = [\n   # [...]\n   (import ./emacs.nix { inherit pkgs; })\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Basic NixOS Package Documentation Configuration\nDESCRIPTION: Initial configuration for including documentation outputs in NixOS packages. Sets up package overrides with paths and outputs specifically for documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides =\n    pkgs: with pkgs; {\n      myPackages = pkgs.buildEnv {\n        name = \"my-packages\";\n        paths = [\n          aspell\n          bc\n          coreutils\n          ffmpeg\n          nix\n          emscripten\n          jq\n          nox\n          silver-searcher\n        ];\n        pathsToLink = [\n          \"/share/man\"\n          \"/share/doc\"\n          \"/bin\"\n        ];\n        extraOutputsToInstall = [\n          \"man\"\n          \"doc\"\n        ];\n      };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Test Execution for Haskell Packages\nDESCRIPTION: Functions to enable, disable, or conditionally disable test execution for Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_25\n\nLANGUAGE: nix\nCODE:\n```\ndoCheck drv\ndontCheck drv\ndontCheckIf condition drv\n```\n\n----------------------------------------\n\nTITLE: Overlay for Using Local rustc Source in Nixpkgs (Bisect/Debug Rust) - Nix\nDESCRIPTION: This overlay injects a local git checkout of the Rust compiler (`rustc`) source into the build of the rust_1_72 package, useful for performing git bisect or local debugging. It uses lib.updateManyAttrsByPath to override the source path for rustc-unwrapped. Intended for debugging and custom build workflows where the Rust compiler source is checked out in `/git/scratch/rust`. Should be used with care as it disables some build-time checks and is not suitable for production derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_36\n\nLANGUAGE: nix\nCODE:\n```\n(\n  final: prev: # lib.optionalAttrs prev.stdenv.targetPlatform.isAarch64\n  {\n    rust_1_72 = lib.updateManyAttrsByPath [\n      {\n        path = [\n          \"packages\"\n          \"stable\"\n        ];\n        update =\n          old:\n          old.overrideScope (\n            final: prev: {\n              rustc-unwrapped = prev.rustc-unwrapped.overrideAttrs (_: {\n                src = lib.cleanSource /git/scratch/rust;\n                # do *not* put passthru.isReleaseTarball=true here\n              });\n            }\n          );\n      }\n    ] prev.rust_1_72;\n  })\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Sourcehut Services and Nginx Reverse Proxy on NixOS (Nix)\nDESCRIPTION: This NixOS module snippet demonstrates how to configure and enable Sourcehut and integrate it with nginx, redis, postfix, postgresql, ACME (for TLS certificates), and firewall settings. Required dependencies include the specified NixOS services (nginx, redis, postfix, postgresql), and key files for secure operations must be present at the referenced paths. Users must provide appropriate FQDN/domain inputs and manage certificate resources. The configuration expects information for secrets and enables several recommended nginx settings; outputs are in the form of systemd service and nginx configuration updates. Limitations: assumes all reference services and keys are available, and settings must match your system's domain configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/sourcehut/default.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\nlet\n  fqdn =\n    let\n      join = hostName: domain: hostName + optionalString (domain != null) \".${domain}\";\n    in join config.networking.hostName config.networking.domain;\nin {\n\n  networking = {\n    hostName = \"srht\";\n    domain = \"tld\";\n    firewall.allowedTCPPorts = [ 22 80 443 ];\n  };\n\n  services.sourcehut = {\n    enable = true;\n    git.enable = true;\n    man.enable = true;\n    meta.enable = true;\n    nginx.enable = true;\n    postfix.enable = true;\n    postgresql.enable = true;\n    redis.enable = true;\n    settings = {\n        \"sr.ht\" = {\n          environment = \"production\";\n          global-domain = fqdn;\n          origin = \"https://${fqdn}\";\n          # Produce keys with srht-keygen from sourcehut.coresrht.\n          network-key = \"/run/keys/path/to/network-key\";\n          service-key = \"/run/keys/path/to/service-key\";\n        };\n        webhooks.private-key= \"/run/keys/path/to/webhook-key\";\n    };\n  };\n\n  security.acme.certs.\"${fqdn}\".extraDomainNames = [\n    \"meta.${fqdn}\"\n    \"man.${fqdn}\"\n    \"git.${fqdn}\"\n  ];\n\n  services.nginx = {\n    enable = true;\n    # only recommendedProxySettings are strictly required, but the rest make sense as well.\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n    recommendedProxySettings = true;\n\n    # Settings to setup what certificates are used for which endpoint.\n    virtualHosts = {\n      \"${fqdn}\".enableACME = true;\n      \"meta.${fqdn}\".useACMEHost = fqdn;\n      \"man.${fqdn}\".useACMEHost = fqdn;\n      \"git.${fqdn}\".useACMEHost = fqdn;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling systemd-sysusers for User and Group Creation - Nix - nix\nDESCRIPTION: This declarative Nix snippet enables the 'systemd.sysusers' service for user and group management, removing the default Perl script dependency. Usage: set 'systemd.sysusers.enable = true;' in 'configuration.nix'. No parameters other than 'enable' are required. Suitable for environments aiming to minimize dependencies or leverage systemd features. Note: This method may lack the advanced features of Userborn and may be considered experimental.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.sysusers.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Using buildBowerComponents Function in Nix\nDESCRIPTION: Example of using the buildBowerComponents function in a Nix expression. It specifies the name of the web app, the generated bower-packages.nix file, and the source of the project.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/bower.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  bowerComponents = buildBowerComponents {\n    name = \"my-web-app\";\n    generated = ./bower-packages.nix; # note 1\n    src = myWebApp; # note 2\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling /etc Overlay Filesystem in NixOS\nDESCRIPTION: Activates the overlay filesystem for /etc management instead of using the default perl script. This configuration enables faster activation and removes the perl dependency.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/etc-overlay.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.etc.overlay.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Static glibc Only When Needed with lib.optionals - Nix\nDESCRIPTION: This block conditionally appends the static glibc output to buildInputs when targeting platforms using glibc. This solves linking errors due to missing static libraries by ensuring 'stdenv.cc.libc.static' is available for static linking. Utilizes 'lib.optionals' to control inclusion; requires 'lib', 'stdenv', and their sub-attributes in the derivation's scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/cross-compilation.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = lib.optionals (stdenv.hostPlatform.libc == \"glibc\") [ stdenv.cc.libc.static ];\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS XServer Configuration - XKB Options\nDESCRIPTION: Example of the reorganized X keyboard extension (XKB) configuration options under services.xserver.xkb\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nservices.xserver.xkb.layout\nservices.xserver.xkb.extraLayouts\nservices.xserver.xkb.model\nservices.xserver.xkb.options\nservices.xserver.xkb.variant\nservices.xserver.xkb.dir\n```\n\n----------------------------------------\n\nTITLE: Overriding Arguments When Building Julia Environments with julia.withPackages (Nix)\nDESCRIPTION: This snippet shows how to customize the Julia environment creation process by using the `.override` function on `julia.withPackages`, specifically setting `precompile = false` to disable pre-compilation. This prevents execution of Pkg.precompile(), which may fail for certain packages in sandboxed scenarios. All other arguments are inherited as defaults. The function takes an attribute set of overrides and a list of packages, returning a derivation for the customized environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/julia.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n(julia.withPackages.override {\n  precompile = false; # Turn off precompilation\n})\n  [ \"Plots\" ]\n```\n\n----------------------------------------\n\nTITLE: Disabling AVX Support for DLib in NixOS\nDESCRIPTION: This Nix code snippet demonstrates how to override the default DLib configuration to disable AVX support. This is necessary for older CPUs that don't support Advanced Vector Extensions, preventing 'Illegal instruction' errors.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/dlib.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nself: super: { dlib = super.dlib.override { avxSupport = false; }; }\n```\n\n----------------------------------------\n\nTITLE: Building NixOS Configuration as Next Boot Default - ShellSession\nDESCRIPTION: This snippet builds the given NixOS configuration and makes it the default for the next boot, but does not activate it immediately. Run as root for correct permissions. Input: None; Output: The new configuration will be applied after system reboot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild boot\n```\n\n----------------------------------------\n\nTITLE: Configuring Keycloak Service with Deprecated and Updated Nix Syntax - Nix DSL - Nix\nDESCRIPTION: These code snippets show how to migrate Keycloak service configurations in NixOS from the old attribute-based syntax to the new, cleaner settings-style syntax. The old approach includes legacy attributes like 'extraConfig', 'frontendUrl', and 'httpPort', which are replaced with a unified 'settings' block and updated database credentials handling. Dependencies include the core Nix language and NixOS module system, with expected inputs as an attribute set mapping configuration keys to their respective values. Outputs are effective Keycloak system settings on the deployed system. These snippets require NixOS 22.05 or later for compatibility with new syntax, and secrets should be provided via secure files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.keycloak = {\n    enable = true;\n    httpPort = \"8080\";\n    frontendUrl = \"https://keycloak.example.com/auth\";\n    database.passwordFile = \"/run/keys/db_password\";\n    extraConfig = {\n      \"subsystem=undertow\".\"server=default-server\".\"http-listener=default\".proxy-address-forwarding = true;\n    };\n  };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.keycloak = {\n    enable = true;\n    settings = {\n      http-port = 8080;\n      hostname = \"keycloak.example.com\";\n      http-relative-path = \"/auth\";\n      proxy = \"edge\";\n    };\n    database.passwordFile = \"/run/keys/db_password\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Built JAR Output Directory - Bash Language\nDESCRIPTION: Displays the output directory structure after building a Maven JAR with Nix. It uses tree and nix-build to show where the resulting Java archive resides, validating the final installation path is under $out/share/java. Requires build-jar.nix and tree to be present.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n❯ tree $(nix-build --no-out-link build-jar.nix)/\n/nix/store/7jw3xdfagkc2vw8wrsdv68qpsnrxgvky-maven-demo-1.0\n└── share\n    └── java\n        └── maven-demo-1.0.jar\n\n2 directories, 1 file\n\n```\n\n----------------------------------------\n\nTITLE: Constructing a NixOS System with Preexisting Nixpkgs - Nix - Nix\nDESCRIPTION: This snippet demonstrates how to construct a NixOS system using an existing invocation of Nixpkgs, leveraging module arguments such as boot.loader.grub.enable and fileSystems configuration. The example uses the Nix language and shows how to inherit top-level attributes such as 'toplevel', 'kernel', 'initialRamdisk', and 'manual' from the result of invoking pkgs.nixos. This approach improves evaluation performance and standardizes deployment architectures using Nixpkgs overlays. Inputs include the desired system configuration and outputs the constructed system derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1809.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  inherit (pkgs.nixos {\n    boot.loader.grub.enable = false;\n    fileSystems.\"/\".device = \"/dev/xvda1\";\n  }) toplevel kernel initialRamdisk manual;\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding System with Custom Nixpkgs Path (Shell, ShellSession)\nDESCRIPTION: This shell session snippet runs the NixOS system rebuild using a custom Nixpkgs repository via the -I flag. It integrates and activates changes in the user-specified Nixpkgs tree. Dependency: Operational NixOS system. Parameter: path to custom Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch -I nixpkgs=/path/to/my/nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Shell Conditional Echo Example in Bash - Bash\nDESCRIPTION: This Bash snippet shows a simple conditional where, if the test 'true' evaluates as successful, the message 'hi' is echoed. This example is used in the documentation to illustrate non-Nix-representable configuration: Bash scripts are not directly transferable to Nix syntax, thus require alternative handling in the Nixpkgs configuration system. The snippet depends only on a Bash shell, takes no arguments, and prints 'hi' if the condition passes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nif true; then echo hi; fi\n```\n\n----------------------------------------\n\nTITLE: Building Netboot Artifacts with Nix - Shell\nDESCRIPTION: This snippet demonstrates how to build the NixOS netboot installer artifacts using the nix-build command. It depends on having the nixpkgs source, Nix toolchain, and system compatibility (x86_64-linux). The primary input is the 'netboot.x86_64-linux' derivation from the specified NixOS release.nix. The command outputs a directory named 'result' which contains the kernel (bzImage), initrd, and an example iPXE script (netboot.ipxe). All dependencies and output locations are managed by Nix; ensure that '<nixpkgs/nixos/release.nix>' correctly resolves in your environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-pxe.section.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnix-build -A netboot.x86_64-linux '<nixpkgs/nixos/release.nix>'\n```\n\n----------------------------------------\n\nTITLE: Generating Virtual Host Configurations with a Function in Nix\nDESCRIPTION: This snippet defines a function makeVirtualHost to abstract and reuse virtual host configuration. The function takes a webroot argument and constructs the appropriate attribute set. Multiple virtual hosts are defined by passing different webroot arguments to the function. No external dependencies are required except knowledge of functions and attribute sets in Nix. Key parameters are the webroot (input) and server name. Outputs are per-host attribute sets suitable for NixOS module services. This approach greatly increases scalability and reduces code repetition when managing many similar virtual hosts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/abstractions.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.virtualHosts =\n    let\n      makeVirtualHost = webroot:\n        { documentRoot = webroot;\n          adminAddr = \"alice@example.org\";\n          forceSSL = true;\n          enableACME = true;\n        };\n    in\n      { \"example.org\" = (makeVirtualHost \"/webroot/example.org\");\n        \"example.com\" = (makeVirtualHost \"/webroot/example.com\");\n        \"example.gov\" = (makeVirtualHost \"/webroot/example.gov\");\n        \"example.nl\" = (makeVirtualHost \"/webroot/example.nl\");\n      };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PHP-FPM Pool with Custom PHP in NixOS\nDESCRIPTION: Demonstrates how to set up a PHP-FPM pool named 'foo' using a custom PHP configuration with specific extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  myPhp = php.withExtensions (\n    { all, ... }:\n    with all;\n    [\n      imagick\n      opcache\n    ]\n  );\nin\n{\n  services.phpfpm.pools.\"foo\".phpPackage = myPhp;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GOPROXY for Nix Daemon\nDESCRIPTION: Configuration to set GOPROXY environment variable in the nix-daemon systemd unit for Go builds within Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/athens.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.nix-daemon.environment.GOPROXY = \"http://localhost:3000\";\n}\n```\n\n----------------------------------------\n\nTITLE: Including Image Tool Documentation Sections using Markdown/Sphinx Directives (Markdown)\nDESCRIPTION: This snippet uses the Sphinx `{=include=}` Markdown directive to import multiple documentation sections into the current file. It pulls in six separate markdown files, each pertaining to a different image creation tool or process within the Nixpkgs documentation system. No explicit dependencies are required beyond a Sphinx/Markdown parser that recognizes the `{=include=}` syntax; the primary input is a list of referenced markdown files, and the output is an assembled documentation chapter with all included content.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\nimages/appimagetools.section.md\nimages/dockertools.section.md\nimages/ocitools.section.md\nimages/portableservice.section.md\nimages/makediskimage.section.md\nimages/binarycache.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding Node.js package in nixpkgs\nDESCRIPTION: Shows how to override a Node.js package (dat) in nixpkgs to add build inputs and mark it as broken for certain Node versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dat = prev.dat.override (oldAttrs: {\n    buildInputs = [\n      final.node-gyp-build\n      pkgs.libtool\n      pkgs.autoconf\n      pkgs.automake\n    ];\n    meta = oldAttrs.meta // {\n      broken = since \"12\";\n    };\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Build Phases up to Check Phase - Bash\nDESCRIPTION: This command defines a complex phases sequence combining pre- and standard phases for deeper build debugging in nix-shell, up to and including checkPhase. It provides granular control over staging the build and isolating failures. Use inside the nix-shell with the expected variables and functions already provided.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nphases=\"${preConfigurePhases[*]:-} configurePhase ${preBuildPhases[*]:-} buildPhase checkPhase\" genericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Providing Extra Build Flags for SwiftPM in Nix Derivation\nDESCRIPTION: This snippet demonstrates how to supply additional flags to the SwiftPM build command ('swift build') via the `swiftpmFlags` attribute in a Nix derivation. The 'swiftpmFlags' list accepts arbitrary command-line flags understood by 'swift build'. It can be used alongside or instead of the default configuration in build attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  swiftpmFlags = [ \"--disable-dead-strip\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Maven Project with Dependency - Maven POM XML\nDESCRIPTION: A minimal Maven POM (Project Object Model) file setting up a Java project ('maven-demo') with a single external dependency on emoji-java. Establishes the necessary metadata and dependencies for a Java JAR project suitable for use with Maven and compatible tools. Must be saved as pom.xml and requires Maven for building.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>io.github.fzakaria</groupId>\n  <artifactId>maven-demo</artifactId>\n  <version>1.0</version>\n  <packaging>jar</packaging>\n  <name>NixOS Maven Demo</name>\n\n  <dependencies>\n    <dependency>\n        <groupId>com.vdurmont</groupId>\n        <artifactId>emoji-java</artifactId>\n        <version>5.1.1</version>\n      </dependency>\n  </dependencies>\n</project>\n\n```\n\n----------------------------------------\n\nTITLE: Setup Hook Example (Bash)\nDESCRIPTION: Example showing how to add environment hooks in setup scripts\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\naddEnvHooks \"$hostOffset\" myBashFunction\n```\n\n----------------------------------------\n\nTITLE: Accessing Final Package Attributes in NixOS\nDESCRIPTION: This snippet demonstrates how the 'passthru' attribute can now reference 'finalAttrs.finalPackage' to access the final package's attributes, including output paths and 'overrideAttrs'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\npassthru.finalAttrs.finalPackage\n```\n\n----------------------------------------\n\nTITLE: Defining a Solo5 Package with Dependencies in Nix\nDESCRIPTION: A simplified derivation for the Solo5 sandboxing tool demonstrating the use of various dependency attributes including nativeBuildInputs, buildInputs, and nativeCheckInputs. The example shows how to handle build-time dependencies, runtime dependencies, and test dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"solo5\";\n  version = \"0.7.5\";\n\n  src = fetchurl {\n    url = \"https://github.com/Solo5/solo5/releases/download/v${finalAttrs.version}/solo5-v${finalAttrs.version}.tar.gz\";\n    hash = \"sha256-viwrS9lnaU8sTGuzK/+L/PlMM/xRRtgVuK5pixVeDEw=\";\n  };\n\n  nativeBuildInputs = [\n    makeWrapper\n    pkg-config\n  ];\n\n  buildInputs = [ libseccomp ];\n\n  postInstall = ''\n    substituteInPlace $out/bin/solo5-virtio-mkimage \\\n      --replace-fail \"/usr/lib/syslinux\" \"${syslinux}/share/syslinux\" \\\n      --replace-fail \"/usr/share/syslinux\" \"${syslinux}/share/syslinux\" \\\n      --replace-fail \"cp \" \"cp --no-preserve=mode \"\n\n    wrapProgram $out/bin/solo5-virtio-mkimage \\\n      --prefix PATH : ${\n        lib.makeBinPath [\n          dosfstools\n          mtools\n          parted\n          syslinux\n        ]\n      }\n  '';\n\n  doCheck = true;\n  nativeCheckInputs = [\n    util-linux\n    qemu\n  ];\n  checkPhase = ''[elided]'';\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Radicale Service in NixOS\nDESCRIPTION: Demonstrates how to configure the Radicale service in NixOS, including hardening the systemd unit and specifying custom filesystem paths.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\nsystemd.services.radicale.serviceConfig.ReadWritePaths = [ \"/path/to/custom/filesystem_folder\" ];\n```\n\n----------------------------------------\n\nTITLE: Accessing Option Declaration Positions in Nix REPL\nDESCRIPTION: Demonstrates how to access the 'declarationPositions' attribute of an option in the NixOS module system using the Nix REPL. This new feature allows users to see where an option was declared in the source code.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n$ nix-repl -f '<nixpkgs/nixos>' [...]\nnix-repl> :p options.environment.systemPackages.declarationPositions\n[ {\n  column = 7;\n  file = \"/nix/store/vm9zf9wvfd628cchj0hdij1g4hzjrcz9-source/nixos/modules/config/system-path.nix\";\n  line = 62;\n} ]\n```\n\n----------------------------------------\n\nTITLE: Generating Nix Expressions from Tarball Lists with Perl Script - ShellSession\nDESCRIPTION: This snippet changes the working directory into the X.org packaging directory within Nixpkgs and invokes a Perl script to generate Nix expressions from the tarballs.list file. The script processes each tarball, analyzes files for dependencies, and produces default.nix, caching downloads to avoid redundancy. Requires Perl, access to tarballs.list, and Nix build tools. Input is expected as a sorted tarball list; output is an autogenerated Nix expression. Watch for missing dependency warnings in script output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/xorg.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\ncd pkgs/servers/x11/xorg\n<tarballs.list perl ./generate-expr-from-tarballs.pl\n```\n\n----------------------------------------\n\nTITLE: Querying Configuration Values with nixos-option - Shell Session\nDESCRIPTION: This snippet demonstrates the use of nixos-option to check current values of configuration options on a NixOS system. Dependencies: nixos-option must be installed and available in $PATH. Input: Option names; Output: The current value(s) in the live configuration. Suitable for interactive inspection or debugging.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_6\n\nLANGUAGE: shellsession\nCODE:\n```\n$ nixos-option services.xserver.enable\ntrue\n\n$ nixos-option boot.kernelModules\n[ \"tun\" \"ipv6\" \"loop\" ... ]\n```\n\n----------------------------------------\n\nTITLE: Entering a NixOS Installation Environment\nDESCRIPTION: Commands to start a login shell in a newly installed NixOS system located in the /mnt directory. This allows testing and verification of the installed system without rebooting.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-installer.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build '<nixpkgs>' -A nixos-enter\n# ./result/bin/nixos-enter\n```\n\n----------------------------------------\n\nTITLE: Enabling Digital Bitbox Hardware Support - NixOS - Nix\nDESCRIPTION: Enables the necessary udev rules and hardware access for Digital Bitbox devices by setting \"hardware.digitalbitbox.enable\" to true in a NixOS configuration. This is required for the OS to recognize and correctly manage the hardware wallet device. The only parameter is the enablement flag, and it requires the Digital Bitbox hardware package to be available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/digitalbitbox/default.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.digitalbitbox.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending AppImage-Runtime with Extra Packages (Nix, nix)\nDESCRIPTION: Demonstrates overriding appimage-run to provide additional runtime libraries for AppImage executables. Uses extraPkgs with pkgs to list missing dependencies. Inputs: list of required packages. Output: customized appimage-run environment. Prerequisite: pkgs.appimage-run in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  programs.appimage.package = pkgs.appimage-run.override {\\n    extraPkgs = pkgs: [\\n      # missing libraries here, e.g.: `pkgs.libepoxy`\\n    ];\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Importing GPG Private Keyring - ShellSession\nDESCRIPTION: This command imports the legacy GnuPG secret keyring (`secring.gpg`) into the current keyring. Needed if the automatic migration of older GnuPG private keys fails and you must recover your key material after upgrading GnuPG. Must be run in a shell with correct permissions and where `~/.gnupg/secring.gpg` exists.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\ngpg --import ~/.gnupg/secring.gpg\n```\n\n----------------------------------------\n\nTITLE: Inspecting Generated JAR Manifest\nDESCRIPTION: Bash command to extract and view the generated MANIFEST.MF file from the built JAR, showing the configured classpath entries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n❯ unzip -q -c $(nix-build --no-out-link runnable-jar.nix)/share/java/maven-demo-1.0.jar META-INF/MANIFEST.MF\n\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nBuilt-By: nixbld\nClass-Path: . ../../repository/com/vdurmont/emoji-java/5.1.1/emoji-jav\n a-5.1.1.jar ../../repository/org/json/json/20170516/json-20170516.jar\nCreated-By: Apache Maven 3.6.3\nBuild-Jdk: 1.8.0_265\nMain-Class: Main\n```\n\n----------------------------------------\n\nTITLE: Customizing RetroArch Build with Selected Libretro Cores - Nix Expression Language\nDESCRIPTION: This Nix expression demonstrates how to create a customized RetroArch derivation with only specific Libretro cores (bsnes, mgba, quicknes) included, instead of the complete set available in retroarch-full. It uses the withCores function on pkgs.retroarch to select cores and provides this configuration through environment.systemPackages. To use this snippet, access the specified cores from the pkgs tree, and ensure that all required cores are available in the Nixpkgs package set. The primary input is a list of core packages and the output is a user environment with the customized RetroArch build. Limitations include the exact set of available cores and potential dependency mismatches if the named cores are not present.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/emulators/libretro/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n\nlet\n  retroarchWithCores = (pkgs.retroarch.withCores (cores: with cores; [\n    bsnes\n    mgba\n    quicknes\n  ]));\nin\n{\n  environment.systemPackages = [\n    retroarchWithCores\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring vwifi Server Node - NixOS - Nix\nDESCRIPTION: This NixOS configuration snippet creates a node acting purely as a vwifi server without networking interaction, meant to simulate a wireless physical layer for use in Wi-Fi related tests. The node is given a static IP address, and its firewall port for vwifi is opened. Required dependencies include the NixOS vwifi module and network configuration. Users can optionally enable monitor mode for another node by setting 'ports.spy'. Inputs include the server's IP and other interface options; there is no output except for the operational server instance. This config should be placed inside a NixOS test suite or machine definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-hardware-features.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nairgap =\n  { config, ... }:\n  {\n    networking.interfaces.eth1.ipv4.addresses = lib.mkForce [\n      {\n        address = \"192.168.1.2\";\n        prefixLength = 24;\n      }\n    ];\n    services.vwifi = {\n      server = {\n        enable = true;\n        ports.tcp = 8212;\n        # uncomment if you want to enable monitor mode on another node\n        # ports.spy = 8213;\n        openFirewall = true;\n      };\n    };\n  };\n```\n\n----------------------------------------\n\nTITLE: Importing TensorRT Module in Nix\nDESCRIPTION: This snippet demonstrates how to import the TensorRT module, which extends the generic module for release expressions with additional fields. It showcases the use of relative imports in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/modules/README.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n./tensorrt/default.nix\n```\n\n----------------------------------------\n\nTITLE: Overriding PHP Packages in Nix\nDESCRIPTION: Demonstrates how to override PHP packages, specifically applying a patch to the mysqlnd extension using an overlay-style function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nphp.override {\n  packageOverrides = final: prev: {\n    extensions = prev.extensions // {\n      mysqlnd = prev.extensions.mysqlnd.overrideAttrs (attrs: {\n        patches = attrs.patches or [ ] ++ [\n          # ...\n        ];\n      });\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Default Kanidm Package Reference - Shell\nDESCRIPTION: This sed command updates references from the previous Kanidm version to the new version within the package.nix file. It searches for all instances of the old version string (e.g. 1_4) and replaces them with the new version (e.g. 1_5). The file must exist and be writable, and the command performs the replacement in-place. This step is crucial for ensuring that the new version is used as the default during package builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ka/kanidm/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsed -i 's/1_4/1_5/' pkgs/by-name/ka/kanidm/package.nix\n```\n\n----------------------------------------\n\nTITLE: Setting PulseAudio Resample Method in NixOS Configuration\nDESCRIPTION: This configuration sets the PulseAudio resample method to 'speex-float-1' for low-powered ARM and MIPS boards in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nhardware.pulseaudio.daemon.config.resample-method = \"speex-float-1\";\n```\n\n----------------------------------------\n\nTITLE: Configuring External Containerd with ZFS Support\nDESCRIPTION: NixOS configuration for setting up external containerd with ZFS snapshot support and custom CNI plugins.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nvirtualisation.containerd = {\n  enable = true;\n  settings =\n    let\n      fullCNIPlugins = pkgs.buildEnv {\n        name = \"full-cni\";\n        paths = with pkgs;[\n          cni-plugins\n          cni-plugin-flannel\n        ];\n      };\n    in {\n      plugins.\"io.containerd.grpc.v1.cri\".cni = {\n        bin_dir = \"${fullCNIPlugins}/bin\";\n        conf_dir = \"/var/lib/rancher/k3s/agent/etc/cni/net.d/\";\n      };\n      # Optionally set private registry credentials here instead of using /etc/rancher/k3s/registries.yaml\n      # plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"registry.example.com\".auth = {\n      #  username = \"\";\n      #  password = \"\";\n      # };\n    };\n};\n# TODO describe how to enable zfs snapshotter in containerd\nservices.k3s.extraFlags = toString [\n  \"--container-runtime-endpoint unix:///run/containerd/containerd.sock\"\n];\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Documentation Root\nDESCRIPTION: Shows how to specify a custom documentation root path for sphinxHook when the default paths cannot be found automatically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_43\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Configure sphinxRoot for uncommon paths\n  sphinxRoot = \"weird/docs/path\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a shellHook to a Docker Image Using streamNixShellImage - Nix\nDESCRIPTION: This Nix snippet shows how to inject a shellHook initialization command into a Docker image's environment by overriding the original derivation's shellHook attribute. It demonstrates appending a custom command to any existing shellHook, ensuring backward compatibility. Prerequisites include knowledge of how shellHook works in Nix shells and the ability to override derivation attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_41\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.streamNixShellImage {\n  tag = \"latest\";\n  drv = hello.overrideAttrs (old: {\n    shellHook = ''\n      ${old.shellHook or \"\"}\n      echo \"Hello, world!\"\n    '';\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Federation and Moderation Policies for Akkoma - Nix\nDESCRIPTION: This snippet sets up federation policies and moderation rules for Akkoma using the mrf_simple module. It lists which hosts to tag as NSFW, reject, or set followers-only, and includes relevant rationales. Dependencies are pkgs.formats.elixirConf and mkRaw for proper Elixir config output. Inputs are target domains and the desired behavior per domain, resulting in content moderation across the fediverse.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.akkoma.config.\":pleroma\" = with (pkgs.formats.elixirConf { }).lib; {\n    \":mrf\".policies = map mkRaw [\n      \"Pleroma.Web.ActivityPub.MRF.SimplePolicy\"\n    ];\n\n    \":mrf_simple\" = {\n      # Tag all media as sensitive\n      media_nsfw = mkMap {\n        \"nsfw.weird.kinky\" = \"Untagged NSFW content\";\n      };\n\n      # Reject all activities except deletes\n      reject = mkMap {\n        \"kiwifarms.cc\" = \"Persistent harassment of users, no moderation\";\n      };\n\n      # Force posts to be visible by followers only\n      followers_only = mkMap {\n        \"beta.birdsite.live\" = \"Avoid polluting timelines with Twitter posts\";\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Shell script formatting validation with shfmt for multiple files\nDESCRIPTION: Shows how to use testers.shfmt to check formatting of multiple shell script files using fileset to select specific files for testing. This ensures consistent code style across shell scripts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  inherit (lib) fileset;\nin\ntesters.shfmt {\n  name = \"nixbsd\";\n  src = fileset.toSource {\n    root = ./.; \n    fileset = fileset.unions [\n      ./lib.sh\n      ./nixbsd-activate\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Emacs Package Resolution with overrideScope in Nix (Nix)\nDESCRIPTION: This Nix code snippet illustrates how to use overrideScope to manually specify which version of a package (e.g., haskell-mode) gets used in the Emacs package set. By defining an overrides function and supplying it to overrideScope, users gain full control over which derivations are included, including transitive dependencies. Dependencies: nixpkgs, emacsPackagesFor, and target Emacs packages. Limitations: manual maintenance is required and all required dependencies should be handled explicitly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/emacs.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  overrides = self: super: rec {\n    haskell-mode = self.melpaPackages.haskell-mode;\n    # ...\n  };\nin\n((emacsPackagesFor emacs).overrideScope overrides).withPackages (\n  p: with p; [\n    # here both these package will use haskell-mode of our own choice\n    ghc-mod\n    dante\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Haredo Install Targets\nDESCRIPTION: Variable haredoInstallTargets can be used to explicitly set install targets. The dontUseHaredoInstall flag can disable the install phase entirely.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/haredo.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nharedoInstallTargets = [ \"install\" ];\ndontUseHaredoInstall = true;\n```\n\n----------------------------------------\n\nTITLE: Configuring Privoxy with Tor Support in NixOS\nDESCRIPTION: Configuration snippet showing how to enable Privoxy and configure it to use Tor's faster port.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  opt-services.privoxy.enable = true;\n  opt-services.privoxy.enableTor = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Eclipse Environment with External Plugins in NixOS\nDESCRIPTION: This Nix expression demonstrates how to create a custom Eclipse environment with both built-in and external plugins. It uses buildEclipsePlugin and buildEclipseUpdateSite functions to include plugins not available in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/eclipse.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: {\n    myEclipse =\n      with pkgs.eclipses;\n      eclipseWithPlugins {\n        eclipse = eclipse-platform;\n        jvmArgs = [ \"-Xmx2048m\" ];\n        plugins = [\n          plugins.color-theme\n          (plugins.buildEclipsePlugin {\n            name = \"myplugin1-1.0\";\n            srcFeature = fetchurl {\n              url = \"http://…/features/myplugin1.jar\";\n              hash = \"sha256-123…\";\n            };\n            srcPlugin = fetchurl {\n              url = \"http://…/plugins/myplugin1.jar\";\n              hash = \"sha256-123…\";\n            };\n          })\n          (plugins.buildEclipseUpdateSite {\n            name = \"myplugin2-1.0\";\n            src = fetchurl {\n              stripRoot = false;\n              url = \"http://…/myplugin2.zip\";\n              hash = \"sha256-123…\";\n            };\n          })\n        ];\n      };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Glance Service with NixOS Module - Nix\nDESCRIPTION: This Nix snippet demonstrates how to enable and configure the Glance dashboard service on NixOS. It includes enabling the service, defining the homepage layout with widget configurations (such as calendar and weather with specified location), and opens the relevant firewall ports to allow public access. To use this, add the configuration block to your NixOS configuration file. Dependencies: NixOS system with access to the glance service module. Key parameters: 'services.glance.enable' (set to true), 'services.glance.settings.pages' (defines dashboard layout), and 'services.glance.openFirewall' (enables external access). Applies only to systems using Nix-based configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/glance.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.glance = {\n    enable = true;\n    settings = {\n      pages = [\n        {\n          name = \"Home\";\n          columns = [\n            {\n              size = \"full\";\n              widgets = [\n                { type = \"calendar\"; }\n                {\n                  type = \"weather\";\n                  location = \"Nivelles, Belgium\";\n                }\n              ];\n            }\n          ];\n        }\n      ];\n    };\n    openFirewall = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building Python Wheels Inside Nix Shell by Adjusting SOURCE_DATE_EPOCH - Shell\nDESCRIPTION: This snippet demonstrates how to run python3 setup.py bdist_wheel inside a Nix shell, ensuring that the wheel is built correctly by overriding the SOURCE_DATE_EPOCH environment variable. It addresses a compatibility issue where Nix's default SOURCE_DATE_EPOCH causes ZIP file timestamp errors. By setting SOURCE_DATE_EPOCH to 1980 or the current timestamp, or by unsetting it, you guarantee successful .whl creation. No dependencies other than a Nix shell and Python build tools are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_49\n\nLANGUAGE: shell\nCODE:\n```\nnix-shell --run \"SOURCE_DATE_EPOCH=315532800 python3 setup.py bdist_wheel\"\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nnix-shell --run \"SOURCE_DATE_EPOCH=$(date +%s) python3 setup.py bdist_wheel\"\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nnix-shell --run \"unset SOURCE_DATE_EPOCH; python3 setup.py bdist_wheel\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing Shell Completion Files with installShellFiles - Nix\nDESCRIPTION: This Nix snippet illustrates how to use the `installShellCompletion` function to handle installation of shell completion files for Bash, Fish, and Zsh shells. Both explicit naming and implicit autodetection behaviors are demonstrated, including providing `--bash`, `--fish`, `--zsh` flags and the optional `--name` parameter. Inputs are shell completion files and various command flags, while outputs are installed shell completions in their proper locations. The system expects completion files to be non-empty and present after installation. The code requires inclusion of `installShellFiles` in the build inputs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/installShellFiles.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ installShellFiles ];\n  postInstall = ''\n    # explicit behavior\n    installShellCompletion --bash --name foobar.bash share/completions.bash\n    installShellCompletion --fish --name foobar.fish share/completions.fish\n    installShellCompletion --zsh --name _foobar share/completions.zsh\n    # implicit behavior\n    installShellCompletion share/completions/foobar.{bash,fish,zsh}\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Absolute Paths for Darwin Tools\nDESCRIPTION: Shows how to replace hardcoded absolute paths to Darwin tools with relative paths using substituteInPlace.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  postPatch = ''\n    substituteInPlace Makefile \\\n      --replace-fail '/usr/bin/xcodebuild' 'xcodebuild' \\\n      --replace-fail '/usr/bin/xcrun' 'xcrun' \\\n      --replace-fail '/usr/bin/PListBuddy' 'PListBuddy'\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Shiori Service Secret via Environment File (Nix, Shell)\nDESCRIPTION: This snippet demonstrates how to securely generate a random HTTP secret for the Shiori service and assign it via an environment file in a NixOS configuration. It requires openssl to generate a 16-byte hexadecimal string, writes the result to a file, and references this path using the `services.shiori.environmentFile` option. Ensure the path is secure and readable by the service. The input to the NixOS option is the string path to the generated environment file, and Shiori reads the secret via the environment variable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# This is how a environment file can be generated:\\n# $ printf \\\"SHIORI_HTTP_SECRET_KEY=%s\\\\n\\\" \\\"$(openssl rand -hex 16)\\\" > /path/to/env-file\n```\n\nLANGUAGE: nix\nCODE:\n```\nservices.shiori.environmentFile = \"/path/to/env-file\";\n```\n\n----------------------------------------\n\nTITLE: Multiple Netbird Connections Configuration in NixOS\nDESCRIPTION: Defines multiple Netbird services running simultaneously with different ports and interfaces. Each service requires at least a port definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/netbird.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.netbird.clients.wt1.port = 51830;\n  services.netbird.clients.wt2.port = 51831;\n}\n```\n\n----------------------------------------\n\nTITLE: Blocking All Unfree Packages Via Predicate - Nix - nix\nDESCRIPTION: Defines an `allowUnfreePredicate` in the user's `config.nix` as a function that always returns `false`, blocking all unfree packages explicitly. Used for stricter environments where absolutely no unfree packages should be allowed, taking precedence over more permissive global settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowUnfreePredicate = (pkg: false);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Unfree Package Access in NixOS\nDESCRIPTION: Configuration to globally enable unfree packages in NixOS system configuration. This setting affects only the NixOS configuration and not user-level Nix commands.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/customizing-packages.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config = {\n    allowUnfree = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up nix-shell Build Environment - Bash\nDESCRIPTION: This snippet creates a temporary directory, starts a nix-shell with the desired package, and sets the output path for manual builds. cd changes to a new temp directory, nix-shell loads the environment for some_package, and export out defines $out for installation. Dependencies: a working Nix/nixpkgs setup and shell access.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd \"$(mktemp -d)\"\nnix-shell '<nixpkgs>' -A some_package\nexport out=$(pwd)/out\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Inkscape Extensions in Nix Shell - Bash\nDESCRIPTION: This Bash snippet demonstrates launching a Nix shell with Inkscape preconfigured to include user-defined extensions. The -p flag injects an overridden package where `inkstitch` is selected as an enabled extension. Upon shell entry, Inkscape is accessible with the specified extension(s) immediately available. Requires: a system with Nix installed and access to corresponding packages. Key parameter: an overridden `inkscape-with-extensions`. Limitations: only works with properly defined extension packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/inkscape.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-shell -p 'inkscape-with-extensions.override { inkscapeExtensions = with inkscape-extensions; [inkstitch]; }'\n[nix-shell:~]$ # Ink/Stitch is now available via the extension menu\n[nix-shell:~]$ inkscape\n```\n\n----------------------------------------\n\nTITLE: Shell Argument for Cross-Compilation Target - Shell Command - Shell\nDESCRIPTION: Shows the resulting shell flag for specifying a custom cross-compilation target in cargo or rustc. Used after configuring Nixpkgs for cross-compilation. The string is a literal shell command argument. Useful for users constructing build scripts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n--target thumbv7em-none-eabi\n```\n\n----------------------------------------\n\nTITLE: Configuring Display and Window Manager Defaults in NixOS with Nix - nix\nDESCRIPTION: This snippet demonstrates how to declare default desktop and window managers in NixOS pre-20.03 using Nix attribute sets. It assigns 'xfce' as the default desktop manager and 'icewm' as the default window manager. The configuration should be placed into a system configuration file written in the Nix programming language, such as configuration.nix. Changing these settings allows NixOS to launch the specified session upon start; this form is now deprecated since 20.03. Requires NixOS and the services.xserver module enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.desktopManager.default = \"xfce\";\n  services.xserver.windowManager.default = \"icewm\";\n}\n```\n\n----------------------------------------\n\nTITLE: Building Minimal Cross GCC Compiler - Nix Expression - nix\nDESCRIPTION: Defines a Nix expression for building a minimal GCC cross-compiler for arm-linux. It handles parameters for enabling/disabling C/C++/F77 languages, toggling profiled compilers, and passing in cross-toolchain dependencies (binutilsArm, kernelHeadersArm). It fetches gcc-core tarball, conditionally applies patches, and sets up relevant build inputs. Output is a stripped-down GCC suitable for building target-side C binaries, with heavy reliance on builder.sh logic for toolchain preparation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/old/cross.txt#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchurl, noSysDirs\n, langC ? true, langCC ? true, langF77 ? false\n, profiledCompiler ? false\n, binutilsArm\n, kernelHeadersArm\n}:\n\nassert langC;\n\nstdenv.mkDerivation {\n  name = \"gcc-4.0.2-arm\";\n  builder = ./builder.sh;\n  src = fetchurl {\n    url = \"ftp://ftp.nluug.nl/pub/gnu/gcc/gcc-4.0.2/gcc-core-4.0.2.tar.bz2\";\n    hash = \"sha256-LANmXRS7/fN2zF5JUJVd8OjNA5aCDsGLQKhSpxWA3Qk=\";\n  };\n  # !!! apply only if noSysDirs is set\n  patches = [./no-sys-dirs.patch ./gcc-inhibit.patch];\n  inherit noSysDirs langC langCC langF77 profiledCompiler;\n  buildInputs = [binutilsArm];\n  inherit kernelHeadersArm binutilsArm;\n  platform = \"arm-linux\";\n}\n\n```\n\n----------------------------------------\n\nTITLE: Basic SBCL Shell Usage with Alexandria Package\nDESCRIPTION: Example showing how to start an SBCL REPL with the Alexandria package loaded via nix-shell.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_0\n\nLANGUAGE: lisp\nCODE:\n```\n$ sbcl\n* (load (sb-ext:posix-getenv \"ASDF\"))\n* (asdf:load-system 'alexandria)\n```\n\n----------------------------------------\n\nTITLE: Importing Image-Based Appliance Profile in NixOS (Nix)\nDESCRIPTION: This snippet demonstrates how to configure a NixOS system to use the image-based appliance profile by importing the relevant Nix expression from the modules path. It disables the ability to switch to the current configuration by setting 'config.system.switch.enable = false', affecting scripts like 'switch-to-configuration'. Required dependencies include a valid 'modulesPath' variable referencing the correct modules location. The main inputs are the attribute set arguments and the expected output is a NixOS configuration that omits system switching capabilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/non-switchable-systems.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ modulesPath, ... }: {\n  imports = [ \"${modulesPath}/profiles/image-based-appliance.nix\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Patching Shebangs with Command-line Arguments in Bash\nDESCRIPTION: Example of using the patchShebangs command with a host flag to update interpreter paths in scripts for a package in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_39\n\nLANGUAGE: sh\nCODE:\n```\npatchShebangs --host /nix/store/<hash>-hello-1.0/bin\n```\n\n----------------------------------------\n\nTITLE: Configuring System Service Package\nDESCRIPTION: Shows how to enable a systemd system service with a provided upstream package in NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.packages = [ pkgs.packagekit ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defaulting X11 Plasma5 Phonon Backend to VLC - NixOS Desktop Manager Option - Markdown\nDESCRIPTION: This item documents the default change for services.xserver.desktopManager.plasma5.phononBackend to vlc, as recommended upstream. The effect is to select VLC as the multimedia backend by default for Plasma 5 sessions. It requires VLC and the Plasma 5 desktop environment to be present for best results.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n- \\`services.xserver.desktopManager.plasma5.phononBackend\\` now defaults to vlc according to [upstrean recommendation](https://community.kde.org/Distributions/Packaging_Recommendations#Non-Plasma_packages)\n```\n\n----------------------------------------\n\nTITLE: Configuring Switchboard with Specific Plugs Only\nDESCRIPTION: Advanced configuration to use only specific Switchboard plugs, disabling all default ones. Useful for testing a particular plugin in isolation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nswitchboard-with-plugs.override {\n  useDefaultPlugs = false;\n  plugs = specialListOfPlugs;\n}\n```\n\n----------------------------------------\n\nTITLE: Freezing Dhall Expression with Semantic Integrity Check\nDESCRIPTION: This snippet demonstrates how to freeze a Dhall expression, adding a semantic integrity check to the remote import. This is necessary for Nixpkgs integration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_1\n\nLANGUAGE: dhall\nCODE:\n```\n-- ./true.dhall\n\nlet Prelude =\n      https://prelude.dhall-lang.org/v20.1.0/package.dhall\n        sha256:26b0ef498663d269e4dc6a82b0ee289ec565d683ef4c00d0ebdd25333a5a3c98\n\nin  Prelude.Bool.not False\n```\n\n----------------------------------------\n\nTITLE: Garage Version Selection Based on State Version - NixOS Option/Package - Markdown\nDESCRIPTION: This snippet illustrates how the Garage distributed storage package version is determined by system.stateVersion. Older installations remain on version 0.7; new systems default to version 0.8. To migrate existing clusters, upstream documentation should be followed, and the services.garage.package attribute can be used to configure the package. This pattern applies to system-wide state versioning and upgradable services within NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n- [Garage](https://garagehq.deuxfleurs.fr/) version is based on [system.stateVersion](options.html#opt-system.stateVersion), existing installations will keep using version 0.7. New installations will use version 0.8. In order to upgrade a Garage cluster, please follow [upstream instructions](https://garagehq.deuxfleurs.fr/documentation/cookbook/upgrading/) and configure [services.garage.package](options.html#opt-services.garage.package).\n```\n\n----------------------------------------\n\nTITLE: Specifying Scripts and Init Commands for WeeChat Startup - Nix\nDESCRIPTION: This snippet configures WeeChat to preload specified scripts from a given Nixpkgs collection and issue initialization commands at startup. The 'scripts' attribute is an array of packaged scripts (such as XMPP and Matrix bridges), loaded before any 'init' commands that set plugin variables. Requires WeeChat scripts available via 'pkgs.weechatScripts'. The configuration ensures custom scripting and environment setup at launch.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nweechat.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      scripts = with pkgs.weechatScripts; [\n        weechat-xmpp\n        weechat-matrix-bridge\n        wee-slack\n      ];\n      init = ''\n        /set plugins.var.python.jabber.key \"val\"\n      '';\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Docker Image for a Nix Derivation Using dockerTools.streamNixShellImage - Nix\nDESCRIPTION: This snippet demonstrates how to call dockerTools.streamNixShellImage in Nix to build a Docker image for a given derivation, in this case the hello package, specifying a custom tag. This requires dockerTools and the target derivation (hello) as inputs. The main parameters are drv (the derivation to be included in the image) and tag (the Docker tag to apply to the image). The result is a script that, when executed and piped into docker image load, builds and imports the resulting image into Docker.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_35\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.streamNixShellImage {\n  drv = hello;\n  tag = \"latest\";\n}\n```\n\n----------------------------------------\n\nTITLE: Performing String Replacement Using substitute in Bash\nDESCRIPTION: Demonstrates usage of the Bash-level substitute function to replace occurrences of @foo@ with the given file path. The functionality is defined at the shell level, requiring Bash, an input source file, an output target file, and correctly formatted replacement parameters. The command modifies the output file by substituting textual placeholders found in the input.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsubstitute $infile $outfile --replace-fail @foo@ ${foopkg}/bin/foo\n```\n\n----------------------------------------\n\nTITLE: Running Module System Tests with Bash Script - Bash\nDESCRIPTION: Shows how to run module system tests using the 'tests/modules.sh' Bash script, which likely executes a suite tailored for the module system in Nixpkgs. Requires executable permissions for 'modules.sh' and a bash-compatible environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\ntests/modules.sh\n```\n\n----------------------------------------\n\nTITLE: Example azure-mgmt-storage Dependency Version Specification - Python (setup.py)\nDESCRIPTION: This line is an excerpt from Azure CLI's 'setup.py' specifying an exact dependency version for 'azure-mgmt-storage'. Such specification is required for determining which version to package or update in the Nixpkgs python-packages file when resolving dependency errors during CLI builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n'azure-mgmt-storage==21.2.0',\n```\n\n----------------------------------------\n\nTITLE: Extending GNOME App Wrapper Arguments using gappsWrapperArgs (Nix)\nDESCRIPTION: Shows how to inject extra arguments into the GNOME application wrapper in a Nix package by appending to `gappsWrapperArgs` via a `preFixup` shell snippet. This allows customization, such as specifying additional data directories for thumbnailers, and is compatible with the automatic wrapping performed by `wrapGApps*` hooks. Key parameters include the paths to packages like `gdk-pixbuf`, `librsvg`, and `shared-mime-info`. Inputs are the referenced packages and outputs are additional wrapper arguments passed to `makeWrapper`. This method assumes using the default build phases and is best used for minor argument additions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gnome.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  preFixup = ''\n    gappsWrapperArgs+=(\n      # Thumbnailers\n      --prefix XDG_DATA_DIRS : \"${gdk-pixbuf}/share\"\n      --prefix XDG_DATA_DIRS : \"${librsvg}/share\"\n      --prefix XDG_DATA_DIRS : \"${shared-mime-info}/share\"\n    )\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image from Local Path - Shell\nDESCRIPTION: This shell instruction demonstrates building a Nix package from an expression that uses a path as `fromImage`. The produced archive is placed in the Nix store, with all output shown except for removed details. The command is used to validate that the export process succeeds and the expected filename results.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/w13l8h3nlkg0zv56k7rj0ai0l2zlf7ss-filesystem.tar\n\n```\n\n----------------------------------------\n\nTITLE: Executing Python Commands in Interactive Test Driver\nDESCRIPTION: Example Python commands that can be run in the interactive test driver environment. These commands start VMs, run test scripts, and execute commands within the test VMs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> start_all()\n>>> test_script()\n>>> machine.succeed(\"touch /tmp/foo\")\n>>> print(machine.succeed(\"pwd\")) # Show stdout of command\n```\n\n----------------------------------------\n\nTITLE: Setting Build Targets for Haskell Packages\nDESCRIPTION: A function to specify which targets should be built for a Haskell package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_31\n\nLANGUAGE: nix\nCODE:\n```\nsetBuildTargets drv list\n```\n\n----------------------------------------\n\nTITLE: Example Gulp Build Script for Bower Components\nDESCRIPTION: A sample gulpfile.js demonstrating how to integrate Bower components into a build process using Gulp. It copies all files from bower_components to a gulpdist directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/bower.section.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar gulp = require('gulp');\n\ngulp.task('default', [], function () {\n  gulp.start('build');\n});\n\ngulp.task('build', [], function () {\n  console.log(\"Just a dummy gulp build\");\n  gulp\n    .src([\"./bower_components/**/*\"])\n    .pipe(gulp.dest(\"./gulpdist/\"));\n});\n```\n\n----------------------------------------\n\nTITLE: Loading and Testing Docker Image with Shell Access\nDESCRIPTION: Commands demonstrating how to load a Docker image built with dockerTools into Docker and test shell access.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_27\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/2p0i3i04cgjlk71hsn7ll4kxaxxiv4qg-docker-image-env-helpers.tar.gz\n$ docker image load -i /nix/store/2p0i3i04cgjlk71hsn7ll4kxaxxiv4qg-docker-image-env-helpers.tar.gz\n(output removed for clarity)\n$ docker container run --rm -it env-helpers:latest /bin/sh\nsh-5.2# help\nGNU bash, version 5.2.21(1)-release (x86_64-pc-linux-gnu)\n(rest of output removed for clarity)\n```\n\n----------------------------------------\n\nTITLE: Order Priority Definition\nDESCRIPTION: Example of using mkBefore to influence the ordering of list values in option definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.firmware = mkBefore [ myFirmware ];\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Unpacking Tar.gz Archives Using fetchzip - Nix\nDESCRIPTION: This snippet uses the fetchzip function within a Nix expression to download and extract the contents of a .tar.gz file, placing the archive's files at the top level via the stripRoot attribute (enabled by default). It requires the nixpkgs lib with the fetchzip function and expects both a valid URL and SHA256 hash. The output is the set of extracted files, suitable for use in a Nix build or as a dependency, and is wrapped in a function accepting a fetchzip argument.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchzip }:\nfetchzip {\n  url = \"https://github.com/NixOS/patchelf/releases/download/0.18.0/patchelf-0.18.0.tar.gz\";\n  hash = \"sha256-3ABYlME9R8klcpJ7MQpyFEFwHmxDDEzIYBqu/CpDYmg=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Example Package Attribute Naming\nDESCRIPTION: Demonstrates the naming convention for package attributes in all-packages.nix, particularly for packages with multiple versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\njson-c_0_9\njson-c_0_11\njson-c = json-c_0_9;\n```\n\n----------------------------------------\n\nTITLE: Including Contribution Chapters in Documentation - Markdown\nDESCRIPTION: This snippet uses a custom Markdown directive ({=include=}) to include multiple chapter files into the main documentation. Each listed file covers a different aspect of contributing to Nixpkgs, such as quick start, coding conventions, submitting changes, handling vulnerabilities, reviewing contributions, and documentation contributions. Requires a Markdown renderer or static site generator that supports the custom {=include=} directive, and expects all referenced chapter files to exist. The output is a unified documentation page integrating the content of all specified chapters in order.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/contributing.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\ncontributing/quick-start.chapter.md\ncontributing/coding-conventions.chapter.md\ncontributing/submitting-changes.chapter.md\ncontributing/vulnerability-roundup.chapter.md\ncontributing/reviewing-contributions.chapter.md\ncontributing/contributing-to-documentation.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding CoreDNS Plugins in NixOS - Nix\nDESCRIPTION: This snippet demonstrates how to override external CoreDNS plugins and specify a vendorHash for reproducible builds in a NixOS configuration. It enables the 'fanout' plugin at a specified version by modifying the externalPlugins array, and includes instructions for generating the necessary vendorHash by provoking a build failure that reveals the correct hash. Key parameters include 'externalPlugins' (list of plugin details) and 'vendorHash' (string for dependency integrity). It requires access to NixOS module system and the pkgs.coredns package with an 'override' method. Input expects a Nix attribute set for the 'services.coredns' module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.coredns = {\n    enable = true;\n    package = pkgs.coredns.override {\n      externalPlugins = [\n        {name = \"fanout\"; repo = \"github.com/networkservicemesh/fanout\"; version = \"v1.9.1\";}\n      ];\n      vendorHash = \"<SRI hash>\";\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building Custom NixOS System Closure for kexec - ShellSession\nDESCRIPTION: Executes nix-build to build a system closure using a user-provided configuration.nix file. Uses --arg to inject the custom configuration and --attr to select config.system.build.kexecTree for output. Dependency: Nix, the nixpkgs repository, and a local configuration.nix file. Input is the configuration file path and attribute; output is a build result tree containing kexec artifacts for the custom system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-kexec.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-build '<nixpkgs/nixos>' \\\n  --arg configuration ./configuration.nix\n  --attr config.system.build.kexecTree\n```\n\n----------------------------------------\n\nTITLE: Deleting Old Pleroma Database and Uploads after Migration - ShellSession\nDESCRIPTION: This set of shell commands removes the original Pleroma PostgreSQL database and disk uploads following a successful migration to Akkoma. It requires database access and a Unix shell. Inputs specify resources to delete; output is a system purged of obsolete Pleroma data.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n# Delete original database\nnix-shell -p postgresql --run 'dropdb pleroma'\n\n# Delete original Pleroma state\nrm -r /var/lib/pleroma\n```\n\n----------------------------------------\n\nTITLE: Launching the NixOS Configuration REPL - ShellSession\nDESCRIPTION: Runs 'nixos-rebuild repl' to open an interactive environment where the configuration is preloaded as the 'config' variable. Supports exploring or debugging Nix expressions. Tab autocompletion and reload commands are available. Requires 'nixos-rebuild' and a valid NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild repl\n```\n\n----------------------------------------\n\nTITLE: Prefetching and Hashing CUDA Toolkit Runfile Installer - Bash\nDESCRIPTION: This Bash command demonstrates how to prefetch a file from a URL and retrieve its SHA256 hash using the 'nix store prefetch-file' command. It is typically used to obtain the hash for a CUDA Toolkit runfile installer prior to updating package definitions. Required parameters include the download URL, and the Nix CLI with appropriate permissions is a dependency. Output is a SHA256 hash printed to stdout, usable in Nix derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnix store prefetch-file --hash-type sha256 <link>\n\n```\n\n----------------------------------------\n\nTITLE: GHC Package Database Header\nDESCRIPTION: Markdown header defining the GHC section with an HTML anchor tag.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/ghc.section.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# GHC {#ghc}\n```\n\n----------------------------------------\n\nTITLE: Regenerating ACME Certificates via systemctl - Shell\nDESCRIPTION: Demonstrates the imperative command needed to forcibly regenerate ACME certificates for a given domain on NixOS using systemctl. Removing the state with 'systemctl clean' deletes all certificate files and account metadata, enabling a clean start for reissuing certs with 'systemctl start'. Requires systemd, NixOS-managed ACME services, and proper permissions. Inputs are the relevant service name; outputs are fresh certificate and account files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nsystemctl clean --what=state acme-example.com.service\n```\n\n----------------------------------------\n\nTITLE: Building Composer with Additional PHP Extensions in Nix\nDESCRIPTION: Shows how to build the Composer package with additional PHP extensions, such as imagick and redis.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n(php.withExtensions (\n  { all, enabled }:\n  enabled\n  ++ (with all; [\n    imagick\n    redis\n  ])\n)).packages.composer\n```\n\n----------------------------------------\n\nTITLE: Configuring GoToSocial Service in NixOS\nDESCRIPTION: Basic NixOS configuration for GoToSocial service with PostgreSQL backend. Sets up the server to listen on localhost:8080 with custom domain configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/gotosocial.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gotosocial = {\n    enable = true;\n    setupPostgresqlDB = true;\n    settings = {\n      application-name = \"My GoToSocial\";\n      host = \"gotosocial.example.com\";\n      protocol = \"https\";\n      bind-address = \"127.0.0.1\";\n      port = 8080;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: oCIS Configuration Initialization Commands\nDESCRIPTION: Console commands to initialize oCIS configuration using nix-shell with the ocis package and generating initial config files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/ocis.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ nix-shell -p ocis_5-bin\n$ mkdir scratch/\n$ cd scratch/\n$ ocis init --config-path . --admin-password \"changeme\"\n```\n\n----------------------------------------\n\nTITLE: Creating OCI Runtime Container with Bash using ociTools.buildContainer in Nix\nDESCRIPTION: This snippet demonstrates how to use ociTools.buildContainer to create an OCI runtime container that runs bash. It specifies the bash executable as the container's entry point and sets the readonly flag to false.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/ocitools.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  ociTools,\n  lib,\n  bash,\n}:\nociTools.buildContainer {\n  args = [\n    (lib.getExe bash)\n  ];\n\n  readonly = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Custom Typst Package - Nix\nDESCRIPTION: This code snippet illustrates how to define a custom Typst package in Nix using the 'buildTypstPackage' helper. It expects the package source directory, version, name, and explicit dependencies listed in 'typstDeps'. Required dependencies are 'buildTypstPackage' and 'typstPackages' from nixpkgs. The output is a new Typst package that can be referenced in environments or by the Typst compiler. Explicitly specifying 'typstDeps' is crucial for correct build and use, and the package will be scoped under '@preview' by default.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/typst.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildTypstPackage,\n  typstPackages,\n}:\n\nbuildTypstPackage (finalAttrs: {\n  pname = \"my-typst-package\";\n  version = \"0.0.1\";\n  src = ./.;\n  typstDeps = with typstPackages; [ cetz_0_3_0 ];\n})\n```\n\n----------------------------------------\n\nTITLE: Rerunning a Single Phase in the Build Process - Bash\nDESCRIPTION: This simple command is for rerunning a single named phase (here, buildPhase) interactively in a nix-shell environment using genericBuild. It allows for efficient iteration, troubleshooting, and patch testing of a single phase without running the whole build sequence from scratch.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nphases=\"buildPhase\" genericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Attaching a Disk Image in Linux VM Build using vmTools.createEmptyImage (Nix)\nDESCRIPTION: This snippet demonstrates using the `preVM` attribute with `runInLinuxVM` to create and attach a disk image the build can use. The image is created with `createEmptyImage`, specifying size and a label. Dependencies include Nixpkgs, `vmTools`, and the disk image creation utility. Key parameters are `size` (image size in MiB) and `fullName` (identifier stored in image metadata). This setup allows testing builds requiring an additional disk device.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }:\nwith pkgs;\nwith vmTools;\nrunInLinuxVM (\n  hello.overrideAttrs (_: {\n    preVM = createEmptyImage {\n      size = 1024;\n      fullName = \"vm-image\";\n    };\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Out-of-tree Custom Package Definition (Nix, nix)\nDESCRIPTION: This out-of-tree Nix snippet creates a barebones package definition for GNU Hello, using stdenv.mkDerivation and fetchurl from pkgs. It sets \\\"hello-2.8\\\" as the name and includes secure fetching. Inputs: pkgs context, outputs: Nix derivation. Dependencies: Nixpkgs, network access for downloading the source.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  environment.systemPackages =\\n    let\\n      my-hello = with pkgs; stdenv.mkDerivation rec {\\n        name = \\\"hello-2.8\\\";\\n        src = fetchurl {\\n          url = \\\"mirror://gnu/hello/${name}.tar.gz\\\";\\n          hash = \\\"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\\\";\\n        };\\n      };\\n    in\\n    [ my-hello ];\\n}\n```\n\n----------------------------------------\n\nTITLE: Testing All Agda Packages in nixpkgs\nDESCRIPTION: Command to trigger ofborg build tests for all Agda packages in the ecosystem. Used for comprehensive testing of package compatibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n@ofborg build agda.passthru.tests.allPackages\n```\n\n----------------------------------------\n\nTITLE: Enabling Intel i965 VA-API Driver in NixOS Hardware Configuration (nix)\nDESCRIPTION: Configures Intel's legacy VA-API (i965) driver for older GPUs by specifying intel-vaapi-driver in hardware.graphics.extraPackages within NixOS. This makes the i965 driver available for libva to discover for supported devices. Suitable for older pre-Gen9 Intel GPUs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.graphics.extraPackages = [\n    intel-vaapi-driver\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Extensible Option Type Service Module\nDESCRIPTION: Shows how to declare an extensible option type placeholder in a service module for display manager configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.enable = mkOption {\n    description = \"Display manager to use\";\n    type = with types; nullOr (enum [ ]);\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Sample 'az extension list' Output - Shell (JSON-formatted)\nDESCRIPTION: This command output displays the details of the installed 'azure-devops' extension in JSON-like format, as returned by 'az extension list'. It confirms the extension's presence, version, type, and install path. The structure helps users verify the operational status after installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n[\\n  {\\n    \\\"experimental\\\": false,\\n    \\\"extensionType\\\": \\\"whl\\\",\\n    \\\"name\\\": \\\"azure-devops\\\",\\n    \\\"path\\\": \\\"/nix/store/azbgnpg5nh5rb8wfvp0r9bmcx83mqrj5-azure-cli-extensions/azure-devops\\\",\\n    \\\"preview\\\": false,\\n    \\\"version\\\": \\\"1.0.0\\\"\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Haredo Build Targets\nDESCRIPTION: Variable haredoBuildTargets can be used to explicitly set build targets. The dontUseHaredoBuild flag can disable the build phase entirely.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/haredo.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nharedoBuildTargets = [ \"target1\" \"target2\" ];\ndontUseHaredoBuild = true;\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies to Haskell Packages\nDESCRIPTION: Functions to add various types of dependencies to Haskell package derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_29\n\nLANGUAGE: nix\nCODE:\n```\naddBuildTools list drv\naddExtraLibraries list drv\naddBuildDepends list drv\naddTestToolDepends list drv\naddPkgconfigDepends list drv\naddSetupDepends list drv\n```\n\n----------------------------------------\n\nTITLE: Problematic Conditional Option Definition\nDESCRIPTION: Example of a problematic conditional definition that causes infinite recursion due to circular dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = if config.services.httpd.enable then {\n    environment.systemPackages = [ /* ... */ ];\n    # ...\n  } else {};\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing FoundationDB Cluster Status - Python in nix-shell - python\nDESCRIPTION: This code snippet is a Python script designed to be executed within a nix-shell, ensuring correct dependency resolution for the required FoundationDB Python API bindings. The script queries the FoundationDB cluster for its status using a transactional read of a special key, parses the JSON result to print whether the database is available, and demonstrates nix-shell shebang usage. It requires both the python and foundationdb73 Python packages, and expects the user to have access permissions for the cluster file. The input is implicit (no arguments), and the output is a one-line availability statement. Constraints include compatibility with API version 520 and proper nix-shell invocation for dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#! /usr/bin/env nix-shell\n#! nix-shell -i python -p python pythonPackages.foundationdb73\n\nimport fdb\nimport json\n\ndef main():\n    fdb.api_version(520)\n    db = fdb.open()\n\n    @fdb.transactional\n    def get_status(tr):\n        return str(tr['\\xff\\xff/status/json'])\n\n    obj = json.loads(get_status(db))\n    print('FoundationDB available: %s' % obj['client']['database_status']['available'])\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n----------------------------------------\n\nTITLE: Listing and Switching to NixOS Channel (Shell)\nDESCRIPTION: Lists current Nix channels and demonstrates how to add the official NixOS release channel using nix-channel commands. The example shows subscription to nixpkgs and addition of a version-specific channel to ensure stable, tested releases are used. Prerequisites: Nix installed. Key parameters: None explicitly, but <version> must be set to the channel version. Output: Channel configuration updated.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-channel --list\\nnixpkgs https://nixos.org/channels/nixpkgs-unstable\n```\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-channel --add https://nixos.org/channels/nixos-<version> nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Defining Kubernetes RuntimeClass for Nvidia\nDESCRIPTION: Kubernetes RuntimeClass manifest that defines the 'nvidia' runtime handler for GPU-enabled pods.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/NVIDIA.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: node.k8s.io/v1\nhandler: nvidia\nkind: RuntimeClass\nmetadata:\n  labels:\n    app.kubernetes.io/component: gpu-operator\n  name: nvidia\n```\n\n----------------------------------------\n\nTITLE: ZRAM Swap Implementation Changes and Removed Option - NixOS System Option - Markdown\nDESCRIPTION: This code provides information on the switch of zramSwap to the zram-generator and the removal of zramSwap.numDevices. This alters the way ephemeral ZRAM block devices are set up on NixOS, affecting users relying on the old option. The zram-generator package is a runtime requirement.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_16\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`zramSwap\\` is now implemented with \\`zram-generator\\`, and the option \\`zramSwap.numDevices\\` for using ZRAM devices as general purpose ephemeral block devices has been removed.\n```\n\n----------------------------------------\n\nTITLE: Updating JetBrains IDE and Plugin Binaries - Update Script Invocation - python\nDESCRIPTION: Shows the invocation of an update script for JetBrains IDEs and plugins. The './bin/update_bin.py' command automates the process of refreshing binary IDE and plugin references in the repository, handling version bumps and related git commits. Requires Python and any dependencies listed at the top of the script; appropriate for maintainers needing to update package sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jetbrains/readme.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./bin/update_bin.py\n```\n\n----------------------------------------\n\nTITLE: Configuring LightDM GTK Greeter Indicators in NixOS\nDESCRIPTION: Configuration example for setting up custom indicators in LightDM GTK greeter panel. Shows how to specify display elements like host, clock, session, language, accessibility, and power indicators.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1803.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.lightdm.greeters.gtk.indicators = [\n    \"~host\" \"~spacer\"\n    \"~clock\" \"~spacer\"\n    \"~session\"\n    \"~language\"\n    \"~a11y\"\n    \"~power\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Prefer-Remote-Fetch Overlay - Nix - Nix Expression Language\nDESCRIPTION: This Nix snippet enables the 'prefer-remote-fetch' overlay by wrapping the call in a two-argument lambda, delegating overlay instantiation to Nixpkgs' overlay mechanism. It must be placed in a .nix file under the overlays directory (e.g., ~/.config/nixpkgs/overlays/). Dependencies include an installed Nix setup with Nixpkgs supporting overlays. Inputs are the overlay arguments (self, super); output is the result of invoking prefer-remote-fetch. Limitations: overlay should be composed correctly with other overlays to avoid conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/prefer-remote-fetch.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nself: super: (super.prefer-remote-fetch self super)\n```\n\n----------------------------------------\n\nTITLE: Updating minor Nix versions\nDESCRIPTION: Script path for automatically updating all minor Nix versions\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/tools/package-management/nix/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./pkgs/tools/package-management/nix/update-all.sh\n```\n\n----------------------------------------\n\nTITLE: Creating an Overlay for Intel MKL BLAS/LAPACK\nDESCRIPTION: This overlay configures Nixpkgs to use Intel's MKL library for both BLAS and LAPACK interfaces. It overrides the default BLAS and LAPACK providers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/overlays.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nself: super:\n\n{\n  blas = super.blas.override {\n    blasProvider = self.mkl;\n  };\n\n  lapack = super.lapack.override {\n    lapackProvider = self.mkl;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding nimOverrides in buildNimPackage Internally - Nix Expression - Nix\nDESCRIPTION: This Nix snippet shows how to override Nim package dependencies internally by overriding the 'nimOverrides' attribute in a custom 'buildNimPackage' function, allowing substitution of dependencies like 'openssl' with alternatives like 'libressl'. Dependencies: Nix, 'buildNimPackage', 'nimOverrides', substitute dependency (e.g., libressl). Inputs: Attrset for override. Output: Custom build function that applies the overridden set. Limitation: Only affects dependencies specified via nimOverrides in lockfiles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  buildNimPackage,\n  nimOverrides,\n  libressl,\n}:\n\nlet\n  buildNimPackage' = buildNimPackage.override {\n    nimOverrides = nimOverrides.override { openssl = libressl; };\n  };\nin\nbuildNimPackage' (finalAttrs: {\n  pname = \"foo\";\n  # …\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Custom Idris Package with Nix-env\nDESCRIPTION: Commands to install a custom Idris package (defined in an overlay) using nix-env, with variations for NixOS and non-NixOS systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ # On NixOS\n$ nix-env -iA nixos.myIdris\n$ # On non-NixOS\n$ nix-env -iA nixpkgs.myIdris\n```\n\n----------------------------------------\n\nTITLE: Evaluating Xen Metadata Description in Nix\nDESCRIPTION: A console command to evaluate and display the meta description attributes of the Xen package with formatting. This is useful for verifying the metadata during the update process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/xe/xen/README.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\necho -e \"\\033[1m$(nix eval .#xen.meta.description --raw 2> /dev/null)\\033[0m\\n\\n$(nix eval .#xen.meta.longDescription --raw 2> /dev/null)\"\n```\n\n----------------------------------------\n\nTITLE: Setting Make Flags in NixOS Package Build\nDESCRIPTION: Example showing how to set make flags for package build configuration by specifying PREFIX to the output directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\n{\n  makeFlags = [ \"PREFIX=$(out)\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Filesystem Contents from an ISO Image using vmTools.extractFs (Nix)\nDESCRIPTION: This code snippet invokes the `extractFs` function from `vmTools` to extract the contents of an ISO image (`image.iso`) into the Nix store. Dependencies include Nixpkgs and a compatible ISO file. The required parameter is `file`, which should be a path to a filesystem image (not a partitioned disk image). The output is a derivation containing the extracted contents.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }: with pkgs; with vmTools; extractFs { file = ./image.iso; }\n```\n\n----------------------------------------\n\nTITLE: Removing Deprecated Azure CLI Extension - Nix\nDESCRIPTION: This Nix expression snippet shows how to remove a deprecated extension by replacing its attribute with a throw statement. This causes any reference to the removed extension ('blockchain') to result in a runtime error, signaling to users and maintainers that the extension is no longer available. The comment documents the date of removal for audit purposes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nblockchain = throw \"The 'blockchain' extension for azure-cli was deprecated upstream\"; # Added 2024-04-26\n```\n\n----------------------------------------\n\nTITLE: Defining Build Inputs in a .NET Project File - XML\nDESCRIPTION: This XML snippet demonstrates how to declare project references within a .NET project (.fsproj), enabling linkage to local projects for multi-project solutions. An additional PackageReference can be added for discovery via Nix build inputs. The ProjectReference element links to a sibling project, while the PackageReference ensures proper NuGet packaging/discovery. Input is the path to a .fsproj file; output is linkage metadata for the build system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<ProjectReference Include=\"../foo/bar.fsproj\" />\n```\n\n----------------------------------------\n\nTITLE: Overriding Package Attributes with overridePackage\nDESCRIPTION: Nix expression showing how to use the overridePackage attribute to modify specific attributes of a Dhall package. In this example, the source attribute of the Prelude package is set to true.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dhallOverrides = self: super: {\n    Prelude = super.Prelude.overridePackage { source = true; };\n\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Attribute Override in all-packages.nix\nDESCRIPTION: Example of overriding default package attributes in all-packages.nix to use different dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/README.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  libfoo = callPackage ../by-name/so/some-package/package.nix {\n    libbar = libbar_2;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Meson Installation Tags in Nix\nDESCRIPTION: Demonstrates how to set installation tags for Meson in a Nix configuration. These tags are passed to Meson's --tags option during the install phase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/meson.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nmesonInstallTags = [ \"emulator\" \"assembler\" ];\n```\n\n----------------------------------------\n\nTITLE: Disabling Shebang Patching in Nix Derivation\nDESCRIPTION: Nix code example showing how to disable the automatic patching of shebangs in a derivation by setting the dontPatchShebangs flag to true.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_41\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  # ...\n  dontPatchShebangs = true;\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning iOS Simulator with App Deployment\nDESCRIPTION: This Nix expression demonstrates how to create a script that spawns an iOS simulator instance and automatically deploys and launches a specific app. It combines app building and simulator launching.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n\n  xcodeenv = import ./xcodeenv {\n    inherit (pkgs) stdenv;\n  };\nin\nxcode.simulateApp {\n  name = \"simulate\";\n  bundleId = \"mycompany.myapp\";\n  app = xcode.buildApp {\n    # ...\n  };\n\n  # Supports all xcodewrapper parameters as well\n  xcodeBaseDir = \"/Applications/Xcode.app\";\n}\n```\n\n----------------------------------------\n\nTITLE: Example Admonition Block with Title in Markdown - Markdown\nDESCRIPTION: This snippet demonstrates an example markdown admonition requiring a title using fenced divs with a class and ID. The first heading inside the admonition acts as the title. The rendered result will be a block marked 'example' with specialized formatting. It is supported only if the documentation build system honors example blocks with titles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n::: {.example #ex-showing-an-example}\\n\\n# Title for this example\\n\\nText for the example.\\n:::\n```\n\n----------------------------------------\n\nTITLE: Loading a Temporary Lua Environment with nix-shell - Shell Command - sh\nDESCRIPTION: This command shows how to open a shell session with a temporary Lua environment using nix-shell and lua.withPackages to specify required Lua packages. The environment is ephemeral and suited for ad-hoc testing or development. Inputs are packages passed to withPackages; the result is a shell with the Lua interpreter and specified modules loaded.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nnix-shell -p 'lua.withPackages(ps: with ps; [ busted luafilesystem ])'\n\n```\n\n----------------------------------------\n\nTITLE: Build Phase Example with SBCL\nDESCRIPTION: Shows how to use SBCL in a build phase to compile Lisp sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildPhase = ''\n    ${sbcl'}/bin/sbcl --load my-build-file.lisp\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Akkoma Systemd Service Confinement - Nix\nDESCRIPTION: This snippet toggles the confinement feature for the Akkoma systemd service in NixOS by enabling execution in a chroot environment. The setting is declarative and should be used with care, as the default confinement may not include all necessary paths, requiring further adjustment with associated options. Input: enable confinement (boolean); Output: systemd service runs Akkoma confined to a chroot. Limitation: Service confinement is not generally supported and may result in runtime errors if dependencies are not properly configured.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.systemd.akkoma.confinement.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Stripping of Haskell Packages\nDESCRIPTION: Functions to enable or disable stripping of debug symbols from Haskell package binaries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\ndoStrip drv\ndontStrip drv\n```\n\n----------------------------------------\n\nTITLE: Checking Current NixOS Channel\nDESCRIPTION: This command shows the current NixOS channel the system is subscribed to.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nix-channel --list | grep nixos\nnixos https://channels.nixos.org/nixos-unstable\n```\n\n----------------------------------------\n\nTITLE: Enabling Source for All Dhall Packages in Nix Overlay\nDESCRIPTION: This Nix code snippet shows how to modify the Dhall overlay to enable source inclusion for all Dhall packages by default.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dhallOverrides = self: super: {\n    # Enable source for all Dhall packages\n    buildDhallPackage = args: super.buildDhallPackage (args // { source = true; });\n\n    true = self.callPackage ./true.nix { };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting openjdk Variants with JavaFX - NixOS Package Override - Markdown\nDESCRIPTION: This section notes that openjdk versions 11 and above are now packaged without JavaFX support by default. It provides an override method to enable JavaFX when needed using openjdk11.override { enableJavaFX = true; }. JavaFX applications will require this override. The code is applicable when building derivations that need JavaFX.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_19\n\nLANGUAGE: markdown\nCODE:\n```\n- \\`openjdk\\` from version 11 and above is not build with \\`openjfx\\` (i.e.: JavaFX) support by default anymore. You can re-enable it by overriding, e.g.: \\`openjdk11.override { enableJavaFX = true; };\\`.\n```\n\n----------------------------------------\n\nTITLE: Configuring crab-hole API Access and Admin Key - Nix\nDESCRIPTION: This code enables the local crab-hole API and sets an admin key for protected functions. The configuration exposes the server on a specific local address and port, and can enable documentation via the web front-end. Requires crab-hole's API support. Inputs include listen address, port, a boolean for documentation, and an admin API key; output is an API endpoint secured with the provided key.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/crab-hole.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.crab-hole.settings.api = {\n    listen = \"127.0.0.1\";\n    port = 8080;\n    # optional (default = false)\n    show_doc = true; # OpenAPI doc loads content from third party websites\n    # optional\n    admin_key = \"1234\";\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling and Configuring FoundationDB - Nix - nix\nDESCRIPTION: This snippet demonstrates how to enable the FoundationDB service within NixOS and specify the desired package version explicitly. It highlights the importance of manually setting the package version due to version compatibilities in FoundationDB. Key options set are services.foundationdb.enable (to activate the service) and services.foundationdb.package (to select a specific FoundationDB version), with a comment illustrating the use of FoundationDB 7.3.x. No other parameters are necessary for this basic setup, but the code must be placed in the NixOS configuration.nix file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.foundationdb.enable = true;\n  services.foundationdb.package = pkgs.foundationdb73; # FoundationDB 7.3.x\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing NixOS Boot Loader and Backing Up Previous Boot (Shell)\nDESCRIPTION: Backs up the existing boot partition then runs the NixOS switch-to-configuration script with boot argument to install the NixOS bootloader. Designed for both BIOS and compatibility-mode UEFI systems. Prerequisites: Profile built, superuser permissions, system ready for bootloader replacement. Input: none. Output: /boot contents backed up, NixOS bootloader installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_14\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo mkdir /boot.bak && sudo mv /boot/* /boot.bak &&\\nsudo NIXOS_INSTALL_BOOTLOADER=1 /nix/var/nix/profiles/system/bin/switch-to-configuration boot\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Packages to a Docker Image via nativeBuildInputs in streamNixShellImage - Nix\nDESCRIPTION: This Nix snippet illustrates how to extend the Docker image produced by streamNixShellImage by adding additional packages as nativeBuildInputs to the base derivation via overrideAttrs. The example adds the cowsay package to a hello derivation. This approach can be used for any set of packages, requires access to the relevant package definitions, and assumes a working knowledge of Nixpkgs and attribute overrides.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_38\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  cowsay,\n  hello,\n}:\ndockerTools.streamNixShellImage {\n  tag = \"latest\";\n  drv = hello.overrideAttrs (old: {\n    nativeBuildInputs = old.nativeBuildInputs or [ ] ++ [\n      cowsay\n    ];\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Building Custom PHP Extension List in Nix\nDESCRIPTION: Demonstrates how to build a custom list of PHP extensions from scratch using the php.withExtensions function, ignoring the default enabled extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nphp.withExtensions (\n  { all, ... }:\n  with all;\n  [\n    imagick\n    opcache\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Installing BEAM packages in an ephemeral Nix shell\nDESCRIPTION: This snippet demonstrates how to create an ephemeral Nix shell with the rebar3 package installed. It uses the nix-shell command to create a temporary environment with the specified package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-shell -p beamPackages.rebar3\n```\n\n----------------------------------------\n\nTITLE: Allowlisting Licenses in User Configuration - Nix - nix\nDESCRIPTION: Utilizes `allowlistedLicenses` attribute in the user's Nixpkgs config to explicitly permit software using the 'amd' and 'wtfpl' licenses. Requires dependency `lib.licenses`. Only affects unfree licenses unless `allowUnfree` is set; input is license names, output is expanded available package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowlistedLicenses = with lib.licenses; [\n    amd\n    wtfpl\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling systemd-based LUKS FIDO2 Unlocking at Boot - nix\nDESCRIPTION: This configuration enables systemd-based unlocking of a LUKS device with FIDO2 during boot. The 'crypttabExtraOpts' option passes FIDO2 parameters, while 'systemd.enable' integrates systemd's stage1 init support. Dependencies are a LUKS2 formatted device and systemd in the initrd. Inputs are device paths and option arrays; outputs are automated FIDO2 unlock at boot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/luks-file-systems.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  boot.initrd = {\\n    luks.devices.root = {\\n      crypttabExtraOpts = [ \"fido2-device=auto\" ];\\n      device = \"/dev/sda2\";\\n    };\\n    systemd.enable = true;\\n  };\\n}\n```\n\n----------------------------------------\n\nTITLE: Adding breakpointHook to nativeBuildInputs in Nix\nDESCRIPTION: This snippet demonstrates how to include the breakpointHook in the nativeBuildInputs of a Nix package. When added, it allows the build process to pause on failure for debugging purposes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/breakpoint.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ breakpointHook ];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Desktop File Using makeDesktopItem - Nix\nDESCRIPTION: This usage pattern shows how to generate a standards-compliant XDG desktop entry file in the Nix store with `makeDesktopItem`. It demonstrates setting various XDG and Nix-specific fields, including name, icon, visibility, categories, actions, and custom extensions. All required keys must be specified according to the XDG specification (with some exceptions), and the resulting file will be accessible in the Nix store. This is used to provide desktop integration for packaged applications.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ makeDesktopItem }:\nmakeDesktopItem {\n  name = \"my-program\";\n  desktopName = \"My Program\";\n  genericName = \"Video Player\";\n  noDisplay = false;\n  comment = \"Cool video player\";\n  icon = \"/path/to/icon\";\n  onlyShowIn = [ \"KDE\" ];\n  dbusActivatable = true;\n  tryExec = \"my-program\";\n  exec = \"my-program --someflag\";\n  path = \"/some/working/path\";\n  terminal = false;\n  actions.example = {\n    name = \"New Window\";\n    exec = \"my-program --new-window\";\n    icon = \"/some/icon\";\n  };\n  mimeTypes = [ \"video/mp4\" ];\n  categories = [ \"Utility\" ];\n  implements = [ \"org.my-program\" ];\n  keywords = [\n    \"Video\"\n    \"Player\"\n  ];\n  startupNotify = false;\n  startupWMClass = \"MyProgram\";\n  prefersNonDefaultGPU = false;\n  extraConfig.X-SomeExtension = \"somevalue\";\n}\n```\n\n----------------------------------------\n\nTITLE: Applying NixOS Configuration Changes\nDESCRIPTION: Command to apply the NixOS configuration changes, activating the PostgreSQL service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ nixos-rebuild switch\n```\n\n----------------------------------------\n\nTITLE: Differentiating Arrays and Lists for libconfig with Nix\nDESCRIPTION: Exemplifies the distinction between libconfig's array and list value types by utilizing mkArray and mkList helper functions within pkgs.formats.libconfig. Facilitates data structure correctness for downstream libconfig consumers. Dependencies: pkgs.formats.libconfig. Input: Nix lists representing data for each type. Output: Attrset with properly typed values for libconfig serialization.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  format = pkgs.formats.libconfig { };\nin {\n  myList = format.lib.mkList [ \"foo\" 1 true ];\n  myArray = format.lib.mkArray [ 1 2 3 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a List of Submodules (Nix)\nDESCRIPTION: Provides an example value for the 'mod' option declared as a list of submodules, with two elements: one where foo=1/bar=\"one\", and another with foo=2/bar=\"two\". Must be used in conjunction with a matching listOf submodule schema. Serves as a practical instantiation of the previously declared list submodule option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config.mod = [\n    { foo = 1; bar = \"one\"; }\n    { foo = 2; bar = \"two\"; }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Using shadowSetup with buildLayeredImage in NixOS\nDESCRIPTION: Example showing how to use shadowSetup with dockerTools.buildLayeredImage to create users and groups during image creation. Requires enableFakechroot to be set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_31\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildLayeredImage {\n  name = \"shadow-basic\";\n  tag = \"latest\";\n\n  contents = [ hello ];\n\n  fakeRootCommands = ''\n    ${dockerTools.shadowSetup}\n    groupadd -r hello\n    useradd -r -g hello hello\n    mkdir /data\n    chown hello:hello /data\n  '';\n  enableFakechroot = true;\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n    WorkingDir = \"/data\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Rolling Back Last nix-env Operation - ShellSession\nDESCRIPTION: Reverts the most recent profile-changing nix-env action using the --rollback flag. This is useful for undoing installations, upgrades, or removals that had unintended consequences. The command expects that a stateful operation (e.g., install, remove, upgrade) has occurred and restores the previous profile state.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-packages.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env --rollback\n```\n\n----------------------------------------\n\nTITLE: Handling Identifier Rename in Redirects Mapping - JSON\nDESCRIPTION: This JSON snippet demonstrates how to represent a renamed identifier in the redirects mapping. To accommodate the rename, a new identifier key is created, and the array includes both the current and previous locations, preserving the historical paths for reliable redirect handling. This allows tools and processes that consume the mapping to address renamed content seamlessly, ensuring backward compatibility for users following old links.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-render-docs/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"<identifier-new>\": [\\n    \"index.html#<identifier-new>\",\\n    \"foo.html#<identifier>\",\\n    \"bar.html#foo\",\\n    \"index.html#<identifier>\"\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging Custom Oh My Zsh Themes and Plugins - Nix Derivation Example\nDESCRIPTION: This Nix derivation provides a template for creating new Oh My Zsh-compatible packages, such as custom themes or plugins. It utilizes 'stdenv.mkDerivation' with a versioned name, downloads sources via fetchFromGitHub, and organizes installation paths to match Oh My Zsh expectations. Dependencies include stdenv and fetchFromGitHub; key parameters are name, version, src, and installPhase. Outputs are structured so 'themes' and 'plugins' are installed under $out/share/zsh, while completion scripts go to $out/share/zsh/site-functions. Limitations: 'dontBuild = true' disables the build phase; exact paths must comply with Oh My Zsh and Zsh conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/zsh/oh-my-zsh.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchFromGitHub }:\n\nstdenv.mkDerivation rec {\n  name = \"exemplary-zsh-customization-${version}\";\n  version = \"1.0.0\";\n  src = fetchFromGitHub {\n    # path to the upstream repository\n  };\n\n  dontBuild = true;\n  installPhase = ''\n    mkdir -p $out/share/zsh/site-functions\n    cp {themes,plugins} $out/share/zsh\n    cp completions $out/share/zsh/site-functions\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Litestream with Grafana Database in NixOS\nDESCRIPTION: This snippet demonstrates a complete Litestream configuration for replicating a Grafana SQLite database to an S3 bucket. It includes necessary permission settings, a script to ensure database files are accessible, and the Litestream service configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/network-filesystems/litestream/default.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  users.users.litestream.extraGroups = [ \"grafana\" ];\n\n  systemd.services.grafana.serviceConfig.ExecStartPost = \"+\" + pkgs.writeShellScript \"grant-grafana-permissions\" ''\n    timeout=10\n\n    while [ ! -f /var/lib/grafana/data/grafana.db ];\n    do\n      if [ \"$timeout\" == 0 ]; then\n        echo \"ERROR: Timeout while waiting for /var/lib/grafana/data/grafana.db.\"\n        exit 1\n      fi\n\n      sleep 1\n\n      ((timeout--))\n    done\n\n    find /var/lib/grafana -type d -exec chmod -v 775 {} \\;\n    find /var/lib/grafana -type f -exec chmod -v 660 {} \\;\n  '';\n\n  services.litestream = {\n    enable = true;\n\n    environmentFile = \"/run/secrets/litestream\";\n\n    settings = {\n      dbs = [\n        {\n          path = \"/var/lib/grafana/data/grafana.db\";\n          replicas = [{\n            url = \"s3://mybkt.litestream.io/grafana\";\n          }];\n        }\n      ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting additional pnpm configuration options\nDESCRIPTION: Example showing how to set additional pnpm configuration options like dedupe-peer-dependants using the prePnpmInstall hook in a Nix derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{\n  prePnpmInstall = ''\n    pnpm config set dedupe-peer-dependants false\n  '';\n  pnpmDeps = pnpm.fetchDeps {\n    inherit (finalAttrs) prePnpmInstall;\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Module Update Review Checklist Template - Markdown\nDESCRIPTION: This markdown snippet provides a review checklist for NixOS module updates, encompassing backward compatibility, proper declaration of removed options, documentation updates, and appropriate option types. Reviewers should use this template to verify their assessments are complete and consistent. Items are presented as markdown checkboxes and comments sections for clarity and easy adoption in platform discussions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/README.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n##### Reviewed points\n\n- [ ] changes are backward compatible\n- [ ] removed options are declared with `mkRemovedOptionModule`\n- [ ] changes that are not backward compatible are documented in release notes\n- [ ] module tests succeed on ARCHITECTURE\n- [ ] options types are appropriate\n- [ ] options description is set\n- [ ] options example is provided\n- [ ] documentation affected by the changes is updated\n\n##### Possible improvements\n\n##### Comments\n```\n\n----------------------------------------\n\nTITLE: Running Hydra Database ID Backfill Command\nDESCRIPTION: Shell command to automatically fill newly added ID columns in the Hydra database after migration. This process may take some time depending on the database size.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ hydra-backfill-ids\n```\n\n----------------------------------------\n\nTITLE: Including Parts in NixOS Manual\nDESCRIPTION: Defines the main parts of the NixOS manual by including files for installation, configuration, administration, and development sections.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/manual.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} parts\ninstallation/installation.md\nconfiguration/configuration.md\nadministration/running.md\ndevelopment/development.md\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Dhall Expression with Prelude Dependency\nDESCRIPTION: This snippet shows a basic Dhall expression that imports the Prelude and uses it to negate a boolean value. It demonstrates the use of remote imports in Dhall.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_0\n\nLANGUAGE: dhall\nCODE:\n```\n-- ./true.dhall\n\nlet Prelude = https://prelude.dhall-lang.org/v20.1.0/package.dhall\n\nin  Prelude.Bool.not False\n```\n\n----------------------------------------\n\nTITLE: Enabling Documentation for All Packages in Environment - Nix - nix\nDESCRIPTION: Demonstrates the experimental __overrideTeXConfig function for a TeX Live environment, enabling inclusion of documentation for all packages by setting withDocs to true. This approach modifies how withPackages returns outputs, and support for related options may change. Prerequisite: texliveSmall.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\ntexliveSmall.__overrideTeXConfig { withDocs = true; }\n```\n\n----------------------------------------\n\nTITLE: Checking Broken Haskell Packages in Nixpkgs\nDESCRIPTION: These commands check which Haskell packages are broken based on the Hydra build report. They are used before marking packages as broken.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/hydra-report.hs get-report\n$ ./maintainers/scripts/haskell/hydra-report.hs mark-broken-list\n```\n\n----------------------------------------\n\nTITLE: Overriding a Python Package Name with packageOverrides - Nix\nDESCRIPTION: This Nix code demonstrates how to override the attributes of a Python package ('pandas') using packageOverrides. The overridePythonAttrs function sets a new name ('foo') for the pandas package, and the modified interpreter is then used to instantiate a Python environment. Dependencies include access to the pkgs set and knowledge of the overridePythonAttrs mechanism. The snippet outputs an environment where pandas is renamed, useful for testing or introducing custom package versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_46\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(\n  let\n    python =\n      let\n        packageOverrides = self: super: {\n          pandas = super.pandas.overridePythonAttrs (old: {\n            name = \"foo\";\n          });\n        };\n      in\n      pkgs.python310.override {\n        inherit packageOverrides;\n      };\n\n  in\n  python.withPackages (ps: [\n    ps.pandas\n  ])\n).env\n\n```\n\n----------------------------------------\n\nTITLE: Adding a Maintainer with GitHub Information in Nixpkgs\nDESCRIPTION: Example of a maintainer entry in maintainer-list.nix that includes email, name, GitHub username, and GitHub ID. Both github and githubId fields are required for maintainers with GitHub accounts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  example = {\n    email = \"user@example.com\";\n    name = \"Example User\";\n    github = \"ghost\";\n    githubId = 10137;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IBus Input Method with New Syntax\nDESCRIPTION: Examples showing both old and new configuration syntax for IBus input method after its options were moved to i18n namespace.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n    i18n.inputMethod.enabled = \"ibus\";\n    i18n.inputMethod.ibus.engines = with pkgs.ibus-engines; [ anthy mozc ];\n  }\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n    programs.ibus.enable = true;\n    programs.ibus.plugins = with pkgs; [ ibus-anthy mozc ];\n  }\n```\n\n----------------------------------------\n\nTITLE: Setting xfce4-session to Launch GNOME Services - ShellSession\nDESCRIPTION: This ShellSession command enables the 'Launch GNOME services on startup' setting within the xfce4-session component, using 'xfconf-query'. Running this command ensures that needed background services run at startup, which can resolve volume management issues in Thunar. It requires the user to have local shell access and the 'xfconf-query' utility available, and the changes take effect upon the next login.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/xfce.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ xfconf-query -c xfce4-session -p /compat/LaunchGNOME -s true\n```\n\n----------------------------------------\n\nTITLE: Basic Service Control Commands\nDESCRIPTION: Shows basic systemctl commands for stopping, starting, and restarting services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemctl stop postgresql.service\n# systemctl start postgresql.service\n# systemctl restart postgresql.service\n```\n\n----------------------------------------\n\nTITLE: Executing Perl Scripts Using Environment Paths - Perl\nDESCRIPTION: This Perl shebang line snippet ensures that the Perl interpreter is resolved from the user\\'s PATH, facilitating script portability in environments where Perl is not installed at a fixed location (e.g., with Nix). No dependencies are required beyond a Perl installation available in the PATH. The only input is the script file using this shebang; output is proper execution if Perl is present. This avoids hardcoding interpreter paths.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_0\n\nLANGUAGE: perl\nCODE:\n```\n#!/usr/bin/env perl\n```\n\n----------------------------------------\n\nTITLE: Invoking Specific Build Phases with genericBuild - Bash\nDESCRIPTION: This Bash snippet shows how to run a subset of Nix build phases interactively by setting the phases environment variable and calling genericBuild. It is commonly used inside nix-shell for stepwise debugging and examination of specific build stages. Prerequisite: genericBuild and all relevant shell functions must be defined in the current environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nphases=\"${prePhases[*]:-} unpackPhase patchPhase\" genericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Workaround for install_data or data_files Permission Errors - Shell\nDESCRIPTION: This shell snippet shows how to work around setuptools' ignoring of the --prefix option for install_data/data_files, which can result in permission errors when installing into the Nix store. It runs setup.py with specific parameters to control the install location and edits setup.py to remove data_files usage. Requires the environment variable $out to be set, and assumes execution inside a buildPhase or similar. The workaround lets you manually relocate and patch data files during build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_50\n\nLANGUAGE: shell\nCODE:\n```\n${python.pythonOnBuildForHost.interpreter} setup.py install_data --install-dir=$out --root=$out\nsed -i '/ = data\\_files/d' setup.py\n\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Configurations\nDESCRIPTION: Demonstration of using mkMerge to combine multiple sets of option definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = mkMerge\n    [ # Unconditional stuff.\n      { environment.systemPackages = [ /* ... */ ];\n      }\n      # Conditional stuff.\n      (mkIf config.services.bla.enable {\n        environment.systemPackages = [ /* ... */ ];\n      })\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS VM Automatic Login Output - ShellSession\nDESCRIPTION: Sample output showing the startup process of the NixOS VM started by darwin.linux-builder, culminating in an automatic login as the 'builder' user. Demonstrates the successful boot and configuration of the VM, which is crucial for remote builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n<<< Welcome to NixOS 22.11.20220901.1bd8d11 (aarch64) - ttyAMA0 >>>\n\nRun 'nixos-help' for the NixOS manual.\n\nnixos login: builder (automatic login)\n\n\n[builder@nixos:~]$\n\n```\n\n----------------------------------------\n\nTITLE: Additional Natural Deduction Rules for Dependency Propagation\nDESCRIPTION: Continuation of the formal rules for dependency propagation, explaining how immediate dependencies' propagated dependencies are handled and how propagated dependencies are treated as regular dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nlet mapOffset(h, t, i) = i + (if i <= 0 then h else t - 1)\n\ndep(h0, t0, A, B)\npropagated-dep(h1, t1, B, C)\nh0 + h1 in {-1, 0, 1}\nh0 + t1 in {-1, 0, 1}\n----------------------------- Take immediate dependencies' propagated dependencies\npropagated-dep(mapOffset(h0, t0, h1),\n               mapOffset(h0, t0, t1),\n               A, C)\n```\n\n----------------------------------------\n\nTITLE: Memory-Only Storage Configuration for Athens\nDESCRIPTION: Configuration to run Athens with in-memory storage only, preventing disk writes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/athens.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.athens = {\n      enable = true;\n      storageType = \"memory\";\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Including External Markdown Sections Using Markdown Metadata Block - Markdown\nDESCRIPTION: This snippet uses the Markdown directive syntax ({=include=}) to programmatically inject the contents of another Markdown file (rl-2505.section.md) into the current document. It requires a Markdown processor or documentation engine that recognizes the {=include=} notation, such as mdBook or specific static site generators. The only parameter is the filename to include. The included content will replace the directive at build time, supporting modular documentation organization and reuse.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/release-notes/release-notes.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\nrl-2505.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Bash Array Mutation and Equality - Nix - nix\nDESCRIPTION: This Nix example uses testers.testEqualArrayOrMap to assert that a function (addCowbell) correctly mutates a bash array. It initializes test arrays, runs a shell script to append values and call the function, and compares the result to expectedArray. It's useful for shell-level testing of hooks or array transformations in the builder context, requiring bash and Nix testing infrastructure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\ntesters.testEqualArrayOrMap {\n  name = \"test-function-add-cowbell\";\n  valuesArray = [\n    \"cowbell\"\n    \"cowbell\"\n  ];\n  expectedArray = [\n    \"cowbell\"\n    \"cowbell\"\n    \"cowbell\"\n  ];\n  script = ''\n    addCowbell() {\n      local -rn arrayNameRef=\"$1\"\n      arrayNameRef+=( \"cowbell\" )\n    }\n\n    nixLog \"appending all values in valuesArray to actualArray\"\n    for value in \"''${valuesArray[@]}\"; do\n      actualArray+=( \"$value\" )\n    done\n\n    nixLog \"applying addCowbell\"\n    addCowbell actualArray\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Composing a Multi-SDK Dotnet Environment Using dotnetCorePackages.combinePackages (Nix)\nDESCRIPTION: This Nix code example shows how to configure a development environment that contains multiple Dotnet SDK versions using combinePackages. The mkShell function is used with a custom package list, leveraging dotnetCorePackages.combinePackages to include sdk_8_0 and sdk_9_0. This is essential for projects requiring multiple SDKs. Requires Nix and access to the dotnetCorePackages attribute set. The first SDK listed will be the default CLI. Version numbers must match available package versions in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nmkShell {\n  name = \"dotnet-env\";\n  packages = [\n    (\n      with dotnetCorePackages;\n      combinePackages [\n        sdk_8_0\n        sdk_9_0\n      ]\n    )\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Python Package Override for All Versions Using Extensions\nDESCRIPTION: Demonstrates how to override Python packages across all interpreter versions using pythonPackagesExtensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_55\n\nLANGUAGE: nix\nCODE:\n```\nfinal: prev: {\n  pythonPackagesExtensions = prev.pythonPackagesExtensions ++ [\n    (python-final: python-prev: {\n      foo = python-prev.foo.overridePythonAttrs (oldAttrs: {\n        # ...\n      });\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Testing a New Gem with Nix Shell\nDESCRIPTION: Command to test a newly added gem using Nix shell with a custom Nixpkgs path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nNIX_PATH=nixpkgs=$PWD nix-shell -p \"ruby.withPackages (ps: with ps; [ name-of-your-gem ])\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Nix Flakes Support - Nix - Nix\nDESCRIPTION: Highlights the need to enable experimental Flakes support in Nix 2.8 by modifying configuration options explicitly. The 'nix' command and Flakes feature remain experimental and must be enabled by end-users via configuration as documented in accompanying release notes. Inputs are configuration file entries, outputs are enabled experimental features.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nnix\n```\n\n----------------------------------------\n\nTITLE: Including Markdown Chapters for Documentation Organization in Markdown\nDESCRIPTION: This snippet demonstrates the use of the Jupyter Book or MyST Markdown syntax to include an entire chapter (interoperability/cyclonedx.md) into the current documentation context. Required dependencies include a documentation generator that supports {=include=} directives, such as Jupyter Book or a compatible Sphinx/MyST parser. The key parameter is the path to the file to be included, and output is the inlined contents of the specified markdown file. This approach enables modular documentation but requires compatible tooling.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/interoperability.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\ninteroperability/cyclonedx.md\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing FoundationDB Data Directory - Nix - nix\nDESCRIPTION: This code sample demonstrates how to override the default data directory used by FoundationDB in the NixOS service configuration. By setting services.foundationdb.dataDir to a custom path (e.g., '/data/fdb'), a user may redirect where FoundationDB stores its persistent data. This option must be included in the NixOS configuration and requires sufficient permissions for the FoundationDB process. No special dependencies beyond a correctly configured FoundationDB module are needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/foundationdb.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.foundationdb.dataDir = \"/data/fdb\";\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building and Loading a Nix-Generated Docker Image with Extra Build Inputs - Shell\nDESCRIPTION: This shell command sequence shows how to perform a nix-build to produce the Docker image, and then use the produced script to load the image into Docker. The process applies to images produced with added build dependencies (like cowsay) as well. Requirements are the same as for basic usage: a working Nix install, suitable system permissions, and Docker.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_39\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/h5abh0vljgzg381lna922gqknx6yc0v7-stream-hello-2.12.1-env\n\n$ /nix/store/h5abh0vljgzg381lna922gqknx6yc0v7-stream-hello-2.12.1-env | docker image load\n(some output removed for clarity)\nLoaded image: hello-2.12.1-env:latest\n```\n\n----------------------------------------\n\nTITLE: Building an Idris2 Library Package with Nix\nDESCRIPTION: Example of packaging the `LSP-lib` library using the `buildIdris` function. This demonstrates fetching the source from GitHub and configuring a simple library without dependencies. The library is built with source code included to support IDE features.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris2.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchFromGitHub, idris2Packages }:\nlet\n  lspLibPkg = idris2Packages.buildIdris {\n    ipkgName = \"lsp-lib\";\n    src = fetchFromGitHub {\n      owner = \"idris-community\";\n      repo = \"LSP-lib\";\n      rev = \"main\";\n      hash = \"sha256-EvSyMCVyiy9jDZMkXQmtwwMoLaem1GsKVFqSGNNHHmY=\";\n    };\n    idrisLibraries = [ ];\n  };\nin\nlspLibPkg.library { withSource = true; }\n```\n\n----------------------------------------\n\nTITLE: Refreshing Bootstrap Tarballs for Target Architecture using Bash Script\nDESCRIPTION: This code snippet demonstrates how to run the refresh-tarballs Bash script to update bootstrap tarballs for a specified target architecture in the Nixpkgs repository. The '--commit' flag commits the result, and '--targets' specifies which architecture to process. Requires the maintainers/scripts/bootstrap-files/refresh-tarballs.bash script in the repo and commit access. Takes architecture identifier as input and produces updated seed tarballs for use in later build/test steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/scripts/bootstrap-files/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ maintainers/scripts/bootstrap-files/refresh-tarballs.bash --commit --targets=i686-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Recommending Modesetting Driver for Intel GPUs - Nix\nDESCRIPTION: Sets services.xserver.videoDrivers to use the 'modesetting' driver, which is recommended for modern Intel hardware. Ensures the X.org server uses kernel mode setting, supporting modern acceleration features. Best for most Intel GPUs except very old chipsets.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.videoDrivers = [ \"modesetting\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Plugins to Urxvt in Nix\nDESCRIPTION: This code shows how to add custom plugins while keeping all default plugins in Urxvt. It combines all available plugins with a custom plugin using the 'builtins.attrValues' function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/urxvt.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nrxvt-unicode.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      plugins = (builtins.attrValues availablePlugins) ++ [ custom-plugin ];\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Memcached Port with Test Hook - Nix\nDESCRIPTION: This snippet sets the memcachedTestPort variable in the preCheck phase of a Nix derivation to change the port Memcached listens on from the default (11211) to 1234. It demonstrates extending the test environment with Bash-only variables for specific testing requirements. Dependency: memcachedTestHook. Input: assignment of memcachedTestPort in preCheck. Output: Memcached runs on the specified port for the test duration. Limitation: Works only in Bash contexts within the derivation execution.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/memcached-test-hook.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, memcachedTestHook }:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeCheckInputs = [\n    memcachedTestHook\n  ];\n\n  preCheck = ''\n    memcachedTestPort=1234;\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Writing the Closure of Store Paths to a Text File - writeClosure - Nix\nDESCRIPTION: This example demonstrates using writeClosure to capture the complete closure for a set of Nix store paths. It takes a list (containing a result of writeScriptBin referencing hello), and writes all transitive dependencies to a single output file. All intermediate and direct inputs needed to execute the bin are included in the closure output, resembling the result of 'nix-store -q --requisites'. The snippet requires all referenced paths to be available in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\nwriteClosure [ (writeScriptBin \"hi\" ''${hello}/bin/hello'') ]\n```\n\n----------------------------------------\n\nTITLE: Specifying Output Hashes for Git Dependencies - buildRustPackage - Nix\nDESCRIPTION: Displays how to provide output hashes in `cargoLock.outputHashes` for dependencies sourced from git, ensuring correct and reproducible builds when using non-registry crates. The mapping is from `crate-version` to a fixed-output store path. Used as part of the `cargoLock` attribute, this is required for each git-sourced dependency; the correct hash is generally discovered by using a fake value initially.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  pname = \"myproject\";\n  version = \"1.0.0\";\n\n  cargoLock = {\n    lockFile = ./Cargo.lock;\n    outputHashes = {\n      \"finalfusion-0.14.0\" = \"17f4bsdzpcshwh74w5z119xjy2if6l2wgyjy56v621skr2r8y904\";\n    };\n  };\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting wpa_supplicant Service\nDESCRIPTION: Command to restart the wpa_supplicant service after making changes to the configuration file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/wireless.section.md#_snippet_5\n\nLANGUAGE: shellsession\nCODE:\n```\n# systemctl restart wpa_supplicant.service\n```\n\n----------------------------------------\n\nTITLE: Customizing PostgreSQL Data Directory Path - Nix - Nix\nDESCRIPTION: Specifies explicit setting of the postgresql dataDir option to maintain backward compatibility when upgrading NixOS and the PostgreSQL module. This setting is necessary for systems with old NixOS state versions (< 17.03). Inputs are Nix attribute assignments; output is the preservation of the existing data storage path. Requires Nixpkgs with the PostgreSQL module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql.dataDir = \"/var/db/postgresql\";\n}\n```\n\n----------------------------------------\n\nTITLE: Building Only the configuration.nix Manpage - Nix/Nixpkgs - ShellSession\nDESCRIPTION: This code snippet illustrates building just the configuration.nix(5) manpage from the Nixpkgs tree for quick iteration and preview. Substitute x86_64-linux as needed for other architectures. The process requires a functional nixpkgs checkout, Nix, and appropriate platform support. The output is a man page in result/share/man/man5/configuration.nix.5.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/contributing-to-this-manual.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ cd /path/to/nixpkgs\\n$ nix-build nixos/release.nix -A nixos-configuration-reference-manpage.x86_64-linux\\n```\n```\n\n----------------------------------------\n\nTITLE: Building a D Project with buildDubPackage (Nix)\nDESCRIPTION: This Nix expression demonstrates packaging a D project using the buildDubPackage helper, incorporating dependencies with dub, and handling installation via a custom installPhase. Dependencies such as dub-to-nix for lockfile generation, and additional build inputs like ncurses and zlib, are specified. Key parameters include the lockfile path (dubLock), source fetching with fetchFromGitHub, and manual definition of installPhase because dub does not handle $out placement; expected input is a D project with corresponding lockfile, and output is an installable derivation packaged for Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dlang.section.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  lib,\n  buildDubPackage,\n  fetchFromGitHub,\n  ncurses,\n  zlib,\n}:\n\nbuildDubPackage rec {\n  pname = \"btdu\";\n  version = \"0.5.1\";\n\n  src = fetchFromGitHub {\n    owner = \"CyberShadow\";\n    repo = \"btdu\";\n    tag = \"v${version}\";\n    hash = \"sha256-3sSZq+5UJH02IO0Y1yL3BLHDb4lk8k6awb5ZysBQciE=\";\n  };\n\n  # generated by dub-to-nix, see below\n  dubLock = ./dub-lock.json;\n\n  buildInputs = [\n    ncurses\n    zlib\n  ];\n\n  installPhase = ''\n    runHook preInstall\n    install -Dm755 btdu -t $out/bin\n    runHook postInstall\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Nix Expression for Layered Docker Image Example - Nix\nDESCRIPTION: This snippet demonstrates a typical Nix expression that builds a layered Docker image using dockerTools. Functions and necessary packages are passed as arguments, making the snippet self-contained and ready for pkgs.callPackage. Inputs are the dockerTools and hello packages; output is a Nix docker image derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_6\n\nLANGUAGE: Nix\nCODE:\n```\n{ dockerTools, hello }:\\ndockerTools.buildLayeredImage {\\n  name = \\\"hello\\\";\\n  contents = [ hello ];\\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Emacs Service for Current User\nDESCRIPTION: SystemD command to enable the Emacs service for the current user only.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsystemctl --user enable emacs\n```\n\n----------------------------------------\n\nTITLE: Copying and Initializing New Kanidm Version - Shell\nDESCRIPTION: These shell commands initialize a new Kanidm package version by copying the configuration Nix file and related patches from the previous version's directory, setting up the directory structure for the upgraded version. Prerequisites include existing files for the previous Kanidm version (e.g. 1_4.nix) and corresponding patch directories. The resulting files serve as a basis for further package definition updates before adding them to version control. Replace version numbers as needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ka/kanidm/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncp pkgs/by-name/ka/kanidm/1_4.nix pkgs/by-name/ka/kanidm/1_5.nix\n```\n\nLANGUAGE: shell\nCODE:\n```\ncp -r pkgs/by-name/ka/kanidm/patches/1_4 pkgs/by-name/ka/kanidm/patches/1_5\n```\n\n----------------------------------------\n\nTITLE: Resetting baloo Indexer After Device ID Changes - KDE/Baloo - Bash\nDESCRIPTION: This shell code snippet shows how to reset the baloo file indexer in KDE when upgrading to the patched NixOS version that mitigates reindex loops caused by changing device IDs (such as on Btrfs or LVM). It disables baloo, purges the old index, and re-enables the service, providing a clean state for the patched behavior. It expects balooctl to be installed and used in a terminal. The main constraint is that this action should only be performed as part of migration to an upgraded system or when issues are encountered.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbalooctl disable ; balooctl purge ; balooctl enable\n```\n\n----------------------------------------\n\nTITLE: Testing Package Availability in nix-shell Python Interpreter - Python Console - Python Console\nDESCRIPTION: Illustrates the import of modules (numpy, toolz) in a Python interpreter launched within nix-shell, ensuring packages requested in nix-shell command are available. As this is an interactive interpreter session, outputs and errors are displayed directly in the console, highlighting successful imports.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_14\n\nLANGUAGE: Python console\nCODE:\n```\n[nix-shell:~/src/nixpkgs]$ python3\nPython 3.12.4 (main, Jun  6 2024, 18:26:44) [GCC 13.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import numpy; import toolz\n```\n\n----------------------------------------\n\nTITLE: goModules Override Example\nDESCRIPTION: Example demonstrating how to override goModules attributes using overrideModAttrs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pet-overridden = pet.overrideAttrs (\n    finalAttrs: previousAttrs: {\n      passthru = previousAttrs.passthru // {\n        overrideModAttrs = lib.composeExtensions previousAttrs.passthru.overrideModAttrs (\n          finalModAttrs: previousModAttrs: {\n            postBuild = ''\n              substituteInPlace vendor/github.com/example/repo/file.go \\\n                --replace-fail \"panic(err)\" \"\"\n            '';\n          }\n        );\n      };\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing SSHFS Mount Logs for Troubleshooting\nDESCRIPTION: Command to access verbose logs of SSHFS for troubleshooting mount issues. This requires adding the 'debug' option to the SSHFS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ journalctl -u $(systemd-escape -p /mnt/my-dir/).mount\nJun 22 11:41:18 workstation mount[87790]: SSHFS version 3.7.1\nJun 22 11:41:18 workstation mount[87793]: executing <ssh> <-x> <-a> <-oClearAllForwardings=yes> <-oServerAliveInterval=15> <-oIdentityFile=/var/secrets/wrong-key> <-2> <my-user@example.com> <-s> <sftp>\nJun 22 11:41:19 workstation mount[87793]: my-user@example.com: Permission denied (publickey).\nJun 22 11:41:19 workstation mount[87790]: read: Connection reset by peer\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Mount process exited, code=exited, status=1/FAILURE\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Failed with result 'exit-code'.\nJun 22 11:41:19 workstation systemd[1]: Failed to mount /mnt/my-dir.\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Consumed 54ms CPU time, received 2.3K IP traffic, sent 2.7K IP traffic.\n```\n\n----------------------------------------\n\nTITLE: Running NixOS-Rebuild to Switch Configuration - ShellSession\nDESCRIPTION: This snippet demonstrates how to invoke 'nixos-rebuild switch' from the command line to build the new configuration, set it as the boot default, and attempt to activate it immediately on the running system. Requires root privileges. Input: None; Output: Applies the latest configuration changes. Dependency: 'nixos-rebuild' tool must be available in your PATH.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch\n```\n\n----------------------------------------\n\nTITLE: Listing Python Packages with nix-env\nDESCRIPTION: Demonstrates how to list all Python packages available in Nixpkgs using nix-env command. Shows package names and their corresponding versions from the nixpkgs-unstable channel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/index.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-env -qaP -f '<nixpkgs>' -A pythonPackages -I nixpkgs=channel:nixpkgs-unstable\n```\n\nLANGUAGE: console\nCODE:\n```\npythonPackages.avahi                                                  avahi-0.8\npythonPackages.boost                                                  boost-1.81.0\npythonPackages.caffe                                                  caffe-1.0\npythonPackages.caffeWithCuda                                          caffe-1.0\npythonPackages.cbeams                                                 cbeams-1.0.3\n…\n```\n\n----------------------------------------\n\nTITLE: Creating and Installing Custom Mods for Cataclysm-DDA\nDESCRIPTION: Comprehensive example showing how to modify existing mods and add new custom mods, soundpacks, and tilesets not available in nixpkgs. Demonstrates the use of buildMod, buildSoundPack, and buildTileSet functions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  customMods =\n    self: super:\n    lib.recursiveUpdate super {\n      # Modify existing mod\n      tileset.UndeadPeople = super.tileset.UndeadPeople.overrideAttrs (old: {\n        # If you like to apply a patch to the tileset for example\n        patches = [ ./path/to/your.patch ];\n      });\n\n      # Add another mod\n      mod.Awesome = cataclysmDDA.buildMod {\n        modName = \"Awesome\";\n        version = \"0.x\";\n        src = fetchFromGitHub {\n          owner = \"Someone\";\n          repo = \"AwesomeMod\";\n          rev = \"...\";\n          hash = \"...\";\n        };\n        # Path to be installed in the unpacked source (default: \".\")\n        modRoot = \"contents/under/this/path/will/be/installed\";\n      };\n\n      # Add another soundpack\n      soundpack.Fantastic = cataclysmDDA.buildSoundPack {\n        # ditto\n      };\n\n      # Add another tileset\n      tileset.SuperDuper = cataclysmDDA.buildTileSet {\n        # ditto\n      };\n    };\nin\ncataclysm-dda.withMods (\n  mods: with mods.extend customMods; [\n    tileset.UndeadPeople\n    mod.Awesome\n    soundpack.Fantastic\n    tileset.SuperDuper\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Deploying Only the Platform-Tools Predefined Package - Nix\nDESCRIPTION: Demonstrates how to include only the Android platform-tools from a predefined androidenv.androidPkgs set in a Nix environment. This provides just the core command-line Android tools, making it suitable for streamlined environments, scripting, or build servers that need minimal SDK components.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nandroidenv.androidPkgs.platform-tools\n```\n\n----------------------------------------\n\nTITLE: Packaging a Simple Factor Application with buildFactorApplication - Nix\nDESCRIPTION: This Nix snippet demonstrates how to use buildFactorApplication to package a simple Factor application called 'foo'. It specifies the required arguments, sets the package name and version, and defines the source download mechanism using fetchurl. The build expects the source directory to contain a specific structure, and the resulting package will provide a /bin/foo application. Required dependencies are nixpkgs.lib, fetchurl, and factorPackages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/factor.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  fetchurl,\n  factorPackages,\n}:\n\nfactorPackages.buildFactorApplication (finalAttrs: {\n  pname = \"foo\";\n  version = \"1.0\";\n\n  src = fetchurl {\n    url = \"https://some-forge.org/foo-${finalAttrs.version}.tar.gz\";\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Local Branch with Remote Channel using Git Merge in ShellSession\nDESCRIPTION: This snippet demonstrates synchronizing a local Git branch with the latest changes from a remote NixOS channel branch via 'git merge'. Requires an established local branch and a valid remote branch reference. It helps keep local customizations up to date with ongoing channels, accepting inputs as branch names and producing a merged branch state.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git remote update origin\n$ git merge origin/nixos-17.03\n```\n\n----------------------------------------\n\nTITLE: Wrapping Arbitrary Derivations as Python Modules with toPythonModule in Nix\nDESCRIPTION: Demonstrates using toPythonModule to adapt a general Nix derivation (for example, a C++ OpenCV build) into a Python module compatible with the Python package set. This method is essential for projects that build Python bindings in non-standard ways. Requires an OpenCV derivation with PYTHON enabled and awareness of version compatibility. Ensures that the resulting derivation is properly available to Python environments created via python-packages.nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  opencv = toPythonModule (\n    pkgs.opencv.override {\n      enablePython = true;\n      pythonPackages = self;\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Nim Package Attributes with overrideNimAttrs - Nix Expression - Nix\nDESCRIPTION: This Nix code demonstrates how to use 'overrideNimAttrs' to override source and lockFile attributes before dependencies and flags are generated for a Nim package. This allows changing sources and lockfile-based dependencies in packages built with 'buildNimPackage'. Dependencies: An existing Nim package, typically from 'pkgs'. Inputs: attrset with src and lockFile values. Output: Overridden Nim package derivation. Limitation: Only applicable prior to lockFile-based dependency resolution.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\npkgs.nitter.overrideNimAttrs {\n  # using a different source which has different dependencies from the standard package\n  src = pkgs.fetchFromGithub {\n    # …\n  };\n  # new lock file generated from the source\n  lockFile = ./custom-lock.json;\n}\n```\n\n----------------------------------------\n\nTITLE: SNIS Asset Verification Hashes\nDESCRIPTION: SHA256 hash values paired with corresponding file paths for SNIS game assets. Includes sound effects, UI sounds, voice clips, 3D models, textures and material files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sn/snis-assets/manifest.txt#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nlMSgVlq5FA54KmLsgunTT6aL0NRMMU0tt+YvCz5PRWI=  share/snis/sounds/ui16.ogg\nzMYjh+1jm9IvWYHo/u1Yj1VuFvMJ8Iwb7CN0+VDoJig=  share/snis/sounds/dangerous-radiation.ogg\nwSgcpszHLNfaxJLmNO7XYmiomLLzZ2ZtwV0TRvKOXYI=  share/snis/sounds/missile_launch.ogg\n```\n\n----------------------------------------\n\nTITLE: Defining an Anchor in a Markdown Heading - Markdown\nDESCRIPTION: This snippet shows how to define an explicit anchor in a Markdown heading using header attributes. This approach ensures that section links remain stable even if the heading text changes. It requires a Markdown processor supporting the attributes extension. The expected input is any heading, and the output is a heading with an anchor ID.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n## Syntax {#sec-contributing-markup}\n```\n\n----------------------------------------\n\nTITLE: Complete NixOS Installation Command Sequence\nDESCRIPTION: Full sequence of commands for installing NixOS on a partitioned disk, including filesystem creation, mounting, configuration generation, and installation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_25\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkfs.ext4 -L nixos /dev/sda1\n# mkswap -L swap /dev/sda2\n# swapon /dev/sda2\n# mkfs.fat -F 32 -n boot /dev/sda3        # (for UEFI systems only)\n# mount /dev/disk/by-label/nixos /mnt\n# mkdir -p /mnt/boot                      # (for UEFI systems only)\n# mount -o umask=077 /dev/disk/by-label/boot /mnt/boot # (for UEFI systems only)\n# nixos-generate-config --root /mnt\n# nano /mnt/etc/nixos/configuration.nix\n# nixos-install\n# reboot\n```\n\n----------------------------------------\n\nTITLE: Including Sections in Markdown Documentation for NixOS Special Build Helpers\nDESCRIPTION: This code snippet uses a custom Markdown directive to include multiple section files related to special build helpers in NixOS. It references sections for fake NSS, FHS environments, setup hooks, mkShell, VM tools, and checkpoint builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\nspecial/fakenss.section.md\nspecial/fhs-environments.section.md\nspecial/makesetuphook.section.md\nspecial/mkshell.section.md\nspecial/vm-tools.section.md\nspecial/checkpoint-build.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking runCommandWith to Create a Derivation - Nix\nDESCRIPTION: This snippet demonstrates how to use `runCommandWith` in Nix to build a derivation by specifying various attributes (including `name` and build input) and a shell command for the build. Usage of `runCommandWith` requires a structured attribute set and a build command string. The function allows fine-grained control over the build environment and outputs the resulting derivation's store path. Dependencies such as the specified native build input (like `cowsay`) must be available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nrunCommandWith\n  {\n    name = \"example\";\n    derivationArgs.nativeBuildInputs = [ cowsay ];\n  }\n  ''\n    cowsay > $out <<EOMOO\n    'runCommandWith' is a bit cumbersome,\n    so we have more ergonomic wrappers.\n    EOMOO\n  ''\n```\n\n----------------------------------------\n\nTITLE: Adding New Release and Setting Default Version for Coq Package in Nix\nDESCRIPTION: This snippet demonstrates how to use overrideCoqDerivation to add a new release of the multinomials library and set it as the default version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\ncoqPackages.lib.overrideCoqDerivation {\n  defaultVersion = \"2.0\";\n  release.\"2.0\".hash = \"sha256-czoP11rtrIM7+OLdMisv2EF7n/IbGuwFxHiPtg3qCNM=\";\n} coqPackages.multinomials\n```\n\n----------------------------------------\n\nTITLE: Selectively Overriding Prelude for a Specific Package\nDESCRIPTION: Nix expression demonstrating how to override the Prelude dependency only for a specific package. This approach allows different packages to use different versions of the Prelude.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dhallOverrides = self: super: {\n    true = self.callPackage ./true.nix {\n      Prelude = self.callPackage ./Prelude.nix { };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Attribute Sets of Submodules Option (Nix)\nDESCRIPTION: Defines an option 'mod' that takes an attribute set (dictionary) mapping to submodules, each with 'foo' (int) and 'bar' (str) fields. Leverages the 'attrsOf' and 'submodule' combinators from the NixOS module system with mkOption. The option expects a set of attribute names, each value following the submodule schema; suitable for named collections.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  options.mod = mkOption {\n    description = \"submodule example\";\n    type = with types; attrsOf (submodule {\n      options = {\n        foo = mkOption {\n          type = int;\n        };\n        bar = mkOption {\n          type = str;\n        };\n      };\n    });\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Perl Packages in all-packages.nix - Nix\nDESCRIPTION: This Nix snippet imports a package definition while explicitly inheriting dependencies, including those from perlPackages. Dependencies are other Nix derivations, possibly from Perl package set. Parameters include references to stdenv, fetchurl, and ClassC3. Used in all-packages.nix to combine package derivations and manage dependencies for Perl-enabled packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  foo = import ../path/to/foo.nix {\n    inherit\n      stdenv\n      fetchurl # ...\n      ;\n    inherit (perlPackages) ClassC3;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Pytest Test Phase Configuration for Python Package - Nix\nDESCRIPTION: This minimal Nix snippet configures the test phase (checkPhase) for a Python package using Pytest directly. It sets pytest as a nativeCheckInput and defines a shell snippet to run pytest, with hooks before and after running the tests. This approach is used for testing Python packages inside the Nix build sandbox when full automation with pytestCheckHook is not suited. The expected input is a Nix derivation context with pytest available. All test file paths and item filtering must be managed manually if needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_32\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeCheckInputs = [ pytest ];\n  checkPhase = ''\n    runHook preCheck\n\n    pytest\n\n    runHook postCheck\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Explicit Netbird Service Configuration in NixOS\nDESCRIPTION: Equivalent to the basic configuration but with explicit parameters. Sets up the netbird service on port 51820 with wt0 interface, and installs both netbird and netbird-wt0 binaries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/netbird.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.netbird.clients.wt0 = {\n    port = 51820;\n    name = \"netbird\";\n    interface = \"wt0\";\n    hardened = false;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning iOS Simulator Instances with Nix\nDESCRIPTION: This Nix expression shows how to create a script for spawning iOS simulator instances using the xcode.simulateApp function. It demonstrates basic usage without app deployment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ios.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n\n  xcodeenv = import ./xcodeenv {\n    inherit (pkgs) stdenv;\n  };\nin\nxcode.simulateApp {\n  name = \"simulate\";\n\n  # Supports all xcodewrapper parameters as well\n  xcodeBaseDir = \"/Applications/Xcode.app\";\n}\n```\n\n----------------------------------------\n\nTITLE: Running NixOS tests for specific version\nDESCRIPTION: Command to build and run important NixOS tests for a specific Nix version\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/tools/package-management/nix/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnix-build nixVersions.nix_$version.tests\n```\n\n----------------------------------------\n\nTITLE: Configuring Overlayfs Mounts in NixOS\nDESCRIPTION: Example configuration showing how to set up both writable and read-only overlayfs mounts in NixOS. The writable overlay specifies upperdir and workdir locations, while the read-only overlay only defines multiple lowerdirs. The writable overlay is configured to mount during the initrd phase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/overlayfs.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems = {\n    \"/writable-overlay\" = {\n      overlay = {\n        lowerdir = [ writableOverlayLowerdir ];\n        upperdir = \"/.rw-writable-overlay/upper\";\n        workdir = \"/.rw-writable-overlay/work\";\n      };\n      # Mount the writable overlay in the initrd.\n      neededForBoot = true;\n    };\n    \"/readonly-overlay\".overlay.lowerdir = [\n      writableOverlayLowerdir\n      writableOverlayLowerdir2\n    ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Jitsi Videobridge API Option Renamed and Exposed for Monitoring - NixOS Service Option - Markdown\nDESCRIPTION: This code explains the renaming of services.jitsi-videobridge.apis to colibriRestApi and the change to a boolean, enabling or disabling the private REST API endpoint for monitoring (e.g., via Prometheus). Enabling the endpoint is required for integration with services.prometheus.exporters.jitsi.enable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_29\n\nLANGUAGE: markdown\nCODE:\n```\n- The option \\`services.jitsi-videobridge.apis\\` has been renamed to \\`colibriRestApi\\` and turned into a boolean. Setting it to \\`true\\` will enable the private rest API, useful for monitoring using \\`services.prometheus.exporters.jitsi.enable\\`. Learn more about the API: \\\"[The COLIBRI control interface (/colibri/)](https://github.com/jitsi/jitsi-videobridge/blob/v2.3/doc/rest.md)\\\".\n```\n\n----------------------------------------\n\nTITLE: Packaging Dhall Code from GitHub with dhall-to-nixpkgs\nDESCRIPTION: Demonstrates how to use dhall-to-nixpkgs to create a Nix package from a Dhall GitHub repository. The command generates a Nix expression with all necessary dependencies automatically detected, using nix-prefetch-git to generate the hash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p haskellPackages.dhall-nixpkgs nix-prefetch-git\n[nix-shell]$ dhall-to-nixpkgs github https://github.com/Gabriella439/dhall-semver.git\n{ buildDhallGitHubPackage, Prelude }:\n  buildDhallGitHubPackage {\n    name = \"dhall-semver\";\n    githubBase = \"github.com\";\n    owner = \"Gabriella439\";\n    repo = \"dhall-semver\";\n    rev = \"2d44ae605302ce5dc6c657a1216887fbb96392a4\";\n    fetchSubmodules = false;\n    hash = \"sha256-n0nQtswVapWi/x7or0O3MEYmAkt/a1uvlOtnje6GGnk=\";\n    directory = \"\";\n    file = \"package.dhall\";\n    source = false;\n    document = false;\n    dependencies = [ (Prelude.overridePackage { file = \"package.dhall\"; }) ];\n    }\n```\n\n----------------------------------------\n\nTITLE: Preparing a Checkpoint Build in Nix\nDESCRIPTION: Creates checkpoint artifacts for a derivation using prepareCheckpointBuild, which will be used as the base for subsequent incremental builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/checkpoint-build.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  checkpointArtifacts = (pkgs.checkpointBuildTools.prepareCheckpointBuild pkgs.virtualbox);\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Explicit Plugin Versions with maven-enforcer-plugin - Maven XML\nDESCRIPTION: Defines a Maven plugin configuration that uses maven-enforcer-plugin to enforce specifying explicit versions for all plugins in the build. Helps ensure Maven plugin versions do not drift with Maven upgrades and promotes reproducibility in builds. Should be placed in the project's POM, requires org.apache.maven.plugins:maven-enforcer-plugin.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-enforcer-plugin</artifactId>\n  <version>3.3.0</version>\n  <executions>\n    <execution>\n      <id>enforce-plugin-versions</id>\n      <goals>\n        <goal>enforce</goal>\n      </goals>\n      <configuration>\n        <rules>\n          <requirePluginVersions />\n        </rules>\n      </configuration>\n    </execution>\n  </executions>\n</plugin>\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Virtualization Parameters for Remote Builder - Nix\nDESCRIPTION: Nix attribute set for customizing VM parameters (disk size, memory, port, working directory) for the darwin-builder remote builder. This allows advanced users to rebuild the VM with altered resources. Requires correct context for nixpkgs and may disable use of binary cache if altered before initial run.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  darwin-builder = nixpkgs.lib.nixosSystem {\n    system = linuxSystem;\n    modules = [\n      \"${nixpkgs}/nixos/modules/profiles/nix-builder-vm.nix\"\n      {\n        virtualisation.host.pkgs = pkgs;\n        virtualisation.darwin-builder.diskSize = 5120;\n        virtualisation.darwin-builder.memorySize = 1024;\n        virtualisation.darwin-builder.hostPort = 33022;\n        virtualisation.darwin-builder.workingDirectory = \"/var/lib/darwin-builder\";\n      }\n    ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Pingvin Share Backend and Frontend Ports with NixOS Modules - Nix\nDESCRIPTION: This Nix snippet demonstrates enabling the Pingvin Share service in a NixOS configuration, setting custom port numbers for both the backend and frontend via 'backend.port' and 'frontend.port', and opening the firewall for these services. The configuration creates two systemd services ('pingvin-share-backend' and 'pingvin-share-frontend') which run in the specified data directory. Required: A NixOS system with the 'services-pingvin-share' option available. Expects the values to be used within a NixOS configuration file (typically /etc/nixos/configuration.nix).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pingvin-share.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services-pingvin-share = {\n    enable = true;\n\n    openFirewall = true;\n\n    backend.port = 9010;\n    frontend.port = 9011;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Docker Image with Excluded Store Paths\nDESCRIPTION: Demonstrates how to create a Docker image without including the store paths, showing the includeStorePaths option usage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.streamLayeredImage {\n  name = \"hello\";\n  contents = [ hello ];\n  includeStorePaths = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Local Branches from Remote Channel Branch in ShellSession\nDESCRIPTION: This snippet shows how to update the local Git repository from the remote and create a new local branch tracking a specific NixOS channel branch. It depends on having an up-to-date Git repo and the appropriate branch name (like 'origin/nixos-17.03'). Inputs include the remote channel branch name, and the output is a newly created local branch following that channel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ git remote update origin\n$ git checkout -b local origin/nixos-17.03\n```\n\n----------------------------------------\n\nTITLE: Setting Make Flags Array with Spaces\nDESCRIPTION: Example showing how to set make flags that contain spaces using makeFlagsArray in a preBuild hook, including CFLAGS and LDFLAGS settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\n{\n  preBuild = ''\n    makeFlagsArray+=(CFLAGS=\"-O0 -g\" LDFLAGS=\"-lfoo -lbar\")\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Check Phase with Hooks - Nix\nDESCRIPTION: This snippet illustrates how to override checkPhase in a Nix derivation, ensuring that preCheck and postCheck hooks are properly run. It is essential when custom test logic is used so that any hooks, such as those setting up or tearing down services like Memcached, are included. Expected inputs: the checkPhase attribute as a string. Outputs: test logic is executed with proper hook calls. No explicit dependencies beyond standard Nix derivation properties; user must ensure hooks exist if referenced.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/memcached-test-hook.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  checkPhase = ''\n    runHook preCheck\n\n    # ... your tests\n\n    runHook postCheck\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Structured Daemon Settings for fwupd - NixOS Service Option - Markdown\nDESCRIPTION: This snippet details the availability of arbitrary structured configuration for the fwupd daemon via services.fwupd.daemonSettings. This allows admins to specify options as key-value pairs or nested mappings, improving flexibility and configuration clarity. It relies on the fwupd NixOS module and the underlying fwupd service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`services.fwupd\\` module now allows arbitrary daemon settings to be configured in a structured manner ([\\`services.fwupd.daemonSettings\\`](#opt-services.fwupd.daemonSettings)).\n```\n\n----------------------------------------\n\nTITLE: Using fakeNss with dockerTools.buildImage in Nix\nDESCRIPTION: This example demonstrates how to use fakeNss as-is with dockerTools.buildImage to create a Docker image containing essential system files like /etc/passwd and /etc/group along with the hello binary.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/fakenss.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  fakeNss,\n  hello,\n}:\ndockerTools.buildImage {\n  name = \"image-with-passwd\";\n  tag = \"latest\";\n\n  copyToRoot = [\n    fakeNss\n    hello\n  ];\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Flat-File Binary Cache With nix-build (ShellSession)\nDESCRIPTION: This command builds the specified binary cache derivation directly from an expression using nix-build. It imports the Nixpkgs package set and invokes callPackage with mkBinaryCache and hello. The dependencies are nix, nixpkgs, mkBinaryCache, and hello. The expected input is a Nix expression as an argument to -E. The output is a path to the binary cache in the /nix/store. This must be run on a system with access to the referenced packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/binarycache.section.md#_snippet_1\n\nLANGUAGE: shellSession\nCODE:\n```\n$ nix-build -E 'let pkgs = import <nixpkgs> {}; in pkgs.callPackage ({ mkBinaryCache, hello }: mkBinaryCache { rootPaths = [hello]; }) {}'\n/nix/store/azf7xay5xxdnia4h9fyjiv59wsjdxl0g-binary-cache\n```\n\n----------------------------------------\n\nTITLE: Removal of Prometheus Pi-hole Exporter Interval Option - NixOS Service Change - Markdown\nDESCRIPTION: This brief note explains that services.prometheus.exporters.pihole.interval no longer exists and has been removed. This affects configurations relying on explicit interval settings for the Pi-hole exporter, likely requiring migration to default intervals or other approaches.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_23\n\nLANGUAGE: markdown\nCODE:\n```\n- The option \\`services.prometheus.exporters.pihole.interval\\` does not exist anymore and has been removed.\n```\n\n----------------------------------------\n\nTITLE: Configuring Neovim with Treesitter Plugins in Nix\nDESCRIPTION: This snippet shows how to configure Neovim with Treesitter plugins using the 'nvim-treesitter.withPlugins' function. It demonstrates how to precompile and include specific Treesitter grammars in the Neovim configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/neovim.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n(pkgs.neovim.override {\n  configure = {\n    packages.myPlugins = with pkgs.vimPlugins; {\n      start = [\n        (nvim-treesitter.withPlugins (\n          plugins: with plugins; [\n            nix\n            python\n          ]\n        ))\n      ];\n    };\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Kernel Derivation - Nix\nDESCRIPTION: This Nix snippet shows how to override various arguments of the kernel derivation using the override function (e.g., ignoreConfigErrors, autoModules, kernelPreferBuiltin, and extraStructuredConfig settings). It utilizes the lib.kernel helpers for additional options. It assumes that pkgs and lib are available in scope, typically from the Nixpkgs package set, and outputs a customized kernel derivation. The inputs are custom arguments to the override; the output is a kernel derivation with modified configuration and features.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/linux.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\npkgs.linux_latest.override {\n  ignoreConfigErrors = true;\n  autoModules = false;\n  kernelPreferBuiltin = true;\n  extraStructuredConfig = with lib.kernel; {\n    DEBUG_KERNEL = yes;\n    FRAME_POINTER = yes;\n    KGDB = yes;\n    KGDB_SERIAL_CONSOLE = yes;\n    DEBUG_INFO = yes;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Writing SVN Access Control Rules - Authz Example (Plaintext)\nDESCRIPTION: This plaintext snippet demonstrates the expected structure and syntax of a Subversion access control file (AuthzSVNAccessFile). It specifies read and write permissions for users and repositories. Requirements: Must be referenced in the Apache HTTPD Nix configuration with proper path. Inputs: Replace REPO_NAME and USER_NAME per environment requirements. Output: Enforces access control when used with mod_authz_svn.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n[/]\n* = r\n\n[REPO_NAME:/]\nUSER_NAME = rw\n```\n\n----------------------------------------\n\nTITLE: Linker Error Due to Stack Protector Hardening with GCC/Binutils (Linker Output)\nDESCRIPTION: This output excerpt illustrates a failure at the linker stage when the 'stackprotector' hardening flag is enabled and the binary is missing the '__stack_chk_fail' symbol. It requires a GCC toolchain with stack protector support, and the error depicts an undefined reference when linking C binaries. This typically indicates incompatibility with stack protector in certain targets or an incomplete runtime environment, necessitating either turning off stack protector or adding needed runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_43\n\nLANGUAGE: text\nCODE:\n```\nbin/blib.a(bios_console.o): In function `bios_handle_cup':\\n/tmp/nix-build-ipxe-20141124-5cbdc41.drv-0/ipxe-5cbdc41/src/arch/i386/firmware/pcbios/bios_console.c:86: undefined reference to `__stack_chk_fail'\n```\n\n----------------------------------------\n\nTITLE: External Package Inclusion with Alexandria\nDESCRIPTION: Example of including an external Alexandria package in the Nixpkgs scope using buildASDFSystem.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  alexandria = sbcl.buildASDFSystem rec {\n    pname = \"alexandria\";\n    version = \"1.4\";\n    src = fetchFromGitLab {\n      domain = \"gitlab.common-lisp.net\";\n      owner = \"alexandria\";\n      repo = \"alexandria\";\n      tag = \"v${version}\";\n      hash = \"sha256-1Hzxt65dZvgOFIljjjlSGgKYkj+YBLwJCACi5DZsKmQ=\";\n    };\n  };\n  sbcl' = sbcl.withOverrides (\n    self: super: {\n      inherit alexandria;\n    }\n  );\nin\nsbcl'.pkgs.alexandria\n```\n\n----------------------------------------\n\nTITLE: Packaging Ruby Application with Dependencies using bundlerApp in Nix\nDESCRIPTION: Advanced Nix expression for packaging a Ruby application (r10k) with runtime dependencies and path wrapping.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  bundlerApp,\n  makeWrapper,\n  git,\n  gnutar,\n  gzip,\n}:\n\nbundlerApp {\n  pname = \"r10k\";\n  gemdir = ./.;\n  exes = [ \"r10k\" ];\n\n  nativeBuildInputs = [ makeWrapper ];\n\n  postBuild = ''\n    wrapProgram $out/bin/r10k --prefix PATH : ${\n      lib.makeBinPath [\n        git\n        gnutar\n        gzip\n      ]\n    }\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Package Build and Execution (Shell, ShellSession)\nDESCRIPTION: Demonstrates building a Nix expression (e.g., my-hello.nix), and executing the built binary. Outputs a shell command sequence: build result and program output ('Hello, world!'). Prerequisite: Existing Nix derivation and Nix tooling.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/adding-custom-packages.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build my-hello.nix\\n$ ./result/bin/hello\\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Building JetBrains PyCharm Community Edition from Source with Maven Artefacts - Build Command - shell\nDESCRIPTION: Provides a workflow for building PyCharm Community Edition from source using Nix and then generating Maven artefacts with a Python script. 'nix build .#jetbrains.pycharm-community-src.src.src' creates the sources, followed by './source/build_maven.py source/pycharm_maven_artefacts.json result/' for artefact assembly. Relies on Nix and Python environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jetbrains/readme.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnix build .#jetbrains.pycharm-community-src.src.src && ./source/build_maven.py source/pycharm_maven_artefacts.json result/\n```\n\n----------------------------------------\n\nTITLE: Configuring Resholve Directives in Nix\nDESCRIPTION: Examples of using fake, fix, and keep directives with resholve in Nix. These directives control how resholve handles ambiguous situations, such as functions, builtins, variables used as commands, and absolute paths.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/misc/resholve/README.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # --fake 'f:setUp;tearDown builtin:setopt source:/etc/bashrc'\n  fake = {\n    # fake accepts the initial of valid identifier types as a CLI convenience.\n    # Use full names in the Nix API.\n    function = [ \"setUp\" \"tearDown\" ];\n    builtin = [ \"setopt\" ];\n    source = [ \"/etc/bashrc\" ];\n  };\n\n  # --fix 'aliases $GIT:gix /bin/bash'\n  fix = {\n    # all single-word directives use `true` as value\n    aliases = true;\n    \"$GIT\" = [ \"gix\" ];\n    \"/bin/bash\" = true;\n  };\n\n  # --keep 'source:$HOME /etc/bashrc ~/.bashrc'\n  keep = {\n    source = [ \"$HOME\" ];\n    \"/etc/bashrc\" = true;\n    \"~/.bashrc\" = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Layered Docker Image Configuration\nDESCRIPTION: Defines a basic layered Docker image configuration with the hello package as its contents.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.streamLayeredImage {\n  name = \"hello\";\n  contents = [ hello ];\n}\n```\n\n----------------------------------------\n\nTITLE: Error Message for Unfree Package Evaluation (Shell Session - shell)\nDESCRIPTION: Illustrates the error message encountered when attempting to evaluate an unfree package without enabling unfree support. No dependencies required; this is printed by Nix or NixOS tools. Input: Attempted installation or evaluation of an unfree package. Output: Error with package name, file, and reason.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n    error: package ‘nvidia-x11-331.49-3.12.17’ in ‘…/nvidia-x11/default.nix:56’\n      has an unfree license, refusing to evaluate\n```\n\n----------------------------------------\n\nTITLE: Specifying a Channel for Automatic Upgrades\nDESCRIPTION: This Nix configuration demonstrates how to specify a particular channel for automatic upgrades.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.autoUpgrade.channel = \"https://channels.nixos.org/nixos-24.11\";\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Zigbee2MQTT Settings in NixOS\nDESCRIPTION: Shows the renamed configuration option for Zigbee2MQTT settings in NixOS, following RFC 0042.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\nservices.zigbee2mqtt.settings = {\n  # Your Zigbee2MQTT configuration here\n};\n```\n\n----------------------------------------\n\nTITLE: Fetching Git Source with HTTPS (Better Practice)\nDESCRIPTION: An improved approach to fetching source code using HTTPS protocol, which is better than git:// but still not optimal compared to fetching an archive.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  src = fetchgit {\n    url = \"https://github.com/NixOS/nix.git\";\n    rev = \"1f795f9f44607cc5bec70d1300150bfefcef2aae\";\n    hash = \"sha256-7D4m+saJjbSFP5hOwpQq2FGR2rr+psQMTcyb1ZvtXsQ=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Common Lisp Implementation with wrapLisp in Nix\nDESCRIPTION: This example demonstrates how to use the wrapLisp function in a Nix expression to wrap a Common Lisp implementation, specifically CLISP. It customizes the wrapped derivation by specifying the CLISP package, the FASL file extension (\\\"fas\\\"), and flags that set the encoding to UTF-8. The wrapLisp function expects at minimum the pkg and faslExt parameters and can accept additional attributes such as flags and program name. wrapLisp is used for integrating Lisp implementations into Nix environments, allowing further customization and package extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nwrapLisp {\n  pkg = clisp;\n  faslExt = \"fas\";\n  flags = [\n    \"-E\"\n    \"UTF8\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling NVIDIA Container Toolkit in NixOS configuration\nDESCRIPTION: This snippet shows how to enable the NVIDIA Container Toolkit in the NixOS configuration file. It sets up the necessary components for CUDA support in containers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.nvidia-container-toolkit.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Package Outputs in TeX Live combine - Nix - nix\nDESCRIPTION: Defines a pkgFilter for texlive.combine to control which outputs are included (e.g., binaries, runtime files, documentation for specific packages). This filter function allows for fine-tuning of installed outputs based on tlType or package name. Inputs: packages with tlType attributes; Outputs: filtered package components. Constraints: Only attributes provided by TeX Live package derivations can be filtered.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\ntexlive.combine {\n  # inherit (texlive) whatever-you-want;\n  pkgFilter =\n    pkg: pkg.tlType == \"run\" || pkg.tlType == \"bin\" || pkg.hasManpages || pkg.pname == \"cm-super\";\n  # elem tlType [ \"run\" \"bin\" \"doc\" \"source\" ]\n  # there are also other attributes: version, name\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting an AppImage with postExtract in Nix\nDESCRIPTION: This example shows how to use the postExtract attribute when extracting an AppImage to modify files during the extraction process. It modifies the desktop file in-place before installing it in the final package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/appimagetools.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ appimageTools, fetchurl }:\nlet\n  pname = \"irccloud\";\n  version = \"0.16.0\";\n\n  src = fetchurl {\n    url = \"https://github.com/irccloud/irccloud-desktop/releases/download/v${version}/IRCCloud-${version}-linux-x86_64.AppImage\";\n    hash = \"sha256-/hMPvYdnVB1XjKgU2v47HnVvW4+uC3rhRjbucqin4iI=\";\n  };\n\n  appimageContents = appimageTools.extract {\n    inherit pname version src;\n    postExtract = ''\n      substituteInPlace $out/irccloud.desktop --replace-fail 'Exec=AppRun' 'Exec=${pname}'\n    '';\n  };\nin\nappimageTools.wrapType2 {\n  inherit pname version src;\n\n  extraPkgs = pkgs: [ pkgs.at-spi2-core ];\n\n  extraInstallCommands = ''\n    mv $out/bin/${pname}-${version} $out/bin/${pname}\n    install -m 444 -D ${appimageContents}/irccloud.desktop $out/share/applications/irccloud.desktop\n    install -m 444 -D ${appimageContents}/usr/share/icons/hicolor/512x512/apps/irccloud.png \\\n      $out/share/icons/hicolor/512x512/apps/irccloud.png\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Pinning Cargo Dependencies by Name using cargoDepsName - buildRustPackage - Nix\nDESCRIPTION: This code uses the `cargoDepsName` parameter to specify a stable directory name for vendored dependencies, ensuring that the generated `cargoHash` remains invariant over version changes. Used alongside other typical packaging attributes, this can reduce maintenance when updating versions. The snippet assumes `finalAttrs`, `rustPlatform`, and `fetchCrate` are present in the scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage (finalAttrs: {\n  pname = \"broot\";\n  version = \"1.2.0\";\n\n  src = fetchCrate {\n    inherit (finalAttrs) pname version;\n    hash = \"sha256-aDQA4A5mScX9or3Lyiv/5GyAehidnpKKE0grhbP1Ctc=\";\n  };\n\n  useFetchCargoVendor = true;\n  cargoHash = \"sha256-iDYh52rj1M5Uupvbx2WeDd/jvQZ+2A50V5rp5e2t7q4=\";\n  cargoDepsName = finalAttrs.pname;\n\n  # ...\n})\n```\n\n----------------------------------------\n\nTITLE: Running nixos-rebuild-ng and Developer Tools - Console\nDESCRIPTION: These shell commands provide examples of typical development workflows for Python-based projects. Commands shown include running the nixos_rebuild module, executing unit tests with pytest, checking types with mypy, fixing lint with ruff, and formatting code. Each tool should be available in the devShell. No special parameters are needed; simply run them as shown in the src directory. Outputs vary by command: program output, test results, or code formatting/lint fixes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-rebuild-ng/README.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n# run program\npython -m nixos_rebuild\n# run tests\npytest\n# check types\nmypy .\n# fix lint issues\nruff check --fix .\n# format code\nruff format .\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up nixbld User and Group (Shell)\nDESCRIPTION: Removes the previously created nixbld user and group using userdel and groupdel after the installation process. Should be run on the original (non-NixOS) distribution if cleanup is desired. Prerequisite: Administrative privileges. No input required. Output: nixbld user/group removed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo userdel nixbld\\n$ sudo groupdel nixbld\n```\n\n----------------------------------------\n\nTITLE: Configuring mitmCache using finalAttrs.finalPackage in Gradle/Nix - Nix Expressions\nDESCRIPTION: This snippet illustrates the use of finalAttrs.finalPackage as the pkg argument to gradle.fetchDeps in mkDerivation. This pattern supports dynamic package selection even for complex derivations; however, it does not allow fine-grained overriding of package attributes as in the previous method. Key prerequisites are a valid Nix derivation context and the presence of deps.json as dependency lockfile.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gradle.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation (finalAttrs: {\n  # ...\n  mitmCache = gradle.fetchDeps {\n    pkg = finalAttrs.finalPackage;\n    data = ./deps.json;\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Parallel Machine Start Command\nDESCRIPTION: Python command to start multiple test machines in parallel\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nstart_all()\n```\n\n----------------------------------------\n\nTITLE: Overriding Coq Derivation in NixOS\nDESCRIPTION: Demonstrates how to override the Coq derivation using the 'coq.override' function. It shows examples of overriding the version, OCaml packages, and Coq version for non-release builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ncoq.override { version = \"d370a9d1328a4e1cdb9d02ee032f605a9d94ec7a\"; coq-version = \"8.10\"; }\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Swift Programs Using the Swift Compiler in Shell\nDESCRIPTION: This snippet demonstrates how to use the Nix shell to invoke the Swift compiler (`swiftc`) directly from the shell and run a minimal Swift executable. It depends on the `swift` package provided by Nixpkgs and assumes access to both Nix and the Swift toolchain. The initial command compiles and links the source code piped in, while the second runs the resulting binary. The code prints \"Hello world!\" to stdout. Paths and tool invocations may differ based on shell environment and system settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Compile and link a simple executable.\nnix-shell -p swift --run 'swiftc -' <<< 'print(\"Hello world!\")'\n# Run it!\n./main\n```\n\n----------------------------------------\n\nTITLE: Temporarily Allowing Unfree Packages - Environment Variable - shell\nDESCRIPTION: Allows all unfree packages to be installed or built in a single nix tool invocation by setting the environment variable `NIXPKGS_ALLOW_UNFREE` for that process. No persistent system effect; the variable must be set each time.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ export NIXPKGS_ALLOW_UNFREE=1\n```\n\n----------------------------------------\n\nTITLE: Generating Custom Vim Plugin Packages from a List File\nDESCRIPTION: Example showing how to use the vim-plugins-updater to generate plugin packages from a custom vim-plugin-names file. This is useful for maintaining out-of-tree overlays.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  myVimPlugins = pkgs.vimPlugins.extend ((pkgs.callPackage ./generated.nix { }));\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Lua Package Using an Overlay - Overlay Template - nix\nDESCRIPTION: This Nix overlay template provides a mechanism to override an existing Lua package (e.g., luarocks-nix) by adjusting its source, name, or attributes using the override pattern. It defines customized packageOverrides for the Lua interpreter and updates the luaPackages alias, making the new version available to the package set. Dependencies are prev, final package sets, and user-provided sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nfinal: prev: {\n\n  lua = prev.lua.override {\n    packageOverrides = luaself: luaprev: {\n\n      luarocks-nix = luaprev.luarocks-nix.overrideAttrs (oa: {\n        pname = \"luarocks-nix\";\n        src = /home/my_luarocks/repository;\n      });\n    };\n  };\n\n  luaPackages = lua.pkgs;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Comparing Patched Qt Branch Against Release Tag - Git\nDESCRIPTION: This git command snippet generates a unified diff patch between the active Nixpkgs-patched branch (e.g., nixpkgs/5.9) and a specific Qt release tag (e.g., v5.9.1), capturing all changes as a single patch file. Dependencies include a local clone of the relevant Qt fork and a checked-out branch. Key parameters: release tag and output filename. The output is a patch file suitable for inclusion in Nixpkgs. Limitations: Only useful for repositories following the defined branch and tag naming conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/qt-5/README.md#_snippet_1\n\nLANGUAGE: git\nCODE:\n```\ngit diff v$version > $module.patch\n```\n\n----------------------------------------\n\nTITLE: Including External Files and Defining Complex Type Collections - Nix Language\nDESCRIPTION: Demonstrates using @include preprocessor directive to include external files and defining attributes of various numeric literals within an attribute set. Shows handling of arrays of ints (with octal and hex), large integers, floats, and scientific notation, common test cases for parsers or type validation. No dependencies other than the referenced external file. Keys are of various literal types with static assignments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nweirderTypes={\\n@include \"@include_file@\"\\narray_of_ints=[0732, 0xa3, 1234];bigint=9223372036854775807;float=0.0012;hex=0x1fc3;list_of_weird_types=(3.141592654, 9223372036854775807, 0x1fc3, 027, 1.2e-32, 1.0);octal=027;pi=3.141592654;};\n```\n\n----------------------------------------\n\nTITLE: Enabling Manual X Starting via startx - Nix\nDESCRIPTION: This snippet enables manual starting of the X server via the startx command by setting services.xserver.displayManager.startx.enable and generateScript to true. Generates a basic xinitrc script to start the session upon running startx. Useful when no display manager is needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.startx = {\n    enable = true;\n    generateScript = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Root User and Group for uWSGI Instances in NixOS with Nix - nix\nDESCRIPTION: This configuration restores previous behavior where the uWSGI emperor and instances ran as root instead of the new default unprivileged user. The snippet sets 'services.uwsgi.user', 'group', and instance-specific 'uid', 'gid'. Meant for 'configuration.nix' in NixOS environments using the uWSGI service. All parameters are strings specifying UNIX users/groups; use only if root operation is desired.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.uwsgi.user = \"root\";\n  services.uwsgi.group = \"root\";\n  services.uwsgi.instance =\n    {\n      uid = \"uwsgi\";\n      gid = \"uwsgi\";\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Processing CUDA Manifests with cuda-redist-find-features - Bash\nDESCRIPTION: This Bash snippet illustrates processing pre-fetched CUDA redistributable manifests using the 'process-manifests' command of the 'cuda-redist-find-features' tool via 'nix run'. The operation logs at DEBUG level and outputs a features JSON file in the specified directory. Inputs include the CUDA version and paths to source and destination directories. Prerequisites are the downloaded manifests and access to the 'cuda-redist-find-features' application.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnix run github:connorbaker/cuda-redist-find-features -- \\\n   process-manifests \\\n   --log-level DEBUG \\\n   --version <newest CUDA version> \\\n   https://developer.download.nvidia.com/compute/cuda/redist \\\n   ./pkgs/development/cuda-modules/cuda/manifests\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Filesystem Options in New List Format\nDESCRIPTION: Example showing the new format for specifying filesystem mount options as a list of strings rather than comma-separated string.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n    fileSystems.\"/example\" = {\n      device = \"/dev/sdc\";\n      fsType = \"btrfs\";\n      options = [ \"noatime\" \"compress=lzo\" \"space_cache\" \"autodefrag\" ];\n    };\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a Katamari Tarball List for X.org using Shell and Perl - ShellSession\nDESCRIPTION: This snippet sets environment variables for an X.org release, fetches the source directory URL using nix-prefetch-url, and pipes the result into a Perl script that searches for .bz2 files within directory listings, reconstructing full tarball URLs and sorting them into a list file for the release. Dependencies include a functional Nix and Perl installation. 'release' and 'url' variables define the X.org release to process. The script expects access to the relevant mirror and that PRINT_PATH=1 produces a directory listing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/xorg.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\nexport release=\"X11R7.7\"\nexport url=\"mirror://xorg/$release/src/everything/\"\ncat $(PRINT_PATH=1 nix-prefetch-url $url | tail -n 1) \\\n  | perl -e 'while (<>) { if (/(href|HREF)=\"([^\"]*.bz2)\"/) { print \"$ENV{'url'}$2\\n\"; }; }' \\\n  | sort > \"tarballs-$release.list\"\n```\n\n----------------------------------------\n\nTITLE: Formatting Swap Partition with mkswap and Label (ShellSession)\nDESCRIPTION: Initializes a swap area on /dev/sda2 and assigns it the label 'swap'. This enables the swap partition to be referenced symbolically. The '-L' option assigns a label, improving device name resilience; 'mkswap' prepares the partition for use as swap.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_12\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mkswap -L swap /dev/sda2\n```\n\n----------------------------------------\n\nTITLE: Generating NixOS Configuration In Place (Shell)\nDESCRIPTION: Runs nixos-generate-config without the --root option to produce system configuration files under /etc/nixos for in-place migration (lustrate) mode. Recommended for users wishing to convert their running system to NixOS. Prerequisites: Root privileges, NixOS tools installed. Output: NixOS config files written to /etc/nixos.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo `which nixos-generate-config`\n```\n\n----------------------------------------\n\nTITLE: Packaging a Font Using a TeX Live Derivation Output - Nix - nix\nDESCRIPTION: Shows how to repackage a font by referencing the texlive.pkg derivation for iwona, using attributes for outputs and specifying a custom installPhase. This approach copies OpenType font files from a TeX package to a standard location in the output tree. Prerequisites: stdenvNoCC, texlive.pkgs.iwona, basic familiarity with custom Nix derivations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nstdenvNoCC.mkDerivation (finalAttrs: {\n  src = texlive.pkgs.iwona;\n  dontUnpack = true;\n\n  inherit (finalAttrs.src) pname version;\n\n  installPhase = ''\n    runHook preInstall\n    install -Dm644 $src/fonts/opentype/nowacki/iwona/*.otf -t $out/share/fonts/opentype\n    runHook postInstall\n  '';\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Error Position Example\nDESCRIPTION: Demonstration of how to use custom position information in definitions for better error messages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  _file = \"file.nix\";\n  options.foo = mkOption {\n    default = 13;\n  };\n  config.foo = lib.mkDefinition {\n    file = \"custom place\";\n    # mkOptionDefault creates a conflict with the option foo's `default = 1` on purpose\n    # So we see the error message below contains the conflicting values and different positions\n    value = lib.mkOptionDefault 42;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Applying patchRcPath Utility in POSIX Shell Scripts - Shell (sh)\nDESCRIPTION: Demonstrates the generic syntax for invoking patchRcPath utilities to prefix the PATH within a shell initialization script. This utility takes the target shell, the script file to patch, and the desired PATH prefix, enabling nested patching for robust script sourcing. There are no direct dependencies except for 'sed' in Csh and POSIX variants.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/patch-rc-path-hooks.section.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npatchRcPath<shell> <file> <PATH-prefix>\n```\n\n----------------------------------------\n\nTITLE: Replacing Source in Haskell Derivations\nDESCRIPTION: A helper function to replace the source of a Haskell package derivation. It takes a set with 'src' and optional 'version' attributes, and the derivation to modify.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\noverrideSrc { src, version } drv\n```\n\n----------------------------------------\n\nTITLE: Converting asusd configuration for version 6\nDESCRIPTION: Example of how to migrate from the old single auraConfig to the new auraConfigs format with text attribute in asusd version 6. This demonstrates the required changes when upgrading to support multiple aura devices.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n-services.asusd.asusdConfig = '''file contents'''\n+services.asusd.asusdConfig.text = '''file contents'''\n```\n\n----------------------------------------\n\nTITLE: Installing a Lua Environment via nix-env - Shell Command - shell\nDESCRIPTION: This shell snippet shows how to install a Nix expression-defined Lua environment (from the previous Nix code, e.g., build.nix) into the user's profile using nix-env. Requires a previously defined Nix environment file. The input is the path to the .nix file. The output is a user environment with the specified Lua interpreter and packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnix-env -if build.nix\n\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Deprecated System Roots in NixOS - ShellSession\nDESCRIPTION: This shell command permanently deletes the /old-root directory, which contains the previous system's root after a successful switch to NixOS. It should only be executed after verifying that NixOS is operating correctly and the user no longer requires recovery of the old system. Requires sudo privileges; improper use may result in data loss.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_17\n\nLANGUAGE: ShellSession\nCODE:\n```\nsudo rm -rf /old-root\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS-over-HTTPS Server with Nginx and ACME - Nix\nDESCRIPTION: This Nix expression demonstrates how to enable and configure the doh-server DNS-over-HTTPS service alongside Nginx, using ACME for automated certificate management. It sets up doh-server with a specific upstream DNS resolver and configures an Nginx virtual host to proxy /dns-query requests to doh-server while enforcing SSL and HTTP/2. The configuration requires the doh-server, nginx, and ACME modules, as well as the specification of firewall ports 80 and 443. Key parameters include the upstream DNS server, ACME settings, and Nginx proxy paths. Expected output is a running DNS-over-HTTPS server accessible via HTTPS. Limitations include reliance on ACME and the recommendation against using doh-server as a standalone HTTPS server due to lack of OCSP Stabling.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/doh-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.doh-server = {\n    enable = true;\n    settings = {\n      upstream = [ \"udp:1.1.1.1:53\" ];\n    };\n  };\n\n  services.nginx = {\n    enable = true;\n    virtualHosts.\"doh.example.com\" = {\n      enableACME = true;\n      forceSSL = true;\n      http2 = true;\n      locations.\"/\".return = 404;\n      locations.\"/dns-query\" = {\n        proxyPass = \"http://127.0.0.1:8053/dns-query\";\n        recommendedProxySettings = true;\n      };\n    };\n    # and other virtual hosts ...\n  };\n\n  security.acme = {\n    acceptTerms = true;\n    defaults.email = \"you@example.com\";\n  };\n\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building NixOS Configuration Components - ShellSession\nDESCRIPTION: This snippet shows typical commands for building specific options from a NixOS configuration using nix-build. It demonstrates changing to the correct directory and specifying which attribute to build using the -A flag. The inputs include the attribute name (e.g., config.option) and outputs the built derivation in the result symlink. Requires a properly configured nixpkgs checkout and a valid NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/building-parts.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ cd /path/to/nixpkgs/nixos\\n$ nix-build -A config.option\n```\n\n----------------------------------------\n\nTITLE: Packaging Dhall Code from Local Directory\nDESCRIPTION: Shows how to use dhall-to-nixpkgs to create a Nix package from a local Dhall directory. The command generates a Nix expression with dependencies detected and included automatically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ dhall-to-nixpkgs directory ~/proj/dhall-semver\n{ buildDhallDirectoryPackage, Prelude }:\n  buildDhallDirectoryPackage {\n    name = \"proj\";\n    src = ~/proj/dhall-semver;\n    file = \"package.dhall\";\n    source = false;\n    document = false;\n    dependencies = [ (Prelude.overridePackage { file = \"package.dhall\"; }) ];\n    }\n```\n\n----------------------------------------\n\nTITLE: Migrating Kubernetes featureGates from List to Attribute Set (Nix)\nDESCRIPTION: These code snippets illustrate the transition in configuring Kubernetes feature gates: the old format uses a list of strings and extra options with concatenated strings, while the new format requires using an attribute set (dictionary) with gate names mapped to booleans or direct values. No external dependencies are needed, and the code is intended for use inside a NixOS module configuration. Key parameters: \\'featureGates\\' as a list or attribute set, \\'extraOpts\\' as additional CLI flags. Inputs are the attribute set or list structure; output is a functioning configuration. Users should replace the old format with the new one for future compatibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  featureGates = [ \"EphemeralContainers\" ];\n  extraOpts = pkgs.lib.concatStringsSep \" \" (\n    [\n      ''--feature-gates=\"CSIMigration=false\"''\n    ]\n  );\n}\n```\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  featureGates = {\n    EphemeralContainers = true;\n    CSIMigration=false;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Patch File with Git Diff - Shell\nDESCRIPTION: This snippet shows how to generate a patch file for SageMath after making source code changes. The process involves making modifications in the source repository and using the 'git diff -u' command to create a unified diff, redirected to a file path inside the Nixpkgs Sage patches directory. The snippet expects git to be installed and assumes write permissions to the target file. Key parameters: modified files and patch file path. Output: a patch file suitable for inclusion in Sage's nix derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sa/sage/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n[user@localhost ~]$ <make changes>\\n[user@localhost ~]$ git diff -u > /path/to/nixpkgs/pkgs/applications/science/math/sage/patches/name-of-patch.patch\n```\n\n----------------------------------------\n\nTITLE: Adding Digital Bitbox Applications to System Packages - NixOS - Nix\nDESCRIPTION: This snippet shows how to add the Digital Bitbox applications (dbb-app and dbb-cli) to the system PATH using the \"environment.systemPackages\" list in a NixOS configuration. The \"pkgs.digitalbitbox\" package must exist in the channel. The key parameter is the inclusion of the package in the list, which ensures both GUI and CLI tools are available to all users.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/programs/digitalbitbox/default.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    pkgs.digitalbitbox\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building iLBC Library with CMake\nDESCRIPTION: CMake configuration file that sets up the build process for the iLBC shared library. Collects all .c and .h files, creates a shared library target, and specifies installation paths for the library and header files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/il/ilbc/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.6)\n\nproject(ilbc)\n\nfile(GLOB ilbc_SRCS *.c)\nfile(GLOB ilbc_HDRS *.h)\n\nadd_library(ilbc SHARED ${ilbc_SRCS})\n\ninstall(TARGETS ilbc DESTINATION lib)\ninstall(FILES ${ilbc_HDRS} DESTINATION include/ilbc)\n```\n\n----------------------------------------\n\nTITLE: Creating a Nix Package for a Dhall Expression\nDESCRIPTION: This Nix code defines a package for the Dhall expression using buildDhallPackage. It specifies the name, code location, dependencies, and source inclusion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n# ./true.nix\n\n{ buildDhallPackage, Prelude }:\n\nbuildDhallPackage {\n  name = \"true\";\n  code = ./true.dhall;\n  dependencies = [ Prelude ];\n  source = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Haddock Documentation Generation for Haskell Packages\nDESCRIPTION: Functions to enable or disable Haddock documentation generation for Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\ndoHaddock drv\ndontHaddock drv\n```\n\n----------------------------------------\n\nTITLE: Overriding Typst Packages with Updated Hashes - Nix\nDESCRIPTION: This snippet shows how to manually override source hashes for Typst packages in Nix when upstream hashes become outdated. It uses the .override and .extend mechanisms to customize the 'polylux_0_4_0' package's source hash. Dependencies are Nix, Typst-related packages from nixpkgs, and familiarity with Nix's overrideAttrs pattern. Inputs include the new output hash value and a list of desired packages. The override ensures reproducibility when upstream package hashes change, but requires users to supply the correct up-to-date hash.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/typst.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\ntypst.withPackages.override\n  (old: {\n    typstPackages = old.typstPackages.extend (\n      _: previous: {\n        polylux_0_4_0 = previous.polylux_0_4_0.overrideAttrs (oldPolylux: {\n          src = oldPolylux.src.overrideAttrs {\n            outputHash = YourUpToDatePolyluxHash;\n          };\n        });\n      }\n    );\n  })\n  (\n    p: with p; [\n      polylux_0_4_0\n      cetz_0_3_0\n    ]\n  )\n```\n\n----------------------------------------\n\nTITLE: Testing Content Equality Between Paths - Nix - nix\nDESCRIPTION: This Nix snippet uses testers.testEqualContents to verify that the contents of two paths are the same. It sets up an 'expected' file, generates an 'actual' file by using sed to modify a base file, and asserts both files are identical. Suitable for regression and correctness testing with custom build or file generation logic.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\ntesters.testEqualContents {\n  assertion = \"sed -e performs replacement\";\n  expected = writeText \"expected\" ''\n    foo baz baz\n  '';\n  actual =\n    runCommand \"actual\"\n      {\n        # not really necessary for a package that's in stdenv\n        nativeBuildInputs = [ gnused ];\n        base = writeText \"base\" ''\n          foo bar baz\n        '';\n      }\n      ''\n        sed -e 's/bar/baz/g' $base >$out\n      '';\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Lua Environment Attribute with nix-env - Shell Command - shell\nDESCRIPTION: This shell snippet illustrates installation of a specific Lua environment attribute (myLuaEnv) from the nixpkgs channel into the user's profile using nix-env. Requires the attribute to be previously defined using packageOverrides in config.nix. Effective for quickly switching or adding environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnix-env -iA nixpkgs.myLuaEnv\n\n```\n\n----------------------------------------\n\nTITLE: Adding Binary Plugins to Krita in NixOS\nDESCRIPTION: This snippet demonstrates how to add custom binary plugins to Krita without replacing the default ones. It uses the override pattern to append new plugins to the existing list stored in pkgs.krita.binaryPlugins.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/krita.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n(pkgs.krita.override (old: {\n  binaryPlugins = old.binaryPlugins ++ [ your-plugin ];\n}))\n```\n\n----------------------------------------\n\nTITLE: Equivalent runCommandWith for runCommand - Nix\nDESCRIPTION: This code snippet illustrates the functional equivalence between `runCommand` and a direct call to `runCommandWith` with the appropriate attributes, using the `stdenvNoCC` environment. This form may be used for more explicit control over build parameters or when building custom wrappers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nrunCommandWith {\n  inherit name derivationArgs;\n  stdenv = stdenvNoCC;\n} buildCommand\n```\n\n----------------------------------------\n\nTITLE: Disabling GNOME Core Utilities - NixOS Module Configuration - Nix\nDESCRIPTION: This snippet disables the installation of standard GNOME core utilities (apps, games, developer tools) when enabling the GNOME desktop, making for a minimal GNOME setup. Dependency is access to the 'services.gnome.core-utilities' module; the key parameter is 'enable', set to false. After applying, none of the core GNOME apps will be installed; the GNOME desktop interface remains.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gnome.core-utilities.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Static Haskell Executables\nDESCRIPTION: A function to build only the executables of a Haskell package, statically linked against Haskell dependencies. It reduces closure size but may not work with all packages due to GHC's dead code elimination.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\njustStaticExecutables drv\n```\n\n----------------------------------------\n\nTITLE: Deleting Old Garbage Collection Roots (Shell - ShellSession)\nDESCRIPTION: This command triggers the Nix garbage collector with the -d flag, which also removes old garbage collection roots. This deletes saved rollback system configurations, permanently freeing additional disk space but removing the ability to rollback to those states. Should be used with caution, especially on production systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ nix-collect-garbage -d\\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Nix Overlay for Custom Idris Installation with Libraries\nDESCRIPTION: Nix overlay definition that creates a custom Idris installation with additional libraries (contrib and pruviloj).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nself: super: {\n  myIdris =\n    with self.idrisPackages;\n    with-packages [\n      contrib\n      pruviloj\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Image Variant Bootloader Options - Nix\nDESCRIPTION: Configures image.modules in a Nix expression to disable the systemd-boot bootloader specifically for the 'linode' image variant using lib.mkForce. This requires Nix/NixOS configuration context and depends on having access to the image.modules attribute and the lib library. The option ensures that boot.loader.systemd-boot.enable is set to false only for the Linode variant, preserving defaults elsewhere. Useful for selectively customizing images for different providers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-images-via-nixos-rebuild-build-image.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n  image.modules.linode = {\\n    boot.loader.systemd-boot.enable = lib.mkForce false;\\n  };\n```\n\n----------------------------------------\n\nTITLE: Declaring Freeform Submodules with Type-Checked Options in NixOS (Nix)\nDESCRIPTION: This snippet defines a NixOS module with an option named 'settings', which uses a submodule supporting arbitrary string-valued attributes through the 'freeformType' mechanism. It also declares a specifically type-checked 'port' option within 'settings', assigning it an integer type and a default value of 8080. Dependencies include the Nix 'lib' and 'types' modules, and this approach allows the user to mix arbitrary string settings with explicitly validated attributes. Input is a set of module arguments; the output is a module configuration attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/freeform-modules.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ lib, config, ... }: {\n\n  options.settings = lib.mkOption {\n    type = lib.types.submodule {\n\n      freeformType = with lib.types; attrsOf str;\n\n      # We want this attribute to be checked for the correct type\n      options.port = lib.mkOption {\n        type = lib.types.port;\n        # Declaring the option also allows defining a default value\n        default = 8080;\n      };\n\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Free-floating Definition\nDESCRIPTION: Example of an incorrect way to create a free-floating definition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nmkForce (mkDefinition {\n   value = 42;\n   file = \"somefile.nix\";\n})\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Sections in Markdown with {=include=}\nDESCRIPTION: This snippet demonstrates how to modularly include two separate markdown files, 'declarative-packages.section.md' and 'ad-hoc-packages.section.md', into the current documentation using the {=include=} directive. No external runtime dependencies are required, but successful resolution depends on the documentation build system understanding the {=include=} syntax (e.g., Pandoc filters or a custom preprocessor). Inputs are the file paths to include; output is the injected content from those files at this location. This approach promotes maintainability and organized documentation structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/package-mgmt.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\ndeclarative-packages.section.md\nad-hoc-packages.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Idris Using Nix-env Command\nDESCRIPTION: Basic command to install the Idris compiler with minimal libraries (prelude and base) using nix-env.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f \"<nixpkgs>\" -iA idris\n```\n\n----------------------------------------\n\nTITLE: Filtering a Path With fileFilter and Intersection in Nix (Nix)\nDESCRIPTION: This snippet pair demonstrates two methods of filtering in the fileset abstraction. The first presents direct filter expression via fileFilter, combined with a predicate and a path, while the second suggests using intersection for combining filtered results. These examples serve as conceptual demonstrations to highlight compositional patterns in Nix fileset operations and the explicit need for path arguments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_5\n\nLANGUAGE: Nix\nCODE:\n```\n\"fileFilter predicate ./.\"\n```\n\nLANGUAGE: Nix\nCODE:\n```\n\"intersection fileset (fileFilter predicate ./.)\"\n```\n\n----------------------------------------\n\nTITLE: LibXML2 Catalog Path Configuration\nDESCRIPTION: Documents how catalog.xml files from xml/dtd and xml/xsl subdirectories of build inputs are added to XML_CATALOG_FILES environment variable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/libxml2.section.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# libxml2 {#setup-hook-libxml2}\n\nAdds every file named `catalog.xml` found under the `xml/dtd` and `xml/xsl` subdirectories of each build input to the `XML_CATALOG_FILES` environment variable.\n```\n\n----------------------------------------\n\nTITLE: Formatting Commit Messages for NixOS - Markdown\nDESCRIPTION: This snippet illustrates the required structure for NixOS-related commit messages, using a markdown code block to show the header and body format. Contributors should follow this template to maintain clarity and consistency in commit history. The header requires a scope and short description; the body should include motivation, links, or extra details as needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/README.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nnixos/(module): (init module | add setting | refactor | etc)\n\n(Motivation for change. Link to release notes. Additional information.)\n```\n\n----------------------------------------\n\nTITLE: Importing CUDA Redistributables Module in Nix\nDESCRIPTION: This code snippet shows how to import the CUDA redistributables module, which aliases the generic module for manifests. It illustrates the use of relative imports in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/modules/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n./cuda/default.nix\n```\n\n----------------------------------------\n\nTITLE: Managing User Channels and Building Packages via Nix Command Line (Shell)\nDESCRIPTION: This sequence of shell commands illustrates managing user channels, updating them, and building or running packages from a custom Nix channel ('nixpkgsunstable'). It shows how to add a channel using 'nix-channel --add', update all user channels with 'nix-channel --update', and then build or run an example package ('gitFull') directly from the named channel using various tools ('nix-build', 'nix run', 'nix-instantiate'). These commands require Nix to be installed and assume the user wants to leverage personal or contributed channel definitions. Inputs are channel URLs, attributes, and expressions referencing the new channel; outputs are built or executed binaries/artifacts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1809.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgsunstable\n$ nix-channel --update\n$ nix-build '<nixpkgsunstable>' -A gitFull\n$ nix run -f '<nixpkgsunstable>' gitFull\n$ nix-instantiate -E '(import <nixpkgsunstable> {}).gitFull'\n```\n\n----------------------------------------\n\nTITLE: Updating Hackage Package Set in Nixpkgs\nDESCRIPTION: This command updates the Hackage package set used by Nixpkgs and creates a commit. It's part of the initial haskell-updates PR process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/update-hackage.sh --do-commit\n```\n\n----------------------------------------\n\nTITLE: Automating Module Option Deprecation - mkRenamedOptionModuleWith - Nix\nDESCRIPTION: Describes the use of 'mkRenamedOptionModuleWith' by NixOS module authors to automate the deprecation cycle of configuration options, minimizing impact on users and third-party modules. The macro makes it easier to rename, deprecate, or migrate options in Nix modules. Key parameters include the original and new option names.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nmkRenamedOptionModuleWith\n```\n\n----------------------------------------\n\nTITLE: Echoing Output Using Python Print Statement - Python\nDESCRIPTION: This snippet prints the string 'hi' to the console. It assumes Python is installed and available to execute the code. The code demonstrates basic usage of standard output, accepts no input parameters, and simply displays text; it is intended as an introductory example of Python syntax for output operations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/python-modules/bash-kernel/test.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\necho hi\n```\n\n----------------------------------------\n\nTITLE: Referencing Agda Library from GitHub - Nix - nix\nDESCRIPTION: Demonstrates how to override an Agda library's source with a fetchFromGitHub expression, allowing retrieval of a specific version from a remote repository. The snippet uses the overrideAttrs pattern inside agda.withPackages and provides GitHub repo, owner, revision, and hash for reproducibility. Required dependencies include access to fetchFromGitHub and correctly specifying attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages (p: [\n  (p.standard-library.overrideAttrs (oldAttrs: {\n    version = \"1.5\";\n    src = fetchFromGitHub {\n      repo = \"agda-stdlib\";\n      owner = \"agda\";\n      rev = \"v1.5\";\n      hash = \"sha256-nEyxYGSWIDNJqBfGpRDLiOAnlHJKEKAOMnIaqfVZzJk=\";\n    };\n  }))\n])\n```\n\n----------------------------------------\n\nTITLE: Building an Idris2 Executable Package with Nix\nDESCRIPTION: Example of packaging the `idris2-lsp` executable that depends on both `LSP-lib` and the built-in `idris2Api`. This demonstrates how to reference other Idris2 libraries in the build process and how to access the executable derivation from the result.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris2.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  callPackage,\n  fetchFromGitHub,\n  idris2Packages,\n}:\n\n# Assuming the previous example lives in `lsp-lib.nix`:\nlet\n  lspLib = callPackage ./lsp-lib.nix { };\n  inherit (idris2Packages) idris2Api;\n  lspPkg = idris2Packages.buildIdris {\n    ipkgName = \"idris2-lsp\";\n    src = fetchFromGitHub {\n      owner = \"idris-community\";\n      repo = \"idris2-lsp\";\n      rev = \"main\";\n      hash = \"sha256-vQTzEltkx7uelDtXOHc6QRWZ4cSlhhm5ziOqWA+aujk=\";\n    };\n    idrisLibraries = [\n      idris2Api\n      lspLib\n    ];\n  };\nin\nlspPkg.executable\n```\n\n----------------------------------------\n\nTITLE: Enabling PostgreSQL in NixOS Configuration\nDESCRIPTION: NixOS configuration for enabling the PostgreSQL service required by Pleroma. This specifies PostgreSQL 13 as the package version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postgresql = {\n    enable = true;\n    package = pkgs.postgresql_13;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Complex Test Expressions with pytestCheckHook\nDESCRIPTION: Shows how to use logical expressions to select tests with pytestCheckHook by using structured attributes. This example disables tests that match both 'Foo' and 'bar' patterns.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_35\n\nLANGUAGE: nix\nCODE:\n```\n{\n  __structuredAttrs = true;\n\n  disabledTests = [\n    \"Foo and bar\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Local Patch Files with Git\nDESCRIPTION: A step-by-step procedure for creating patch files using Git. This involves initializing a Git repository, making changes, and generating a diff file that can be included in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ cd the/program/source\n$ git init\n$ git add .\n$ git diff -a > nixpkgs/pkgs/the/package/0001-changes.patch\n```\n\n----------------------------------------\n\nTITLE: Alexandria Package Override Example\nDESCRIPTION: Shows how to override Alexandria package attributes using overrideLispAttrs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lisp.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nsbcl.pkgs.alexandria.overrideLispAttrs (oldAttrs: rec {\n  version = \"1.4\";\n  src = fetchFromGitLab {\n    domain = \"gitlab.common-lisp.net\";\n    owner = \"alexandria\";\n    repo = \"alexandria\";\n    tag = \"v${version}\";\n    hash = \"sha256-1Hzxt65dZvgOFIljjjlSGgKYkj+YBLwJCACi5DZsKmQ=\";\n  };\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Dhall Package using Nix\nDESCRIPTION: This shell command builds the Dhall package defined in the Nix expression using the nix build command.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ nix build --file ./example.nix dhallPackages.true\n```\n\n----------------------------------------\n\nTITLE: Formatting Script Output for Commit Automation - JSON\nDESCRIPTION: Demonstrates the structure of a JSON list that update scripts must print to standard output for the automatic commit feature in update.nix. Each object corresponds to an attribute updated, containing old/new versions and changed files. Optional fields provide extra commit message details. Dependencies include update.nix and a Git environment ready for automation. Input must be a correctly formatted JSON list; otherwise, the workflow may fail or ignore changes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"attrPath\": \"volume_key\",\n    \"oldVersion\": \"0.3.11\",\n    \"newVersion\": \"0.3.12\",\n    \"files\": [\n      \"/path/to/nixpkgs/pkgs/development/libraries/volume-key/default.nix\"\n    ]\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Arbitrary String Settings and Type-Checked Ports with Freeform Modules (Nix)\nDESCRIPTION: This snippet illustrates configuration options permitted by a freeform module: assigning the undeclared attribute 'settings.logLevel' to a string value, showing the prohibition of non-string values according to the specified freeform type, and assigning 'settings.port' an integer value as allowed by its explicit option declaration. It helps distinguish between attributes accepted by freeformType rules and those checked or rejected based on more specific type constraints.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/freeform-modules.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # Not a declared option, but the freeform type allows this\n  settings.logLevel = \"debug\";\n\n  # Not allowed because the the freeform type only allows strings\n  # settings.enable = true;\n\n  # Allowed because there is a port option declared\n  settings.port = 80;\n\n  # Not allowed because the port option doesn't allow strings\n  # settings.port = \"443\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Runnable JAR Wrapper with makeWrapper - Nix Language\nDESCRIPTION: Demonstrates a Nix derivation that builds a runnable JAR and wraps it with an executable using makeWrapper. It flattens the Maven repository for classpath construction and generates a bin script that runs the main class with required JARs on the classpath. Requires Nixpkgs packages: stdenv, maven, callPackage, makeWrapper, jre, and a correctly built Maven repository and source. Output is an executable in $out/bin and a JAR in $out/share/java.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  maven,\n  callPackage,\n  makeWrapper,\n  jre,\n}:\nlet\n  repository = callPackage ./build-maven-repository.nix { };\nin\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"maven-demo\";\n  version = \"1.0\";\n\n  src = builtins.fetchTarball \"https://github.com/fzakaria/nixos-maven-example/archive/main.tar.gz\";\n  nativeBuildInputs = [ makeWrapper ];\n  buildInputs = [ maven ];\n\n  buildPhase = ''\n    runHook preBuild\n\n    echo \"Using repository ${repository}\"\n    mvn --offline -Dmaven.repo.local=${repository} package;\n\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/bin\n\n    classpath=$(find ${repository} -name \"*.jar\" -printf ':%h/%f');\n    install -Dm644 target/maven-demo-${finalAttrs.version}.jar $out/share/java\n    # create a wrapper that will automatically set the classpath\n    # this should be the paths from the dependency derivation\n    makeWrapper ${jre}/bin/java $out/bin/maven-demo \\\n          --add-flags \"-classpath $out/share/java/maven-demo-${finalAttrs.version}.jar:''${classpath#:}\" \\\n          --add-flags \"Main\"\n\n    runHook postInstall\n  '';\n})\n\n```\n\n----------------------------------------\n\nTITLE: Installing Cataclysm-DDA with Predefined Mods\nDESCRIPTION: Simple example showing how to install Cataclysm-DDA with selected mods from the default nixpkgs collection, specifically including the UndeadPeople tileset.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\ncataclysm-dda.withMods (\n  mods: with mods; [\n    tileset.UndeadPeople\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Loading Kernel Modules in Initial Ramdisk\nDESCRIPTION: Example showing how to include kernel modules in the initial ramdisk for early boot requirements using boot.initrd.kernelModules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.initrd.kernelModules = [ \"cifs\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Jottacloud CLI Options and Package - NixOS - Nix\nDESCRIPTION: This Nix configuration snippet shows how to customize the Jottacloud CLI service, providing additional options and specifying an explicit 'jotta-cli' package. The 'options' array (here set to '[\"slow\"]') passes runtime flags such as enabling low memory mode, while the 'package' attribute overrides which version or derivation of jotta-cli should be used (e.g., from 'pkgs.jotta-cli'). This allows fine-grained control over both runtime behavior and the package source. Requires access to a private or customized Nix package set if overriding 'package'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/jotta-cli.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nservices.jotta-cli = {\n  enable = true;\n  options = [ \"slow\" ];\n  package = pkgs.jotta-cli;\n};\n```\n\n----------------------------------------\n\nTITLE: NixOS Service Configuration - NetworkManager FCC Unlock\nDESCRIPTION: Configuration example showing the new networking.networkmanager.fccUnlockScripts option that replaced enableFccUnlock\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nnetworking.networkmanager.fccUnlockScripts\n```\n\n----------------------------------------\n\nTITLE: Basic Crystal Package Derivation in Nix\nDESCRIPTION: A minimal Nix derivation using crystal.buildCrystalPackage to build the Mint language. It specifies the package name, version, source repository, and path to the shards.nix file for dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/crystal.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\ncrystal.buildCrystalPackage rec {\n  pname = \"mint\";\n  version = \"0.5.0\";\n\n  src = fetchFromGitHub {\n    owner = \"mint-lang\";\n    repo = \"mint\";\n    rev = version;\n    hash = \"sha256-dFN9l5fgrM/TtOPqlQvUYgixE4KPr629aBmkwdDoq28=\";\n  };\n\n  # Insert the path to your shards.nix file here\n  shardsFile = ./shards.nix;\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Maven A-Level Metadata Structure\nDESCRIPTION: XML structure for artifact-level metadata in Maven repositories, used for version listing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/tools/build-managers/gradle/README.md#_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<groupId>group-id</groupId>\n<artifactId>artifact-id</artifactId>\n<versioning>\n  <latest>version</latest>\n  <release>version</release>\n  <versions>\n    <version>version</version>\n  </versions>\n  <lastUpdated>timestamp</lastUpdated>\n</versioning>\n```\n\n----------------------------------------\n\nTITLE: Inspecting Double Invocation Maven Repo Output - Bash Language\nDESCRIPTION: Shows how to examine the directory structure of a Maven repository produced by the double invocation pattern in Nix. Uses the tree utility and nix-build to print the resulting content, helping users verify the contents of the Maven output derivation. Assumes double-invocation-repository.nix exists and tree is installed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n❯ tree $(nix-build --no-out-link double-invocation-repository.nix) | head\n/nix/store/8kicxzp98j68xyi9gl6jda67hp3c54fq-maven-repository\n├── backport-util-concurrent\n│   └── backport-util-concurrent\n│       └── 3.1\n│           ├── backport-util-concurrent-3.1.pom\n│           └── backport-util-concurrent-3.1.pom.sha1\n├── classworlds\n│   └── classworlds\n│       ├── 1.1\n│       │   ├── classworlds-1.1.jar\n\n```\n\n----------------------------------------\n\nTITLE: Overriding PAM LightDM Auto Login Service - Nix\nDESCRIPTION: This snippet shows how to override the PAM configuration for LightDM's autologin in NixOS to permit root auto-login. It uses the 'lib.mkForce' utility to ensure full replacement of the target option and provides a custom multi-line string containing authenticating and session management directives. Essential when the default LightDM constraints are too restrictive (e.g., preventing root login).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  security.pam.services.lightdm-autologin.text = lib.mkForce ''\n      auth     requisite pam_nologin.so\n      auth     required  pam_succeed_if.so quiet\n      auth     required  pam_permit.so\n\n      account  include   lightdm\n\n      password include   lightdm\n\n      session  include   lightdm\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Rook/Ceph Support in NixOS\nDESCRIPTION: NixOS kernel module configuration required for Rook/Ceph storage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n  boot.kernelModules = [ \"rbd\" ];\n```\n\n----------------------------------------\n\nTITLE: Building a Custom TeX Live Environment with combine - Nix - nix\nDESCRIPTION: Illustrates how to assemble a custom TeX Live environment by combining multiple schemes and packages using texlive.combine. Package sets are inherited from the texlive attribute, supporting a flexible collection of packages. Intended for users who need to mix a curated set of packages (e.g., for Korean, algorithms, fonts). Prerequisite: Nixpkgs, basic understanding of TeX Live schemes and collections.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/texlive.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\ntexlive.combine {\n  inherit (texlive)\n    scheme-small\n    collection-langkorean\n    algorithms\n    cm-super\n    ;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MinIO Data Directories in NixOS\nDESCRIPTION: Shows the updated syntax for specifying multiple data directories for MinIO in NixOS, which is now required for using erasure coding.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\nservices.minio.dataDir = [ \"/path/to/dir1\" \"/path/to/dir2\" ];\n```\n\n----------------------------------------\n\nTITLE: Creating a Nix Store Only Disk Image using Nixpkgs (Nix)\nDESCRIPTION: This Nix expression demonstrates how to generate a disk image containing only the Nix store and registration information using the make-disk-image function from the Nixpkgs library. It sets explicit parameters for image format (qcow2), disables the bootloader and EFI manipulation, and selects a store-only build (onlyNixStore = true;). Required dependencies include the Nixpkgs library, and parameters such as diskSize, format, and additionalPaths control the image build. Outputs a derivation producing a disk image file suitable for use with QEMU or similar tools.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/makediskimage.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> { };\n  lib = pkgs.lib;\n  make-disk-image = import <nixpkgs/nixos/lib/make-disk-image.nix>;\nin\nmake-disk-image {\n  inherit pkgs lib;\n  config = { };\n  additionalPaths = [ ];\n  format = \"qcow2\";\n  onlyNixStore = true;\n  partitionTableType = \"none\";\n  installBootLoader = false;\n  touchEFIVars = false;\n  diskSize = \"auto\";\n  additionalSpace = \"0M\"; # Defaults to 512M.\n  copyChannel = false;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Nebula Relay and Relays - NixOS Option - Markdown\nDESCRIPTION: This entry describes new options in the services.nebula.networks.<name> namespace: isRelay and relays, allowing the setup of relay nodes and specifying which hosts traffic should be relayed through in a Nebula network. These features depend on the Nebula software and proper configuration of the relevant network. Inputs control peer relaying behavior and affect network topology and routing for overlay meshes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n- Nebula now supports the \\`services.nebula.networks.<name>.isRelay\\` and \\`services.nebula.networks.<name>.relays\\` configuration options for setting up or allowing traffic relaying. See the [announcement](https://www.defined.net/blog/announcing-relay-support-in-nebula/) for more details about relays.\n```\n\n----------------------------------------\n\nTITLE: Alternative Reference to Stable Android Studio Package - Nix\nDESCRIPTION: Specifies the androidStudioPackages.stable.full attribute as a build input—functionally identical to 'android-studio-full'—to set up a complete Android SDK within a Nix build environment. Ensures access to all essential tools and system images necessary for comprehensive Android app development.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [ androidStudioPackages.stable.full ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cataclysm-DDA to Use XDG Config Directory\nDESCRIPTION: Nix override to change the default configuration directory from ~/.cataclysm-dda to XDG_CONFIG_HOME/cataclysm-dda.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\ncataclysm-dda.override {\n  useXdgDir = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Parallel Tests in Rust Package Build\nDESCRIPTION: Configuration to disable parallel test execution in a Rust package build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  # ...\n  dontUseCargoParallelTests = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Singularity and Apptainer - Package Selection and Option Updates - Markdown\nDESCRIPTION: This block explains the package namespace split between apptainer (the renamed mainline project) and singularity (Sylabs Inc's fork), both available in nixpkgs. It introduces a new singularity-tools.buildImage argument for explicit package selection, and a programs.singularity.enableFakeroot option to provide fakeroot support across both variants. It affects build tooling and runtime privileges for container images in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\n- As Singularity has renamed to [Apptainer](https://apptainer.org/news/community-announcement-20211130)\n  to distinguish from [an un-renamed fork by Sylabs Inc.](https://sylabs.io/2021/05/singularity-community-edition),\n  there are now two packages of Singularity/Apptainer:\n  * \\`apptainer\\`: From \\`github.com/apptainer/apptainer\\`, which is the new repo after renaming.\n  * \\`singularity\\`: From \\`github.com/sylabs/singularity\\`, which is the fork by Sylabs Inc..\n\n  \\`singularity-tools.buildImage\\` got a new input argument \\`singularity\\` to specify which package to use.\n\n- The new option \\`programs.singularity.enableFakeroot\\`, if set to \\`true\\`, provides \\`--fakeroot\\` support for \\`apptainer\\` and \\`singularity\\`.\n```\n\n----------------------------------------\n\nTITLE: Basic Grocy Service Configuration in NixOS\nDESCRIPTION: A minimal configuration to enable the Grocy service in NixOS with a custom hostname. This sets up a basic nginx vhost with automatic ACME/Let's Encrypt SSL configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/grocy.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  services.grocy = {\n    enable = true;\n    hostName = \"grocy.tld\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking hyperlinks in static site documentation with lycheeLinkCheck\nDESCRIPTION: Example of using testers.lycheeLinkCheck to validate hyperlinks in the Nix documentation. This test will verify that internal links in the documentation site are correct.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\ntesters.lycheeLinkCheck {\n  site = nix.doc + \"/share/doc/nix/manual\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Diffie-Hellman Params and Service File - NixOS Module Configuration - Nix\nDESCRIPTION: This snippet shows how to define security Diffie-Hellman parameters for a custom service and configure a .conf file to reference the generated DH parameters path in NixOS. It utilizes module options and template string embedding within the Nix expression. Dependencies include the NixOS module system and proper user permissions to manage security.dhparams. The snippet expects the config attribute set as input and outputs attribute sets for both DH parameters and configuration file text. Modify options as required for custom services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1809.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ config, ... }:\n\n{\n  security.dhparams.params.myservice = {};\n  environment.etc.\"myservice.conf\".text = ''\n    dhparams = ${config.security.dhparams.params.myservice.path}\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Running lib.fileset Tests with Bash Script - Bash\nDESCRIPTION: Describes invoking the test suite for 'lib.fileset' by running 'fileset/tests.sh', a shell script that likely contains relevant assertions and verifications for the associated library component. The test script requires executable permissions and is expected to print results or error messages to the terminal.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nfileset/tests.sh\n```\n\n----------------------------------------\n\nTITLE: Including Subchapters in NixOS Administration Documentation\nDESCRIPTION: A directive that includes multiple Markdown subchapters related to NixOS system administration. These subchapters cover various aspects of system management including service management, rebooting, user sessions, control groups, logging, system state, store cleaning, containers, and troubleshooting.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/running.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\nservice-mgmt.chapter.md\nrebooting.chapter.md\nuser-sessions.chapter.md\ncontrol-groups.chapter.md\nlogging.chapter.md\nsystem-state.chapter.md\ncleaning-store.chapter.md\ncontainers.chapter.md\ntroubleshooting.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Final Rebase and Conflict Resolution onto Target Branch (Git)\nDESCRIPTION: This snippet describes the steps after retargeting a pull request to its new base branch. It involves performing a standard rebase of the feature branch onto 'upstream/staging', checking for conflicts with 'git status', and force-pushing the resolved branch. All commands assume a standard Git environment with upstream and origin remotes configured. This process ensures the feature branch is up-to-date and mergeable with the new target.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\n# Rebase onto target branch\ngit rebase upstream/staging\n# Review and fixup possible conflicts\ngit status\n# Force push your changes\ngit push origin feature --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Disabling LightDM Display Manager in Pantheon\nDESCRIPTION: Configuration setting to disable the default LightDM display manager when using Pantheon desktop environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1903.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nservices.xserver.displayManager.lightdm.enable\n```\n\n----------------------------------------\n\nTITLE: Adding PackageReference for Nix Discovery - XML\nDESCRIPTION: This XML snippet expands upon the previous example, illustrating how to add a PackageReference to allow Nix-based builds to discover locally built projects as NuGet dependencies. The PackageReference includes a wildcard version and a build condition for continuous integration scenarios. It ensures proper handling when integrating with buildDotnetModule's buildInputs. Input is the XML configuration added to .csproj/.fsproj; output influences dependency resolution at build/install time.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<ProjectReference Include=\"../foo/bar.fsproj\" />\n<PackageReference Include=\"bar\" Version=\"*\" Condition=\" '$(ContinuousIntegrationBuild)'=='true' \"/>\n```\n\n----------------------------------------\n\nTITLE: Kyverno Policy for Longhorn NixOS Path Configuration\nDESCRIPTION: Kubernetes YAML configuration defining Kyverno policy to automatically inject correct PATH environment variables for Longhorn pods on NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: longhorn-nixos-path\n  namespace: longhorn-system\ndata:\n  PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/run/wrappers/bin:/nix/var/nix/profiles/default/bin:/run/current-system/sw/bin\n---\napiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: longhorn-add-nixos-path\n  annotations:\n    policies.kyverno.io/title: Add Environment Variables from ConfigMap\n    policies.kyverno.io/subject: Pod\n    policies.kyverno.io/category: Other\n    policies.kyverno.io/description: >\n      Longhorn invokes executables on the host system, and needs\n      to be aware of the host systems PATH. This modifies all\n      deployments such that the PATH is explicitly set to support\n      NixOS based systems.\nspec:\n  rules:\n    - name: add-env-vars\n      match:\n        resources:\n          kinds:\n            - Pod\n          namespaces:\n            - longhorn-system\n      mutate:\n        patchStrategicMerge:\n          spec:\n            initContainers:\n              - (name): \"*\"\n                envFrom:\n                  - configMapRef:\n                      name: longhorn-nixos-path\n            containers:\n              - (name): \"*\"\n                envFrom:\n                  - configMapRef:\n                      name: longhorn-nixos-path\n---\n```\n\n----------------------------------------\n\nTITLE: Setting System State Version for Compatibility - NixOS Configuration - Nix\nDESCRIPTION: This configuration snippet sets the NixOS system state version to '14.12' using the 'system.stateVersion' option. This is needed to preserve compatibility with previous NixOS release behaviors, such as SSHD key types. It must be included in the system's configuration.nix. The main input is the desired version string; output is the system retaining older default behaviors where necessary.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  system.stateVersion = \"14.12\";\n}\n```\n\n----------------------------------------\n\nTITLE: Importing CUDNN Module in Nix\nDESCRIPTION: This snippet demonstrates how to import the CUDNN module, which aliases the generic module for release expressions. It showcases the use of relative imports in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/modules/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n./cudnn/default.nix\n```\n\n----------------------------------------\n\nTITLE: Enabling GNOME Games - NixOS Module Configuration - Nix\nDESCRIPTION: This code enables the installation of all available GNOME games on NixOS by setting the 'services.gnome.games.enable' module option to true. Dependency is the GNOME games module in NixOS. After applying, standard GNOME game packages will be present on the system. Only the 'enable' attribute needs to be set to true.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/gnome.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gnome.games.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Pleroma Database with PostgreSQL\nDESCRIPTION: Command to create and seed the Pleroma database using the previously generated setup.psql file, executed as the postgres user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ sudo -u postgres psql -f setup.psql\n```\n\n----------------------------------------\n\nTITLE: JSON Response Format for Image Upload\nDESCRIPTION: Example JSON response structure returned by the POST /image endpoint after successful image uploads. Includes file identifiers and delete tokens for each uploaded image.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pict-rs.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"files\": [\n        {\n            \"delete_token\": \"JFvFhqJA98\",\n            \"file\": \"lkWZDRvugm.jpg\"\n        },\n        {\n            \"delete_token\": \"kAYy9nk2WK\",\n            \"file\": \"8qFS0QooAn.jpg\"\n        },\n        {\n            \"delete_token\": \"OxRpM3sf0Y\",\n            \"file\": \"1hJaYfGE01.jpg\"\n        }\n    ],\n    \"msg\": \"ok\"\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Init Commands to WeeChat via 'init' Attribute - Nix\nDESCRIPTION: This snippet shows how to pass initialization commands to WeeChat using the 'init' attribute in the Nix override. These commands run at startup, enabling custom session configuration such as setting variables or adding servers. The attribute 'init' is set to a shell-like string containing WeeChat commands. Requires knowledge of supported WeeChat startup commands.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nweechat.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      init = ''\n        /set foo bar\n        /server add libera irc.libera.chat\n      '';\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Staging Workflow Git Branch Visualization\nDESCRIPTION: Mermaid diagram showing the flow of commits between master, staging, and staging-next branches, including automatic and manual merge processes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_13\n\nLANGUAGE: mermaid\nCODE:\n```\n%%{init: {\n    'theme': 'base',\n    'themeVariables': {\n        'gitInv0': '#ff0000',\n        'gitInv1': '#ff0000',\n        'git2': '#ff4444',\n        'commitLabelFontSize': '15px'\n    },\n    'gitGraph': {\n        'showCommitLabel':true,\n        'mainBranchName': 'master',\n        'rotateCommitLabel': true\n    }\n} }%%\ngitGraph\n    commit id:\" \"\n    branch staging\n    commit id:\"  \"\n    branch staging-next\n\n    merge master id:\"automatic\"\n    checkout staging\n    merge staging-next id:\"automatic \"\n\n    checkout staging-next\n    merge staging type:HIGHLIGHT id:\"manual\"\n    commit id:\"fixup\"\n\n    checkout master\n    checkout staging\n    checkout master\n    commit id:\"       \"\n    checkout staging-next\n    merge master id:\"automatic  \"\n    checkout staging\n    merge staging-next id:\"automatic   \"\n\n    checkout staging-next\n    commit id:\"fixup \"\n    checkout master\n    merge staging-next type:HIGHLIGHT id:\"manual (PR)\"\n```\n\n----------------------------------------\n\nTITLE: Setting Install Name via Linker Flags in Nix Derivation (Nix)\nDESCRIPTION: This snippet demonstrates configuring the install name for a dynamic library on Darwin by passing linker flags within a Nix mkDerivation expression. It conditionally applies the LDFLAGS only on Darwin systems using lib.optional, setting the install_name so that the resulting dynamic library references the correct path at runtime. Dependencies include stdenv.mkDerivation and Nixpkgs' lib, as well as proper setup of the hostPlatform attribute. The input expects mkDerivation context and outputs a derivation with the correct install_name embedded.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  # ...\n  makeFlags = lib.optional stdenv.hostPlatform.isDarwin \"LDFLAGS=-Wl,-install_name,$(out)/lib/libfoo.dylib\";\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Target Kernel Headers - Builder Script - shell\nDESCRIPTION: A shell builder script used for extracting and installing Linux kernel headers for the target (arm) architecture. It implements buildPhase and installPhase functions: first running make for a key header file, then building ARCH=arm, and copying requisite include files into the $out directory. Also, it creates an empty autoconf.h file to satisfy dependencies. Depends on an environment provided by stdenv/setup. Expects invocation from mkDerivation as builder.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/old/cross.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsource $stdenv/setup\n\n\nbuildPhase() {\n    make include/linux/version.h\n}\n\nbuildPhase=buildPhase\n\n\ninstallPhase() {\n    mkdir $out\n    mkdir $out/include\n    #cd $out/include\n    #ln -s asm-arm asm\n    make include/asm ARCH=arm\n    cp -prvd include/linux include/asm include/asm-arm include/asm-generic $out/include\n    echo -n > $out/include/linux/autoconf.h\n}\n\ninstallPhase=installPhase\n\n\ngenericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Including Eggs in Build Inputs with Nix Expression - Nix\nDESCRIPTION: This code snippet demonstrates how to specify CHICKEN and a specific egg (e.g., srfi-189) as build inputs in a Nix derivation. By placing chickens and one or more eggs under buildInputs, the Nix build environment configures the relevant CHICKEN environment variables via setup hooks. No additional dependencies beyond Nixpkgs and the chickenPackages attribute set are required. This approach supports consistent builds for packages needing specific Scheme extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/chicken.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    chicken\n    chickenPackages.chickenEggs.srfi-189\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling the Firewall in NixOS (Nix - nix)\nDESCRIPTION: Demonstrates how to turn off the default firewall by setting an attribute in the system configuration. Relevant for cases where no firewall is desired. Input: Boolean value for networking.firewall.enable. Output: System service disables the firewall on rebuild and reboot.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.firewall.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Android Ant-based Project Build Configuration\nDESCRIPTION: Nix configuration for building Android applications using Ant build system, including release signing configuration and SDK/NDK integration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\nandroidenv.buildApp {\n  name = \"MyAndroidApp\";\n  src = ./myappsources;\n  release = true;\n\n  # If release is set to true, you need to specify the following parameters\n  keyStore = ./keystore;\n  keyAlias = \"myfirstapp\";\n  keyStorePassword = \"mykeystore\";\n  keyAliasPassword = \"myfirstapp\";\n\n  # Any Android SDK parameters that install all the relevant plugins that a\n  # build requires\n  platformVersions = [ \"24\" ];\n\n  # When we include the NDK, then ndk-build is invoked before Ant gets invoked\n  includeNDK = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Build and Native Build Inputs for Classpath Integration (Nix)\nDESCRIPTION: Specifies how to declare buildInputs and nativeBuildInputs in a package that relies on another Java library, ensuring that JARs are added to the CLASSPATH automatically. Dependencies include the referenced Java library (libfoo) and JDK. Outputs an environment where CLASSPATH contains paths to necessary JAR files for build/runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/java.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [ libfoo ];\n  nativeBuildInputs = [ jdk ];\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Filtering Out All Files From a Directory Using fileFilter (Nix)\nDESCRIPTION: This Nix code snippet illustrates the use of the fileFilter function in combination with the path './.'. It shows a scenario for discussing the behavior when a filter is applied that excludes all files. The snippet serves as an example to question whether the directory structure should remain unchanged or be altered when all files are excluded. The code is not a standalone implementation, but a point of discussion for designing predictable filter semantics in fileset operations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_1\n\nLANGUAGE: Nix\nCODE:\n```\n\"fileFilter (file: false) ./.\"\n```\n\n----------------------------------------\n\nTITLE: Triggering a Build for a Specific Agda Package via Ofborg - Shell/Comment - shell\nDESCRIPTION: A sample PR comment that triggers the Ofborg build process for a specific Agda package (here, agdaPackages.iowa-stdlib) in the Nixpkgs CI infrastructure. To use, post as a comment in a GitHub pull request on Nixpkgs. No dependencies other than Ofborg being connected to the repository.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n@ofborg build agdaPackages.iowa-stdlib\n```\n\n----------------------------------------\n\nTITLE: Setting Default MPI Implementation in NixOS\nDESCRIPTION: Configuration to override the default MPI implementation from openmpi to mpich.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nself: super:\n{\n  mpi = super.mpich;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Kernel with Specific Source and Config - Nix\nDESCRIPTION: This Nix expression demonstrates manual kernel configuration by specifying version, src, and configfile for pkgs.linuxPackages_custom. It explicitly fetches a kernel tarball and uses a custom configuration file, making it suitable for use cases like VM kernels. Dependencies include pkgs, a valid URL for the tarball, and a path to a config file. The main input is an attribute set with version, src, and configfile; it outputs a custom Linux kernel derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/linux.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\npkgs.linuxPackages_custom {\n  version = \"6.1.55\";\n  src = pkgs.fetchurl {\n    url = \"https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-${version}.tar.xz\";\n    hash = \"sha256-qH4kHsFdU0UsTv4hlxOjdp2IzENrW5jPbvsmLEr/FcA=\";\n  };\n  configfile = ./path_to_config_file;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Switchboard Plugs in NixOS\nDESCRIPTION: Manual configuration to override the default Switchboard plugs with custom ones. This adds to the default plugins unless useDefaultPlugs is set to false.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nswitchboard-with-plugs.override {\n  plugs = [\n    pkgs.some-special-plug\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Typical Shell Commands for Rust Development inside Nix Shell (Shell)\nDESCRIPTION: This small snippet lists typical shell commands used for building and testing a Rust project inside a Nix shell. Using `nix-shell --pure` ensures a clean environment, followed by Rust's standard `cargo build` and `cargo test` invocations. There are no direct dependencies, but use assumes the shell environment is provided by a compatible `shell.nix`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_32\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-shell --pure\n$ cargo build\n$ cargo test\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Systemd Units via Package Configuration (Nix - nix)\nDESCRIPTION: Demonstrates how to enable systemd units provided by a package in NixOS using a Nix configuration attribute. Requires NixOS system module configuration capabilities, with pkgs.foo referring to a Nix package set attribute. Input: An attribute set containing systemd configuration. Output: The system will enable service units included in the listed packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.packages = [ pkgs.foo ];\n}\n```\n\n----------------------------------------\n\nTITLE: Updating PureScm Package Version and Dependencies\nDESCRIPTION: Shell command sequence for updating the PureScm package version and its npm dependencies. The process includes bumping the version in package.json and regenerating the package lock file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/pu/purescm/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n(cd manifests && nix-shell -p nodejs --command \"npm i --package-lock-only\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Users for Anki Sync Server in NixOS\nDESCRIPTION: This snippet demonstrates how to set up a user for Anki Sync Server. It specifies a username and a file containing the password.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/anki-sync-server.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.anki-sync-server.users = [\n    {\n      username = \"user\";\n      passwordFile = /etc/anki-sync-server/user;\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Including Release Notes Appendix\nDESCRIPTION: Defines an appendix for release notes that will be processed into a separate HTML file with the path //release-notes.html.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/manual.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} appendix html:into-file=//release-notes.html\nrelease-notes/release-notes.md\n```\n```\n\n----------------------------------------\n\nTITLE: Building a fetchurl Package with Custom Output Name - Shell\nDESCRIPTION: This shell command illustrates the result of building a Nix package with a custom output name set in fetchurl. The output path uses the given name, demonstrating predictable naming irrespective of which URL fetched the file. It requires only Nix and provides a stable artifact location.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/zczb6wl3al6jm9sm5h3pr6nqn0i5ji9z-nixpkgs-version\n```\n\n----------------------------------------\n\nTITLE: Packaging a Perl Module with preConfigure Hook - Nix\nDESCRIPTION: This advanced Nix derivation packages the BerkeleyDB Perl module, adding a preConfigure shell hook to prepare custom configuration required for the build. Dependencies are buildPerlPackage, fetchurl, and db. Inputs include the config and pre-built libraries; output is a packaged Perl module suitable for environments needing BerkeleyDB support. Demonstrates customizing the build process for complex Perl modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildPerlPackage,\n  fetchurl,\n  db,\n}:\n\nbuildPerlPackage rec {\n  pname = \"BerkeleyDB\";\n  version = \"0.36\";\n\n  src = fetchurl {\n    url = \"mirror://cpan/authors/id/P/PM/PMQS/BerkeleyDB-${version}.tar.gz\";\n    hash = \"sha256-4Y+HGgGQqcOfdiKcFIyMrWBEccVNVAMDBWZlFTMorh8=\";\n  };\n\n  preConfigure = ''\n    echo \"LIB = ${db.out}/lib\" > config.in\n    echo \"INCLUDE = ${db.dev}/include\" >> config.in\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Converting pkgs.lib to lib in NixOS Modules\nDESCRIPTION: Example of converting a NixOS module from using pkgs.lib to explicitly importing lib as a module argument. This is the recommended pattern for all NixOS modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\nwith pkgs.lib;\n\n{\n  options = {\n    foo = mkOption { /* … */ };\n  };\n  config = mkIf config.foo { /* … */ };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, lib, ... }:\n\nwith lib;\n\n{\n  options = {\n    foo = mkOption { /* option declaration */ };\n  };\n  config = mkIf config.foo { /* option definition */ };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Custom SDK Version in Darwin Build\nDESCRIPTION: Example showing how to specify a non-default SDK version for Darwin builds that require newer APIs or frameworks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  # ...\n  buildInputs = [ apple-sdk_14 ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Inspecting Unnamed Exported Image Archive - Shell\nDESCRIPTION: This shell sample exhibits Nix building a Docker image export without a name attribute, showing that the resulting tarball's filename may be misleading (.tar.gz despite being uncompressed). The `file` command is used to confirm the file type. Requires Nix store access, presence of built image, and the POSIX file utility. Important for avoiding tarball extension confusion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(output removed for clarity)\n/nix/store/by3f40xvc4l6bkis74l0fj4zsy0djgkn-hello.tar.gz\n$ file /nix/store/by3f40xvc4l6bkis74l0fj4zsy0djgkn-hello.tar.gz\n/nix/store/by3f40xvc4l6bkis74l0fj4zsy0djgkn-hello.tar.gz: POSIX tar archive (GNU)\n\n```\n\n----------------------------------------\n\nTITLE: Including Chapter Files in Markdown Documentation\nDESCRIPTION: A markdown include directive that references multiple chapter files related to build helpers documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\nbuild-helpers/fixed-point-arguments.chapter.md\nbuild-helpers/fetchers.chapter.md\nbuild-helpers/trivial-build-helpers.chapter.md\nbuild-helpers/testers.chapter.md\nbuild-helpers/dev-shell-tools.chapter.md\nbuild-helpers/special.md\nbuild-helpers/images.md\nhooks/index.md\nlanguages-frameworks/index.md\npackages/index.md\n```\n```\n\n----------------------------------------\n\nTITLE: Defining End-Of-Life (EOL) Garage Versions in Nix - Nix Expression - nix\nDESCRIPTION: This Nix code snippet defines a legacy version of the Garage package, marking it as end-of-life (EOL). It utilizes the 'generic' function, specifying the version, SHA256 hash, and setting an 'eol' attribute to true to indicate its EOL status. Dependencies include the standard Nix package infrastructure and a 'generic' function for version instantiation. Parameters include the version string, cryptographic hash for source integrity, and EOL flag; outputs an attribute set for a deprecated Garage version, typically used to protect users from unintentionally upgrading to unsupported versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-servers/garage.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n/* ... */\n{\n  garage_0_7_3 = generic {\n    version = \"0.7.3\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n    eol = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting vboxsf Shared Folders - Filesystem Configuration - NixOS - Nix\nDESCRIPTION: Configures a shared folder using VirtualBox's vboxsf filesystem in NixOS by assigning to the 'fileSystems' attribute in configuration.nix. Inputs: mount point (e.g., '/shiny'), device name (e.g., 'myshinysharedfolder'), and file system type ('vboxsf'). Requires that VirtualBox guest additions and appropriate kernel modules are available. Used for seamless file sharing between host and guest; no output except the mounted folder at runtime.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems.\"/shiny\" = {\n    device = \"myshinysharedfolder\";\n    fsType = \"vboxsf\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Typing Booster Languages with Custom Hunspell Dictionaries (Nix)\nDESCRIPTION: This example shows how to override the languages supported by ibus-engines.typing-booster in NixOS, adding custom hunspell dictionaries (e.g., 'de-at', 'en-gb'). The override function accepts a langs attribute (an array of language codes) that must match those available in pkgs.hunspellDicts. This pattern is used in configuration or overlays to customize package functionality for additional input languages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/ibus.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nibus-engines.typing-booster.override {\n  langs = [\n    \"de-at\"\n    \"en-gb\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Extending mkDerivation with Fixed-Point Support Using lib.extendMkDerivation (Nix)\nDESCRIPTION: This snippet shows how to define a build helper that supports fixed-point attribute sets by leveraging lib.extendMkDerivation. By specifying constructDrv as stdenv.mkDerivation and listing excluded attribute names (like specialArg), this helper ensures fields are properly filtered. The extendDrvArgs lambda allows further customization of derived attributes, including default values and conditional logic. Requires the Nixpkgs library and stdenv, and supports passing the full fixed-point attribute set (finalAttrs) to the underlying derivation. Useful for composing more advanced and reusable build helpers.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fixed-point-arguments.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlib.extendMkDerivation {\n  constructDrv = stdenv.mkDerivation;\n  excludeDrvArgNames = [\n    # Don\\'t pass specialArg into mkDerivation.\n    \"specialArg\"\n  ];\n  extendDrvArgs =\n    finalAttrs:\n    {\n      preferLocalBuild ? true,\n      allowSubstitute ? false,\n      specialArg ? (_: false),\n      ...\n    }@args:\n    {\n      # Arguments to pass\n      inherit\n        preferLocalBuild\n        allowSubstitute\n        ;\n      # Some expressions involving specialArg\n      greeting = if specialArg \"hi\" then \"hi\" else \"hello\";\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Expanded mkIf Implementation Example\nDESCRIPTION: Shows how mkIf effectively pushes down conditionals into individual definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = {\n    environment.systemPackages = if config.services.httpd.enable then [ /* ... */ ] else [];\n    # ...\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: mkPackageOption Basic Usage\nDESCRIPTION: Shows basic usage of mkPackageOption for creating a package configuration option with defaults.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nmkPackageOption pkgs \"name\" { default = [ \"path\" \"in\" \"pkgs\" ]; example = \"literal example\"; }\n```\n\n----------------------------------------\n\nTITLE: Launching Octave with Specific Packages via nix-shell (ShellSession)\nDESCRIPTION: This command launches a Nix shell environment that provides Octave along with the specified 'symbolic' package by leveraging the withPackages function. It uses the -p flag to add a package to the environment, passing an inline lambda function to select packages. The command depends on Nixpkgs and assumes 'symbolic' is a valid Octave package attribute. The shell provides an ephemeral environment; any installed packages are only available in this session.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/octave.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p 'octave.withPackages (ps: with ps; [ symbolic ])'\n```\n\n----------------------------------------\n\nTITLE: Upgrading All Installed Packages - ShellSession\nDESCRIPTION: Upgrades all installed user packages for which a newer version exists in the current Nix channel using the nix-env -u '*' command. The '*' wildcard targets every installed package. Dependencies include a previously updated channel and installed packages. The outcome is all relevant packages in the user profile are upgraded, except those pinned to older versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ad-hoc-packages.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -u '*'\n```\n\n----------------------------------------\n\nTITLE: Marking Haskell Packages as Broken or Unbroken\nDESCRIPTION: Functions to set or unset the 'broken' flag for Haskell package derivations, affecting whether they will be built or skipped.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\nmarkBroken drv\nmarkUnbroken drv\nunmarkBroken drv\n```\n\n----------------------------------------\n\nTITLE: Configuring Specialisation in NixOS\nDESCRIPTION: These snippets show how to replace the deprecated nesting.clone and nesting.children options with the new specialisation configurations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  specialisation.example-sub-configuration = {\n    configuration = {\n      # ...\n    };\n  };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  specialisation.example-sub-configuration = {\n    inheritParentConfig = false;\n    configuration = {\n      # ...\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Package Inside the Nix Development Environment Container\nDESCRIPTION: Example showing how to use the buildDerivation command inside a container created with buildNixShellImage to build and test the hello package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_34\n\nLANGUAGE: shell\nCODE:\n```\n$ docker container run -it hello-2.12.1-env:latest\n[nix-shell:~]$ buildDerivation\nRunning phase: unpackPhase\nunpacking source archive /nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\nsource root is hello-2.12.1\n(some output removed for clarity)\nRunning phase: fixupPhase\nshrinking RPATHs of ELF executables and libraries in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1\nshrinking /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/bin/hello\nchecking for references to /build/ in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1...\ngzipping man pages under /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/share/man/\npatching script interpreter paths in /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1\nstripping (with command strip and flags -S -p) in  /nix/store/f2vs29jibd7lwxyj35r9h87h6brgdysz-hello-2.12.1/bin\n\n[nix-shell:~]$ $out/bin/hello\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Setting Up Synapse Antispam Module for Mjolnir - Nix\nDESCRIPTION: This snippet demonstrates integrating the Mjolnir-based antispam module with Synapse using NixOS configuration files. It adds the matrix-synapse-mjolnir-antispam plugin to the Synapse plugin list and configures the MJolnir module with options to block invites and messages from banned users/servers, as well as filter users from the directory. Key parameters include toggles for blocking invites, messages, usernames, and specifying ban list room IDs. This block is intended for the NixOS configuration.nix, requiring the relevant plugin package and previously created ban list rooms already joined by the server.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/matrix/mjolnir.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.matrix-synapse = {\n    plugins = with pkgs; [\n      matrix-synapse-plugins.matrix-synapse-mjolnir-antispam\n    ];\n    extraConfig = ''\n      modules:\n        - module: mjolnir.Module\n          config:\n            # Prevent servers/users in the ban lists from inviting users on this\n            # server to rooms. Default true.\n            block_invites: true\n            # Flag messages sent by servers/users in the ban lists as spam. Currently\n            # this means that spammy messages will appear as empty to users. Default\n            # false.\n            block_messages: false\n            # Remove users from the user directory search by filtering matrix IDs and\n            # display names by the entries in the user ban list. Default false.\n            block_usernames: false\n            # The room IDs of the ban lists to honour. Unlike other parts of Mjolnir,\n            # this list cannot be room aliases or permalinks. This server is expected\n            # to already be joined to the room - Mjolnir will not automatically join\n            # these rooms.\n            ban_lists:\n              - \"!roomid:example.org\"\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Administrative Users with pleroma_ctl - ShellSession\nDESCRIPTION: This shell command invokes the pleroma_ctl administration utility to create a new user for Akkoma, assigning administrative and moderator roles, and setting the provided password. It requires the Akkoma service and CLI to be running. Inputs are the user's nickname, email, and password; output is a new privileged user account.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/akkoma.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ pleroma_ctl user new <nickname> <email> --admin --moderator --password <password>\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL script reference for TimescaleDB upgrade\nDESCRIPTION: Reference to a SQL script that must be run after upgrading TimescaleDB to fix hypertable foreign keys. This script is required for proper database functioning after the upgrade.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nhttps://github.com/timescale/timescaledb-extras/blob/master/utils/2.15.X-fix_hypertable_foreign_keys.sql\n```\n\n----------------------------------------\n\nTITLE: Setting Vim Alias to Emacs Editor\nDESCRIPTION: Shell alias configuration to redirect vi commands to the Emacs editor wrapper script.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nalias vi=$EDITOR\n```\n\n----------------------------------------\n\nTITLE: Including All Default Plugins and Custom Python Packages - WeeChat Nix Override - Nix\nDESCRIPTION: This Nix example illustrates how to include all default plugins and substitute the Python plugin with one containing extra dependencies using 'builtins.attrValues' and attribute update syntax. The approach merges 'availablePlugins' with an overridden 'python' entry using 'withPackages'. It accepts all default plugins but ensures Python plugin is replaced with a version that bundles extra packages like 'pycrypto' and 'python-dbus'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/weechat.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nweechat.override {\n  configure =\n    { availablePlugins, ... }:\n    {\n      plugins = builtins.attrValues (\n        availablePlugins\n        // {\n          python = availablePlugins.python.withPackages (\n            ps: with ps; [\n              pycrypto\n              python-dbus\n            ]\n          );\n        }\n      );\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing a Haskell Executable - nix-env Install Command - ShellSession\nDESCRIPTION: Instructs how to install a Haskell executable program, such as 'pandoc', from the available haskellPackages using the nix-env command-line tool. Requires a functioning Nix setup and an appropriate channel. Inputs: package attribute to install (e.g., 'haskellPackages.pandoc'); output: the specified executable made available in the user's environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-env -f \"<nixpkgs>\" -iA haskellPackages.pandoc\n```\n\n----------------------------------------\n\nTITLE: Builder Script for Minimal Cross GCC - Tool Wrapping and Platform Setup - shell\nDESCRIPTION: This builder.sh shell script prepares, builds, and installs a minimal cross GCC. It handles environment tweaks (including use of noSysDirs, extra compiler/linker flags, and a ld-wrapper hook for glibc), sets up the binutils specifically prefixed for arm-linux, and symlinks arm toolchain utilities into the compiler output directory. It configures language frontends based on inputs, disables unnecessary subsystems, and prunes resulting installation. Prerequisites are Nix stdenv, arm binutils, kernel headers, and a properly structured builder environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/old/cross.txt#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsource $stdenv/setup\n\n\nexport NIX_FIXINC_DUMMY=$NIX_BUILD_TOP/dummy\nmkdir $NIX_FIXINC_DUMMY\n\n\nif test \"$noSysDirs\" = \"1\"; then\n\n    if test \"$noSysDirs\" = \"1\"; then\n        # Figure out what extra flags to pass to the gcc compilers\n        # being generated to make sure that they use our glibc.\n        if test -e $NIX_CC/nix-support/orig-glibc; then\n            glibc=$(cat $NIX_CC/nix-support/orig-glibc)\n            # Ugh.  Copied from gcc-wrapper/builder.sh.  We can't just\n            # source in $NIX_CC/nix-support/add-flags, since that\n            # would cause *this* GCC to be linked against the\n            # *previous* GCC.  Need some more modularity there.\n            extraCFlags=\"-B$glibc/lib -isystem $glibc/include\"\n            extraLDFlags=\"-B$glibc/lib -L$glibc/lib -Wl,-s \\\n              -Wl,-dynamic-linker,$glibc/lib/ld-linux.so.2\"\n\n            # Oh, what a hack.  I should be shot for this.\n            # In stage 1, we should link against the previous GCC, but\n            # not afterwards.  Otherwise we retain a dependency.\n            # However, ld-wrapper, which adds the linker flags for the\n            # previous GCC, is also used in stage 2/3.  We can prevent\n            # it from adding them by NIX_GLIBC_FLAGS_SET, but then\n            # gcc-wrapper will also not add them, thereby causing\n            # stage 1 to fail.  So we use a trick to only set the\n            # flags in gcc-wrapper.\n            hook=$(pwd)/ld-wrapper-hook\n            echo \"NIX_GLIBC_FLAGS_SET=1\" > $hook\n            export NIX_LD_WRAPPER_START_HOOK=$hook\n        fi\n\n        export NIX_EXTRA_CFLAGS=$extraCFlags\n        export NIX_EXTRA_LDFLAGS=$extraLDFlags\n        export CFLAGS=$extraCFlags\n        export CXXFLAGS=$extraCFlags\n        export LDFLAGS=$extraLDFlags\n    fi\n\nelse\n    patches=\"\"\nfi\n\n\npreConfigure=preConfigure\npreConfigure() {\n\n    # Determine the frontends to build.\n    langs=\"c\"\n    if test -n \"$langCC\"; then\n        langs=\"$langs,c++\"\n    fi\n    if test -n \"$langF77\"; then\n        langs=\"$langs,f77\"\n    fi\n\n    # Cross compiler evilness\n    mkdir -p $out\n    mkdir -p $out/arm-linux\n    mkdir -p $out/arm-linux/bin\n    ln -s $binutilsArm/arm-linux/bin/as $out/arm-linux/bin/as\n    ln -s $binutilsArm/arm-linux/bin/ld $out/arm-linux/bin/ld\n    ln -s $binutilsArm/arm-linux/bin/ar $out/arm-linux/bin/ar\n    ln -s $binutilsArm/arm-linux/bin/ranlib $out/arm-linux/bin/ranlib\n\n    # Perform the build in a different directory.\n    mkdir ../build\n    cd ../build\n\n    configureScript=../$sourceRoot/configure\n    configureFlags=\"--enable-languages=$langs --target=$platform --disable-threads --disable-libmudflap --disable-shared --with-headers=$kernelHeadersArm/include --disable-multilib\"\n}\n\n\npostInstall=postInstall\npostInstall() {\n    # Remove precompiled headers for now.  They are very big and\n    # probably not very useful yet.\n    find $out/include -name \"*.gch\" -exec rm -rf {} \\; -prune\n\n    # Remove `fixincl' to prevent a retained dependency on the\n    # previous gcc.\n    rm -rf $out/libexec/gcc/*/*/install-tools\n}\n\n\n#if test -z \"$profiledCompiler\"; then\n    #makeFlags=\"bootstrap\"\n#else\n    #makeFlags=\"profiledbootstrap\"\n#fi\n\ngenericBuild\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Wingpanel with Specific Indicators Only\nDESCRIPTION: Advanced configuration to use only specific Wingpanel indicators, disabling all default ones. Useful for testing a particular plugin in isolation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nwingpanel-with-indicators.override {\n  useDefaultIndicators = false;\n  indicators = specialListOfIndicators;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bootspec Extensions in NixOS\nDESCRIPTION: Example showing how to use boot.bootspec.extensions to inject custom data for SecureBoot configuration. This snippet demonstrates adding an OS release path for unified kernel image creation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/bootspec.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, ... }: {\n  boot.bootspec.extensions = {\n    \"org.secureboot.osRelease\" = config.environment.etc.\"os-release\".source;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GVfs Package for Xfce4 with Disabled Samba Support\nDESCRIPTION: Configuration snippet to set a lighter version of GVfs without Samba support for Xfce4 desktop environment. This maintains the previous behavior after the default configuration was changed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.gvfs.package = pkgs.gvfs.override { samba = null; };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Source for a Derivation in Nix\nDESCRIPTION: Changes the source of a package using overrideAttrs, which will be built incrementally using the previously created checkpoint artifacts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/checkpoint-build.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  changedVBox = pkgs.virtualbox.overrideAttrs (old: {\n    src = path/to/vbox/sources;\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding nimOverrides in buildNimPackage Externally - Nix Expression - Nix\nDESCRIPTION: This example demonstrates externally overriding a dependency for a Nim package by overriding the 'nimOverrides' attribute in 'buildNimPackage' from outside the package definition, effective for cases where the dependency needs to be swapped globally. Dependencies: Nix, 'pkgs', 'buildNimPackage', 'nimOverrides', replacement package (e.g., libressl). Inputs: Attrset specifying override. Output: Attribute set with overridden dependency. Limitation: Should be used with care to avoid unintended global impact.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/nim.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }:\n{\n  foo = pkgs.foo.override {\n    buildNimPackage = pkgs.buildNimPackage.override {\n      nimOverrides = pkgs.nimOverrides.override { openssl = libressl; };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Editing NixOS Manuals - Nix/Nixpkgs - ShellSession\nDESCRIPTION: This ShellSession snippet provides a workflow for checking and building edits to the NixOS manual using nix-build. To use it, navigate to the nixpkgs directory, edit manual sources, and run the nix-build command. The result will be a built manual in HTML format found at ./result/share/doc/nixos/index.html. Dependencies include a checked-out Nixpkgs repository and Nix installed on the system. The primary parameters are the build target architecture (e.g., x86_64-linux) and the path to manual sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/contributing-to-this-manual.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ cd /path/to/nixpkgs\\n$ $EDITOR doc/nixos/manual/... # edit the manual\\n$ nix-build nixos/release.nix -A manual.x86_64-linux\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Torch with CMake for C++ Project - CMake\nDESCRIPTION: This snippet sets up a CMake project for compiling a C++ executable that depends on the Torch library. It declares a minimum CMake version (3.0), searches for the required Torch package, propagates necessary compiler flags, defines the output executable, and ensures appropriate linkage with Torch libraries. Dependencies: Torch C++ distribution and CMake 3.0+. Key parameters: 'test.cpp' (source file), 'TORCH_CXX_FLAGS' (compiler flags), and 'TORCH_LIBRARIES' (link libraries).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/science/math/libtorch/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0)\nfind_package(Torch REQUIRED)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${TORCH_CXX_FLAGS}\")\nadd_executable(test test.cpp)\ntarget_link_libraries(test \"${TORCH_LIBRARIES}\")\n```\n\n----------------------------------------\n\nTITLE: Using sparseCheckout Option with fetchgit in mkDerivation - Nix\nDESCRIPTION: This example demonstrates how to restrict the fetched contents of a Git repository using the sparseCheckout attribute of fetchgit within a stdenv.mkDerivation call. Requires stdenv and fetchgit. sparseCheckout is set to a list of relative directory paths, resulting in only those directories being fetched. A valid Git URL and hash must be provided. Outputs a derivation (here named 'hello') with limited contents, reducing download size and build time. Only works with git repositories supporting sparse checkout.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchgit }:\n\nstdenv.mkDerivation {\n  name = \"hello\";\n  src = fetchgit {\n    url = \"https://...\";\n    sparseCheckout = [\n      \"directory/to/be/included\"\n      \"another/directory\"\n    ];\n    hash = \"sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Python Packages to Test Script\nDESCRIPTION: Example of adding external Python packages to the test environment\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  extraPythonPackages = p: [ p.numpy ];\n\n  nodes = { };\n\n  # Type checking on extra packages doesn't work yet\n  skipTypeCheck = true;\n\n  testScript = ''\n    import numpy as np\n    assert str(np.zeros(4)) == \"[0. 0. 0. 0.]\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Coq Package Set in NixOS\nDESCRIPTION: Shows how to create a Coq package set using the 'mkCoqPackages' function with a specified Coq derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nmkCoqPackages coq\n```\n\n----------------------------------------\n\nTITLE: Querying Basic Systemd Status\nDESCRIPTION: Shows how to check the status of active systemd units using the systemctl command without arguments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/service-mgmt.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ systemctl\n-.mount          loaded active mounted   /\nswapfile.swap    loaded active active    /swapfile\nsshd.service     loaded active running   SSH Daemon\ngraphical.target loaded active active    Graphical Interface\n...\n```\n\n----------------------------------------\n\nTITLE: Concatenating Files with concatScript in Nix\nDESCRIPTION: This example shows how to use concatScript to concatenate multiple files into a single executable script in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\nconcatScript\n  \"my-file\"\n  [\n    file1\n    file2\n  ]\n```\n\n----------------------------------------\n\nTITLE: Creating an Executable Script with writeTextFile in Nix\nDESCRIPTION: This example demonstrates how to use writeTextFile to create an executable script in the Nix store, including a checkPhase and additional metadata.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nwriteTextFile {\n  name = \"my-cool-script\";\n  text = ''\n    #!/bin/sh\n    echo \"This is my cool script!\"\n  '';\n  executable = true;\n  destination = \"/some/subpath/my-cool-script\";\n  checkPhase = ''\n    ${pkgs.shellcheck}/bin/shellcheck $out/some/subpath/my-cool-script\n  '';\n  meta = {\n    license = pkgs.lib.licenses.cc0;\n  };\n  allowSubstitutes = true;\n  preferLocalBuild = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing Unfree Packages in Nixpkgs (Nix - nix)\nDESCRIPTION: Configures Nixpkgs to allow installation and use of packages that do not have a free software license. This setting is vital for users who need unfree drivers or software. Dependency: NixOS configuration attribute set including nixpkgs.config. Input: Boolean value to enable unfree package support. Output: Nixpkgs will not refuse evaluation of unfree packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config.allowUnfree = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Using nix-shell as Shebang in Ruby Script\nDESCRIPTION: Demonstrates how to use nix-shell as a shebang in a Ruby script to specify dependencies. This allows for self-contained scripts with all required dependencies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n#! /usr/bin/env nix-shell\n#! nix-shell -i ruby -p \"ruby.withPackages (ps: with ps; [ nokogiri rest-client ])\"\n\nrequire 'nokogiri'\nrequire 'rest-client'\n\nbody = RestClient.get('http://example.com').body\nputs Nokogiri::HTML(body).at('h1').text\n```\n\n----------------------------------------\n\nTITLE: Automatic Update Script Configuration in Nix\nDESCRIPTION: Examples of different ways to configure automatic package updates using the updateScript attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, writeScript }:\nstdenv.mkDerivation {\n  # ...\n  passthru.updateScript = writeScript \"update-zoom-us\" ''\n    #!/usr/bin/env nix-shell\n    #!nix-shell -i bash -p curl pcre2 common-updater-scripts\n\n    set -eu -o pipefail\n\n    version=\"$(curl -sI https://zoom.us/client/latest/zoom_x86_64.tar.xz | grep -Fi 'Location:' | pcre2grep -o1 '/(([0-9]\\.?)+)/')\"\n    update-source-version zoom-us \"$version\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Sections with Markdown Include Directives (Markdown)\nDESCRIPTION: This snippet uses a Markdown comment block with the {=include=} directive to pull content from multiple section files into the current documentation chapter. Each file listed (e.g., citrix.section.md, nginx.section.md) represents a distinct documentation section for a package or a topic maintained separately. Dependencies: The snippet assumes a documentation processing system (such as Pandoc) that recognizes and processes the special include block syntax. Input: List of documented section file paths, Output: Aggregated documentation composed of all included files in processing. Major limitation: Inclusion relies on the build system's correct interpretation of {=include=} blocks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/index.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} sections\ncitrix.section.md\ndarwin-builder.section.md\ndlib.section.md\neclipse.section.md\nelm.section.md\nemacs.section.md\nfirefox.section.md\nfish.section.md\nfuse.section.md\ngeant4.section.md\nibus.section.md\ninkscape.section.md\nkakoune.section.md\nkrita.section.md\nlinux.section.md\nlhapdf.section.md\nlocales.section.md\netc-files.section.md\nnginx.section.md\nopengl.section.md\nshell-helpers.section.md\npython-tree-sitter.section.md\nsteam.section.md\ncataclysm-dda.section.md\nurxvt.section.md\nvcpkg.section.md\nweechat.section.md\nxorg.section.md\nbuild-support.md\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring services.github-runner ServiceOverrides - Nix\nDESCRIPTION: This NixOS configuration example sets the SupplementaryGroups for the github-runner service, using the new services.github-runner.serviceOverrides option. The attribute is set as a list containing the 'docker' group, enabling the github-runner service to access Docker. This replaces previous overriding via systemd.services.github-runner.serviceConfig. Requires NixOS with github-runner service enabled. Inputs include the attribute set defining serviceOverrides, outputs are custom service configuration within systemd.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.github-runner.serviceOverrides.SupplementaryGroups = [\n    \"docker\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Plugin Override for Vim Plugin Dependencies\nDESCRIPTION: Example showing how to create an override for a Vim plugin that requires dependencies. This demonstrates adding dependencies to the deoplete-fish plugin.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/vim.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  deoplete-fish = super.deoplete-fish.overrideAttrs (old: {\n    dependencies = with super; [\n      deoplete-nvim\n      vim-fish\n    ];\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Building Cross Binutils with Nix - Nix Expression - nix\nDESCRIPTION: Defines a Nix expression to build cross-compilation binutils for the arm-linux platform targeting i686-linux using stdenv.mkDerivation. It fetches the binutils source, passes cross-compilation configuration flags (e.g., --target), and inherits a noSysDirs flag. Dependencies include fetchurl, stdenv, and noSysDirs. Inputs include target architecture and source tarball; output is a ready-to-use cross-binutils for arm-linux. Limited to binutils 2.16.1 and expects builder.sh to be available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/old/cross.txt#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{stdenv, fetchurl, noSysDirs}:\n\nstdenv.mkDerivation {\n  name = \"binutils-2.16.1-arm\";\n  builder = ./builder.sh;\n  src = fetchurl {\n    url = \"http://ftp.nluug.nl/gnu/binutils/binutils-2.16.1.tar.bz2\";\n    hash = \"sha256-14pv+YKrL3NyFwbnv9MoWsZHgEZk5+pHhuZtAfkcVsU=\";\n  };\n  inherit noSysDirs;\n  configureFlags = [ \"--target=arm-linux\" ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Allowing Specific Unfree Packages via Name Predicate - Nix - nix\nDESCRIPTION: Configures `allowUnfreePredicate` as a function to permit only unfree packages whose names are present in the list (\"roon-server\", \"vscode\"). Requires access to builtins and `lib.getName`. Only matching package names are allowed to install; others remain blocked.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  allowUnfreePredicate =\n    pkg:\n    builtins.elem (lib.getName pkg) [\n      \"roon-server\"\n      \"vscode\"\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Vulkan ICD Filename via Environment Variable in Shell (ShellSession)\nDESCRIPTION: Demonstrates exporting the VK_ICD_FILENAMES environment variable to specify one or more JSON ICD driver files for Vulkan, using output from nix-build for the amdvlk package. Input is the path to the Vulkan ICD file; output is that Vulkan applications will use the specified driver.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ export \\\n  VK_ICD_FILENAMES=`nix-build '<nixpkgs>' --no-out-link -A amdvlk`/share/vulkan/icd.d/amd_icd64.json\n```\n\n----------------------------------------\n\nTITLE: Compact Docker Image Configuration with lib.getExe\nDESCRIPTION: Shows a more compact way to create a Docker image using lib.getExe to reference the hello executable directly in the config.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dockerTools,\n  hello,\n  lib,\n}:\ndockerTools.streamLayeredImage {\n  name = \"hello\";\n  tag = \"latest\";\n  config.Cmd = [ \"${lib.getExe hello}\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Resholve into Existing Builds with phraseSolution\nDESCRIPTION: Example of using resholve.phraseSolution to integrate resholve into a standard stdenv.mkDerivation build. This technique allows for resolving shell script dependencies within a more complex build process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/misc/resholve/README.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, resholve, module1 }:\n\nstdenv.mkDerivation {\n  # pname = \"testmod3\";\n  # version = \"unreleased\";\n  # src = ...;\n\n  installPhase = ''\n    mkdir -p $out/bin\n    install conjure.sh $out/bin/conjure.sh\n    ${resholve.phraseSolution \"conjure\" {\n      scripts = [ \"bin/conjure.sh\" ];\n      interpreter = \"${bash}/bin/bash\";\n      inputs = [ module1 ];\n      fake = {\n        external = [ \"jq\" \"openssl\" ];\n      };\n    }}\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing a Local Unlisted Agda Library - Nix - nix\nDESCRIPTION: Shows how to add a custom, locally-developed Agda library not present in Nixpkgs by calling agdaPackages.mkDerivation inside agda.withPackages. Key attributes are pname, version, and src (local path), and the package is included in Agda's environment. Inputs include a function p (agdaPackages) and the mkDerivation attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nagda.withPackages (p: [\n  (p.mkDerivation {\n    pname = \"your-agda-lib\";\n    version = \"1.0.0\";\n    src = /path/to/your-agda-lib;\n  })\n])\n```\n\n----------------------------------------\n\nTITLE: Viewing Current Kernel Configuration in Linux\nDESCRIPTION: Shell command to display the configuration of the currently running kernel by reading the compressed config file from /proc.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nzcat /proc/config.gz\n```\n\n----------------------------------------\n\nTITLE: Including Modular Documentation Sections - Markdown\nDESCRIPTION: This snippet uses the Markdown {=include=} directive to modularly include additional documentation sections for NixOS container management. It allows the main file to reference other markdown files such as 'imperative-containers.section.md', 'declarative-containers.section.md', and 'container-networking.section.md', ensuring content reuse and structured organization. This approach requires a Markdown processor that supports the {=include=} directive.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/containers.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\\nimperative-containers.section.md\\ndeclarative-containers.section.md\\ncontainer-networking.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Patches to Haskell Packages\nDESCRIPTION: A function to add patches to a Haskell package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\nappendPatches list drv\n```\n\n----------------------------------------\n\nTITLE: Viewing Active systemd Control Groups - ShellSession\nDESCRIPTION: This ShellSession snippet shows the output of the 'systemd-cgls' command, used to display the process hierarchy by control group in a running systemd environment. It helps administrators inspect which services and users are assigned to which cgroups, aiding in system resource troubleshooting and management. The output tree illustrates how systemd assigns processes to user and service cgroups, useful for visually verifying cgroup organization.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/control-groups.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ systemd-cgls\\n├─user\\n│ └─eelco\\n│   └─c1\\n│     ├─ 2567 -:0\\n│     ├─ 2682 kdeinit4: kdeinit4 Running...\\n│     ├─ ...\\n│     └─10851 sh -c less -R\\n└─system\\n  ├─httpd.service\\n  │ ├─2444 httpd -f /nix/store/3pyacby5cpr55a03qwbnndizpciwq161-httpd.conf -DNO_DETACH\\n  │ └─...\\n  ├─dhcpcd.service\\n  │ └─2376 dhcpcd --config /nix/store/f8dif8dsi2yaa70n03xir8r653776ka6-dhcpcd.conf\\n  └─ ...\n```\n\n----------------------------------------\n\nTITLE: Remove Compiler References Example (Nix)\nDESCRIPTION: Example showing how to remove references to the compiler in build output using remove-references-to\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_32\n\nLANGUAGE: nix\nCODE:\n```\n{\n  postInstall = ''\n    find \"$out\" -type f -exec remove-references-to -t ${stdenv.cc} '{}' +\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Test Script Polling Condition\nDESCRIPTION: Examples of using polling_condition decorator for continuous state checking\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@polling_condition\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n\n\nmachine.succeed(\"foo --start\")\nmachine.wait_until_succeeds(\"pgrep -x foo\")\n\nwith foo_running:\n    ...  # Put `foo` through its paces\n```\n\nLANGUAGE: python\nCODE:\n```\n@polling_condition(seconds_interval=10)\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n```\n\nLANGUAGE: python\nCODE:\n```\n@polling_condition\ndef foo_running():\n    \"check that foo is running\"\n    machine.succeed(\"pgrep -x foo\")\n```\n\nLANGUAGE: python\nCODE:\n```\n@polling_condition(description=\"check that foo is running\")\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Text File in a Subdirectory with writeTextDir in Nix\nDESCRIPTION: This example demonstrates how to use writeTextDir to create a text file within a subdirectory of the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\nwriteTextDir \"share/my-file\" ''\n  Contents of File\n''\n```\n\n----------------------------------------\n\nTITLE: Generating Pleroma Configuration with pleroma_ctl\nDESCRIPTION: Commands to create an initial Pleroma configuration using the pleroma_ctl utility in a temporary nix-shell environment. This generates both the main config file and PostgreSQL setup script.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/networking/pleroma.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir tmp-pleroma\n$ cd tmp-pleroma\n$ nix-shell -p pleroma-otp\n$ pleroma_ctl instance gen --output config.exs --output-psql setup.psql\n```\n\n----------------------------------------\n\nTITLE: Extension Path Generation Example - Nix\nDESCRIPTION: Demonstrates the correct path structure for VSCode extensions using the marketplace reference publisher and name in lowercase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/vscode/extensions/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n${lib.strings.toLower mktplcRef.publisher}.${lib.string.toLower mktplcRef.name}\n```\n\n----------------------------------------\n\nTITLE: Configuring SDKs and Cross-Compilation with mkDerivation (Nix)\nDESCRIPTION: This example illustrates advanced usage of mkDerivation to direct different compiler and build phases to use distinct macOS SDK versions for complex cross-compilation scenarios on Darwin. It assigns specific SDKs to build (depsBuildBuild), host (buildInputs), and propagated (depsTargetTargetPropagated) roles, ensuring each toolchain phase uses the correct macOS version. Required dependencies include multiple apple-sdk_X packages and the set-up of stdenv with cross-compilation-aware attributes. Inputs are the various build and SDK assignments; output is a derivation with SDKs attached to corresponding toolchain roles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  # ...\n  depsBuildBuild = [ buildPackages.stdenv.cc ];\n  nativeBuildInputs = [ apple-sdk_12 ];\n  buildInputs = [ apple-sdk_13 ];\n  depsTargetTargetPropagated = [ apple-sdk_14 ];\n}\n# The build-build `clang` will use the 12.3 SDK while the package build itself will use the 13.3 SDK.\n# Derivations that add this package as an input will have the 14.4 SDK propagated to them.\n```\n\n----------------------------------------\n\nTITLE: Updating Stackage Nightly Resolver in Nixpkgs\nDESCRIPTION: This command updates the Stackage Nightly resolver used by Nixpkgs and creates a commit. It's part of the initial haskell-updates PR process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/update-stackage.sh --do-commit\n```\n\n----------------------------------------\n\nTITLE: Updating nix-fallback-paths\nDESCRIPTION: Command to fetch and update the fallback paths file for a specific Nix version from the official releases server\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/tools/package-management/nix/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncurl https://releases.nixos.org/nix/nix-$version/fallback-paths.nix > nixos/modules/installer/tools/nix-fallback-paths.nix\n```\n\n----------------------------------------\n\nTITLE: Setting Trusted Users in nix.conf - Nix - Configuration Snippet\nDESCRIPTION: Specifies trusted users for the Nix installation via the nix.conf file. Required for launching the darwin.linux-builder remote builder on macOS, this grants privileged access for the specified users. Replace the placeholder with your actual username. This setting is needed prior to using remote builders and is non-functional without appropriate user privileges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nextra-trusted-users = <your username goes here>\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Prelude Globally for All Dhall Packages\nDESCRIPTION: Nix expression showing how to override the default Prelude package globally for all Dhall packages. This approach makes a specific version of the Prelude available to all packages in the overlay.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  dhallOverrides = self: super: {\n    true = self.callPackage ./true.nix { };\n\n    Prelude = self.callPackage ./Prelude.nix { };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running NixOS Test with runNixOSTest\nDESCRIPTION: Demonstrates how to use runNixOSTest to execute a simple NixOS test that verifies the hello package installation and execution.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\npkgs.testers.runNixOSTest (\n  { lib, ... }:\n  {\n    name = \"hello\";\n    nodes.machine =\n      { pkgs, ... }:\n      {\n        environment.systemPackages = [ pkgs.hello ];\n      };\n    testScript = ''\n      machine.succeed(\"hello\")\n    '';\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Container IP Address in NixOS\nDESCRIPTION: This snippet demonstrates how to obtain the IPv4 address of a NixOS container named 'foo' and ping it to verify connectivity.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/container-networking.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container show-ip foo\n10.233.4.2\n\n$ ping -c1 10.233.4.2\n64 bytes from 10.233.4.2: icmp_seq=1 ttl=64 time=0.106 ms\n```\n\n----------------------------------------\n\nTITLE: Setting Default Nixpkgs Expressions for nix-env with Symlink in ShellSession\nDESCRIPTION: This snippet links a custom Nixpkgs source directory into '~/.nix-defexpr/nixpkgs', making 'nix-env' default to using custom expressions. It requires that the source directory exists and appropriate file system permissions are set. The input is the path to custom sources, and the result is that 'nix-env' and tools referencing '~/.nix-defexpr' resolve to user-supplied Nixpkgs definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ ln -s /my/sources/nixpkgs ~/.nix-defexpr/nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Exploring Java Packages with nix repl\nDESCRIPTION: Shows how to use nix repl to explore available Java compiler variants and packages in javaPackages. Demonstrates tab completion functionality for package discovery.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ nix repl '<nixpkgs>' -I nixpkgs=channel:nixpkgs-unstable\nnix-repl> javaPackages.<tab>\njavaPackages.compiler               javaPackages.openjfx15              javaPackages.openjfx21              javaPackages.recurseForDerivations\njavaPackages.jogl_2_4_0             javaPackages.openjfx17              javaPackages.openjfx22\njavaPackages.mavenfod               javaPackages.openjfx19              javaPackages.override\njavaPackages.openjfx11              javaPackages.openjfx20              javaPackages.overrideDerivation\n```\n\n----------------------------------------\n\nTITLE: Migrating from overridePackages to Overlays in Nixpkgs (Nix)\nDESCRIPTION: This snippet demonstrates the deprecated method of using `overridePackages` to customize packages in Nixpkgs prior to the 17.03 release. It shows creating a customized package set by passing an overrides function to `pkgs.overridePackages`. Inputs are a self/super override function; outputs are the adjusted package set. This approach is now obsolete and should be replaced as per next snippet.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1703.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkgs = import <nixpkgs> {};\nin\n  pkgs.overridePackages (self: super: { /* ... */ })\n```\n\n----------------------------------------\n\nTITLE: Setting Memory Limits for a systemd Service - NixOS Configuration - nix\nDESCRIPTION: This NixOS configuration snippet demonstrates how to set a memory usage cap for a systemd-managed service, specifically restricting 'httpd.service' to 512 MiB of RAM. The 'MemoryLimit' field excludes swap, preventing the specified service from consuming more than the set limit. To take effect, this should be placed within 'configuration.nix' under the relevant 'systemd.services' attribute; the limit string must follow systemd's recognized format (e.g., 'M' for mebibytes).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/control-groups.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\\n  systemd.services.httpd.serviceConfig.MemoryLimit = \\\"512M\\\";\\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Variables in Multiple Files using substituteAllFiles in Nix\nDESCRIPTION: Shows how to use substituteAllFiles in a Nix expression to perform batch substitutions of @hello@ in multiple specified files within a directory. The function takes a src directory, a list of target files, and a set of variable bindings. Outputs only the processed files; unlisted files in the directory are excluded from the result. Dependencies: substituteAllFiles and all specified Nix variables. Only files listed in the files attribute are processed and output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/build-support.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{ substituteAllFiles }:\nsubstituteAllFiles {\n  src = ./.;\n  files = [\n    \"foo.txt\"\n    \"bar.txt\"\n  ];\n  hello = \"there\";\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Nix Store with Deduplication (Shell - ShellSession)\nDESCRIPTION: This command runs the Nix store optimizer, replacing identical files in the store with hard links to reduce disk usage (sometimes by as much as 40%). The process reads the entire Nix store and may take considerable time, especially on large stores. No parameters are needed, but sufficient permissions and free disk space are required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/cleaning-store.chapter.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ nix-store --optimise\\n```\n```\n\n----------------------------------------\n\nTITLE: Using an Added Package in a Custom Docker Container Environment - Shell\nDESCRIPTION: This snippet shows running a shell inside the generated Docker image and using a newly available package (cowsay) to verify its presence. The container should already be built with cowsay as per the Nix configuration. Input is a shell command in the running container and the output is the ASCII art result from cowsay.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_40\n\nLANGUAGE: shell\nCODE:\n```\n$ docker container run -it hello-2.12.1-env:latest\n[nix-shell:~]$ cowsay \"Hello, world!\"\n _______________\n< Hello, world! >\n ---------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\n\n----------------------------------------\n\nTITLE: Creating an Executable Script with writeScript in Nix\nDESCRIPTION: This example shows how to use writeScript to create an executable script file in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_13\n\nLANGUAGE: nix\nCODE:\n```\nwriteScript \"my-file\" ''\n  Contents of File\n''\n```\n\n----------------------------------------\n\nTITLE: Patch Collection for Schroot System Utility\nDESCRIPTION: A comprehensive set of patch files addressing functionality improvements and bug fixes for schroot 1.6.13-5. Includes fixes for copyfiles operations, mount points, translations, and configuration issues.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sc/schroot/debian-patches.txt#_snippet_0\n\nLANGUAGE: patch\nCODE:\n```\nschroot/1.6.13-5\n1539621689.revert.schroot-1.6.10-48-g2600bcab.revert-environment-preserve-empty-values.patch\n1448890714.schroot-1.7.2-72-gbf30a928.setup-d-20copyfiles-canonicalize-destination-path.patch\n1453505583.schroot-1.7.2-72-g11587fd8.etc-setup-d-20copyfiles-replace-dangling-symlink-during-cp.patch\n1496783678.schroot-1.7.2-127-ga5e5d8d9.fix-bash-completion.patch\n1530433671.schroot-1.7.2-129-g00c0a972.cmake-use-soelim-r-option.patch\n1487872945.schroot-1.7.2-137-g5c36362b.support-copyfiles-installation-into-non-existent-directories.patch\n1487872999.schroot-1.7.2-138-g5a611c49.support-copyfiles-source-destination-specifications.patch\n1662655911.reschroot-1.6.13-2-g779349dc.replace-usage-of-egrep-and-which.patch\n1662656169.reschroot-1.6.13-3-ga9e100e5.clean-up-mess-created-in-the-portuguese-translations.patch\n1664011392.reschroot-1.6.13-4-g93017cff.update-french-translation.patch\n1665995770.reschroot-1.6.13-5-g81b88b45.document-a-login-shell-might-be-switched-to-a-regular-shell.patch\n1692468301.reschroot-1.6.13-6-g271acf6e.subject-mount-a-new-instance-of-dev-pts-in-the-chroot.patch\n1664222056.reschroot-1.6.13-9-g55af32cf.fix-localename-type.patch\n1658716738.reschroot-1.6.12-2-g2045008e.fix-variable-usage-in-copyfiles-copy-file-function.patch\nfix-dupes-in-buildd-configuration.patch\nfix-example-configuration.patch\n```\n\n----------------------------------------\n\nTITLE: Declaring Typed 1D and Nested Lists - Nix Language\nDESCRIPTION: Demonstrates list creation in Nix with mixed types and nesting. The 1D list includes integers and strings, illustrating type heterogeneity. The 2D list contains both flat and nested elements, showing how composite types and recursion can be handled. No dependencies or parameters; values are directly assigned.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nlist1d=(1, \"mixed!\", 5, 2);list2d=(1, (1, 1.2, \"foo\"), (\"bar\", 1.2, 1));\n```\n\n----------------------------------------\n\nTITLE: Extracting an AppImage to install extra files in Nix\nDESCRIPTION: This example demonstrates how to extract files from an AppImage using appimageTools.extract and then install them in the final package. It extracts desktop files and icons from the IRCCloud AppImage and installs them in the appropriate locations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/appimagetools.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ appimageTools, fetchurl }:\nlet\n  pname = \"irccloud\";\n  version = \"0.16.0\";\n\n  src = fetchurl {\n    url = \"https://github.com/irccloud/irccloud-desktop/releases/download/v${version}/IRCCloud-${version}-linux-x86_64.AppImage\";\n    hash = \"sha256-/hMPvYdnVB1XjKgU2v47HnVvW4+uC3rhRjbucqin4iI=\";\n  };\n\n  appimageContents = appimageTools.extract {\n    inherit pname version src;\n  };\nin\nappimageTools.wrapType2 {\n  inherit pname version src;\n\n  extraPkgs = pkgs: [ pkgs.at-spi2-core ];\n\n  extraInstallCommands = ''\n    mv $out/bin/${pname}-${version} $out/bin/${pname}\n    install -m 444 -D ${appimageContents}/irccloud.desktop $out/share/applications/irccloud.desktop\n    install -m 444 -D ${appimageContents}/usr/share/icons/hicolor/512x512/apps/irccloud.png \\\n      $out/share/icons/hicolor/512x512/apps/irccloud.png\n    substituteInPlace $out/share/applications/irccloud.desktop \\\n      --replace-fail 'Exec=AppRun' 'Exec=${pname}'\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Mounting an ISO Image Using Loop Device - ShellSession\nDESCRIPTION: This command mounts a built NixOS ISO image to a target directory using a loop device and the iso9660 filesystem. It requires root privileges and the \\'mount\\' utility to be available on the system. The key parameters are the ISO file path and the target mount directory; upon execution, the ISO contents become accessible at the specified mount point. The command must be adapted if the ISO path or mount directory differ.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-nixos.chapter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# mount -o loop -t iso9660 ./result/iso/nixos-image-25.05pre-git-x86_64-linux.iso /mnt/iso\n```\n\n----------------------------------------\n\nTITLE: Disabling Parallel Building for Haskell Packages\nDESCRIPTION: A function to disable parallel building for a Haskell package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_34\n\nLANGUAGE: nix\nCODE:\n```\ndisableParallelBuilding drv\n```\n\n----------------------------------------\n\nTITLE: Building a Specific systemd Unit with nix-build - ShellSession\nDESCRIPTION: This snippet demonstrates how to build a specific systemd unit from the NixOS configuration, taking into account that unit names frequently contain dots, requiring the attribute path to be quoted. The command outputs the built unit to the result symlink. Input includes the quoted attribute path for the desired unit, and output is the built unit file. Prerequisite: configured systemd and an existing Nix derivation for the unit.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/building-parts.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build -A 'config.systemd.units.\"httpd.service\".unit'\n```\n\n----------------------------------------\n\nTITLE: Registering Multimedia Key Remapping in NixOS (Nix)\nDESCRIPTION: Augments the NixOS X server configuration to install a new media key layout, specifying descriptions, language, and pointing both symbolsFile and keycodesFile to the relevant files. Requires that these files are present at the given paths. Inputs: attribute set; output: system layout is updated upon rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.xkb.extraLayouts.media = {\n    description  = \"Multimedia keys remapping\";\n    languages    = [ \"eng\" ];\n    symbolsFile  = /path/to/media-key;\n    keycodesFile = /path/to/media-sym;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SSH to Connect to Non-Default Port - SSH Config\nDESCRIPTION: Defines a Host block in SSH configuration to allow connecting to the linux-builder instance on a custom port (default 31022). Sets the Hostname, HostKeyAlias, and port. This is necessary if the builder runs on a non-standard SSH port, and the file should be placed at /etc/ssh/ssh_config.d/100-linux-builder.conf.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nHost linux-builder\n  Hostname localhost\n  HostKeyAlias linux-builder\n  Port 31022\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Adobe Flash and Unfree Packages for Firefox/Chromium (Nix - nix)\nDESCRIPTION: Enables installation of unfree packages and Adobe Flash plugin for Firefox and Chromium within NixOS. Prerequisite is an attribute set within nixpkgs.config. Input: Boolean switches for allowUnfree, firefox.enableAdobeFlash, and chromium.enableAdobeFlash. Output: Flash support is enabled for both browsers if requested.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1404.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config.allowUnfree = true;\n  nixpkgs.config.firefox.enableAdobeFlash = true; # for Firefox\n  nixpkgs.config.chromium.enableAdobeFlash = true; # for Chromium\n}\n```\n\n----------------------------------------\n\nTITLE: Example Package Version Format for Unstable Commits\nDESCRIPTION: Demonstrates the correct version format for packages built from repository commits without assigned versions. The version should start with the latest upstream version, followed by -unstable- and the commit date.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n\"2.2-unstable-2022-03-15\"\n```\n\n----------------------------------------\n\nTITLE: Calling Agda with Library and Include Flags - Shell - shell\nDESCRIPTION: Demonstrates running Agda with the -l flag to specify the standard-library and the -i flag to add the current directory to the include path when typechecking a file. This command should be run in a shell with Agda installed and expects MyFile.agda to exist in the current directory. The output will be standard Agda typechecking results or compilation errors.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ agda -l standard-library -i . MyFile.agda\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Intersection Operation on File Sets (Nix)\nDESCRIPTION: This Nix snippet demonstrates the intersection operation between two file sets, './.' and './foo'. It is used to discuss expected behavior regarding overlapping directories and preservation of directories or files. The example serves a conceptual purpose in fileset interface discussions and helps to clarify how intersection semantics map to directory and file inclusion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_2\n\nLANGUAGE: Nix\nCODE:\n```\n\"intersection ./. ./foo\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Individual Kubernetes Components - NixOS Module - Nix\nDESCRIPTION: Enables individual Kubernetes services (apiserver, controllerManager, scheduler, addonManager, proxy, flannel) by explicitly setting their respective options to true in the NixOS configuration. Requires the NixOS Kubernetes module to be available. The input represents a Nix attribute set for the 'services.kubernetes' options. After activation, the node will run the enabled services, but other cluster-wide options or parameters may still require configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/kubernetes.chapter.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.kubernetes = {\n    apiserver.enable = true;\n    controllerManager.enable = true;\n    scheduler.enable = true;\n    addonManager.enable = true;\n    proxy.enable = true;\n    flannel.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Nix Expression Result\nDESCRIPTION: The result of evaluating the previous Nix expression, showing that the passthru attribute can be accessed directly from the derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/passthru.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n4\n```\n\n----------------------------------------\n\nTITLE: Configuring Icon Theme Dependencies in Nixpkgs - Nix\nDESCRIPTION: This snippet demonstrates how to configure a Nix derivation to include a specific icon theme as a build input and adjust environment variables for wrapped GNOME applications. The buildInputs attribute ensures the Pantheon elementary icon theme is available. The preFixup hook appends a prefix to the XDG_DATA_DIRS variable utilizing the XDG_ICON_DIRS, ensuring that the wrapped application will locate the required icons during runtime. This approach is specific to Nixpkgs, and assumes the presence of gappsWrapperArgs and wrapped binaries via default Nix GNOME packaging infrastructure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gnome.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    pantheon.elementary-icon-theme\n  ];\n  preFixup = ''\n    gappsWrapperArgs+=(\n      # The icon theme is hardcoded.\n      --prefix XDG_DATA_DIRS : \"$XDG_ICON_DIRS\"\n    )\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Maven Artifact URL Structure Example\nDESCRIPTION: Examples of Maven repository URL patterns for both regular and snapshot artifacts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/tools/build-managers/gradle/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nhttps://repo.maven.apache.org/maven2/org/slf4j/slf4j-api/2.0.9/slf4j-api-2.0.9.pom\nhttps://oss.sonatype.org/content/groups/public/com/tobiasdiez/easybind/2.2.1-SNAPSHOT/easybind-2.2.1-20230117.075740-16.pom\n```\n\n----------------------------------------\n\nTITLE: Creating Development Shells for Elixir Projects Using Nix mkShell - Nix Language\nDESCRIPTION: This snippet offers a basic shell.nix example for entering a Nix shell preconfigured with a particular Elixir version for development purposes. It demonstrates using mkShell with custom buildInputs, specifically selecting a BEAM interpreter and Elixir runtime. No additional shell hooks or overlays are used, making it suitable for lightweight local development and testing. Prerequisites are the availability of Nixpkgs with Elixir/BEAM support, and the primary output is an interactive development environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/beam.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\nwith pkgs;\nlet\n  elixir = beam.packages.erlang_27.elixir_1_18;\nin\nmkShell {\n  buildInputs = [ elixir ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Bash Script with writeShellScript in Nix\nDESCRIPTION: This example shows how to use writeShellScript to create a Bash script with a proper shebang in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\nwriteShellScript \"my-script\" ''\n  echo \"hi\"\n''\n```\n\n----------------------------------------\n\nTITLE: Complete Nix Expression for Building Web App Frontend\nDESCRIPTION: A comprehensive Nix expression that builds a web application frontend using Bower components and Gulp. It demonstrates how to integrate buildBowerComponents, set up the build environment, and execute the build process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/bower.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  myWebApp ? {\n    outPath = ./.;\n    name = \"myWebApp\";\n  },\n  pkgs ? import <nixpkgs> { },\n}:\n\npkgs.stdenv.mkDerivation {\n  name = \"my-web-app-frontend\";\n  src = myWebApp;\n\n  buildInputs = [ pkgs.nodePackages.gulp ];\n\n  bowerComponents = pkgs.buildBowerComponents {\n    # note 1\n    name = \"my-web-app\";\n    generated = ./bower-packages.nix;\n    src = myWebApp;\n  };\n\n  nativeBuildInputs = [\n    writableTmpDirAsHomeHook # note 3\n  ];\n\n  buildPhase = ''\n    runHook preBuild\n\n    cp --reflink=auto --no-preserve=mode -R $bowerComponents/bower_components . # note 2\n    ${pkgs.nodePackages.gulp}/bin/gulp build # note 4\n\n    runHook postBuild\n  '';\n\n  installPhase = \"mv gulpdist $out\";\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Build Flags for Haskell Packages\nDESCRIPTION: A function to append build flags to the Haskell package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_27\n\nLANGUAGE: nix\nCODE:\n```\nappendBuildFlags list drv\n```\n\n----------------------------------------\n\nTITLE: Example Error Message for Duplicate Unique Option - Plain Text\nDESCRIPTION: This is a plain text error message shown by nixos-rebuild when two modules define the same unique option. It demonstrates what users see when attempting to merge unmergeable values for options that cannot be concatenated (e.g., string-type options). Dependencies: N/A. Input: Occurs during collision; Output: Standard error text.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_3\n\nLANGUAGE: plain\nCODE:\n```\nThe unique option `services.httpd.adminAddr' is defined multiple times, in `/etc/nixos/httpd.nix' and `/etc/nixos/configuration.nix'.\n```\n\n----------------------------------------\n\nTITLE: Configuring Non-Interactive SSHFS Mount in NixOS\nDESCRIPTION: NixOS configuration for setting up a non-interactive SSHFS mount. This includes filesystem and SSH options for reliable and secure mounting.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/sshfs-file-systems.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fileSystems.\"/mnt/my-dir\" = {\n    device = \"my-user@example.com:/my-dir/\";\n    fsType = \"sshfs\";\n    options =\n      [ # Filesystem options\n        \"allow_other\"          # for non-root access\n        \"_netdev\"              # this is a network fs\n        \"x-systemd.automount\"  # mount on demand\n\n        # SSH options\n        \"reconnect\"              # handle connection drops\n        \"ServerAliveInterval=15\" # keep connections alive\n        \"IdentityFile=/var/secrets/example-key\"\n      ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Inline Package Test Implementation in Nix\nDESCRIPTION: Example of implementing a simple inline test for a Go package using yq-go. The test verifies JSON output formatting.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{ /* ... , */ yq-go }:\n\nbuildGoModule rec {\n  # …\n\n  passthru.tests = {\n    simple = runCommand \"${pname}-test\" {} ''\n      echo \"test: 1\" | ${yq-go}/bin/yq eval -j > $out\n      [ \"$(cat $out | tr -d $'\\n ')\" = '{\"test\":1}' ]\n    '';\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Legacy Bitmap Fonts to NixOS Fonts Configuration - Nix\nDESCRIPTION: This snippet illustrates how to explicitly include legacy Xorg bitmap fonts in the NixOS 'fonts.fonts' option array, following their removal from the default set when both X11 and unfree software are enabled. It shows how to add the desired font packages from the 'pkgs.xorg' attribute set, ensuring compatibility with older workflows. Prerequisites include access to the pkgs.xorg namespace in configuration expressions. Inputs are font package attribute names; outputs are system-wide availability of the specified bitmap fonts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  fonts.fonts = [\n    pkgs.xorg.fontbhlucidatypewriter100dpi\n    pkgs.xorg.fontbhlucidatypewriter75dpi\n    pkgs.xorg.fontbh100dpi\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JWE Secret with TPM2 Policy using Clevis (Shell)\nDESCRIPTION: This shell command uses the clevis tool to encrypt the string \"hi\" using a TPM2-backed policy, outputting the result as a JWE file. Requires Clevis and a compatible TPM2 device on the system. The command pins decryption such that it only succeeds if the TPM2 device fulfills the required policy. The input secret comes from standard input and the resulting JWE file can be used for further device decryption. No additional parameters beyond a basic JSON object are required for this minimal example.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/clevis.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\necho -n hi | clevis encrypt tpm2 '{}' > hi.jwe\n```\n\n----------------------------------------\n\nTITLE: Testing File Creation with Shell Script in Bash\nDESCRIPTION: This shell script snippet creates an empty file named 'test' in the current directory using the 'touch' command. It demonstrates basic file system interaction, requiring Bash or any POSIX-compliant shell as a dependency. The main parameter is the filename, and the script outputs no data, simply verifying that the file can be created without error.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/xc/xc/example.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ntouch ./test\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal NixOS Configuration File Function - Nix - nix\nDESCRIPTION: Defines the basic template of a NixOS configuration file as a function accepting at least 'config' and 'pkgs' arguments, returning a set of option definitions. This skeleton provides the necessary structure for all NixOS configurations. Dependencies: The Nix language and understanding of NixOS module system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ /* option definitions */\n}\n```\n\n----------------------------------------\n\nTITLE: User Login to a NixOS Container - ShellSession\nDESCRIPTION: Demonstrates logging into the 'foo' container as a non-root user (e.g., 'alice') with password authentication. The login operation is available to all host users, and provides a regular login prompt. Useful for shell access without root privileges.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container login foo\nfoo login: alice\nPassword: ***\n```\n\n----------------------------------------\n\nTITLE: Dynamically Skipping Large Groups of Go Tests in Nix - Nix\nDESCRIPTION: Shows a Nix pattern for programmatically skipping multiple Go tests by defining a list of test names to be skipped. The `skippedTests` list is concatenated into a regular expression, which is then passed as the argument to the `-skip` flag through the `checkFlags` attribute. This method is suitable for skipping many tests efficiently, such as integration or network-dependent tests. Inputs are the list of test patterns, and the output is a `checkFlags` list that disables targeted tests during build. Requires access to builtins for string operations. Limitations are those imposed by Go's test selection and regular expression parsing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/go.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  checkFlags =\n    let\n      # Skip tests that require network access\n      skippedTests = [\n        \"TestNetwork\"\n        \"TestDatabase/with_mysql\" # exclude only the subtest\n        \"TestIntegration\"\n      ];\n    in\n    [ \"-skip=^${builtins.concatStringsSep \"$|^\" skippedTests}$\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding nix-shell Invocation in Perl Script Shebang - Perl\nDESCRIPTION: This Perl script snippet embeds a nix-shell invocation directly in the shebang to automatically launch the right Nix environment when the script is executed. Requires Nix and nix-shell to be available. The key parameters are language ('perl') and packages ('perl', 'perlPackages.DBFile'). Inputs are none beyond the script file. Outputs are the execution of the Perl script with dependencies resolved ad-hoc through Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/perl.section.md#_snippet_3\n\nLANGUAGE: perl\nCODE:\n```\n#!/usr/bin/env nix-shell\n#! nix-shell -i perl -p perl perlPackages.DBFile\n```\n\n----------------------------------------\n\nTITLE: Overriding Python Package Set to Pin Django Version - NixOS Nix\nDESCRIPTION: This Nix expression demonstrates how to override the default python3 package set within a Nix/NixOS environment to pin the 'django' attribute to use the legacy 'django_3' derivation for compatibility. It uses an override function to inject custom package overrides, ensuring that applications relying on the 'django' alias do not unintentionally upgrade to Django v4.x. Requires a working nixpkgs and understanding of Nix overlays. Inputs are not explicitly parameterized; the main output is a modified python3 attribute set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  python = python3.override {\n    packageOverrides = self: super: {\n      django = super.django_3;\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Kernel Configuration in NixOS\nDESCRIPTION: Example showing how to modify kernel configuration to enable KGDB support using the packageOverrides feature in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/linux-kernel.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nixpkgs.config.packageOverrides = pkgs: pkgs.lib.recursiveUpdate pkgs {\n    linuxKernel.kernels.linux_5_10 = pkgs.linuxKernel.kernels.linux_5_10.override {\n      extraConfig = ''\n        KGDB y\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning 'node' Role to Node - NixOS Kubernetes Module - Nix\nDESCRIPTION: Configures a node as a Kubernetes worker by assigning the 'node' role in the 'services.kubernetes.roles' list. This setup automatically enables the kubelet and kube-proxy services required for node participation in the cluster. Dependencies are the presence of the NixOS Kubernetes module. Intended for scalable, multi-node clusters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/kubernetes.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.kubernetes.roles = [ \"node\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Submodule Option by Reference (Nix)\nDESCRIPTION: Shows how to define a submodule option by referencing an external 'modOptions' attribute set. This pattern is useful for reusing or sharing option schemas across multiple modules. Dependencies include 'mkOption', 'types', and the submodule schema in 'modOptions'. The resulting option 'mod' expects an attribute set matching the schema.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  modOptions = {\n    options = {\n      foo = mkOption {\n        type = int;\n      };\n      bar = mkOption {\n        type = int;\n      };\n    };\n  };\nin\n{\n  options.mod = mkOption {\n    description = \"submodule example\";\n    type = with types; submodule modOptions;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Chicken Egg Scope to Use Local Sources - Nix\nDESCRIPTION: This Nix code snippet exemplifies how to override the CHICKEN egg attribute set to use a local source for a particular egg, specifically srfi-180. It uses overrideScope on both chickenPackages and chickenEggs to inject a custom local source for srfi-180, affecting all downstream eggs that depend on it (e.g., json-rpc). Prerequisites are familiarity with Nix's overlay/override mechanisms and access to the appropriate local sources. Inputs and outputs are Nix attribute sets representing the modified egg collection.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/chicken.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  myChickenPackages = pkgs.chickenPackages.overrideScope (\n    self: super: {\n      # The chicken package itself can be overridden to effect the whole ecosystem.\n      # chicken = super.chicken.overrideAttrs {\n      #   src = ...\n      # };\n\n      chickenEggs = super.chickenEggs.overrideScope (\n        eggself: eggsuper: {\n          srfi-180 = eggsuper.srfi-180.overrideAttrs {\n            # path to a local copy of srfi-180\n            src = <...>;\n          };\n        }\n      );\n    }\n  );\nin\n# Here, `myChickenPackages.chickenEggs.json-rpc`, which depends on `srfi-180` will use\n# the local copy of `srfi-180`.\n<...>\n```\n\n----------------------------------------\n\nTITLE: Building and Loading a Docker Image with Custom shellHook - Shell\nDESCRIPTION: This shell transcript details building a Nix-based Docker image with a custom shellHook and loading it into Docker. It is similar to the standard build/load flow, but intended to showcase the image customization using shellHook. The process remains dependent on nix-build for build generation and a working Docker setup for image loading.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_42\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-build\n(some output removed for clarity)\n/nix/store/iz4dhdvgzazl5vrgyz719iwjzjy6xlx1-stream-hello-2.12.1-env\n\n$ /nix/store/iz4dhdvgzazl5vrgyz719iwjzjy6xlx1-stream-hello-2.12.1-env | docker image load\n(some output removed for clarity)\nLoaded image: hello-2.12.1-env:latest\n```\n\n----------------------------------------\n\nTITLE: Defining a Shell Application with Runtime Dependencies - writeShellApplication - Nix\nDESCRIPTION: This Nix expression demonstrates constructing an executable shell application using writeShellApplication. It assigns a name, lists runtime inputs (curl and w3m), and defines the text of a shell pipeline. The snippet requires the listed packages (curl and w3m) to be available in the Nix store, and outputs a shell application that fetches content from nixos.org and prints it as plain text. Additional derivation arguments and environment variables can be passed if needed. The resulting binary is placed in the user profile or shell path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\nwriteShellApplication {\n  name = \"show-nixos-org\";\n\n  runtimeInputs = [\n    curl\n    w3m\n  ];\n\n  text = ''\n    curl -s 'https://nixos.org' | w3m -dump -T text/html\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Switching to Specialised Configuration in NixOS\nDESCRIPTION: These shell commands demonstrate how to switch to a specialised configuration at runtime, comparing the old and new methods.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_13\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo /run/current-system/specialisation/example-sub-configuration/bin/switch-to-configuration test\n```\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo /run/current-system/fine-tune/child-1/bin/switch-to-configuration test\n```\n\n----------------------------------------\n\nTITLE: Legacy Dovecot2 Mailboxes List Configuration - Nix\nDESCRIPTION: This snippet shows the deprecated configuration style for specifying Dovecot2 mailboxes as a list of attribute sets. It would be placed under the 'services.dovecot2.mailboxes' option in the NixOS config. Each list element is a mailbox definition with parameters like 'name' and 'auto'. Upgrading to attribute set format is recommended to avoid evaluation breakage in future Nixpkgs releases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.dovecot2.mailboxes = [\n    { name = \"Junk\";\n      auto = \"create\";\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Restarting the Nix Daemon on macOS - ShellSession\nDESCRIPTION: Shows the launchctl command needed on macOS to restart the Nix daemon, crucial after making SSH or builder configuration changes. Requires sudo privileges. Ensures the new SSH configuration is applied system-wide.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/darwin-builder.section.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ sudo launchctl kickstart -k system/org.nixos.nix-daemon\n\n```\n\n----------------------------------------\n\nTITLE: Creating Nix Shell Environment with Bundler Gems\nDESCRIPTION: Shows how to create a Nix shell environment using bundlerEnv to manage gems from a Gemfile. This approach is useful for projects with existing Gemfiles.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n# ...\nlet\n  gems = bundlerEnv {\n    name = \"gems-for-some-project\";\n    gemdir = ./.;\n  };\nin\nmkShell {\n  packages = [\n    gems\n    gems.wrappedRuby\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Apache HTTP Server with Nested Sets - NixOS - nix\nDESCRIPTION: Shows an alternative way to enable and configure the Apache HTTP Server using nested set notation. This style groups related configuration under hierarchy, making it easier to manage many settings. Requires: 'config' and 'pkgs' arguments, NixOS module system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\n{ services = {\n    httpd = {\n      enable = true;\n      adminAddr = \"alice@example.org\";\n      virtualHosts = {\n        localhost = {\n          documentRoot = \"/webroot\";\n        };\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SSH Support in gpg-agent.conf - Conf\nDESCRIPTION: This configuration line enables SSH agent emulation in gpg-agent. It should be added to the user's `~/.gnupg/gpg-agent.conf` file. Required for utilizing gpg-agent as a drop-in replacement for ssh-agent. Users must manually add their SSH keys via `ssh-add` after enabling this.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_7\n\nLANGUAGE: conf\nCODE:\n```\nenable-ssh-support\n```\n\n----------------------------------------\n\nTITLE: Enabling installCheck Phase in Nix Derivation - Nix\nDESCRIPTION: Enables the installCheck phase by setting the attribute 'doInstallCheck' to true within a derivation. The installCheck phase runs after installation and typically executes the 'make installcheck' target to verify installation correctness. Requires that install checks are supported on the current platform (cross-compilation disables this feature); input is the attribute set and output is that installCheck will be executed if supported.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_30\n\nLANGUAGE: nix\nCODE:\n```\n{\n  doInstallCheck = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Node.js package generation script in Shell\nDESCRIPTION: Command to run the script that generates Node.js packages in nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./pkgs/development/node-packages/generate.sh\n```\n\n----------------------------------------\n\nTITLE: Adding Elementary AppCenter Flatpak Repository\nDESCRIPTION: Shell command to add the elementary AppCenter Flatpak repository to enable installation of applications through AppCenter.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ flatpak remote-add --if-not-exists appcenter https://flatpak.elementary.io/repo.flatpakrepo\n```\n\n----------------------------------------\n\nTITLE: Creating JWE Secret with Shamir Secret Sharing using Clevis (Shell)\nDESCRIPTION: This multi-line shell command uses Clevis to create a JWE file employing Shamir's Secret Sharing (SSS). The secret \"hi\" is encrypted so that two policies (TPM2 and Tang) are combined: at least two \"pins\" must be satisfied for decryption, as set by \"t: 2\". Requires Clevis, a TPM2 device, and a Tang server reachable at the specified URL. The \"pcr_ids\" parameter identifies TPM PCRs to use. This configuration helps build robust decryption policies involving multiple factors. The output file enables composite unattended decryption scenarios.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/clevis.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\necho -n hi | clevis encrypt sss \\\n'{\"t\": 2, \"pins\": {\"tpm2\": {\"pcr_ids\": \"0\"}, \"tang\": {\"url\": \"http://tang.local\"}}}' \\\n> hi.jwe\n```\n\n----------------------------------------\n\nTITLE: Allowing Builtin FetchGit for Dependencies - buildRustPackage - Nix\nDESCRIPTION: Enables `allowBuiltinFetchGit` in the `cargoLock` attribute to avoid manually specifying `outputHashes` when building outside of nixpkgs. This setting modifies dependency resolution behavior, making it more convenient for private or experimental projects. The environment must support built-in fetchers for git repositories.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  pname = \"myproject\";\n  version = \"1.0.0\";\n\n  cargoLock = {\n    lockFile = ./Cargo.lock;\n    allowBuiltinFetchGit = true;\n  };\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring stripExclude for Directory Path Patterns - Nix\nDESCRIPTION: Prevents files within specified directory paths ('lib/modules/*/build/*') from being stripped in the build phase. This is done by setting 'stripExclude' to a list of glob patterns within a derivation. Standard Nix derivation definitions are assumed; supply patterns relevant to files which should retain debug symbols.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  # ...\n  stripExclude = [ \"lib/modules/*/build/*\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NAT for Container Network Access in NixOS\nDESCRIPTION: This configuration enables Network Address Translation (NAT) on the host to allow containers to access the external network. It sets up NAT rules for all container interfaces and specifies the external interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/container-networking.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.nat.enable = true;\n  networking.nat.internalInterfaces = [\"ve-+\"];\n  networking.nat.externalInterface = \"eth0\";\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Tap-to-Click on Touchpads - Nix\nDESCRIPTION: Configures the touchpad driver to disable tapping by setting services.libinput.touchpad.tapping to false. Option relies on libinput support and valid touchpad hardware. Other touchpad options can be set similarly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.libinput.touchpad.tapping = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Docker Image from Local Path - Nix\nDESCRIPTION: This expression exports a Docker image from a local tarball path (e.g., `./image.tar.gz`) using `dockerTools.exportImage`, specifying the `name` attribute which is mandatory when `fromImage` is a path. Dependencies include only `dockerTools`. The output is a tar archive named as specified, built from the given local file, and suitable for later import.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools }:\ndockerTools.exportImage {\n  name = \"filesystem.tar\";\n  fromImage = ./image.tar.gz;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Regenerating CHICKEN Egg Package Set with egg2nix - Bash\nDESCRIPTION: This shell snippet illustrates the process for updating the CHICKEN eggs package set in Nixpkgs using egg2nix. It requires installing egg2nix through Nix, navigating to the appropriate directory, and running egg2nix to generate a new eggs.nix file from eggs.scm. Key prerequisites include working Nix and chickenPackages.egg2nix. The command assumes the user is maintaining CHICKEN eggs in the specified path and that eggs.scm lists all required eggs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/chicken.section.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-shell -p chickenPackages.egg2nix\n$ cd pkgs/development/compilers/chicken/5/\n$ egg2nix eggs.scm > eggs.nix\n```\n\n----------------------------------------\n\nTITLE: Creating New Branch for Major Qt Version Updates - Git\nDESCRIPTION: This git command creates a new branch (nixpkgs/$major) from an existing patched branch (nixpkgs/$oldmajor) for a different major version, forming the basis for rebasing patches. Prerequisites: local repository fork and both old and new major versions existing as branches/tags. Parameters: target branch and base branch names. Output is a new local branch set up for applying new patches. Constraint: Assumes proper structure and existence of upstream branches.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/qt-5/README.md#_snippet_3\n\nLANGUAGE: git\nCODE:\n```\ngit checkout -b nixpkgs/$major nixpkgs/$oldmajor\n```\n\n----------------------------------------\n\nTITLE: Debugging Infinite Module Loops - nixos-rebuild with Trace - ShellSession\nDESCRIPTION: Demonstrates how to invoke nixos-rebuild with the '--show-trace' flag to display a stack trace if an infinite recursion or module argument evaluation loop is encountered. Requires a broken (recursive) module to actually trigger the output. Input: broken NixOS module; Output: error message with evaluation trace, useful for debugging complex module interactions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_5\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nixos-rebuild build --show-trace\n…\nwhile evaluating the module argument `pkgs' in \"/etc/nixos/my-module.nix\":\ninfinite recursion encountered\n```\n\n----------------------------------------\n\nTITLE: Incorrect Hash After URL Change with fetchurl (Nix Language)\nDESCRIPTION: Demonstrates a common mistake: updating the fetchurl's url parameter without updating the hash, resulting in an incorrect or stale output. After changing the version in the url, the hash from the previous version is incorrectly retained, which causes Nix to reuse a cached store object and not fetch the updated content. Always update the hash parameter when the source url changes. If the hash is forgotten, the build may silently succeed with out-of-date content.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  url = \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\";\n  hash = \"sha256-ZHl1emidXVojm83LCVrwULpwIzKE/mYwfztVkvpruOM=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Proprietary NVIDIA Graphics Driver - Nix\nDESCRIPTION: Sets up the X server to use the proprietary NVIDIA driver by including \"nvidia\" in the services.xserver.videoDrivers list. Essential for best 3D performance on compatible NVIDIA cards. Requires the NVIDIA driver package and reboot for activation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.videoDrivers = [ \"nvidia\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Broken Packages\nDESCRIPTION: Commands for generating Hydra report and marking broken Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/hydra-report.hs get-report\n$ ./maintainers/scripts/haskell/hydra-report.hs mark-broken-list\n$ ./maintainers/scripts/haskell/mark-broken.sh --do-commit\n```\n\n----------------------------------------\n\nTITLE: Intel Driver with TearFree for Old GPUs - Nix\nDESCRIPTION: Specifies usage of the 'intel' video driver along with custom deviceSection options to enable DRI 2 and the TearFree feature. Helpful for mitigating screen tearing on old Intel iGPUs. Service and driver must support these options; may reduce performance versus default.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.videoDrivers = [ \"intel\" ];\n    services.xserver.deviceSection = ''\n    Option \"DRI\" \"2\"\n    Option \"TearFree\" \"true\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Running Chromium NixOS VM Tests\nDESCRIPTION: Command for running all automated NixOS VM tests for Chromium variants. This helps verify that updates to Chromium, ungoogled-chromium, and Google Chrome work correctly in a NixOS environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/browsers/chromium/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnix-build nixos/tests/chromium.nix\n```\n\n----------------------------------------\n\nTITLE: Including Preface in NixOS Manual\nDESCRIPTION: Defines the preface section of the NixOS manual by including the preface.md file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/manual.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} preface\npreface.md\n```\n```\n\n----------------------------------------\n\nTITLE: Running Games with Steam-run\nDESCRIPTION: Command to run Linux games in the FHS-compatible chroot environment using steam-run.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/steam.section.md#_snippet_2\n\nLANGUAGE: shellsession\nCODE:\n```\nsteam-run ./foo\n```\n\n----------------------------------------\n\nTITLE: Using importNpmLock with custom fetcherOpts for npm Dependency Fetching - Nix\nDESCRIPTION: This snippet extends the prior example by demonstrating how to pass custom fetcher options using the fetcherOpts attribute for selective dependencies in importNpmLock. It specifically demonstrates passing curlOptsList to pkgs.fetchurl for the axios package. This allows granular control over how dependencies are retrieved, making it suitable for complex or restrictive networking environments. Dependencies include buildNpmPackage and importNpmLock, and inputs are project source and configuration options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{ buildNpmPackage, importNpmLock }:\n\nbuildNpmPackage {\n  pname = \"hello\";\n  version = \"0.1.0\";\n  src = ./.;\n\n  npmDeps = importNpmLock {\n    npmRoot = ./.;\n    fetcherOpts = {\n      # Pass 'curlOptsList' to 'pkgs.fetchurl' while fetching 'axios'\n      \"node_modules/axios\" = {\n        curlOptsList = [ \"--verbose\" ];\n      };\n    };\n  };\n\n  npmConfigHook = importNpmLock.npmConfigHook;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apache httpd 2.2 in NixOS 14.12\nDESCRIPTION: Configuration snippet to continue using Apache httpd 2.2 in NixOS 14.12, where httpd 2.4 has become the default. This overrides the default package with the older version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1412.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.httpd.package = pkgs.apacheHttpd_2_2;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Benchmark Execution for Haskell Packages\nDESCRIPTION: Functions to enable or disable benchmark execution for Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_30\n\nLANGUAGE: nix\nCODE:\n```\ndoBenchmark drv\ndontBenchmark drv\n```\n\n----------------------------------------\n\nTITLE: Generating Initial NixOS Configuration Files\nDESCRIPTION: Command to create the initial NixOS configuration files. This generates a basic configuration.nix and hardware-configuration.nix based on the current system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing.chapter.md#_snippet_17\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-generate-config --root /mnt\n```\n\n----------------------------------------\n\nTITLE: Configuring Clevis-Backed Device Decryption at Boot (Nix)\nDESCRIPTION: This Nix configuration specifies a device (here, /dev/nvme0n1p1) to be decrypted at boot using a pre-generated Clevis JWE secret file. Requires the Clevis module to be enabled, a JWE file (e.g., nvme0n1p1.jwe), and that the device is one of the supported encrypted types (bcachefs, zfs, luks). The \"secretFile\" attribute provides the path to the JWE file. If decryption policies are not met, fallback to interactive unlocking occurs. Useful for automating the unlocking of disks with complex boot-time policies.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/clevis.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.initrd.clevis.devices.\"/dev/nvme0n1p1\".secretFile = ./nvme0n1p1.jwe;\n}\n```\n\n----------------------------------------\n\nTITLE: Emitting Warnings with NixOS Module System - Nix\nDESCRIPTION: This NixOS module snippet emits a warning if the 'bar' feature of the 'foo' service is enabled. It uses the NixOS module system's 'warnings' mechanism and the 'lib.mkIf' utility to conditionally include the warning in the module configuration. To use this, ensure the 'lib' library is available, and the respective service options ('services.foo.enable' and 'services.foo.bar') are defined in the configuration. The warning is presented when both 'foo' and its 'bar' feature are enabled, helping to inform users of potential issues without interrupting the build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/assertions.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, ... }:\n{\n  config = lib.mkIf config.services.foo.enable {\n    warnings =\n      if config.services.foo.bar\n      then [ ''You have enabled the bar feature of the foo service.\n               This is known to cause some specific problems in certain situations.\n               '' ]\n      else [];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Assembler Error from Enabling PIC with Incompatible Code (Assembler Output)\nDESCRIPTION: This assembler output snippet demonstrates a typical error when the PIC ('-fPIC') hardening flag is activated but the code being built (such as kernel modules or bare-metal programs) does not support it. The snippet shows a missing or invalid displacement error, which implies that disabling the PIC flag is necessary for successful compilation of such code. It requires usage of GCC/Clang with the assembler and inputs that are not PIC-compatible; the output is an assembler error message.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_45\n\nLANGUAGE: text\nCODE:\n```\nccbLfRgg.s: Assembler messages:\\nccbLfRgg.s:33: Error: missing or invalid displacement expression `private_key_len@GOTOFF'\n```\n\n----------------------------------------\n\nTITLE: Configuring CUDA SAXPY Project with CMake\nDESCRIPTION: This CMake script sets up a CUDA-enabled SAXPY project. It requires CMake 3.25 or higher, finds the CUDA toolkit with required components (cudart and cublas), and configures the build with specific compiler options for the CUDA language. The script also defines installation targets.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/saxpy/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.25)\nproject(saxpy LANGUAGES CXX CUDA)\n\nfind_package(CUDAToolkit REQUIRED COMPONENTS cudart cublas)\n\nadd_executable(saxpy saxpy.cu)\ntarget_link_libraries(saxpy PUBLIC CUDA::cublas CUDA::cudart m)\ntarget_compile_features(saxpy PRIVATE cxx_std_14)\ntarget_compile_options(saxpy PRIVATE $<$<COMPILE_LANGUAGE:CUDA>:\n                                     --expt-relaxed-constexpr>)\n\ninstall(TARGETS saxpy)\n```\n\n----------------------------------------\n\nTITLE: Specifying User Authorized SSH Keys - NixOS - Nix\nDESCRIPTION: This snippet declaratively sets authorized SSH public keys for a specific user ('alice') in the NixOS configuration. Using 'users.users.<username>.openssh.authorizedKeys.keys', administrators can provide an array of public keys that grant SSH access. Dependencies include the NixOS user and OpenSSH modules. The key parameter is the list of key strings; when the configuration is built, these are written to the user's '~/.ssh/authorized_keys'. No keys are added by default; all keys must be specified explicitly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/ssh.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.alice.openssh.authorizedKeys.keys =\n    [ \"ssh-ed25519 AAAAB3NzaC1kc3MAAACBAPIkGWVEt4...\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Running the WordPress Package Regeneration Script in Shell\nDESCRIPTION: This snippet demonstrates how to regenerate the wordpressPackages set in Nixpkgs by executing the generate.sh shell script. It is intended to be run from the repository root after editing the necessary JSON files, and ensures that package definitions are updated before committing changes. The script does not require parameters and outputs updated package lists; usage assumes that shell is available and executable permissions are set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/web-apps/wordpress/packages/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./generate.sh\n```\n\n----------------------------------------\n\nTITLE: Manually Starting Display Manager - ShellSession\nDESCRIPTION: This ShellSession snippet shows how to manually start the NixOS graphical display manager using systemctl. Use after disabling X autorun. Command must be run as root or with appropriate system permissions. Starts the default graphical login service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n# systemctl start display-manager.service\n```\n\n----------------------------------------\n\nTITLE: Complete NixOS Package Environment with GNU Info Support\nDESCRIPTION: Full configuration including GNU info support with post-build setup for info documentation database generation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: {\n    myProfile = pkgs.writeText \"my-profile\" ''\n      export PATH=$HOME/.nix-profile/bin:/nix/var/nix/profiles/default/bin:/sbin:/bin:/usr/sbin:/usr/bin\n      export MANPATH=$HOME/.nix-profile/share/man:/nix/var/nix/profiles/default/share/man:/usr/share/man\n      export INFOPATH=$HOME/.nix-profile/share/info:/nix/var/nix/profiles/default/share/info:/usr/share/info\n    '';\n    myPackages = pkgs.buildEnv {\n      name = \"my-packages\";\n      paths = with pkgs; [\n        (runCommand \"profile\" { } ''\n          mkdir -p $out/etc/profile.d\n          cp ${myProfile} $out/etc/profile.d/my-profile.sh\n        '')\n        aspell\n        bc\n        coreutils\n        ffmpeg\n        man\n        nix\n        emscripten\n        jq\n        nox\n        silver-searcher\n        texinfoInteractive\n      ];\n      pathsToLink = [\n        \"/share/man\"\n        \"/share/doc\"\n        \"/share/info\"\n        \"/bin\"\n        \"/etc\"\n      ];\n      extraOutputsToInstall = [\n        \"man\"\n        \"doc\"\n        \"info\"\n      ];\n      postBuild = ''\n        if [ -x $out/bin/install-info -a -w $out/share/info ]; then\n          shopt -s nullglob\n          for i in $out/share/info/*.info $out/share/info/*.info.gz; do\n              $out/bin/install-info $i $out/share/info/dir\n          done\n        fi\n      '';\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading from Multiple URLs with fetchurl - Nix Language\nDESCRIPTION: This snippet extends 'fetchurl' usage in Nix to accept multiple possible URLs via the 'urls' attribute. It retries URLs in order, using the first URL that succeeds, and verifies the fetched content with a hash. Required parameters are 'urls' (a list of candidate download URLs) and 'hash'. This pattern ensures more robust fetching where mirrors or fallback sources exist.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  urls = [\n    \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/does-not-exist\"\n    \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\"\n  ];\n  hash = \"sha256-BZqI7r0MNP29yGH5+yW2tjU9OOpOCEvwWKrWCv5CQ0I=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying SQL Tests for Reproducibility in WAL2JSON\nDESCRIPTION: Outlines the changes made to the original wal2json SQL test files to ensure reproducible output. These modifications include redirecting LSN output, replacing dynamic timestamps, and adjusting test execution parameters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/tests/postgresql/wal2json/README.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\n\\o /dev/null\n```\n\nLANGUAGE: SQL\nCODE:\n```\n'2023-01-01 00:00:00'::timestamp\n```\n\n----------------------------------------\n\nTITLE: Android Repository Update Script Execution\nDESCRIPTION: Command to update the generated expressions for Android SDK components by running the update script in the androidenv directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n./update.sh\n```\n\n----------------------------------------\n\nTITLE: Running lib.path Property Tests with Bash Script - Bash\nDESCRIPTION: Provides the command to execute the 'lib.path' property-based tests using 'path/tests/prop.sh'. This script runs tests for the 'lib.path' sub-library, and may require setups or fixtures located in the 'path/tests' directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\npath/tests/prop.sh\n```\n\n----------------------------------------\n\nTITLE: Declaring SOCKS Proxy Instances with NixOS Services (Nix)\nDESCRIPTION: This snippet shows how to configure the `services.nylon` module in a NixOS configuration prior to the 17.03 release, where proxy parameters are set at the top-level attribute. It is meant for users migrating SOCKS proxy declarations and demonstrates the typical assignment of `enable`, `acceptInterface`, `bindInterface`, and `port`. Inputs are attribute names and values; outputs are configuration state. Key parameter limitations include legacy compatibility; the form is no longer the recommended practice post-17.03.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1703.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nylon = {\n    enable = true;\n    acceptInterface = \"br0\";\n    bindInterface = \"tun1\";\n    port = 5912;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: GitHub Authentication Check\nDESCRIPTION: Commands for authenticating and verifying GitHub CLI authentication status.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ gh auth login\n```\n\nLANGUAGE: console\nCODE:\n```\n$ gh auth status\n```\n\n----------------------------------------\n\nTITLE: Searching Documents in Meilisearch Index via curl - bash\nDESCRIPTION: This bash command queries the 'movies' index in Meilisearch by sending a POST request to the '/indexes/movies/search' endpoint with a search string ('botman') designed to showcase typo tolerance. The command uses curl with JSON data and requires the Meilisearch instance running locally. The output will contain search results matched by Meilisearch, demonstrating its fuzzy matching capabilities.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/search/meilisearch.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl 'http://127.0.0.1:7700/indexes/movies/search' --data '{ \"q\": \"botman\" }'\n```\n\n----------------------------------------\n\nTITLE: Migrating IPFS data directory in NixOS 17.09\nDESCRIPTION: Shell commands to manually migrate IPFS data from the old default location to a custom data directory specified in the configuration. This is needed because the ipfs service no longer ignores the dataDir option.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1709.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\ndataDir=<valueOfDataDir>\nmv /var/lib/ipfs/.ipfs/* $dataDir\nrmdir /var/lib/ipfs/.ipfs\n```\n\n----------------------------------------\n\nTITLE: Fetching External Patches with fetchpatch\nDESCRIPTION: How to fetch patches from external sources using fetchpatch to minimize maintenance burden and repository size. Suitable for patches already merged upstream or published elsewhere.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  patches = [\n    (fetchpatch {\n      name = \"fix-check-for-using-shared-freetype-lib.patch\";\n      url = \"http://git.ghostscript.com/?p=ghostpdl.git;a=patch;h=8f5d285\";\n      hash = \"sha256-uRcxaCjd+WAuGrXOmGfFeu79cUILwkRdBu48mwcBE7g=\";\n    })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding nixos-rebuild-ng to systemPackages with Nix - Nix\nDESCRIPTION: This snippet demonstrates how to include nixos-rebuild-ng as an additional package in the NixOS system by extending the environment.systemPackages list in your configuration.nix file. It requires the NixOS module system and access to a pkgs argument, and should be inserted in the system's Nix expression. The pkgs.nixos-rebuild-ng attribute ensures the package is available to all users. No other configuration changes are required. Inputs: pkgs attribute set. Outputs: nixos-rebuild-ng installed system-wide.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-rebuild-ng/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\n{\n  environment.systemPackages = [ pkgs.nixos-rebuild-ng ];\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Command in a NixOS Container - ShellSession\nDESCRIPTION: Executes an arbitrary command ('uname -a') inside the 'foo' container via 'nixos-container run'. Useful for diagnostics or one-off tasks. The syntax routes extra arguments after the container name directly into the target environment. Outputs the command result as seen from within the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/imperative-containers.section.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-container run foo -- uname -a\nLinux foo 3.4.82 #1-NixOS SMP Thu Mar 20 14:44:05 UTC 2014 x86_64 GNU/Linux\n```\n\n----------------------------------------\n\nTITLE: Building Hare Program Derivations with hareHook in Nix\nDESCRIPTION: This Nix expression demonstrates how to set up a package to build Hare programs using the hareHook package within the Nixpkgs build infrastructure. It specifies adding hareHook to nativeBuildInputs and configures standard derivation properties like pname, version, and src. The meta section inherits platform information from hareHook. Dependencies include hareHook, lib, and stdenv. The placeholders <name>, <version>, <src>, and <description> should be replaced with package-specific information. The generated derivation can be built by Nix, invoking the underlying Hare toolchain with appropriate environment variables automatically configured.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/hare.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hareHook,\n  lib,\n  stdenv,\n}:\nstdenv.mkDerivation {\n  pname = \"<name>\";\n  version = \"<version>\";\n  src = \"<src>\";\n\n  nativeBuildInputs = [ hareHook ];\n\n  meta = {\n    description = \"<description>\";\n    inherit (hareHook) badPlatforms platforms;\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Complete HOCON Configuration Example with Various Data Structures\nDESCRIPTION: A comprehensive HOCON configuration example showing various data structures including 2D arrays, attribute sets with special characters, nested objects, escaped strings, numeric values, and file includes. Demonstrates different HOCON syntax features including string quoting, escaping, nested objects, and inclusion mechanisms.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/hocon/test/comprehensive/expected.txt#_snippet_0\n\nLANGUAGE: hocon\nCODE:\n```\n{\n  \"array2d\" = [\n    [\n      1,\n      2,\n      \"a\"\n    ],\n    [\n      2,\n      1,\n      \"b\"\n    ]\n  ]\n  \"cursed \\\" .attrs \\\" \" = {\n    \"a\" = 1\n    \"a b\" = ${?a}\n    \"a b c\" = ${?a b}\n  }\n  \"misc attrs\" = {\n    \"x\" = 1\n    \"y\" += {\n      \"a\" = 1\n    }\n  }\n  \"nasty_string\" = \"\\\"@\\n\\\\\\t^*bf\\n0\\\";'''$\"\n  \"nested\" = {\n    \"attrset\" = {\n      \"has\" = {\n        \"a\" = {\n          \"integer\" = {\n            \"value\" = 100\n          }\n        }\n      }\n    }\n  }\n  \"simple_top_level_attr\" = \"1.0\"\n  \"some_floaty\" = 29.95\n  \"to_include\" = {\n    include \"/nix/store/ccnzr53dpipdacxgci3ii3bqacvb5hxm-hocon-test-include.conf\"\n    include \"https://example.com\"\n    include required(file(\"/nix/store/ccnzr53dpipdacxgci3ii3bqacvb5hxm-hocon-test-include.conf\"))\n    include \"/nix/store/ccnzr53dpipdacxgci3ii3bqacvb5hxm-hocon-test-include.conf\"\n    include url(\"https://example.com\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Base Directory for Anki Sync Server in NixOS\nDESCRIPTION: This snippet shows how to change the base directory where Anki Sync Server stores synced data.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/anki-sync-server.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.anki-sync-server.baseDirectory = \"/home/anki/data\";\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding NixOS System Using Modified Sources with nixos-rebuild in ShellSession\nDESCRIPTION: This snippet shows how to instruct 'nixos-rebuild' to use custom Nixpkgs sources by specifying the '-I' flag. Requires a path to the modified source tree and sufficient permissions (the command runs as root). The primary parameter is the custom path, and the output is that the system rebuilds with the provided source tree instead of the default channels.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/sources.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch -I nixpkgs=/my/sources/nixpkgs\n```\n\n----------------------------------------\n\nTITLE: Migrating Matrix Synapse Service Configuration to RFC42 Settings - Nix\nDESCRIPTION: This pair of snippets demonstrates the migration process for the Matrix Synapse service configuration in NixOS from the pre-22.05 structure to the new one compatible with RFC42. The 'Before' code block uses top-level options; the 'After' block nests most settings under 'services.matrix-synapse.settings' and adopts updated option names ('bind_addresses' replaces 'bind_address'). This change is required after upgrading to the new module version. Inputs include server_name, registration secrets, TLS certificates, and listeners. Outputs are updated and compatible NixOS configurations. It is crucial to migrate all custom settings appropriately for continued service operation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.matrix-synapse = {\n    enable = true;\n\n    server_name = \"example.com\";\n    public_baseurl = \"https://example.com:8448\";\n\n    enable_registration = false;\n    registration_shared_secret = \"xohshaeyui8jic7uutuDogahkee3aehuaf6ei3Xouz4iicie5thie6nohNahceut\";\n    macaroon_secret_key = \"xoo8eder9seivukaiPh1cheikohquuw8Yooreid0The4aifahth3Ou0aiShaiz4l\";\n\n    tls_certificate_path = \"/var/lib/acme/example.com/fullchain.pem\";\n    tls_certificate_path = \"/var/lib/acme/example.com/fullchain.pem\";\n\n    listeners = [ {\n      port = 8448;\n      bind_address = \"\";\n      type = \"http\";\n      tls = true;\n      resources = [ {\n        names = [ \"client\" ];\n        compress = true;\n      } {\n        names = [ \"federation\" ];\n        compress = false;\n      } ];\n    } ];\n\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing JWS Verification Error for ACME Accounts using lego - Shell\nDESCRIPTION: Outlines recovery steps to resolve 'JWS verification error' produced by lego when account credentials are corrupt. The commands search for and move the affected lego account directory, re-initialize it using systemd-tmpfiles, and restart the ACME systemd service to re-issue certificates. Dependencies include systemd, lego ACME client, and shell access as root. Inputs are the service and account directories; outputs are newly generated credentials and certificates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n# Find the accounts folder for the certificate\nsystemctl cat acme-example.com.service | grep -Po 'accounts/[^:]*'\nexport accountdir=\"$(!!)\"\n# Move this folder to some place else\nmv /var/lib/acme/.lego/$accountdir{,.bak}\n# Recreate the folder using systemd-tmpfiles\nsystemd-tmpfiles --create\n# Get a new account and reissue certificates\n# Note: Do this for all certs that share the same account email address\nsystemctl start acme-example.com.service\n```\n\n----------------------------------------\n\nTITLE: Assigning Custom Network Interface Names with systemd in NixOS (nix)\nDESCRIPTION: This snippet shows how to declare a custom network interface name based on the device's MAC address using systemd.network.links in a NixOS configuration. It assigns the name 'wan' to a specified physical interface. The configuration requires NixOS and uses the systemd module for network interface management. The expected input is a NixOS configuration block; the output is a renamed interface at boot time. Proper physical MAC address matching is necessary and uniqueness should be assured to avoid configuration conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/renaming-interfaces.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.network.links.\"10-wan\" = {\n    matchConfig.PermanentMACAddress = \"52:54:00:12:01:01\";\n    linkConfig.Name = \"wan\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Cargo.lock File for Dependencies - buildRustPackage - Nix\nDESCRIPTION: Illustrates how to use the `cargoLock` attribute in `buildRustPackage` to directly specify a `Cargo.lock` file, simplifying dependency management during packaging. The lockfile must be present at the provided path. The build will fetch dependencies declared in the lock; key parameters are the `lockFile` path. Outputs a derivation with locked dependency versions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nrustPlatform.buildRustPackage {\n  pname = \"myproject\";\n  version = \"1.0.0\";\n\n  cargoLock = {\n    lockFile = ./Cargo.lock;\n  };\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Torrent Files in Nix\nDESCRIPTION: Shows how to use the fetchtorrent function to download files via BitTorrent. This example demonstrates setting a custom configuration for the transmission client and specifying a magnet link as the URL.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchtorrent }:\n\nfetchtorrent {\n  config = {\n    peer-limit-global = 100;\n  };\n  url = \"magnet:?xt=urn:btih:dd8255ecdc7ca55fb0bbf81323d87062db1f6d1c\";\n  hash = \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling External Bootloader with Custom Install Hook (NixOS - Nix)\nDESCRIPTION: This Nix expression demonstrates how to enable an external bootloader in a NixOS configuration by setting the boot.loader.external.enable option to true and specifying a custom installHook. The installHook references the 'fooboot-install' binary from the 'fooboot' package path in the current package set. Required dependencies include access to the custom FooBoot package. The configuration expects the bootloader program to handle installation when provided with the NixOS system closure path. Input expects a NixOS module arguments set with at least 'pkgs' defined; outputs are side effects in system bootloader configuration. Limitations: This configuration assumes the user-provided installer will correctly handle all bootloader management steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/loader/external/external.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }: {\n  boot.loader.external = {\n    enable = true;\n    installHook = \"${pkgs.fooboot}/bin/fooboot-install\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Chapters with Markdown Directives - Markdown\nDESCRIPTION: This snippet uses extended Markdown include syntax with directive notation (\"{=include=}\") to programmatically embed external chapter files located within the 'stdenv' directory. Each line instructs the documentation toolchain to inline the respective chapter at this location, supporting modularity and maintainability of the overall documentation. Required dependencies include a documentation build tool or preprocessor that supports the '{=include=}' directive, and paths must be valid relative to this documentation file. No parameters are accepted; each line strictly points to a static Markdown file. The output is a fully assembled Markdown file ready for further processing or conversion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} chapters\nstdenv/stdenv.chapter.md\nstdenv/meta.chapter.md\nstdenv/passthru.chapter.md\nstdenv/multiple-output.chapter.md\nstdenv/cross-compilation.chapter.md\nstdenv/platform-notes.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Package File in Bash\nDESCRIPTION: Commands to create and add a new package.nix file to the Nixpkgs repository.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ emacs pkgs/by-name/so/some-package/package.nix\n$ git add pkgs/by-name/so/some-package/package.nix\n```\n\n----------------------------------------\n\nTITLE: Creating a Subversion Repository - Command Line (Shell)\nDESCRIPTION: This shell command initializes a new Subversion repository named REPO_NAME in the specified parent directory. Requires the subversion package to be installed and appropriate permissions to write in the repository parent. Key parameter: REPO_NAME is the name of the repository directory to be created. Expected output: Directory structure for a new SVN repository.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ svn create REPO_NAME\n```\n\n----------------------------------------\n\nTITLE: Checking Maintainer Pings Between Revisions\nDESCRIPTION: Example of using get-maintainer-pings-between.sh to check which maintainers would be pinged between two Nixpkgs revisions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/scripts/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmaintainers/scripts/get-maintainer-pings-between.sh HEAD^ HEAD\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic GNOME Wrapping for Qt Application Build (Nix)\nDESCRIPTION: Illustrates a workaround for Qt applications built with `stdenv.mkDerivation` and `wrapGAppsHook3`, where both GNOME and Qt setup hooks might produce conflicting wrapper scripts. Setting `dontWrapGApps = true` disables the GNOME wrapper, and manually appending GNOME-specific wrapper arguments to `qtWrapperArgs` integrates required environment configuration into the Qt wrapper. Dependencies include `wrapGAppsHook3`, `qt6.wrapQtAppsHook`, and `qmake`. The snippet expects all necessary input paths to be available in-scope. This method is required when multiple frameworks use their own wrappers, to avoid double-wrapping binaries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/gnome.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  pname = \"calibre\";\n  version = \"3.47.0\";\n\n  nativeBuildInputs = [\n    wrapGAppsHook3\n    qt6.wrapQtAppsHook\n    qmake\n    # ...\n  ];\n\n  dontWrapGApps = true;\n\n  preFixup = ''\n    qtWrapperArgs+=(\"''${gappsWrapperArgs[@]}\")\n  '';\n}\n\n```\n\n----------------------------------------\n\nTITLE: Building K3s Passthru Tests with Nix - Shell\nDESCRIPTION: Illustrates a command to locally build specific K3s passthru tests (etcd, single-node, multi-node) using Nix. The command is run from the root of the nixpkgs repository on an upgrade branch to verify the test suite for a specified K3s version (e.g., version 1.29 with '29'). Requires Nix to be installed and the proper branch and package layout to exist. The expected output is a build or test result for the specified K3s version's test modules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/PKG_UPKEEP.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnix build .#k3s_1_29.passthru.tests.{etcd,single-node,multi-node}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Prefer-Remote-Fetch Overlay - Nixpkgs - Shell\nDESCRIPTION: This Shell session demonstrates the full process of creating an overlays directory, crafting the prefer-remote-fetch.nix overlay file, and populating it with the appropriate Nix code. Dependencies include Bash or a compatible shell, file system access, and a writable ~/.config/nixpkgs/overlays/ directory. The cat > ... <<EOF workflow requires user input to paste the Nix lambda, and writes the overlay declaration used by Nix for subsequent evaluations. Output is a fully configured overlay, ready to be loaded by Nix. Limitation: the steps must be executed as the relevant user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/prefer-remote-fetch.section.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir ~/.config/nixpkgs/overlays/\n$ cat > ~/.config/nixpkgs/overlays/prefer-remote-fetch.nix <<EOF\n  self: super: super.prefer-remote-fetch self super\nEOF\n```\n\n----------------------------------------\n\nTITLE: Blocklisting Licenses in User Configuration - Nix - nix\nDESCRIPTION: Configures user-level package blocking for `agpl3Only` and `gpl3Only` by using `blocklistedLicenses` with `lib.licenses`. Search and evaluation for these licenses are denied in all contexts. Input is an array of license identifiers; output is that these packages will not be available to the user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  blocklistedLicenses = with lib.licenses; [\n    agpl3Only\n    gpl3Only\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Relaxing Version Constraint on Dependency - buildHomeAssistantComponent - Nix\nDESCRIPTION: This Nix fragment demonstrates how to ignore version requirements for specific Python dependencies when building a Home Assistant component. The dependencies attribute lists required Python packages, while ignoreVersionRequirement is set to a list of package names whose version constraints should be relaxed. This pattern can be used in a buildHomeAssistantComponent expression to avoid errors caused by overly strict dependency constraints.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/home-assistant/custom-components/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n  dependencies = [\n    pyemvue\n  ];\n\n  # don't check the version constraint of pyemvue\n  ignoreVersionRequirement = [\n    \"pyemvue\"\n  ];\n\n```\n\n----------------------------------------\n\nTITLE: Configuring User Accounts as List of Attribute Sets - Nix\nDESCRIPTION: This snippet demonstrates the deprecated way of defining users in a NixOS configuration using a list of attribute sets. Each user is represented by an entry in the list with keys such as 'name', 'description', and 'isNormalUser'. This format is no longer recommended, as it requires extracting the 'name' field and is harder to manage programmatically.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users =\n    [ { name = \"me\";\n        description = \"My personal user.\";\n        isNormalUser = true;\n      }\n    ];\n}\n```\n\n----------------------------------------\n\nTITLE: Querying PostgreSQL Plugin Collection in NixOS using Nix REPL\nDESCRIPTION: Demonstrates how to access and explore available PostgreSQL plugins for a specific version using the Nix REPL. The example shows accessing plugins for PostgreSQL 15.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/postgresql.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ nix repl '<nixpkgs>'\n\nLoading '<nixpkgs>'...\nAdded 10574 variables.\n\nnix-repl> postgresql_15.pkgs.<TAB><TAB>\npostgresql_15.pkgs.cstore_fdw        postgresql_15.pkgs.pg_repack\npostgresql_15.pkgs.pg_auto_failover  postgresql_15.pkgs.pg_safeupdate\npostgresql_15.pkgs.pg_bigm           postgresql_15.pkgs.pg_similarity\npostgresql_15.pkgs.pg_cron           postgresql_15.pkgs.pg_topn\npostgresql_15.pkgs.pg_hll            postgresql_15.pkgs.pgjwt\npostgresql_15.pkgs.pg_partman        postgresql_15.pkgs.pgroonga\n...\n```\n\n----------------------------------------\n\nTITLE: Appending Configuration Directory to Lustration List (Shell)\nDESCRIPTION: Echoes the relative etc/nixos path and appends it to the /etc/NIXOS_LUSTRATE file, ensuring that configuration is preserved during root partition purging. Input: none. Output: /etc/NIXOS_LUSTRATE updated with etc/nixos entry.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_13\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ echo etc/nixos | sudo tee -a /etc/NIXOS_LUSTRATE\n```\n\n----------------------------------------\n\nTITLE: Thunar GVFS Warning Message on Startup - Plain\nDESCRIPTION: This plain text snippet provides an example of a warning message that may appear when Thunar attempts to interface with remote volumes without required GNOME services. It is encountered in Thunar log outputs and serves as a diagnostic clue for troubleshooting. The message suggests a missing dependency (UDisks2VolumeMonitor) and directs users to enable related GNOME background services for resolution.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/xfce.chapter.md#_snippet_2\n\nLANGUAGE: plain\nCODE:\n```\nThunar:2410): GVFS-RemoteVolumeMonitor-WARNING **: remote volume monitor with dbus name org.gtk.Private.UDisks2VolumeMonitor is not supported\n```\n\n----------------------------------------\n\nTITLE: Android Gradle Build Configuration\nDESCRIPTION: Gradle configuration for Android projects specifying buildToolsVersion, NDK version, and CMake version to ensure compatibility with androidenv declarations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/android.section.md#_snippet_13\n\nLANGUAGE: gradle\nCODE:\n```\nandroid {\n    buildToolsVersion \"30.0.3\"\n    ndkVersion = \"22.0.7026061\"\n    externalNativeBuild {\n        cmake {\n            version \"3.10.2\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dismounting Kubelet Filesystem - Shell Command - bash\nDESCRIPTION: This script checks if a kubelet mount exists, extracts its mount path using 'grep' and 'cut', and then attempts to unmount it if found. It uses parameter expansion to perform 'umount' only if the KUBELET_PATH variable is set. Dependencies: 'grep', 'cut', mount, umount; expected to be run as root or with sufficient privileges. Input: none; Output: Kubelet filesystem is dismounted.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n KUBELET_PATH=$(mount | grep kubelet | cut -d' ' -f3);\n ${KUBELET_PATH:+umount $KUBELET_PATH}\n```\n\n----------------------------------------\n\nTITLE: Testing Build Failure with Custom Builder - Nix - nix\nDESCRIPTION: This Nix expression uses testers.testBuildFailure to ensure that a specific build fails as intended. It wraps a runCommand that deliberately fails (using 'exit 3'), verifies the produced output and log files, and checks the exit code. Useful for writing tests that must confirm a derivation fails under controlled conditions. Dependencies include testers.testBuildFailure and runCommand.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nrunCommand \"example\"\n  {\n    failed = testers.testBuildFailure (\n      runCommand \"fail\" { } ''\n        echo ok-ish >$out\n        echo failing though\n        exit 3\n      ''\n    );\n  }\n  ''\n    grep -F 'ok-ish' $failed/result\n    grep -F 'failing though' $failed/testBuildFailure.log\n    [[ 3 = $(cat $failed/testBuildFailure.exit) ]]\n    touch $out\n  ''\n```\n\n----------------------------------------\n\nTITLE: Configuring systemd-coredump Behavior in NixOS\nDESCRIPTION: This snippet shows how to modify systemd-coredump behavior or disable it to revert to the old core dump handling in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nsystemd.coredump.extraConfig\nsystemd.coredump.enable = false;\n```\n\n----------------------------------------\n\nTITLE: Setting GOPROXY via Nix Experimental Features\nDESCRIPTION: Configuration to set GOPROXY using Nix's experimental impure-env feature.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/athens.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nix.settings.experimental-features = [ \"configurable-impure-env\" ];\n  nix.settings.impure-env = \"GOPROXY=http://localhost:3000\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating branch from specific Git commit\nDESCRIPTION: Command to create a new branch based on a specific commit hash instead of master\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit switch --create update-hello <the desired base commit>\n```\n\n----------------------------------------\n\nTITLE: Specifying Symlinks in a Portable Service Image with pkgs.portableService (Nix)\nDESCRIPTION: This Nix snippet extends the basic portableService build by adding a symlink to /etc/ssl within the image, sourced from the cacert package. Dependencies include lib, writeText, portableService, hello, and cacert. The symlinks attribute receives an object-symlink mapping, allowing global paths such as /etc/ssl to be made available inside the image for services expecting them. The rest of the configuration is similar to the basic example. Pay attention to correct attribute formatting and ensure all referenced derivations exist.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/portableservice.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  writeText,\n  portableService,\n  hello,\n  cacert,\n}:\nlet\n  hello-service = writeText \"hello.service\" ''\n    [Unit]\n    Description=Hello world service\n\n    [Service]\n    Type=oneshot\n    ExecStart=${lib.getExe hello}\n  '';\nin\nportableService {\n  pname = \"hello\";\n  inherit (hello) version;\n  units = [ hello-service ];\n  symlinks = [\n    {\n      object = \"${cacert}/etc/ssl\";\n      symlink = \"/etc/ssl\";\n    }\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Kernel sysctl Option with Integer and Quoted Attribute Name - NixOS - nix\nDESCRIPTION: Assigns an integer value to a kernel sysctl setting by quoting the attribute key to handle dots in the name. Demonstrates how to map NixOS configuration keys to kernel sysctl settings, using integers as values. The attribute name must be quoted for non-NixOS options.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 60;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced NixOS Package Environment with Man Pages\nDESCRIPTION: Extended configuration that includes environment variable setup for man pages and adds a profile script to the package environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/using/configuration.chapter.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: {\n    myProfile = pkgs.writeText \"my-profile\" ''\n      export PATH=$HOME/.nix-profile/bin:/nix/var/nix/profiles/default/bin:/sbin:/bin:/usr/sbin:/usr/bin\n      export MANPATH=$HOME/.nix-profile/share/man:/nix/var/nix/profiles/default/share/man:/usr/share/man\n    '';\n    myPackages = pkgs.buildEnv {\n      name = \"my-packages\";\n      paths = with pkgs; [\n        (runCommand \"profile\" { } ''\n          mkdir -p $out/etc/profile.d\n          cp ${myProfile} $out/etc/profile.d/my-profile.sh\n        '')\n        aspell\n        bc\n        coreutils\n        ffmpeg\n        man\n        nix\n        emscripten\n        jq\n        nox\n        silver-searcher\n      ];\n      pathsToLink = [\n        \"/share/man\"\n        \"/share/doc\"\n        \"/bin\"\n        \"/etc\"\n      ];\n      extraOutputsToInstall = [\n        \"man\"\n        \"doc\"\n      ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Emacs Config with writeText and Emacs withPackages in Nix (Nix & Emacs Lisp)\nDESCRIPTION: This composite snippet shows how to inject a custom Emacs Lisp configuration by creating a default.el file at build time using pkgs.writeText and then making Emacs load this automatically via packageOverrides. The writeText creates a default.el containing multiple use-package expressions for key Emacs packages, specifying commands, keybindings, and initialization code. The code block is primarily in Nix but embeds a multi-line Emacs Lisp script. Dependencies include Nixpkgs, Emacs, and the listed Emacs packages. Limitations: this config is loaded in addition to the user's, and settings can be bypassed by running Emacs with -q.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/emacs.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  packageOverrides = pkgs: {\n    myEmacsConfig = pkgs.writeText \"default.el\" ''\n      (eval-when-compile\n        (require 'use-package))\n\n      ;; load some packages\n\n      (use-package company\n        :bind (\"<C-tab>\" . company-complete)\n        :diminish company-mode\n        :commands (company-mode global-company-mode)\n        :defer 1\n        :config\n        (global-company-mode))\n\n      (use-package counsel\n        :commands (counsel-descbinds)\n        :bind (([remap execute-extended-command] . counsel-M-x)\n               (\"C-x C-f\" . counsel-find-file)\n               (\"C-c g\" . counsel-git)\n               (\"C-c j\" . counsel-git-grep)\n               (\"C-c k\" . counsel-ag)\n               (\"C-x l\" . counsel-locate)\n               (\"M-y\" . counsel-yank-pop)))\n\n      (use-package flycheck\n        :defer 2\n        :config (global-flycheck-mode))\n\n      (use-package ivy\n        :defer 1\n        :bind ((\"C-c C-r\" . ivy-resume)\n               (\"C-x C-b\" . ivy-switch-buffer)\n               :map ivy-minibuffer-map\n               (\"C-j\" . ivy-call))\n        :diminish ivy-mode\n        :commands ivy-mode\n        :config\n        (ivy-mode 1))\n\n      (use-package magit\n        :defer\n        :if (executable-find \"git\")\n        :bind ((\"C-x g\" . magit-status)\n               (\"C-x G\" . magit-dispatch-popup))\n        :init\n        (setq magit-completing-read-function 'ivy-completing-read))\n\n      (use-package projectile\n        :commands projectile-mode\n        :bind-keymap (\"C-c p\" . projectile-command-map)\n        :defer 5\n        :config\n        (projectile-global-mode))\n    '';\n\n    myEmacs = emacs.pkgs.withPackages (\n      epkgs:\n      (with epkgs.melpaStablePackages; [\n        (runCommand \"default.el\" { } ''\n          mkdir -p $out/share/emacs/site-lisp\n          cp ${myEmacsConfig} $out/share/emacs/site-lisp/default.el\n        '')\n        company\n        counsel\n        flycheck\n        ivy\n        magit\n        projectile\n        use-package\n      ])\n    );\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Directory File Sets with and without Subdirectories in Nix (Nix)\nDESCRIPTION: This pair of illustrative Nix code snippets demonstrate two different possible behaviors for representing a file set using the path './.'. The first snippet suggests including the directory and all its subdirectories, while the second includes only the directory itself, not subdirectories. These are examples for discussing how file sets might define inclusivity of directory structure, not intended for direct evaluation. They highlight the challenge of encoding file-only versus directory-preserving semantics in Nix fileset abstractions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_0\n\nLANGUAGE: Nix\nCODE:\n```\n\"./.\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Crystal Binary Targets in Nix\nDESCRIPTION: This snippet shows how to specify the mapping between binary names and source files for Crystal packages in Nix. It sets the 'mint' binary to be built from the src/mint.cr source file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/crystal.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  crystalBinaries.mint.src = \"src/mint.cr\";\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Syncthing Data Directory\nDESCRIPTION: Example showing the correct way to configure Syncthing data directory path after changes requiring exact folder specification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n    services.syncthing = {\n        enable = true;\n        dataDir = \"/home/somebody/.syncthing\";\n        user = \"somebody\";\n    };\n  }\n```\n\n----------------------------------------\n\nTITLE: Enabling Phantomjs Support in Grafana on NixOS\nDESCRIPTION: Configuration to enable the deprecated phantomjs support in Grafana. PhantomJS support is disabled by default in NixOS 20.09 but can be re-enabled by overriding the Grafana package attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.grafana.package = pkgs.grafana.overrideAttrs (oldAttrs: rec {\n    phantomJsSupport = true;\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Etcd Service in NixOS Configuration - Nix Expression - nix\nDESCRIPTION: This snippet disables the Etcd service in NixOS by setting 'services.etcd.enable' to false within the system configuration file. On rebuild, Etcd systemd service files will be removed but this does not automatically clear Etcd data. Prerequisite: Edit and rebuild '/etc/nixos/configuration.nix' as root.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/CLUSTER_UPKEEP.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n services.etcd.enable = false;\n```\n\n----------------------------------------\n\nTITLE: Adding Package Deprecation Alias in Nixpkgs\nDESCRIPTION: How to add an alias for a deprecated package in Nixpkgs' aliases.nix file. This ensures users attempting to install the removed package get a clear error message explaining why it was removed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  jbidwatcher = throw \"jbidwatcher was discontinued in march 2021\"; # added 2021-03-15\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Setup Hook - Nixpkgs - Nix\nDESCRIPTION: This code snippet demonstrates how to use pkgs.makeSetupHook to define a new setup hook called \"something-hook\" within the Nixpkgs project. It specifies both binary (propagatedBuildInputs) and non-binary (depsTargetTargetPropagated) dependencies for the hook, and attaches a shell script from a given path. The pkgs.makeSetupHook function injects these dependencies into the build environment, producing a hook script to be run during native build inputs phase.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/makesetuphook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\npkgs.makeSetupHook {\n  name = \"something-hook\";\n  propagatedBuildInputs = [ pkgs.commandsomething ];\n  depsTargetTargetPropagated = [ pkgs.libsomething ];\n} ./script.sh\n```\n\n----------------------------------------\n\nTITLE: Simplifying Build Failure Assertion and Log Checks - Nix - nix\nDESCRIPTION: This example demonstrates testers.testBuildFailure', an enhanced test helper that wraps testers.testBuildFailure to make build failure assertions easier. It checks the builder's exit code, specified log entries, and allows additional custom scripts. Inputs include the failing derivation, expected exit code, expected log entries, and a script for further checks.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\ntesters.testBuildFailure' {\n  drv = runCommand \"doc-example\" { } ''\n    echo ok-ish >\"$out\"\n    echo failing though\n    exit 3\n  '';\n  expectedBuilderExitCode = 3;\n  expectedBuilderLogEntries = [ \"failing though\" ];\n  script = ''\n    grep --silent -F 'ok-ish' \"$failed/result\"\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Picom Compositor with Custom Effects in NixOS - Nix\nDESCRIPTION: This Nix configuration snippet shows how to enable and customize the picom compositor service for visual effects within the Xfce Desktop Environment. Required dependency is the 'picom' package provided by Nixpkgs, and the setup allows you to fine-tune fade effects, opacity, shadows, and transition speeds by adjusting the listed parameters. Place this configuration inside your system settings to enable picom with these graphical effects for all users.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/xfce.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.picom = {\n    enable = true;\n    fade = true;\n    inactiveOpacity = 0.9;\n    shadow = true;\n    fadeDelta = 4;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Crafting and Registering Custom EDID Files with runCommand - Nix\nDESCRIPTION: This snippet illustrates how to create custom EDID files using a Nix derivation with pkgs.runCommand. It places base64-decoded EDID binaries in $out/lib/firmware/edid/ and registers them by assigning the resulting derivation to hardware.display.edid.packages. Dependencies include access to pkgs.runCommand and standard Unix utilities (mkdir, base64). Inputs are EDID binaries in base64; output is a derivation suitable for NixOS's hardware display subsystem. Replace placeholder text with actual base64-encoded EDID data extracted from hardware.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/hardware/display.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  hardware.display.edid.packages = [\n    (pkgs.runCommand \"edid-custom\" {} ''\n       mkdir -p $out/lib/firmware/edid\n       base64 -d > \"$out/lib/firmware/edid/custom1.bin\" <<'EOF'\n       <insert your base64 encoded EDID file here `base64 < /sys/class/drm/card0-.../edid`>\n       EOF\n       base64 -d > \"$out/lib/firmware/edid/custom2.bin\" <<'EOF'\n       <insert your base64 encoded EDID file here `base64 < /sys/class/drm/card1-.../edid`>\n       EOF\n    '')\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Perl VM Test Deprecation Warning in NixOS Shell - ShellSession\nDESCRIPTION: This shell output demonstrates the warning message displayed to users when attempting to run Perl-based NixOS VM tests, which are deprecated as of release 20.03. The warning advises migration to the new Python-based test driver and points to further details. No user action besides migration is required; the message is informational and appears whenever the Perl VM test driver is invoked from the shell or automation. Requires NixOS environments using integration tests.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ warning: Perl VM tests are deprecated and will be removed for 20.09.\nPlease update your tests to use the python test driver.\nSee https://github.com/NixOS/nixpkgs/pull/71684 for details.\n```\n\n----------------------------------------\n\nTITLE: Manually Setting Postfix Relay and Transport Maps for Mailman - Nix\nDESCRIPTION: This snippet exemplifies manual configuration of Postfix relay domains, transport maps, and local recipient maps for a Mailman deployment in NixOS. The lists reference hash maps generated by Mailman, and the configuration must be performed manually to allow user customization and correct ordering of values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.postfix.relayDomains = [ \"hash:/var/lib/mailman/data/postfix_domains\" ];\n  services.postfix.config.transport_maps = [ \"hash:/var/lib/mailman/data/postfix_lmtp\" ];\n  services.postfix.config.local_recipient_maps = [ \"hash:/var/lib/mailman/data/postfix_lmtp\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Execer and Wrapper Lore in Resholve - Nix Language\nDESCRIPTION: This Nix snippet demonstrates how to manually override 'execer' and 'wrapper' lore for resholve when analyzing package executables. The 'execer' list is used to specify explicit verdicts such as 'cannot' or 'can' for given executable paths, while the 'wrapper' list maps known wrappers to their target programs. All provided verdicts and mappings are strings; these entries can override or extend those detected by binlore. Inputs are derivations or strings referencing executable paths. There are no direct dependencies apart from the variables referenced (like openssl.bin and gnugrep), but actual effect requires integration with the broader resholve build system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/misc/resholve/README.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  # --execer 'cannot:${openssl.bin}/bin/openssl can:${openssl.bin}/bin/c_rehash'\n  execer = [\n    /*\n      This is the same verdict binlore will\n      come up with. It\\'s a no-op just to demo\n      how to fiddle lore via the Nix API.\n    */\n    \"cannot:${openssl.bin}/bin/openssl\"\n    # different verdict, but not used\n    \"can:${openssl.bin}/bin/c_rehash\"\n  ];\n\n  # --wrapper '${gnugrep}/bin/egrep:${gnugrep}/bin/grep'\n  wrapper = [\n    /*\n      This is the same verdict binlore will\n      come up with. It\\'s a no-op just to demo\n      how to fiddle lore via the Nix API.\n    */\n    \"${gnugrep}/bin/egrep:${gnugrep}/bin/grep\"\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Wrapper Arguments with libcosmicAppWrapperArgs in Nix\nDESCRIPTION: This Nix snippet illustrates injecting additional arguments into the application wrapper using the preFixup hook with libcosmicAppWrapperArgs. The snippet adds a custom environment variable (ENVIRONMENT_VARIABLE) with a designated value during the build phase. The preFixup attribute is a shell script segment run during package fixup, enabling further environment manipulation. The snippet requires knowledge of bash scripting within Nix and assumes the presence of libcosmicAppHook.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cosmic.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  rustPlatform,\n  libcosmicAppHook,\n}:\nrustPlatform.buildRustPackage {\n  # ...\n  preFixup = ''\n    libcosmicAppWrapperArgs+=(--set-default ENVIRONMENT_VARIABLE VALUE)\n  '';\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sourcing fzf Shell Integration Scripts - Bash\nDESCRIPTION: Demonstrates integrating 'fzf' package shell helpers into the shell by dynamically sourcing completion and key binding scripts using the 'fzf-share' helper to resolve their paths at runtime. Requires the 'fzf' package with 'fzf-share' available in the environment. The code should be added to the user's '.bashrc' to enable fuzzy completion and key bindings in bash sessions. Outputs are not generated directly; instead, the shell sourcing enables command-line features from 'fzf'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/shell-helpers.section.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsource \"$(fzf-share)/completion.bash\"\nsource \"$(fzf-share)/key-bindings.bash\"\n```\n\n----------------------------------------\n\nTITLE: Controlling Source Hyperlinking in Haskell Documentation\nDESCRIPTION: Functions to enable or disable hyperlinking of source code in generated Haddock documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_24\n\nLANGUAGE: nix\nCODE:\n```\ndoHyperlinkSource drv\ndontHyperlinkSource drv\n```\n\n----------------------------------------\n\nTITLE: Enabling Duo Security PAM Service\nDESCRIPTION: Configuration path for enabling Duo Security PAM module in specific services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1903.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nsecurity.pam.services.<name?>.duoSecurity.enable\n```\n\n----------------------------------------\n\nTITLE: Creating a Default.nix for Idris Package\nDESCRIPTION: Definition of a default.nix file that allows building an Idris package using a simple nix-build command.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/idris.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n{\n  yaml = idrisPackages.callPackage ./yaml.nix { };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Superuser Role - PostgreSQL - SQL\nDESCRIPTION: Provides a SQL statement to ensure the existence of the 'postgres' user as a login superuser, mandatory after NixOS postgresql module changes. Should be run as a database super admin before upgrading. No external dependencies beyond a working PostgreSQL installation and super admin access. Input is the SQL command, output is the 'postgres' superuser role.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_18\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE ROLE postgres LOGIN SUPERUSER;\n```\n\n----------------------------------------\n\nTITLE: Retroarch Core Configuration Update\nDESCRIPTION: New syntax for configuring RetroArch cores, replacing the older override method with a new withCores function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/release-notes/rl-2505.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n# Old syntax\nretroarch.override { cores = [ ... ]; }\n\n# New syntax\nretroarch.withCores (cores: [ ... ])\n```\n\n----------------------------------------\n\nTITLE: Connecting via SSH to the NixOS Virtual Machine - ShellSession\nDESCRIPTION: This snippet shows how to SSH into the running NixOS VM via the forwarded port, assuming the VM is running and correct credentials (password or authorized_keys) are set. No additional dependencies beyond an SSH client. Usage: Connects to 'localhost' on port '2222'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/changing-config.chapter.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ ssh -p 2222 localhost\n```\n\n----------------------------------------\n\nTITLE: Fetching Updated Qt 5 Source with Custom Script - Shell\nDESCRIPTION: This shell snippet instructs users to run a specialized fetch script (./maintainers/scripts/fetch-kde-qt.sh) to update or initialize the source tree for a given major Qt 5 version under the Nixpkgs structure. Requires a properly structured Nixpkgs repository and the fetch script in place. The key parameter is the path to the Qt version subdirectory, and the main dependency is bash or a compatible shell. Outputs the remotely fetched Qt source code and updates the specified directory as needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/qt-5/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./maintainers/scripts/fetch-kde-qt.sh pkgs/development/libraries/qt-5/$major\n```\n\n----------------------------------------\n\nTITLE: Invalidating Fetcher by Derivation Hash to Force Refetching - Nix - nix\nDESCRIPTION: This Nix snippet demonstrates testers.invalidateFetcherByDrvHash, which alters the output name of a fetcher derivation by including its hash. This enforces re-fetching when the fetcher changes, ensuring test reproducibility in scenarios where caching by output hash would otherwise prevent it. It is particularly suited for testing external source fetchers, and requires knowledge of Nix fetcher usage.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_14\n\nLANGUAGE: nix\nCODE:\n```\n{\n  tests.fetchgit = testers.invalidateFetcherByDrvHash fetchgit {\n    name = \"nix-source\";\n    url = \"https://github.com/NixOS/nix\";\n    rev = \"9d9dbe6ed05854e03811c361a3380e09183f4f4a\";\n    hash = \"sha256-7DszvbCNTjpzGRmpIVAWXk20P0/XTrWZ79KSOGLrUWY=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Debugging Patch Errors in LLVM Git Build (Shell)\nDESCRIPTION: This snippet demonstrates the output of a failed build attempt for llvmPackages_git.clang, showing a patch failure. It illustrates how to use the -L and --keep-failed flags for easier debugging of patch errors.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/compilers/llvm/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n...\\nclang-unstable> patching sources\\nclang-unstable> applying patch /nix/store/nndv6gq6w608n197fndvv5my4a5zg2qi-purity.patch\\nclang-unstable> patching file lib/Driver/ToolChains/Gnu.cpp\\nclang-unstable> Hunk #1 FAILED at 487.\\nclang-unstable> 1 out of 1 hunk FAILED -- saving rejects to file lib/Driver/ToolChains/Gnu.cpp.rej\\nnote: keeping build directory '/tmp/nix-build-clang-unstable-2022-25-07.drv-17'\\nerror: builder for '/nix/store/zwi123kpkyz52fy7p6v23azixd807r8c-clang-unstable-2022-25-07.drv' failed with exit code 1;\\n       last 8 log lines:\\n> unpacking sources\\n> unpacking source archive /nix/store/mrxadx11wv1ckjr2208qgxp472pmmg6g-clang-src-unstable-2022-25-07\\n> source root is clang-src-unstable-2022-25-07/clang\\n> patching sources\\n> applying patch /nix/store/nndv6gq6w608n197fndvv5my4a5zg2qi-purity.patch\\n> patching file lib/Driver/ToolChains/Gnu.cpp\\n> Hunk #1 FAILED at 487.\\n> 1 out of 1 hunk FAILED -- saving rejects to file lib/Driver/ToolChains/Gnu.cpp.rej\\nFor full logs, run 'nix log /nix/store/zwi123kpkyz52fy7p6v23azixd807r8c-clang-unstable-2022-25-07.drv'.\\nnote: keeping build directory '/tmp/nix-build-compiler-rt-libc-unstable-2022-25-07.drv-20'\\nerror: 1 dependencies of derivation '/nix/store/ndbbh3wrl0l39b22azf46f1n7zlqwmag-clang-wrapper-unstable-2022-25-07.drv' failed to build\n```\n\n----------------------------------------\n\nTITLE: Adding an Azure CLI Extension to Extensions-Manual - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to add a new Azure CLI extension (here, 'azure-devops') to the 'extensions-manual.nix' file. It defines an attribute using 'mkAzExtension', specifying package name, version, download URL, SHA256 hash, description, build inputs, and the maintainer. Variable substitution is used in the URL with '${version}'. 'propagatedBuildInputs' includes required Python packages. The snippet serves as a template for manual extension packaging.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n  azure-devops = mkAzExtension {\\n    pname = \\\"azure-devops\\\";\\n    version = \\\"1.0.0\\\";\\n    url = \\\"https://github.com/Azure/azure-devops-cli-extension/releases/download/20240206.1/azure_devops-${version}-py2.py3-none-any.whl\\\";\\n    sha256 = \\\"658a2854d8c80f874f9382d421fa45abf6a38d00334737dda006f8dec64cf70a\\\";\\n    description = \\\"Tools for managing Azure DevOps\\\";\\n    propagatedBuildInputs = with python3Packages; [\\n      distro\\n    ];\\n    meta.maintainers = with lib.maintainers; [ katexochen ];\\n  };\n```\n\n----------------------------------------\n\nTITLE: Modifying Pipewire Module Parameters via JSON Drop-In - JSON\nDESCRIPTION: This snippet shows how to override arguments for a specific Pipewire module (here, libpipewire-module-rt) by re-declaring it in a JSON drop-in config file. Users provide the \\\"name\\\" and \\\"args\\\" object under \\\"context.modules\\\". Dependencies include Pipewire itself and writing permission to /etc/pipewire/ for custom configuration files. Key parameters are the module's name and any custom arguments it needs, such as \\\"rt.prio\\\" for real-time priority adjustment. Inputs are the arguments to the module and outputs are changed Pipewire module behaviors. In some cases, systemd service-level settings may be preferred.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_32\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"context.modules\\\": [\\n    {\\n      \\\"name\\\": \\\"libpipewire-module-rt\\\",\\n      \\\"args\\\": {\\n        \\\"rt.prio\\\": 90\\n      }\\n    }\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IBus Table Engines in NixOS\nDESCRIPTION: Example configuration for enabling IBus table-based input methods. Shows how to enable both the base table engine and additional table-based input methods.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  ibus.engines = with pkgs.ibus-engines; [ table table-others ];\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS User Module Without Group Assignment - nix\nDESCRIPTION: This configuration snippet shows how a system user was previously defined in NixOS without specifying a group. The users.users.foo attribute set includes isSystemUser = true, but omits the group option. This practice is now deprecated as group assignment is required for security reasons, and leaving it out can result in an insecure setup.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2111.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  users.users.foo = {\n    isSystemUser = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling DWARF Debugging for Haskell Packages\nDESCRIPTION: A function to compile a Haskell package with additional debug symbols, useful for debugging with tools like gdb.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\nenableDWARFDebugging drv\n```\n\n----------------------------------------\n\nTITLE: Configuring redisTestHook with custom port\nDESCRIPTION: Shows how to customize the Redis server port by setting the redisTestPort variable in the preCheck phase of a package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/redis-test-hook.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  stdenv,\n  redis,\n  redisTestHook,\n}:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeCheckInputs = [\n    redisTestHook\n  ];\n\n  preCheck = ''\n    redisTestPort=6390;\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Snapper Config Schema - Nix\nDESCRIPTION: This set of two Nix snippets illustrates the migration of snapper configuration syntax in NixOS. The first snippet shows the deprecated, old format (using subvolume and extraConfig strings, suitable for block-style configuration), while the second reveals the new, preferred format (using uppercase keys and Nix lists for users). These examples require the Nix configuration language, with inputs corresponding to snapper subvolume and user settings; the output modifies system file snapshots management.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.snapper.configs.example = {\n    subvolume = \"/example\";\n    extraConfig = ''\n      ALLOW_USERS=\"alice\"\n    '';\n  };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.snapper.configs.example = {\n    SUBVOLUME = \"/example\";\n    ALLOW_USERS = [ \"alice\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Upstream Version into Patched Branch - Git\nDESCRIPTION: This git snippet merges a specified upstream release tag (v$version) into an active branch (nixpkgs/$major) for a module fork, without fast-forwarding. It is used during minor version updates to bring in the latest upstream changes before generating new patches. Dependencies: local fork clone, properly checked out branch, existing patch structure. Parameters: version tag. Outputs merged branch ready for conflict resolution. Limitations include potential merge conflicts requiring manual intervention.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/qt-5/README.md#_snippet_2\n\nLANGUAGE: git\nCODE:\n```\ngit merge --no-ff v$version\n```\n\n----------------------------------------\n\nTITLE: Port Forwarding to NixOS Test VM\nDESCRIPTION: Command to set up port forwarding to a single NixOS test VM. This example forwards port 22 in the VM to port 2222 on the host machine.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ QEMU_NET_OPTS=\"hostfwd=tcp:127.0.0.1:2222-:22\" ./result/bin/nixos-test-driver\n```\n\n----------------------------------------\n\nTITLE: Defining 1D and 2D Arrays - Nix Language\nDESCRIPTION: Defines simple one- and two-dimensional arrays in Nix to demonstrate array syntax and initialization. No external dependencies are required. The 1D array stores integers, while the 2D array consists of tuples of integers, emphasizing how multi-dimensional collections are created. Inputs are static values and outputs are Nix bindings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\narray1d=[1, 5, 2];array2d=([1, 2], [2, 1]);\n```\n\n----------------------------------------\n\nTITLE: Using binSh Helper with buildLayeredImage in NixOS\nDESCRIPTION: Example showing how to add the binSh helper to a Docker image built with dockerTools.buildLayeredImage, enabling shell access inside the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.buildLayeredImage {\n  name = \"env-helpers\";\n  tag = \"latest\";\n\n  contents = [\n    hello\n    dockerTools.binSh\n  ];\n\n  config = {\n    Cmd = [ \"/bin/hello\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: NixOS VM Test Network Configuration\nDESCRIPTION: Example configuration for nixosTest showing how to set up a VM test network with a single machine node that includes the hello package and enables a service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{\n  name = \"my-test\";\n  nodes = {\n    machine1 =\n      {\n        lib,\n        pkgs,\n        nodes,\n        ...\n      }:\n      {\n        environment.systemPackages = [ pkgs.hello ];\n        services.foo.enable = true;\n      };\n    # machine2 = ...;\n  };\n  testScript = ''\n    start_all()\n    machine1.wait_for_unit(\"foo.service\")\n    machine1.succeed(\"hello | foo-send\")\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Emacs Daemon After Configuration - NixOS - Shell\nDESCRIPTION: These shell commands are run after updating the system configuration to activate the Emacs daemon using systemd under a user's session. 'nixos-rebuild switch' updates the system, 'systemctl --user daemon-reload' reloads user-level systemd configuration, and 'systemctl --user start emacs.service' launches the Emacs daemon. Requires NixOS, systemd user units, and a suitable configuration.nix. Ensures the Emacs server is ready for client connections.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nnixos-rebuild switch  # to activate the new configuration.nix\nsystemctl --user daemon-reload        # to force systemd reload\nsystemctl --user start emacs.service  # to start the Emacs daemon\n\n```\n\n----------------------------------------\n\nTITLE: Modifying GHC Profiling Build Settings with Overlays - Nix\nDESCRIPTION: This Nix code snippet defines an overlay to globally enable or disable profiling for GHC's bundled core libraries by overriding the compiler derivation. The overlay should be added to the overlays list and requires specifying the desired GHC version (via ghcName) and profiling setting (enableProfiling). The snippet relies on the Nixpkgs haskell compiler infrastructure and is sensitive to changes in default compiler versions and naming conventions; building GHC from scratch can be resource-intensive.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_36\n\nLANGUAGE: nix\nCODE:\n```\nlet\\n  # Name of the compiler and package set you want to change. If you are using\\n  # the default package set `haskellPackages`, you need to look up what version\\n  # of GHC it currently uses (note that this is subject to change).\\n  ghcName = \\\"ghc92\\\";\\n  # Desired new setting\\n  enableProfiling = true;\\nin\\n\\n[\\n  # The first overlay modifies the GHC derivation so that it does or does not\\n  # build profiling versions of the core libraries bundled with it. It is\\n  # recommended to only use such an overlay if you are enabling profiling on a\\n  # platform that doesn't by default, because compiling GHC from scratch is\\n  # quite expensive.\\n  (\\n    final: prev:\\n    let\\n      inherit (final) lib;\\n    in\\n\\n    {\\n      haskell = prev.haskell // {\\n        compiler = prev.haskell.compiler // {\\n          ${ghcName} = prev.haskell.compiler.${ghcName}.override {\\n            # Unfortunately, the GHC setting is named differently for historical reasons\\n            enableProfiledLibs = enableProfiling;\\n          };\\n        };\\n      };\\n    }\\n  )\n```\n\n----------------------------------------\n\nTITLE: Exporting Layered Docker Image for Import - Nix\nDESCRIPTION: This Nix expression is identical to the previous `exportImage` example and illustrates the preparatory step for importing an exported image into Docker. It generates a tar archive containing the filesystem of a layered Docker image constructed from the `hello` package. Usage of `dockerTools` and `hello` derivations is required with standard parameters. The output is suitable as input to `docker image import`.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.exportImage {\n  name = \"hello\";\n  fromImage = dockerTools.buildLayeredImage {\n    name = \"hello\";\n    contents = [ hello ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Prepending Kernel Modules with mkBefore Function - Nix\nDESCRIPTION: This snippet uses mkBefore to ensure that the 'kvm-intel' kernel module is loaded before all others. Dependencies: Requires mkBefore, typically provided by pkgs.lib in Nixpkgs. Input: A list of kernel modules; Output: Augmented boot.kernelModules option with 'kvm-intel' at the beginning. Limitation: Only works when mkBefore is available in scope.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/modularity.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelModules = mkBefore [ \"kvm-intel\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hydra Migration Package in NixOS\nDESCRIPTION: Specifies the Hydra migration package to be used for upgrading the Hydra service. This is necessary for adding new database columns before upgrading to the latest version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }: {\n  services.hydra.package = pkgs.hydra-migration;\n}\n```\n\n----------------------------------------\n\nTITLE: Building ROOT Package with GNU Install Layout - CMake/Bash Nix - Markdown\nDESCRIPTION: This block describes a packaging change for the ROOT software in the nixpkgs repository, specifying the use of the -Dgnuinstall=ON CMake flag. The build now produces a standard Unix layout with bin, lib, share, and etc subdirectories. This requires a compatible version of ROOT and CMake, and affects paths for documentation, configuration files, and resource directories within the package outputs. Users and downstream packages should update references to resources accordingly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n- The \\`root\\` package is now built with the \\\"-Dgnuinstall=ON\\\" CMake flag, making the output conform the \\`bin\\` \\`lib\\` \\`share\\` layout. In this layout, \\`tutorials\\` is under \\`share/doc/ROOT/\\`; \\`cmake\\`, \\`font\\`, \\`icons\\`, \\`js\\` and \\`macro\\` under \\`share/root\\`; \\`Makefile.comp\\` and \\`Makefile.config\\` under \\`etc/root\\`.\n```\n\n----------------------------------------\n\nTITLE: Installing and Configuring Discourse Plugins - Nix\nDESCRIPTION: This example configures the Discourse instance to install specific plugins and adjust their settings by referencing the plugins package set. It demonstrates use of the plugins attribute, integration with secret/transient settings, and optional plugin-level defaults using siteSettings. File paths, plugin names, and secret references must be customized for the target environment. All configured plugins must be available in the selected Discourse package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/discourse.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.discourse = {\n    enable = true;\n    hostname = \"discourse.example.com\";\n    sslCertificate = \"/path/to/ssl_certificate\";\n    sslCertificateKey = \"/path/to/ssl_certificate_key\";\n    admin = {\n      email = \"admin@example.com\";\n      username = \"admin\";\n      fullName = \"Administrator\";\n      passwordFile = \"/path/to/password_file\";\n    };\n    mail.outgoing = {\n      serverAddress = \"smtp.emailprovider.com\";\n      port = 587;\n      username = \"user@emailprovider.com\";\n      passwordFile = \"/path/to/smtp_password_file\";\n    };\n    mail.incoming.enable = true;\n    plugins = with config.services.discourse.package.plugins; [\n      discourse-spoiler-alert\n      discourse-solved\n    ];\n    siteSettings = {\n      plugins = {\n        spoiler_enabled = false;\n      };\n    };\n    secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Top-Level Attribute Bindings with Various Types - Nix Language\nDESCRIPTION: Sets top-level attributes to scalar values including numbers, floats, and simple strings to demonstrate foundational assignment statements of various types in Nix. No dependencies, all values are set directly. Suitable for showcasing attribute assignment, value referencing, and typing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\nsimple_top_level_attr=\"1.0\";some_floaty=29.95;top-level-dash=\"pass\";\n```\n\n----------------------------------------\n\nTITLE: Inspecting a Phase Defined as a Shell Function - Bash\nDESCRIPTION: This snippet uses Bash's type command to display the definition of buildPhase if it is implemented as a shell function. It helps developers understand or modify the logic of a build phase during iterative builds within nix-shell. Requirements: buildPhase must exist as a Bash function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ntype buildPhase\n\n```\n\n----------------------------------------\n\nTITLE: Generating Secret Key for Plausible Setup - ShellSession\nDESCRIPTION: This snippet demonstrates generating a 64-byte base64-encoded secret key using the 'openssl' command line utility. It is required as a prerequisite for setting up Plausible analytics, since Plausible's server expects a strong secret for authentication or cryptographic operations. The output should be stored securely and passed to the NixOS configuration as described in subsequent steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/plausible.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ openssl rand -base64 64\n```\n\n----------------------------------------\n\nTITLE: Installing Executable Files with installShellFiles - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to use the `installBin` function provided by the `installShellFiles` helper. The example illustrates renaming an undesirably-named file and installing multiple files as executables into the package's `outputBin` directory via a custom `postInstall` hook. Dependencies include the `installShellFiles` package, and the `postInstall` hook executes in the context of the Nix package build system. Parameters are paths to executable files that will be installed. Inputs are filenames, and outputs are installed binaries. Renaming should precede installation if needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/installShellFiles.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  nativeBuildInputs = [ installShellFiles ];\n\n  # Sometimes the file has an undersirable name. It should be renamed before\n  # being installed via installBin\n  postInstall = ''\n    mv a.out delmar\n    installBin foobar delmar\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Upgrading NixOS to Latest Version\nDESCRIPTION: This command upgrades NixOS to the latest version in the chosen channel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/upgrading.chapter.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nixos-rebuild switch --upgrade\n```\n\n----------------------------------------\n\nTITLE: Modifying Post-Install Script for Coq Package in Nix\nDESCRIPTION: This example shows how to use .overrideAttrs to add custom code to the post-installation process of the multinomials package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\ncoqPackages.multinomials.overrideAttrs (oldAttrs: {\n  postInstall =\n    oldAttrs.postInstall or \"\"\n    + ''\n      echo \"you can do anything you want here\"\n    '';\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Flat-File Binary Cache as a Substituter in Nix Builds (ShellSession)\nDESCRIPTION: This example demonstrates running nix-build to build the hello package, while providing the transferred flat-file binary cache as a trusted substituter using the --option substituters and trusted-substituters options. Dependencies include a working Nix installation and access to the copied cache directory. Key parameters specify the Nix attribute, options disabling signature verification, and the cache path. Input: Nix expression/attribute, Output: built package path in the /nix/store. Limitations include cache completeness and possible signature requirements unless explicitly disabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/binarycache.section.md#_snippet_3\n\nLANGUAGE: shellSession\nCODE:\n```\n$ nix-build -A hello '<nixpkgs>' \\\n  --option require-sigs false \\\n  --option trusted-substituters file:///tmp/hello-cache \\\n  --option substituters file:///tmp/hello-cache\n/nix/store/zhl06z4lrfrkw5rp0hnjjfrgsclzvxpm-hello-2.12.1\n```\n\n----------------------------------------\n\nTITLE: Testing Standard Library Dependencies in nixpkgs\nDESCRIPTION: Command to trigger ofborg build tests for all reverse dependencies of agda standard library. This helps verify that package updates don't break dependent packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/agda.section.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n@ofborg build agdaPackages.standard-library.passthru.tests\n```\n\n----------------------------------------\n\nTITLE: Including External Markdown Sections in Docs - Markdown\nDESCRIPTION: This snippet demonstrates how to include content from an external markdown file into the current documentation using a custom code block directive. The '{=include=}' syntax, typically interpreted by certain static site generators or preprocessing tools, pulls in the contents of the specified file path ('../release-notes-nixpkgs/rl-2505.section.md'). This approach helps maintain modular documentation and separate release notes for reusability. The expected output replaces this block with the referenced section's content during the documentation build process. Ensure that your Markdown processor supports this directive; otherwise, it will be displayed verbatim.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2505.section.md#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\n../release-notes-nixpkgs/rl-2505.section.md\n```\n```\n\n----------------------------------------\n\nTITLE: Generating New Certificates for ACME Testing in Bash\nDESCRIPTION: This snippet shows the commands to generate new certificates using a Nix build and copy them to the current directory. It uses generate-certs.nix to build the certificates and then copies the result to the current directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/tests/common/acme/server/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnix-build generate-certs.nix\ncp result/* .\nrm result\n```\n\n----------------------------------------\n\nTITLE: Substitute Command Example (Shell)\nDESCRIPTION: Example demonstrating the substitute command usage for string replacement and variable substitution in files\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_33\n\nLANGUAGE: shell\nCODE:\n```\nsubstitute ./foo.in ./foo.out \\\n    --replace-fail /usr/bin/bar $bar/bin/bar \\\n    --replace-fail \"a string containing spaces\" \"some other text\" \\\n    --subst-var someVar\n```\n\n----------------------------------------\n\nTITLE: Basic Suwayomi-Server Configuration in NixOS\nDESCRIPTION: Demonstrates the minimal configuration to enable Suwayomi-Server in NixOS. This snippet enables the service with default settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/suwayomi-server.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.suwayomi-server = {\n    enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the NixOS Bootloader via Shell Command - ShellSession\nDESCRIPTION: This shell command installs the NixOS bootloader during the migration or initial setup process. It sets the NIXOS_INSTALL_BOOTLOADER environment variable to ensure the bootloader is reinstalled, and calls the switch-to-configuration script in boot mode. This step depends on a previously built NixOS system profile located at /nix/var/nix/profiles/system/bin/switch-to-configuration, and should be run as root. The expected outcome is an updated bootloader reflecting the current system configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-from-other-distro.section.md#_snippet_15\n\nLANGUAGE: ShellSession\nCODE:\n```\nsudo NIXOS_INSTALL_BOOTLOADER=1 /nix/var/nix/profiles/system/bin/switch-to-configuration boot\n```\n\n----------------------------------------\n\nTITLE: Pushing new commits to pull request\nDESCRIPTION: Git command for pushing additional commits to an existing pull request\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Maven V-Level Metadata Structure\nDESCRIPTION: XML structure for version-level metadata in Maven repositories, used for snapshot version management.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/tools/build-managers/gradle/README.md#_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<groupId>group-id</groupId>\n<artifactId>artifact-id</artifactId>\n<versioning>\n  <lastUpdated>timestamp</lastUpdated>\n  <snapshot>\n    <timestamp>build-timestamp</timestamp>\n    <buildNumber>number</buildNumber>\n  </snapshot>\n  <snapshotVersions>\n    <snapshotVersion>\n      <classifier>optional-classifier</classifier>\n      <extension>ext</extension>\n      <value>version</value>\n      <updated>timestamp</updated>\n    </snapshotVersion>\n  </snapshotVersions>\n</versioning>\n```\n\n----------------------------------------\n\nTITLE: New NixOS Library Functions\nDESCRIPTION: Summary of new library functions added in NixOS 24.11 including fromHexString, network IPv6 parsing, license utilities, output helpers, string manipulation, and fetcher normalization functions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\nlib.fromHexString \"ff\"  # Convert hex to integer\nlib.network.ipv6.fromString \"2001:db8::1\"  # Parse IPv6\nlib.getLicenseFromSpdxIdOr defaultValue \"MIT\"  # Get license from SPDX ID\nlib.getFirstOutput [\"bin\" \"out\"] package  # Get first available output\nlib.trim \"  hello  \"  # Remove whitespace\nlib.trimWith [\" \" \"\\t\"] \"\\t hello \"  # Remove specific chars\n```\n\n----------------------------------------\n\nTITLE: Configuring Parsedmarc with External IMAP - Nix\nDESCRIPTION: Demonstrates a minimal NixOS configuration to enable the Parsedmarc service for parsing DMARC reports from an external IMAP mailbox and saving results to a local Elasticsearch instance. The configuration highlights essential options such as IMAP server connectivity and authentication, and disables GeoIP provisioning for simplicity (note: GeoIP is recommended for full functionality). Required: NixOS system with services.parsedmarc module and access to the specified email credentials. The snippet expects an available IMAP server and a secure password file, with inputs being service options and outputs being managed systemd services.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/parsedmarc.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.parsedmarc = {\n    enable = true;\n    settings.imap = {\n      host = \"imap.example.com\";\n      user = \"alice@example.com\";\n      password = \"/path/to/imap_password_file\";\n    };\n    provision.geoIp = false; # Not recommended!\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Sources with gitignoreSource and gitignoreSourcePure in Nix\nDESCRIPTION: This snippet demonstrates various ways to use the gitignoreSource and gitignoreSourcePure functions from nix-gitignore to filter source files and directories. It shows how to pass ignore patterns as an empty list, a supplemental string, a direct override string, or a list mixing strings and file paths. Requires nixpkgs and the nix-gitignore package. The \"src\" attribute is used in derivations to set the filtered source path, with different behaviors as documented in comments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions/nix-gitignore.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n{\n\n  src = nix-gitignore.gitignoreSource [ ] ./source;\n  # Simplest version\n\n  src = nix-gitignore.gitignoreSource \"supplemental-ignores\\n\" ./source;\n  # This one reads the ./source/.gitignore and concats the auxiliary ignores\n\n  src = nix-gitignore.gitignoreSourcePure \"ignore-this\\nignore-that\\n\" ./source;\n  # Use this string as gitignore, don't read ./source/.gitignore.\n\n  src = nix-gitignore.gitignoreSourcePure [ \"ignore-this\\nignore-that\\n\" ~/.gitignore ] ./source;\n  # It also accepts a list (of strings and paths) that will be concatenated\n  # once the paths are turned to strings via readFile.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bundler for Platform-Specific Gems in Shell\nDESCRIPTION: Commands to configure Bundler to build platform-specific gems from source, either globally or locally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ bundle config set force_ruby_platform true\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ bundle config set --local force_ruby_platform true\n```\n\n----------------------------------------\n\nTITLE: Overriding Inkscape Extensions Using Nix Expression - Nix\nDESCRIPTION: This snippet demonstrates how to use Nix's override capability to specify a custom list of Inkscape extensions during the installation of Inkscape. It assumes `inkscape-with-extensions` and corresponding extension packages are available in your Nix package set. `inkscapeExtensions` is set using `with inkscape-extensions`, allowing you to select the desired plugins, such as `inkstitch`. The configuration results in an Inkscape installation with only the specified extensions included. Inputs: none directly, but depends on the presence of the plugin(s) (e.g., `inkstitch`) in your nixpkgs. Output: a customized package derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/inkscape.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\ninkscape-with-extensions.override {\n  inkscapeExtensions = with inkscape-extensions; [\n    inkstitch\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Building Custom Version Kernel with Manual modDirVersion - Nix\nDESCRIPTION: This Nix snippet illustrates how to build a Linux kernel with a custom version string while specifying the correct modDirVersion to maintain compatibility between the module directory and kernel sources. Like the previous snippet, it requires at least pkgs, a downloadable kernel source, and a config file. The key inputs are version (with a custom suffix), modDirVersion (for modules compatibility), src, and configfile. The output is a custom Linux kernel derivation for cases that require custom versioning semantics.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/linux.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs, ... }:\npkgs.linuxPackages_custom {\n  version = \"6.1.55-custom\";\n  modDirVersion = \"6.1.55\";\n  src = pkgs.fetchurl {\n    url = \"https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-${modDirVersion}.tar.xz\";\n    hash = \"sha256-qH4kHsFdU0UsTv4hlxOjdp2IzENrW5jPbvsmLEr/FcA=\";\n  };\n  configfile = ./path_to_config_file;\n}\n```\n\n----------------------------------------\n\nTITLE: Substituting Dependency Version for All Packages Using packageOverrides - Nix\nDESCRIPTION: This snippet replaces the version of the 'scipy' dependency for all Python packages by using packageOverrides at interpreter construction. It returns a Python environment (via withPackages) that uses scipy_0_17 instead of the default scipy, affecting both direct and transitive dependencies. This approach is useful when all packages must use a specific version of a dependency, such as in testing or in projects with strict requirements.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/python.section.md#_snippet_47\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { };\n\n(\n  let\n    packageOverrides = self: super: {\n      scipy = super.scipy_0_17;\n    };\n  in\n  (pkgs.python310.override {\n    inherit packageOverrides;\n  }).withPackages\n    (ps: [\n      ps.blaze\n    ])\n).env\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Coq Package Version in Nix\nDESCRIPTION: This example shows how to use .override to change the version of the multinomials package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\ncoqPackages.multinomials.override {\n  version = \"1.5.1\";\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Uploading Custom NixOS Config AMI\nDESCRIPTION: Commands to build a custom NixOS configuration into an AMI and upload it to AWS. Uses nixos-rebuild with the amazon image variant.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/maintainers/scripts/ec2/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nNIXOS_CONFIG=\"$(pwd)/my-config.nix\" nixos-rebuild build-image --image-variant amazon\n\nexport AWS_REGION=us-west-2\nexport AWS_PROFILE=my-profile\nnix run github:NixOS/amis#upload-ami -- --image-info ./result/nix-support/image-info.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Swap Devices with a List of Sets - NixOS - nix\nDESCRIPTION: Defines swap devices by providing a list containing a set, with the set specifying the device path. Useful for managing multiple similar resources (e.g., disks) with sets inside a list. List element is a set with the required key(s).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_11\n\nLANGUAGE: nix\nCODE:\n```\n{\n  swapDevices = [ { device = \"/dev/disk/by-label/swap\"; } ];\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Package in Nix Environment\nDESCRIPTION: Command to install a newly created package into the user's Nix environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-env -f . -iA libfoo\n```\n\n----------------------------------------\n\nTITLE: Multiple Version Package Management\nDESCRIPTION: Examples of different approaches to managing multiple versions of packages in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/README.md#_snippet_4\n\nLANGUAGE: nix\nCODE:\n```\n{\n  inherit\n    ({\n      foo_1 = callPackage ../tools/foo/1.nix { };\n      foo_2 = callPackage ../tools/foo/2.nix { };\n    })\n    foo_1\n    foo_2\n    ;\n}\n```\n\n----------------------------------------\n\nTITLE: Template File Example (Bash)\nDESCRIPTION: Example template file showing variable substitution syntax using @varName@ placeholders\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n#! @bash@/bin/sh\nPATH=@coreutils@/bin\necho @foo@\n```\n\n----------------------------------------\n\nTITLE: Force pushing after history rewrite\nDESCRIPTION: Git command for force pushing after rewriting commit history\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: mkPackageOption with Extra Description\nDESCRIPTION: Demonstrates mkPackageOption usage with additional description text for PyTorch package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\nmkPackageOption pkgs [ \"python312Packages\" \"torch\" ] {\n  extraDescription = \"This is an example and doesn't actually do anything.\";\n}\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.python312Packages.torch;\n  defaultText = lib.literalExpression \"pkgs.python312Packages.torch\";\n  description = \"The pytorch package to use. This is an example and doesn't actually do anything.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying and Repairing the Entire Nix Store - Shell Commands - ShellSession\nDESCRIPTION: This snippet presents the command for scanning the entire Nix store to detect and repair corrupted paths. The 'nix-store --verify --check-contents --repair' command instructs Nix to cryptographically verify all store items and repair those with mismatches, redownloading them if available in a binary cache. The operation may be time-consuming, requires Nix to be properly set up, and will not repair paths unavailable in caches.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/administration/store-corruption.section.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n# nix-store --verify --check-contents --repair\n```\n\n----------------------------------------\n\nTITLE: Declaring Option with Typed Freeform Settings Using Nix Submodules\nDESCRIPTION: This snippet demonstrates how to extend a service's settings option in Nix using a submodule with type-checked attributes while leveraging the settingsFormat.type for all remaining (freeform) keys. It requires the settingsFormat definition for the relevant config format, and relies on lib.types.submodule and options definition utilities. The example enforces the port attribute to be a valid port type, provides a default, makes the option show up in generated documentation, and supports schema-driven config for both strict and flexible keys. Inputs are Nix attrsets with options; outputs include stricter config validation and enhanced user documentation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  settings = lib.mkOption {\n    type = lib.types.submodule {\n\n      freeformType = settingsFormat.type;\n\n      # Declare an option for the port such that the type is checked and this option\n      # is shown in the manual.\n      options.port = lib.mkOption {\n        type = lib.types.port;\n        default = 8080;\n        description = ''\n          Which port this service should listen on.\n        '';\n      };\n\n    };\n    default = {};\n    description = ''\n      Configuration for Foo, see\n      <link xlink:href=\"https://example.com/docs/foo\"/>\n      for supported values.\n    '';\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Re-attaching to WeeChat Screen Session - Shell\nDESCRIPTION: This shell command allows an authorized user to re-attach to the running WeeChat screen session using the multiuser-enabled screen instance as 'weechat/weechat-screen'. The command assumes that multiuser support has been configured in the 'screenrc' and that the user has been added to the session's ACL. The session name may vary if configured differently in the NixOS settings. There are no dependencies other than having 'screen' installed and the necessary access granted.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/weechat.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nscreen -x weechat/weechat-screen\n```\n\n----------------------------------------\n\nTITLE: Example Package Version Format for Projects Without Releases\nDESCRIPTION: Shows the version format for projects that have no release versions or incompatible versioning schemes. Uses 0 as the base version number.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n\"0-unstable-2022-03-15\"\n```\n\n----------------------------------------\n\nTITLE: Building Azure CLI with a Specific Extension - Shell\nDESCRIPTION: This shell command uses Nix to build the Azure CLI package with a specified extension, here 'azure-devops'. The command relies on the Nix expression system ('--expr') to instantiate a build with the listed extension. It requires a functional Nix environment with the Nixpkgs repository checked out and assumes 'azure-cli.extensions.azure-devops' has been defined in the Nix expression.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnix build --impure --expr 'with (import ./. {}); azure-cli.withExtensions [ azure-cli.extensions.azure-devops ]'\n```\n\n----------------------------------------\n\nTITLE: Vulnerability Roundup Issue Format Template - Plain Text\nDESCRIPTION: Documents the required format for composing a 'Vulnerability roundup' issue in Nixpkgs. The template includes placeholders for package search links, CVE lists, impacted versions, and contributors. It is meant for automation or maintainers to standardize vulnerability reporting. Inputs are context-specific details; outputs are structured issue descriptions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_27\n\nLANGUAGE: txt\nCODE:\n```\n<link to relevant package search on search.nix.gsc.io>, <link to relevant files in Nixpkgs on GitHub>\n\n<list of related CVEs, their CVSS score, and the impacted NixOS version>\n\n<list of the scanned Nixpkgs versions>\n\n<list of relevant contributors>\n```\n\n----------------------------------------\n\nTITLE: Package Override Definition Migration\nDESCRIPTION: Example of migrating a package override definition from all-packages.nix to a name-based structure.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/README.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n# all-packages.nix\nfooWithBaz = foo.override {\n  bar = baz;\n};\n# turned into pkgs/by-name/fo/fooWithBaz/package.nix with:\n{\n  foo,\n  baz,\n}:\n\nfoo.override {\n  bar = baz;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WordPress Plugins Using the NixOS Wordpress Module in Nix\nDESCRIPTION: This Nix configuration example demonstrates defining a Wordpress site and enabling specific plugins using the wordpressPackages.plugins namespace. Dependencies include the NixOS Wordpress service and available plugins within the package set. The configuration uses an attribute set for sites, keyed by the network domain, with a plugins list that can be expanded as needed. Inputs are NixOS configuration options and plugin names; output applies configuration to the Wordpress service on deployment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/web-apps/wordpress/packages/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.wordpress = {\n    sites.\"blog.${config.networking.domain}\" = {\n      plugins = with pkgs.wordpressPackages.plugins; [\n        anti-spam-bee\n        code-syntax-block\n        cookie-notice\n        lightbox-with-photoswipe\n        wp-gdpr-compliance\n      ];\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining XKB Symbols for Multimedia Keys in Plain Text\nDESCRIPTION: Creates a custom symbols file that binds the multimedia keycodes to X11 actions for audio volume adjustment. This must be coordinated with the corresponding keycodes file. Input: keycodes for <volUp> and <volDown>; output: key-to-action map for XKB.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_26\n\nLANGUAGE: plain text\nCODE:\n```\nxkb_symbols \"media\"\n{\n key.type = \"ONE_LEVEL\";\n key <volUp>   { [ XF86AudioLowerVolume ] };\n key <volDown> { [ XF86AudioRaiseVolume ] };\n}\n```\n\n----------------------------------------\n\nTITLE: Reviewing Last Commit Changes with nixpkgs-review (Shell)\nDESCRIPTION: This snippet examines the effects of the most recent repository commit using nixpkgs-review. It requires the user to have nix-shell and nixpkgs-review installed and operates on the HEAD commit. Outputs include a summary of built packages impacted by the last commit, suitable for targeted verification.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-shell -p nixpkgs-review --run \"nixpkgs-review rev HEAD\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Executable Project with ImGui, GLFW, and OpenGL - CMake\nDESCRIPTION: This CMakeLists.txt snippet configures a C++ project to build an executable that links against ImGui, GLFW, and OpenGL libraries. It requires CMake version 3.20 or higher and the presence of the imgui, glfw3, and OpenGL packages. The main source file is main.cpp, and the \"demo\" executable is set to install in the bin directory. No additional parameters beyond the external dependencies are needed; expected outputs are the built and installed demo executable. Constraints include the need for all dependencies to be present at CMake configure time.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/imgui/demo/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(ImguiDemo LANGUAGES CXX)\ncmake_minimum_required(VERSION 3.20)\n\nadd_executable(demo ./main.cpp)\n\nfind_package(imgui REQUIRED)\nfind_package(glfw3 REQUIRED)\nfind_package(OpenGL REQUIRED)\ntarget_link_libraries(demo PRIVATE imgui glfw OpenGL::GL)\n\ninstall(TARGETS demo RUNTIME DESTINATION bin)\n```\n\n----------------------------------------\n\nTITLE: Reviewing Pull Requests Using nixpkgs-review (Shell)\nDESCRIPTION: These code snippets demonstrate how to use the nixpkgs-review tool to review the impact of a pull request or local changes in the nixpkgs repository. They require nix-shell or Nix flakes setup and the nixpkgs-review package. The workflows review pull requests by number, uncommitted changes, or arbitrary commits with various shell invocations; they expect the user to specify which PR or commit to check. The outputs are builds of affected packages and their dependencies, allowing for manual or automated test verification. Limitations include Linux-only testing support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-shell -p nixpkgs-review --run \"nixpkgs-review pr 12345\"\n```\n\n----------------------------------------\n\nTITLE: Configuring NetworkManager Unmanaged Interfaces\nDESCRIPTION: Configuration to specify which interfaces NetworkManager should ignore, allowing coexistence with WPA Supplicant.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/network-manager.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  networking.networkmanager.unmanaged = [\n     \"*\" \"except:type:wwan\" \"except:type:gsm\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Example bower.json for Bower Package Declaration\nDESCRIPTION: A sample bower.json file declaring dependencies for a web application. It specifies Angular and Bootstrap as required packages with version constraints.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/bower.section.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"my-web-app\",\n  \"dependencies\": {\n    \"angular\": \"~1.5.0\",\n    \"bootstrap\": \"~3.3.6\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring, Building, and Installing a C++ Project with Inja using CMake\nDESCRIPTION: This CMake configuration file sets up a C++ project named 'inja-simple-cmake-test' with support for the Inja templating library. It uses 'find_package' to locate the Inja dependency, defines an executable target built from main.cpp, and ensures that all required libraries are linked. The 'install' command is included to package the built executable into the system's bin directory for easy access. Prerequisites include CMake, a C++ compiler, and the Inja library available to CMake. The primary input is the main.cpp source file, and the result is an installed executable; the setup assumes that Inja is configured in the environment or build system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/in/inja/simple-cmake-test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(inja-simple-cmake-test LANGUAGES CXX)\nfind_package(inja REQUIRED)\nadd_executable(simple-cmake-test main.cpp)\ntarget_link_libraries(simple-cmake-test PRIVATE pantor::inja)\ninstall(TARGETS simple-cmake-test DESTINATION bin)\n```\n\n----------------------------------------\n\nTITLE: Building Package in Nix\nDESCRIPTION: Command to build and test a new package using nix-build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-build -A some-package\n```\n\n----------------------------------------\n\nTITLE: Running Discourse Update Scripts via Shell Commands - shell\nDESCRIPTION: These snippets provide the shell commands necessary for updating the Discourse package within Nixpkgs. Dependencies include Python (for update.py), Nix, and access to the appropriate directory within the repository. Commands must be run in order: running './update.py print-diffs' helps update configurations, './update.py update' applies the update, './update.py update-mail-receiver' and './update.py update-plugins' update mail receivers and plugins, while 'nix build -L -f ... discourse.tests' and 'discourseAllPlugins.tests' ensure the updates work. Inputs include paths and configuration files; outputs are updated packages and build/test results. Only changes made by these scripts should be committed to prevent unrepeatable manual interventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/web-apps/discourse/how_to_update.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./update.py print-diffs\n```\n\nLANGUAGE: shell\nCODE:\n```\n./update.py update\n```\n\nLANGUAGE: shell\nCODE:\n```\nnix build -L -f ../../../../ discourse.tests\n```\n\nLANGUAGE: shell\nCODE:\n```\n./update.py update-mail-receiver\n```\n\nLANGUAGE: shell\nCODE:\n```\n./update.py update-plugins\n```\n\nLANGUAGE: shell\nCODE:\n```\nnix build -L -f ../../../../ discourseAllPlugins.tests\n```\n\n----------------------------------------\n\nTITLE: Configuring Haredo Check Targets\nDESCRIPTION: Variable haredoCheckTargets can be used to explicitly set check/test targets. The dontUseHaredoCheck flag can disable the check phase entirely.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/haredo.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nharedoCheckTargets = [ \"check\" \"test\" ];\ndontUseHaredoCheck = true;\n```\n\n----------------------------------------\n\nTITLE: Extension Commit Message Template - New Extension\nDESCRIPTION: Template for git commit messages when adding a new VSCode extension to the repository.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/vscode/extensions/README.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nvscode-extensions.publisher.extension-name: init at 1.2.3\n\nRelease: https://github.com/owner/project/releases/tag/1.2.3\n```\n\n----------------------------------------\n\nTITLE: Declaring Nix Function Arguments Explicitly - Nix\nDESCRIPTION: This snippet demonstrates preferred argument declaration in Nix functions, where required arguments are listed explicitly within a set. It prescribes using direct key names (e.g., 'stdenv', 'fetchurl', 'perl') for clarity and maintainability. This style avoids ambiguity in function parameters and improves code readability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_15\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchurl, perl }: <...>\n```\n\n----------------------------------------\n\nTITLE: Specifying Build Inputs for Scheme Derivations in Nix - Nix\nDESCRIPTION: This snippet demonstrates how to declare Scheme-related build inputs (such as chez and collections of SRFI extensions from akkuPackages) within a Nix derivation. It requires a Nix environment set up with access to the nixpkgs repository and presumes that akkuPackages and the chez interpreter are available attributes. The buildInputs array specifies dependencies to be made accessible in the building or shell context; expected input is the attribute set, and output is a derivation utilizing these dependencies. Limitations may include availability of the specified packages within nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/scheme.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = [\n    chez\n    akkuPackages.chez-srfi\n  ];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Rust Cargo Hash - Nix Attribute Expression - Nix\nDESCRIPTION: This snippet assigns the SRI-format `cargoHash` needed by `buildRustPackage` to verify vendored dependencies. No external dependencies apart from a valid hash and being within a Nix attribute set are required. Change the hash as dependencies or source changes; used to ensure reproducible builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/rust.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  cargoHash = \"sha256-l1vL2ZdtDRxSGvP0X/l3nMw8+6WF67KPutJEzUROjg8=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Reviewing Pull Requests with nixpkgs-review - ShellSession\nDESCRIPTION: Illustrates using the nixpkgs-review tool within a nix-shell to evaluate a pull request by PR number. Requires nix-shell, nixpkgs-review installed, and appropriate permissions. The command checks out the relevant PR and generates a test build/review environment. Replace PRNUMBER with the actual pull request number; outputs a summary of build/test status for changed packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_23\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p nixpkgs-review --run \"nixpkgs-review pr PRNUMBER\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Citrix Workspace Package for Custom Certificates with Nix (nix)\nDESCRIPTION: This snippet shows how to customize the Citrix Workspace App package within Nixpkgs to include extra certificates by using 'override' and 'symlinkJoin'. The user specifies additional certificate files in the 'extraCerts' array, and Nix builds a customized package including these certificates. Dependencies include Nix, Nixpkgs, and the custom .pem certificate files. The key inputs are paths to .pem files; the output is a Citrix Workspace package with additional trust anchors. The 'config.allowUnfree = true;' is required as the software is unfree.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/citrix.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nwith import <nixpkgs> { config.allowUnfree = true; };\nlet\n  extraCerts = [\n    ./custom-cert-1.pem\n    ./custom-cert-2.pem # ...\n  ];\nin\ncitrix_workspace.override { inherit extraCerts; }\n```\n\n----------------------------------------\n\nTITLE: Provisioning Local Mail for Parsedmarc - Nix\nDESCRIPTION: Illustrates a NixOS configuration to automatically provision a local mailbox for Parsedmarc, which receives DMARC reports directly. By enabling localMail and specifying a hostname, the system manages mail delivery for the DMARC recipient. GeoIP remains disabled for simplicity but should be enabled for comprehensive reporting. Prerequisites include proper DNS and MX record setup for the specified hostname, and the NixOS mail-related modules enabled. The configuration inputs are the localMail and geoIp options, resulting in a self-hosted email collection process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/parsedmarc.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.parsedmarc = {\n    enable = true;\n    provision = {\n      localMail = {\n        enable = true;\n        hostname = monitoring.example.com;\n      };\n      geoIp = false; # Not recommended!\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Davis Service for Deployment - Nix\nDESCRIPTION: This Nix expression snippet demonstrates the declarative configuration of the Davis server within a NixOS module. Dependencies include a NixOS system with the Davis module and a path to secrets for admin credentials and the application secret. Parameters such as hostname, mail server DSN, and file paths for credentials are set; these options control service activation, mail integration, and web server (nginx) configuration. The configuration assumes deployment with a local SQLite database under /var/lib/davis and secure storage of secret files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/davis.md#_snippet_1\n\nLANGUAGE: Nix\nCODE:\n```\n{\n  services.davis = {\n    enable = true;\n    hostname = \"davis.example.com\";\n    mail = {\n      dsn = \"smtp://username@example.com:25\";\n      inviteFromAddress = \"davis@example.com\";\n    };\n    adminLogin = \"admin\";\n    adminPasswordFile = \"/run/secrets/davis-admin-password\";\n    appSecretFile = \"/run/secrets/davis-app-secret\";\n    nginx = {};\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing nixos-rebuild with nixos-rebuild-ng - Nix\nDESCRIPTION: This Nix snippet enables full replacement of the classic nixos-rebuild with the Python-based nixos-rebuild-ng by toggling the system.rebuild.enableNg option in configuration.nix. This changes config.system.build.nixos-rebuild to point to the new tool, affecting all system rebuild tasks. It requires the system.rebuild.enableNg option to be supported in your NixOS version. No other parameters are necessary. Inputs: Boolean toggle. Outputs: nixos-rebuild-ng becomes the default system rebuild tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-rebuild-ng/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n{\n  system.rebuild.enableNg = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Strict Existence and Compositional Path Filtering in Nix (Nix)\nDESCRIPTION: These Nix snippets illustrate error conditions and workarounds when attempting to remove non-existent paths from a file set. The first shows a direct difference operation that would fail if the path does not exist. Subsequent snippets offer explicit alternatives that mitigate failure by using maybeMissing, or demonstrate error propagation in more complex compounded operations. They are didactic, aiming to clarify design rationale behind strict path existence checking and its consequences for safe composition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_6\n\nLANGUAGE: Nix\nCODE:\n```\n\"difference ./. ./does-not-exist\"\n```\n\nLANGUAGE: Nix\nCODE:\n```\n\"difference ./. (maybeMissing ./does-not-exist)\"\n```\n\nLANGUAGE: Nix\nCODE:\n```\n\"difference ./. (difference ./foo ./foo/bar)\"\n```\n\n----------------------------------------\n\nTITLE: Listing Docker Images After Loading Custom Built Image (shell)\nDESCRIPTION: Lists all Docker images using the Docker CLI to demonstrate the effect of setting the 'created' attribute to 'now' in the image manifest. Outputs image repository, tag, image ID, creation time, and size. Assumes at least one image (the 'hello:latest' built above) is available.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ docker image ls\nREPOSITORY   TAG      IMAGE ID       CREATED              SIZE\nhello        latest   de2bf4786de6   About a minute ago   25.2MB\n\n```\n\n----------------------------------------\n\nTITLE: Large Package Test Configuration in Nix\nDESCRIPTION: Example of setting up larger package tests using phoronix-test-suite, demonstrating test organization across multiple files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, lib, fetchurl, callPackage }:\n\nstdenv.mkDerivation {\n  # …\n\n  passthru.tests = {\n    simple-execution = callPackage ./tests.nix { };\n  };\n\n  meta = { /* … */ };\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{ runCommand, phoronix-test-suite }:\n\nlet\n  inherit (phoronix-test-suite) pname version;\nin\n\nrunCommand \"${pname}-tests\" { meta.timeout = 60; }\n  ''\n    # automatic initial setup to prevent interactive questions\n    ${phoronix-test-suite}/bin/phoronix-test-suite enterprise-setup >/dev/null\n    # get version of installed program and compare with package version\n    if [[ `${phoronix-test-suite}/bin/phoronix-test-suite version` != *\"${version}\"*  ]]; then\n      echo \"Error: program version does not match package version\"\n      exit 1\n    fi\n    # run dummy command\n    ${phoronix-test-suite}/bin/phoronix-test-suite dummy_module.dummy-command >/dev/null\n    # needed for Nix to register the command as successful\n    touch $out\n  ''\n```\n\n----------------------------------------\n\nTITLE: Generating SHA256 Checksum for Cataclysm-DDA Revision\nDESCRIPTION: Shell command to get the SHA256 checksum of a specific Cataclysm-DDA git revision for use in nix package overrides.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnix-prefetch-url --unpack \"https://github.com/CleverRaven/Cataclysm-DDA/archive/${YOUR_FAVORITE_REVISION}.tar.gz\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Qt Application Theme in NixOS (Nix)\nDESCRIPTION: This code snippet shows how to enable Qt integration for desktop environments such as GNOME, Pantheon, and Cinnamon by specifying the 'platformTheme' as 'gnome' and setting the 'style' to 'adwaita'. The configuration is to be included in a NixOS configuration file, and the 'qt' attribute set must be supported by the desktop environment. Input is a Nix attribute set, and output is the updated system configuration. Note that this functionality may be removed in the future, and is only applicable if Qt applications need theming integration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2311.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{\n  qt = {\n    enable = true;\n    platformTheme = \"gnome\";\n    style = \"adwaita\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing Generated Manpage Files with man --local-file - Nix/Nixpkgs - ShellSession\nDESCRIPTION: Demonstrates how to preview a manually built manpage using the man command with the --local-file option. The input should be an absolute or relative path to a manpage file (e.g. configuration.nix.5) generated by an earlier build step. There are no additional dependencies except basic Unix man(1) support.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/contributing-to-this-manual.chapter.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\n```ShellSession\\n$ man --local-file result/share/man/man5/configuration.nix.5\\n```\n```\n\n----------------------------------------\n\nTITLE: Shell Command REPL Example for nix-build - Shell\nDESCRIPTION: This snippet illustrates how to format a multiline shell command and resulting output in reference documentation. The input lines are prefixed with $ and the output is shown as the shell would return it. It demonstrates usage of nix-build with several options, and the kind of result path printed upon completion.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ nix-build -A hello '<nixpkgs>' \\\\\\n  --option require-sigs false \\\\\\n  --option trusted-substituters file:///tmp/hello-cache \\\\\\n  --option substituters file:///tmp/hello-cache\\n/nix/store/zhl06z4lrfrkw5rp0hnjjfrgsclzvxpm-hello-2.12.1\n```\n\n----------------------------------------\n\nTITLE: Edit-Compile-Run Kernel Module Workflow - ShellSession\nDESCRIPTION: These commands depict a typical edit-compile-run loop for developing Linux kernel modules (specifically for Mellanox drivers), including building the kernel dev environment, opening a shell session, unpacking the sources, building kernel modules inside the drivers/Mellanox path, and loading a kernel module. The workflow assumes existing source code, Nix tooling, and appropriate permissions. Input is a set of commands executed in sequence; the output is newly built kernel modules and their insertion into the running kernel.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/linux.section.md#_snippet_4\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-build '<nixpkgs>' -A linuxPackages.kernel.dev\n$ nix-shell '<nixpkgs>' -A linuxPackages.kernel\n$ unpackPhase\n$ cd linux-*\n$ make -C $dev/lib/modules/*/build M=$(pwd)/drivers/net/ethernet/mellanox modules\n# insmod ./drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.ko\n```\n\n----------------------------------------\n\nTITLE: SNIS Asset File Listing\nDESCRIPTION: A formatted list of file paths and their corresponding SHA256 hashes for game assets including textures, sounds and solarsystem files. Each line contains a base64-encoded hash followed by the file path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sn/snis-assets/manifest.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ndZfp5pRqDOdn6NJ4XwLoecpj+INCp4AUmUVo8Nm7YT0=  share/snis/solarsystems/quidgebo/kojax-with-clouds-4.png\nkBMBUOWEc3+q93oiqnUjH456Lro6pWUYhlwN5z0Apqo=  share/snis/textures/nebula4.png\nbL2QLHimTgHgMcCWXjABNNWAeYZjfYcSMG69Fe8NNqk=  share/snis/textures/image2.png\n```\n\n----------------------------------------\n\nTITLE: Running a Derivation in Linux VM with Custom Memory (Nixpkgs vmTools, Nix)\nDESCRIPTION: This code shows how to override VM parameters for `runInLinuxVM`. It customizes the memory size (`memSize`) to 1024 MiB when building the `hello` package. Required dependencies are the Nix package set and `vmTools`. The configurable parameter is `memSize`, set via `overrideAttrs`. The output is the build result in a VM with increased memory allocation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }:\nwith pkgs;\nwith vmTools;\nrunInLinuxVM (\n  hello.overrideAttrs (_: {\n    memSize = 1024;\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Adding NixOS Tests to a Package Definition\nDESCRIPTION: Example showing how to include NixOS tests in a package's passthru.tests attribute. This demonstrates referencing a NixOS test from the nixosTests argument to test OpenSMTPD's functionality in a virtual machine.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/passthru.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ nixosTests, ... }:\n{\n  # ...\n  passthru.tests = {\n    basic-functionality-and-dovecot-integration = nixosTests.opensmtpd;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Assorted GCC Compiler Errors Triggered by Fortify Hardening in C (C Compiler Output)\nDESCRIPTION: This collection of GCC build errors showcases what can occur when 'fortify' hardening is active, such as issues with incomplete types, storage size, identifier syntax, or redefinition and attribute errors. The snippet assumes a C build with the '-O2 -D_FORTIFY_SOURCE=2' flags set, possibly in conjunction with '-Werror'. Each error highlights code or environment incompatibility with fortify, suggesting to disable the flag or adjust warning behaviors in affected builds. Inputs are faulty C source code; outputs are diagnostics from the GCC compiler.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_44\n\nLANGUAGE: text\nCODE:\n```\nmalloc.c:404:15: error: return type is an incomplete type\\nmalloc.c:410:19: error: storage size of 'ms' isn't known\\n\\nstrdup.h:22:1: error: expected identifier or '(' before '__extension__'\\n\\nstrsep.c:65:23: error: register name not specified for 'delim'\\n\\ninstallwatch.c:3751:5: error: conflicting types for '__open_2'\\n\\nfcntl2.h:50:4: error: call to '__open_missing_mode' declared with attribute error: open with O_CREAT or O_TMPFILE in second argument needs 3 arguments\n```\n\n----------------------------------------\n\nTITLE: Building All lib Tests Derivation Using Nix - Bash\nDESCRIPTION: Demonstrates how to build and run the full test suite for the Nixpkgs 'lib' library by invoking 'nix-build' on 'tests/release.nix'. This command evaluates all defined tests and outputs the derivation result. It requires 'nix' to be installed and the working directory to be properly initialized as a Nixpkgs checkout.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nnix-build tests/release.nix\n```\n\n----------------------------------------\n\nTITLE: NixOS Module Test Integration\nDESCRIPTION: Example showing how to link NixOS module tests to a package using passthru.tests attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, lib, nixosTests }:\n\nstdenv.mkDerivation {\n  # ...\n\n  passthru.tests = {\n    nginx = nixosTests.nginx;\n  };\n\n  # ...\n}\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Chapters Using Markdown Import Directives - Markdown\nDESCRIPTION: This snippet imports multiple markdown chapter files into the main configuration documentation using the custom '{=include=}' directive. It is dependent on the documentation build system supporting these directives, such as MyST or Sphinx with appropriate extensions. The purpose is to maintain modular documentation for different aspects of NixOS configuration, ensuring that each aspect is separated into its own markdown file. Inputs are lists of chapter filenames, and outputs are the inclusion of that content in the rendered documentation. The snippet enables a maintainable, scalable approach to documentation assembly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/configuration.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} chapters\nconfig-syntax.chapter.md\npackage-mgmt.chapter.md\nuser-mgmt.chapter.md\nfile-systems.chapter.md\nx-windows.chapter.md\nwayland.chapter.md\ngpu-accel.chapter.md\nxfce.chapter.md\nnetworking.chapter.md\nlinux-kernel.chapter.md\nsubversion.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Valid Free-floating Definition\nDESCRIPTION: Example of creating a valid free-floating definition with mkDefinition.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nmkDefinition {\n   value = mkForce 42;\n   file = \"somefile.nix\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nextcloud Module with Extra Apps - Nix\nDESCRIPTION: This Nix expression configures the Nextcloud service module with a specific package set and extra app packages using the with-expression and inherit to include selected apps. It assumes that nextcloud31 and nextcloud31Packages.apps are available in pkgs. The config.adminpassFile parameter demonstrates using writeText to embed admin credentials. Inputs: pkgs set with Nextcloud-related attributes; output: NixOS module configuration. Constraints: version numbers for Nextcloud and package set must be adapted as needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/nextcloud/packages/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.nextcloud = {\n    enable = true;\n    package = pkgs.nextcloud31;\n    hostName = \"localhost\";\n    config.adminpassFile = \"${pkgs.writeText \\\"adminpass\\\" \\\"hunter2\\\"}\";\n    extraApps = with pkgs.nextcloud31Packages.apps; {\n      inherit mail calendar contact;\n    };\n    extraAppsEnable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Sectioned Function Documentation with Markdown Directives - Markdown\nDESCRIPTION: This snippet uses custom markdown syntax to include content from several section-based markdown files into the current documentation. It lists included files by their relative path, each likely containing grouped utility functions or documentation. There are no external software dependencies, but proper support for the inclusion syntax (possibly via pandoc or a similar documentation system) is required. The included files cover the library, generators, debugging, remote fetch preferences, and nix-gitignore-related functions. The expected result is a merged, navigable documentation file without any direct executable input or output.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/functions.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\\nfunctions/library.md\\nfunctions/generators.section.md\\nfunctions/debug.section.md\\nfunctions/prefer-remote-fetch.section.md\\nfunctions/nix-gitignore.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Coercing a Nix Store Path and Combining File Sets (Nix)\nDESCRIPTION: This set of Nix code snippets illustrate alternatives for handling Nix store paths and combining file sets under different root directories. They demonstrate verbose syntax for importing store paths and using union operations, discuss dangerous behaviors related to coercion, and highlight limitations when working with Nix store entries. These are illustrative, not executable, and serve to analyze API expressiveness, safety, and the composability of the fileset abstraction interface.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/fileset/README.md#_snippet_3\n\nLANGUAGE: Nix\nCODE:\n```\n\"let root = \\\"/nix/store/...-source\\\"; in union \\\"${root}/foo\\\" \\\"${root}/bar\\\"\"\n```\n\nLANGUAGE: Nix\nCODE:\n```\n\"toSource { root = \\\"/nix/store/...-source\\\"; fileset = union \\\"./foo\\\" \\\"./bar\\\"; }\"\n```\n\nLANGUAGE: Nix\nCODE:\n```\n\"let fs = lib.fileset.withRoot \\\"/nix/store/...-source\\\"; in fs.union \\\"./foo\\\" \\\"./bar\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Running Self-service Commands for Citrix Workspace in Shell (ShellSession)\nDESCRIPTION: This code snippet demonstrates how to configure Citrix Workspace's self-service application using the command line. It first calls 'storebrowse' to register the provided .cr configuration file, then launches the 'selfservice' client. The user must already have downloaded the .cr file from their NetScaler Gateway and have both 'storebrowse' and 'selfservice' binaries installed. Inputs include the user's .cr config file path; outputs are configuration registration and the opening of the selfservice UI.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/citrix.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ storebrowse -C ~/Downloads/receiverconfig.cr\\n$ selfservice\n```\n\n----------------------------------------\n\nTITLE: Overriding Entrypoint for Lovelace Module with Nix\nDESCRIPTION: This snippet demonstrates how to override the default entrypoint for a lovelace module in NixOS by specifying a custom JavaScript file using the passthru.entrypoint attribute. The attribute can be set to the desired bundle filename, which is then used instead of the \"${pname}.js\" default. There are no required dependencies beyond standard Nixpkgs setup; this setting should appear in the module's derivation definition. The primary parameter is passthru.entrypoint, and its value should be a string matching the intended JavaScript bundle.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/servers/home-assistant/custom-lovelace-modules/README.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  passthru.entrypoint = \"demo-card-bundle.js\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL ReadWritePaths for File Export Operations in NixOS\nDESCRIPTION: Configuration to allow MySQL to write to custom folders when using SELECT * INTO OUTFILE operations. This example grants write access to /var/data directory by adjusting systemd service parameters.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  systemd.services.mysql.serviceConfig.ReadWritePaths = [ \"/var/data\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning and Handling Special String Values - Nix Language\nDESCRIPTION: Assigns a Nix variable to a complex string literal containing escaped characters, quotes, special symbols, and whitespace to illustrate string handling and escaping rules. No dependencies or configuration needed. Input is a raw string; output is a binding to the processed value.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nnasty_string=\"\\\"@\\n\\\\\\t^*bf\\n0\\\";'''$\";\n```\n\n----------------------------------------\n\nTITLE: Discouraged: Nix Functions with Open Parameter Set - Nix\nDESCRIPTION: This code snippet shows a discouraged option for Nix function definitions that uses an open attribute set ({ ... }) to accept both required and extra optional parameters. The recommendation is to spell out required parameters for clarity rather than using an open set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, fetchurl, perl, ... }: <...>\n```\n\n----------------------------------------\n\nTITLE: Circular Conditional Definition Example\nDESCRIPTION: Demonstration of a clearly circular and contradictory conditional definition that would fail.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  config = if config.services.httpd.enable then {\n    services.httpd.enable = false;\n  } else {\n    services.httpd.enable = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting the XKB Keycodes File at Session Startup in NixOS (Nix)\nDESCRIPTION: Configures the X server session to load a custom keycodes file using setxkbmap invoked within sessionCommands. Used when Xorg does not automatically pick up non-symbol layout components. Input: shell command string for setxkbmap; output: desired keymap loaded at session start.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_28\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.sessionCommands = \"setxkbmap -keycodes media\";\n}\n```\n\n----------------------------------------\n\nTITLE: Consulting Cert Spotter Script Man Page - Shell Session\nDESCRIPTION: This shell command, intended for the NixOS environment, demonstrates how to access the man page for Cert Spotter's script/notification hooks by spawning a shell with Cert Spotter available and opening its manual. It requires an environment with nix-shell and the certspotter package. This aids users in obtaining detailed documentation on custom notification hooks and their environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/certspotter.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-shell -p certspotter --run 'man 8 certspotter-script'\n```\n\n----------------------------------------\n\nTITLE: Mapping JSON to Nix Object Syntax in Nixpkgs - Nix & JSON\nDESCRIPTION: This snippet demonstrates how a simple nested value in JSON ({\"foo\":{\"bar\":10}}) can be directly mapped to an equivalent object in Nix syntax ({ foo = { bar = 10; }; }). The JSON example is a structure with \"foo\" containing another object \"bar\" with value 10. This highlights how Nix-representable formats can be trivially converted, enabling configuration through Nix expressions. No external dependencies are required, and the parameters are native constructs of JSON and Nix. Inputs are the JSON structure, and the corresponding output is the valid Nix representation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\\"foo\\\":{\\\"bar\\\":10}}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{ foo = { bar = 10; }; }\n```\n\n----------------------------------------\n\nTITLE: Configuring Gitit Import in NixOS\nDESCRIPTION: Example showing how to import Gitit service configuration in NixOS after it was removed from default module list.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n    imports = [ <nixpkgs/nixos/modules/services/misc/gitit.nix> ];\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a Gemfile for Packaging Ruby Applications\nDESCRIPTION: Example Gemfile content for packaging a Ruby application (mdl) using Bundler.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/ruby.section.md#_snippet_9\n\nLANGUAGE: ruby\nCODE:\n```\nsource 'https://rubygems.org' do\n  gem 'mdl'\nend\n```\n\n----------------------------------------\n\nTITLE: Building switch-to-configuration-ng in Development Shell\nDESCRIPTION: Instructions for building the switch-to-configuration-ng tool using nix-shell and cargo. The process involves entering a development shell and building the Rust project.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sw/switch-to-configuration-ng/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd ./pkgs/by-name/sw/switch-to-configuration-ng\nnix-shell ../../../.. -A switch-to-configuration-ng\ncd ./src\ncargo build\n```\n\n----------------------------------------\n\nTITLE: Building a Derivation Locally Using Nix for Target System\nDESCRIPTION: This code snippet shows how to locally build a derivation (here, 'hello') on a specified target system using the 'nix-build' command. The '-A hello' argument selects the 'hello' attribute, and '--argstr system' specifies the system identifier (such as 'i686-linux'). Assumes the Nix tool is installed, and a valid derivation is available under the selected attribute. Used to test if a bootstrap seed update enables building known packages for the intended architecture. Output is the built package in the local Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/scripts/bootstrap-files/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ nix-build -A hello --argstr system i686-linux\n```\n\n----------------------------------------\n\nTITLE: Querying Maintainer Information in Shell\nDESCRIPTION: Examples of using get-maintainer.sh to retrieve maintainer information in JSON format. The script allows lookups using different selectors like handle, email, name, github, githubId, and matrix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/maintainers/scripts/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n❯ ./get-maintainer.sh nicoo\n{\n  \"email\": \"nicoo@debian.org\",\n  \"github\": \"nbraud\",\n  \"githubId\": 1155801,\n  \"keys\": [\n    {\n      \"fingerprint\": \"E44E 9EA5 4B8E 256A FB73 49D3 EC9D 3708 72BC 7A8C\"\n    }\n  ],\n  \"name\": \"nicoo\",\n  \"handle\": \"nicoo\"\n}\n\n❯ ./get-maintainer.sh name 'Silvan Mosberger'\n{\n  \"email\": \"contact@infinisil.com\",\n  \"github\": \"infinisil\",\n  \"githubId\": 20525370,\n  \"keys\": [\n    {\n      \"fingerprint\": \"6C2B 55D4 4E04 8266 6B7D  DA1A 422E 9EDA E015 7170\"\n    }\n  ],\n  \"matrix\": \"@infinisil:matrix.org\",\n  \"name\": \"Silvan Mosberger\",\n  \"handle\": \"infinisil\"\n}\n```\n\n----------------------------------------\n\nTITLE: Importing CUDNN Releases in Nix\nDESCRIPTION: This snippet demonstrates how to import the CUDNN releases file, which contains release expressions for CUDNN. It shows the use of relative imports in Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/modules/README.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n../cudnn/releases.nix\n```\n\n----------------------------------------\n\nTITLE: Disabling Fallback Theme Settings with Customized libcosmicAppHook in Nix\nDESCRIPTION: This snippet shows how to disable the fallback to cosmic-settings when using libcosmicAppHook by setting includeSettings = false. By overriding the default behavior, the Nix expression customizes libcosmicAppHook using __spliced and buildHost if available. This is useful when COSMIC applications should not inherit fallback theme settings. The key parameters include includeSettings and nativeBuildInputs, and this approach requires familiarity with Nix's override mechanism.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cosmic.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  rustPlatform,\n  libcosmicAppHook,\n}:\nlet\n  # Get build-time version of libcosmicAppHook\n  libcosmicAppHook' = (libcosmicAppHook.__spliced.buildHost or libcosmicAppHook).override {\n    includeSettings = false;\n  };\nin\nrustPlatform.buildRustPackage {\n  # ...\n  nativeBuildInputs = [ libcosmicAppHook' ];\n  # ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring versionCheckHook in Nix Derivation - Nix\nDESCRIPTION: Demonstrates how to incorporate the versionCheckHook into a Nix derivation by specifying it in nativeInstallCheckInputs and enabling doInstallCheck. This ensures the package build process includes an automated version check phase, helping verify that the main program's output contains the declared version string. No external dependencies are required beyond the Nixpkgs standard environment; key parameters include nativeInstallCheckInputs and doInstallCheck. The output is a derivation that will fail to build if the check does not pass.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/versionCheckHook.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  versionCheckHook,\n# ...\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  # ...\n\n  nativeInstallCheckInputs = [\n    versionCheckHook\n  ];\n  doInstallCheck = true;\n\n  # ...\n})\n```\n\n----------------------------------------\n\nTITLE: Controlling Hydra Distribution for Haskell Packages\nDESCRIPTION: Functions to control whether Hydra will build a package by modifying the 'hydraPlatforms' attribute.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\ndoDistribute drv\ndontDistribute drv\n```\n\n----------------------------------------\n\nTITLE: Git Commands for Package Removal\nDESCRIPTION: Git commands for committing changes when removing a package from Nixpkgs. These commands are part of the package deprecation workflow and include adding modified files and creating a commit with explanatory message.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n$ git add pkgs/applications/misc/jbidwatcher/default.nix pkgs/top-level/all-packages.nix pkgs/top-level/aliases.nix\n$ git commit\n```\n\n----------------------------------------\n\nTITLE: Converting Zabbix Database to Required Character Set and Collation\nDESCRIPTION: SQL commands to convert a Zabbix database to the required utf8 character set and utf8_bin collation needed for Zabbix 5.0. Includes a query to generate conversion statements for all tables.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nALTER DATABASE `zabbix` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;\n\n-- the following will produce a list of SQL commands you should subsequently execute\nSELECT CONCAT(\"ALTER TABLE \", TABLE_NAME,\" CONVERT TO CHARACTER SET utf8 COLLATE utf8_bin;\") AS ExecuteTheString\nFROM information_schema.`COLUMNS`\nWHERE table_schema = \"zabbix\" AND COLLATION_NAME = \"utf8_general_ci\";\n```\n\n----------------------------------------\n\nTITLE: Fixing Package Overrides with attachPkgs in Cataclysm-DDA\nDESCRIPTION: Example demonstrating how to properly override Cataclysm-DDA packages while preserving passthru attributes. Shows both manual fixing and using the attachPkgs helper.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/cataclysm-dda.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  # You enabled parallel building.\n  myCDDA = cataclysm-dda-git.overrideAttrs (_: {\n    enableParallelBuilding = true;\n  });\n\n  # Unfortunately, this refers to the package before overriding and\n  # parallel building is still disabled.\n  badExample = myCDDA.withMods (_: [ ]);\n\n  inherit (cataclysmDDA) attachPkgs pkgs wrapCDDA;\n\n  # You can fix it by hand\n  goodExample1 = myCDDA.overrideAttrs (old: {\n    passthru = old.passthru // {\n      pkgs = pkgs.override { build = goodExample1; };\n      withMods = wrapCDDA goodExample1;\n    };\n  });\n\n  # or by using a helper function `attachPkgs`.\n  goodExample2 = attachPkgs pkgs myCDDA;\nin\n\n# badExample                     # parallel building disabled\n# goodExample1.withMods (_: [])  # parallel building enabled\ngoodExample2.withMods (_: [ ]) # parallel building enabled\n```\n\n----------------------------------------\n\nTITLE: Configuring cuDNN Frontend Build and Install with CMake - CMake\nDESCRIPTION: This CMake script defines the configuration, build, and installation steps for the cuDNN frontend library. It sets up options for enabling/disabling samples, tests, and Python bindings, and manages header inclusion, dependencies on CUDAToolkit and CUDA libraries, compilation features (C++17), and install/export rules for package consumers. Required dependencies include CMake 3.23+, CUDA Toolkit, and related CUDA libraries. The script leverages interface libraries for headers and precompiled headers, and uses GNUInstallDirs and CMakePackageConfigHelpers for standards-compliant installation and packaging. Key configuration flags like CUDNN_FRONTEND_SKIP_JSON_LIB, CUDNN_FRONTEND_BUILD_SAMPLES, CUDNN_FRONTEND_BUILD_TESTS, and CUDNN_FRONTEND_BUILD_PYTHON_BINDINGS allow flexible builds. The expected input is a CMake build environment, and outputs are library targets and CMake config files. Limitations: assumes presence of suitable CUDA toolkit and compatible compiler.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/cuda-modules/cudnn-frontend/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.23)\n\nproject(cudnn_frontend VERSION 1.8.0)\n\noption(CUDNN_FRONTEND_SKIP_JSON_LIB \"Defines whether FE should not include nlohmann/json.hpp.\" OFF)\noption(CUDNN_FRONTEND_BUILD_SAMPLES \"Defines if samples are built or not.\" ON)\noption(CUDNN_FRONTEND_BUILD_TESTS \"Defines if unittests are built or not.\" ON)\noption(CUDNN_FRONTEND_BUILD_PYTHON_BINDINGS \"Defines if python bindings are built or not.\" OFF)\n\nif(MSVC OR MSYS OR MINGW)\n    add_compile_options(/W4 /WX)\nelse()\n    add_compile_options(-Wall -Wextra -Wpedantic -Werror -Wno-error=attributes -Wno-attributes -Wno-error=unused-function -Wno-unused-function)\nendif()\n\nadd_library(cudnn_frontend INTERFACE)\n\n# Add header files to library\nfile(GLOB_RECURSE CUDNN_FRONTEND_INCLUDE_FILES \"include/*\")\ntarget_sources(\n    cudnn_frontend\n    PUBLIC\n        FILE_SET\n            HEADERS\n            BASE_DIRS\n                \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n            FILES\n                \"${CUDNN_FRONTEND_INCLUDE_FILES}\"\n)\nunset(CUDNN_FRONTEND_INCLUDE_FILES)\n\ntarget_compile_definitions(cudnn_frontend INTERFACE $<$<BOOL:${CUDNN_FRONTEND_SKIP_JSON_LIB}>:CUDNN_FRONTEND_SKIP_JSON_LIB>)\n\ntarget_include_directories(\n    cudnn_frontend\n    INTERFACE\n        \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\"\n        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\"\n)\n\n# Find the cuda compiler\nfind_package(CUDAToolkit REQUIRED)\n\ntarget_include_directories(cudnn_frontend INTERFACE ${CUDAToolkit_INCLUDE_DIRS})\n\ntarget_compile_features(cudnn_frontend INTERFACE cxx_std_17)\n\n# Make PCH for targets to link against\nadd_library(_cudnn_frontend_pch INTERFACE)\ntarget_precompile_headers(_cudnn_frontend_pch INTERFACE ${PROJECT_SOURCE_DIR}/include/cudnn_frontend.h)\n\nif (CUDNN_FRONTEND_BUILD_SAMPLES)\n    add_subdirectory(samples)\n    target_link_libraries(\n        samples\n        PRIVATE\n            CUDA::cublasLt\n            CUDA::nvrtc\n    )\n    target_link_libraries(\n        legacy_samples\n        PRIVATE\n            CUDA::cublasLt\n            CUDA::nvrtc\n    )\nendif()\n\nif (CUDNN_FRONTEND_BUILD_TESTS)\n    add_subdirectory(test)\n    target_link_libraries(\n        tests\n        CUDA::cublasLt\n        CUDA::nvrtc\n    )\nendif()\n\nif (CUDNN_FRONTEND_BUILD_PYTHON_BINDINGS)\n    add_subdirectory(python)\nendif()\n\n# Introduce variables:\n# * CMAKE_INSTALL_LIBDIR\n# * CMAKE_INSTALL_BINDIR\n# * CMAKE_INSTALL_INCLUDEDIR\ninclude(GNUInstallDirs)\n\n# Install and export the header files\ninstall(\n    TARGETS\n        cudnn_frontend\n    EXPORT\n        cudnn_frontend_targets\n    FILE_SET HEADERS\n)\n\nif (CUDNN_FRONTEND_BUILD_SAMPLES)\n    install(TARGETS legacy_samples samples RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif (CUDNN_FRONTEND_BUILD_TESTS)\n    install(TARGETS tests RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\n# See https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#example-generating-package-files\ninclude(CMakePackageConfigHelpers)\n\nexport(\n    EXPORT\n        cudnn_frontend_targets\n    FILE\n        \"${CMAKE_CURRENT_BINARY_DIR}/cudnn_frontend/cudnn_frontend-targets.cmake\"\n)\ninstall(\n    EXPORT\n        cudnn_frontend_targets\n    FILE\n        cudnn_frontend-targets.cmake\n    DESTINATION\n        \"${CMAKE_INSTALL_LIBDIR}/cmake/cudnn_frontend\"\n)\n\nconfigure_package_config_file(\n    cudnn_frontend-config.cmake.in\n    \"${CMAKE_CURRENT_BINARY_DIR}/cudnn_frontend-config.cmake\"\n    INSTALL_DESTINATION\n        \"${CMAKE_INSTALL_LIBDIR}/cmake/cudnn_frontend\"\n)\ninstall(\n    FILES\n        \"${CMAKE_CURRENT_BINARY_DIR}/cudnn_frontend-config.cmake\"\n    DESTINATION\n        \"${CMAKE_INSTALL_LIBDIR}/cmake/cudnn_frontend\"\n)\n```\n\n----------------------------------------\n\nTITLE: Reviewing Uncommitted Changes with nixpkgs-review (Shell)\nDESCRIPTION: This snippet invokes nixpkgs-review using the 'wip' option to review work-in-progress or uncommitted changes in the repository. It requires nix-shell and the nixpkgs-review package and assumes the current working directory is the root of a nixpkgs clone. The review is performed for any local changes, building affected package dependencies for manual testing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-shell -p nixpkgs-review --run \"nixpkgs-review wip\"\n```\n\n----------------------------------------\n\nTITLE: Rebasing Module Patches onto New Major Version - Git\nDESCRIPTION: This git snippet rebases local changes from an old release version (v$oldversion) onto a new target release (v$version) in a newly created branch, used for major version updates. Dependencies: properly set up local repository, relevant branches, and version tags. Parameters: old and new version tags. The output is an updated branch containing the re-applied and rebased custom patches. Limitations: Conflicts may occur and require manual resolution, and branch structure must follow conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/libraries/qt-5/README.md#_snippet_4\n\nLANGUAGE: git\nCODE:\n```\ngit rebase v$oldversion --onto v$version\n```\n\n----------------------------------------\n\nTITLE: Passing FUSE Version Macro When Configuring Builds - Shell\nDESCRIPTION: Suggests a configuration flag to resolve the issue where FUSE_USE_VERSION is undefined during compilation by explicitly defining it in CFLAGS. This workaround is recommended for autoconf-based projects where the upstream does not properly export FUSE_USE_VERSION via build scripts. Requires knowledge of the actual macro value (e.g., 25) and that it is compatible with the package's source. Adds '-DFUSE_USE_VERSION=25' to configuration flags used during build to ensure headers compile correctly.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/fuse.section.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nCFLAGS=-DFUSE_USE_VERSION=25\n```\n\n----------------------------------------\n\nTITLE: Configuring MAC Algorithms in OpenSSH Settings - Nix\nDESCRIPTION: This Nix configuration snippet demonstrates how to explicitly set the list of MAC algorithms for the OpenSSH service. It is used for cases where removed MAC-then-encrypt algorithms must be re-added for compatibility with certain clients or libraries. The array services.openssh.settings.Macs specifies the enabled MACs for SSH connections, with each string identifying a supported algorithm; inputs are Nix expressions, the output affects the generated SSHD configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.openssh.settings.Macs = [\n    \"hmac-sha2-512\"\n    \"hmac-sha2-256\"\n    \"umac-128@openssh.com\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Secure Application Secret - ShellSession\nDESCRIPTION: This snippet uses shell commands to generate a random 48-character alphanumeric secret suitable for use as an application secret in Davis configuration. It requires a Unix-like shell environment with access to /dev/urandom, cat, tr, fold, and head utilities. The input is provided by /dev/urandom and filtered for alphanumeric characters; the output is a random string printed to standard output. Ensure permissions are managed appropriately when saving this secret.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/davis.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\ncat /dev/urandom | tr -dc a-zA-Z0-9 | fold -w 48 | head -n 1\n```\n\n----------------------------------------\n\nTITLE: Building Custom Emacs with Packages - Nix - Nix Expression\nDESCRIPTION: This Nix expression builds a custom Emacs installation with a user-defined set of Emacs packages from various repositories (MELPA, ELPA, system packages, etc.). It makes use of nixpkgs' emacsWithPackages helper and demonstrates collecting packages from different origins and assembling them into one Emacs derivation. Required dependency is a working Nix setup and access to the nixpkgs repository; input parameter pkgs allows overriding nixpkgs. Outputs an Emacs binary with the specific packages available in its load-path. Run with 'nix-build emacs.nix', output is the 'emacs' binary in the result folder.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n/*\nThis is a nix expression to build Emacs and some Emacs packages I like\nfrom source on any distribution where Nix is installed. This will install\nall the dependencies from the nixpkgs repository and build the binary files\nwithout interfering with the host distribution.\n\nTo build the project, type the following from the current directory:\n\n$ nix-build emacs.nix\n\nTo run the newly compiled executable:\n\n$ ./result/bin/emacs\n*/\n\n# The first non-comment line in this file indicates that\n# the whole file represents a function.\n{ pkgs ? import <nixpkgs> {} }:\n\nlet\n  # The let expression below defines a myEmacs binding pointing to the\n  # current stable version of Emacs. This binding is here to separate\n  # the choice of the Emacs binary from the specification of the\n  # required packages.\n  myEmacs = pkgs.emacs;\n  # This generates an emacsWithPackages function. It takes a single\n  # argument: a function from a package set to a list of packages\n  # (the packages that will be available in Emacs).\n  emacsWithPackages = (pkgs.emacsPackagesFor myEmacs).emacsWithPackages;\nin\n  # The rest of the file specifies the list of packages to install. In the\n  # example, two packages (magit and zerodark-theme) are taken from\n  # MELPA stable.\n  emacsWithPackages (epkgs: (with epkgs.melpaStablePackages; [\n    magit          # ; Integrate git <C-x g>\n    zerodark-theme # ; Nicolas' theme\n  ])\n  # Two packages (undo-tree and zoom-frm) are taken from MELPA.\n  ++ (with epkgs.melpaPackages; [\n    undo-tree      # ; <C-x u> to show the undo tree\n    zoom-frm       # ; increase/decrease font size for all buffers %lt;C-x C-+>\n  ])\n  # Three packages are taken from GNU ELPA.\n  ++ (with epkgs.elpaPackages; [\n    auctex         # ; LaTeX mode\n    beacon         # ; highlight my cursor when scrolling\n    nameless       # ; hide current package name everywhere in elisp code\n  ])\n  # notmuch is taken from a nixpkgs derivation which contains an Emacs mode.\n  ++ [\n    pkgs.notmuch   # From main packages set\n  ])\n\n```\n\n----------------------------------------\n\nTITLE: Natural Deduction Rules for Dependency Propagation in Nix\nDESCRIPTION: Formal specification of dependency propagation rules in Nix using Natural Deduction. These rules define how dependencies propagate across packages while accounting for platform offsets and cross-compilation considerations.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nlet mapOffset(h, t, i) = i + (if i <= 0 then h else t - 1)\n\npropagated-dep(h0, t0, A, B)\npropagated-dep(h1, t1, B, C)\nh0 + h1 in {-1, 0, 1}\nh0 + t1 in {-1, 0, 1}\n-------------------------------------- Transitive property\npropagated-dep(mapOffset(h0, t0, h1),\n               mapOffset(h0, t0, t1),\n               A, C)\n```\n\n----------------------------------------\n\nTITLE: Printing with std::cout - C++\nDESCRIPTION: Prints the string \\\"Hello world.\\\" to the standard output stream using std::cout from the iostream library in C++. Requires including the <iostream> header. This snippet demonstrates basic console output, doesn't take any input, and outputs a single line to the console. No additional setup or dependencies are needed aside from a C++ compiler.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/jupyter-kernels/xeus-cling/test.ipynb#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\\nstd::cout << \"Hello world.\";\n```\n\n----------------------------------------\n\nTITLE: Cloning and Checking Out SageMath Source with Git - Shell\nDESCRIPTION: This snippet demonstrates how to clone the SageMath source repository from GitHub and check out a specific version using git. It assumes the user has git installed and provides commands to clone the repo, navigate into it, and switch to the desired version. The key parameters are the repository URL and the target Sage version. Input: shell terminal; Output: a local checkout of the specified Sage version. Caution: Replace '9.8' with the desired SageMath version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/sa/sage/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n[user@localhost ~]$ git clone https://github.com/sagemath/sage.git\\n[user@localhost ~]$ cd sage\\n[user@localhost sage]$ git checkout 9.8 # substitute the relevant version here\n```\n\n----------------------------------------\n\nTITLE: Library Function Reexports\nDESCRIPTION: Standardized reexporting of builtin functions through the lib namespace for consistent access patterns.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2411.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\nlib.lists.map -> builtins.map\nlib.attrsets.intersectAttrs -> builtins.intersectAttrs\nlib.attrsets.removeAttrs -> builtins.removeAttrs\nlib.strings.match -> builtins.match\nlib.strings.split -> builtins.split\nlib.typeOf -> builtins.typeOf\nlib.unsafeGetAttrPos -> builtins.unsafeGetAttrPos\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Build-Time FUSE Header Detection Failure - Text\nDESCRIPTION: Shows the output from an autoconf-based build process when it cannot find the required fuse.h header. This error is common if the FUSE_USE_VERSION macro is not defined or when the headers are not properly detected during configuration. It helps maintainers understand when additional CFLAGS or build script changes are needed to progress a FUSE package build. Inputs are configure scripts and the expected output is an error 'No fuse.h found'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/fuse.section.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nchecking for fuse.h... no\\nconfigure: error: No fuse.h found.\n```\n\n----------------------------------------\n\nTITLE: Including Modular Networking Documentation Sections in Markdown\nDESCRIPTION: This snippet demonstrates the use of the '{=include=}' directive to incorporate multiple section-based markdown files into a unified documentation page. Dependencies include a markdown processor or static site generator that supports the '{=include=}' syntax. Key parameters are the paths to the respective section files, and the snippet enables modular content composition for easier upkeep and clarity. The expected output is a single documentation page with the contents of all specified sections inlined.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/networking.chapter.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} sections\\nnetwork-manager.section.md\\nssh.section.md\\nipv4-config.section.md\\nipv6-config.section.md\\nfirewall.section.md\\nwireless.section.md\\nad-hoc-network-config.section.md\\nrenaming-interfaces.section.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up systemd User Services in xinitrc - shell\nDESCRIPTION: Provides shell commands to integrate systemd user services with X sessions. Imports environment variables, starts graphical user target, and launches dbus-daemon for session management. Should be appended to xinitrc when using systemd user services for graphical environments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n# import required env variables from the current shell\nsystemctl --user import-environment DISPLAY XDG_SESSION_ID\n# start all graphical user services\nsystemctl --user start nixos-fake-graphical-session.target\n# start the user dbus daemon\ndbus-daemon --session --address=\"unix:path=/run/user/$(id -u)/bus\" &\n```\n\n----------------------------------------\n\nTITLE: Configuring PulseAudio for Additional Bluetooth Audio Codecs - Nix - Nix\nDESCRIPTION: Demonstrates how to enable support for additional Bluetooth codecs in PulseAudio, such as aptX or LDAC, by overriding the default package selection in NixOS configuration. Requires PulseAudio 15.0 or later and the appropriate hardware. The 'hardware.pulseaudio.package' attribute must be set to 'pkgs.pulseaudioFull'; this action enables codec switching via pavucontrol, replacing the deprecated third-party modules 'pulseaudio-modules-bt' and 'pulseaudio-hsphfpd'.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2205.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nhardware.pulseaudio.package = pkgs.pulseaudioFull;\n```\n\n----------------------------------------\n\nTITLE: Defining Deeply Nested Attribute Sets - Nix Language\nDESCRIPTION: Defines a nested attribute set structure in Nix, showcasing how deeply hierarchically organized data can be represented. The innermost value is an integer contained within several layers of attributes. No external dependencies; this demonstrates Nix's capacity for labeled, structured data. Input and output are strictly defined by the assigned hierarchy.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/pkgs-lib/formats/libconfig/test/comprehensive/expected.txt#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nnested={attrset={has={a={integer={value=100;};};};};level-dash=\"pass\";};\n```\n\n----------------------------------------\n\nTITLE: Using Local Patches in Nixpkgs\nDESCRIPTION: How to include local patch files in Nixpkgs packages. This is recommended when patches solve Nixpkgs-specific issues, are not yet merged upstream, or might disappear from external sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_12\n\nLANGUAGE: nix\nCODE:\n```\n{\n  patches = [ ./0001-add-missing-include.patch ];\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Gitea Service Data and PostgreSQL Database - Shell\nDESCRIPTION: This shell snippet provides the step-by-step commands necessary to completely migrate a Gitea instance (including state directory and PostgreSQL database) to Forgejo on NixOS. Dependencies include systemd for service management, PostgreSQL CLI tools (psql), and the presence of both gitea and forgejo users. Key steps involve stopping services, moving data, renaming Postgres user and database, changing file ownership, and restarting with the new service—ensuring state continuity during migration. Input paths, usernames, and service names may need adjustment for custom deployments.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/misc/forgejo.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nsystemctl stop gitea\nmv /var/lib/gitea /var/lib/forgejo\nrunuser -u postgres -- psql -c '\n  ALTER USER gitea RENAME TO forgejo;\n  ALTER DATABASE gitea RENAME TO forgejo;\n'\nnixos-rebuild switch\nsystemctl stop forgejo\nchown -R forgejo:forgejo /var/lib/forgejo\nsystemctl restart forgejo\n```\n\n----------------------------------------\n\nTITLE: Including Additional Service-Specific Chapters - Markdown\nDESCRIPTION: This snippet includes chapters focused on configuration profiles and specific services like Mattermost and Kubernetes using the '{=include=}' directive. It assumes that each referenced chapter file elaborates on configuration and management best practices for these systems. Dependencies are the same as previous include usages - a documentation framework capable of processing these directives. Inputs are specific chapter filenames, and outputs are the respective segments included in the final documentation. This approach keeps the documentation extensible and categorized by subsystem.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/configuration.md#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} chapters\nprofiles.chapter.md\nmattermost.chapter.md\nkubernetes.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Build Error Due to Mismatched Prelude Version\nDESCRIPTION: Shows the build error that occurs when trying to build a Dhall expression that depends on a different version of the Prelude than what's provided by default in Nixpkgs. The HTTP import is blocked due to integrity check mismatch.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_10\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix build --file ./example.nix dhallPackages.true\nbuilder for '/nix/store/0f1hla7ff1wiaqyk1r2ky4wnhnw114fi-true.drv' failed with exit code 1; last 10 log lines:\n\n  Dhall was compiled without the 'with-http' flag.\n\n  The requested URL was: https://prelude.dhall-lang.org/v19.0.0/package.dhall\n\n\n  4│       https://prelude.dhall-lang.org/v19.0.0/package.dhall\n  5│         sha256:eb693342eb769f782174157eba9b5924cf8ac6793897fc36a31ccbd6f56dafe2\n\n  /nix/store/rsab4y99h14912h4zplqx2iizr5n4rc2-true.dhall:4:7\n[1 built (1 failed), 0.0 MiB DL]\nerror: build of '/nix/store/0f1hla7ff1wiaqyk1r2ky4wnhnw114fi-true.drv' failed\n```\n\n----------------------------------------\n\nTITLE: Executing Patch Upgrade Script for K3s - Shell\nDESCRIPTION: Demonstrates how to perform a patch upgrade for a specific minor version of K3s using the provided update script from the root directory of the nixpkgs git repository. The command accepts a version string (e.g., \"30\") as an argument, triggering the patch update process for that series. The script must be present at './pkgs/applications/networking/cluster/k3s/update-script.sh'. Expected input is the version string, and output is the result of the patch process, used for automating K3s package updates.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/PKG_UPKEEP.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./pkgs/applications/networking/cluster/k3s/update-script.sh \"30\"\n```\n\n----------------------------------------\n\nTITLE: PowerPC Platform Check in NixOS\nDESCRIPTION: Platform check expression to replace the deprecated isPowerPC predicate. Checks for 32-bit big-endian POWER/PowerPC systems.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2211.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n(with foo; isPower && is32bit && isBigEndian)\n```\n\n----------------------------------------\n\nTITLE: Running Tester Test Suite with Nix-Build - Bash\nDESCRIPTION: This snippet illustrates how to navigate to the Nixpkgs repository and execute the testers test suite using nix-build with the -A attribute. It assumes that nix and nix-build are installed and that the user is in a shell environment with access to the Nixpkgs source directory. The first command changes the current directory to the nixpkgs root, and the second runs the test suite for tester functions. The output is the result of the test build, which will indicate pass/failure for the suite; no parameters are needed, but correct directory context is required.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/build-support/testers/test/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd nixpkgs\nnix-build -A tests.testers\n```\n\n----------------------------------------\n\nTITLE: Including Chapters in NixOS Manual\nDESCRIPTION: Defines a standalone chapter about contributing to the manual by including the corresponding markdown file.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/manual.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\ncontributing-to-this-manual.chapter.md\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring ACME in NixOS\nDESCRIPTION: Shows how to add custom flags to the Lego ACME client in NixOS, specifically for cases where the removed --reuse-key parameter is still needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\nsecurity.acme = {\n  certs = {\n    \"example.com\" = {\n      extraLegoRenewFlags = [ \"--reuse-key\" ];\n    };\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating the Initial Password File for SVN Auth - Command Line (Shell)\nDESCRIPTION: This shell command creates a new password file for SVN user authentication using Apache, specifying initial credentials. The -cs flags create the file and use SHA encryption for the password. Prerequisites: The `htpasswd` utility must be installed and write access to the password file location. Inputs: PASSWORD_FILE is the target file, USER_NAME is the initial user. Output: Encrypted password file for user authentication.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/subversion.chapter.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ htpasswd -cs PASSWORD_FILE USER_NAME\n```\n\n----------------------------------------\n\nTITLE: Setting Derivation Output Environment Variables with devShellTools (Nix)\nDESCRIPTION: Shows how to extract output-related environment variables from a derivation using devShellTools.derivationOutputEnv. This function is dependent on having a valid derivation object (such as hello) and the devShellTools library. It accepts an attribute set with outputList and outputMap, returning environment variables for the derivation’s outputs. Sample input includes a derivation’s outputs, with the function yielding environment variables as an attribute set, facilitating post-build scripting or analysis.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/dev-shell-tools.chapter.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\nlet\n  pkg = hello;\nin\ndevShellTools.derivationOutputEnv {\n  outputList = pkg.outputs;\n  outputMap = pkg;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JWE Secret with Tang Policy using Clevis (Shell)\nDESCRIPTION: This shell command creates a JWE file containing the secret \"hi\" using Clevis and a Tang server policy. It requires Clevis and access to a running Tang server at the specified URL. The \"url\" parameter specifies the Tang server endpoint that must be reachable during decryption. The resulting JWE file binds decryption to Tang server presence. The output file can later be specified for device auto-decryption.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/system/boot/clevis.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\necho -n hi | clevis encrypt tang '{\"url\": \"http://tang.local\"}' > hi.jwe\n```\n\n----------------------------------------\n\nTITLE: Including NixOS Installation Sub-Chapters in Markdown\nDESCRIPTION: A markdown include directive that references various sub-chapters related to NixOS installation, configuration, and maintenance. This directive appears to use a custom include syntax to compile multiple chapter files into a single document.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installation.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{=include=} chapters\nobtaining.chapter.md\ninstalling.chapter.md\nchanging-config.chapter.md\nupgrading.chapter.md\nbuilding-nixos.chapter.md\nbuilding-images-via-nixos-rebuild-build-image.chapter.md\nbuilding-images-via-systemd-repart.chapter.md\n```\n\n----------------------------------------\n\nTITLE: Steam Crash Error Example\nDESCRIPTION: Example error message showing segmentation fault caused by libcrypto conflicts with radeonsi_dri.so.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/steam.section.md#_snippet_1\n\nLANGUAGE: shellsession\nCODE:\n```\nsteam.sh: line 713: 7842 Segmentation fault (core dumped)\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Export Statement Generation using attrsOf str - Bash\nDESCRIPTION: This code section describes how an option of type attrsOf str in Nix can be used to auto-generate shell configuration files with environment variable export statements. The generated shell code follows the pattern export FOO=\"foo\" for each key/value pair. This is typically used as part of an automated configFile option when dealing with non-Nix-representable formats. No explicit code is shown, but the approach concerns generating such Bash shell lines from attribute sets.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/settings-options.section.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport FOO=\\\"foo\\\"\n```\n\n----------------------------------------\n\nTITLE: Building the Nixpkgs Manual Using nix-build - Shell\nDESCRIPTION: This snippet demonstrates how to quickly build the Nixpkgs reference manual using the nix-build command in a shell session. It requires Nix and access to the Nixpkgs repository. The inputs are the path to the Nixpkgs repo and the doc target; the build output will be produced in the ./result/share/doc/nixpkgs/manual.html path. This is a simple shell command sequence for checking manual edits.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ cd /path/to/nixpkgs\\n$ nix-build doc\n```\n\n----------------------------------------\n\nTITLE: Exporting Layered Docker Image with dockerTools - Nix\nDESCRIPTION: This Nix expression builds a layered Docker image using `dockerTools.buildLayeredImage` containing the `hello` package, then exports its filesystem tar archive using `dockerTools.exportImage`. It requires `dockerTools` and `hello` as dependencies. The `name` parameter specifies the output basename, and `fromImage` points to the layered image derivation. The expected output is a `.tar` or `.tar.gz` archive suitable for import or inspection, with contents defined by the included package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\n{ dockerTools, hello }:\ndockerTools.exportImage {\n  name = \"hello\";\n  fromImage = dockerTools.buildLayeredImage {\n    name = \"hello\";\n    contents = [ hello ];\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Hydra Build Report for Haskell Packages\nDESCRIPTION: These commands generate a build report from Hydra and create a Markdown document to notify maintainers of broken packages. It's used after Hydra finishes building updated packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/hydra-report.hs get-report\n$ ./maintainers/scripts/haskell/hydra-report.hs ping-maintainers\n```\n\n----------------------------------------\n\nTITLE: Creating an Admonition Block Using Fenced Divs - Markdown\nDESCRIPTION: This snippet illustrates how to define a warning admonition in Markdown using fenced divs with a class attribute. The input is any important warning content, and the output is a visually distinct block in rendered documentation. This pattern requires a Markdown renderer that supports the fenced divs extension.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_3\n\nLANGUAGE: Markdown\nCODE:\n```\n::: {.warning}\\nThis is a warning\\n:::\n```\n\n----------------------------------------\n\nTITLE: Building the Linux Kernel Using Nix - Build Command - ShellSession\nDESCRIPTION: This command initiates the build process for the new Linux kernel version in the Nixpkgs environment. The '-A' flag specifies the kernel attribute to build (in this case, kernel_2_6_22), assuming it was correctly updated and added to the kernels set. Output artifacts will be found in a result symlink. A full and successful build confirms correctness of prior configuration steps.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/README.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-build -A linuxKernel.kernels.kernel_2_6_22\n```\n\n----------------------------------------\n\nTITLE: Including Markdown Chapters in Documentation - Markdown\nDESCRIPTION: This code snippet uses the markdown {=include=} directive to insert the contents of specified chapter files into the overall documentation. Dependencies include the presence of the referenced files (functions.md and module-system/module-system.chapter.md) in the documentation directory. The snippet enables modular documentation by pulling in content dynamically, and is limited by the supported syntax of the documentation generation tool in use. The expected output is a compiled markdown page where the contents of the referenced files are inlined at the specified location.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/lib.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{=include=} chapters\\nfunctions.md\\nmodule-system/module-system.chapter.md\\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling TigerBeetle Service - Nix - Nix\nDESCRIPTION: This Nix code snippet demonstrates how to enable the TigerBeetle service by setting the services.tigerbeetle.enable option to true in the configuration.nix file. No additional dependencies are required beyond NixOS itself. This configuration will start the TigerBeetle service with default settings; no parameters or accounts need to be specified. The expected result is that the service becomes active with its default behavior, and no custom networking or replication is enabled.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/databases/tigerbeetle.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.tigerbeetle.enable = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Unmounting USB Partitions on Linux using ShellSession\nDESCRIPTION: This snippet demonstrates how to unmount all partitions on a USB device on Linux before writing an image. The command uses wildcards to unmount all mounted partitions for the specified device (e.g., sdb). This step ensures data safety and that the device is not in use before writing the ISO. Requires sudo privileges. Replace 'sdX' with the device identifier obtained from lsblk.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/installing-usb.section.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\nsudo umount /dev/sdX*\n```\n\n----------------------------------------\n\nTITLE: Debugging Steam Startup Issues with Strace\nDESCRIPTION: Command to trace system calls and signals to diagnose Steam startup failures.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/steam.section.md#_snippet_0\n\nLANGUAGE: shellsession\nCODE:\n```\nstrace steam\n```\n\n----------------------------------------\n\nTITLE: Defining Redirects Mapping Structure - JSON\nDESCRIPTION: This JSON snippet illustrates the canonical format for storing the mapping between documentation content identifiers and their historical and current output paths (e.g., HTML files with anchors). Each key represents a unique identifier, and the associated array lists the locations, with the first item being the current location. No external dependencies beyond JSON parsing are needed. Inputs are the current and previous output paths for each identifier, and this mapping is referenced by nixos-render-docs to generate redirects and ensure integrity during documentation builds.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-render-docs/README.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"<identifier>\": [\\n    \"index.html#<identifier>\",\\n    \"foo.html#foo\",\\n    \"bar.html#foo\"\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Priority Override Definition\nDESCRIPTION: Example of using mkOverride to set explicit priority for option definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-def.section.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.openssh.enable = mkOverride 10 false;\n}\n```\n\n----------------------------------------\n\nTITLE: Example ModuleNotFoundError Output - Shell (Python Error Traceback)\nDESCRIPTION: This command output snippet shows a typical Python error encountered during Azure CLI builds when a required module is missing. The error message guides maintainers to resolve such issues by identifying and updating missing dependencies in Nix expressions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nModuleNotFoundError: No module named 'azure.mgmt.storage.v2023_05_01'\n```\n\n----------------------------------------\n\nTITLE: Unpacking Linux Kernel Source Tree - Shell - ShellSession\nDESCRIPTION: These commands create a temporary directory and unpack the Linux kernel source into it using the provided Nix build phase helpers. They are used after entering nix-shell and assume access to unpackPhase via the Nix shell environment. 'pushd $(mktemp -d)' changes directory to a new temporary location, while 'unpackPhase' unpacks the kernel sources.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/README.md#_snippet_1\n\nLANGUAGE: ShellSession\nCODE:\n```\n[nix-shell]$ pushd $(mktemp -d)\n[nix-shell]$ unpackPhase\n```\n\n----------------------------------------\n\nTITLE: Migrated Dovecot2 Mailboxes Attribute Set Configuration - Nix\nDESCRIPTION: This updated snippet illustrates the recommended attribute set style for configuring Dovecot2 mailboxes within the NixOS configuration. Each mailbox is keyed by its name and can include additional mailbox parameters, such as 'auto'. This format is required from release 21.05 onwards and improves validity checking and future compatibility.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.dovecot2.mailboxes = {\n    Junk.auto = \"create\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Azure CLI Extension Metadata Output - JSON\nDESCRIPTION: This JSON object provides metadata for an Azure CLI extension, including its name, description, version, download URL, SHA256 hash, license, and required Python dependencies. The output is typically produced by the extension index query and is used to populate or update Nix derivations for Azure CLI extensions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"pname\\\": \\\"azure-devops\\\",\\n  \\\"description\\\": \\\"Tools for managing Azure DevOps.\\\",\\n  \\\"version\\\": \\\"1.0.1\\\",\\n  \\\"url\\\": \\\"https://github.com/Azure/azure-devops-cli-extension/releases/download/20240514.1/azure_devops-1.0.1-py2.py3-none-any.whl\\\",\\n  \\\"sha256\\\": \\\"f300d0288f017148514ebe6f5912aef10c7a6f29bdc0c916b922edf1d75bc7db\\\",\\n  \\\"license\\\": \\\"MIT\\\",\\n  \\\"requires\\\": [\\n    \\\"distro (==1.3.0)\\\",\\n    \\\"distro==1.3.0\\\"\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: External NixOS Test Configuration\nDESCRIPTION: Example of running NixOS tests outside the nixpkgs repository using runNixOSTest\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nlet pkgs = import <nixpkgs> {};\nin\n\npkgs.testers.runNixOSTest {\n  imports = [ ./test.nix ];\n  defaults.services.foo.package = mypkg;\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a User and Home Directory with userdel - ShellSession - ShellSession\nDESCRIPTION: This command deletes a user account ('alice') and their home directory using 'userdel -r'. The '-r' flag instructs the utility to remove the user's home directory and mail spool in addition to the account entry. Root privileges are required. Use with caution, as deleted data may be unrecoverable.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/user-mgmt.chapter.md#_snippet_6\n\nLANGUAGE: ShellSession\nCODE:\n```\n# userdel -r alice\n```\n\n----------------------------------------\n\nTITLE: Enabling AX.25 Support in Xastir Using libax25 - NixOS Package Integration - Markdown\nDESCRIPTION: This snippet highlights that Xastir, an amateur radio application, now has support for AX.25 interfaces by leveraging the libax25 package. This allows APRS and other radio communication through supported protocols. The feature is exposed through the system-level package integration and requires compatible hardware.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_20\n\nLANGUAGE: markdown\nCODE:\n```\n- [Xastir](https://xastir.org/index.php/Main_Page) can now access AX.25 interfaces via the \\`libax25\\` package.\n```\n\n----------------------------------------\n\nTITLE: Configuring ACME with DNS Validation using BIND in NixOS\nDESCRIPTION: This snippet shows how to configure ACME for DNS validation using BIND in NixOS. It includes setting up BIND, configuring ACME for DNS validation, and generating necessary secret files.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/security/acme/default.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.bind = {\n    enable = true;\n    extraConfig = ''\n      include \"/var/lib/secrets/dnskeys.conf\";\n    '';\n    zones = [\n      rec {\n        name = \"example.com\";\n        file = \"/var/db/bind/${name}\";\n        master = true;\n        extraConfig = \"allow-update { key rfc2136key.example.com.; };\";\n      }\n    ];\n  };\n\n  # Now we can configure ACME\n  security.acme.acceptTerms = true;\n  security.acme.defaults.email = \"admin+acme@example.com\";\n  security.acme.certs.\"example.com\" = {\n    domain = \"*.example.com\";\n    dnsProvider = \"rfc2136\";\n    environmentFile = \"/var/lib/secrets/certs.secret\";\n    # We don't need to wait for propagation since this is a local DNS server\n    dnsPropagationCheck = false;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Azure Extension Index using Shell Script - Shell\nDESCRIPTION: This shell command queries the Azure CLI extension index for metadata about a specific extension. It requires the script 'query-extension-index.sh' (supplied in the repository), the current Azure CLI version, and the desired extension name. The '--download' flag ensures the extension metadata is also downloaded. The command outputs extension information in JSON, which can be used for manual packaging.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/az/azure-cli/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./query-extension-index.sh --cli-version=2.61.0 --extension=azure-devops --download\n```\n\n----------------------------------------\n\nTITLE: Accepting Generic Arguments via '@'-Pattern in Nix Functions - Nix\nDESCRIPTION: This snippet demonstrates the recommended use of an '@'-pattern to capture all arguments in a Nix function while still making required arguments explicit. This is useful for functions that do additional processing or pass many arguments along, as with wrappers for mkDerivation. The example also shows conditional attribute definition within the derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_18\n\nLANGUAGE: nix\nCODE:\n```\n{ stdenv, doCoverageAnalysis ? false, ... } @ args:\n\nstdenv.mkDerivation (args // {\n  foo = if doCoverageAnalysis then \"bla\" else \"\";\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing SwiftPM Build Configurations in Nix Derivation\nDESCRIPTION: This Nix expression fragment specifies how to set a custom build configuration (e.g., 'debug' instead of the default 'release') for SwiftPM in a Nix derivation. The key parameter is `swiftpmBuildConfig`, accepted by the build environment when using `swiftpm2nix`. It is intended to be merged into the attribute set for a Nix derivation building Swift projects with SwiftPM.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/swift.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  swiftpmBuildConfig = \"debug\";\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Custom Ubuntu 20.04 VM Disk Image with Extra Packages using vmTools.diskImageFuns (Nix)\nDESCRIPTION: This example illustrates building an 8GiB Ubuntu 20.04 VM image with Firefox included, using the `diskImageFuns` utility from `vmTools`. Dependencies are Nixpkgs, `vmTools`, and the specific `diskImageFuns.ubuntu2004x86_64` image builder. Key parameters are `extraPackages` (list of distribution package names) and `size` (disk size in MiB). The output is a derivation producing a disk image tailored for further VM use or testing.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/vm-tools.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs }:\nwith pkgs;\nwith vmTools;\ndiskImageFuns.ubuntu2004x86_64 {\n  extraPackages = [ \"firefox\" ];\n  size = 8192;\n}\n```\n\n----------------------------------------\n\nTITLE: Reviewing Pull Requests Using nix run for Flake Usage (Shell)\nDESCRIPTION: This snippet shows how to leverage Nix flakes by using the nix run command to invoke nixpkgs-review for testing a given pull request. It requires a flake-enabled Nix installation and the nixpkgs repository to be available via the flake URI. The key parameter is the pull request number. The output is a report of buildable packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix run nixpkgs#nixpkgs-review -- pr 12345\n```\n\n----------------------------------------\n\nTITLE: Testing VA-API Installation with vainfo via nix-shell (ShellSession)\nDESCRIPTION: Shows how to quickly test VA-API setup by running vainfo via nix-shell, ensuring use of the libva-utils package regardless of global installation. Requires Nix and network access to fetch dependencies if not already installed. Output is driver and device information provided by vainfo.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/gpu-accel.chapter.md#_snippet_7\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-shell -p libva-utils --run vainfo\n```\n\n----------------------------------------\n\nTITLE: Updating an Existing Prometheus Exporter Module\nDESCRIPTION: This snippet demonstrates how to update an existing exporter module by renaming or removing options using mkRenamedOptionModule and mkRemovedOptionModule, with the nginx exporter as an example.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/monitoring/prometheus/exporters.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ config, lib, pkgs, options }:\n\nlet\n  cfg = config.services.prometheus.exporters.nginx;\nin\n{\n  port = 9113;\n  extraOpts = {\n    # additional module options\n    # ...\n  };\n  serviceOpts = {\n    # service configuration\n    # ...\n  };\n  imports = [\n    # 'services.prometheus.exporters.nginx.telemetryEndpoint' -> 'services.prometheus.exporters.nginx.telemetryPath'\n    (lib.mkRenamedOptionModule [ \"telemetryEndpoint\" ] [ \"telemetryPath\" ])\n\n    # removed option 'services.prometheus.exporters.nginx.insecure'\n    (lib.mkRemovedOptionModule [ \"insecure\" ] ''\n      This option was replaced by 'prometheus.exporters.nginx.sslVerify' which defaults to true.\n    '')\n    ({ options.warnings = options.warnings; })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Packaging a Lua Library Manually with toLuaModule - Nix Expression - nix\nDESCRIPTION: This code illustrates manual packaging of a Lua library in Nix by using toLuaModule to wrap a standard package derivation. The package (mynewlib) is exposed in an attribute set, and stdenv.mkDerivation provides the build logic. Prerequisites include stdenv and any Lua build inputs. The packaged module conforms to Nixpkgs Lua conventions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/lua.section.md#_snippet_9\n\nLANGUAGE: nix\nCODE:\n```\n{\n  mynewlib = toLuaModule (\n    stdenv.mkDerivation {\n      # ...\n    }\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Discouraged: Conditional List Construction with if-then-else (Nullable) in Nix - Nix\nDESCRIPTION: This snippet illustrates a discouraged method for conditionally adding elements to a list using an explicit conditional with null. Using lib.optional is preferred for easier reasoning about list types and for consistency, except in rare circumstances where null is needed as a workaround without forcing a mass rebuild.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = if stdenv.hostPlatform.isDarwin then [ iconv ] else null;\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing Multiple Plugins for Nomad Extra Settings - NixOS Option Fix - Markdown\nDESCRIPTION: This details a fix to services.nomad.extraSettingsPlugins, which now allows specifying more than one plugin in the configuration. It improves flexibility for advanced Nomad setups. This option depends on the Nomad service and accepts plugin paths or names as a list or array.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2305.section.md#_snippet_22\n\nLANGUAGE: markdown\nCODE:\n```\n- The option \\`services.nomad.extraSettingsPlugins\\` has been fixed to allow more than one plugin in the path.\n```\n\n----------------------------------------\n\nTITLE: Example NixOS Release Version Structure\nDESCRIPTION: A markdown table showing the version structure across three NixOS releases, demonstrating how K3s versions are managed and backported to maintain upgrade compatibility between releases.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/VERSIONING.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* NixOS 23.11\n  * k3s/k3s_1_27 (Release Version, patches backported)\n  * k3s_1_28 (Backported)\n  * k3s_1_29 (Backported)\n  * k3s_1_30 (Backported)\n* NixOS 24.05\n  * k3s/k3s_1_30 (Release Version, patches backported)\n  * k3s_1_31 (Backported)\n  * k3s_1_32 (Backported)\n* NixOS 24.11\n  * k3s/k3s_1_32 (Release Version, patches backported)\n```\n\n----------------------------------------\n\nTITLE: Concatenating Files with concatTextFile in Nix\nDESCRIPTION: This example shows how to use concatTextFile to concatenate multiple files into a single file in the Nix store.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_17\n\nLANGUAGE: nix\nCODE:\n```\nconcatTextFile\n  {\n    name = \"my-file\";\n    files = [\n      drv1\n      \"${drv2}/path/to/file\"\n    ];\n  }\n```\n\n----------------------------------------\n\nTITLE: Using import <nixpkgs> for Fetching External Projects in NixOS Modules\nDESCRIPTION: Example demonstrating the correct way to fetch external projects in NixOS modules. When downloading other projects to import their modules, pkgs should be replaced with (import <nixpkgs> {}).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\nlet\n  myProject = pkgs.fetchurl {\n    src = url;\n    sha256 = hash;\n  };\nin\n\n{\n  imports = [ \"${myProject}/module.nix\" ];\n}\n```\n\nLANGUAGE: nix\nCODE:\n```\n{ config, pkgs, ... }:\n\nlet\n  myProject = (import <nixpkgs> {}).fetchurl {\n    src = url;\n    sha256 = hash;\n  };\nin\n\n{\n  imports = [ \"${myProject}/module.nix\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Discouraged: Generic 'args' Passing for Nix mkDerivation - Nix\nDESCRIPTION: This snippet demonstrates a discouraged Nix pattern where the arguments set is passed through and attributes are accessed in a verbose and less clear manner using dotted notation. It is preferred to use explicit argument patterns for maintainability and clarity.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_19\n\nLANGUAGE: nix\nCODE:\n```\nargs:\n\nargs.stdenv.mkDerivation (args // {\n  foo = if args ? doCoverageAnalysis && args.doCoverageAnalysis then \"bla\" else \"\";\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Unix socket authentication for MySQL root user\nDESCRIPTION: SQL script to create a MySQL root user with Unix socket authentication. This is required when using the new declarative database configuration options in services.mysql if you previously had a password-protected root user.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1709.section.md#_snippet_2\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE USER 'root'@'%' IDENTIFIED BY '';\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n\n-- Optionally, delete the password-authenticated user:\n-- DROP USER 'root'@'localhost';\n```\n\n----------------------------------------\n\nTITLE: Conditionally Building Lists Using lib.optional in Nix - Nix\nDESCRIPTION: This snippet demonstrates the recommended approach to conditionally including elements in an attribute list in Nix, using lib.optional and related helper functions. This ensures correct typing (list or empty list) and improves consistency across the codebase, especially for buildInputs or similar attributes.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_22\n\nLANGUAGE: nix\nCODE:\n```\n{\n  buildInputs = lib.optional stdenv.hostPlatform.isDarwin iconv;\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Output Name with fetchurl and Multiple URLs - Nix Language\nDESCRIPTION: This Nix snippet customizes the name of the fetched output by specifying a 'name' attribute in addition to 'urls' and 'hash'. It's useful for ensuring a stable output name regardless of which URL actually succeeded. All other behavior matches fetchurl's multi-URL logic. This approach is common for reproducibility when upstream file names may vary.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/fetchers.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{ fetchurl }:\nfetchurl {\n  name = \"nixpkgs-version\";\n  urls = [\n    \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/does-not-exist\"\n    \"https://raw.githubusercontent.com/NixOS/nixpkgs/23.11/.version\"\n  ];\n  hash = \"sha256-BZqI7r0MNP29yGH5+yW2tjU9OOpOCEvwWKrWCv5CQ0I=\";\n}\n```\n\n----------------------------------------\n\nTITLE: Discouraged: Using Generic 'args' Parameter for Nix Functions - Nix\nDESCRIPTION: This snippet illustrates a discouraged pattern in Nix functions where all arguments are passed in a generic 'args' set and accessed via 'with' or attribute access. This style reduces discoverability of required parameters and should be avoided in favor of explicit parameter lists.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_16\n\nLANGUAGE: nix\nCODE:\n```\nargs: with args; <...>\n```\n\n----------------------------------------\n\nTITLE: Package Dependency Query Command\nDESCRIPTION: Shows how to query the dependencies of the hello package using nix-store command.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/images/dockertools.section.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ nix-store --query -R $(nix-build -A hello)\n/nix/store/i93s7xxblavsacpy82zdbn4kplsyq48l-libunistring-1.1\n/nix/store/ji01n9vinnj22nbrb86nx8a1ssgpilx8-libidn2-2.3.4\n/nix/store/ldrslljw4rg026nw06gyrdwl78k77vyq-xgcc-12.3.0-libgcc\n/nix/store/9y8pmvk8gdwwznmkzxa6pwyah52xy3nk-glibc-2.38-27\n/nix/store/zhl06z4lrfrkw5rp0hnjjfrgsclzvxpm-hello-2.12.1\n```\n\n----------------------------------------\n\nTITLE: Defining a FHS-Compatible X11 Environment Using buildFHSEnv in Nix\nDESCRIPTION: This Nix code defines a environment using buildFHSEnv for applications requiring a Filesystem Hierarchy Standard (FHS) layout, such as proprietary binaries. It imports Nixpkgs and applies buildFHSEnv with specified attributes, bundling both host-architecture and multi-architecture dependency packages, and uses bash as the entry script. The code requires Nixpkgs to be accessible at <nixpkgs>, and is intended for use within shell.nix; running nix-shell will drop the user into an FHS sandbox with the specified libraries present. Key parameters include targetPkgs (for x86_64), multiPkgs (for various arch libraries), runScript (the shell command to launch), and name (environment identifier).\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/fhs-environments.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\n\n(pkgs.buildFHSEnv {\n  name = \"simple-x11-env\";\n  targetPkgs =\n    pkgs:\n    (with pkgs; [\n      udev\n      alsa-lib\n    ])\n    ++ (with pkgs.xorg; [\n      libX11\n      libXcursor\n      libXrandr\n    ]);\n  multiPkgs =\n    pkgs:\n    (with pkgs; [\n      udev\n      alsa-lib\n    ]);\n  runScript = \"bash\";\n}).env\n```\n\n----------------------------------------\n\nTITLE: Complete Checkpoint Build Example in Nix\nDESCRIPTION: A full example demonstrating the checkpoint build process for the hello package. It creates checkpoint artifacts, modifies the package to display a different message, and builds the modified version incrementally.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/special/checkpoint-build.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  pkgs ? import <nixpkgs> { },\n}:\nlet\n  inherit (pkgs.checkpointBuildTools)\n    prepareCheckpointBuild\n    mkCheckpointBuild\n    ;\n  helloCheckpoint = prepareCheckpointBuild pkgs.hello;\n  changedHello = pkgs.hello.overrideAttrs (_: {\n    doCheck = false;\n    patchPhase = ''\n      sed -i 's/Hello, world!/Hello, Nix!/g' src/hello.c\n    '';\n  });\nin\nmkCheckpointBuild changedHello helloCheckpoint\n```\n\n----------------------------------------\n\nTITLE: Creating MySQL/MariaDB Non-Root User for Service Operation\nDESCRIPTION: SQL commands to create a dedicated non-root user required for MySQL/MariaDB operation with the updated systemd service configuration. This grants all privileges and must be run before upgrading.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2009.section.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nCREATE USER IF NOT EXISTS 'mysql'@'localhost' identified with unix_socket;\nGRANT ALL PRIVILEGES ON *.* TO 'mysql'@'localhost' WITH GRANT OPTION;\n```\n\n----------------------------------------\n\nTITLE: Fetching Git Source with git:// Protocol (Bad Practice)\nDESCRIPTION: An example of a bad practice when fetching source code using the git:// protocol, which won't be proxied. This approach is discouraged in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  src = fetchgit {\n    url = \"git://github.com/NixOS/nix.git\";\n    rev = \"1f795f9f44607cc5bec70d1300150bfefcef2aae\";\n    hash = \"sha256-7D4m+saJjbSFP5hOwpQq2FGR2rr+psQMTcyb1ZvtXsQ=\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Version testing with custom command and expected version string\nDESCRIPTION: Shows how to use testers.testVersion with a custom command and specific version string to check. This example runs 'leetcode -V' and verifies the output contains 'leetcode 0.4.2' as a whole word.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  version = \"0.4.2\";\n\n  passthru.tests.version = testers.testVersion {\n    package = leetcode-cli;\n    command = \"leetcode -V\";\n    version = \"leetcode ${version}\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Wrapped Fish Shell with Plugins in NixOS\nDESCRIPTION: This snippet demonstrates how to use the wrapFish function to create a custom Fish shell environment with specified plugins and configuration directories. It includes two plugins (pure and foreign-env) and a custom configuration directory path.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/fish.section.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nwrapFish {\n  pluginPkgs = with fishPlugins; [\n    pure\n    foreign-env\n  ];\n  completionDirs = [ ];\n  functionDirs = [ ];\n  confDirs = [ \"/path/to/some/fish/init/dir/\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Attributes Without Unnecessary String Interpolation - Nix\nDESCRIPTION: This snippet demonstrates the recommended way of assigning values to attributes in a Nix set without unnecessary string interpolation, thus preserving type and avoiding verbose syntax. Direct assignment is preferred when the source value is already a string.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_20\n\nLANGUAGE: nix\nCODE:\n```\n{\n  rev = version;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring vwifi Monitor (Spy) Node - NixOS - Nix\nDESCRIPTION: This NixOS config snippet sets up a monitor node capable of sniffing/spying on all Wi-Fi packets from other simulated nodes, as allowed by the vwifi spy interface. The node has a dedicated IP address and enables the relevant vwifi client and module options, including 'spy: true'. Dependencies are the NixOS vwifi module and compatible kernel/modules. Inputs specify MAC, IP, and server options. The node receives packets but does not join or serve the network; monitor mode only works if the vwifi server has its spy port open.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/testing-hardware-features.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nmonitor =\n  { config, ... }:\n  {\n    networking.interfaces.eth1.ipv4.addresses = lib.mkForce [\n      {\n        address = \"192.168.1.4\";\n        prefixLength = 24;\n      }\n    ];\n\n    services.vwifi = {\n      module = {\n        enable = true;\n        macPrefix = \"74:F8:F6:00:03\";\n      };\n      client = {\n        enable = true;\n        spy = true;\n        serverAddress = \"192.168.1.2\";\n      };\n    };\n```\n\n----------------------------------------\n\nTITLE: Setting Kernel Modules List Option - NixOS - nix\nDESCRIPTION: Specifies multiple kernel modules to load by assigning a list of strings to the 'boot.kernelModules' option. Elements are whitespace-separated and must be strings. Demonstrates usage of string lists in option definitions.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/config-file.section.md#_snippet_10\n\nLANGUAGE: nix\nCODE:\n```\n{\n  boot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ];\n}\n```\n\n----------------------------------------\n\nTITLE: Discouraged: Unnecessary String Interpolation in Nix Attribute Assignment - Nix\nDESCRIPTION: The snippet shows a discouraged Nix pattern where an attribute is assigned a value using redundant string interpolation. When the value is already a string, direct assignment should be used to simplify code and avoid unnecessary computation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_21\n\nLANGUAGE: nix\nCODE:\n```\n{\n  rev = \"${version}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Running lib.filesystem Tests with Bash Script - Bash\nDESCRIPTION: Outlines running file system-related tests for the 'lib.filesystem' sub-library via the 'tests/filesystem.sh' Bash script. The script is tailored for library-specific test cases and requires standard Unix shell tools.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/lib/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\ntests/filesystem.sh\n```\n\n----------------------------------------\n\nTITLE: Testing pkg-config modules with explicit module names in Nix\nDESCRIPTION: Shows how to verify that a package exposes specified pkg-config modules using testers.hasPkgConfigModules with explicitly provided module names rather than using the default from meta.pkgConfigModules.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/testers.chapter.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  passthru.tests.pkg-config = testers.hasPkgConfigModules {\n    package = finalAttrs.finalPackage;\n    moduleNames = [ \"libfoo\" ];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: JSON Response Format for Image Details\nDESCRIPTION: Example JSON response structure returned by the GET /image/details endpoints, providing metadata about an image including dimensions, content type, and creation timestamp.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/pict-rs.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"width\": 800,\n    \"height\": 537,\n    \"content_type\": \"image/webp\",\n    \"created_at\": [\n        2020,\n        345,\n        67376,\n        394363487\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Prelude Package with dhall-to-nixpkgs\nDESCRIPTION: Command to generate a Nix package file for a specific version of the Dhall Prelude. This allows overriding the default Prelude version to match the one required by a Dhall expression.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dhall.section.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ dhall-to-nixpkgs github https://github.com/dhall-lang/dhall-lang.git \\\n    --name Prelude \\\n    --directory Prelude \\\n    --rev v19.0.0 \\\n    > Prelude.nix\n```\n\n----------------------------------------\n\nTITLE: Starting Emacs Client Commands\nDESCRIPTION: Commands to connect to an Emacs daemon instance, including options for creating new frames in graphical or terminal mode.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/editors/emacs.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nemacsclient FILENAME\nemacsclient --create-frame  # opens a new frame (window)\nemacsclient --create-frame --tty  # opens a new frame on the current terminal\n```\n\n----------------------------------------\n\nTITLE: Validating NixOS Manual Edits with devmode in ShellSession\nDESCRIPTION: This snippet shows how to quickly validate edits to the NixOS manual using the devmode command in a nix-shell environment. It requires navigating to the manual directory and entering a nix-shell before running devmode.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/writing-documentation.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ cd /path/to/nixpkgs/nixos/doc/manual\n$ nix-shell\n[nix-shell:~]$ devmode\n```\n\n----------------------------------------\n\nTITLE: Setting Up Socat for Shell Proxy to NixOS Test VM\nDESCRIPTION: Command to set up socat as a proxy for shell access to a NixOS test VM. This creates a TCP server that can receive terminal input/output from the virtual machine.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ socat 'READLINE,PROMPT=$ ' tcp-listen:4444,reuseaddr\n```\n\n----------------------------------------\n\nTITLE: Suwayomi-Server Basic Authentication Configuration in NixOS\nDESCRIPTION: Shows how to set up basic authentication for the Suwayomi-Server web interface, including username and password file configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/web-apps/suwayomi-server.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{ ... }:\n\n{\n  services.suwayomi-server = {\n    enable = true;\n\n    openFirewall = true;\n\n    settings = {\n      server.port = 4567;\n      server = {\n        basicAuthEnabled = true;\n        basicAuthUsername = \"username\";\n\n        # NOTE: this is not a real upstream option\n        basicAuthPasswordFile = ./path/to/the/password/file;\n      };\n    };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Running Podman container with specific NVIDIA GPU\nDESCRIPTION: This command demonstrates how to run a Podman container with a specific NVIDIA GPU (in this case, GPU 0) exposed to the container.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/cuda.section.md#_snippet_11\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ podman run --rm -it --device=nvidia.com/gpu=0 ubuntu:latest nvidia-smi -L\nGPU 0: NVIDIA GeForce RTX 4090 (UUID: <REDACTED>)\n```\n\n----------------------------------------\n\nTITLE: Installing Azure CLI Extensions in NixOS\nDESCRIPTION: Example of installing Azure CLI with extensions using the new extension support. This demonstrates how to install the aks-preview extension for Azure CLI while maintaining immutability.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2405.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nenvironment.systemPackages = [\n  (azure-cli.withExtensions [ azure-cli.extensions.aks-preview ])\n];\n```\n\n----------------------------------------\n\nTITLE: Customizing Crystal Build Options in Nix\nDESCRIPTION: This snippet demonstrates how to override the default Crystal build options in a Nix derivation. It shows setting custom flags like --release and --verbose when building Crystal binaries.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/crystal.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\n{\n  crystalBinaries.mint.options = [\n    \"--release\"\n    \"--verbose\"\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute-Tagged Union Options with Submodules in NixOS (nix)\nDESCRIPTION: This Nix expression illustrates how to define an attribute-tagged union for an option, using submodules to capture multiple behaviors ('bounce', 'forward', 'drop') for a fictional packet routing service. Dependencies include the NixOS module system and 'lib' functions like mkOption and type combinators. The code details definition of both option schema and a sample configuration; key attributes are nested under rules, mapping protocol names ('http', 'ssh') to actions, each action taking its own submodule config. Inputs expect an attribute set following this structure; outputs are properly merged configurations. Limitations may include the need for all submodule option defaults and careful merging of user-provided values.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-types.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{ lib, ... }:\nlet inherit (lib) type mkOption;\nin {\n  options.toyRouter.rules = mkOption {\n    description = ''\n      Rules for a fictional packet routing service.\n    '';\n    type = types.attrsOf (\n      types.attrTag {\n        bounce = mkOption {\n          description = \"Send back a packet explaining why it wasn't forwarded.\";\n          type = types.submodule {\n            options.errorMessage = mkOption { … };\n          };\n        };\n        forward = mkOption {\n          description = \"Forward the packet.\";\n          type = types.submodule {\n            options.destination = mkOption { … };\n          };\n        };\n        drop = types.mkOption {\n          description = \"Drop the packet without sending anything back.\";\n          type = types.submodule {};\n        };\n      });\n  };\n  config.toyRouter.rules = {\n    http = {\n      bounce = {\n        errorMessage = \"Unencrypted HTTP is banned. You must always use https://.\";\n      };\n    };\n    ssh = { drop = {}; };\n  };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Filtering PHP Extensions in Nix\nDESCRIPTION: Shows how to exclude specific default extensions (in this case, opcache) while adding new ones (imagick) using the php.withExtensions function.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/php.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\nphp.withExtensions (\n  { enabled, all }: (lib.filter (e: e != php.extensions.opcache) enabled) ++ [ all.imagick ]\n)\n```\n\n----------------------------------------\n\nTITLE: Running Specific Chromium Variant Test\nDESCRIPTION: Command for testing a specific Chromium variant (in this case ungoogled-chromium) using NixOS VM tests. This allows targeting a specific browser implementation instead of running all tests.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/browsers/chromium/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnix-build nixos/tests/chromium.nix -A ungoogled\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Avahi Service Definitions in NixOS\nDESCRIPTION: This code snippet shows how to add custom Avahi service definitions using the services.avahi.extraServiceFiles option in NixOS configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1909.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nservices.avahi.extraServiceFiles\n```\n\n----------------------------------------\n\nTITLE: Running Android Environment Tests in NixOS\nDESCRIPTION: Commands to run the Android environment test suite. Requires setting the NIXPKGS_ALLOW_UNFREE environment variable and navigating to the nixpkgs directory before building the test suite.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/mobile/androidenv/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ export NIXPKGS_ALLOW_UNFREE=1\n$ cd path/to/nixpkgs\n$ nix-build -A androidenv.test-suite.tests\n```\n\n----------------------------------------\n\nTITLE: Setting up Git branch for Nixpkgs contribution\nDESCRIPTION: Commands to fetch latest changes from upstream Nixpkgs and create a new feature branch based on master\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure you have the latest changes from upstream Nixpkgs\ngit fetch upstream\n\n# Create and switch to a new branch based off the master branch in Nixpkgs\ngit switch --create update-hello upstream/master\n```\n\n----------------------------------------\n\nTITLE: Configuring Frobnicator Service Type in NixOS\nDESCRIPTION: Option to enable or disable frobnication of a specific type. This boolean option is defined in the frobnicator service module and can be set for individual named types.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/ni/nixos-render-docs/src/tests/sample_options_simple_legacy.md#_snippet_0\n\nLANGUAGE: nix\nCODE:\n```\nservices.frobnicator.types.<name>.enable\n```\n\n----------------------------------------\n\nTITLE: Configuring xcodebuild with Custom Flags\nDESCRIPTION: Example of setting up xcodebuild configuration with custom build flags and schema settings.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/platform-notes.chapter.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nstdenv.mkDerivation {\n  name = \"libfoo-1.2.3\";\n  xcbuildFlags = [\n    \"-configuration\"\n    \"Release\"\n    \"-project\"\n    \"libfoo-project.xcodeproj\"\n    \"-scheme\"\n    \"libfoo Package (macOS only)\"\n  ];\n  __structuredAttrs = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Nerd Fonts Directory Structure Change\nDESCRIPTION: Updated directory structure for Nerd Fonts installation, with fonts now organized in separate subdirectories under the NerdFonts directory.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/release-notes/rl-2505.section.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n$out/share/fonts/{opentype,truetype}/NerdFonts/<fontDirName>\n```\n\n----------------------------------------\n\nTITLE: Referencing Path to MIME Cache File\nDESCRIPTION: Shows the file system path where the MIME cache is typically located in NixOS packages. This file is removed during package setup to prevent conflicts.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/desktop-file-utils.section.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n$out/share/applications/mimeinfo.cache\n```\n\n----------------------------------------\n\nTITLE: Marking Broken Haskell Packages in Nixpkgs\nDESCRIPTION: This command marks broken Haskell packages in Nixpkgs configuration files and regenerates the package set. It updates various YAML files and creates a commit.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/mark-broken.sh --do-commit\n```\n\n----------------------------------------\n\nTITLE: Inline Anchor for Precise Linking in Markdown - Markdown\nDESCRIPTION: This example demonstrates how to use a bracketed span to define an inline anchor in Markdown, allowing links to point to specific list items or phrases. The input includes the bracketed span syntax with an ID attribute. It requires a Markdown processor that supports bracketed spans. The visible output is a regular list item, but linkable by the provided anchor.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/README.md#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n- []{#ssec-gnome-hooks-glib} `glib` setup hook will populate `GSETTINGS_SCHEMAS_PATH` and then `wrapGApps*` hook will prepend it to `XDG_DATA_DIRS`.\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Wingpanel Indicators in NixOS\nDESCRIPTION: Manual configuration to override the default Wingpanel indicators with custom ones. This adds to the default plugins unless useDefaultIndicators is set to false.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nwingpanel-with-indicators.override {\n  indicators = [\n    pkgs.some-special-indicator\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Running NixOS Test Driver with VM State Preservation\nDESCRIPTION: Command to run the NixOS test driver while preserving VM state from previous runs. The VM state is stored in a temporary directory for reuse.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/running-nixos-tests-interactively.section.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ ./result/bin/nixos-test-driver --keep-vm-state\n```\n\n----------------------------------------\n\nTITLE: Enabling Package Tests in NixOS Build\nDESCRIPTION: Example showing how to enable package tests by setting the doCheck flag to true in the derivation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/stdenv/stdenv.chapter.md#_snippet_25\n\nLANGUAGE: nix\nCODE:\n```\n{\n  doCheck = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Regenerating Haskell Package Set in Nixpkgs\nDESCRIPTION: This command regenerates the Haskell package set used in Nixpkgs and creates a commit. It's part of the initial haskell-updates PR process.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/development/haskell-modules/HACKING.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ ./maintainers/scripts/haskell/regenerate-hackage-packages.sh --do-commit\n```\n\n----------------------------------------\n\nTITLE: Generating NuGet Dependency Lockfile\nDESCRIPTION: Command to generate a JSON lockfile from NuGet packages using the nuget-to-json tool.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/dotnet.section.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ nuget-to-json out > deps.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Hime Input Method in NixOS\nDESCRIPTION: Configuration for enabling Hime, a lightweight input method framework supporting multiple input methods including Cangjie, Zhuyin, and others.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/i18n/input-method/default.md#_snippet_5\n\nLANGUAGE: nix\nCODE:\n```\n{\n  i18n.inputMethod = {\n    enable = true;\n    type = \"hime\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Cache Compression Configuration\nDESCRIPTION: Configuration for mkBinaryCache compression method, showing how to specify xz compression instead of the new zstd default.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/release-notes/rl-2505.section.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\ncompression = \"xz\";\n```\n\n----------------------------------------\n\nTITLE: Building NixOS Image with nixos-rebuild - ShellSession\nDESCRIPTION: Demonstrates how to build a NixOS image for a specific platform (e.g., Amazon) using the nixos-rebuild build-image command in a shell. Requires a working NixOS configuration and access to the nixos-rebuild tool. The --image-variant flag selects the target platform variant, and upon completion the resulting image is stored in the Nix store with a descriptive path. No input parameters beyond the CLI arguments are needed.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/installation/building-images-via-nixos-rebuild-build-image.chapter.md#_snippet_0\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nixos-rebuild build-image --image-variant amazon\\n[...]\\nDone. The disk image can be found in /nix/store/[hash]-nixos-image-amazon-25.05pre-git-x86_64-linux/nixos-image-amazon-25.05pre-git-x86_64-linux.vpc\n```\n\n----------------------------------------\n\nTITLE: Listing Available Eclipse Plugins in NixOS\nDESCRIPTION: This command lists all available Eclipse plugins that can be installed using the eclipseWithPlugins function in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/packages/eclipse.section.md#_snippet_2\n\nLANGUAGE: ShellSession\nCODE:\n```\n$ nix-env -f '<nixpkgs>' -qaP -A eclipses.plugins --description\n```\n\n----------------------------------------\n\nTITLE: Setting PATH Environment for Longhorn Container\nDESCRIPTION: PATH environment variable configuration to ensure Longhorn container works correctly on NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nPATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/run/wrappers/bin:/nix/var/nix/profiles/default/bin:/run/current-system/sw/bin\n```\n\n----------------------------------------\n\nTITLE: Overriding Coq Package Dependency in Nix\nDESCRIPTION: This snippet demonstrates how to use .override to change the mathcomp dependency of the multinomials package.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/coq.section.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nmultinomials.override {\n  mathcomp = my-special-mathcomp;\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Kodi Addon Configuration\nDESCRIPTION: Previous method of configuring Kodi with addons in NixOS.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2105.section.md#_snippet_7\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = [\n    pkgs.kodi\n  ];\n\n  nixpkgs.config.kodi = {\n    enableInputStreamAdaptive = true;\n    enableVFSSFTP = true;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting GPG_TTY Environment Variable - Shell\nDESCRIPTION: This snippet sets the GPG_TTY environment variable to the current terminal device, ensuring gpg-agent can correctly communicate with GnuPG clients that require a terminal. It should be placed in `~/.bashrc` or a similar shell-init file. Required for proper passphrase prompts when using GnuPG in interactive terminals.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1603.section.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nGPG_TTY=$(tty)\nexport GPG_TTY\n```\n\n----------------------------------------\n\nTITLE: Controlling Profiling for Haskell Packages\nDESCRIPTION: Functions to enable or disable profiling for executables and libraries in Haskell packages.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md#_snippet_33\n\nLANGUAGE: nix\nCODE:\n```\nenableExecutableProfiling drv\ndisableExecutableProfiling drv\nenableLibraryProfiling drv\ndisableLibraryProfiling drv\n```\n\n----------------------------------------\n\nTITLE: Extension Commit Message Template - Update\nDESCRIPTION: Template for git commit messages when updating an existing VSCode extension version.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/editors/vscode/extensions/README.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nvscode-extensions.publisher.extension-name: 1.2.3 -> 2.3.4\n\nRelease: https://github.com/owner/project/releases/tag/2.3.4\n```\n\n----------------------------------------\n\nTITLE: Setting GOPROXY Environment Variable\nDESCRIPTION: Configuration to set the GOPROXY environment variable for using Athens in Go builds outside of Nix.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/development/athens.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.variables = {\n    GOPROXY = \"http://localhost:3000\";\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Check Oldest Supported Release Command\nDESCRIPTION: Nix command to find the oldest supported release version in the NixOS system.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nnix-instantiate --eval -A lib.trivial.oldestSupportedRelease\n```\n\n----------------------------------------\n\nTITLE: Rebasing on upstream master\nDESCRIPTION: Git commands to rebase local branch on top of upstream master to resolve conflicts\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch upstream\ngit rebase upstream/master\ngit push --force-with-lease\n```\n\n----------------------------------------\n\nTITLE: Configuring NFS Support in NixOS\nDESCRIPTION: NixOS configuration to enable NFS filesystem support and RPC bind service.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/applications/networking/cluster/k3s/docs/examples/STORAGE.md#_snippet_3\n\nLANGUAGE: nix\nCODE:\n```\nboot.supportedFilesystems = [ \"nfs\" ];\nservices.rpcbind.enable = true;\n```\n\n----------------------------------------\n\nTITLE: Installing Package Extensions in NixOS\nDESCRIPTION: Example showing how to install packages with extensions, specifically demonstrating pass password manager and Python package extensions configuration.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/customizing-packages.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  environment.systemPackages = with pkgs; [\n    sl\n    (pass.withExtensions (subpkgs: with subpkgs; [\n      pass-audit\n      pass-otp\n      pass-genphrase\n    ]))\n    (python3.withPackages (subpkgs: with subpkgs; [\n        requests\n    ]))\n    cowsay\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Default Package Attributes in Nix\nDESCRIPTION: Shows the default arguments passed to package definitions in Nixpkgs.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/by-name/README.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib = pkgs.lib;\n  stdenv = pkgs.stdenv;\n  libbar = pkgs.libbar;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Pantheon Applications in NixOS\nDESCRIPTION: Configuration to prevent installation of Pantheon's default applications when enabling the desktop environment.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/modules/services/x11/desktop-managers/pantheon.md#_snippet_2\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.pantheon.apps.enable = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Package Directory in Bash\nDESCRIPTION: Command to create a new package directory following the Nixpkgs naming convention.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/pkgs/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir -p pkgs/by-name/so/some-package\n```\n\n----------------------------------------\n\nTITLE: Pushing changes to Nixpkgs fork\nDESCRIPTION: Git commands for pushing local changes to your fork of Nixpkgs repository\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit push --set-upstream origin HEAD\n```\n\n----------------------------------------\n\nTITLE: Patching Fish Init Script with patchRcPath in Nix Derivation - Nix\nDESCRIPTION: Illustrates a Nix expression for patching a Fish shell init script within a Nix derivation. Sets patchRcPathFish as a native build input, and uses a postFixup phase to call the patcher with a constructed PATH including coreutils, man, and which. The snippet demonstrates standard Nix package customization practices and function injection. Requires the patchRcPathFish utility and its dependencies to be available during build.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/hooks/patch-rc-path-hooks.section.md#_snippet_1\n\nLANGUAGE: nix\nCODE:\n```\n{\n  lib,\n  stdenv,\n  patchRcPathFish,\n}:\nstdenv.mkDerivation {\n\n  # ...\n\n  nativeBuildInputs = [\n    patchRcPathFish\n  ];\n\n  postFixup = ''\n    patchRcPathFish $out/bin/this-foo.fish ${\n      lib.makeBinPath [\n        coreutils\n        man\n        which\n      ]\n    }\n  '';\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Nix sandboxing configuration\nDESCRIPTION: Configuration snippet to enable sandboxing in Nix builds\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\nsandbox = true\n```\n\n----------------------------------------\n\nTITLE: Extensible Option Type SDDM Backend\nDESCRIPTION: Shows how to extend the display manager option type in the SDDM backend module.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/development/option-declarations.section.md#_snippet_8\n\nLANGUAGE: nix\nCODE:\n```\n{\n  services.xserver.displayManager.enable = mkOption {\n    type = with types; nullOr (enum [ \"sddm\" ]);\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Including Module Chapters Dynamically Using a Template Variable - Markdown\nDESCRIPTION: This snippet demonstrates the dynamic inclusion of markdown chapters using the '{=include=}' directive and a template variable ('@MODULE_CHAPTERS@'). The directive expects the build or templating system to substitute this variable with a list of additional chapter files before rendering. Dependencies include the documentation build process supporting both the include directive and templating variables. The input is the template variable, and the output is the expanded and included list of chapter files. This approach enables flexible and automatic inclusion of different modules during documentation generation.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/configuration.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n```{=include=} chapters\n@MODULE_CHAPTERS@\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Haskell Packages - nix-env Query - ShellSession\nDESCRIPTION: Runs a nix-env command to list all available Haskell packages from the Nixpkgs collection using attribute selection. Requires Nix installed and a channel available as '<nixpkgs>'. Inputs: none specific, run as a shell command. Output: a tabular list of package names and their descriptions filtered from the Haskell package set.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-1509.section.md#_snippet_3\n\nLANGUAGE: ShellSession\nCODE:\n```\nnix-env -f \"<nixpkgs>\" -qaP -A haskellPackages\n```\n\n----------------------------------------\n\nTITLE: Displaying Custom PAM Rule Line for LightDM - Nix\nDESCRIPTION: This code snippet represents a single line from a PAM configuration for LightDM. It demonstrates a permissive authentication rule. This is referenced as the custom rule allowing all users, including root, to authenticate without restriction.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/release-notes/rl-2003.section.md#_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\nauth required pam_succeed_if.so quiet\n```\n\n----------------------------------------\n\nTITLE: Sample Window Manager Startup in xinitrc - shell\nDESCRIPTION: This snippet exemplifies manually starting background utilities (sxhkd) and a window manager (bspwm) within a user-created xinitrc file. Each process is backgrounded. Users must ensure these binaries are installed and in PATH.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/nixos/doc/manual/configuration/x-windows.chapter.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nsxhkd &\nbspwm &\n```\n\n----------------------------------------\n\nTITLE: Writing Direct Store References to File - writeDirectReferencesToFile - Nix\nDESCRIPTION: This snippet shows how to list all direct store path references from a Nix derivation output using writeDirectReferencesToFile. Given an output path (such as created via writeScriptBin), it produces a file enumerating only immediate dependencies, analogous to running 'nix-store -q --references'. This is limited to direct references and excludes deeper dependency chains.\nSOURCE: https://github.com/nixos/nixpkgs/blob/master/doc/build-helpers/trivial-build-helpers.chapter.md#_snippet_23\n\nLANGUAGE: nix\nCODE:\n```\nwriteDirectReferencesToFile (writeScriptBin \"hi\" ''${hello}/bin/hello'')\n```"
  }
]