[
  {
    "owner": "grahamdumpleton",
    "repo": "wrapt",
    "content": "TITLE: Creating Basic Function Decorator with Wrapt\nDESCRIPTION: Demonstrates how to create a basic pass-through decorator using wrapt.decorator. The wrapper function takes four required arguments: wrapped, instance, args, and kwargs.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Universal Decorator Implementation with Wrapt\nDESCRIPTION: Implements a universal decorator that can handle all function types (normal functions, instance methods, class methods, static methods, and classes) with proper type checking.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\n@wrapt.decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Creating a Universal Decorator for All Function Types with Wrapt\nDESCRIPTION: This example demonstrates how to create a universal decorator that behaves correctly in all situations: when applied to functions, static methods, instance methods, class methods, or classes. It uses inspection to determine the type of the wrapped object and instance.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/README.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\n@wrapt.decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Complete Context-Aware Synchronization Decorator in Python\nDESCRIPTION: Full-featured synchronization decorator that handles all contexts including functions, instance methods, class methods, and class decorators. Uses a meta lock for thread-safe lock creation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    # Use the instance as the context if function was bound.\n\n    if instance is not None:\n        context = instance\n    else:\n        context = wrapped\n\n    # Retrieve the lock for the specific context.\n\n    lock = vars(context).get('_synchronized_lock', None)\n\n    if lock is None:\n        # There is no existing lock defined for the context we\n        # are dealing with so we need to create one. This needs\n        # to be done in a way to guarantee there is only one\n        # created, even if multiple threads try and create it at\n        # the same time. We can't always use the setdefault()\n        # method on the __dict__ for the context. This is the\n        # case where the context is a class, as __dict__ is\n        # actually a dictproxy. What we therefore do is use a\n        # meta lock on this wrapper itself, to control the\n        # creation and assignment of the lock attribute against\n        # the context.\n\n        meta_lock = vars(synchronized).setdefault(\n                '_synchronized_meta_lock', threading.Lock())\n\n        with meta_lock:\n            # We need to check again for whether the lock we want\n            # exists in case two threads were trying to create it\n            # at the same time and were competing to create the\n            # meta lock.\n\n            lock = vars(context).get('_synchronized_lock', None)\n\n            if lock is None:\n                lock = threading.RLock()\n                setattr(context, '_synchronized_lock', lock)\n\n    with lock:\n        return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Universal Decorator Implementation\nDESCRIPTION: Final implementation of a universal decorator that handles all cases: functions, instance methods, class methods, and classes\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Creating a Parameterized Decorator with Wrapt\nDESCRIPTION: This example shows how to create a decorator that accepts arguments. It uses a function closure where the outer function accepts decorator arguments and returns the actual decorator. The wrapper function has access to these arguments when the decorated function is called.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/README.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\ndef with_arguments(myarg1, myarg2):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return wrapper\n\n@with_arguments(1, 2)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments Decorator Implementation\nDESCRIPTION: Demonstrates creating a decorator with optional arguments that can be used with or without parentheses.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\ndef with_optional_arguments(wrapped=None, *, myarg1=1, myarg2=2):\n    if wrapped is None:\n        return functools.partial(with_optional_arguments,\n                myarg1=myarg1, myarg2=myarg2)\n\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n    return wrapper(wrapped)\n```\n\n----------------------------------------\n\nTITLE: Custom Callable Wrapper Implementation in Python\nDESCRIPTION: Implements a custom wrapper class that adds entry/exit logging around function calls using wrapt.ObjectProxy.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef function():\n    print('executing', function.__name__)\n\nclass CallableWrapper(wrapt.ObjectProxy):\n\n    def __call__(self, *args, **kwargs):\n        print('entering', self.__wrapped__.__name__)\n        try:\n            return self.__wrapped__(*args, **kwargs)\n        finally:\n            print('exiting', self.__wrapped__.__name__)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Pass-Through Decorator with Wrapt\nDESCRIPTION: This snippet demonstrates how to create a simple pass-through decorator using wrapt. The decorator takes the wrapped function, instance, args, and kwargs as parameters, and simply calls the wrapped function with the provided arguments.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/README.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Creating a Universal Decorator with wrapt in Python\nDESCRIPTION: Demonstrates how to implement a universal decorator that can be applied to functions, methods, static methods, class methods, and classes. It uses inspect to determine the context and adjust behavior accordingly.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/quick-start.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\n@wrapt.decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Decorator with Arguments using wrapt in Python\nDESCRIPTION: Shows how to create a decorator that accepts arguments. The decorator is wrapped in a function closure, allowing access to the decorator arguments within the inner wrapper function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/quick-start.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\ndef with_arguments(myarg1, myarg2):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return wrapper\n\n@with_arguments(1, 2)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Basic Function Wrapper Implementation in Python\nDESCRIPTION: Demonstrates a basic wrapper function implementation that handles different types of wrapped objects including classes, static methods, class methods and instance methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\ndef wrapper(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Universal Decorator Base Classes in Python\nDESCRIPTION: This code defines two classes, bound_function_wrapper and function_wrapper, which form the foundation of a universal decorator. These classes handle the wrapping of functions and methods, distinguishing between different types of callables.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n\n    def __call__(self, *args, **kwargs):\n        if self.instance is None:\n            instance, args = args[0], args[1:]\n            wrapped = functools.partial(self.wrapped, instance)\n            return self.wrapper(wrapped, instance, args, kwargs)\n        return self.wrapper(self.wrapped, self.instance, args, kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Complete Function Wrapper Implementation - Python\nDESCRIPTION: Final implementation of the function wrapper system with support for multiple levels of binding and proper descriptor protocol handling.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper, binding, parent):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n        self.binding = binding\n        self.parent = parent\n\n    def __call__(self, *args, **kwargs):\n        if self.binding == 'function':\n            if self.instance is None:\n                instance, args = args[0], args[1:]\n                wrapped = functools.partial(self.wrapped, instance)\n                return self.wrapper(wrapped, instance, args, kwargs)\n            else:\n                return self.wrapper(self.wrapped, self.instance, args, kwargs)\n        else:\n            instance = getattr(self.wrapped, '__self__', None)\n            return self.wrapper(self.wrapped, instance, args, kwargs)\n\n    def __get__(self, instance, owner):\n        if self.instance is None and self.binding == 'function':\n            descriptor = self.parent.wrapped.__get__(instance, owner)\n            return bound_function_wrapper(descriptor, instance, self.wrapper,\n                    self.binding, self.parent)\n        return self\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n        if isinstance(wrapped, classmethod):\n            self.binding = 'classmethod'\n        elif isinstance(wrapped, staticmethod):\n            self.binding = 'staticmethod'\n        else:\n            self.binding = 'function'\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper,\n                self.binding, self)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Complete Decorator Implementation with Proxy Classes\nDESCRIPTION: Full implementation of the decorator pattern including proxy classes for object and function wrapping, supporting all Python function types.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/06-maintaining-decorator-state-using-a-class.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass object_proxy(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__name__ = wrapped.__name__\n        except AttributeError:\n            pass\n\n    @property\n    def __class__(self):\n        return self.wrapped.__class__\n\n    def __getattr__(self, name):\n        return getattr(self.wrapped, name)\n\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper, binding, parent):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n        self.binding = binding\n        self.parent = parent\n\n    def __call__(self, *args, **kwargs):\n        if self.binding == 'function':\n            if self.instance is None:\n                instance, args = args[0], args[1:]\n                wrapped = functools.partial(self.wrapped, instance)\n                return self.wrapper(wrapped, instance, args, kwargs)\n            else:\n                return self.wrapper(self.wrapped, self.instance, args, kwargs)\n        else:\n            instance = getattr(self.wrapped, '__self__', None)\n            return self.wrapper(self.wrapped, instance, args, kwargs)\n\n    def __get__(self, instance, owner):\n        if self.instance is None and self.binding == 'function':\n            descriptor = self.parent.wrapped.__get__(instance, owner)\n            return bound_function_wrapper(descriptor, instance, self.wrapper,\n                    self.binding, self.parent)\n        return self\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n        if isinstance(wrapped, classmethod):\n            self.binding = 'classmethod'\n        elif isinstance(wrapped, staticmethod):\n            self.binding = 'staticmethod'\n        else:\n            self.binding = 'function'\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper,\n                self.binding, self)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n\ndef decorator(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n```\n\n----------------------------------------\n\nTITLE: Simple Decorator Factory using FunctionWrapper\nDESCRIPTION: Shows how to create a simple decorator factory using wrapt.FunctionWrapper to delegate execution of wrapped functions.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef function_wrapper(wrapper):\n    @functools.wraps(wrapper)\n    def _wrapper(wrapped):\n        return FunctionWrapper(wrapped, wrapper)\n    return _wrapper\n```\n\n----------------------------------------\n\nTITLE: Creating a Decorator Factory in Python\nDESCRIPTION: This snippet defines a decorator factory function that uses the function_wrapper class to create decorators. It simplifies the process of creating new decorators by handling the boilerplate code.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef decorator(wrapper):\n    @functools.wraps(wrapper)\n    def _decorator(wrapped):\n        return function_wrapper(wrapped, wrapper)\n    return _decorator\n```\n\n----------------------------------------\n\nTITLE: Implementing Universal Decorator with wrapt\nDESCRIPTION: Demonstrates creation of a universal decorator that can be applied to classes, functions, static methods, class methods, and instance methods. The decorator can determine the context in which it was applied.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\nimport inspect\n\n@wrapt.decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # Decorator was applied to a class.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to a function or staticmethod.\n            return wrapped(*args, **kwargs)\n    else:\n        if inspect.isclass(instance):\n            # Decorator was applied to a classmethod.\n            return wrapped(*args, **kwargs)\n        else:\n            # Decorator was applied to an instancemethod.\n            return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Class Decoration with Wrapt\nDESCRIPTION: Shows how to apply decorators to classes and handle super() calls in both Python 2 and 3 contexts.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\nclass Class(object):\n    pass\n\nc = Class()\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator Pattern with Function Wrappers in Python\nDESCRIPTION: A pattern for implementing decorators using object proxies and descriptors. The implementation provides separate function wrappers for bound and unbound methods, properly handling the descriptor protocol.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped):\n        super(bound_function_wrapper, self).__init__(wrapped)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped):\n       super(function_wrapper, self).__init__(wrapped)\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__( instance, owner)\n        return bound_function_wrapper(wrapped)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Universal Decorator Pattern\nDESCRIPTION: Demonstrates the intended universal decorator pattern that can handle different method types and contexts.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef universal(wrapped, instance, args, kwargs):\n    if instance is None:\n        if inspect.isclass(wrapped):\n            # class.\n        else:\n            # function or staticmethod.\n    else:\n        if inspect.isclass(instance):\n            # classmethod.\n        else:\n            # instancemethod.\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator with Arguments\nDESCRIPTION: Shows how to create a decorator that accepts arguments using function closure. The outer function captures decorator arguments while the inner wrapper handles the decorated function execution.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\ndef with_arguments(myarg1, myarg2):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return wrapper\n\n@with_arguments(1, 2)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Function Wrapper with Descriptor Protocol in Python\nDESCRIPTION: Implements a comprehensive function wrapper that properly handles bound methods using the descriptor protocol.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass BoundCallableWrapper(wrapt.ObjectProxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(BoundCallableWrapper, self).__init__(wrapped)\n        self._self_wrapper = wrapper\n\n    def __get__(self, instance, owner):\n        return self\n\n    def __call__(self, *args, **kwargs):\n        return self._self_wrapper(self.__wrapped__, args, kwargs)\n\nclass CallableWrapper(wrapt.ObjectProxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(CallableWrapper, self).__init__(wrapped)\n        self._self_wrapper = wrapper\n\n    def __get__(self, instance, owner):\n        function = self.__wrapped__.__get__(instance, owner)\n        return BoundCallableWrapper(function, self._self_wrapper)\n\n    def __call__(self, *args, **kwargs):\n        return self._self_wrapper(self.__wrapped__, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Proxy Based Function Wrappers in Python\nDESCRIPTION: Creates two wrapper classes that use object proxy to handle both bound and unbound function wrapping scenarios. The implementation preserves function attributes and supports proper inspection through __get__ and __call__ methods. This approach eliminates the need for update_wrapper() and handles attribute access transparently.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped):\n        super(bound_function_wrapper, self).__init__(wrapped)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped):\n       super(function_wrapper, self).__init__(wrapped)\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__( instance, owner)\n        return bound_function_wrapper(wrapped)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Python Decorator Syntax\nDESCRIPTION: Shows the basic syntax for applying a decorator to a function using the @ symbol, introduced in Python 2.4. Compares it to the equivalent pre-2.4 syntax.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@function_wrapper\ndef function():\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\ndef function():\n    pass\n\nfunction = function_wrapper(function)\n```\n\n----------------------------------------\n\nTITLE: Function Wrapper Decorator Implementation\nDESCRIPTION: Implementation of a decorator that prints wrapped object, instance, and arguments information\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    print('WRAPPED', wrapped)\n    print('INSTANCE', instance)\n    print('ARGS', args)\n    return wrapped(*args, **kwargs)\n\n@my_function_wrapper\ndef function(a, b):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Python Flexible Synchronized Decorator\nDESCRIPTION: Enhanced Python synchronized decorator supporting both automatic and manual lock specification.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped=None, lock=None):\n    if wrapped is None:\n        return functools.partial(synchronized, lock=lock)\n    if lock is None:\n        lock = threading.RLock()\n    @functools.wraps(wrapped)\n    def _wrapper(*args, **kwargs):\n        with lock:\n            return wrapped(*args, **kwargs)\n    return _wrapper\n\n@synchronized\ndef function1():\n    pass\n\nlock = threading.Lock()\n\n@synchronized(lock=lock)\ndef function2():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Pass-Through Decorator with Wrapt\nDESCRIPTION: Demonstrates how to create a simple pass-through decorator using the wrapt.decorator factory. This example shows the basic structure of a wrapt decorator that maintains the original function's behavior.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing a Function Wrapper Using a Class\nDESCRIPTION: Demonstrates how to create a function wrapper using a class with __init__ and __call__ methods. This approach allows for more complex wrapper logic.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n\n@function_wrapper\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Basic Synchronized Decorator Implementation\nDESCRIPTION: Initial implementation of a synchronized decorator that handles function, method and class synchronization using threading locks.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/08-the-synchronized-decorator-as-context-manager.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    if instance is None:\n        owner = wrapped\n    else:\n        owner = instance\n\n    lock = vars(owner).get('_synchronized_lock', None)\n\n    if lock is None:\n        meta_lock = vars(synchronized).setdefault(\n                '_synchronized_meta_lock', threading.Lock())\n\n        with meta_lock:\n            lock = vars(owner).get('_synchronized_lock', None)\n            if lock is None:\n                lock = threading.RLock()\n                setattr(owner, '_synchronized_lock', lock)\n\n    with lock:\n        return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Signature Changing Decorator Implementation\nDESCRIPTION: Demonstrates how to create decorators that modify function signatures using adapter prototypes and dynamic signature generation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef _my_adapter_prototype(arg1, arg2): pass\n\n@wrapt.decorator(adapter=_my_adapter_prototype)\ndef my_adapter(wrapped, instance, args, kwargs):\n    \"\"\"Adapter documentation.\"\"\"\n\n    def _execute(arg1, arg2, *_args, **_kwargs):\n        return wrapped(arg1*arg2, *_args, **_kwargs)\n\n    return _execute(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Pass-Through Decorator with wrapt in Python\nDESCRIPTION: Demonstrates how to create a simple pass-through decorator using the wrapt library. This decorator doesn't modify the function's behavior but showcases the basic structure of a wrapt decorator.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/quick-start.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing a Function Wrapper Using a Closure\nDESCRIPTION: Shows how to create a function wrapper using a closure, which is a more popular approach due to its simplicity. The nested function acts as the wrapper.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef function_wrapper(wrapped):\n    def _wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper\n\n@function_wrapper\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Core Synchronized Decorator Implementation\nDESCRIPTION: Implementation of the synchronized decorator that handles both function decoration and context manager functionality using FunctionWrapper\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped):\n    def _synchronized_lock(context):\n        lock = vars(context).get('_synchronized_lock', None)\n\n        if lock is None:\n            meta_lock = vars(synchronized).setdefault(\n                    '_synchronized_meta_lock', Lock())\n\n            with meta_lock:\n                lock = vars(context).get('_synchronized_lock', None)\n\n                if lock is None:\n                    lock = RLock()\n                    setattr(context, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        with _synchronized_lock(instance or wrapped):\n            return wrapped(*args, **kwargs)\n\n    class _FinalDecorator(FunctionWrapper):\n        def __enter__(self):\n            self._self_lock = _synchronized_lock(self.__wrapped__)\n            self._self_lock.acquire()\n            return self._self_lock\n\n        def __exit__(self, *args):\n            self._self_lock.release()\n\n    return _FinalDecorator(wrapped=wrapped, wrapper=_synchronized_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Context Manager Enhanced Synchronized Implementation\nDESCRIPTION: Final implementation of synchronized decorator that supports both decorator and context manager usage patterns.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/08-the-synchronized-decorator-as-context-manager.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped):\n    def _synchronized_lock(owner):\n        lock = vars(owner).get('_synchronized_lock', None)\n\n        if lock is None:\n            meta_lock = vars(synchronized).setdefault(\n                    '_synchronized_meta_lock', threading.Lock())\n\n            with meta_lock:\n                lock = vars(owner).get('_synchronized_lock', None)\n                if lock is None:\n                    lock = threading.RLock()\n                    setattr(owner, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        with _synchronized_lock(instance or wrapped):\n            return wrapped(*args, **kwargs)\n\n    class _synchronized_function_wrapper(function_wrapper):\n\n        def __enter__(self):\n            self._lock = _synchronized_lock(self.wrapped)\n            self._lock.acquire()\n            return self._lock\n\n        def __exit__(self, *args):\n            self._lock.release()\n\n    return _synchronized_function_wrapper(wrapped, _synchronized_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Decorator with Arguments Using Function Closure\nDESCRIPTION: Implementation of a decorator that accepts arguments using a function closure pattern, allowing access to decorator arguments when the wrapper is called.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef with_arguments(arg):\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper\n\n@with_arguments(arg=1)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Preserving Function Metadata in Wrappers\nDESCRIPTION: Demonstrates how to manually copy function metadata to preserve introspection capabilities, and introduces the functools.wraps decorator as a more convenient solution.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef function_wrapper(wrapped):\n    def _wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    _wrapper.__name__ = wrapped.__name__\n    _wrapper.__doc__ = wrapped.__doc__\n    return _wrapper\n\n@function_wrapper\ndef function():\n    pass\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(function.__name__)\nfunction\n```\n\nLANGUAGE: python\nCODE:\n```\nimport functools\n\ndef function_wrapper(wrapped):\n    @functools.wraps(wrapped)\n    def _wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper\n\n@function_wrapper\ndef function():\n    pass\n```\n\nLANGUAGE: python\nCODE:\n```\nimport functools\n\nclass function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        functools.update_wrapper(self, wrapped)\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Function Wrapper Pattern with User-Supplied Decorator\nDESCRIPTION: An improved implementation of function wrappers that delegates execution to a user-supplied decorator function. This allows for custom decorator behavior while maintaining proper function metadata.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, args, kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, self.wrapper)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Synchronized Decorator Implementation\nDESCRIPTION: Complete implementation of synchronized decorator supporting both lock objects and automatic context-based locking\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped):\n    if hasattr(wrapped, 'acquire') and hasattr(wrapped, 'release'):\n        lock = wrapped\n\n        @decorator\n        def _synchronized(wrapped, instance, args, kwargs):\n            with lock:\n                return wrapped(*args, **kwargs)\n\n        class _PartialDecorator(ObjectProxy):\n            def __enter__(self):\n                lock.acquire()\n                return lock\n\n            def __exit__(self, *args):\n                lock.release()\n\n        return _PartialDecorator(wrapped=_synchronized)\n\n    def _synchronized_lock(context):\n        lock = vars(context).get('_synchronized_lock', None)\n\n        if lock is None:\n            meta_lock = vars(synchronized).setdefault(\n                    '_synchronized_meta_lock', Lock())\n\n            with meta_lock:\n                lock = vars(context).get('_synchronized_lock', None)\n\n                if lock is None:\n                    lock = RLock()\n                    setattr(context, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        with _synchronized_lock(instance or wrapped):\n            return wrapped(*args, **kwargs)\n\n    class _FinalDecorator(FunctionWrapper):\n        def __enter__(self):\n            self._self_lock = _synchronized_lock(self.__wrapped__)\n            self._self_lock.acquire()\n            return self._self_lock\n\n        def __exit__(self, *args):\n            self._self_lock.release()\n\n    return _FinalDecorator(wrapped=wrapped, wrapper=_synchronized_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Basic Decorator Factory Implementation in Python\nDESCRIPTION: Basic implementation of a decorator factory that allows creation of function wrappers. Uses functools.wraps to preserve function metadata.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef decorator(wrapper):\n    @functools.wraps(wrapper)\n    def _decorator(wrapped):\n        return function_wrapper(wrapped, wrapper)\n    return _decorator\n```\n\n----------------------------------------\n\nTITLE: Class-based Decorator Implementation\nDESCRIPTION: Shows how to implement a decorator using a class with __call__ method, allowing for better encapsulation of decorator functionality.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\nclass with_arguments(object):\n\n    def __init__(self, myarg1, myarg2):\n        self.myarg1 = myarg1\n        self.myarg2 = myarg2\n\n    @wrapt.decorator\n    def __call__(self, wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n@with_arguments(1, 2)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Cache Decorator with External State\nDESCRIPTION: Implementation of a cache decorator that maintains state between calls using an externally provided dictionary.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef cache(d):\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        try:\n            key = (args, frozenset(kwargs.items()))\n            return d[key]\n        except KeyError:\n            result = d[key] = wrapped(*args, **kwargs)\n            return result\n    return _wrapper\n\n_d = {}\n\n@cache(_d)\ndef function():\n    return time.time()\n```\n\n----------------------------------------\n\nTITLE: Class-Based Decorator Implementation in Python\nDESCRIPTION: Basic implementation of a decorator using a class with arguments, demonstrating state maintenance through class instance.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/06-maintaining-decorator-state-using-a-class.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass with_arguments(object):\n\n    def __init__(self, arg):\n        self.arg = arg\n\n    @decorator\n    def __call__(self, wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n@with_arguments(arg=1)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments Decorator Implementation\nDESCRIPTION: Implementation of a decorator that makes arguments optional using functools.partial, allowing the decorator to be used with or without parentheses.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef optional_arguments(wrapped=None, *, arg=1):\n    if wrapped is None:\n        return functools.partial(optional_arguments, arg=arg)\n\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n    return _wrapper(wrapped)\n```\n\n----------------------------------------\n\nTITLE: Creating a Decorator Factory in Python\nDESCRIPTION: A decorator function that acts as a factory for creating other decorators. This implementation simplifies the creation of decorators by requiring only a wrapper function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef decorator(wrapper):\n    @functools.wraps(wrapper)\n    def _decorator(wrapped):\n        return function_wrapper(wrapped, wrapper)\n    return _decorator\n```\n\n----------------------------------------\n\nTITLE: Required Arguments Decorator with Keyword-Only Arguments\nDESCRIPTION: Implementation of a decorator that requires keyword arguments using Python 3's keyword-only argument syntax.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef required_arguments(*, arg):\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper\n```\n\n----------------------------------------\n\nTITLE: Custom Function Wrapper Implementation\nDESCRIPTION: Shows how to create custom function wrapper classes that inherit from wrapt.FunctionWrapper and wrapt.BoundFunctionWrapper.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef custom_function_wrapper(attribute):\n\n    class CustomBoundFunctionWrapper(wrapt.BoundFunctionWrapper):\n\n        def __call__(self, *args, **kwargs):\n            if attribute:\n                ...\n            return super(CustomBoundFunctionWrapper, self).__call__(*args, **kwargs)\n\n    class CustomFunctionWrapper(wrapt.FunctionWrapper):\n\n        __bound_function_wrapper__ = CustomBoundFunctionWrapper\n\n        def __call__(self, *args, **kwargs):\n            if attribute:\n                ...\n            return super(CustomFunctionWrapper, self).__call__(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Argument Specification Factory\nDESCRIPTION: Shows how to implement a factory for generating argument specifications dynamically, useful for adapting decorator signatures at runtime.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef argspec_factory(wrapped):\n    argspec = inspect.getfullargspec(wrapped)\n\n    args = argspec.args[1:]\n    defaults = argspec.defaults and argspec.defaults[-len(argspec.args):]\n\n    return inspect.ArgSpec(args, argspec.varargs,\n            argspec.keywords, defaults)\n```\n\n----------------------------------------\n\nTITLE: Universal Decorator Factory Implementation\nDESCRIPTION: Implementation of a decorator factory that handles binding for both functions and methods using a function wrapper approach.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/06-maintaining-decorator-state-using-a-class.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef decorator(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        def _execute(wrapped):\n            if instance is None:\n                return function_wrapper(wrapped, wrapper)\n            elif inspect.isclass(instance):\n                return function_wrapper(wrapped, wrapper.__get__(None, instance))\n            else:\n                return function_wrapper(wrapped, wrapper.__get__(instance, type(instance)))\n        return _execute(*args, **kwargs)\n    return function_wrapper(wrapper, _wrapper)\n```\n\n----------------------------------------\n\nTITLE: Registering Post Import Hook using Decorator Pattern in Python\nDESCRIPTION: Example showing how to register a post import hook using a decorator pattern to handle module imports. This demonstrates the basic concept from PEP 369 for registering callbacks when modules are imported.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport imp\n\n@imp.when_imported('decimal')\ndef register(decimal):\n    Inexact.register(decimal.Decimal)\n```\n\n----------------------------------------\n\nTITLE: Synchronized Usage Examples\nDESCRIPTION: Comprehensive examples showing different ways to use the synchronized decorator with various method types and their lock binding behavior.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@synchronized # lock bound to function1\ndef function1():\n    pass\n\n@synchronized # lock bound to function2\ndef function2():\n    pass\n\n@synchronized # lock bound to Class\nclass Class(object):\n\n    @synchronized # lock bound to instance of Class\n    def function_im(self):\n        pass\n\n    @synchronized # lock bound to Class\n    @classmethod\n    def function_cm(cls):\n        pass\n\n    @synchronized # lock bound to function_sm\n    @staticmethod\n    def function_sm():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Argument Specification Factory in Python\nDESCRIPTION: Example showing how to create an argument specification factory for dynamic decorator adaptation that processes function arguments.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/changes.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef argspec_factory(wrapped):\n    argspec = inspect.getargspec(wrapped)\n\n    args = argspec.args[1:]\n    defaults = argspec.defaults and argspec.defaults[-len(argspec.args):]\n\n    return inspect.ArgSpec(args, argspec.varargs,\n            argspec.keywords, defaults)\n\ndef session(wrapped):\n    @wrapt.decorator(adapter=argspec_factory(wrapped))\n    def _session(wrapped, instance, args, kwargs):\n        with transaction() as session:\n            return wrapped(session, *args, **kwargs)\n\n    return _session(wrapped)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Function Wrapper with Instance Awareness\nDESCRIPTION: An improved implementation that preserves the class instance information when decorating methods, allowing decorators to access both the instance and the arguments.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, self.instance, args, kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__( instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Decorator Control Using Callable\nDESCRIPTION: Shows how to implement dynamic control of decorator execution using a callable function for the enabled parameter. The decorator's behavior can be controlled at runtime.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef _enabled():\n    return True\n\n@wrapt.decorator(enabled=_enabled)\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Basic Object Proxy Usage with Dictionary in Python\nDESCRIPTION: Demonstrates basic usage of wrapt.ObjectProxy with a dictionary object, showing how the proxy transparently passes through operations to the wrapped object.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> table = {}\n>>> proxy = wrapt.ObjectProxy(table)\n>>> proxy['key-1'] = 'value-1'\n>>> proxy['key-2'] = 'value-2'\n\n>>> proxy.keys()\n['key-2', 'key-1']\n>>> table.keys()\n['key-2', 'key-1']\n\n>>> isinstance(proxy, dict)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Wrapt Decorator Implementation in Python\nDESCRIPTION: Implementation using the wrapt module's decorator functionality, showing usage with regular functions and methods. Demonstrates both inner and outer decorator placement with classmethod and staticmethod.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/benchmarks.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef wrapper3(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@wrapper3\ndef function3():\n    pass\n\nclass Class(object):\n\n    @wrapper3\n    def function3(self):\n        pass\n\n    @wrapper3\n    @classmethod\n    def function3cmo(cls):\n        pass\n\n    @classmethod\n    @wrapper3\n    def function3cmi(cls):\n        pass\n\n    @wrapper3\n    @staticmethod\n    def function3smo():\n        pass\n\n    @staticmethod\n    @wrapper3\n    def function3smi():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Improved Universal Decorator with Method Type Detection in Python\nDESCRIPTION: This updated implementation of the universal decorator attempts to distinguish between different types of methods (instance, class, static) by checking the wrapped object type in the constructor.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper, binding):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n        self.binding = binding\n\n    def __call__(self, *args, **kwargs):\n        if self.binding == 'function' and self.instance is None:\n            instance, args = args[0], args[1:]\n            wrapped = functools.partial(self.wrapped, instance)\n            return self.wrapper(wrapped, instance, args, kwargs)\n        return self.wrapper(self.wrapped, self.instance, args, kwargs)\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n        if isinstance(wrapped, classmethod):\n            self.binding = 'classmethod'\n        elif isinstance(wrapped, staticmethod):\n            self.binding = 'staticmethod'\n        else:\n            self.binding = 'function'\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper,\n                self.binding)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Decorator Factory in Python\nDESCRIPTION: This code snippet defines a custom decorator factory using a function wrapper class and object proxy. It demonstrates the implementation of a more flexible decorator mechanism that properly handles descriptor protocols.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/09-performance-overhead-of-using-decorators.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n        ...\n\n    def __get__(self, instance, owner):\n        ...\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n\ndef decorator(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        def _execute(wrapped):\n            if instance is None:\n                return function_wrapper(wrapped, wrapper)\n            elif inspect.isclass(instance):\n                return function_wrapper(wrapped, wrapper.__get__(None, instance))\n            else:\n                return function_wrapper(wrapped, wrapper.__get__(instance, type(instance)))\n        return _execute(*args, **kwargs)\n    return function_wrapper(wrapper, _wrapper)\n```\n\n----------------------------------------\n\nTITLE: Implementing Robust Descriptor-Based Decorator in Python\nDESCRIPTION: Complete implementation of a robust decorator that properly handles method binding through descriptors, preserving Python's execution model.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass object_proxy(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__name__ = wrapped.__name__\n        except AttributeError:\n            pass\n\n    @property\n    def __class__(self):\n        return self.wrapped.__class__\n\n    def __getattr__(self, name):\n        return getattr(self.wrapped, name)\n\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper, binding, parent):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n        self.binding = binding\n        self.parent = parent\n\n    def __call__(self, *args, **kwargs):\n        if self.binding == 'function':\n            if self.instance is None:\n                instance, args = args[0], args[1:]\n                wrapped = functools.partial(self.wrapped, instance)\n                return self.wrapper(wrapped, instance, args, kwargs)\n            else:\n                return self.wrapper(self.wrapped, self.instance, args, kwargs)\n        else:\n            instance = getattr(self.wrapped, '__self__', None)\n            return self.wrapper(self.wrapped, instance, args, kwargs)\n\n    def __get__(self, instance, owner):\n        if self.instance is None and self.binding == 'function':\n            descriptor = self.parent.wrapped.__get__(instance, owner)\n            return bound_function_wrapper(descriptor, instance, self.wrapper,\n                    self.binding, self.parent)\n        return self\n\nclass function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(function_wrapper, self).__init__(wrapped)\n        self.wrapper = wrapper\n        if isinstance(wrapped, classmethod):\n            self.binding = 'classmethod'\n        elif isinstance(wrapped, staticmethod):\n            self.binding = 'staticmethod'\n        else:\n            self.binding = 'function'\n\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__(instance, owner)\n        return bound_function_wrapper(wrapped, instance, self.wrapper,\n                self.binding, self)\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapper(self.wrapped, None, args, kwargs)\n\ndef decorator(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        def _execute(wrapped):\n            if instance is None:\n                return function_wrapper(wrapped, wrapper)\n            elif inspect.isclass(instance):\n                return function_wrapper(wrapped,\n                        wrapper.__get__(None, instance))\n            else:\n                return function_wrapper(wrapped,\n                        wrapper.__get__(instance, type(instance)))\n        return _execute(*args, **kwargs)\n    return function_wrapper(wrapper, _wrapper)\n```\n\n----------------------------------------\n\nTITLE: Instance-Aware Decorator Example in Python\nDESCRIPTION: A modified decorator that demonstrates how to access both the instance and arguments in the wrapper function, showing different behavior for functions and methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    print('INSTANCE', instance)\n    print('ARGS', args)\n    return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Argument Processing in Decorator\nDESCRIPTION: Shows how to properly process and modify function arguments within a decorator using nested functions.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef my_decorator(wrapped, instance, args, kwargs):\n    def _execute(arg1, arg2, *_args, **_kwargs):\n        return wrapped(arg1, arg2, *_args, **_kwargs)\n\n    return _execute(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Descriptors for Python Function Wrappers\nDESCRIPTION: This code demonstrates how to solve the decorator-descriptor interaction problem by implementing function wrappers as descriptors that properly handle the binding protocol.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n\nclass function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n    def __get__(self, instance, owner):\n        wrapped = self.wrapped.__get__( instance, owner)\n        return bound_function_wrapper(wrapped)\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Function Closure Decorator Implementation in Python\nDESCRIPTION: Implementation of decorators using function closures, demonstrating wrapper pattern for regular functions and methods. Shows usage with instance, class, and static methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/benchmarks.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef wrapper2(func):\n    def _wrapper2(*args, **kwargs):\n        return func(*args, **kwargs)\n    return _wrapper2\n\n@wrapper2\ndef function2():\n    pass\n\nclass Class(object):\n\n    @wrapper2\n    def function2(self):\n        pass\n\n    @classmethod\n    @wrapper2\n    def function2cmi(cls):\n        pass\n\n    @staticmethod\n    @wrapper2\n    def function2smi():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Bound Function Wrapper\nDESCRIPTION: Implementation of a bound_function_wrapper class that handles instance method calls correctly by managing instance binding and argument passing.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __call__(self, *args, **kwargs):\n        if self.instance is None:\n            instance, args = args[0], args[1:]\n            wrapped = functools.partial(self.wrapped, instance)\n            return self.wrapper(wrapped, instance, args, kwargs)\n        return self.wrapper(self.wrapped, self.instance, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Enabling/Disabling Decorator Functionality\nDESCRIPTION: Demonstrates how to implement a decorator that can be enabled or disabled using the enabled parameter.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nENABLED = True\n\n@wrapt.decorator(enabled=ENABLED)\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Universal Decorator in Python\nDESCRIPTION: This code demonstrates how to use the universal decorator to create a custom decorator that prints information about the wrapped function or method when called.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    print('INSTANCE', instance)\n    print('ARGS', args)\n    return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Mock-like Testing Implementation with Wrapt\nDESCRIPTION: Shows how to build a Mock-like testing utility using wrapt's transient_function_wrapper, capturing method calls and arguments for later assertion.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        pass\n\ndef patch(module, name):\n    def _decorator(wrapped):\n        class Wrapper(object):\n            @transient_function_wrapper(module, name)\n            def __call__(self, wrapped, instance, args, kwargs):\n                self.args = args\n                self.kwargs = kwargs\n                return wrapped(*args, **kwargs)\n        wrapper = Wrapper()\n        @wrapper\n        def _wrapper():\n            return wrapped(wrapper)\n        return _wrapper\n    return _decorator\n\n@patch(__name__, 'ProductionClass.method')\ndef test_method(mock_method):\n    real = ProductionClass()\n    result = real.method(3, 4, 5, key='value')\n    assert real.method.__name__ == 'method'\n    assert mock_method.args == (3, 4, 5)\n    assert mock_method.kwargs.get('key') == 'value'\n```\n\n----------------------------------------\n\nTITLE: Object Proxy Implementation with Wrapt\nDESCRIPTION: Shows a better approach using ObjectProxy to wrap objects without modifying the original instance, allowing for method interception and behavior modification.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper, ObjectProxy\n\nclass StorageClass(object):\n    def run(self):\n        pass\n\nstorage = StorageClass()\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        return storage\n\nclass StorageClassProxy(ObjectProxy):\n    def run(self):\n        return self.__wrapped__.run()\n\n@transient_function_wrapper(__name__, 'ProductionClass.method')\ndef apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):\n    storage = wrapped(*args, **kwargs)\n    return StorageClassProxy(storage)\n\n@apply_ProductionClass_method_wrapper\ndef test_method():\n    real = ProductionClass()\n    data = real.method(3, 4, 5, key='value')\n    result = data.run()\n```\n\n----------------------------------------\n\nTITLE: Class-Based Cache Decorator Implementation\nDESCRIPTION: Implements a caching decorator using a class-based approach with internal state management through instance attributes.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass cache(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        self.d = {}\n\n    def __call__(self, *args, **kwargs):\n        try:\n            key = (args, frozenset(kwargs.items()))\n            return self.d[key]\n        except KeyError:\n            result = self.d[key] = self.wrapped(*args, **kwargs)\n            return result\n\n@cache\ndef function():\n    return time.time()\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Decorator Factory in Python\nDESCRIPTION: A demonstration of using the decorator factory to create and apply a custom decorator that prints the arguments passed to the wrapped function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, args, kwargs):\n    print('ARGS', args)\n    return wrapped(*args, **kwargs)\n\n@my_function_wrapper\ndef function(a, b):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Python Decorator Factory Implementation\nDESCRIPTION: Updated synchronized decorator using a decorator factory pattern for better method support.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped=None, lock=None):\n    if wrapped is None:\n        return functools.partial(synchronized, lock=lock)\n\n    if lock is None:\n        lock = threading.RLock()\n\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        with lock:\n            return wrapped(*args, **kwargs)\n\n    return _wrapper(wrapped)\n```\n\n----------------------------------------\n\nTITLE: Wrapt Example: Transient Function Wrapper in Python\nDESCRIPTION: Shows how to use wrapt's transient_function_wrapper for temporary method patching during testing. The wrapper is only applied for the scope of the decorated test function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        print a, b, c, key\n\n@transient_function_wrapper(__name__, 'ProductionClass.method')\ndef apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):\n    assert args == (3, 4, 5) and kwargs.get('key') == 'value'\n    return 3\n\n@apply_ProductionClass_method_wrapper\ndef test_method():\n    real = ProductionClass()\n    result = real.method(3, 4, 5, key='value')\n    assert result == 3\n```\n\n----------------------------------------\n\nTITLE: Improved Synchronized Decorator with Meta Lock\nDESCRIPTION: Enhanced implementation using a meta lock to handle thread-safe initialization of locks, supporting all method types including class methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    if instance is None:\n        owner = wrapped\n    else:\n        owner = instance\n\n    lock = vars(owner).get('_synchronized_lock', None)\n\n    if lock is None:\n        meta_lock = vars(synchronized).setdefault(\n                '_synchronized_meta_lock', threading.Lock())\n\n        with meta_lock:\n            lock = vars(owner).get('_synchronized_lock', None)\n            if lock is None:\n                lock = threading.RLock()\n                setattr(owner, '_synchronized_lock', lock)\n\n    with lock:\n        return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Wrapt Example: Basic Method Patching in Python\nDESCRIPTION: Demonstrates equivalent functionality to Mock using wrapt's patch_function_wrapper. Shows how to intercept method calls and override return values.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import patch_function_wrapper\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        print a, b, c, key\n\n@patch_function_wrapper(__name__, 'ProductionClass.method')\ndef wrapper(wrapped, instance, args, kwargs):\n    assert args == (3, 4, 5) and kwargs.get('key') == 'value'\n    return 3\n\ndef test_method():\n    real = ProductionClass()\n    result = real.method(3, 4, 5, key='value')\n    assert result == 3\n```\n\n----------------------------------------\n\nTITLE: Lock-Based Synchronization Example\nDESCRIPTION: Example showing synchronization using explicit lock objects\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nlock = threading.RLock()\n\n@synchronized(lock)\ndef function_1():\n    pass\n\n@synchronized(lock)\ndef function_2():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Decorator Execution Logic\nDESCRIPTION: Function that handles the execution of wrapped functions in a decorator context, dealing with different instance scenarios and wrapper binding. This implementation demonstrates basic decorator mechanics but has limitations with attribute handling.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/06-maintaining-decorator-state-using-a-class.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef _execute(wrapped):\n    if instance is None:\n        return function_wrapper(wrapped, wrapper)\n    elif inspect.isclass(instance):\n        return function_wrapper(wrapped, wrapper.__get__(None, instance))\n    else:\n        return function_wrapper(wrapped, wrapper.__get__(instance, type(instance)))\nreturn _execute(*args, **kwargs)\nreturn function_wrapper(wrapper, _wrapper)\n```\n\n----------------------------------------\n\nTITLE: Instance-aware Synchronization Decorator in Python\nDESCRIPTION: Enhanced synchronization decorator that handles instance methods by associating locks with class instances rather than methods. Supports both function and instance method contexts.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    # Use the instance as the context if function was bound.\n\n    if instance is not None:\n        context = vars(instance)\n    else:\n        context = vars(wrapped)\n\n    # Retrieve the lock for the specific context.\n\n    lock = context.get('_synchronized_lock', None)\n\n    if lock is None:\n        # There was no lock yet associated with the function so we\n        # create one and associate it with the wrapped function.\n        # We use ``dict.setdefault()`` as a means of ensuring that\n        # only one thread gets to set the lock if multiple threads\n        # do this at the same time. This may mean redundant lock\n        # instances will get thrown away if there is a race to set\n        # it, but all threads would still get back the same one lock.\n\n        lock = context.setdefault('_synchronized_lock',\n                threading.RLock())\n\n    with lock:\n        return wrapped(*args, **kwargs)\n\n@synchronized\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Using Wrapt Adapter Factory for Decorator Creation\nDESCRIPTION: Demonstrates the use of wrapt.adapter_factory for creating decorators with dynamic argument adaptation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/changes.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator(adapter=wrapt.adapter_factory(argspec_factory))\ndef _session(wrapped, instance, args, kwargs):\n    with transaction() as session:\n        return wrapped(session, *args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Python Automatic Lock Creation Synchronized Decorator\nDESCRIPTION: Python synchronized decorator that automatically creates a lock for each decorated function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped):\n    lock = threading.RLock()\n    @functools.wraps(wrapped)\n    def _wrapper(*args, **kwargs):\n        with lock:\n            return wrapped(*args, **kwargs)\n    return _wrapper\n\n@synchronized\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Function Wrapper Implementation\nDESCRIPTION: Shows how to implement and apply a function wrapper using wrapt's wrap_function_wrapper method.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\nclass Example(object):\n    def name(self):\n        return 'name'\n\nimport wrapt\n\nwrapt.wrap_function_wrapper(Example, 'name', wrapper)\n```\n\n----------------------------------------\n\nTITLE: Class Method Decoration Examples\nDESCRIPTION: Shows different method types (instance, class, and static) being decorated in a class context.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n\n    @function_wrapper\n    def method(self):\n        pass\n\n    @classmethod\n    def cmethod(cls):\n        pass\n\n    @staticmethod\n    def smethod():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Basic Wrapper Usage Example\nDESCRIPTION: Demonstrates how to use the function wrapper decorator to wrap a simple function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@function_wrapper\ndef wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@wrapper\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Python Basic Synchronized Decorator with Lock Parameter\nDESCRIPTION: Initial Python implementation of synchronized decorator requiring an external lock object.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(lock=None):\n    def _decorator(wrapped):\n        @functools.wraps(wrapped)\n        def _wrapper(*args, **kwargs):\n            with lock:\n                return wrapped(*args, **kwargs)\n        return _wrapper\n    return _decorator\n\nlock = threading.RLock()\n\n@synchronized(lock)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Function-specific Lock Synchronization Decorator in Python\nDESCRIPTION: Synchronization decorator that automatically creates and associates a lock with each decorated function. Creates locks on demand and attaches them to the wrapped function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    # Retrieve the lock from the wrapped function.\n\n    lock = vars(wrapped).get('_synchronized_lock', None)\n\n    if lock is None:\n        # There was no lock yet associated with the function so we\n        # create one and associate it with the wrapped function.\n        # We use ``dict.setdefault()`` as a means of ensuring that\n        # only one thread gets to set the lock if multiple threads\n        # do this at the same time. This may mean redundant lock\n        # instances will get thrown away if there is a race to set\n        # it, but all threads would still get back the same one lock.\n\n        lock = vars(wrapped).setdefault('_synchronized_lock',\n                threading.RLock())\n\n    with lock:\n        return wrapped(*args, **kwargs)\n\n@synchronized\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Class Method Decoration with Wrapt\nDESCRIPTION: Shows how to decorate class methods using wrapt, with important notes about decorator placement relative to @classmethod for Python version compatibility.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\nclass Class(object):\n\n    @pass_through\n    @classmethod\n    def function_cm(cls, arg1, arg2):\n        pass\n\nClass.function_cm(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Basic Lock-based Synchronization Decorator in Python\nDESCRIPTION: Simple synchronization decorator that accepts an explicit lock parameter. Uses a recursive lock to prevent deadlocks in recursive calls.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(lock):\n    @wrapt.decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        with lock:\n            return wrapped(*args, **kwargs)\n    return _wrapper\n\nimport threading\n\nlock = threading.RLock()\n\n@synchronized(lock)\ndef function():\n    pass\n\nclass Class(object):\n\n    @synchronized(lock)\n    def function(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Basic Function Cache Decorator Implementation\nDESCRIPTION: Demonstrates implementation of a caching decorator using function-based approach with state management through function attributes.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@cache\ndef function1():\n    return time.time()\n\n_d = {}\n\n@cache(d=_d)\ndef function2():\n    return time.time()\n\n@cache(d=_d)\ndef function3():\n    return time.time()\n```\n\n----------------------------------------\n\nTITLE: Class Method Synchronization Example\nDESCRIPTION: Example showing how to use the synchronized decorator with class methods and instance methods\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n\n    @synchronized\n    @classmethod\n    def function_cm(cls):\n        pass\n\n    def function_im(self):\n        with synchronized(Class):\n            pass\n```\n\n----------------------------------------\n\nTITLE: Static Method Decoration with Wrapt\nDESCRIPTION: Demonstrates decorating static methods using wrapt, where the instance argument is None and behaves similar to normal functions.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\nclass Class(object):\n\n    @pass_through\n    @staticmethod\n    def function_sm(arg1, arg2):\n        pass\n\nClass.function_sm(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Monkey Patch Module Implementation in Python\nDESCRIPTION: Example module containing the actual monkey patch implementation that wraps the target function with additional functionality.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import wrap_function_wrapper\n\ndef _mkdtemp_wrapper(wrapped, instance, args, kwargs):\n    print 'calling', wrapped.__name__\n    return wrapped(*args, **kwargs)\n\ndef apply_patch(module):\n    print 'patching', module.__name__\n    wrap_function_wrapper(module, 'mkdtemp', _mkdtemp_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Instance-Level Lock Synchronization Example\nDESCRIPTION: Example showing instance-level lock synchronization using context manager\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n\n    def __init__(self):\n        self.lock1 = threading.RLock()\n\n    def function_im(self):\n        with synchronized(self.lock1):\n            pass\n```\n\n----------------------------------------\n\nTITLE: Initial Synchronized Decorator Implementation\nDESCRIPTION: Basic implementation of synchronized decorator that stores locks on instance or function objects, handling both instance and class methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    if instance is None:\n        context = vars(wrapped)\n    else:\n        context = vars(instance)\n\n    lock = context.get('_synchronized_lock', None)\n\n    if lock is None:\n        lock = context.setdefault('_synchronized_lock', threading.RLock())\n\n    with lock:\n        return wrapped(*args, **kwargs)\n\nclass Object(object):\n\n    @synchronized\n    def method_im(self):\n        pass\n\n    @synchronized\n    @classmethod\n    def method_cm(cls):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Object Proxy in Python\nDESCRIPTION: A minimal implementation of an object proxy class that preserves the wrapped object's attributes, name, and class. This serves as the foundation for creating decorator wrappers.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass object_proxy(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__name__= wrapped.__name__\n        except AttributeError:\n            pass\n\n    @property\n    def __class__(self):\n        return self.wrapped.__class__\n\n    def __getattr__(self, name):\n        return getattr(self.wrapped, name)\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Monkey Patch Implementation in Python\nDESCRIPTION: Implementation of lazy loading mechanism for monkey patches using wrapt's post import hooks to delay patch loading until the target module is imported.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sys\n\nfrom wrapt import register_post_import_hook\n\ndef load_and_execute(name):\n    def _load_and_execute(target_module):\n        __import__(name)\n        patch_module = sys.modules[name]\n        getattr(patch_module, 'apply_patch')(target_module)\n    return _load_and_execute\n\nregister_post_import_hook(load_and_execute('patch_tempfile'), 'tempfile')\n```\n\n----------------------------------------\n\nTITLE: Synchronized Decorator Usage Examples\nDESCRIPTION: Examples showing different ways to use the synchronized decorator with functions, methods, and classes.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/08-the-synchronized-decorator-as-context-manager.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@synchronized # lock bound to function1\ndef function1():\n    pass\n\n@synchronized # lock bound to function2\ndef function2():\n    pass\n\n@synchronized # lock bound to Class\nclass Class(object):\n\n    @synchronized # lock bound to instance of Class\n    def function_im(self):\n        pass\n\n    @synchronized # lock bound to Class\n    @classmethod\n    def function_cm(cls):\n        pass\n\n    @synchronized # lock bound to function_sm\n    @staticmethod\n    def function_sm():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronized Function with Semaphore in Python\nDESCRIPTION: Shows how to use the @synchronized decorator with a threading.Semaphore to limit concurrent access to a function. The semaphore is initialized to allow 2 concurrent accesses.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsemaphore = threading.Semaphore(2)\n\n@synchronized(semaphore)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Custom Wrapper with Instance Variables\nDESCRIPTION: Demonstrates how to implement custom function wrappers with instance variables that can change over the lifetime of the wrapper.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef custom_function_wrapper(attribute):\n\n    class CustomBoundFunctionWrapper(wrapt.BoundFunctionWrapper):\n\n        def __init__(self, *args, **kwargs):\n            super(CustomBoundFunctionWrapper, self).__init(*args, **kwargs)\n            self._self_attribute = attribute\n\n        def __call__(self, *args, **kwargs):\n            if self._self_attribute:\n                ...\n            return super(CustomBoundFunctionWrapper, self).__call__(*args, **kwargs)\n\n    class CustomFunctionWrapper(wrapt.FunctionWrapper):\n\n        __bound_function_wrapper__ = CustomBoundFunctionWrapper\n\n        def __init__(self, *args, **kwargs):\n            super(CustomFunctionWrapper, self).__init(*args, **kwargs)\n            self._self_attribute = attribute\n\n        def __call__(self, *args, **kwargs):\n            if self._self_attribute:\n                ...\n            return super(CustomFunctionWrapper, self).__call__(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Refactored Synchronized Implementation without @decorator\nDESCRIPTION: Reimplemented synchronized decorator without using the @decorator pattern to enable custom function wrapper creation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/08-the-synchronized-decorator-as-context-manager.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef synchronized(wrapped):\n    def _synchronized_lock(owner):\n        lock = vars(owner).get('_synchronized_lock', None)\n\n        if lock is None:\n            meta_lock = vars(synchronized).setdefault(\n                    '_synchronized_meta_lock', threading.Lock())\n\n            with meta_lock:\n                lock = vars(owner).get('_synchronized_lock', None)\n                if lock is None:\n                    lock = threading.RLock()\n                    setattr(owner, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        with _synchronized_lock(instance or wrapped):\n            return wrapped(*args, **kwargs)\n\n    return function_wrapper(wrapped, _synchronized_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Using super() with Decorated Class in Python\nDESCRIPTION: Demonstrates how to properly use super() with a decorated class by accessing the original wrapped class using __wrapped__ attribute. Also shows the simplified syntax for Python 3.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/issues.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@mydecorator\nclass Derived(Base):\n\n    def __init__(self):\n        super(Derived.__wrapped__, self).__init__()\n```\n\nLANGUAGE: python\nCODE:\n```\n@mydecorator\nclass Derived(Base):\n\n    def __init__(self):\n        super().__init__()\n```\n\n----------------------------------------\n\nTITLE: Class-Based Function Wrapper Pattern\nDESCRIPTION: Shows a basic class-based implementation of a function wrapper decorator pattern that wraps a function and delegates calls.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass function_wrapper(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Basic Function Wrapper Implementation Example\nDESCRIPTION: Demonstrates a basic function wrapper decorator that fails to preserve the argument specification of the wrapped function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\ndef function_wrapper(wrapped): ...\n\n@function_wrapper\ndef function(arg1, arg2): pass\n```\n\n----------------------------------------\n\nTITLE: Data Object Synchronization Example\nDESCRIPTION: Example demonstrating synchronization using a shared data object\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Data(object):\n    pass\n\ndata = Data()\n\ndef function_1():\n    with synchronized(data):\n        pass\n\ndef function_2():\n    with synchronized(data):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Python Object-Based Lock Storage\nDESCRIPTION: Implementation storing the lock on the wrapped function object with thread-safe initialization.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef synchronized(wrapped, instance, args, kwargs):\n    lock = vars(wrapped).get('_synchronized_lock', None)\n    if lock is None:\n        lock = vars(wrapped).setdefault('_synchronized_lock', threading.RLock())\n    with lock:\n        return wrapped(*args, **kwargs)\n\n@synchronized\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Traditional Function Closure Decorator in Python\nDESCRIPTION: This code shows how to implement a decorator using the traditional function closure method. It's provided for comparison with the custom decorator factory approach.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/09-performance-overhead-of-using-decorators.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef my_function_wrapper(wrapped):\n    def _my_function_wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _my_function_wrapper\n\n@my_function_wrapper\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Function Inspection Result\nDESCRIPTION: Shows the incorrect argument specification returned when inspecting a wrapped function using inspect.getargspec().\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(inspect.getargspec(function))\nArgSpec(args=[], varargs='args', keywords='kwargs', defaults=None)\n```\n\n----------------------------------------\n\nTITLE: Python 3 Keyword-Only Arguments Decorator\nDESCRIPTION: Demonstrates using Python 3's keyword-only arguments syntax to enforce keyword argument usage in decorator implementation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\ndef with_keyword_only_arguments(*, myarg1, myarg2):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return wrapper\n\n@with_keyword_only_arguments(myarg1=1, myarg2=2)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Disabled Decorator Pattern in Python\nDESCRIPTION: Demonstrates how to create a pass-through decorator that can be globally disabled using the enabled parameter. When disabled, there is no runtime overhead at the point of call.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nENABLED = False\n\n@wrapt.decorator(enabled=ENABLED)\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Class-based Wrapper Implementation\nDESCRIPTION: Shows a class-based decorator implementation that causes inspection failures.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass function_wrapper(object): ...\n\n@function_wrapper\ndef function(arg1, arg2): pass\n```\n\n----------------------------------------\n\nTITLE: Decorator Failure with Classmethod Example\nDESCRIPTION: This code illustrates how traditional Python decorators fail when applied to classmethods because they don't properly handle the descriptor protocol.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n    @function_wrapper\n    @classmethod\n    def cmethod(cls):\n        pass\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> Class.cmethod()\nTraceback (most recent call last):\n  File \"classmethod.py\", line 15, in <module>\n    Class.cmethod()\n  File \"classmethod.py\", line 6, in _wrapper\n    return wrapped(*args, **kwargs)\nTypeError: 'classmethod' object is not callable\n```\n\n----------------------------------------\n\nTITLE: Cache Decorator with Internal State\nDESCRIPTION: Implementation of a cache decorator that maintains state between calls using an internally created dictionary.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef cache(wrapped):\n    d = {}\n\n    @decorator\n    def _wrapper(wrapped, instance, args, kwargs):\n        try:\n            key = (args, frozenset(kwargs.items()))\n            return d[key]\n        except KeyError:\n            result = d[key] = wrapped(*args, **kwargs)\n            return result\n\n    return _wrapper(wrapped)\n\n@cache\ndef function():\n    return time.time()\n```\n\n----------------------------------------\n\nTITLE: Using functools.update_wrapper with Descriptor-based Wrappers\nDESCRIPTION: This example shows how to use functools.update_wrapper with descriptor-based function wrappers, noting the performance implications when creating bound wrappers.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        functools.update_wrapper(self, wrapped)\n\nclass function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        functools.update_wrapper(self, wrapped)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Introspection Issues with Function Wrappers\nDESCRIPTION: Illustrates how basic function wrappers can break introspection by returning incorrect function names or raising AttributeErrors.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef function_wrapper(wrapped):\n    def _wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper\n\n@function_wrapper\ndef function():\n    pass\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(function.__name__)\n_wrapper\n```\n\nLANGUAGE: python\nCODE:\n```\nclass function_wrapper(object):\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n    def __call__(self, *args, **kwargs):\n        return self.wrapped(*args, **kwargs)\n\n@function_wrapper\ndef function():\n    pass\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(function.__name__)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'function_wrapper' object has no attribute '__name__'\n```\n\n----------------------------------------\n\nTITLE: Classmethod Decorator Error Example\nDESCRIPTION: Demonstrates the AttributeError that occurs when combining function_wrapper with @classmethod in Python 2.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n    @function_wrapper\n    @classmethod\n    def cmethod(cls):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Property Interception with Object Proxy\nDESCRIPTION: Demonstrates how to intercept attribute access using property decorators with ObjectProxy, allowing for attribute value validation and modification.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper, ObjectProxy\n\nclass StorageClass(object):\n    def __init__(self):\n        self.name = 'name'\n\nstorage = StorageClass()\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        return storage\n\nclass StorageClassProxy(ObjectProxy):\n    @property\n    def name(self):\n        return self.__wrapped__.name\n\n@transient_function_wrapper(__name__, 'ProductionClass.method')\ndef apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):\n    storage = wrapped(*args, **kwargs)\n    return StorageClassProxy(storage)\n\n@apply_ProductionClass_method_wrapper\ndef test_method():\n    real = ProductionClass()\n    data = real.method(3, 4, 5, key='value')\n    assert data.name == 'name'\n```\n\n----------------------------------------\n\nTITLE: Using Custom Decorator Factory in Python\nDESCRIPTION: This snippet demonstrates how to use the custom decorator factory to create and apply a decorator to a normal function. It contrasts this approach with the traditional function closure method.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/09-performance-overhead-of-using-decorators.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@my_function_wrapper\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Documenting Decorated Functions\nDESCRIPTION: Shows how wrapt preserves function documentation and docstrings when using decorators, allowing access through the help system and __doc__ attribute.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef my_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@my_decorator\ndef function(arg1, arg2):\n    \"\"\"Function documentation.\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Instance Method Call via Class\nDESCRIPTION: Shows how instance methods are called directly through the class, highlighting the issue with instance reference passing.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> Class.function_im(c, 1, 2)\nINSTANCE None\nARGS (<__main__.Class object at 0x1085ca9d0>, 1, 2)\n```\n\n----------------------------------------\n\nTITLE: Initial Function Wrapper Implementation - Python\nDESCRIPTION: First implementation of bound_function_wrapper class showing initial approach to handling different method types and bindings.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass bound_function_wrapper(object_proxy):\n\n    def __init__(self, wrapped, instance, wrapper, binding):\n        super(bound_function_wrapper, self).__init__(wrapped)\n        self.instance = instance\n        self.wrapper = wrapper\n        self.binding = binding\n\n    def __call__(self, *args, **kwargs):\n        if self.binding == 'function':\n            if self.instance is None:\n                instance, args = args[0], args[1:]\n                wrapped = functools.partial(self.wrapped, instance)\n                return self.wrapper(wrapped, instance, args, kwargs)\n            else:\n                return self.wrapper(self.wrapped, self.instance, args, kwargs)\n        else:\n            instance = getattr(self.wrapped, '__self__', None)\n            return self.wrapper(self.wrapped, instance, args, kwargs)\n```\n\n----------------------------------------\n\nTITLE: Attempted Class-Based Decorator with Arguments\nDESCRIPTION: Demonstrates an attempt to implement a class-based decorator that accepts arguments, using the @decorator pattern.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass with_arguments(object):\n\n    def __init__(self, arg):\n        self.arg = arg\n\n    @decorator\n    def __call__(self, wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n@with_arguments(arg=1)\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator Class Pattern in Python\nDESCRIPTION: Example of creating a class-based decorator using wrapt.decorator with customizable initialization arguments.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/changes.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\nclass mydecoratorclass(object):\n    def __init__(self, arg=None):\n        self.arg = arg\n    def __call__(self, wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n\n@mydecoratorclass\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Applying Decorator to Class Methods in Python\nDESCRIPTION: Example showing how the decorator factory can be applied to instance methods of classes, demonstrating its flexibility across different function types.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n    @my_function_wrapper\n    def function_im(self, a, b):\n        pass\n\nc = Class()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Objects as Descriptors in Python\nDESCRIPTION: This code snippet demonstrates how Python function objects are actually descriptors with __get__ methods that bind the function to class instances, turning them into bound methods.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> def f(obj): pass\n\n>>> hasattr(f, '__get__')\nTrue\n\n>>> f\n<function f at 0x10e963cf8>\n\n>>> obj = object()\n\n>>> f.__get__(obj, type(obj))\n<bound method object.f of <object object at 0x10e8ac0b0>>\n```\n\n----------------------------------------\n\nTITLE: Undecorated Function Call Implementations in Python\nDESCRIPTION: Base implementation of undecorated functions and methods to establish baseline performance metrics. Includes regular function, instance method, class method, and static method implementations.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/benchmarks.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef function1():\n    pass\n\nclass Class(object):\n\n    def function1(self):\n        pass\n\n    @classmethod\n    def function1cm(cls):\n        pass\n\n    @staticmethod\n    def function1sm():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Adapter Factory in Python\nDESCRIPTION: Shows how to create a custom adapter factory by extending wrapt.AdapterFactory class for decorator customization.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/changes.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass DelegatedAdapterFactory(wrapt.AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\n\nadapter_factory = DelegatedAdapterFactory\n```\n\n----------------------------------------\n\nTITLE: Simple Function Wrapper Usage in Python\nDESCRIPTION: Example of using the decorator factory to create a simple function wrapper that prints instance, args, and kwargs before executing the wrapped function.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/05-decorators-which-accept-arguments.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    print('INSTANCE', instance)\n    print('ARGS', args)\n    print('KWARGS', kwargs)\n    return wrapped(*args, **kwargs)\n\n@my_function_wrapper\ndef function(a, b):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Applying Decorator to Class Method\nDESCRIPTION: Shows how to apply the universal decorator to a class method using the @ syntax.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Example(object):\n\n    @universal\n    def name(self):\n        return 'name'\n```\n\n----------------------------------------\n\nTITLE: Using the Robust Decorator Implementation in Python\nDESCRIPTION: Example showing how to use the robust decorator implementation with a class method, demonstrating the correct syntax for this approach.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef my_function_wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Closure Decorator for Method Tracing in Python\nDESCRIPTION: Example of a simple function closure-based decorator applied to a class method, with execution tracing to analyze call patterns.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef my_function_wrapper(wrapped):\n    def _my_function_wrapper(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _my_function_wrapper\n\nclass Class(object):\n    @my_function_wrapper\n    def method(self):\n        pass\n\ninstance = Class()\n\nimport sys\n\ndef tracer(frame, event, arg):\n    print(frame.f_code.co_name, event)\n\nsys.setprofile(tracer)\n\ninstance.method()\n```\n\n----------------------------------------\n\nTITLE: Basic Class Decorator Example\nDESCRIPTION: Demonstrates basic application of a decorator to a class definition\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@my_function_wrapper\nclass Class(object):\n    pass\n\n>>> c = Class()\nINSTANCE None\nARGS ()\n```\n\n----------------------------------------\n\nTITLE: Instance Method Decoration with Wrapt\nDESCRIPTION: Demonstrates how to apply a pass-through decorator to an instance method using wrapt. Shows both instance and class-level method calls.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\nclass Class(object):\n\n    @pass_through\n    def function_im(self, arg1, arg2):\n        pass\n\nc = Class()\n\nc.function_im(1, 2)\n\nClass.function_im(c, 1, 2)\n```\n\n----------------------------------------\n\nTITLE: Performance of C Extension Robust Decorator on Methods\nDESCRIPTION: Timing results for a method decorated with the C extension implementation of the robust decorator, showing improved performance over pure Python.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n1000000 loops, best of 3: 0.836 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Decorator Module Implementation in Python\nDESCRIPTION: Implementation using the decorator module from PyPI, showing usage with regular functions and methods. Demonstrates decorator placement with classmethod and staticmethod decorators.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/benchmarks.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@decorator.decorator\ndef wrapper4(wrapped, *args, **kwargs):\n    return wrapped(*args, **kwargs)\n\n@wrapper4\ndef function4():\n    pass\n\nclass Class(object):\n\n    @wrapper4\n    def function4(self):\n        pass\n\n    @classmethod\n    @wrapper4\n    def function4cmi(cls):\n        pass\n\n    @staticmethod\n    @wrapper4\n    def function4smi():\n        pass\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operations with Object Proxy in Python\nDESCRIPTION: Shows how wrapt.ObjectProxy handles arithmetic operations, rich comparisons, and hashing when wrapping numeric values.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> value = 1\n>>> proxy = wrapt.ObjectProxy(value)\n\n>>> proxy + 1\n2\n\n>>> int(proxy)\n1\n>>> hash(proxy)\n1\n>>> hash(value)\n1\n\n>>> proxy < 2\nTrue\n>>> proxy == 0\nFalse\n```\n\n----------------------------------------\n\nTITLE: Custom Proxy with Private Attributes in Python\nDESCRIPTION: Shows how to implement a custom proxy that maintains its own private attributes using the _self_ prefix.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/wrappers.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef function():\n    print('executing', function.__name__)\n\nclass CallableWrapper(wrapt.ObjectProxy):\n\n    def __init__(self, wrapped, wrapper):\n        super(CallableWrapper, self).__init__(wrapped)\n        self._self_wrapper = wrapper\n\n    def __call__(self, *args, **kwargs):\n        return self._self_wrapper(self.__wrapped__, args, kwargs)\n\ndef wrapper(wrapped, args, kwargs):\n      print('entering', wrapped.__name__)\n      try:\n          return wrapped(*args, **kwargs)\n      finally:\n          print('exiting', wrapped.__name__)\n```\n\n----------------------------------------\n\nTITLE: Performance of Robust Decorator Factory Implementation in Python\nDESCRIPTION: Timing results for the pure Python implementation of the decorator factory pattern, showing significantly higher overhead than simpler approaches.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n1000000 loops, best of 3: 0.771 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Transparent Object Proxy in Python\nDESCRIPTION: This code demonstrates a basic implementation of a transparent object proxy in Python that handles attribute access to make the proxy behave like the wrapped object.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass object_proxy(object):\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__name__= wrapped.__name__\n        except AttributeError:\n            pass\n\n    @property\n    def __class__(self):\n        return self.wrapped.__class__\n\n    def __getattr__(self, name):\n        return getattr(self.wrapped, name)\n```\n\n----------------------------------------\n\nTITLE: Custom Adapter Factory Implementation\nDESCRIPTION: Demonstrates how to create a custom adapter factory by subclassing wrapt.AdapterFactory for dynamic adapter generation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass DelegatedAdapterFactory(wrapt.AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\n\nadapter_factory = DelegatedAdapterFactory\n```\n\n----------------------------------------\n\nTITLE: Mock Example: Function Return Value Wrapping\nDESCRIPTION: Shows how to wrap a function that returns another function using Mock, allowing interception of the returned function's calls.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom mock import Mock, patch\n\ndef function():\n    pass\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        return function\n\ndef wrapper2(wrapped):\n    def _wrapper2(*args, **kwargs):\n        return wrapped(*args, **kwargs)\n    return _wrapper2\n\ndef wrapper1(wrapped):\n    def _wrapper1(self, *args, **kwargs):\n        func = wrapped(self, *args, **kwargs)\n        return Mock(side_effect=wrapper2(func))\n    return _wrapper1\n\n@patch(__name__+'.ProductionClass.method', autospec=True,\n        side_effect=wrapper1(ProductionClass.method))\ndef test_method(mock_method):\n    real = ProductionClass()\n    func = real.method(3, 4, 5, key='value')\n    result = func()\n```\n\n----------------------------------------\n\nTITLE: Basic Function Wrapping with Wrapt\nDESCRIPTION: Demonstrates basic function wrapping using wrapt decorators to modify method behavior. Shows a problematic approach of modifying global objects directly.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper, function_wrapper\n\nclass StorageClass(object):\n    def run(self):\n        pass\n\nstorage = StorageClass()\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        return storage\n\n@function_wrapper\ndef run_method_wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@transient_function_wrapper(__name__, 'ProductionClass.method')\ndef apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):\n    storage = wrapped(*args, **kwargs)\n    storage.run = run_method_wrapper(storage.run)\n    return storage\n\n@apply_ProductionClass_method_wrapper\ndef test_method():\n    real = ProductionClass()\n    data = real.method(3, 4, 5, key='value')\n    result = data.run()\n```\n\n----------------------------------------\n\nTITLE: Mock Example: Side Effects with Original Method Call\nDESCRIPTION: Demonstrates using Mock with side effects to validate arguments while still calling the original method. Uses autospec for proper method binding.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom mock import Mock, patch\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        print a, b, c, key\n\ndef wrapper(wrapped):\n    def _wrapper(self, *args, **kwargs):\n        assert args == (3, 4, 5) and kwargs.get('key') == 'value'\n        return wrapped(self, *args, **kwargs)\n    return _wrapper\n\n@patch(__name__+'.ProductionClass.method', autospec=True,\n        side_effect=wrapper(ProductionClass.method))\n\ndef test_method(mock_method):\n    real = ProductionClass()\n    result = real.method(3, 4, 5, key='value')\n```\n\n----------------------------------------\n\nTITLE: Patch Function Wrapper Decorator\nDESCRIPTION: Demonstrates using wrapt's patch_function_wrapper decorator for automatic monkey patching upon module import.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport wrapt\n\n@wrapt.patch_function_wrapper('example', 'Example.name')\ndef wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Class Method Decorators Example\nDESCRIPTION: Demonstrates applying decorators to different types of class methods (instance, class, and static methods)\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/04-implementing-a-universal-decorator.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n\n    @my_function_wrapper\n    def function_im(self, a, b):\n        pass\n\n    @my_function_wrapper\n    @classmethod\n    def function_cm(self, a, b):\n        pass\n\n    @my_function_wrapper\n    @staticmethod\n    def function_sm(a, b):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Execution Trace Output for Robust Decorator on Methods\nDESCRIPTION: Trace output showing the more complex execution flow when a method is decorated with the descriptor-based approach, highlighting the extra binding steps.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n('__get__', 'call') # function_wrapper\n    ('__init__', 'call') # bound_function_wrapper\n        ('__init__', 'call') # object_proxy\n        ('__init__', 'return')\n    ('__init__', 'return')\n('__get__', 'return')\n\n('__call__', 'call') # bound_function_wrapper\n    ('my_function_wrapper', 'call')\n        ('method', 'call')\n        ('method', 'return')\n    ('my_function_wrapper', 'return')\n('__call__', 'return')\n```\n\n----------------------------------------\n\nTITLE: Class Method Definition Example\nDESCRIPTION: Example of defining a class method with the decorator, showing how class methods are implemented.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n\n    @my_function_wrapper\n    @classmethod\n    def function_cm(cls, a, b):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Function Return with Wrapper Example in Python\nDESCRIPTION: Example showing a basic function return statement with wrapped arguments, demonstrating how wrapper functions handle both positional and keyword arguments.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nreturn wrapped(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Class-Level Lock Synchronization Example\nDESCRIPTION: Example showing class-level lock synchronization with multiple methods\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Class(object):\n    lock1 = threading.RLock()\n    lock2 = threading.RLock()\n\n    @synchronized(lock1)\n    @classmethod\n    def function_cm_1(cls):\n        pass\n\n    @synchronized(lock1)\n    def function_im_1(self):\n        pass\n\n    @synchronized(lock2)\n    @classmethod\n    def function_cm_2(cls):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Execution Trace Output for Function Closure Decorator on Methods\nDESCRIPTION: Trace output showing the execution flow when a method decorated with a function closure is called, demonstrating the simplicity of this approach.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n_my_function_wrapper call\n    method call\n    method return\n_my_function_wrapper return\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Decorated Class in Python\nDESCRIPTION: Shows the correct way to inherit from a decorated class by accessing the original wrapped class using __wrapped__ attribute. Required for Python versions before 3.7.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/issues.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@mydecorator\nclass Base(object):\n    pass\n\nclass Derived(Base.__wrapped__):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Pre-@ Syntax Decorator Application\nDESCRIPTION: Demonstrates the traditional way of applying decorators before the @ syntax was introduced in Python.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Example(object):\n\n    def name(self):\n        return 'name'\n    name = universal(name)\n```\n\n----------------------------------------\n\nTITLE: Basic Synchronized Usage Example\nDESCRIPTION: Simple example showing synchronized usage in a with statement\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/examples.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith synchronized(self):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Performance of Undecorated Method Call in Python\nDESCRIPTION: Timing results for an undecorated method call, establishing the baseline for method call performance.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n10000000 loops, best of 3: 0.143 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Discovering Python Import Hooks\nDESCRIPTION: Code snippet showing the basic logic for discovering and registering post-import hooks based on a provided name.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nname = name.strip()\nif name:\n    print 'discover', name\n    discover_post_import_hooks(name)\n```\n\n----------------------------------------\n\nTITLE: Mock Example: Return Value Patching in Python\nDESCRIPTION: Shows how to use Mock library to patch a method's return value and verify method calls. Uses @patch decorator to temporarily override method behavior during testing.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom mock import Mock, patch\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        print a, b, c, key\n\n@patch(__name__+'.ProductionClass.method', return_value=3)\ndef test_method(mock_method):\n    real = ProductionClass()\n    result = real.method(3, 4, 5, key='value')\n    mock_method.assert_called_with(3, 4, 5, key='value')\n    assert result == 3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Binding in Python Classes\nDESCRIPTION: This snippet shows how method binding works in Python classes, where a function inside a class becomes a bound method when accessed through an instance.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> class Object(object):\n...   def f(self): pass\n\n>>> obj = Object()\n\n>>> obj.f\n<bound method Object.f of <__main__.Object object at 0x10abf29d0>>\n```\n\n----------------------------------------\n\nTITLE: Timing Function Execution with Python's timeit Module\nDESCRIPTION: This code snippet shows how to use the timeit module to measure the execution time of a decorated function. It's used to compare the performance overhead of different decorator implementations.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/09-performance-overhead-of-using-decorators.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# benchmarks.py\ndef function():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Setup.py Configuration for Monkey Patch Package\nDESCRIPTION: Package configuration using setuptools to create installable monkey patch modules with entry points for discovery.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nNAME = 'wrapt_patches.tempfile_debugging'\n\ndef patch_module(module, function=None):\n    function = function or 'patch_%s' % module.replace('.', '_')\n    return '%s = %s:%s' % (module, NAME, function)\n\nENTRY_POINTS = [\n    patch_module('tempfile'),\n]\n\nsetup_kwargs = dict(\n    name = NAME,\n    version = '0.1',\n    packages = ['wrapt_patches'],\n    package_dir = {'wrapt_patches': 'src'},\n    entry_points = { NAME: ENTRY_POINTS },\n)\n\nsetup(**setup_kwargs)\n```\n\n----------------------------------------\n\nTITLE: Wrapt Example: Function Return Value Wrapping\nDESCRIPTION: Demonstrates wrapping a returned function using wrapt's function_wrapper decorator, providing a cleaner alternative to Mock's approach.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/12-using-wrapt-to-support-testing-of-software.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import transient_function_wrapper, function_wrapper\n\ndef function():\n    pass\n\nclass ProductionClass(object):\n    def method(self, a, b, c, key):\n        return function\n\n@function_wrapper\ndef result_function_wrapper(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@transient_function_wrapper(__name__, 'ProductionClass.method')\ndef apply_ProductionClass_method_wrapper(wrapped, instance, args, kwargs):\n    return result_function_wrapper(wrapped(*args, **kwargs))\n\n@apply_ProductionClass_method_wrapper\ndef test_method():\n    real = ProductionClass()\n    func = real.method(3, 4, 5, key='value')\n    result = func()\n```\n\n----------------------------------------\n\nTITLE: Final Monkey Patch Implementation Module\nDESCRIPTION: Complete implementation of a monkey patch module that wraps the tempfile.mkdtemp function with debugging capabilities.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom wrapt import wrap_function_wrapper\n\ndef _mkdtemp_wrapper(wrapped, instance, args, kwargs):\n    print 'calling', wrapped.__name__\n    return wrapped(*args, **kwargs)\n\ndef patch_tempfile(module):\n    print 'patching', module.__name__\n    wrap_function_wrapper(module, 'mkdtemp', _mkdtemp_wrapper)\n```\n\n----------------------------------------\n\nTITLE: Benchmark Command for Testing Method Call Performance in Python\nDESCRIPTION: Shell command using timeit to benchmark the performance of method calls with different decorator implementations.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ python -m timeit -s 'import benchmarks; c=benchmarks.Class()' 'c.method()'\n```\n\n----------------------------------------\n\nTITLE: Explicit Post Import Hook Registration in Python\nDESCRIPTION: Alternative approach to register post import hooks using explicit function calls rather than decorators.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport imp\n\ndef register(decimal):\n    Inexact.register(decimal.Decimal)\n\nimp.register_post_import_hook(register, 'decimal')\n```\n\n----------------------------------------\n\nTITLE: Tracing Function Execution with Python's Profile Hooks\nDESCRIPTION: This snippet demonstrates how to use Python's profile hooks mechanism to trace the execution of a decorated function. It helps visualize the different function calls involved in each decorator implementation.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/09-performance-overhead-of-using-decorators.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\ndef tracer(frame, event, arg):\n    print(frame.f_code.co_name, event)\n\nsys.setprofile(tracer)\n\nfunction()\n```\n\n----------------------------------------\n\nTITLE: Site Customization Wrapper Functions\nDESCRIPTION: Implementation of wrapper functions for executing site customization during Python initialization.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef _execsitecustomize_wrapper(wrapped):\n    def _execsitecustomize(*args, **kwargs):\n        try:\n            return wrapped(*args, **kwargs)\n        finally:\n            if not site.ENABLE_USER_SITE:\n                _register_bootstrap_functions()\n    return _execsitecustomize\n\ndef _execusercustomize_wrapper(wrapped):\n    def _execusercustomize(*args, **kwargs):\n        try:\n```\n\n----------------------------------------\n\nTITLE: Manual Import Hook Installation\nDESCRIPTION: Code that needs to be added at the start of Python applications for manual patch discovery and application.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom wrapt import discover_post_import_hooks\n\npatches = os.environ.get('WRAPT_PATCHES')\n\nif patches:\n    for name in patches.split(','):\n        name = name.strip()\n        if name:\n            print 'discover', name\n            discover_post_import_hooks(name)\n```\n\n----------------------------------------\n\nTITLE: Interactive Python Shell Commands for Testing Monkey Patch\nDESCRIPTION: Example showing how to test the monkey patch implementation in an interactive Python shell.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ python -i lazyloader.py\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import tempfile\npatching tempfile\n>>> tempfile.mkdtemp()\ncalling mkdtemp\n'/var/folders/0p/4vcv19pj5d72m_bx0h40sw340000gp/T/tmpfB8r20'\n```\n\n----------------------------------------\n\nTITLE: Environment-based Patch Discovery Setup\nDESCRIPTION: Initial setup code for discovering and loading monkey patches based on environment variables.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nfrom wrapt import discover_post_import_hooks\n\npatches = os.environ.get('WRAPT_PATCHES')\n\nif patches:\n    for name in patches.split(','):\n```\n\n----------------------------------------\n\nTITLE: Abstract Base Class TypeError Example\nDESCRIPTION: Example of the TypeError that occurs when using issubclass() with decorated classes that use abc.ABCMeta metaclass.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/issues.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nTypeError: issubclass() arg 1 must be a class\n```\n\n----------------------------------------\n\nTITLE: Namespace Package Initialization in Python\nDESCRIPTION: Required initialization code for creating a namespace package to organize monkey patch modules.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pkgutil\n__path__ = pkgutil.extend_path(__path__, __name__)\n```\n\n----------------------------------------\n\nTITLE: Function Argument Specification Example\nDESCRIPTION: Demonstrates how to preserve and inspect function argument specifications when using wrapt decorators, using inspect.getargspec().\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/decorators.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@wrapt.decorator\ndef my_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@my_decorator\ndef function(arg1, arg2):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Enabling Wrapt Patches via Environment Variable\nDESCRIPTION: Shell command demonstrating how to enable specific monkey patches using the WRAPT_PATCHES environment variable.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ WRAPT_PATCHES=wrapt_patches.tempfile_debugging python -i entrypoints.py\n```\n\n----------------------------------------\n\nTITLE: Performance of Function Closure Decorator on Methods in Python\nDESCRIPTION: Timing results for a method decorated with a function closure implementation, showing the additional overhead introduced.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n1000000 loops, best of 3: 0.382 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Basic Python Module Import Example\nDESCRIPTION: Demonstrates the standard Python import syntax that can cause monkey patching challenges.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom module import function\n```\n\n----------------------------------------\n\nTITLE: Corrected Instance Method Call Output\nDESCRIPTION: Demonstrates the corrected output when calling an instance method through the class after implementing the wrapper.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> Class.function_im(c, 1, 2)\nINSTANCE <__main__.Class object at 0x1085ca9d0>\nARGS (1, 2)\n```\n\n----------------------------------------\n\nTITLE: Automated Bootstrap PTH File Code\nDESCRIPTION: Single-line .pth file code that conditionally imports and executes the bootstrap module.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport os, sys; os.environ.get('AUTOWRAPT_BOOTSTRAP') and __import__('autowrapt.bootstrap') and sys.modules['autowrapt.bootstrap'].bootstrap()\n```\n\n----------------------------------------\n\nTITLE: Implementing Bootstrap Function in Python\nDESCRIPTION: Function to register bootstrap functions by reading package names from an environment variable and discovering post-import hooks. Uses a global flag to prevent multiple registrations.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n_registered = False\n\ndef _register_bootstrap_functions():\n    global _registered\n    if _registered:\n        return\n    _registered = True\n\n    from wrapt import discover_post_import_hooks\n    for name in os.environ.get('AUTOWRAPT_BOOTSTRAP', '').split(','):\n        discover_post_import_hooks(name)\n```\n\n----------------------------------------\n\nTITLE: Performance of C Extension-Based Decorator Implementation in Python\nDESCRIPTION: Timing results for the C extension implementation of the decorator factory, showing improved performance over the pure Python version.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n1000000 loops, best of 3: 0.382 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Running Specific Test Environment with tox\nDESCRIPTION: Command to run tests for a specific Python version and extension configuration using tox with the -e option.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/testing.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntox -e py39-install-extensions\n```\n\n----------------------------------------\n\nTITLE: Interactive Python Session with Patch Application\nDESCRIPTION: Python console output showing the discovery and application of a tempfile debugging patch at runtime.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/13-ordering-issues-when-monkey-patching-in-python.md#2025-04-21_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\ndiscover wrapt_patches.tempfile_debugging\n>>> import tempfile\npatching tempfile\n```\n\n----------------------------------------\n\nTITLE: Package Setup Configuration in Python\nDESCRIPTION: Setup configuration for the autowrapt package including package metadata, dependencies, data files, and entry points. Uses setuptools and distutils for configuration.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport os\n\nfrom setuptools import setup\nfrom distutils.sysconfig import get_python_lib\n\nsetup_kwargs = dict(\n    name = 'autowrapt',\n    packages = ['autowrapt'],\n    package_dir = {'autowrapt': 'src'},\n    data_files = [(get_python_lib(prefix=''), ['autowrapt-init.pth'])],\n    entry_points = {'autowrapt.examples': ['this = autowrapt.examples:autowrapt_this']},\n    install_requires = ['wrapt>=1.10.4'],\n)\n\nsetup(**setup_kwargs)\n```\n\n----------------------------------------\n\nTITLE: Java Synchronized Method Implementation\nDESCRIPTION: Example of Java class using synchronized methods to ensure thread-safe counter operations.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic class SynchronizedCounter {\n    private int c = 0;\n    public synchronized void increment() {\n        c++;\n    }\n    public synchronized void decrement() {\n        c--;\n    }\n    public synchronized int value() {\n        return c;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tox Test Environments for Wrapt\nDESCRIPTION: Defines test environment configuration for Wrapt project testing. Sets up Python version requirements and specifies commands for running tests using pytest. Includes test coverage configuration.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/tests/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\ntox\n```\n\n----------------------------------------\n\nTITLE: Example Autowrapt Hook Implementation\nDESCRIPTION: Example implementation of an autowrapt hook function that extends the behavior of Python's 'this' module by printing additional text when the module is imported.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import print_function\n\ndef autowrapt_this(module):\n    print('The wrapt package is absolutely amazing and you should use it.')\n```\n\n----------------------------------------\n\nTITLE: Implementation of functools.update_wrapper in Python\nDESCRIPTION: This code shows how functools.update_wrapper works in Python 3.3, highlighting how it preserves attributes from the wrapped function including __name__, __doc__, and __dict__.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/02-the-interaction-between-decorators-and-descriptors.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nWRAPPER_ASSIGNMENTS = ('__module__',\n       '__name__', '__qualname__', '__doc__',\n       '__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\n\ndef update_wrapper(wrapper, wrapped,\n        assigned = WRAPPER_ASSIGNMENTS,\n        updated = WRAPPER_UPDATES):\n    wrapper.__wrapped__ = wrapped\n    for attr in assigned:\n        try:\n            value = getattr(wrapped, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in updated:\n        getattr(wrapper, attr).update(\n                getattr(wrapped, attr, {}))\n```\n\n----------------------------------------\n\nTITLE: Type Checking Example\nDESCRIPTION: Shows the difference between function and instance method types in Python class definitions.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/11-safely-applying-monkey-patches-in-python.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Example(object):\n    def name(self):\n        return 'name'\n    print type(name)\n\nprint type(Example.name)\n```\n\n----------------------------------------\n\nTITLE: Synchronized Context Manager Example\nDESCRIPTION: Example showing the intended usage of synchronized as a context manager for block-level synchronization.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Object(object):\n\n    @synchronized\n    def function_im_1(self):\n        pass\n\n    def function_im_2(self):\n        with synchronized(self):\n            pass\n```\n\n----------------------------------------\n\nTITLE: Class Method Call Output\nDESCRIPTION: Shows the problematic output when calling a decorated class method, highlighting the issue with instance handling.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/03-implementing-a-factory-for-creating-decorators.md#2025-04-21_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n>>> Class.function_cm(1, 2)\nINSTANCE 1\nARGS (2,)\n```\n\n----------------------------------------\n\nTITLE: Running Tests with tox in wrapt\nDESCRIPTION: Command to run tests for all supported Python versions (2.7, 3.5-3.9 and PyPy) with and without C extensions using tox.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/testing.rst#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntox\n```\n\n----------------------------------------\n\nTITLE: Class-based Wrapper Inspection Error\nDESCRIPTION: Demonstrates the TypeError that occurs when trying to inspect a function wrapped with a class-based decorator.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/01-how-you-implemented-your-python-decorator-is-wrong.md#2025-04-21_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(inspect.getargspec(function))\nTraceback (most recent call last):\n  File \"...\", line XXX, in <module>\n    print(inspect.getargspec(function))\n  File \".../inspect.py\", line 813, in getargspec\n    raise TypeError('{!r} is not a Python function'.format(func))\nTypeError: <__main__.function_wrapper object at 0x107e0ac90> is not a Python function\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Basic Function Call Performance in Python\nDESCRIPTION: Timing results for executing a basic function call without any decoration, showing the baseline performance metric.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n10000000 loops, best of 3: 0.132 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Java Fine-Grained Locking Example\nDESCRIPTION: Java class showing fine-grained locking using separate lock objects for different counters.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class MsLunch {\n    private long c1 = 0;\n    private long c2 = 0;\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n    public void inc1() {\n        synchronized(lock1) {\n            c1++;\n        }\n    }\n    public void inc2() {\n        synchronized(lock2) {\n            c2++;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Performance of Pure Python Robust Decorator on Methods\nDESCRIPTION: Timing results for a method decorated with the pure Python robust decorator implementation, showing significantly higher overhead.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n100000 loops, best of 3: 6.67 usec per loop\n```\n\n----------------------------------------\n\nTITLE: Collecting and Viewing Coverage Results\nDESCRIPTION: Sequence of commands to run tests, combine coverage data, and generate HTML coverage reports for local viewing.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/testing.rst#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntox\ncoverage combine\ncoverage html --ignore-errors\n```\n\n----------------------------------------\n\nTITLE: Installing Wrapt Package\nDESCRIPTION: Command for installing the Wrapt package using pip package manager.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install wrapt\n```\n\n----------------------------------------\n\nTITLE: Easy Install Path Management Code\nDESCRIPTION: Example of executable code in a .pth file used by easy_install to manage Python path modifications.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys; sys.__plen = len(sys.path)\n./antigravity-0.1-py2.7.egg\nimport sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,'__egginsert',0); sys.path[p:p]=new; sys.__egginsert = p+len(new)\n```\n\n----------------------------------------\n\nTITLE: Java Synchronized Statement Example\nDESCRIPTION: Demonstration of Java synchronized statement block using this as the lock object.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/07-the-missing-synchronized-decorator.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic void addName(String name) {\n    synchronized(this) {\n        lastName = name;\n        nameCount++;\n    }\n    nameList.add(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Python Site Module Initialization\nDESCRIPTION: Main function from Python's site module showing the interpreter initialization sequence.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/14-automatic-patching-of-python-applications.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef main():\n    global ENABLE_USER_SITE\n    abs__file__()\n    known_paths = removeduppaths()\n    if ENABLE_USER_SITE is None:\n        ENABLE_USER_SITE = check_enableusersite()\n    known_paths = addusersitepackages(known_paths)\n    known_paths = addsitepackages(known_paths)\n    if sys.platform == 'os2emx':\n        setBEGINLIBPATH()\n    setquit()\n    setcopyright()\n    sethelper()\n    aliasmbcs()\n    setencoding()\n    execsitecustomize()\n    if ENABLE_USER_SITE:\n        execusercustomize()\n    # Remove sys.setdefaultencoding() so that users cannot change the\n    # encoding after initialization. The test for presence is needed when\n    # this module is run as a script, because this code is executed twice.\n    if hasattr(sys, \"setdefaultencoding\"):\n        del sys.setdefaultencoding\n```\n\n----------------------------------------\n\nTITLE: Listing Sphinx Documentation Dependencies\nDESCRIPTION: This snippet lists the required Python packages for generating Sphinx documentation with the Read the Docs theme. It includes Sphinx itself and the specific theme package.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/docs/requirements.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsphinx\nsphinx_rtd_theme\n```\n\n----------------------------------------\n\nTITLE: Performance of Function Closure Decorator Implementation in Python\nDESCRIPTION: Timing results for a function decorated with a simple function closure implementation, showing increased overhead compared to undecorated functions.\nSOURCE: https://github.com/grahamdumpleton/wrapt/blob/develop/blog/10-performance-overhead-when-applying-decorators-to-methods.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n1000000 loops, best of 3: 0.326 usec per loop\n```"
  }
]