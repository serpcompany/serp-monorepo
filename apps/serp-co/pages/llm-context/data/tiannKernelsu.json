[
  {
    "owner": "tiann",
    "repo": "kernelsu",
    "content": "TITLE: Rendering dynamic device support table with Vue.js and JSON data\nDESCRIPTION: This snippet implements a Vue.js component that imports a JSON file containing kernel repository data and renders a table dynamically. It uses Vue's v-for directive to iterate over each repository entry, displaying maintainer names, kernel repository links, and the list of supported devices. Key dependencies include Vue.js for reactivity and the presence of '../../repos.json' containing data objects with maintainer, kernel, and device fields. The dynamic table enhances maintainability and scalability by reflecting the latest data changes without code modifications.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/unofficially-support-devices.md#_snippet_0\n\nLANGUAGE: Vue.js\nCODE:\n```\n<script setup>\\nimport data from '../../repos.json'\\n</script>\\n\\n<table>\\n   <thead>\\n      <tr>\\n         <th>Người bảo trì</th>\\n         <th>Kho lưu trữ</th>\\n         <th>Thiết bị hỗ trợ</th>\\n      </tr>\\n   </thead>\\n   <tbody>\\n    <tr v-for=\"repo in data\" :key=\"repo.devices\">\\n        <td><a :href=\"repo.maintainer_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.maintainer }}</a></td>\\n        <td><a :href=\"repo.kernel_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.kernel_name }}</a></td>\\n        <td>{{ repo.devices }}</td>\\n    </tr>\\n   </tbody>\\n</table>\n```\n\n----------------------------------------\n\nTITLE: Manually Patching fs/exec.c for KernelSU (Diff/C)\nDESCRIPTION: Provides a diff patch illustrating how to modify the `do_execveat_common` function in `fs/exec.c`. It adds external function declarations and conditional calls to `ksu_handle_execveat` and `ksu_handle_execveat_sucompat` based on the `CONFIG_KSU` flag and `ksu_execveat_hook` variable. This is part of the manual integration process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/exec.c b/fs/exec.c\nindex ac59664eaecf..bdd585e1d2cc 100644\n--- a/fs/exec.c\n+++ b/fs/exec.c\n@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,\n \treturn retval;\n }\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_execveat_hook __read_mostly;\n+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,\n+\t\t\tvoid *envp, int *flags);\n+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,\n+\t\t\t\t void *argv, void *envp, int *flags);\n+#endif\n static int do_execveat_common(int fd, struct filename *filename,\n \t\t\t      struct user_arg_ptr argv,\n \t\t\t      struct user_arg_ptr envp,\n \t\t\t      int flags)\n {\n+   #ifdef CONFIG_KSU\n+\tif (unlikely(ksu_execveat_hook))\n+\t\tksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);\n+\telse\n+\t\tksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);\n+   #endif\n \treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n }\n```\n\n----------------------------------------\n\nTITLE: Enabling BusyBox Standalone Mode (Shell)\nDESCRIPTION: Demonstrates two methods to enable BusyBox's ASH Standalone Shell Mode outside of the standard KernelSU execution environment. The first uses the `ASH_STANDALONE=1` environment variable, which is preferred as it's inherited by child processes. The second uses the `-o standalone` command-line option. This mode forces the `ash` shell to use internal BusyBox applets for all commands, ensuring a predictable environment.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>\n```\n\nLANGUAGE: sh\nCODE:\n```\n/data/adb/ksu/bin/busybox sh -o standalone <script>\n```\n\n----------------------------------------\n\nTITLE: Installing KernelSU into Kernel Source Tree Using Setup Script - Shell\nDESCRIPTION: This snippet provides three variants to fetch and execute the KernelSU setup script from GitHub to integrate KernelSU features into the kernel source. The user can specify latest stable tag, main branch for development version, or a specific version tag (e.g., v0.5.2). This command runs in the kernel source root directory and requires internet access with curl installed. The setup script modifies kernel source as per KernelSU integration needs. After execution, rebuilding the kernel produces a KernelSU-enabled kernel image.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Repacking Boot Image with magiskboot on Android (Shell)\nDESCRIPTION: Executes the `magiskboot` binary on the Android device to repack the boot image using the modified components (specifically, the KernelSU `Image` renamed to `kernel`). This creates a new file named `new-boot.img`.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n./magiskboot repack boot.img\n\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU Support to Kernel Source using Shell Script from GitHub\nDESCRIPTION: This group of shell commands downloads and runs the KernelSU setup script from the official GitHub repository to add KernelSU support into the kernel source tree. It supports installing a stable version (latest tag), the main development branch, or selecting a specific tag by passing it as an argument. After running this script, the kernel can be rebuilt with KernelSU enabled.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/read_write.c for KernelSU Integration\nDESCRIPTION: Patch for read_write.c to hook into the vfs_read functionality, which allows KernelSU to intercept and modify file read operations for various security features.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/read_write.c b/fs/read_write.c\nindex 650fc7e0f3a6..55be193913b6 100644\n--- a/fs/read_write.c\n+++ b/fs/read_write.c\n@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n }\n EXPORT_SYMBOL(kernel_read);\n \n+extern bool ksu_vfs_read_hook __read_mostly;\n+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,\n+\t\t\tsize_t *count_ptr, loff_t **pos);\n ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n {\n \tssize_t ret;\n \n+\tif (unlikely(ksu_vfs_read_hook))\n+\t\tksu_handle_vfs_read(&file, &buf, &count, &pos);\n+\n \tif (!(file->f_mode & FMODE_READ))\n \t\treturn -EBADF;\n \tif (!(file->f_mode & FMODE_CAN_READ))\n```\n\n----------------------------------------\n\nTITLE: Building Kernel with KernelSU Integration\nDESCRIPTION: This set of commands facilitates integrating KernelSU into an already successful kernel build. It includes fetching the setup script from a GitHub repository and executing it with different tags or branches (latest stable, main branch, specific version tags). These commands prepare the environment for building a kernel with KernelSU support.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Installing KernelSU via Script from GitHub (Stable Tag)\nDESCRIPTION: This command downloads and executes the KernelSU setup script from GitHub using a specific stable release tag, automating the installation process on the kernel source directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU - Shell\nDESCRIPTION: This snippet integrates KernelSU into the kernel source.  It uses `curl` to download and execute a setup script from the KernelSU repository.  The script will modify the kernel source to add KernelSU support. Requires `curl` installed, and the user needs to be in the root of the kernel source directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Building Android Kernel with Bazel (Android 13 and Above) using Shell\nDESCRIPTION: Starting with Android 13, the kernel build process uses Bazel. This snippet shows how to invoke Bazel to build the aarch64 kernel distribution quickly using the 'fast' configuration. It relies on Bazel's build infrastructure targeting the network label //common:kernel_aarch64_dist. This method replaces the traditional shell script-based builds and is geared towards faster and reproducible builds.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU to Kernel Source (Latest Stable)\nDESCRIPTION: This shell command downloads and executes the `setup.sh` script from the KernelSU repository to integrate the latest stable version of KernelSU into the kernel source tree. The script automates the process of copying KernelSU files and making necessary modifications.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Android Kernel Source Code Using Repo\nDESCRIPTION: This snippet demonstrates the process of initializing and syncing the Android kernel source repository using 'repo' commands. It involves creating a local manifest and synchronizing all necessary source files based on a provided manifest file, which should be downloaded from Google's GKI release builds page.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Initializing Android Kernel Source Repo using Shell\nDESCRIPTION: This snippet initializes the Android kernel source repository by setting up the repo tool with a custom kernel manifest file. The manifest file uniquely identifies the kernel build and ensures reproducibility. It requires having the <kernel_manifest.xml> file downloaded from the GKI release builds. The commands sync the source code according to the specified manifest, enabling developers to work with a consistent kernel source tree.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: KernelSU Script Utility Functions\nDESCRIPTION: Documents the utility functions (`ui_print`, `abort`, `set_perm`, `set_perm_recursive`) provided by the KernelSU environment for use in scripts like `customize.sh` and boot scripts. Explains their purpose, parameters, and usage, noting preferred alternatives to standard shell commands like `echo` and `exit`.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_7\n\nLANGUAGE: txt\nCODE:\n```\nui_print <msg>\n    print <msg> to console\n    Avoid using 'echo' as it will not display in custom recovery's console\n\nabort <msg>\n    print error message <msg> to console and terminate the installation\n    Avoid using 'exit' as it will skip the termination cleanup steps\n\nset_perm <target> <owner> <group> <permission> [context]\n    if [context] is not set, the default is \"u:object_r:system_file:s0\"\n    this function is a shorthand for the following commands:\n       chown owner.group target\n       chmod permission target\n       chcon context target\n\nset_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]\n    if [context] is not set, the default is \"u:object_r:system_file:s0\"\n    for all files in <directory>, it will call:\n       set_perm file owner group filepermission context\n    for all directories in <directory> (including itself), it will call:\n       set_perm dir owner group dirpermission context\n\n```\n\n----------------------------------------\n\nTITLE: Determining Module Directory in Scripts (Shell)\nDESCRIPTION: Recommends using `MODDIR=${0%/*}` within module shell scripts (like `service.sh`, `post-fs-data.sh`) to dynamically get the module's base directory path. This method reliably extracts the directory from the script's own path (`$0`) and avoids hardcoding paths, ensuring portability.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nMODDIR=${0%/*}\n```\n\n----------------------------------------\n\nTITLE: Magiskboot commands for unpacking, modifying, and repacking boot images on Android\nDESCRIPTION: Details steps to use magiskboot to unpack a device's boot.img, replace its kernel with a custom Image, and repack it for flashing, applicable on rooted Android devices.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/installation.md#_snippet_2\n\nLANGUAGE: Shell Script\nCODE:\n```\n./magiskboot unpack boot.img\nmv -f Image kernel\n./magiskboot repack boot.img\n```\n\n----------------------------------------\n\nTITLE: Fastboot commands for flashing and rebooting\nDESCRIPTION: Shows standard fastboot commands to flash the patched boot image onto the device and to reboot it, essential for GKI mode installation workflows.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/installation.md#_snippet_1\n\nLANGUAGE: Shell Script\nCODE:\n```\nfastboot flash boot boot.img\nfastboot reboot\n```\n\n----------------------------------------\n\nTITLE: KernelSU Setup Script (Specific Tag)\nDESCRIPTION: This command downloads and executes the `setup.sh` script from the KernelSU repository, integrating KernelSU into the kernel build process.  It takes a version tag as an argument (e.g., v0.5.2).\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/exec.c for KernelSU Integration\nDESCRIPTION: Patch for exec.c to hook into the execveat functionality, which is necessary for KernelSU to intercept and modify process execution to implement root access.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/exec.c b/fs/exec.c\nindex ac59664eaecf..bdd585e1d2cc 100644\n--- a/fs/exec.c\n+++ b/fs/exec.c\n@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,\n \treturn retval;\n }\n \n+extern bool ksu_execveat_hook __read_mostly;\n+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,\n+\t\t\tvoid *envp, int *flags);\n+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,\n+\t\t\t\t void *argv, void *envp, int *flags);\n static int do_execveat_common(int fd, struct filename *filename,\n \t\t\t      struct user_arg_ptr argv,\n \t\t\t      struct user_arg_ptr envp,\n \t\t\t      int flags)\n {\n+\tif (unlikely(ksu_execveat_hook))\n+\t\tksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);\n+\telse\n+\t\tksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);\n \treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n }\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/open.c for KernelSU Integration\nDESCRIPTION: Patch for open.c to hook into the faccessat functionality, which allows KernelSU to intercept and modify file access operations for permission management.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 05036d819197..965b84d486b8 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn ksys_fallocate(fd, mode, offset, len);\n }\n \n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t int *flags);\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n  */\n long do_faccessat(int dfd, const char __user *filename, int mode)\n {\n \tconst struct cred *old_cred;\n \tstruct cred *override_cred;\n \tstruct path path;\n \tstruct inode *inode;\n \tstruct vfsmount *mnt;\n \tint res;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW;\n \n+\tksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n \n \tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/stat.c for KernelSU Integration with vfs_statx\nDESCRIPTION: Patch for stat.c to hook into the vfs_statx functionality, which allows KernelSU to intercept and modify file status operations for advanced permission management.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 376543199b5a..82adcef03ecc 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,\n }\n EXPORT_SYMBOL(vfs_statx_fd);\n \n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+\n /**\n  * vfs_statx - Get basic and extra attributes by filename\n  * @dfd: A file descriptor representing the base dir for a relative filename\n@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;\n \n+\tksu_handle_stat(&dfd, &filename, &flags);\n \tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Replacing Directories with setfattr\nDESCRIPTION: This snippet outlines how to replace directories in the system using the `REPLACE` variable and `setfattr` within `customize.sh`.  By setting the `trusted.overlay.opaque` attribute on a directory, OverlayFS will replace the corresponding directory in `/system`.  The expected input is a list of paths to directories, and the output is the replacement of those directories with empty ones in the overlaid system, without altering `/system` itself.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/module.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nREPLACE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Manually Patching fs/read_write.c for KernelSU (Diff/C)\nDESCRIPTION: Provides a diff patch illustrating how to modify the `vfs_read` function in `fs/read_write.c`. It adds external function declarations and a conditional call to `ksu_handle_vfs_read` based on the `CONFIG_KSU` flag and `ksu_vfs_read_hook` variable. This is part of the manual integration process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/read_write.c b/fs/read_write.c\nindex 650fc7e0f3a6..55be193913b6 100644\n--- a/fs/read_write.c\n+++ b/fs/read_write.c\n@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n }\n EXPORT_SYMBOL(kernel_read);\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_vfs_read_hook __read_mostly;\n+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,\n+\t\t\tsize_t *count_ptr, loff_t **pos);\n+#endif\n ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n {\n \tssize_t ret;\n+\n+   #ifdef CONFIG_KSU \n+\tif (unlikely(ksu_vfs_read_hook))\n+\t\tksu_handle_vfs_read(&file, &buf, &count, &pos);\n+   #endif\n+\n \tif (!(file->f_mode & FMODE_READ))\n \t\treturn -EBADF;\n \tif (!(file->f_mode & FMODE_CAN_READ))\n```\n\n----------------------------------------\n\nTITLE: Declaring System Directories for Replacement (Shell)\nDESCRIPTION: Shows how to use the `REPLACE` variable in `customize.sh` to specify system directories that should be entirely replaced by the module's version. KernelSU creates the listed directories within the module's `system` directory and sets the `trusted.overlay.opaque=y` extended attribute on them. This causes OverlayFS to completely mask the original system directory contents with the module's directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nREPLACE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Backporting path_umount and Permission Checks in the Linux Kernel (C)\nDESCRIPTION: This patch introduces two new functions, can_umount and path_umount, to the fs/namespace.c source file of the Linux kernel (C). The can_umount function checks permissions and validity for unmounting using a given path and options such as MNT_FORCE, MNT_DETACH, and UMOUNT_NOFOLLOW, ensuring proper privileges and mount consistency. The path_umount function coordinates permission checking, calls the internal unmount routine, and releases resources, preventing premature expiration marks. Applying this patch requires Linux kernel source code, knowledge of patch application, and recompilation after modification. Parameters include the path to unmount and unmount-specific flags; return values convey success or specific error codes, and constraints include being applicable only on kernels prior to GKI with relevant dependencies present.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/how-to-integrate-for-non-gki.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n--- a/fs/namespace.c\n+++ b/fs/namespace.c\n@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)\n }\n #endif\n\n+static int can_umount(const struct path *path, int flags)\n+{\n+\tstruct mount *mnt = real_mount(path->mnt);\n+\n+\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n+\t\treturn -EINVAL;\n+\tif (!may_mount())\n+\t\treturn -EPERM;\n+\tif (path->dentry != path->mnt->mnt_root)\n+\t\treturn -EINVAL;\n+\tif (!check_mnt(mnt))\n+\t\treturn -EINVAL;\n+\tif (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */\n+\t\treturn -EINVAL;\n+\tif (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\treturn 0;\n+}\n+\n+int path_umount(struct path *path, int flags)\n+{\n+\tstruct mount *mnt = real_mount(path->mnt);\n+\tint ret;\n+\n+\tret = can_umount(path, flags);\n+\tif (!ret)\n+\t\tret = do_umount(mnt, flags);\n+\n+\t/* we mustn't call path_put() as that would clear mnt_expiry_mark */\n+\tdput(path->dentry);\n+\tmntput_no_expire(mnt);\n+\treturn ret;\n+}\n /*\n  * Now umount can handle mount points as well as block devices.\n  * This is important for filesystems which use unnamed block devices.\n\n```\n\n----------------------------------------\n\nTITLE: Patching Boot Image with ksud (Shell)\nDESCRIPTION: Demonstrates the most common usage of the `ksud boot-patch` tool. It patches a specified boot image file (`<boot.img>`) and explicitly sets the KMI version using the `--kmi` option. This command is used to integrate KernelSU into a stock boot image.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nksud boot-patch -b <boot.img> --kmi android13-5.10\n\n```\n\n----------------------------------------\n\nTITLE: Patching stat.c for KernelSU\nDESCRIPTION: This snippet modifies `fs/stat.c` to integrate KernelSU. It adds conditional compilation based on `CONFIG_KSU`, and calls `ksu_handle_stat` before performing the original operations, to enable KernelSU functionality. This hook allows KernelSU to intercept stat calls.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 376543199b5a..82adcef03ecc 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,\n }\n EXPORT_SYMBOL(vfs_statx_fd);\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+#endif\n+  \n /**\n  * vfs_statx - Get basic and extra attributes by filename\n  * @dfd: A file descriptor representing the base dir for a relative filename\n@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;\n \n+   #ifdef CONFIG_KSU\n+  ksu_handle_stat(&dfd, &filename, &flags);\n+   #endif\n \tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t\t   AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Building Android Kernel Using Bazel for Android 13 and Above - Shell\nDESCRIPTION: This snippet explains how to build the Android kernel distribution target for aarch64 architecture using Bazel build system starting from Android 13. It requires Bazel installed and configured properly, with the kernel source code compatible with Bazel build configurations. The command builds the fast configuration of the kernel target '//common:kernel_aarch64_dist'. The output is a kernel distribution artifact generated by Bazel.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Structure\nDESCRIPTION: This snippet illustrates the basic structure of a KernelSU module, which is packaged as a zip file. The `customize.sh` script is highlighted as an optional script that allows for customization of the module installation process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nmodule.zip\n│\n├── customize.sh                       <--- (Tùy chọn, biết thêm chi tiết sau)\n│                                           Tập lệnh này sẽ có nguồn gốc từ update-binary\n├── ...\n├── ...  /* Các tập tin còn lại của mô-đun */\n│\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Installer Structure\nDESCRIPTION: Describes the basic directory layout of a KernelSU module packaged as a ZIP file for installation via the KernelSU manager, highlighting the optional `customize.sh` script used for installation customization.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_6\n\nLANGUAGE: txt\nCODE:\n```\nmodule.zip\n│\n├── customize.sh                       <--- (Optional, more details later)\n│                                           This script will be sourced by update-binary\n├── ...\n├── ...  /* The rest of module's files */\n│\n\n```\n\n----------------------------------------\n\nTITLE: Repacking Boot Image with magiskboot on PC (Shell)\nDESCRIPTION: Executes the `magiskboot` binary on a PC to repack the boot image using the modified components (specifically, the KernelSU `Image` renamed to `kernel`). This creates a new file named `new-boot.img`.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\n./magiskboot repack boot.img\n\n```\n\n----------------------------------------\n\nTITLE: Backing up the boot.img\nDESCRIPTION: This step emphasizes the crucial importance of backing up the original boot.img before flashing any modified boot images to prevent boot loops and enable recovery via fastboot if issues arise. Data loss is a potential risk.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Replacing Kernel with Image File\nDESCRIPTION: This command replaces the `kernel` file with the `Image` file. This step is performed after unpacking the boot image with magiskboot and preparing the replacement kernel.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_19\n\nLANGUAGE: Shell\nCODE:\n```\nmv -f Image kernel\n```\n\n----------------------------------------\n\nTITLE: Patching exec.c for KernelSU\nDESCRIPTION: This code modifies the `fs/exec.c` file to incorporate KernelSU functionality. It introduces conditional compilation based on `CONFIG_KSU`, and calls `ksu_handle_execveat` or `ksu_handle_execveat_sucompat` within the `do_execveat_common` function, depending on the `ksu_execveat_hook` flag. This ensures that KernelSU's execve hooks are executed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/exec.c b/fs/exec.c\nindex ac59664eaecf..bdd585e1d2cc 100644\n--- a/fs/exec.c\n+++ b/fs/exec.c\n@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,\n \treturn retval;\n }\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_execveat_hook __read_mostly;\n+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,\n+\t\t\tvoid *envp, int *flags);\n+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,\n+\t\t\t\t void *argv, void *envp, int *flags);\n+#endif\n static int do_execveat_common(int fd, struct filename *filename,\n \t\t\t  struct user_arg_ptr argv,\n \t\t\t  struct user_arg_ptr envp,\n \t\t\t  int flags)\n {\n+   #ifdef CONFIG_KSU\n+\tif (unlikely(ksu_execveat_hook))\n+\t\tksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);\n+\telse\n+\t\tksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);\n+   #endif\n \treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n }\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Main Branch)\nDESCRIPTION: This snippet integrates KernelSU into the kernel source code using the main development branch. It downloads and executes the `setup.sh` script from the KernelSU repository and passes `main` as an argument to select the main branch.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\n----------------------------------------\n\nTITLE: Temporarily Booting Image with Fastboot (Shell)\nDESCRIPTION: Uses `fastboot` to boot the device using a specified `boot.img` file without permanently installing it. This is useful for testing a patched image before flashing it to ensure it works correctly and avoids potential boot loops.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nfastboot boot boot.img\n\n```\n\n----------------------------------------\n\nTITLE: Patching fs/exec.c for KernelSU Integration\nDESCRIPTION: This diff patch modifies the `fs/exec.c` file in the kernel source code to integrate KernelSU's execution handling logic. It hooks into the `do_execveat_common` function to allow KernelSU to intercept and modify process execution.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/exec.c b/fs/exec.c\nindex ac59664eaecf..bdd585e1d2cc 100644\n--- a/fs/exec.c\n+++ b/fs/exec.c\n@@ -1890,11 +1890,14 @@ static int __do_execve_file(int fd, struct filename *filename,\n \treturn retval;\n }\n \n+extern bool ksu_execveat_hook __read_mostly;\n+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,\n+\t\t\tvoid *envp, int *flags);\n+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,\n+\t\t\t\t void *argv, void *envp, int *flags);\n static int do_execveat_common(int fd, struct filename *filename,\n \t\t\t      struct user_arg_ptr argv,\n \t\t\t      struct user_arg_ptr envp,\n \t\t\t      int flags)\n {\n+\tif (unlikely(ksu_execveat_hook))\n+\t\tksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);\n+\telse\n+\t\tksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);\n \treturn __do_execve_file(fd, filename, argv, envp, flags, NULL);\n }\n```\n\n----------------------------------------\n\nTITLE: Building Android AArch64 Kernel Image with LTO Optimization - Shell\nDESCRIPTION: This snippet shows how to build an aarch64 Android kernel image using a build script with Link Time Optimization (LTO) enabled as 'thin' to reduce memory usage during compilation. It requires the Linux environment with appropriate build dependencies installed, the kernel source synchronized, and the build configuration file specified as 'common/build.config.gki.aarch64'. The environment variable LTO=thin optimizes build memory efficiency, which is critical for machines with less than 24GB RAM. The output is the compiled kernel image.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Understanding security patch levels\nDESCRIPTION: Describes how modern Android devices utilize security patch levels in boot images to prevent flashing of outdated images. It explains the relationship between kernel security patch level and boot loops.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Rebooting Device with Fastboot (Shell)\nDESCRIPTION: Uses the `fastboot` command to reboot the connected Android device. Typically used after flashing an image or temporarily booting to exit fastboot mode and start the Android operating system.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nfastboot reboot\n\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Latest Stable)\nDESCRIPTION: This snippet integrates KernelSU into the kernel source code using the latest stable tag. It downloads and executes the `setup.sh` script from the KernelSU repository using `curl` and `bash`. It automatically detects the latest stable version.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Checking KernelSU Compatibility\nDESCRIPTION: This section outlines the process to check if the device is compatible with KernelSU using the KernelSU Manager app. If the app displays \"Unsupported,\" it indicates a need to compile the kernel oneself. If the app displays \"Not Installed,\" then the device is compatible.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Installing LKM with Manager\nDESCRIPTION: This section describes the process of installing KernelSU in LKM mode using the Manager app. It offers the options of patching and flashing a boot.img from file, installing with root access, and installing to an inactive slot.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Fixing Terminal Permission Issues in KernelSU\nDESCRIPTION: Patch for fs/devpts/inode.c to resolve issues with terminal permissions in KernelSU. This modification addresses problems with executing the 'pm' command in terminal by adding a KernelSU hook to handle devpts operations.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/devpts/inode.c b/fs/devpts/inode.c\nindex 32f6f1c68..d69d8eca2 100644\n--- a/fs/devpts/inode.c\n+++ b/fs/devpts/inode.c\n@@ -602,6 +602,8 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)\n        return dentry;\n }\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_devpts(struct inode*);\n+#endif\n+\n /**\n  * devpts_get_priv -- get private data for a slave\n  * @pts_inode: inode of the slave\n@@ -610,6 +612,7 @@ struct dentry *devpts_pty_new(struct pts_fs_info *fsi, int index, void *priv)\n  */\n void *devpts_get_priv(struct dentry *dentry)\n {\n+       #ifdef CONFIG_KSU\n+       ksu_handle_devpts(dentry->d_inode);\n+       #endif\n        if (dentry->d_sb->s_magic != DEVPTS_SUPER_MAGIC)\n                return NULL;\n        return dentry->d_fsdata;\n```\n\n----------------------------------------\n\nTITLE: KernelSU Installer Variables\nDESCRIPTION: These variables are available within the `customize.sh` script during module installation and provide information about the KernelSU environment, device, and module installation location. It allows developers to tailor installations based on these environment details. They include variables for determining KernelSU version, CPU architecture, and Android API level.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n- `KSU` (bool): variable to mark the script is running in the KernelSU environment, and the value of this variable will always be true. You can use it to differentiate between KernelSU and Magisk.\n- `KSU_VER` (string): version string of current installed KernelSU (e.g. `v0.4.0`)\n- `KSU_VER_CODE` (int): version code of current installed KernelSU in user space (e.g. `10672`)\n- `KSU_KERNEL_VER_CODE` (int): version code of current installed KernelSU in kernel space (e.g. `10672`)\n- `BOOTMODE` (bool): always is `true` in KernelSU\n- `MODPATH` (path): the path where your module files will be installed\n- `TMPDIR` (path): where you can temporarily store files\n- `ZIPFILE` (path): your module installation zip\n- `ARCH` (string): CPU architecture of the device. The value is `arm`, `arm64`, `x86` or `x64`\n- `IS64BIT` (bool): `true` if `$ARCH` is `arm64` or `x64`\n- `API` (int): API level (Android version) of the device (e.g. `23` for Android 6.0)\n```\n\n----------------------------------------\n\nTITLE: KernelSU Setup Script (Main Branch)\nDESCRIPTION: This command downloads and executes the `setup.sh` script from the KernelSU repository's `main` branch, integrating KernelSU into the kernel build process.  This version uses the development `main` branch.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\n----------------------------------------\n\nTITLE: KernelSU Installer Functions\nDESCRIPTION: These functions are available for use within `customize.sh` to perform common operations during module installation, such as printing messages, aborting the installation, setting permissions on files and directories. They provides utility and facilitates the creation of robust installation scripts.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nui_print <msg>\n    in <msg> ra console\n    Tránh sử dụng 'echo' vì nó sẽ không hiển thị trong console của recovery tùy chỉnh\n\nabort <msg>\n    in thông báo lỗi <msg> ra bàn điều khiển và chấm dứt cài đặt\n    Tránh sử dụng 'exit' vì nó sẽ bỏ qua các bước dọn dẹp chấm dứt\n\nset_perm <target> <owner> <group> <permission> [context]\n    nếu [context] không được đặt, mặc định là \"u:object_r:system_file:s0\"\n    chức năng này là một shorthand cho các lệnh sau:\n       chown owner.group target\n       chmod permission target\n       chcon context target\n\nset_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]\n    nếu [context] không được đặt, mặc định là \"u:object_r:system_file:s0\"\n    đối với tất cả các tệp trong <directory>, nó sẽ gọi:\n       bối cảnh cấp phép tệp của nhóm chủ sở hữu tệp set_perm\n    đối với tất cả các thư mục trong <directory> (bao gồm cả chính nó), nó sẽ gọi:\n       set_perm bối cảnh phân quyền của nhóm chủ sở hữu thư mục\n```\n\n----------------------------------------\n\nTITLE: KernelSU Boot Script Execution Flow\nDESCRIPTION: Details the execution points of KernelSU general and module boot scripts (`post-fs-data.d`, `service.d`, `post-mount.d`, `boot-completed.d`, `post-fs-data.sh`, `service.sh`, `boot-completed.sh`, `post-mount.sh`) within the context of the Android boot process. It outlines the various stages where scripts can run and their characteristics (blocking/non-blocking, mount status, etc.).\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_8\n\nLANGUAGE: txt\nCODE:\n```\n0. Bootloader (nothing on screen)\nload patched boot.img\nload kernel:\n    - GKI mode: GKI kernel with KernelSU integrated\n    - LKM mode: stock kernel\n...\n\n1. kernel exec init (OEM logo on screen):\n    - GKI mode: stock init\n    - LKM mode: exec ksuinit, insmod kernelsu.ko, exec stock init\nmount /dev, /dev/pts, /proc, /sys, etc.\nproperty-init -> read default props\nread init.rc\n...\nearly-init -> init -> late_init\nearly-fs\n   start vold\nfs\n  mount /vendor, /system, /persist, etc.\npost-fs-data\n  *safe mode check\n  *execute general scripts in post-fs-data.d/\n  *load sepolicy.rule\n  *mount tmpfs\n  *execute module scripts post-fs-data.sh\n    **(Zygisk)./bin/zygisk-ptrace64 monitor\n  *(pre)load system.prop (same as resetprop -n)\n  *remount modules /system\n  *execute general scripts in post-mount.d/\n  *execute module scripts post-mount.sh\nzygote-start\nload_all_props_action\n  *execute resetprop (actual set props for resetprop with -n option)\n... -> boot\n  class_start core\n    start-service logd, console, vold, etc.\n  class_start main\n    start-service adb, netd (iptables), zygote, etc.\n\n2. kernel2user init (ROM animation on screen, start by service bootanim)\n*execute general scripts in service.d/\n*execute module scripts service.sh\n*set props for resetprop without -p option\n  **(Zygisk) hook zygote (start zygiskd)\n  **(Zygisk) mount zygisksu/module.prop\nstart system apps (autostart)\n...\nboot complete (broadcast ACTION_BOOT_COMPLETED event)\n*execute general scripts in boot-completed.d/\n*execute module scripts boot-completed.sh\n\n3. User operable (lock screen)\ninput password to decrypt /data/data\n*actual set props for resetprop with -p option\nstart user apps (autostart)\n\n```\n\n----------------------------------------\n\nTITLE: Building Kernel Image (build.sh) - Shell\nDESCRIPTION: This shell script command builds the kernel image using `build.sh`. It sets the `LTO` and `BUILD_CONFIG` environment variables to configure the build process for aarch64 architecture. The `LTO=thin` flag is crucial to prevent build failures if the computer has insufficient memory.  It specifies the build configuration file and the architecture.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Building Kernel (aarch64) - Shell\nDESCRIPTION: This snippet compiles a kernel image for the aarch64 architecture using a build script. It sets environment variables for LTO (Link Time Optimization) and build configuration. This requires the build environment for the kernel and the appropriate build tools.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU to Kernel Source (Specific Tag)\nDESCRIPTION: This shell command downloads and executes the `setup.sh` script from the KernelSU repository to integrate a specific tagged version of KernelSU into the kernel source tree.  The `-s v0.5.2` argument specifies that version v0.5.2 should be used. Useful to revert to a previous stable version if issues arise with newer releases.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Data Using Vue 3 Script Setup Syntax in JavaScript\nDESCRIPTION: This snippet imports external JSON data from '../../repos.json' using the Vue 3 <script setup> syntax. The imported data is used as a reactive source to populate a table dynamically. It requires a correctly structured JSON file and Vue 3 environment with support for the <script setup> SFC syntax.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/unofficially-support-devices.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport data from '../../repos.json'\n```\n\n----------------------------------------\n\nTITLE: Building Kernel with Bazel (AArch64)\nDESCRIPTION: This snippet shows how to build an AArch64 kernel using `bazel`. It configures the build with the `fast` configuration and targets the `kernel_aarch64_dist` target. This is the standard build method for Android 13 and later.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Building Kernel with Bazel (Android 13+)\nDESCRIPTION: This snippet builds the kernel using Bazel, specifically for Android 13 and later. It utilizes the `tools/bazel` command with a fast configuration to build the `kernel_aarch64_dist` target.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Importing Device Repository Data Using Vue.js Script Setup - JavaScript\nDESCRIPTION: This snippet imports a JSON file containing repository data into the Vue.js component's script setup, enabling reactive data usage in the template. The data contains details about maintainers, kernel repositories, and supported devices, which will be dynamically rendered. This requires Vue 3 with script setup syntax support and relevant project build tooling to handle JSON imports.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/unofficially-support-devices.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport data from '../../repos.json'\n```\n\n----------------------------------------\n\nTITLE: Declaring System Files/Folders for Removal (Shell)\nDESCRIPTION: Illustrates how to use the `REMOVE` variable within a module's `customize.sh` script (run during installation/update) to specify system files or directories for removal. KernelSU processes this list by creating corresponding whiteout character device files (`mknod <TARGET> c 0 0`) within the module's `system` directory, effectively hiding the original items via OverlayFS.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nREMOVE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU to Kernel Source (Main Branch)\nDESCRIPTION: This shell command downloads and executes the `setup.sh` script from the KernelSU repository to integrate the development (main) branch of KernelSU into the kernel source tree.  The `-s main` argument specifies that the main branch should be used.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\n----------------------------------------\n\nTITLE: Understanding Kernel and Android version differences\nDESCRIPTION: This highlights that Kernel versions and Android versions are not necessarily the same. Explains that the kernel version might not match the Android version installed at the time of shipment and to check the kernel version for flashing, especially after system upgrades.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Displaying KSU/Magisk Environment Differences\nDESCRIPTION: This snippet highlights the usage of the `KSU` variable to determine if a script is running within a KernelSU environment or a Magisk environment. It also notes the unchanging values of `MAGISK_VER_CODE` and `MAGISK_VER` in the KernelSU context.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/module.md#_snippet_3\n\nLANGUAGE: txt\nCODE:\n```\n- KSU (bool): 标记此脚本运行在 KernelSU 环境下，此变量的值将永远为 `true`，你可以通过它区分 Magisk.\n- MAGISK_VER_CODE 在 KernelSU 中永远为 `25200`，MAGISK_VER 则为 `v25.2`，请不要通过这两个变量来判断是否是 KernelSU！\n```\n\n----------------------------------------\n\nTITLE: Installing GKI with fastboot\nDESCRIPTION: Instructions for installing KernelSU's boot.img using fastboot. It advises finding the correct boot.img for your device's KMI version and the correct compression format.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\nfastboot flash boot boot.img\n```\n\n----------------------------------------\n\nTITLE: Installing KernelSU from Development Branch\nDESCRIPTION: This command executes the latest development version of the KernelSU setup script from GitHub, allowing testing or use of the cutting-edge features during kernel development.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Module File Structure with WebUI in KernelSU\nDESCRIPTION: Shows the basic directory structure required for a KernelSU module with a web interface. The module must contain a module.prop file and a webroot directory with at least an index.html file as the entry point.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module-webui.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n❯ tree .\n.\n|-- module.prop\n`-- webroot\n    `-- index.html\n```\n\n----------------------------------------\n\nTITLE: KernelSU customize.sh Utility Functions for Printing and Permissions\nDESCRIPTION: Provides functions to display messages and manage file permissions during module customization. 'ui_print' displays messages in the recovery console, 'abort' terminates installation with an error. 'set_perm' and 'set_perm_recursive' set ownership, permissions, and security contexts, streamlining file setup.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/module.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nui_print <msg>\n  # Prints message to console, avoid 'echo' which may not display.\n\nabort <msg>\n  # Displays error message and terminates installation process.\n\nset_perm <target> <owner> <group> <permission> [context]\n  # Sets ownership, permissions, and security context for a target file.\n  # Defaults context to \"u:object_r:system_file:s0\" if not provided.\n\nset_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]\n  # Applies permissions recursively to all files and directories inside the specified directory.\n  # Defaults context as above if not specified.\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Directory Structure (Text)\nDESCRIPTION: Defines the standard directory layout for a KernelSU module located within `/data/adb/modules/$MODID`. It outlines essential components: `module.prop` for metadata, the `system` directory for OverlayFS overlays, status flag files (`disable`, `remove`, `skip_mount`), optional scripts triggered at different boot stages (`post-fs-data.sh`, `post-mount.sh`, `service.sh`, `boot-completed.sh`), `uninstall.sh` for cleanup, `action.sh` for user interaction, `system.prop` for system property injection, and `sepolicy.rule` for custom SELinux rules.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\n/data/adb/modules\n├── .\n├── .\n|\n├── $MODID                  <--- The folder is named with the ID of the module\n│   │\n│   │      *** Module Identity ***\n│   │\n│   ├── module.prop         <--- This file stores the metadata of the module\n│   │\n│   │      *** Main Contents ***\n│   │\n│   ├── system              <--- This folder will be mounted if skip_mount does not exist\n│   │   ├── ...\n│   │   ├── ...\n│   │   └── ...\n│   │\n│   │      *** Status Flags ***\n│   │\n│   ├── skip_mount          <--- If exists, KernelSU will NOT mount your system folder\n│   ├── disable             <--- If exists, the module will be disabled\n│   ├── remove              <--- If exists, the module will be removed next reboot\n│   │\n│   │      *** Optional Files ***\n│   │\n│   ├── post-fs-data.sh     <--- This script will be executed in post-fs-data\n│   ├── post-mount.sh       <--- This script will be executed in post-mount\n│   ├── service.sh          <--- This script will be executed in late_start service\n│   ├── boot-completed.sh   <--- This script will be executed on boot completed\n|   ├── uninstall.sh        <--- This script will be executed when KernelSU removes your module\n|   ├── action.sh           <--- This script will be executed when user click the Action button in KernelSU app\n│   ├── system.prop         <--- Properties in this file will be loaded as system properties by resetprop\n│   ├── sepolicy.rule       <--- Additional custom sepolicy rules\n│   │\n│   │      *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY ***\n│   │\n│   ├── vendor              <--- A symlink to $MODID/system/vendor\n│   ├── product             <--- A symlink to $MODID/system/product\n│   ├── system_ext          <--- A symlink to $MODID/system/system_ext\n│   │\n│   │      *** Any additional files / folders are allowed ***\n│   │\n│   ├── ...\n│   └── ...\n|\n├── another_module\n│   ├── .\n│   └── .\n├── .\n├── .\n```\n\n----------------------------------------\n\nTITLE: Building AArch64 Kernel Image (build.sh)\nDESCRIPTION: This snippet shows how to build an AArch64 kernel image using the `build/build.sh` script. It includes the `LTO=thin` flag to reduce memory usage during the build process. Building the kernel requires following the official Android documentation.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Exec Root Command - JavaScript\nDESCRIPTION: This JavaScript snippet utilizes the `exec` function from the 'kernelsu' library to execute a command in a root shell. It then checks the exit code to determine the success or failure of the command and logs the output.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { exec } from 'kernelsu';\n\nconst { errno, stdout, stderr } = await exec('ls -l', { cwd: '/tmp' });\nif (errno === 0) {\n    // success\n    console.log(stdout);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Commands Using KernelSU JavaScript API JavaScript\nDESCRIPTION: Demonstrates usage of KernelSU's JavaScript API, imported from the 'kernelsu' npm package, to execute shell commands within the web interface. The example executes the command to get the Android device's product model property with 'getprop ro.product.model' and retrieves both the error number and standard output of the command. This API facilitates direct interaction between the web UI and underlying system, enabling modules to implement custom functionality through command execution.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module-webui.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { exec } from 'kernelsu';\n\nconst { errno, stdout } = exec(\"getprop ro.product.model\");\n```\n\n----------------------------------------\n\nTITLE: Patching fs/open.c for KernelSU Integration\nDESCRIPTION: This diff patch modifies the `fs/open.c` file in the kernel source code to integrate KernelSU's file access handling logic.  It hooks into the `do_faccessat` function, allowing KernelSU to control file access permissions.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 05036d819197..965b84d486b8 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn ksys_fallocate(fd, mode, offset, len);\n }\n \n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t int *flags);\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n  */\n long do_faccessat(int dfd, const char __user *filename, int mode)\n {\n+\tksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n \tconst struct cred *old_cred;\n \tstruct cred *override_cred;\n \tstruct path path;\n```\n\n----------------------------------------\n\nTITLE: Renaming the Kernel file (Shell)\nDESCRIPTION: This command is designed to rename the extracted kernel file 'kernel' and save it as 'Image'. This renaming step is required, after unpacking the boot image, to allow proper operation for the next step. The command `mv -f Image kernel` renames the kernel file and replaces any existing file in the system.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/installation.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmv -f Image kernel\n```\n\n----------------------------------------\n\nTITLE: Stdout Stream Example - JavaScript\nDESCRIPTION: This JavaScript code demonstrates the use of `stdout` from a spawned child process.  It attaches a listener to the `data` event of the `stdout` stream to capture and log the output of the executed command.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst subprocess = spawn('ls');\n\nsubprocess.stdout.on('data', (data) => {\n  console.log(`Received chunk ${data}`);\n});\n```\n\n----------------------------------------\n\nTITLE: KernelSU customize.sh Variables and Environment\nDESCRIPTION: Defines variables available in the 'customize.sh' script in KernelSU, providing environment details, permissions, architecture, API level, and kernel version. These variables enable script customization based on device properties and installation context.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/module.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nKSU (bool): true, indicating script runs in KernelSU environment\nKSU_VER (string): version string, e.g., \"v0.4.0\"\nKSU_VER_CODE (int): version code, e.g., 10672\nKSU_KERNEL_VER_CODE (int): kernel version code, e.g., 10672\nBOOTMODE (bool): always true\nMODPATH (path): target installation directory\nTMPDIR (path): temporary storage directory\nZIPFILE (path): path to installation zip file\nARCH (string): CPU architecture, e.g., \"arm\", \"arm64\", \"x86\", \"x64\"\nIS64BIT (bool): true if ARCH is \"arm64\" or \"x64\"\nAPI (int): Android API level, e.g., 23\n\n# Note: MAGISK_VER_CODE and MAGISK_VER are not reliable indicators in KernelSU\n```\n\n----------------------------------------\n\nTITLE: Building Android Kernel for aarch64 Architecture\nDESCRIPTION: This build command compiles the aarch64 Android kernel using the specified build configuration. Including 'LTO=thin' optimizes link-time optimization for smaller memory usage, but must be included if the system has less than 24GB RAM. Starting from Android 13, the build system uses Bazel for kernel compilation.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Displaying ksud boot-patch Help (Shell)\nDESCRIPTION: Shows the command-line options available for the `ksud boot-patch` command, which is used to patch boot or init_boot images for KernelSU. It lists flags like `--boot`, `--kernel`, `--module`, `--kmi`, etc., along with their descriptions and default behavior.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\noriole:/ # ksud boot-patch -h\nPatch boot or init_boot images to apply KernelSU\n\nUsage: ksud boot-patch [OPTIONS]\n\nOptions:\n  -b, --boot <BOOT>              Boot image path. If not specified, it will try to find the boot image automatically\n  -k, --kernel <KERNEL>          Kernel image path to be replaced\n  -m, --module <MODULE>          LKM module path to be replaced. If not specified, the built-in module will be used\n  -i, --init <INIT>              init to be replaced\n  -u, --ota                      Will use another slot if the boot image is not specified\n  -f, --flash                    Flash it to boot partition after patch\n  -o, --out <OUT>                Output path. If not specified, the current directory will be used\n      --magiskboot <MAGISKBOOT>  magiskboot path. If not specified, the built-in version will be used\n      --kmi <KMI>                KMI version. If specified, the indicated KMI will be used\n  -h, --help                     Print help\n\n```\n\n----------------------------------------\n\nTITLE: Patching input.c for KernelSU SafeMode\nDESCRIPTION: This code modifies the `drivers/input/input.c` file to enable KernelSU's SafeMode. It introduces conditional compilation based on `CONFIG_KSU`, and calls `ksu_handle_input_handle_event` inside the `input_handle_event` function. This allows KernelSU to intercept input events and potentially trigger SafeMode.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/drivers/input/input.c b/drivers/input/input.c\nindex 45306f9ef247..815091ebfca4 100755\n--- a/drivers/input/input.c\n+++ b/drivers/input/input.c\n@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,\n \treturn disposition;\n }\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_input_hook __read_mostly;\n+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);\n+#endif\n+  \n static void input_handle_event(struct input_dev *dev,\n \t\t\t       unsigned int type, unsigned int code, int value)\n {\n\tint disposition = input_get_disposition(dev, type, code, &value);\n+   #ifdef CONFIG_KSU\n+\tif (unlikely(ksu_input_hook))\n+\t\tksu_handle_input_handle_event(&type, &code, &value);\n+   #endif\n \n \tif (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)\n \t\tadd_input_randomness(type, code, value);\n```\n\n----------------------------------------\n\nTITLE: SELinux Custom Domain Configuration (Example)\nDESCRIPTION: This shell code demonstrates how to define a custom SELinux domain (app1) and enforce it. It includes setting the type, enforcing the domain, adding it to the 'mlstrustedsubject' attribute, and defining an 'allow' rule. This example is for demonstration and the broad 'allow' rule is discouraged.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/app-profile.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntype app1\nenforce app1\ntypeattribute app1 mlstrustedsubject\nallow app1 * * *\n```\n\n----------------------------------------\n\nTITLE: Unpacking Boot Image with magiskboot on PC (Shell)\nDESCRIPTION: Executes the `magiskboot` binary on a PC to unpack the `boot.img` file. This process extracts components like the kernel image, which is saved as a file named `kernel` in the current directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\n./magiskboot unpack boot.img\n\n```\n\n----------------------------------------\n\nTITLE: Executing Command in Global Mount Namespace\nDESCRIPTION: This command demonstrates how to execute a specific command within the global mount namespace.  It uses `nsenter` to enter the mount namespace associated with process ID 1 and then executes the specified command.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/faq.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnsenter --mount=/proc/1/ns/mnt\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Metadata File Format (module.prop) - Plain Text\nDESCRIPTION: Defines the required fields and format of the module.prop file used for KernelSU modules. This file is mandatory for module recognition and must use UNIX line endings. It includes string fields for id, name, version, author, description, and an integer versionCode used for version comparison. The id field must follow a specific regex pattern to serve as a unique module identifier.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nid=<string>\nname=<string>\nversion=<string>\nversionCode=<int>\nauthor=<string>\ndescription=<string>\n```\n\n----------------------------------------\n\nTITLE: Changing Directory in ADB Shell (Shell)\nDESCRIPTION: Standard shell command executed within an `adb shell` session. It changes the current working directory to `/data/local/tmp/`, which is where necessary files like `magiskboot` and image files were pushed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncd /data/local/tmp/\n\n```\n\n----------------------------------------\n\nTITLE: Defining module.prop file format\nDESCRIPTION: This snippet describes the required format for the `module.prop` file, a crucial configuration file within a KernelSU module. It specifies the format with key-value pairs.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/module.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nid=<string>\nname=<string>\nversion=<string>\nversionCode=<int>\nauthor=<string>\ndescription=<string>\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Directory Structure\nDESCRIPTION: The standard directory structure required for a KernelSU module, showing all required and optional files and directories with their specific purposes.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n/data/adb/modules\n├── .\n├── .\n|\n├── $MODID                  <--- 模組的資料夾名稱與模組 ID 相同\n│   │\n│   │      *** 模組識別 ***\n│   │\n│   ├── module.prop         <--- 這個檔案儲存與模組相關的中繼資料，例如模組 ID、版本等\n│   │\n│   │      *** 主要內容 ***\n│   │\n│   ├── system              <--- 這個資料夾會在 skip_mount 不存在時被掛接至系統\n│   │   ├── ...\n│   │   ├── ...\n│   │   └── ...\n│   │\n│   │      *** 狀態旗標 ***\n│   │\n│   ├── skip_mount          <--- 如果這個檔案存在，那麼 KernelSU 將不會掛接您的系統資料夾\n│   ├── disable             <--- 如果這個檔案存在，那麼模組將會被停用\n│   ├── remove              <--- 如果這個檔案存在，那麼模組將會在下次重新開機時被移除\n│   │\n│   │      *** 選用檔案 ***\n│   │\n│   ├── post-fs-data.sh     <--- 這個腳本將會在 post-fs-data 中執行\n│   ├── service.sh          <--- 這個腳本將會在 late_start 服務中執行\n|   ├── uninstall.sh        <--- 這個腳本將會在 KernelSU 移除模組時執行\n│   ├── system.prop         <--- 這個檔案中指定的屬性將會在系統啟動時透過 resetprop 變更\n│   ├── sepolicy.rule       <--- 這個檔案中的 SELinux 原則將會在系統開機時載入\n│   │\n│   │      *** 自動產生的目錄，不要手動建立或修改！ ***\n│   │\n│   ├── vendor              <--- A symlink to $MODID/system/vendor\n│   ├── product             <--- A symlink to $MODID/system/product\n│   ├── system_ext          <--- A symlink to $MODID/system/system_ext\n│   │\n│   │      *** 允許的其他額外檔案/資料夾 ***\n│   │\n│   ├── ...\n│   └── ...\n|\n├── another_module\n│   ├── .\n│   └── .\n├── .\n├── .\n```\n\n----------------------------------------\n\nTITLE: Building Android Kernel Image for aarch64 Architecture\nDESCRIPTION: This snippet shows commands to build an Android kernel image specifically for aarch64 architecture. It uses environment variables such as LTO for link-time optimization and a specific build configuration. It also mentions the alternative Bazel build system introduced in Android 13, which simplifies the process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\nLANGUAGE: Shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Finding and Linking Log Library (CMake)\nDESCRIPTION: This snippet searches for the log library and links it to the 'kernelsu' library. The find_library command locates the log library and assigns it to the variable 'log-lib'.  The target_link_libraries function links the found log library to the kernelsu target.  The output links the log library to the project.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/manager/app/src/main/cpp/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfind_library(log-lib log)\n\ntarget_link_libraries(kernelsu ${log-lib})\n```\n\n----------------------------------------\n\nTITLE: Removing GKI Protected Exports for Android 14 Kernel using Shell\nDESCRIPTION: To enable Wi-Fi and Bluetooth functionality on certain Android 14 kernels, this snippet removes all files matching the 'abi_gki_protected_exports_*' pattern under the 'common/android' directory. This workaround disables GKI protected exports that may interfere with wireless modules. It assumes the developer has write permissions and understands the implications of modifying kernel exports.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nrm common/android/abi_gki_protected_exports_*\n```\n\n----------------------------------------\n\nTITLE: KernelSU Busybox Standalone Ash Shell Mode Activation - Shell\nDESCRIPTION: Explains how to enable the standalone mode of KernelSU's bundled Busybox Ash shell, which ensures all commands are run from Busybox applets regardless of PATH. This mode guarantees predictable command availability across Android versions. Activation can be done by setting the environment variable ASH_STANDALONE=1 or passing the -o standalone option to the busybox shell. Once enabled, child sh shells inherit this mode. KernelSU runs all shell scripts in this mode by default.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n1. Export environment variable:\nASH_STANDALONE=1 /data/adb/ksu/bin/busybox sh <script>\n\n2. Or use command line option:\n/data/adb/ksu/bin/busybox sh -o standalone <script>\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Android Kernel Source Repository - Shell\nDESCRIPTION: This snippet demonstrates how to initialize and synchronize the Android kernel source code using the 'repo' tool. It involves initializing the repo client with a manifest URL, replacing the manifest file with a user-provided kernel_manifest.xml to ensure reproducible builds, re-initializing with the new manifest, and syncing the kernel source code. Prerequisites include having the 'repo' tool installed and a proper kernel_manifest.xml file obtained from GKI release builds. Inputs are commands run in a shell environment, outputs are the synchronized kernel source files.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Describing Android Boot Sequence with KernelSU Modules txt\nDESCRIPTION: This snippet provides a textual walkthrough of the Android boot process emphasizing how KernelSU integrates into the system at various phases such as kernel startup, early filesystem mounting, service initialization, and boot completion. It specifies module-specific script executions like Zygisk hooks, resetprop commands, and system property preloading. Dependencies include understanding of Android init stages and KernelSU module requirements. Inputs include the kernel mode (GKI or LKM) which affect behavior differences; outputs are the staged execution of scripts and system services initialization, culminating in a fully operational Android system. Limitations: partial omission of some details, assumes familiarity with Android init conventions.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/module.md#_snippet_3\n\nLANGUAGE: txt\nCODE:\n```\n0. Bootloader (nada nesta tela)\\nload patched boot.img\\nload kernel:\\n    - Modo GKI: kernel GKI com KernelSU integrado\\n    - Modo LKM: kernel stock\\n...\\n\\n1. kernel exec init (logo OEM na tela):\\n    - Modo GKI: stock init\\n    - Modo LKM: exec ksuinit, insmod kernelsu.ko, exec stock init\\nmount /dev, /dev/pts, /proc, /sys, etc.\\nproperty-init -> read default props\\nread init.rc\\n...\\nearly-init -> init -> late_init\\nearly-fs\\n   start vold\\nfs\\n  mount /vendor, /system, /persist, etc.\\npost-fs-data\\n  *verificação do modo de segurança\\n  *executar scripts gerais em post-fs-data.d/\\n  *carregar sepolicy.rule\\n  *montar tmpfs\\n  *executar scripts de módulo post-fs-data.sh\\n    **(Zygisk)./bin/zygisk-ptrace64 monitor\\n  *(pré)carregamento de system.prop (igual a resetprop -n)\\n  *remontar módulos em /system\\n  *executar scripts gerais em post-mount.d/\\n  *executar scripts de módulo post-mount.sh\\nzygote-start\\nload_all_props_action\\n  *executar resetprop (defina adereços reais para resetprop com a opção -n)\\n... -> boot\\n  class_start core\\n    start-service logd, console, vold, etc.\\n  class_start main\\n    start-service adb, netd (iptables), zygote, etc.\\n\\n2. kernel2user init (animação da ROM na tela, inicie pelo serviço bootanim)\\n*executar scripts gerais em service.d/\\n*executar scripts de módulo service.sh\\n*definir adereços para resetprop sem a opção -p\\n  **(Zygisk) hook zygote (iniciar o zygiskd)\\n  **(Zygisk) montar zygisksu/module.prop\\niniciar apps do sistema (início automático)\\n...\\ninicialização completa (transmitir evento ACTION_BOOT_COMPLETED)\\n*executar scripts gerais em boot-completed.d/\\n*executar scripts de módulo boot-completed.sh\\n\\n3. Operável pelo usuário (tela de bloqueio)\\ninsira a senha para descriptografar /data/data\\n*conjunto real de adereços para resetprop com opção -p\\niniciar apps de usuário (início automático)\n```\n\n----------------------------------------\n\nTITLE: Syncing Kernel Source Code - Shell\nDESCRIPTION: This shell script snippet outlines the commands required to synchronize the kernel source code from a remote repository. It uses `repo init` to initialize the repository, `mv` to move the manifest file, `repo init` again using the manifest, and `repo sync` to fetch the source code. It prepares the build environment by downloading the necessary kernel source code.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: KernelSU module.prop Configuration Format (Text)\nDESCRIPTION: Specifies the format for the `module.prop` file, which is mandatory for a directory to be recognized as a KernelSU module. It uses key-value pairs to define module metadata: `id` (unique identifier matching `^[a-zA-Z][a-zA-Z0-9._-]+$`), `name`, `version`, `versionCode` (integer for version comparison), `author`, and `description`. Values must be single-line strings, and the file must use Unix (LF) line endings.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module.md#_snippet_2\n\nLANGUAGE: txt\nCODE:\n```\nid=<string>\nname=<string>\nversion=<string>\nversionCode=<int>\nauthor=<string>\ndescription=<string>\n```\n\n----------------------------------------\n\nTITLE: Getting Module Directory Path in Shell Scripts\nDESCRIPTION: A shell command to determine the module's directory path dynamically in module scripts, avoiding hardcoded paths.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nMODDIR=${0%/*}\n```\n\n----------------------------------------\n\nTITLE: Syncing Kernel Source - Shell\nDESCRIPTION: This snippet synchronizes the kernel source code using `repo`.  It initializes the repository, moves a manifest file, initializes with the manifest, and then syncs the source. This requires the `repo` tool, a manifest file and network connectivity to Google's source.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Unpacking boot.img Using magiskboot (Shell)\nDESCRIPTION: This command uses the `magiskboot` utility to unpack a `boot.img` file. The purpose of this operation is to extract the kernel from the boot image. The extracted kernel will then be used as a base. The output of this command is the 'kernel' file which represents the stock kernel of the device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/installation.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./magiskboot unpack boot.img\n```\n\n----------------------------------------\n\nTITLE: KernelSU Installer Helper Functions and Variables - Shell\nDESCRIPTION: Lists environment variables and helper functions available inside customize.sh scripts during module installation using KernelSU's busybox ash shell in standalone mode. Variables include module path, architecture info, KernelSU version codes, device ABI, and flags to distinguish KernelSU from Magisk. Helper functions allow printing messages, aborting with errors, and setting file permissions recursively with SELinux contexts.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nui_print <msg>\n    コンソールに <msg> を表示します\n    カスタムリカバリーのコンソールでは表示されないため、「echo」の使用は避けてください\n\nabort <msg>\n    エラーメッセージ<msg>をコンソールに出力し、インストールを終了させます\n    終了時のクリーンアップがスキップされてしまうため、「exit」の使用は避けてください\n\nset_perm <target> <owner> <group> <permission> [context]\n    [context] が設定されていない場合、デフォルトは \"u:object_r:system_file:s0\" です。\n    この機能は、次のコマンドの略記です：\n       chown owner.group target\n       chmod permission target\n       chcon context target\n\nset_perm_recursive <directory> <owner> <group> <dirpermission> <filepermission> [context]\n    [context] が設定されていない場合、デフォルトは \"u:object_r:system_file:s0\" です。\n    <directory> 内のすべてのファイルに対しては以下が実行されます:\n       set_perm file owner group filepermission context\n    <directory> 内のすべてのディレクトリ（自身を含む）に対しては以下が実行されます:\n       set_perm dir owner group dirpermission context\n```\n\n----------------------------------------\n\nTITLE: Pushing magiskboot Library to Device via ADB (Shell)\nDESCRIPTION: This command utilizes adb (Android Debug Bridge) to push the `libmagiskboot.so` library from the Magisk package to a temporary directory on the connected Android device. The library is then made executable using `chmod`. This is a prerequisite step for unpacking, modifying, and repacking boot images. The destination directory is `/data/local/tmp/`.  The library is necessary for interacting with the boot image's kernel and other components.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/installation.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nadb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot\n```\n\n----------------------------------------\n\nTITLE: Pushing File to Device via ADB (Shell)\nDESCRIPTION: Uses the Android Debug Bridge (`adb`) to copy a file (specifically `libmagiskboot.so`) from the computer (`Magisk-*/lib/arm64-v8a/libmagiskboot.so`) to a temporary directory (`/data/local/tmp/magiskboot`) on the connected Android device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nadb push Magisk-*/lib/arm64-v8a/libmagiskboot.so /data/local/tmp/magiskboot\n\n```\n\n----------------------------------------\n\nTITLE: KernelSU Boot Script Modes and Locations - Plain Text\nDESCRIPTION: Describes KernelSU's handling of boot scripts, divided into two execution modes: synchronous post-fs-data mode and asynchronous late_start service mode. It explains the timing and impact of each mode on the boot process. It elaborates on script locations for general and module scripts, execution permission requirements, and which mode these scripts run in. Cautions about avoid using setprop in post-fs-data and recommendation to use resetprop are included.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_4\n\nLANGUAGE: txt\nCODE:\n```\n- post-fs-data モード\n  - 同期処理です。実行が終わるか、10秒が経過するまでブートプロセスが一時停止されます。\n  - スクリプトはモジュールがマウントされる前に実行されます。モジュール開発者はモジュールがマウントされる前に、動的にモジュールを調整できます。\n  - このステージは Zygote が始まる前に起きるので、Android のほとんどの処理の前に割り越してくれます\n  - **警告:** `setprop` を使うとブートプロセスのデッドロックを引き起します!` resetprop -n <prop_name> <prop_value> を使ってください\n  - **本当に必要な場合だけこのモードでコマンド実行してください**\n- late_start サービスモード\n  - 非同期処理です。スクリプトは、起動プロセスの次めの部分と依存しなく同期に実行されます。\n  - **ほとんどのスクリプトにはこちらがおたします**\n\nKernelSU では、起動スクリプトは住所によって一致スクリプトとモジュールスクリプトの2種類に分けられます：\n\n- 一般スクリプト\n  - /data/adb/post-fs-data.d か /data/adb/service.d に配置されます\n  - スクリプトが実行可能な状态に設定されている場合に限られます (コマンド chmod +x script.sh)\n  - post-fs-data.d のスクリプトは post-fs-data モードで実行されり、service.d のスクリプトは late_start サービスモードで実行されます\n  - モジュールはインストール時に一般スクリプトを追加すべきしくない\n- モジュールスクリプト\n  - モジュール独自のフォルダに配置されます\n  - モジュールが有効な場合に限り実行されます\n  - post-fs-data.sh は post-fs-data モードで実行され、service.sh は late_start サービスモードで実行されます\n\nすべてのブートスクリプトは、KernelSU の Busybox `ash` シェルで「スタンドアロンモード」を有効にした状態で実行されます。\n```\n\n----------------------------------------\n\nTITLE: Making magiskboot Executable on PC (Shell)\nDESCRIPTION: Standard shell command used on a Windows, macOS, or Linux PC to grant execute permissions (`+x`) to the downloaded `magiskboot` binary. This is necessary before running the binary to unpack/repack images.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nchmod +x magiskboot\n\n```\n\n----------------------------------------\n\nTITLE: Repacking boot.img Using magiskboot (Shell)\nDESCRIPTION: This command uses the `magiskboot` utility to repack the modified `boot.img` file. The modified boot image will contain the modified KernelSU kernel. The output of the command is the 'new-boot.img' which is then flashed to the device using fastboot.  This completes the process of patching the boot image.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/installation.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n./magiskboot repack boot.img\n```\n\n----------------------------------------\n\nTITLE: REPLACE Variable Usage for Directory Replacement\nDESCRIPTION: Example of using the REPLACE variable in customize.sh to specify directories that should be completely replaced by empty directories when the module is applied.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nREPLACE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Manually Patching fs/stat.c (vfs_statx) for KernelSU (Diff/C)\nDESCRIPTION: Provides a diff patch illustrating how to modify the `vfs_statx` function in `fs/stat.c`. It adds an external function declaration and a conditional call to `ksu_handle_stat` based on the `CONFIG_KSU` flag. This is part of the manual integration process for kernels supporting `vfs_statx`.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 376543199b5a..82adcef03ecc 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,\n }\n EXPORT_SYMBOL(vfs_statx_fd);\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+#endif\n+\n /**\n  * vfs_statx - Get basic and extra attributes by filename\n  * @dfd: A file descriptor representing the base dir for a relative filename\n@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;\n \n+   #ifdef CONFIG_KSU\n+\tksu_handle_stat(&dfd, &filename, &flags);\n+   #endif\n \tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Patching stat.c or fstatat.c (older kernels) for KernelSU\nDESCRIPTION: This patch applies to kernels that don't have the `vfs_statx` function, replacing it with the `vfs_fstatat` function. It includes conditional compilation based on `CONFIG_KSU`, and calls `ksu_handle_stat` before performing the original operations, to enable KernelSU functionality. This allows KernelSU to intercept stat calls on older kernels.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 068fdbcc9e26..5348b7bb9db2 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)\n }\n EXPORT_SYMBOL(vfs_fstat);\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+#endif\n int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n \tint flag)\n {\n\tint error = -EINVAL;\n\tunsigned int lookup_flags = 0;\n+   #ifdef CONFIG_KSU \n+  ksu_handle_stat(&dfd, &filename, &flag);\n+   #endif\n+\n \tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t\t  AT_EMPTY_PATH)) != 0)\n \t\tgoto out;\n```\n\n----------------------------------------\n\nTITLE: Making File Executable in ADB Shell (Shell)\nDESCRIPTION: Standard shell command executed within an `adb shell` session. It grants execute permissions (`+x`) to the `magiskboot` binary located at `/data/local/tmp/magiskboot`, making it runnable on the Android device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nchmod +x magiskboot\n\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/open.c for KernelSU Integration in Early Kernels\nDESCRIPTION: Alternative patch for open.c for kernels earlier than 4.17, inserting the hook directly in the faccessat syscall rather than in do_faccessat function.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 2ff887661237..e758d7db7663 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn error;\n }\n \n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\tint *flags);\n+\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n \tint res;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW;\n \n+\tksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n+\n \tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Flashing Boot Image with Fastboot (Shell)\nDESCRIPTION: Uses the `fastboot` command-line tool to flash a `boot.img` file onto the device's `boot` partition. This is a standard method for installing custom or patched boot images on Android devices while in bootloader/fastboot mode.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nfastboot flash boot boot.img\n\n```\n\n----------------------------------------\n\nTITLE: ksud boot-patch example\nDESCRIPTION: Provides an example `ksud boot-patch` command to patch a boot.img and specifies the KMI version.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\nksud boot-patch -b <boot.img> --kmi android13-5.10\n```\n\n----------------------------------------\n\nTITLE: Building Kernel Using Bazel for Android 13+\nDESCRIPTION: This command builds the Android kernel using Bazel, specifying the 'fast' configuration and targeting the 'kernel_aarch64_dist' build target. It is required starting from Android 13 to accommodate modern build processes.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Replacing Kernel File on Android (Shell)\nDESCRIPTION: Standard shell command executed on the Android device to replace the extracted stock `kernel` file with the KernelSU `Image` file. `-f` forces the move, overwriting the destination file.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nmv -f Image kernel\n\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module 'REMOVE' Variable Example for File Whitelisting - Shell\nDESCRIPTION: An example snippet showing how to use the REMOVE variable inside customize.sh to declare a list of files or directories to delete from the system overlay by creating 'whiteout' device nodes with mknod. KernelSU automates the whiteout creation for listed paths, effectively removing those files after module enablement.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nREMOVE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing KernelSU with ADB Sideload via TWRP\nDESCRIPTION: This command installs the KernelSU AnyKernel3 zip package via ADB sideload in TWRP recovery. This method is suitable for devices with TWRP installed. The zip package must be located in the same directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_21\n\nLANGUAGE: Shell\nCODE:\n```\nadb sideload AnyKernel-*.zip\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Specific Tag)\nDESCRIPTION: This snippet integrates KernelSU into the kernel source code using a specific version tag (e.g., v0.5.2). It downloads and executes the `setup.sh` script and provides the tag as an argument, ensuring a specific version of KernelSU is used.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Kernel Version Format Explanation in Text\nDESCRIPTION: Explanation of the kernel release version format highlighting the Kernel Module Interface (KMI) components. It shows how the version string is parsed and the meaning of each segment, including Version, PatchLevel, SubLevel, AndroidRelease, KMI generation, and suffix. This context is crucial for determining kernel compatibility in KernelSU installation.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/installation.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\nKernelRelease :=\nVersion.PatchLevel.SubLevel-AndroidRelease-KmiGeneration-suffix\nw      .x         .y       -zzz           -k            -something\n```\n\n----------------------------------------\n\nTITLE: Obtaining the official firmware\nDESCRIPTION: This section outlines the process to get the official firmware required for LKM mode. It explains how to extract boot.img. For Android 13 devices, it mentions patching the init_boot partition instead of boot.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Repacking Boot Image with Magiskboot\nDESCRIPTION: This command repacks the boot image after replacing the kernel.  It requires the `magiskboot` binary and the modified `boot.img` file. The resulting `new-boot.img` can be flashed to the device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_20\n\nLANGUAGE: Shell\nCODE:\n```\n./magiskboot repack boot.img\n```\n\n----------------------------------------\n\nTITLE: KernelSU Command Line Execution (Kotlin)\nDESCRIPTION: This Kotlin code snippet, extracted from KernelSU's manager app, demonstrates how KernelSU utilizes `nsenter` to execute commands within a specific mount namespace. It's used internally by KernelSU to manage the mount namespace.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/faq.md#_snippet_2\n\nLANGUAGE: kotlin\nCODE:\n```\nhttps://github.com/tiann/KernelSU/blob/77056a710073d7a5f7ee38f9e77c9fd0b3256576/manager/app/src/main/java/me/weishu/kernelsu/ui/util/KsuCli.kt#L115\n```\n\n----------------------------------------\n\nTITLE: Shell Command Example\nDESCRIPTION: This shell command shows the output of the `id` command. The `id` command displays the user and group IDs, along with the groups a user belongs to. It is crucial for understanding a user's permissions within the system.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/app-profile.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\noriole:/ $ id\nuid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0\n```\n\n----------------------------------------\n\nTITLE: Example `id` command output in shell\nDESCRIPTION: This snippet shows an example output of the `id` command executed in the ADB shell. It displays the UID, GID, and supplementary groups of the current user, which is important for understanding user and group permissions in the Android system.  It highlights the relationship between the user's identity and the resources it can access.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/app-profile.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\noriole:/ $ id\nuid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0\n```\n\n----------------------------------------\n\nTITLE: Using magiskboot on PC - Linux/macOS/Windows\nDESCRIPTION: This snippet details the steps to use `magiskboot` to unpack, modify, and repack a `boot.img` file. Requires `magiskboot` executable and a `boot.img` file. The process involves unpacking the image, replacing the kernel, and repacking it.  The resulting `new-boot.img` needs to be flashed via fastboot.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./magiskboot unpack boot.img\n```\n\nLANGUAGE: bash\nCODE:\n```\nmv -f Image kernel\n```\n\nLANGUAGE: bash\nCODE:\n```\n./magiskboot repack boot.img\n```\n\n----------------------------------------\n\nTITLE: KernelSU Boot Script Overview\nDESCRIPTION: This segment offers an overview of boot scripts within KernelSU, categorizing them by their execution mode (post-fs-data and late_start) and their storage location (common scripts and module scripts). Execution modes determine when the script runs during the boot process, while storage locations determine whether the scripts are module-specific or global.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nIn KernelSU, scripts are divided into two types based on their run mode: post-fs-data mode and service late_start mode:\n\n- post-fs-data mode\n   - This stage is BLOCKING. The boot process is paused before it has finished executing or 10 seconds has passed.\n   - Scripts run before any modules are mounted. This allows module developers to automatically adjust their modules before it is mounted.\n   - This stage occurs before Zygote is started, which almost makes sense for everything in Android\n   - **WARNING:** using `setprop` will cause the boot process to be bottlenecked! Instead, please use `resetprop -n <prop_name> <prop_value>`.\n   - **Only run scripts in this mode if necessary.**\n- service late_start mode\n   - This stage is NON-BLOCKING. Your script runs in parallel with the rest of the boot process.\n   - **This is the recommended stage for running most scripts.**\n\nIn KernelSU, boot scripts are divided into two types based on their storage location: common scripts and module scripts:\n\n- Common Scripts\n   - Located in `/data/adb/post-fs-data.d`, `/data/adb/service.d`, `/data/adb/post-mount.d` or `/data/adb/boot-completed.d`\n   - Only executed if the script is set to executable (`chmod +x script.sh`)\n   - Scripts in `post-fs-data.d` run in post-fs-data mode and scripts in `service.d` run in service late_start mode.\n   - Modules **DO NOT** add common scripts during installation\n- Module Scripts\n   - Located in the module's own directory\n   - Only executed if the module is enabled\n   - `post-fs-data.sh` runs in post-fs-data mode, `service.sh` runs in service late_start mode, `boot-completed.sh` runs when boot is completed, `post-mount.sh` runs on overlayfs is mounted.\n\nAll boot scripts will run in KernelSU's `ash` BusyBox shell with \"Standalone Mode\" enabled.\n```\n\n----------------------------------------\n\nTITLE: Building Aarch64 Kernel\nDESCRIPTION: This snippet builds the aarch64 kernel. It uses the `build/build.sh` script with specific configurations for GKI. The `LTO=thin` flag is essential to prevent build failures on systems with limited memory (less than 24 GB).\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: ksud boot-patch command usage for boot image patching\nDESCRIPTION: Demonstrates how to use the KernelSU ksud tool to patch a device's boot or init_boot image to enable KernelSU features, supporting cross-platform (macOS, Linux, Windows) usage.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/installation.md#_snippet_0\n\nLANGUAGE: Shell Script\nCODE:\n```\nksud boot-patch -b <boot.img> --kmi android13-5.10\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Commands with KernelSU JavaScript API\nDESCRIPTION: Demonstrates how to use the KernelSU JavaScript API to execute shell commands from a module's web interface. The example shows importing the exec function from the kernelsu package and using it to retrieve a system property.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/module-webui.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { exec } from 'kernelsu';\n\nconst { errno, stdout } = exec(\"getprop ro.product.model\");\n```\n\n----------------------------------------\n\nTITLE: Spawn Root Process - JavaScript\nDESCRIPTION: This JavaScript snippet uses the `spawn` function to execute a new process (e.g., `ls`) in a root shell.  It captures `stdout`, `stderr`, and the exit code, logging the data received from the child process streams and handling the exit event to report the process completion status.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { spawn } from 'kernelsu';\n\nconst ls = spawn('ls', ['-lh', '/data']);\n\nls.stdout.on('data', (data) => {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.log(`stderr: ${data}`);\n});\n\nls.on('exit', (code) => {\n  console.log(`child process exited with code ${code}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Magiskboot commands for unpacking, modifying, and repacking boot images on PC\nDESCRIPTION: Provides equivalent steps to modify boot images using magiskboot tool on Windows/macOS/Linux on a PC, requiring pre-downloaded images and magiskboot binary.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/installation.md#_snippet_3\n\nLANGUAGE: Shell Script\nCODE:\n```\nchmod +x magiskboot\n./magiskboot unpack boot.img\nmv -f Image kernel\n./magiskboot repack boot.img\n```\n\n----------------------------------------\n\nTITLE: Module Installer Structure\nDESCRIPTION: The file structure required for a KernelSU module installer zip file, showing the customize.sh script location which allows customizing the installation process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\nmodule.zip\n│\n├── customize.sh                       <--- (Optional, more details later)\n│                                           This script will be sourced by update-binary\n├── ...\n├── ...  /* 其他模块文件 */\n│\n```\n\n----------------------------------------\n\nTITLE: Show Toast Message - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates the use of the `toast` function from the 'kernelsu' library to display a toast message in the UI.  It takes a string argument as the message to be shown.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { toast } from 'kernelsu';\ntoa\n```\n\n----------------------------------------\n\nTITLE: Making magiskboot Executable (Shell)\nDESCRIPTION: This command uses `chmod` within an adb shell to grant execute permissions to the `magiskboot` binary, which has been previously pushed to the device. This allows the user to execute the `magiskboot` utility, enabling the operations like unpacking and repacking the boot image. This step is necessary before attempting to unpack or repack the boot image with magiskboot.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/installation.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nchmod +x magiskboot\n```\n\n----------------------------------------\n\nTITLE: Customize.sh Script Usage in KernelSU\nDESCRIPTION: This explains how to use `customize.sh` to customize the module installation process. By default the script runs after the module files are extracted and permissions are applied. `SKIPUNZIP=1` can be declared in `customize.sh` to skip default installation steps and gain full control. The script runs in ash BusyBox shell with \"Standalone Mode\" enabled.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nIf you need to customize the module installation process, you can optionally create a script in the installer named `customize.sh`. This script will be _sourced_ (not executed!) by the module installation script after all files are extracted and default permissions and second texts are applied. This is very useful if your module requires additional setup based on the device's ABI or you need to set special permissions/second texts for some of your module files.\n\nIf you want to control and completely customize the installation process, declare `SKIPUNZIP=1` in `customize.sh` to skip all default installation steps. That way, your `customize.sh` will be responsible for installing everything.\n\nThe `customize.sh` script runs in KernelSU's `ash` BusyBox shell with \"Standalone Mode\" enabled. The following variables and functions are available:\n```\n\n----------------------------------------\n\nTITLE: Detecting KernelSU Environment in Scripts\nDESCRIPTION: This snippet demonstrates how to detect if a module is running within the KernelSU environment using the `KSU` environment variable. This allows modules to execute different code paths depending on the environment.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/difference-with-magisk.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n在所有你可以运行模块脚本的地方（`customize.sh`, `post-fs-data.sh`, `service.sh`)，你都可以通过环境变量`KSU` 来区分，在 KernelSU 中，这个环境变量将被设置为 `true`。\n```\n\n----------------------------------------\n\nTITLE: Backporting path_umount for KernelSU on Pre-GKI Kernels\nDESCRIPTION: Patch for fs/namespace.c to backport path_umount functionality from kernel 5.9 to pre-GKI kernels. This enables the \"Umount modules\" feature in KernelSU on older kernels by implementing the missing path_umount function.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_11\n\nLANGUAGE: diff\nCODE:\n```\n--- a/fs/namespace.c\n+++ b/fs/namespace.c\n@@ -1739,6 +1739,39 @@ static inline bool may_mandlock(void)\n }\n #endif\n \n+static int can_umount(const struct path *path, int flags)\n+{\n+\tstruct mount *mnt = real_mount(path->mnt);\n+\n+\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n+\t\treturn -EINVAL;\n+\tif (!may_mount())\n+\t\treturn -EPERM;\n+\tif (path->dentry != path->mnt->mnt_root)\n+\t\treturn -EINVAL;\n+\tif (!check_mnt(mnt))\n+\t\treturn -EINVAL;\n+\tif (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */\n+\t\treturn -EINVAL;\n+\tif (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\treturn 0;\n+}\n+\n+int path_umount(struct path *path, int flags)\n+{\n+\tstruct mount *mnt = real_mount(path->mnt);\n+\tint ret;\n+\n+\tret = can_umount(path, flags);\n+\tif (!ret)\n+\t\tret = do_umount(mnt, flags);\n+\n+\t/* we mustn't call path_put() as that would clear mnt_expiry_mark */\n+\tdput(path->dentry);\n+\tmntput_no_expire(mnt);\n+\treturn ret;\n+}\n /*\n  * Now umount can handle mount points as well as block devices.\n  * This is important for filesystems which use unnamed block devices.\n```\n\n----------------------------------------\n\nTITLE: Deleting Files in KernelSU Modules\nDESCRIPTION: This snippet shows the method for deleting files in KernelSU modules. Unlike Magisk, KernelSU requires creating a directory with the same name as the file to be deleted.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/difference-with-magisk.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nKernelSU 不支持 `.replace` 方式，相反，你需要通过 `mknod filename c 0 0` 创建同名文件夹来删除对应文件。\n```\n\n----------------------------------------\n\nTITLE: KernelSU Setup Script (Latest Tag)\nDESCRIPTION: This command downloads and executes the `setup.sh` script from the KernelSU repository's `main` branch, which integrates KernelSU into the kernel build process.  This version uses the latest stable tag.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Modifying drivers/input/input.c for KernelSU SafeMode\nDESCRIPTION: Patch to enable KernelSU's built-in SafeMode by hooking into the input_handle_event function, which allows KernelSU to detect specific key combinations to enter recovery mode during bootloop scenarios.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/drivers/input/input.c b/drivers/input/input.c\nindex 45306f9ef247..815091ebfca4 100755\n--- a/drivers/input/input.c\n+++ b/drivers/input/input.c\n@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,\n \treturn disposition;\n }\n \n+extern bool ksu_input_hook __read_mostly;\n+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);\n+\n static void input_handle_event(struct input_dev *dev,\n \t\t\t       unsigned int type, unsigned int code, int value)\n {\n\tint disposition = input_get_disposition(dev, type, code, &value);\n+\n+\tif (unlikely(ksu_input_hook))\n+\t\tksu_handle_input_handle_event(&type, &code, &value);\n \n \tif (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)\n \t\tadd_input_randomness(type, code, value);\n```\n\n----------------------------------------\n\nTITLE: Enabling KernelSU Safe Mode by Modifying Input Handling\nDESCRIPTION: Patch for drivers/input/input.c to enable KernelSU's Safe Mode feature. This modification hooks into the input event handling system to detect specific key combinations that trigger Safe Mode, which helps prevent bootloops when KernelSU encounters issues.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_9\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/drivers/input/input.c b/drivers/input/input.c\nindex 45306f9ef247..815091ebfca4 100755\n--- a/drivers/input/input.c\n+++ b/drivers/input/input.c\n@@ -367,10 +367,13 @@ static int input_get_disposition(struct input_dev *dev,\n \treturn disposition;\n }\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_input_hook __read_mostly;\n+extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);\n+#endif\n+\n static void input_handle_event(struct input_dev *dev,\n \t\t\t       unsigned int type, unsigned int code, int value)\n {\n\tint disposition = input_get_disposition(dev, type, code, &value);\n+   #ifdef CONFIG_KSU\n+\tif (unlikely(ksu_input_hook))\n+\t\tksu_handle_input_handle_event(&type, &code, &value);\n+   #endif\n \n \tif (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)\n \t\tadd_input_randomness(type, code, value);\n```\n\n----------------------------------------\n\nTITLE: Removing GKI Protected Exports for Android 14 Kernel Compatibility\nDESCRIPTION: This command deletes all files matching 'android/abi_gki_protected_exports_*' to ensure Wi-Fi and Bluetooth functionalities work properly on certain Android 14 kernels that require removal of GKI protected exports.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nrm common/android/abi_gki_protected_exports_*\n```\n\n----------------------------------------\n\nTITLE: Manually Patching fs/open.c for KernelSU (Diff/C)\nDESCRIPTION: Provides a diff patch illustrating how to modify the `do_faccessat` function in `fs/open.c`. It adds an external function declaration and a conditional call to `ksu_handle_faccessat` based on the `CONFIG_KSU` flag. This is part of the manual integration process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 05036d819197..965b84d486b8 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn ksys_fallocate(fd, mode, offset, len);\n }\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t int *flags);\n+#endif\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n  */\n long do_faccessat(int dfd, const char __user *filename, int mode)\n {\n+\tconst struct cred *old_cred;\n \tstruct cred *override_cred;\n \tstruct path path;\n \tstruct inode *inode;\n@@ -362,6 +365,8 @@ long do_faccessat(int dfd, const char __user *filename, int mode)\n \tint res;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW;\n \n+   #ifdef CONFIG_KSU\n+\tksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n+   #endif\n \tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Installing with Magiskboot on Android\nDESCRIPTION: This section outlines steps for patching a boot image using magiskboot on an Android device. The steps describe how to unpack boot.img, replace kernel, repack, and then flash the new boot image. Requires installing magisk on android device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_17\n\n\n\n----------------------------------------\n\nTITLE: Patching open.c (older kernels) for KernelSU\nDESCRIPTION: This patch modifies `fs/open.c` in older kernels to integrate KernelSU's hook for the `faccessat` system call. It conditionally includes the KernelSU functionality based on `CONFIG_KSU`. The `ksu_handle_faccessat` function is called before calling the original function. This ensures that KernelSU can properly intercept and handle the access calls.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 2ff887661237..e758d7db7663 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn error;\n }\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t\t        int *flags);\n+#endif\n+  \n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n \tint res;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW;\n+   #ifdef CONFIG_KSU\n+  ksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n+   #endif\n \n \tif (mode & ~S_IRWXO)  /* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Creating an example REMOVE variable\nDESCRIPTION: This snippet provides an example of using the `REMOVE` variable within a `customize.sh` script to remove files or directories from the system. It utilizes the overlayfs mechanism to achieve a systemless removal.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/module.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nREMOVE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Manually Patching fs/open.c (Older Kernels) for KernelSU (Diff/C)\nDESCRIPTION: Provides a diff patch for `fs/open.c` targeted at kernels older than 4.17 where `do_faccessat` might not exist. It shows how to add the KernelSU hook `ksu_handle_faccessat` directly within the `SYSCALL_DEFINE3(faccessat, ...)` macro definition, conditionally compiled using `CONFIG_KSU`. This is part of the manual integration process for specific older kernels.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 2ff887661237..e758d7db7663 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -355,6 +355,9 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn error;\n }\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t\t\t\t\t        int *flags);\n+#endif\n+\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -370,6 +373,8 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)\n \tint res;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW;\n \n+   #ifdef CONFIG_KSU\n+\tksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n+   #endif\n+\n \tif (mode & ~S_IRWXO)\t/* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Replacing Kernel File on PC (Shell)\nDESCRIPTION: Standard shell command used on a PC to replace the extracted stock `kernel` file with the KernelSU `Image` file. `-f` forces the move, overwriting the destination file.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\nmv -f Image kernel\n\n```\n\n----------------------------------------\n\nTITLE: Building Kernel with Bazel - Shell\nDESCRIPTION: This snippet builds the kernel using Bazel. This requires the bazel build tool and the correct configurations for the kernel build. The output is the kernel image for aarch64.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Enabling Kprobes in Kernel Configuration\nDESCRIPTION: These kernel configuration options enable kprobes, which is necessary for the automatic integration method of KernelSU. These options need to be enabled in the kernel's `.config` file before building the kernel. If kprobes are not enabled, the automatic integration will fail.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nCONFIG_KPROBES=y\nCONFIG_HAVE_KPROBES=y\nCONFIG_KPROBE_EVENTS=y\n```\n\n----------------------------------------\n\nTITLE: Overriding Shell Startup with .ksurc - Shell\nDESCRIPTION: This snippet explains how to customize the shell's startup process. By default, the shell (`/system/bin/sh`) loads `/system/etc/mkshrc`. To override this and load a custom configuration, a user can create a `/data/adb/ksu/.ksurc` file.  The `su` command will then load this user-provided file instead of the system default.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/hidden-features.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Adding KernelSU via Manual Patching\nDESCRIPTION: This shell command downloads and executes the `setup.sh` script from the KernelSU repository to integrate the KernelSU code into the kernel source tree.  This is the initial step for manual patching.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Enabling KernelSU in Defconfig\nDESCRIPTION: This snippet demonstrates how to configure the `CONFIG_KSU` option in the kernel's defconfig file. This option enables KernelSU support during the kernel build process.  The specific path of the defconfig file might vary depending on the device.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n# KernelSU\nCONFIG_KSU=y\n```\n\n----------------------------------------\n\nTITLE: Install KernelSU Library - Shell\nDESCRIPTION: This snippet demonstrates the installation of the 'kernelsu' library using `yarn`.  This is a prerequisite for using the library's functionalities.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn add kernelsu\n```\n\n----------------------------------------\n\nTITLE: LKM Mode benefits\nDESCRIPTION: The document enumerates the advantages of LKM mode. It does not replace the kernel, making it suitable for cases where original kernel requirements exist. LKM mode facilitates easier updates and OTA compatibility. The mode allows temporary root and uninstallation without partition flashing.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Manually Patching fs/stat.c (vfs_fstatat) for KernelSU (Diff/C)\nDESCRIPTION: Provides an alternative diff patch for `fs/stat.c`, showing how to modify the `vfs_fstatat` function instead of `vfs_statx` for kernels that do not have the latter. It adds an external function declaration and a conditional call to `ksu_handle_stat` based on the `CONFIG_KSU` flag. This is part of the manual integration process.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 068fdbcc9e26..5348b7bb9db2 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)\n }\n EXPORT_SYMBOL(vfs_fstat);\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+#endif\n int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n \t\t\tint flag)\n {\n@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = 0;\n \n+   #ifdef CONFIG_KSU \n+\tksu_handle_stat(&dfd, &filename, &flag);\n+   #endif\n+\n \tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t      AT_EMPTY_PATH)) != 0)\n \t\tgoto out;\n```\n\n----------------------------------------\n\nTITLE: Rendering Maintainers, Repositories, and Devices in a Vue.js Table - HTML\nDESCRIPTION: This snippet defines an HTML table enhanced with Vue.js directives to dynamically render rows for each repository entry from the imported data. It displays the maintainer name and link, kernel repository name and link, and supported devices per row. The snippet uses v-for for iteration and binds href attributes safely with target and rel attributes to open links in new tabs without referrer issues.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/unofficially-support-devices.md#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<table>\n   <thead>\n      <tr>\n         <th>維護者</th>\n         <th>存放庫</th>\n         <th>支援裝置</th>\n      </tr>\n   </thead>\n   <tbody>\n    <tr v-for=\"repo in data\" :key=\"repo.devices\">\n        <td><a :href=\"repo.maintainer_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.maintainer }}</a></td>\n        <td><a :href=\"repo.kernel_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.kernel_name }}</a></td>\n        <td>{{ repo.devices }}</td>\n    </tr>\n   </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Get Module Info - JavaScript\nDESCRIPTION: This JavaScript snippet uses the `moduleInfo` function to retrieve information about a KernelSU module.  The code logs the module information, specifically the module ID, to the console.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { moduleInfo } from 'kernelsu';\n// print moduleId in console\nconsole.log(moduleInfo());\n```\n\n----------------------------------------\n\nTITLE: Patching open.c for KernelSU\nDESCRIPTION: This patch modifies `fs/open.c` to add KernelSU's hook for the `faccessat` system call. It conditionally includes the KernelSU functionality based on `CONFIG_KSU`.  The `ksu_handle_faccessat` function is called before calling the original function.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/open.c b/fs/open.c\nindex 05036d819197..965b84d486b8 100644\n--- a/fs/open.c\n+++ b/fs/open.c\n@@ -348,6 +348,8 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n \treturn ksys_fallocate(fd, mode, offset, len);\n }\n \n+#ifdef CONFIG_KSU\n+extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,\n+\t\t\t int *flags);\n+#endif\n /*\n  * access() needs to use the real uid/gid, not the effective uid/gid.\n  * We do this by temporarily clearing all FS-related capabilities and\n@@ -355,6 +357,7 @@ SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n  */\n long do_faccessat(int dfd, const char __user *filename, int mode)\n {\n\tconst struct cred *old_cred;\n\tstruct cred *override_cred;\n\tstruct path path;\n\tstruct inode *inode;\n\tstruct vfsmount *mnt;\n\tint res;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW;\n+   #ifdef CONFIG_KSU\n+  ksu_handle_faccessat(&dfd, &filename, &mode, NULL);\n+   #endif\n \n \tif (mode & ~S_IRWXO)  /* where's F_OK, X_OK, W_OK, R_OK? */\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Building aarch64 Android Kernel Image using Shell\nDESCRIPTION: This snippet demonstrates how to build an aarch64 kernel image using a shell script-based build system. It sets the LTO=thin flag, which is critical for memory-constrained systems (less than 24 GB RAM), and specifies the build configuration file. The build command leverages a build.sh script located in the build directory. The output is a kernel image suitable for GKI-compliant Android devices.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-build.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nLTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh\n```\n\n----------------------------------------\n\nTITLE: Removing Files/Folders with mknod\nDESCRIPTION: This snippet demonstrates how to remove files or folders from the original system directory using `mknod` and the `REMOVE` variable within `customize.sh`.  It leverages OverlayFS's behavior to 'white-out' files, making them appear deleted without altering the actual `/system` partition.  Dependencies include the module's path (`$MODPATH`).  The output is the removal of specified files/folders from the overlaid `/system`.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/module.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nREMOVE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Rendering Dynamic Table of Maintainers and Devices Using Vue 3 Template HTML\nDESCRIPTION: This snippet uses Vue 3 template syntax to create a table with columns for Maintainer, Repository, and Supported Devices. By leveraging the v-for directive, it iterates through the imported data array (\"data\"), generating rows and embedding links with appropriate attributes (target and rel) for security and SEO. It expects the data to have keys: maintainer, maintainer_link, kernel_name, kernel_link, and devices.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/unofficially-support-devices.md#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<table>\\n   <thead>\\n      <tr>\\n         <th>Mantenedor</th>\\n         <th>Repositário</th>\\n         <th>Dispositivos suportados</th>\\n      </tr>\\n   </thead>\\n   <tbody>\\n    <tr v-for=\"repo in data\" :key=\"repo.devices\">\\n        <td><a :href=\"repo.maintainer_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.maintainer }}</a></td>\\n        <td><a :href=\"repo.kernel_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.kernel_name }}</a></td>\\n        <td>{{ repo.devices }}</td>\\n    </tr>\\n   </tbody>\\n</table>\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU to Kernel Source Tree with bash\nDESCRIPTION: Command to download and add KernelSU to your kernel source tree. Note that you must use v0.9.5 for non-GKI kernels as newer versions no longer support them.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.9.5\n```\n\n----------------------------------------\n\nTITLE: Rebooting device after flashing in shell\nDESCRIPTION: Command to reboot the device after successfully flashing the KernelSU boot image. This completes the installation process and boots into the system with KernelSU installed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/installation.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nfastboot reboot\n```\n\n----------------------------------------\n\nTITLE: Building Kernel Image (bazel) - Shell\nDESCRIPTION: This shell script command builds the kernel image using `bazel`. It uses the `tools/bazel build` command to build the kernel, specifying the `--config=fast` option and the target `//common:kernel_aarch64_dist`. This is for building kernels starting from Android 13. This builds the kernel using the Bazel build system.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntools/bazel build --config=fast //common:kernel_aarch64_dist\n```\n\n----------------------------------------\n\nTITLE: Rebooting after fastboot\nDESCRIPTION: This step instructs to reboot the device after writing the boot image using the `fastboot reboot` command.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\nfastboot reboot\n```\n\n----------------------------------------\n\nTITLE: Patching read_write.c for KernelSU\nDESCRIPTION: This code modifies the `fs/read_write.c` file to incorporate KernelSU functionality. It adds conditional compilation based on `CONFIG_KSU`, and calls `ksu_handle_vfs_read` if the `ksu_vfs_read_hook` is enabled, before calling the original function. This ensures that KernelSU's read hooks are executed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/read_write.c b/fs/read_write.c\nindex 650fc7e0f3a6..55be193913b6 100644\n--- a/fs/read_write.c\n+++ b/fs/read_write.c\n@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n }\n EXPORT_SYMBOL(kernel_read);\n \n+#ifdef CONFIG_KSU\n+extern bool ksu_vfs_read_hook __read_mostly;\n+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,\n+\tsize_t *count_ptr, loff_t **pos);\n+#endif\n ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n {\n\tssize_t ret;\n+   #ifdef CONFIG_KSU \n+\tif (unlikely(ksu_vfs_read_hook))\n+\t\tksu_handle_vfs_read(&file, &buf, &count, &pos);\n+   #endif\n+\n \tif (!(file->f_mode & FMODE_READ))\n \t\treturn -EBADF;\n \tif (!(file->f_mode & FMODE_CAN_READ))\n\n```\n\n----------------------------------------\n\nTITLE: Installing GKI using Kernel Manager\nDESCRIPTION: This method requires root access. The method uses AnyKernel3 ZIP and a kernel manager app. The user is instructed to download AnyKernel3 zip and install it.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Fetching and Rendering KernelSU Repositories with Vue.js\nDESCRIPTION: This snippet defines a Vue.js script setup block. It imports data from a 'repos.json' file. This data is then used to dynamically generate a table. The table displays maintainer information, repository links, and supported devices. The `v-for` directive iterates through the `data` array to create table rows. Links are rendered using the `href` attribute.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/unofficially-support-devices.md#_snippet_0\n\nLANGUAGE: Vue.js\nCODE:\n```\n<script setup>\nimport data from '../../repos.json'\n</script>\n\n<table>\n   <thead>\n      <tr>\n         <th>メンテナー</th>\n         <th>リポジトリ</th>\n         <th>対応デバイス</th>\n      </tr>\n   </thead>\n   <tbody>\n    <tr v-for=\"repo in data\" :key=\"repo.devices\">\n        <td><a :href=\"repo.maintainer_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.maintainer }}</a></td>\n        <td><a :href=\"repo.kernel_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.kernel_name }}</a></td>\n        <td>{{ repo.devices }}</td>\n    </tr>\n   </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Finding cxx Package and Linking Libraries (CMake)\nDESCRIPTION: This code finds the cxx package and links the cxx::cxx library. This is a dependency required for the kernelsu project. It searches for the package via find_package and uses link_libraries to ensure linking occurs. The output will link the cxx library to the project.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/manager/app/src/main/cpp/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(cxx REQUIRED CONFIG)\nlink_libraries(cxx::cxx)\n```\n\n----------------------------------------\n\nTITLE: Installing KernelSU with Specific Tag (e.g., v0.5.2)\nDESCRIPTION: This command downloads and executes a specific version of the KernelSU setup script from GitHub, which is useful for reproducibility and testing specific versions.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Android Boot Sequence with KernelSU Hooks\nDESCRIPTION: A step-by-step representation of the Android boot process, starting from the bootloader and kernel initialization, through various init stages (early-fs, fs, post-fs-data, zygote-start), service startups, and culminating in the boot complete event and user-operable state. KernelSU-specific actions, module script executions (post-fs-data.sh, post-mount.sh, service.sh, boot-completed.sh), sepolicy loading, tmpfs mounting, and property setting are highlighted with asterisks.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/module.md#_snippet_4\n\nLANGUAGE: txt\nCODE:\n```\n0. Bootloader (nothing on screen)\nload patched boot.img\nload kernel:\n    - GKI mode: GKI kernel with KernelSU integrated\n    - LKM mode: stock kernel\n...\n\n1. kernel exec init (oem logo on screen):\n    - GKI mode: stock init\n    - LKM mode: exec ksuinit, insmod kernelsu.ko, exec stock init\nmount /dev, /dev/pts, /proc, /sys, etc.\nproperty-init -> read default props\nread init.rc\n...\nearly-init -> init -> late_init\nearly-fs\n   start vold\nfs\n  mount /vendor, /system, /persist, etc.\npost-fs-data\n  *safe mode check\n  *execute general scripts in post-fs-data.d/\n  *load sepolicy.rule\n  *mount tmpfs\n  *execute module scripts post-fs-data.sh\n    **(Zygisk)./bin/zygisk-ptrace64 monitor\n  *(pre)load system.prop (same as resetprop -n)\n  *remount modules /system\n  *execute general scripts in post-mount.d/\n  *execute module scripts post-mount.sh\nzygote-start\nload_all_props_action\n  *execute resetprop (actual set props for resetprop with -n option)\n... -> boot\n  class_start core\n    start-service logd, console, vold, etc.\n  class_start main\n    start-service adb, netd (iptables), zygote, etc.\n\n2. kernel2user init (rom animation on screen, start by service bootanim)\n*execute general scripts in service.d/\n*execute module scripts service.sh\n*set props for resetprop without -p option\n  **(Zygisk) hook zygote (start zygiskd)\n  **(Zygisk) mount zygisksu/module.prop\nstart system apps (autostart)\n...\nboot complete (broadcast ACTION_BOOT_COMPLETED event)\n*execute general scripts in boot-completed.d/\n*execute module scripts boot-completed.sh\n\n3. User operable (lock screen)\ninput password to decrypt /data/data\n*actual set props for resetprop with -p option\nstart user apps (autostart)\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Folder Structure Overview - Plain Text\nDESCRIPTION: Shows the directory structure expected for KernelSU modules installed under /data/adb/modules. It describes module folders named by module ID containing module.prop metadata, optional system overlay directories, status flags (skip_mount, disable, remove), and various scripts like post-fs-data.sh and service.sh used in boot stages. Symbolic links and additional optional files are also illustrated. This structure follows KernelSU conventions and differs from Magisk by lack of Zygisk support.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n/data/adb/modules\n├── .\n├── .\n|\n├── $MODID                  <--- フォルダの名前はモジュールの ID で付けます\n│   │\n│   │      *** モジュールの ID ***\n│   │\n│   ├── module.prop         <--- このファイルにモジュールのメタデータを保存します\n│   │\n│   │      *** メインコンテンツ ***\n│   │\n│   ├── system              <--- skip_mount が存在しない場合、このフォルダがマウントされます\n│   │   ├── ...\n│   │   ├── ...\n│   │   └── ...\n│   │\n│   │      *** ステータスフラグ ***\n│   │\n│   ├── skip_mount          <--- 存在する場合、KernelSU はシステムフォルダをマウントしません\n│   ├── disable             <--- 存在する場合、モジュールは無効化されます\n│   ├── remove              <--- 存在する場合、次の再起動時にモジュールが削除されます\n│   │\n│   │      *** 任意のファイル ***\n│   │\n│   ├── post-fs-data.sh     <--- このスクリプトは post-fs-data で実行されます\n│   ├── service.sh          <--- このスクリプトは late_start サービスで実行されます\n|   ├── uninstall.sh        <--- このスクリプトは KernelSU がモジュールを削除するときに実行されます\n│   ├── system.prop         <--- このファイルのプロパティは resetprop によってシステムプロパティとして読み込まれます\n│   ├── sepolicy.rule       <--- カスタム SEPolicy ルールを追加します\n│   │\n│   │      *** 自動生成されるため、手動で作成または変更しないでください ***\n│   │\n│   ├── vendor              <--- $MODID/system/vendor へのシンボリックリンク\n│   ├── product             <--- $MODID/system/product へのシンボリックリンク\n│   ├── system_ext          <--- $MODID/system/system_ext へのシンボリックリンク\n│   │\n│   │      *** その他のファイル/フォルダの追加も可能です ***\n│   │\n│   ├── ...\n│   └── ...\n|\n├── another_module\n│   ├── .\n│   └── .\n├── .\n├── .\n```\n\n----------------------------------------\n\nTITLE: Understanding ADB and fastboot\nDESCRIPTION: Explains the need for ADB and fastboot tools. The user is advised to learn about these tools using a search engine if they are unfamiliar with them.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Latest Tag) - Shell\nDESCRIPTION: This shell script downloads and executes the `setup.sh` script from the KernelSU repository to integrate it with the current kernel source.  The `curl` command fetches the script, and the `bash` command executes it. The `setup.sh` script modifies the kernel build process to include KernelSU functionality. This command fetches and runs the setup script for the latest stable KernelSU release.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Main Branch) - Shell\nDESCRIPTION: This shell script downloads and executes the `setup.sh` script from the KernelSU repository to integrate it with the current kernel source. The `curl` command fetches the script and the `bash` command executes it with the argument `main` to specify the main branch (development branch) of KernelSU. This command fetches and runs the setup script for the development branch of KernelSU.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\n----------------------------------------\n\nTITLE: REMOVE Variable Usage for File Removal\nDESCRIPTION: Example of using the REMOVE variable in customize.sh to specify files or directories that should be removed from the system when the module is applied via overlayfs.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nREMOVE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Rendering Data in HTML Table using Vue.js\nDESCRIPTION: This snippet iterates through the imported `data` array using `v-for` to generate table rows. Each row displays the maintainer's name (linked to their profile), the kernel repository name (linked to the kernel source), and the supported devices. The links use `target=\"_blank\"` and `rel=\"noreferrer\"` for security and user experience.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/unofficially-support-devices.md#_snippet_1\n\nLANGUAGE: Vue.js\nCODE:\n```\n<table>\n   <thead>\n      <tr>\n         <th>Maintainer</th>\n         <th>Repository</th>\n         <th>Support devices</th>\n      </tr>\n   </thead>\n   <tbody>\n    <tr v-for=\"repo in data\" :key=\"repo.devices\">\n        <td><a :href=\"repo.maintainer_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.maintainer }}</a></td>\n        <td><a :href=\"repo.kernel_link\" target=\"_blank\" rel=\"noreferrer\">{{ repo.kernel_name }}</a></td>\n        <td>{{ repo.devices }}</td>\n    </tr>\n   </tbody>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Data in Vue Component\nDESCRIPTION: This snippet imports a JSON file (repos.json) containing data about kernel repositories and their maintainers. It uses the `import` statement to make the data available within the Vue component's scope for rendering in the template.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/unofficially-support-devices.md#_snippet_0\n\nLANGUAGE: Vue.js\nCODE:\n```\n<script setup>\nimport data from '../repos.json'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Creating an example REPLACE variable\nDESCRIPTION: This snippet provides an example of using the `REPLACE` variable within a `customize.sh` script to replace files or directories from the system. It utilizes the overlayfs mechanism to achieve a systemless replacement.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/module.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nREPLACE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: Patching fs/stat.c for KernelSU Integration\nDESCRIPTION: This diff patch modifies the `fs/stat.c` file in the kernel source code to integrate KernelSU's file stat handling logic. It hooks into the `vfs_statx` function, allowing KernelSU to intercept file stat calls.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 376543199b5a..82adcef03ecc 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -148,6 +148,8 @@ int vfs_statx_fd(unsigned int fd, struct kstat *stat,\n }\n EXPORT_SYMBOL(vfs_statx_fd);\n \n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+\n /**\n  * vfs_statx - Get basic and extra attributes by filename\n  * @dfd: A file descriptor representing the base dir for a relative filename\n@@ -170,6 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;\n \n+\tksu_handle_stat(&dfd, &filename, &flags);\n \tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)\n \t\treturn -EINVAL;\n```\n\n----------------------------------------\n\nTITLE: Defining KernelSU Module's Webroot Directory Structure txt\nDESCRIPTION: Defines the required directory structure for a KernelSU module web interface. The root directory must contain a 'webroot' subdirectory with an 'index.html' file as the entry point for the web UI, alongside a 'module.prop' file. This structure allows KernelSU to correctly locate and display the module's web page through its WebView. Proper permissions and SELinux contexts for this directory are automatically managed by KernelSU upon installation, so manual adjustments are discouraged.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module-webui.md#_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n❏ tree .\n.\n|-- module.prop\n`-- webroot\n    `-- index.html\n```\n\n----------------------------------------\n\nTITLE: Patching fs/read_write.c for KernelSU Integration\nDESCRIPTION: This diff patch modifies the `fs/read_write.c` file in the kernel source code.  It hooks into the `vfs_read` function, giving KernelSU the ability to intercept and modify file read operations.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/how-to-integrate-for-non-gki.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/read_write.c b/fs/read_write.c\nindex 650fc7e0f3a6..55be193913b6 100644\n--- a/fs/read_write.c\n+++ b/fs/read_write.c\n@@ -434,10 +434,14 @@ ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n }\n EXPORT_SYMBOL(kernel_read);\n \n+extern bool ksu_vfs_read_hook __read_mostly;\n+extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,\n+\t\t\tsize_t *count_ptr, loff_t **pos);\n ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n {\n \tssize_t ret;\n \n+\tif (unlikely(ksu_vfs_read_hook))\n+\t\tksu_handle_vfs_read(&file, &buf, &count, &pos);\n+\n \tif (!(file->f_mode & FMODE_READ))\n```\n\n----------------------------------------\n\nTITLE: SELinux configuration example\nDESCRIPTION: This snippet demonstrates how SELinux can be used to control the permissions of a root process after executing `su`. It shows the definition of a custom SELinux domain (`app1`), setting its type, applying the enforcement, making it a trusted subject, and then allowing all actions for demonstration purposes. It provides insight into setting up security rules with a custom context.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/app-profile.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntype app1\nenforce app1\ntypeattribute app1 mlstrustedsubject\nallow app1 * * *\n```\n\n----------------------------------------\n\nTITLE: Modifying fs/stat.c for KernelSU Integration with vfs_fstatat\nDESCRIPTION: Alternative patch for stat.c when using vfs_fstatat instead of vfs_statx in older kernels, which allows KernelSU to intercept file status operations for permission management.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-integrate-for-non-gki.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/fs/stat.c b/fs/stat.c\nindex 068fdbcc9e26..5348b7bb9db2 100644\n--- a/fs/stat.c\n+++ b/fs/stat.c\n@@ -87,6 +87,8 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)\n }\n EXPORT_SYMBOL(vfs_fstat);\n \n+extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);\n+\n int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n \t\tint flag)\n {\n@@ -94,6 +96,8 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,\n \tint error = -EINVAL;\n \tunsigned int lookup_flags = 0;\n \n+\tksu_handle_stat(&dfd, &filename, &flag);\n+\n \tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |\n \t\t      AT_EMPTY_PATH)) != 0)\n \t\tgoto out;\n```\n\n----------------------------------------\n\nTITLE: Installing LKM with command-line\nDESCRIPTION: This provides instructions on installing LKM via the command line using the `ksud` tool. It explains where to download the tool. It mentions the options available in the `ksud boot-patch` command, including boot image, kernel, module, and KMI version specification.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\noriole:/ # ksud boot-patch -h\nPatch boot or init_boot images to apply KernelSU\n\nUsage: ksud boot-patch [OPTIONS]\n\nOptions:\n  -b, --boot <BOOT>              boot image path, if not specified, will try to find the boot image automatically\n  -k, --kernel <KERNEL>          kernel image path to replace\n  -m, --module <MODULE>          LKM module path to replace, if not specified, will use the builtin one\n  -i, --init <INIT>              init to be replaced\n  -u, --ota                      will use another slot when boot image is not specified\n  -f, --flash                    Flash it to boot partition after patch\n  -o, --out <OUT>                output path, if not specified, will use current directory\n      --magiskboot <MAGISKBOOT>  magiskboot path, if not specified, will use builtin one\n      --kmi <KMI>                KMI version, if specified, will use the specified KMI\n  -h, --help                     Print help\n```\n\n----------------------------------------\n\nTITLE: Creating the customize.sh File\nDESCRIPTION: This snippet demonstrates the creation of a `customize.sh` file which allows developers to customize the installation process. This script will be sourced by the installer after all files are extracted, and standard permissions are applied.  It allows for device-specific configurations and setting special permissions or security contexts.  Requires knowledge of the KernelSU environment variables and functions.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/module.md#_snippet_2\n\nLANGUAGE: txt\nCODE:\n```\nmodule.zip\n│\n├── customize.sh                       <--- (Opcional, mais detalhes posteriormente)\n│                                           Este script será fornecido por update-binary\n├── ...\n├── ...  /* O resto dos arquivos do módulo */\n│\n```\n\n----------------------------------------\n\nTITLE: Alternative KernelSU Installation Methods in Markdown\nDESCRIPTION: Markdown documentation explaining alternative approaches to install KernelSU, including using Magisk first for root access and using PC flashing tools. It warns users to prioritize the magiskboot method if these alternatives cause boot failures.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/installation.md#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n## 其他变通方法 {#other-methods}\n\n其实所有这些安装方法的主旨只有一个，那就是**替换原厂的内核为 KernelSU 提供的内核**；只要能实现这个目的，就可以安装；比如以下是其他可行的方法：\n\n1. 首先安装 Magisk，通过 Magisk 获取 root 权限后使用内核刷写器刷入 KernelSU 的 AnyKernel 包。\n2. 使用某些 PC 上的刷机工具箱刷入 KernelSU 提供的内核。\n\n如果这些方法导致无法开机，请优先尝试用 `magiskboot` 的方法。\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom RC File for KernelSU\nDESCRIPTION: By default, the system shell loads /system/etc/mkshrc. KernelSU allows users to create a custom .ksurc file at /data/adb/ksu/.ksurc which will be loaded when using the su command.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/hidden-features.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n/data/adb/ksu/.ksurc\n```\n\n----------------------------------------\n\nTITLE: Displaying User and Group IDs in ADB Shell (Example)\nDESCRIPTION: This shell command displays the current user's ID (UID), group ID (GID), and supplementary groups in an ADB shell. It's used to understand the current user's context and permissions. The output shows the UID, GID, and groups, along with contextual information.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/app-profile.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\noriole:/ $ id\nuid=2000(shell) gid=2000(shell) groups=2000(shell),1004(input),1007(log),1011(adb),1015(sdcard_rw),1028(sdcard_r),1078(ext_data_rw),1079(ext_obb_rw),3001(net_bt_admin),3002(net_bt),3003(inet),3006(net_bw_stats),3009(readproc),3011(uhid),3012(readtracefs) context=u:r:shell:s0\n```\n\n----------------------------------------\n\nTITLE: KernelSU Module Installer ZIP File Structure - Plain Text\nDESCRIPTION: Illustrates the organization of a KernelSU module installer packaged as a ZIP file. It optionally contains a customize.sh script loaded during installation for advanced setup, followed by other module files. The basic ZIP structure is simple but allows customization through the included script.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_2\n\nLANGUAGE: txt\nCODE:\n```\nmodule.zip\n│\n├── customize.sh                       <--- (任意、詳細は後述)\n│                                           このスクリプトは update-binary から読み込まれます\n├── ...\n├── ...  /* 残りのモジュールのファイル */\n```\n\n----------------------------------------\n\nTITLE: Determining KernelSU modes\nDESCRIPTION: Introduces KernelSU's two operating modes: GKI (replacing the device's original kernel with a generic one) and LKM (loading a loadable kernel module). The choice between these modes depends on the specific device and use case.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Synchronizing Kernel Source Code using repo for GKI Android Kernel\nDESCRIPTION: This script initializes the repo for Android kernel sources, sets the manifest, and synchronizes the source code. It includes moving the manifest file to the repo directory for a predictable build process, based on a specific kernel manifest XML, which should be downloaded from the official GKI repository.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Integrating KernelSU (Specific Tag) - Shell\nDESCRIPTION: This shell script downloads and executes the `setup.sh` script from the KernelSU repository to integrate it with the current kernel source. The `curl` command fetches the script and the `bash` command executes it with the argument `v0.5.2` (or any other tag) to specify a specific KernelSU tag.  This command allows the user to select and integrate a specific version of KernelSU.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/how-to-build.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Downloading and Running KernelSU Setup Script (Bash)\nDESCRIPTION: Downloads and executes the KernelSU setup script using `curl` and `bash` to add the KernelSU source files (specifically version v0.9.5, the last compatible version) to the current kernel source tree. This is the initial step for both kprobe and manual integration methods.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.9.5\n```\n\n----------------------------------------\n\nTITLE: Choosing between GKI and LKM\nDESCRIPTION: The document recommends LKM mode for phones and GKI mode for emulators, WSA, or Waydroid.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: KernelSU Module 'REPLACE' Variable Example for Directory Overlay Replacement - Shell\nDESCRIPTION: An example snippet showing how to use the REPLACE variable inside customize.sh to specify directories that replace system directories fully by setting trusted.overlay.opaque attribute. KernelSU automatically creates appropriate directories and applies the necessary OverlayFS attribute to replace these system folders during module activation.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/module.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nREPLACE=\"\n/system/app/YouTube\n/system/app/Bloatware\n\"\n```\n\n----------------------------------------\n\nTITLE: KernelSU Magisk Version Note\nDESCRIPTION: This is a warning regarding the `MAGISK_VER_CODE` and `MAGISK_VER` variables in the KernelSU environment. It emphasizes these variables are not reliable for KernelSU detection because they are kept constant. This helps to avoid the incorrect usage of these variables, ensuring proper checks.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/module.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nIn KernelSU, MAGISK_VER_CODE always is 25200 and MAGISK_VER always is v25.2. Please do not use these two variables to determine if it's running on KernelSU.\n```\n\n----------------------------------------\n\nTITLE: Enabling Kprobes in Kernel Configuration (Text/Config)\nDESCRIPTION: Specifies the necessary kernel configuration options (`CONFIG_KPROBES`, `CONFIG_HAVE_KPROBES`, `CONFIG_KPROBE_EVENTS`) that must be enabled (set to 'y') in the kernel's `.config` or `defconfig` file to support KernelSU integration via the kprobe method. Enabling `CONFIG_MODULES` might also be required.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_1\n\nLANGUAGE: txt\nCODE:\n```\nCONFIG_KPROBES=y\nCONFIG_HAVE_KPROBES=y\nCONFIG_KPROBE_EVENTS=y\n```\n\n----------------------------------------\n\nTITLE: Understanding KMI\nDESCRIPTION: This explains the concept of Kernel Module Interface (KMI) and its relation to compatibility. Kernels with the same KMI version are compatible. Different KMIs cause incompatibility, and the device might not boot when flashing a kernel with a different KMI. The format of kernel version for GKI devices is also detailed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Setting CMake Version and Project Definition\nDESCRIPTION: This snippet sets the minimum required version of CMake and defines the project name. It ensures that the build process uses a compatible version of CMake and names the project 'kernelsu'. There are no specific parameters here, only the versions. The output is that CMake is setup to build the kernelsu project.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/manager/app/src/main/cpp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Sets the minimum version of CMake required to build the native library.\ncmake_minimum_required(VERSION 3.18.1)\n\nproject(\"kernelsu\")\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Library and Linking Source Files (CMake)\nDESCRIPTION: This snippet creates a shared library named 'kernelsu' and specifies the source files to be included. It uses the add_library command with the SHARED option.  The input is the list of source files 'jni.cc' and 'ksu.cc'. The output is a shared library which is compiled using the mentioned sources files.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/manager/app/src/main/cpp/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(kernelsu\n        SHARED\n        jni.cc\n        ksu.cc\n        )\n```\n\n----------------------------------------\n\nTITLE: Adding KernelSU to Kernel Source Tree\nDESCRIPTION: This snippet downloads and executes a setup script to add KernelSU to the kernel source tree. The script fetches the necessary files from the KernelSU repository.  The different methods for calling setup.sh are shown, which are determined by the branch or tag being used.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-integrate-for-non-gki.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s main\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LSs \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" | bash -s v0.5.2\n```\n\n----------------------------------------\n\nTITLE: Flashing KernelSU boot.img Using Fastboot in Bash\nDESCRIPTION: Commands for flashing the KernelSU boot.img onto an Android device using fastboot. It includes rebooting the device into bootloader mode with adb and flashing the boot partition with the provided boot.img file. This method requires the device to support fastboot and is suitable for first-time KernelSU installation without root or custom recovery.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/installation.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nfastboot flash boot boot.img\n```\n\nLANGUAGE: sh\nCODE:\n```\nfastboot reboot\n```\n\n----------------------------------------\n\nTITLE: Unpacking Boot Image with magiskboot on Android (Shell)\nDESCRIPTION: Executes the `magiskboot` binary on the Android device to unpack the `boot.img` file. This process extracts components like the kernel image, which is saved as a file named `kernel` in the current directory.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/installation.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n./magiskboot unpack boot.img\n\n```\n\n----------------------------------------\n\nTITLE: SELinux Configuration Example\nDESCRIPTION: This code snippet provides an example of SELinux rules that could be applied to a custom domain `app1`.  These rules include `type`, `enforce`, `typeattribute` and `allow` statements that configure the SELinux context of an application when using the Root Profile.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/app-profile.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntype app1\nenforce app1\ntypeattribute app1 mlstrustedsubject\nallow app1 * * *\n```\n\n----------------------------------------\n\nTITLE: Removing GKI Protected Exports - Shell\nDESCRIPTION: This snippet removes files related to GKI protected exports, which might be necessary to make Wi-Fi/Bluetooth work in some Android 14 kernels.  This operation is performed via the `rm` command, and requires the user to be in the root of the kernel source tree.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/pt_BR/guide/how-to-build.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nrm common/android/abi_gki_protected_exports_*\n```\n\n----------------------------------------\n\nTITLE: Resizing modules.img (Not Recommended)\nDESCRIPTION: This snippet shows the command to resize the `modules.img` file.  It is highly discouraged as it may cause modules to malfunction.  No support will be provided if you choose to proceed.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_CN/guide/faq.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nresize2fs -M\n```\n\n----------------------------------------\n\nTITLE: Syncing Kernel Source Code (repo)\nDESCRIPTION: This snippet demonstrates how to synchronize the kernel source code using the `repo` tool. It initializes the repo, moves the manifest file, and syncs the repository.  The `<kernel_manifest.xml>` file is crucial for reproducible builds.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Syncing Kernel Source Code using repo\nDESCRIPTION: This snippet initializes the repo, moves the kernel manifest file, initializes with the manifest file and synchronizes the source code.  The `<kernel_manifest.xml>` file uniquely identifies the build and allows for rebuilding. It relies on the repo tool and assumes a valid kernel manifest file is available.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ru_RU/guide/how-to-build.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrepo init -u https://android.googlesource.com/kernel/manifest\nmv <kernel_manifest.xml> .repo/manifests\nrepo init -m manifest.xml\nrepo sync\n```\n\n----------------------------------------\n\nTITLE: Enabling KernelSU in Kernel Configuration (Text/Config)\nDESCRIPTION: Shows the kernel configuration option (`CONFIG_KSU`) that needs to be added and set to 'y' in the relevant `defconfig` file (e.g., `arch/arm64/configs/your_defconfig`) to enable KernelSU when using the manual integration method.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/guide/how-to-integrate-for-non-gki.md#_snippet_2\n\nLANGUAGE: txt\nCODE:\n```\n# KernelSU\nCONFIG_KSU=y\n```\n\n----------------------------------------\n\nTITLE: Module Property File Format (module.prop)\nDESCRIPTION: Format specification for the module.prop file which contains module metadata such as ID, name, version, and description. This file is required for KernelSU to recognize a folder as a valid module.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/zh_TW/guide/module.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nid=<string>\nname=<string>\nversion=<string>\nversionCode=<int>\nauthor=<string>\ndescription=<string>\n```\n\n----------------------------------------\n\nTITLE: Flashing boot.img using fastboot in shell\nDESCRIPTION: Command to flash the KernelSU boot image to the boot partition of the device using fastboot. This should be executed after entering fastboot mode and selecting the correct boot image for your kernel version.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/id_ID/guide/installation.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nfastboot flash boot boot.img\n```\n\n----------------------------------------\n\nTITLE: Enter/Exit Fullscreen - JavaScript\nDESCRIPTION: This JavaScript snippet uses the `fullScreen` function, which is part of the 'kernelsu' library, to control the fullscreen state of a WebView. It takes a boolean argument to toggle the fullscreen mode on or off.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/js/README.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fullScreen } from 'kernelsu';\nfullScreen(true);\n```\n\n----------------------------------------\n\nTITLE: Unpacking Boot Image with Magiskboot\nDESCRIPTION: This command unpacks a boot image using magiskboot. It requires the `magiskboot` binary and the `boot.img` file. The unpacked kernel file represents the original kernel.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_18\n\nLANGUAGE: Shell\nCODE:\n```\n./magiskboot unpack boot.img\n```\n\n----------------------------------------\n\nTITLE: Executing Shell in Global Mount Namespace\nDESCRIPTION: This command allows you to obtain a shell within the global mount namespace.  It utilizes `nsenter` with target process ID 1 and the mount namespace option to enter the global mount namespace.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/vi_VN/guide/faq.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnsenter -t 1 -m sh\n```\n\n----------------------------------------\n\nTITLE: GKI Mode benefits\nDESCRIPTION: The document describes the advantages of GKI mode. It offers broad compatibility across various devices and bypasses dependencies on official firmware updates as long as the KMI matches.\nSOURCE: https://github.com/tiann/kernelsu/blob/main/website/docs/ja_JP/guide/installation.md#_snippet_7\n\n"
  }
]