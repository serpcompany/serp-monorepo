[
  {
    "owner": "cometbft",
    "repo": "cometbft",
    "content": "TITLE: Installing CometBFT in Go\nDESCRIPTION: Command to install the CometBFT binary using Go's package manager.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo install github.com/cometbft/cometbft/cmd/cometbft@v1.0\n```\n\n----------------------------------------\n\nTITLE: ABCI 2.0 Consensus Methods Documentation\nDESCRIPTION: Detailed documentation of the core consensus methods in ABCI 2.0 including InitChain, PrepareProposal, ProcessProposal, ExtendVote, VerifyVoteExtension, FinalizeBlock, and Commit. Each method description includes its purpose, execution context, and determinism requirements.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_basic_concepts.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- InitChain: Initializes the blockchain on genesis\n- PrepareProposal: Allows block proposer to perform application-dependent work\n- ProcessProposal: Enables validators to perform application-dependent block validation\n- ExtendVote: Allows validators to attach additional data to precommit messages\n- VerifyVoteExtension: Validates vote extension data\n- FinalizeBlock: Delivers decided blocks to the Application\n- Commit: Persists application state\n```\n\n----------------------------------------\n\nTITLE: Initializing and starting CometBFT node\nDESCRIPTION: Commands to initialize and start a CometBFT node for a new blockchain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncometbft init\ncometbft node\n```\n\n----------------------------------------\n\nTITLE: Resetting CometBFT Blockchain\nDESCRIPTION: Command to reset the CometBFT blockchain, removing all data and resetting validator files.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncometbft unsafe_reset_all\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Method in ABCI Application\nDESCRIPTION: Implementation of the Query method for the KVStoreApplication that retrieves data from a Badger database. It handles requests to read information and returns appropriate responses based on whether the key exists.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) Query(_ context.Context, req *abcitypes.QueryRequest) (*abcitypes.QueryResponse, error) {\n    resp := abcitypes.QueryResponse{Key: req.Data}\n\n    dbErr := app.db.View(func(txn *badger.Txn) error {\n        item, err := txn.Get(req.Data)\n        if err != nil {\n            if !errors.Is(err, badger.ErrKeyNotFound) {\n                return err\n            }\n            resp.Log = \"key does not exist\"\n            return nil\n        }\n\n        return item.Value(func(val []byte) error {\n            resp.Log = \"exists\"\n            resp.Value = val\n            return nil\n        })\n    })\n    if dbErr != nil {\n        log.Panicf(\"Error reading database, unable to execute query: %v\", dbErr)\n    }\n    return &resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Genesis File for CometBFT Network in JSON\nDESCRIPTION: This snippet demonstrates the structure and content of a genesis.json file for a CometBFT network. It includes network parameters, consensus settings, and initial validator configuration. The file is crucial for network initialization and must be identical across all nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/genesis.json.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"genesis_time\": \"2024-03-01T20:22:57.532998Z\",\n  \"chain_id\": \"test-chain-HfdKnD\",\n  \"initial_height\": \"0\",\n  \"consensus_params\": {\n    \"block\": {\n      \"max_bytes\": \"4194304\",\n      \"max_gas\": \"10000000\"\n    },\n    \"evidence\": {\n      \"max_age_num_blocks\": \"100000\",\n      \"max_age_duration\": \"172800000000000\",\n      \"max_bytes\": \"1048576\"\n    },\n    \"validator\": {\n      \"pub_key_types\": [\n        \"ed25519\"\n      ]\n    },\n    \"version\": {\n      \"app\": \"0\"\n    },\n    \"feature\": {\n      \"vote_extensions_enable_height\": \"1\"\n      \"pbts_enable_height\": \"1\"\n    }\n  },\n  \"validators\": [\n    {\n      \"address\": \"E74FBE24164CFC4F88E311C3AC92E63D0DC310D8\",\n      \"pub_key\": {\n        \"type\": \"tendermint/PubKeyEd25519\",\n        \"value\": \"UjxDQgVTlHJOZ7axpMl/iczMIJXiQpFxCFjwKGvzYqE=\"\n      },\n      \"power\": \"10\",\n      \"name\": \"\"\n    }\n  ],\n  \"app_hash\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: FinalizeBlock Request Parameters Schema\nDESCRIPTION: Protobuf message structure defining the request parameters for the FinalizeBlock method, including transaction list, commit info, misbehavior reports, and block metadata.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_9\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage FinalizeBlockRequest {\n  repeated bytes txs = 1;\n  CommitInfo decided_last_commit = 2;\n  repeated Misbehavior misbehavior = 3;\n  bytes hash = 4;\n  int64 height = 5;\n  google.protobuf.Timestamp time = 6;\n  bytes next_validators_hash = 7;\n  bytes proposer_address = 8;\n  int64 syncing_to_height = 9;\n}\n```\n\n----------------------------------------\n\nTITLE: FinalizeBlock Response Schema\nDESCRIPTION: Protobuf message structure defining the response parameters for the FinalizeBlock method, including events, transaction results, validator updates, and application state hash.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage FinalizeBlockResponse {\n  repeated Event events = 1;\n  repeated ExecTxResult tx_results = 2;\n  repeated ValidatorUpdate validator_updates = 3;\n  ConsensusParams consensus_param_updates = 4;\n  bytes app_hash = 5;\n  google.protobuf.Duration next_block_delay = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Transactions in CheckTx Method\nDESCRIPTION: The code defines a method to validate transactions in the form 'key=value'. It checks the format using the `isValid` helper function and integrates this validation into the `CheckTx` method. It expects transactions to be valid format strings, returning a validation code indicating success or failure.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) isValid(tx []byte) uint32 {\n    // check format\n    parts := bytes.Split(tx, []byte(\"=\"))\n    if len(parts) != 2 {\n        return 1\n    }\n\n    return 0\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) CheckTx(_ context.Context, check *abcitypes.CheckTxRequest) (*abcitypes.CheckTxResponse, error) {\n    code := app.isValid(check.Tx)\n    return &abcitypes.CheckTxResponse{Code: code}, nil\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nimport(\n    \"bytes\"\n    \"context\"\n    abcitypes \"github.com/cometbft/cometbft/abci/types\"\n    \"github.com/dgraph-io/badger/v4\"\n)\n```\n\n----------------------------------------\n\nTITLE: Processing Transactions and Finalizing Block in CometBFT Forum App (Go)\nDESCRIPTION: Implements the FinalizeBlock method to process ban transactions and messages, update the application state, and prepare the response. It handles user banning, message appending, and chat history updates.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nerr = json.Unmarshal(tx, &banTx)\nif err != nil {\n\t// since we did this in ProcessProposal this should never happen here\n\treturn nil, err\n}\nerr = UpdateOrSetUser(app.state.DB, banTx.UserName, true, app.onGoingBlock)\nif err != nil {\n\treturn nil, err\n}\nrespTxs[i] = &abci.ExecTxResult{Code: CodeTypeOK}\n}\n\nfor idx, tx := range req.Txs[finishedBanTxIdx:] {\n\t// From this point on, there should be no BanTxs anymore\n\t// If there is one, ParseMessage will return an error as the\n\t// format of the two transactions is different.\n\tmsg, err := model.ParseMessage(tx)\n\ti := idx + finishedBanTxIdx\n\tif err != nil {\n\t\t// since we did this in ProcessProposal this should never happen here\n\t\treturn nil, err\n\t}\n\n\t// Check if this sender already existed; if not, add the user too\n\terr = UpdateOrSetUser(app.state.DB, msg.Sender, false, app.onGoingBlock)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Add the message for this sender\n\tmessage, err := model.AppendToExistingMessages(app.state.DB, *msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = app.onGoingBlock.Set([]byte(msg.Sender+\"msg\"), []byte(message))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchatHistory, err := model.AppendToChat(app.state.DB, *msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Append messages to chat history\n\terr = app.onGoingBlock.Set([]byte(\"history\"), []byte(chatHistory))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// This adds the user to the DB, but the data is not committed nor persisted until Commit is called\n\trespTxs[i] = &abci.ExecTxResult{Code: abci.CodeTypeOK}\n\tapp.state.Size++\n}\napp.state.Height = req.Height\n\nresponse := &abci.FinalizeBlockResponse{TxResults: respTxs, AppHash: app.state.Hash()}\nreturn response, nil\n```\n\n----------------------------------------\n\nTITLE: Starting the KVStore ABCI application\nDESCRIPTION: Command to start the KVStore example application using ABCI CLI.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nabci-cli kvstore\n```\n\n----------------------------------------\n\nTITLE: Implementing the Query ABCI Method in Go for KVStore Application\nDESCRIPTION: Implements the `Query` method for the `KVStoreApplication`. It handles client requests to read data from the BadgerDB key-value store. The method takes a query request, attempts to retrieve the value associated with the requested key from the database within a read-only transaction, and returns the value and a log message indicating existence or absence. Errors during database access, other than key-not-found, cause a panic. It only reads committed data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) Query(_ context.Context, req *abcitypes.QueryRequest) (*abcitypes.QueryResponse, error) {\n    resp := abcitypes.QueryResponse{Key: req.Data}\n\n    dbErr := app.db.View(func(txn *badger.Txn) error {\n        item, err := txn.Get(req.Data)\n        if err != nil {\n            if !errors.Is(err, badger.ErrKeyNotFound) {\n                return err\n            }\n            resp.Log = \"key does not exist\"\n            return nil\n        }\n\n        return item.Value(func(val []byte) error {\n            resp.Log = \"exists\"\n            resp.Value = val\n            return nil\n        })\n    })\n    if dbErr != nil {\n        log.Panicf(\"Error reading database, unable to execute query: %v\", dbErr)\n    }\n    return &resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Running CometBFT Light Client Proxy Server in Bash\nDESCRIPTION: This snippet shows how to start the CometBFT light client proxy server using the 'cometbft light' command. It specifies the chain ID, primary node, witness nodes, and trusted header information. The light client verifies CometBFT RPC calls before passing them to the caller.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/light-client.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cometbft light supernova -p tcp://233.123.0.140:26657 \\\n  -w tcp://179.63.29.15:26657,tcp://144.165.223.135:26657 \\\n  --height=10 --hash=37E9A6DD3FA25E83B22C18835401E8E56088D0D7ABC6FD99FCDC920DD76C1C57\n```\n\n----------------------------------------\n\nTITLE: Installing CometBFT and ABCI CLI\nDESCRIPTION: Commands to install CometBFT and the ABCI CLI tool using Go.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/cometbft/cometbft\ncd $GOPATH/src/github.com/cometbft/cometbft\nmake install_abci\n```\n\n----------------------------------------\n\nTITLE: Block Finalization and Transaction Processing with BadgerDB in Go\nDESCRIPTION: This snippet describes how to process transactions using the `FinalizeBlock` method, which executes state updates within a Badger transaction. It checks transaction validity and updates the key-value store, logging execution results. Badger transactions must remain uncommitted until the `Commit` method executes. Key parts are validating transactions, executing them, and recording the results along with events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) FinalizeBlock(_ context.Context, req *abcitypes.FinalizeBlockRequest) (*abcitypes.FinalizeBlockResponse, error) {\n    var txs = make([]*abcitypes.ExecTxResult, len(req.Txs))\n\n    app.onGoingBlock = app.db.NewTransaction(true)\n    for i, tx := range req.Txs {\n        if code := app.isValid(tx); code != 0 {\n            log.Printf(\"Error: invalid transaction index %v\", i)\n            txs[i] = &abcitypes.ExecTxResult{Code: code}\n        } else {\n            parts := bytes.SplitN(tx, []byte(\"=\"), 2)\n            key, value := parts[0], parts[1]\n            log.Printf(\"Adding key %s with value %s\", key, value)\n\n            if err := app.onGoingBlock.Set(key, value); err != nil {\n                log.Panicf(\"Error writing to database, unable to execute tx: %v\", err)\n            }\n\n            log.Printf(\"Successfully added key %s with value %s\", key, value)\n\n            // Add an event for the transaction execution.\n            // Multiple events can be emitted for a transaction, but we are adding only one event\n            txs[i] = &abcitypes.ExecTxResult{\n                Code: 0,\n                Events: []abcitypes.Event{\n                    {\n                        Type: \"app\",\n                        Attributes: []abcitypes.EventAttribute{\n                            {Key: \"key\", Value: string(key), Index: true},\n                            {Key: \"value\", Value: string(value), Index: true},\n                        },\n                    },\n                },\n            }\n        }\n    }\n\n    return &abcitypes.FinalizeBlockResponse{\n      TxResults:        txs,\n      NextBlockDelay:   1 * time.Second,\n    }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a CometBFT Node Instance in Go\nDESCRIPTION: Shows the instantiation of a CometBFT node using `nm.NewNode`. It requires various components: a context, the loaded configuration, the private validator, the node key, a proxy client creator for the application (using `proxy.NewLocalClientCreator` for in-process communication), a genesis document provider, a database provider, a metrics provider, and a logger. Errors during node creation are handled with `log.Fatalf`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nnode, err := nm.NewNode(\n    context.Background(),\n    config,\n    pv,\n    nodeKey,\n    proxy.NewLocalClientCreator(app),\n    nm.DefaultGenesisDocProviderFunc(config),\n    cfg.DefaultDBProvider,\n    nm.DefaultMetricsProvider(config.Instrumentation),\n    logger)\n\nif err != nil {\n    log.Fatalf(\"Creating node: %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Database Layer Implementation with BadgerDB in Go\nDESCRIPTION: Complete implementation of database operations using BadgerDB. Includes user management (create, find, update), validator handling, and basic key-value operations. Uses badger/v4 for persistent storage and supports JSON serialization for user data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/5.model.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage model\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/dgraph-io/badger/v4\"\n\n\t\"github.com/cometbft/cometbft/abci/types\"\n)\n\ntype DB struct {\n\tdb *badger.DB\n}\n\nfunc (db *DB) Init(database *badger.DB) {\n\tdb.db = database\n}\n\nfunc (db *DB) Commit() error {\n\treturn db.db.Update(func(txn *badger.Txn) error {\n\t\treturn txn.Commit()\n\t})\n}\n\nfunc NewDB(dbPath string) (*DB, error) {\n\t// Open badger DB\n\topts := badger.DefaultOptions(dbPath)\n\tdb, err := badger.Open(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new DB instance and initialize with badger DB\n\tdbInstance := &DB{}\n\tdbInstance.Init(db)\n\n\treturn dbInstance, nil\n}\n\nfunc (db *DB) GetDB() *badger.DB {\n\treturn db.db\n}\n\nfunc (db *DB) Size() int64 {\n\tlsm, vlog := db.GetDB().Size()\n\treturn lsm + vlog\n}\n\nfunc (db *DB) CreateUser(user *User) error {\n\t// Check if the user already exists\n\terr := db.db.View(func(txn *badger.Txn) error {\n\t\t_, err := txn.Get([]byte(user.Name))\n\t\treturn err\n\t})\n\tif err == nil {\n\t\treturn errors.New(\"user already exists\")\n\t}\n\n\t// Save the user to the database\n\terr = db.db.Update(func(txn *badger.Txn) error {\n\t\tuserBytes, err := json.Marshal(user)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal user to JSON: %w\", err)\n\t\t}\n\t\terr = txn.Set([]byte(user.Name), userBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\nfunc (db *DB) FindUserByName(name string) (*User, error) {\n\t// Read the user from the database\n\tvar user *User\n\terr := db.db.View(func(txn *badger.Txn) error {\n\t\titem, err := txn.Get([]byte(name))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = item.Value(func(val []byte) error {\n\t\t\treturn json.Unmarshal(val, &user)\n\t\t})\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error in retrieving user: %w\", err)\n\t}\n\treturn user, nil\n}\n\nfunc (db *DB) UpdateOrSetUser(uname string, toBan bool, txn *badger.Txn) error {\n\tuser, err := db.FindUserByName(uname)\n\t// If user is not in the db, then add it\n\tif errors.Is(err, badger.ErrKeyNotFound) {\n\t\tu := new(User)\n\t\tu.Name = uname\n\t\tu.Banned = toBan\n\t\tuser = u\n\t} else {\n\t\tif err != nil {\n\t\t\treturn errors.New(\"not able to process user\")\n\t\t}\n\t\tuser.Banned = toBan\n\t}\n\tuserBytes, err := json.Marshal(user)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshaling user: %w\", err)\n\t}\n\treturn txn.Set([]byte(user.Name), userBytes)\n}\n\nfunc (db *DB) Set(key, value []byte) error {\n\treturn db.db.Update(func(txn *badger.Txn) error {\n\t\treturn txn.Set(key, value)\n\t})\n}\n\nfunc ViewDB(db *badger.DB, key []byte) ([]byte, error) {\n\tvar value []byte\n\terr := db.View(func(txn *badger.Txn) error {\n\t\titem, err := txn.Get(key)\n\t\tif err != nil {\n\t\t\tif !errors.Is(err, badger.ErrKeyNotFound) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tvalue, err = item.ValueCopy(nil)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn value, nil\n}\n\nfunc (db *DB) Close() error {\n\treturn db.db.Close()\n}\n\nfunc (db *DB) Get(key []byte) ([]byte, error) {\n\treturn ViewDB(db.db, key)\n}\n\nfunc (db *DB) GetValidators() (validators []types.ValidatorUpdate, err error) {\n\terr = db.db.View(func(txn *badger.Txn) error {\n\t\topts := badger.DefaultIteratorOptions\n\t\topts.PrefetchSize = 10\n\t\tit := txn.NewIterator(opts)\n\t\tdefer it.Close()\n\t\tfor it.Rewind(); it.Valid(); it.Next() {\n\t\t\tvar err error\n\t\t\titem := it.Item()\n\t\t\tk := item.Key()\n\t\t\tif isValidatorTx(k) {\n\t\t\t\terr := item.Value(func(v []byte) error {\n\t\t\t\t\tvalidator := new(types.ValidatorUpdate)\n\t\t\t\t\terr = types.ReadMessage(bytes.NewBuffer(v), validator)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tvalidators = append(validators, *validator)\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn validators, nil\n}\n\nfunc isValidatorTx(tx []byte) bool {\n\treturn bytes.HasPrefix(tx, []byte(\"val\"))\n}\n```\n\n----------------------------------------\n\nTITLE: State Machine Flow Diagram for Byzantine Consensus Protocol (Markdown)\nDESCRIPTION: This Markdown snippet employs an ASCII-art diagram to demonstrate all primary states, transitions, and conditions in the consensus algorithm's state machine. It specifies paths, timeouts, and triggering events for state changes such as moving from Precommit to Commit or handling timeouts. The diagram is designed for explanatory purposes in documentation and offers a holistic view of protocol state advancement, but being Markdown, it's inherently static and non-interactive. Required context is the surrounding architectural description of the consensus rounds. Inputs and outputs are conceptual: protocol steps and their organization. Constraints are graphical abstraction and the need for reader familiarity with state machine notation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/consensus.md#2025-04-22_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n                         +-------------------------------------+\n                         v                                     |(Wait til `CommitTime+timeoutCommit`)\n                   +-----------+                         +-----+-----+\n      +----------> |  Propose  +--------------+          | NewHeight |\n      |            +-----------+              |          +-----------+\n      |                                       |                ^\n      |(Else, after timeoutPrecommit)         v                |\n+-----+-----+                           +-----------+          |\n| Precommit |  <------------------------+  Prevote  |          |\n+-----+-----+                           +-----------+          |\n      |(When +2/3 Precommits for block found)                  |\n      v                                                        |\n+--------------------------------------------------------------------+\n|  Commit                                                            |\n|                                                                    |\n|  * Set CommitTime = now;                                           |\n|  * Wait for block, then stage/save/commit block;                   |\n+--------------------------------------------------------------------+\n```\n\n----------------------------------------\n\nTITLE: Implementing ProcessProposal Method in ABCI Application\nDESCRIPTION: Implementation of the ProcessProposal method that validates proposed blocks before voting to accept them. This implementation simply accepts all proposals without additional validation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) ProcessProposal(_ context.Context, proposal *abcitypes.ProcessProposalRequest) (*abcitypes.ProcessProposalResponse, error) {\n    return &abcitypes.ProcessProposalResponse{Status: abcitypes.PROCESS_PROPOSAL_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Starting a CometBFT Node and KVStore Application In-Process in Go\nDESCRIPTION: Provides the complete `main` function for running the KVStore application and a CometBFT node together. It handles command-line flag parsing for the home directory, loads CometBFT configuration using Viper, initializes a BadgerDB database, creates the KVStore application instance, loads validator and node keys, sets up logging, creates and starts the CometBFT node using `nm.NewNode` with a local proxy client, and manages graceful shutdown on SIGTERM/SIGINT signals.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"github.com/cometbft/cometbft/p2p\"\n    \"github.com/cometbft/cometbft/privval\"\n    \"github.com/cometbft/cometbft/proxy\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"path/filepath\"\n    \"syscall\"\n\n    \"github.com/dgraph-io/badger/v4\"\n    \"github.com/spf13/viper\"\n    cfg \"github.com/cometbft/cometbft/config\"\n    cmtflags \"github.com/cometbft/cometbft/libs/cli/flags\"\n    cmtlog \"github.com/cometbft/cometbft/libs/log\"\n    nm \"github.com/cometbft/cometbft/node\"\n)\n\nvar homeDir string\n\nfunc init() {\n    flag.StringVar(&homeDir, \"cmt-home\", \"\", \"Path to the CometBFT config directory (if empty, uses $HOME/.cometbft)\")\n}\n\nfunc main() {\n    flag.Parse()\n    if homeDir == \"\" {\n        homeDir = os.ExpandEnv(\"$HOME/.cometbft\")\n    }\n\n    config := cfg.DefaultConfig()\n    config.SetRoot(homeDir)\n    viper.SetConfigFile(fmt.Sprintf(\"%s/%s\", homeDir, \"config/config.toml\"))\n\n    if err := viper.ReadInConfig(); err != nil {\n        log.Fatalf(\"Reading config: %v\", err)\n    }\n    if err := viper.Unmarshal(config); err != nil {\n        log.Fatalf(\"Decoding config: %v\", err)\n    }\n    if err := config.ValidateBasic(); err != nil {\n        log.Fatalf(\"Invalid configuration data: %v\", err)\n    }\n    dbPath := filepath.Join(homeDir, \"badger\")\n    db, err := badger.Open(badger.DefaultOptions(dbPath))\n\n    if err != nil {\n        log.Fatalf(\"Opening database: %v\", err)\n    }\n    defer func() {\n        if err := db.Close(); err != nil {\n            log.Printf(\"Closing database: %v\", err)\n        }\n    }()\n\n    app := NewKVStoreApplication(db)\n\n    pv := privval.LoadFilePV(\n        config.PrivValidatorKeyFile(),\n        config.PrivValidatorStateFile(),\n    )\n\n    nodeKey, err := nodekey.LoadNodeKey(config.NodeKeyFile()) // Assuming nodekey is imported or part of p2p perhaps\n    if err != nil {\n        log.Fatalf(\"failed to load node's key: %v\", err)\n    }\n\n    logger := cmtlog.NewLogger(os.Stdout)\n    logger, err = cmtflags.ParseLogLevel(config.LogLevel, logger, cfg.DefaultLogLevel)\n\n    if err != nil {\n        log.Fatalf(\"failed to parse log level: %v\", err)\n    }\n\n    node, err := nm.NewNode(\n        context.Background(),\n        config,\n        pv,\n        nodeKey,\n        proxy.NewLocalClientCreator(app),\n        nm.DefaultGenesisDocProviderFunc(config),\n        cfg.DefaultDBProvider,\n        nm.DefaultMetricsProvider(config.Instrumentation),\n        logger,\n    )\n\n    if err != nil {\n        log.Fatalf(\"Creating node: %v\", err)\n    }\n\n    node.Start()\n    defer func() {\n        node.Stop()\n        node.Wait()\n    }()\n\n    c := make(chan os.Signal, 1)\n    signal.Notify(c, os.Interrupt, syscall.SIGTERM)\n    <-c\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Proof of Fork to Satisfy IBC Requirements - Go\nDESCRIPTION: Specifies a function to extend a provided proof of fork (PoF) further in block history to ensure it aligns with the IBC component's known state. The function constructs a new PoF with a revised trusted root and composite traces combining the connector (meeting point) prefix and both PoF's original traces. Inputs include the new root, connector, light store, and the existing PoF structure. Requires LightBlock and consensus trace management, as well as a trusted chain of block history.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc extendPoF (root LightBlock,\n                connector LightBlock,\n    lightStore LightStore,\n    Pof LightNodeProofofFork) (LightNodeProofofFork}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI Interface for KVStore Application\nDESCRIPTION: Go code implementing the ABCI interface methods for a basic key-value store application using CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    abcitypes \"github.com/cometbft/cometbft/abci/types\"\n    \"context\"\n)\n\ntype KVStoreApplication struct{}\n\nvar _ abcitypes.Application = (*KVStoreApplication)(nil)\n\nfunc NewKVStoreApplication() *KVStoreApplication {\n    return &KVStoreApplication{}\n}\n\nfunc (app *KVStoreApplication) Info(_ context.Context, info *abcitypes.InfoRequest) (*abcitypes.InfoResponse, error) {\n    return &abcitypes.InfoResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) Query(_ context.Context, req *abcitypes.QueryRequest) (*abcitypes.QueryResponse, error) {\n    return &abcitypes.QueryResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) CheckTx(_ context.Context, check *abcitypes.CheckTxRequest) (*abcitypes.CheckTxResponse, error) {\n    return &abcitypes.CheckTxResponse{Code: 0}, nil\n}\n\nfunc (app *KVStoreApplication) InitChain(_ context.Context, chain *abcitypes.InitChainRequest) (*abcitypes.InitChainResponse, error) {\n    return &abcitypes.InitChainResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) PrepareProposal(_ context.Context, proposal *abcitypes.PrepareProposalRequest) (*abcitypes.PrepareProposalResponse, error) {\n    return &abcitypes.PrepareProposalResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ProcessProposal(_ context.Context, proposal *abcitypes.ProcessProposalRequest) (*abcitypes.ProcessProposalResponse, error) {\n    return &abcitypes.ProcessProposalResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) FinalizeBlock(_ context.Context, req *abcitypes.FinalizeBlockRequest) (*abcitypes.FinalizeBlockResponse, error) {\n    return &abcitypes.FinalizeBlockResponse{}, nil\n}\n\nfunc (app KVStoreApplication) Commit(_ context.Context, commit *abcitypes.CommitRequest) (*abcitypes.CommitResponse, error) {\n    return &abcitypes.CommitResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ListSnapshots(_ context.Context, snapshots *abcitypes.ListSnapshotsRequest) (*abcitypes.ListSnapshotsResponse, error) {\n    return &abcitypes.ListSnapshotsResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) OfferSnapshot(_ context.Context, snapshot *abcitypes.OfferSnapshotRequest) (*abcitypes.OfferSnapshotResponse, error) {\n    return &abcitypes.OfferSnapshotResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) LoadSnapshotChunk(_ context.Context, chunk *abcitypes.LoadSnapshotChunkRequest) (*abcitypes.LoadSnapshotChunkResponse, error) {\n    return &abcitypes.LoadSnapshotChunkResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ApplySnapshotChunk(_ context.Context, chunk *abcitypes.ApplySnapshotChunkRequest) (*abcitypes.ApplySnapshotChunkResponse, error) {\n\treturn &abcitypes.ApplySnapshotChunkResponse{Result: abcitypes.APPLY_SNAPSHOT_CHUNK_RESULT_ACCEPT}, nil\n}\n\nfunc (app KVStoreApplication) ExtendVote(_ context.Context, extend *abcitypes.ExtendVoteRequest) (*abcitypes.ExtendVoteResponse, error) {\n    return &abcitypes.ExtendVoteResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) VerifyVoteExtension(_ context.Context, verify *abcitypes.VerifyVoteExtensionRequest) (*abcitypes.VerifyVoteExtensionResponse, error) {\n    return &abcitypes.VerifyVoteExtensionResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing the CometBFT Contribution Workflow with Mermaid Diagram\nDESCRIPTION: A flowchart diagram illustrating the decision process and workflow for contributing to CometBFT. It shows different paths based on problem complexity, from issue creation through RFCs, ADRs, and pull requests to final merge.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nflowchart LR\n    complexity{Problem\\ncomplexity}\n    issue(\"New issue\\n(Problem articulation\\nfor discussion)\")\n    clarity{\"Problem +\\nsolution clarity\"}\n    rfc(\"RFC pull request(s)\")\n    rfc_merge(\"Merge RFC to main\")\n    risk{\"Solution\\ncomplexity/risk\"}\n    adr(\"ADR + PoC\\npull request(s)\")\n    adr_merge(\"Merge ADR to main\\nand create tracking issue\")\n    pr(\"Solution\\npull request(s)\")\n    merge(\"Merge to main/backport\\nor feature branch\")\n\n    complexity --\"Low/Moderate/High\"--> issue\n    complexity --Trivial--> pr\n    issue --> clarity\n    clarity --High--> risk\n    clarity --Low--> rfc\n    rfc --Approved--> rfc_merge\n    risk --\"Moderate/High\"--> adr\n    adr --\"ADR accepted by core team\"--> adr_merge\n    adr_merge --> pr\n    risk --Low--> pr\n    pr --Approved--> merge\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing PrepareProposal Method in ABCI Application\nDESCRIPTION: Implementation of the PrepareProposal method that allows the application to modify transaction groups before they are included in blocks. This implementation simply returns the unmodified group of transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) PrepareProposal(_ context.Context, proposal *abcitypes.PrepareProposalRequest) (*abcitypes.PrepareProposalResponse, error) {\n    return &abcitypes.PrepareProposalResponse{Txs: proposal.Txs}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Commit Data Response Format in CometBFT API\nDESCRIPTION: Example response structure for the commit endpoint showing the signed header with block details, validator signatures, and canonical status. Contains metadata about the block and cryptographic signatures from validators.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"signed_header\": {\n      \"header\": {\n        \"version\": {\n          \"block\": \"10\",\n          \"app\": \"0\"\n        },\n        \"chain_id\": \"cosmoshub-2\",\n        \"height\": \"12\",\n        \"time\": \"2019-04-22T17:01:51.701356223Z\",\n        \"last_block_id\": {\n          \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n          \"parts\": {\n            \"total\": 1,\n            \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n          }\n        },\n        \"last_commit_hash\": \"21B9BC845AD2CB2C4193CDD17BFC506F1EBE5A7402E84AD96E64171287A34812\",\n        \"data_hash\": \"970886F99E77ED0D60DA8FCE0447C2676E59F2F77302B0C4AA10E1D02F18EF73\",\n        \"validators_hash\": \"D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0\",\n        \"next_validators_hash\": \"D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0\",\n        \"consensus_hash\": \"0F2908883A105C793B74495EB7D6DF2EEA479ED7FC9349206A65CB0F9987A0B8\",\n        \"app_hash\": \"223BF64D4A01074DC523A80E76B9BBC786C791FB0A1893AC5B14866356FCFD6C\",\n        \"last_results_hash\": \"\",\n        \"evidence_hash\": \"\",\n        \"proposer_address\": \"D540AB022088612AC74B287D076DBFBC4A377A2E\"\n      },\n      \"commit\": {\n        \"height\": \"1311801\",\n        \"round\": 0,\n        \"block_id\": {\n          \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n          \"parts\": {\n            \"total\": 1,\n            \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n          }\n        },\n        \"signatures\": [\n          {\n            \"block_id_flag\": 2,\n            \"validator_address\": \"000001E443FD237E4B616E2FA69DF4EE3D49A94F\",\n            \"timestamp\": \"2019-04-22T17:01:58.376629719Z\",\n            \"signature\": \"14jaTQXYRt8kbLKEhdHq7AXycrFImiLuZx50uOjs2+Zv+2i7RTG/jnObD07Jo2ubZ8xd7bNBJMqkgtkd0oQHAw==\"\n          }\n        ]\n      }\n    },\n    \"canonical\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ABCI Server Setup and Signal Handling\nDESCRIPTION: Code snippet that initializes and starts the ABCI server using a Unix domain socket. It includes signal handling to gracefully stop the server upon receiving SIGTERM or Ctrl-C.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nserver := abciserver.NewSocketServer(socketAddr, app)\nserver.SetLogger(logger)\n\nif err := server.Start(); err != nil {\n    fmt.Fprintf(os.Stderr, \"error starting socket server: %v\", err)\n    os.Exit(1)\n}\ndefer server.Stop()\n\nc := make(chan os.Signal, 1)\nsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n<-c\n```\n\n----------------------------------------\n\nTITLE: Broadcasting a transaction to CometBFT\nDESCRIPTION: cURL command to send a transaction to the CometBFT node for processing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"abcd\"'\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Node with In-Process Application\nDESCRIPTION: Starts a CometBFT node with a simple key-value store application. The 'kvstore' is non-persistent, while 'persistent_kvstore' offers persistence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --proxy_app=kvstore\n```\n\n----------------------------------------\n\nTITLE: Implementing the PrepareProposal ABCI Method in Go\nDESCRIPTION: Implements the `PrepareProposal` method for the `KVStoreApplication`. This method is called by CometBFT to allow the application to modify a proposed block's transaction list before it's finalized. This specific implementation simply returns the transaction list unmodified, accepting the proposal as is. It receives the proposal request containing transactions and maximum allowed bytes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) PrepareProposal(_ context.Context, proposal *abcitypes.PrepareProposalRequest) (*abcitypes.PrepareProposalResponse, error) {\n    return &abcitypes.PrepareProposalResponse{Txs: proposal.Txs}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: ABCI-CLI Console Interactive Commands\nDESCRIPTION: Example of interactive console commands showing various ABCI operations including prepare_proposal, process_proposal, finalize_block, commit, and query operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/abci-cli.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n> echo hello\n-> code: OK\n-> data: hello\n-> data.hex: 0x68656C6C6F\n\n> info\n-> code: OK\n-> data: {\"size\":0}\n-> data.hex: 0x7B2273697A65223A307D\n\n> prepare_proposal \"abc=123\"\n-> code: OK\n-> log: Succeeded. Tx: abc=123\n\n> process_proposal \"abc==456\"\n-> code: OK\n-> status: PROCESS_PROPOSAL_STATUS_REJECT\n\n> process_proposal \"abc=123\"\n-> code: OK\n-> status: PROCESS_PROPOSAL_STATUS_ACCEPT\n\n> finalize_block \"abc=123\"\n-> code: OK\n-> code: OK\n-> data.hex: 0x0200000000000000\n\n> commit\n-> code: OK\n\n> info\n-> code: OK\n-> data: {\"size\":1}\n-> data.hex: 0x7B2273697A65223A317D\n\n> query \"abc\"\n-> code: OK\n-> log: exists\n-> height: 0\n-> key: abc\n-> key.hex: 616263\n-> value: 123\n-> value.hex: 313233\n\n> finalize_block \"def=xyz\" \"ghi=123\"\n-> code: OK\n-> code: OK\n-> code: OK\n-> data.hex: 0x0600000000000000\n\n> commit\n-> code: OK\n\n> query \"def\"\n-> code: OK\n-> log: exists\n-> height: 0\n-> key: def\n-> key.hex: 646566\n-> value: xyz\n-> value.hex: 78797A\n```\n\n----------------------------------------\n\nTITLE: Implementing Flexible Node Initialization with Service Injection in Go\nDESCRIPTION: Proposed function signature for a new public API that would allow injecting custom service components into a CometBFT node. This would enable users to replace default components without vendoring the entire codebase.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-069-flexible-node-initialization.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc NewWithServices(conf *config.Config,\n\tlogger log.Logger,\n\tcf proxy.ClientCreator,\n\tgen *types.GenesisDoc,\n\tsrvs []service.Service,\n) (service.Service, error) {\n```\n\n----------------------------------------\n\nTITLE: Querying Chat History via CometBFT RPC using curl (Bash)\nDESCRIPTION: This command uses curl to query the application state via the `/abci_query` endpoint using a specific key (`data=\"history\"`). This retrieves the complete chat history maintained by the application, typically returned in the 'log' field of the response.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"history\"'\n```\n\n----------------------------------------\n\nTITLE: Consensus Parameters Response Format in CometBFT API\nDESCRIPTION: Example response structure for the consensus_params endpoint showing block parameters, evidence rules, and validator constraints. These parameters govern the fundamental consensus rules of the blockchain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_24\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"block_height\": \"1\",\n    \"consensus_params\": {\n      \"block\": {\n        \"max_bytes\": \"22020096\",\n        \"max_gas\": \"1000\",\n        \"time_iota_ms\": \"1000\"\n      },\n      \"evidence\": {\n        \"max_age\": \"100000\"\n      },\n      \"validator\": {\n        \"pub_key_types\": [\n          \"ed25519\"\n        ]\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting and Gracefully Stopping the CometBFT Node in Go\nDESCRIPTION: Demonstrates how to start the created CometBFT node using `node.Start()`. It also sets up deferred functions `node.Stop()` and `node.Wait()` to ensure the node is stopped gracefully and the process waits for shutdown completion when the function exits (e.g., upon receiving a termination signal or returning from `main`).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nnode.Start()\ndefer func() {\n    node.Stop()\n    node.Wait()\n}()\n```\n\n----------------------------------------\n\nTITLE: Checking CometBFT Node Status\nDESCRIPTION: Queries the status of the running CometBFT node using the local RPC endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncurl -s localhost:26657/status\n```\n\n----------------------------------------\n\nTITLE: Finalizing Blocks with CometBFT in Go\nDESCRIPTION: The `FinalizeBlock` function finalizes block transactions, updates user status within the application database, appends messages to chat history, and assigns response codes. It processes transactions by differentiating between ban and non-ban types using helpers like `isBanTx` and `model.ParseMessage`. This function depends on a transaction object and database operations, indicating it requires access to certain database APIs and models.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\n// FinalizeBlock Deliver the decided block to the Application.\nfunc (app *ForumApp) FinalizeBlock(_ context.Context, req *abci.FinalizeBlockRequest) (*abci.FinalizeBlockResponse, error) {\n\tapp.logger.Info(\"Executing Application FinalizeBlock\")\n\n\t// Iterate over Tx in current block\n\tapp.onGoingBlock = app.state.DB.GetDB().NewTransaction(true)\n\trespTxs := make([]*abci.ExecTxResult, len(req.Txs))\n\tfinishedBanTxIdx := len(req.Txs)\n\tfor i, tx := range req.Txs {\n\t\tvar err error\n\n\t\tif !isBanTx(tx) {\n\t\t\tfinishedBanTxIdx = i\n\t\t\tbreak\n\t\t}\n\t\tbanTx := new(model.BanTx)\n\t\terr = json.Unmarshal(tx, &banTx)\n\t\tif err != nil {\n\t\t\t// since we did this in ProcessProposal this should never happen here\n\t\t\treturn nil, err\n\t\t}\n\t\terr = UpdateOrSetUser(app.state.DB, banTx.UserName, true, app.onGoingBlock)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trespTxs[i] = &abci.ExecTxResult{Code: CodeTypeOK}\n\t}\n\n\tfor idx, tx := range req.Txs[finishedBanTxIdx:] {\n\t\t// From this point on, there should be no BanTxs anymore\n\t\t// If there is one, ParseMessage will return an error as the\n\t\t// format of the two transactions is different.\n\t\tmsg, err := model.ParseMessage(tx)\n\t\ti := idx + finishedBanTxIdx\n\t\tif err != nil {\n\t\t\t// since we did this in ProcessProposal this should never happen here\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Check if this sender already existed; if not, add the user too\n\t\terr = UpdateOrSetUser(app.state.DB, msg.Sender, false, app.onGoingBlock)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Add the message for this sender\n\t\tmessage, err := model.AppendToExistingMessages(app.state.DB, *msg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = app.onGoingBlock.Set([]byte(msg.Sender+\"msg\"), []byte(message))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tchatHistory, err := model.AppendToChat(app.state.DB, *msg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Append messages to chat history\n\t\terr = app.onGoingBlock.Set([]byte(\"history\"), []byte(chatHistory))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// This adds the user to the DB, but the data is not committed nor persisted until Commit is called\n\t\trespTxs[i] = &abci.ExecTxResult{Code: abci.CodeTypeOK}\n\t\tapp.state.Size++\n\t}\n\tapp.state.Height = req.Height\n\n\tresponse := &abci.FinalizeBlockResponse{TxResults: respTxs, AppHash: app.state.Hash()}\n\treturn response, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Handling OS Interrupt Signals for Graceful Shutdown in Go\nDESCRIPTION: Implements OS signal handling to allow graceful shutdown. It creates a channel to receive `os.Interrupt` and `syscall.SIGTERM` signals. The program blocks (`<-c`) until such a signal is received, allowing the deferred functions (like `node.Stop()`) to execute before the program terminates.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nc := make(chan os.Signal, 1)\nsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n<-c\n```\n\n----------------------------------------\n\nTITLE: Updating Main Function to Create KVStoreApplication\nDESCRIPTION: Modifies the main.go file to create an instance of the KVStoreApplication.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    fmt.Println(\"Hello, CometBFT\")\n\n    _ = NewKVStoreApplication()\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling ABCI Protocol Buffers\nDESCRIPTION: Command to compile the ABCI protobuf files from the root of the CometBFT repository. This generates the necessary code for Protocol Buffer communication between the consensus engine and applications.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/abci/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake protoc_abci\n```\n\n----------------------------------------\n\nTITLE: Defining Merkle Proof Operations\nDESCRIPTION: This code snippet defines the Protobuf message structure for Merkle proof operations in CometBFT. The `ProofOps` message includes a sequence of `ProofOp` messages, where each `ProofOp` specifies a unique type of proof for a key in a Merkle tree. The structure allows for different types of Merkle proofs using a flexible key-value format.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_app_requirements.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ProofOps {\n  repeated ProofOp ops = 1\n}\n\nmessage ProofOp {\n  string type = 1;\n  bytes key   = 2;\n  bytes data  = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI PrepareProposal Method in Go\nDESCRIPTION: Implements the PrepareProposal method of the ABCI interface. It prepares a proposal for the next block, handling curse word filtering and user banning based on vote extensions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) PrepareProposal(_ context.Context, req *abci.PrepareProposalRequest) (*abci.PrepareProposalResponse, error) {\n\tapp.logger.Info(\"Executing Application PrepareProposal\")\n\n\t// Get the curse words from for all vote extensions received at the end of last height.\n\tvoteExtensionCurseWords := app.getWordsFromVe(req.LocalLastCommit.Votes)\n\n\tcurseWords := strings.Split(voteExtensionCurseWords, \"|\")\n\tif hasDuplicateWords(curseWords) {\n\t\treturn nil, errors.New(\"duplicate words found\")\n\t}\n\n\t// Prepare req puts the BanTx first, then adds the other transactions\n\t// ProcessProposal should verify this\n\tproposedTxs := make([][]byte, 0)\n\tfinalProposal := make([][]byte, 0)\n\tbannedUsersString := make(map[string]struct{})\n\tfor _, tx := range req.Txs {\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal tx in PrepareProposal: %w\", err)\n\t\t}\n\t\t// Adding the curse words from vote extensions too\n\t\tif !hasCurseWord(msg.Message, voteExtensionCurseWords) {\n\t\t\tproposedTxs = append(proposedTxs, tx)\n\t\t\tcontinue\n\t\t}\n\t\t// If the message contains curse words then ban the user by\n\t\t// creating a \"ban transaction\" and adding it to the final proposal\n\t\tbanTx := model.BanTx{UserName: msg.Sender}\n\t\tbannedUsersString[msg.Sender] = struct{}{}\n\t\tresultBytes, err := json.Marshal(banTx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the ban tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal ban tx in PrepareProposal: %w\", err)\n\t\t}\n\t\tfinalProposal = append(finalProposal, resultBytes)\n\t}\n\n\t// Need to loop again through the proposed Txs to make sure there is none left by a user that was banned\n\t// after the tx was accepted\n\tfor _, tx := range proposedTxs {\n\t\t// there should be no error here as these are just transactions we have checked and added\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal tx in PrepareProposal: %w\", err)\n\t\t}\n\t\t// If the user is banned then include this transaction in the final proposal\n\t\tif _, ok := bannedUsersString[msg.Sender]; !ok {\n\t\t\tfinalProposal = append(finalProposal, tx)\n\t\t}\n\t}\n\treturn &abci.PrepareProposalResponse{Txs: finalProposal}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing KVStore Application Structure with BadgerDB\nDESCRIPTION: Defines the main application structure with BadgerDB integration and its constructor. Includes necessary imports for BadgerDB and ABCI types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype KVStoreApplication struct {\n    db           *badger.DB\n    onGoingBlock *badger.Txn\n}\n\nvar _ abcitypes.Application = (*KVStoreApplication)(nil)\n\nfunc NewKVStoreApplication(db *badger.DB) *KVStoreApplication {\n    return &KVStoreApplication{db: db}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Light Client Verification Router in Go\nDESCRIPTION: Main routing function that determines which verification strategy to use based on target height. Handles cases for already verified blocks, forward verification to higher heights, and backwards verification to lower heights.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nfunc Main (primary PeerID, lightStore LightStore, targetHeight Height)\n          (LightStore, Result) {\n\n    b1, r1 = lightStore.Get(targetHeight)\n    if r1 = true and b1.State = StateVerified {\n        // block already there\n        return (lightStore, ResultSuccess)\n    }\n\n    if targetHeight > lightStore.LatestVerified.height {\n     // case of Part IV\n        return VerifyToTarget(primary, lightStore, targetHeight)\n    }\n    else {\n        b2, r2 = lightStore.LatestPrevious(targetHeight);\n        if r2 = true {\n            // make auxiliary lightStore auxLS to call VerifyToTarget.\n   // VerifyToTarget uses LatestVerified of the given lightStore\n            // For that we need:\n            // auxLS.LatestVerified = lightStore.LatestPrevious(targetHeight)\n            auxLS.Init;\n            auxLS.Update(b2,StateVerified);\n            if r1 = true {\n                // we need to verify a previously downloaded light block.\n                // we add it to the auxiliary store so that VerifyToTarget\n                // does not download it again\n                auxLS.Update(b1,b1.State);\n            }\n            auxLS, res2 = VerifyToTarget(primary, auxLS, targetHeight)\n            // move all lightblocks from auxLS to lightStore,\n            // maintain state\n   // we do that whether VerifyToTarget was successful or not\n            for i, s range auxLS {\n                lighStore.Update(s,s.State)\n            }\n            return (lightStore, res2)\n        }\n        else {\n            return Backwards(primary, lightStore, targetHeight)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Actor Interface in Go\nDESCRIPTION: Code example showing the basic interface structure for implementing the Actor model in Go. It defines the Actor interface with a Receive method and a Context interface that provides access to the actor system, sender reference, and message content.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-104-actor-model.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Actor interface {\n    // Receive handles every incoming message sent to an actor. It is the sole\n    // method responsible for mutating the state of the actor.\n    Receive(ctx Context)\n}\n\ntype Context interface {\n    // System provides a reference to the primary actor system in which the\n    // actor is running. This allows the actor to spawn and kill other actors,\n    // send messages to other actors, etc.\n    System() ActorSystem\n\n    // Sender provides a reference to the sender of a message, which allows the\n    // receiving actor to send a response if required.\n    Sender() ActorRef\n\n    // Message sent by the sender. Notice the \"any\" type - a common pattern in\n    // Go-based actor frameworks, which effectively results in type erasure.\n    //\n    // It is, of course, possible to implement some degree of compile-time\n    // guarantees using Go generics, but this is still somewhat limited compared\n    // to directly calling methods on a struct.\n    Message() any\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI ProcessProposal Method in Go\nDESCRIPTION: Implements the ProcessProposal method of the ABCI interface. It validates the proposed block and transactions, ensuring proper ordering of ban transactions and checking for banned users.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) ProcessProposal(_ context.Context, req *abci.ProcessProposalRequest) (*abci.ProcessProposalResponse, error) {\n\tapp.logger.Info(\"Executing Application ProcessProposal\")\n\n\tbannedUsers := make(map[string]struct{}, 0)\n\n\tfinishedBanTxIdx := len(req.Txs)\n\tfor i, tx := range req.Txs {\n\t\tif !isBanTx(tx) {\n\t\t\tfinishedBanTxIdx = i\n\t\t\tbreak\n\t\t}\n\t\tvar parsedBan model.BanTx\n\t\terr := json.Unmarshal(tx, &parsedBan)\n\t\tif err != nil {\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, err\n\t\t}\n\t\tbannedUsers[parsedBan.UserName] = struct{}{}\n\t}\n\n\tfor _, tx := range req.Txs[finishedBanTxIdx:] {\n\t\t// From this point on, there should be no BanTxs anymore\n\t\t// If there is one, ParseMessage will return an error as the\n\t\t// format of the two transactions is different.\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, err\n\t\t}\n\t\tif _, ok := bannedUsers[msg.Sender]; ok {\n\t\t\t// sending us a tx from a banned user\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, nil\n\t\t}\n\t}\n\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: StartRound Function Implementation in Go\nDESCRIPTION: Implementation of the StartRound function that handles proposal generation with time monotonicity guarantees. The function ensures proposal times are greater than previous decisions and sets appropriate proposal times for new values.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-algorithm.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunction StartRound(round) {\n   round_p ← round\n   step_p ← propose\n   if proposer(h_p, round_p) = p {\n      if validValue_p != nil {\n         proposal ← validValue_p // proposal.time unchanged\n      } else {\n         wait until now_p > decision_p[h_p-1].time // time monotonicity\n         proposal ← getValue()\n         proposal.time ← now_p // proposal time set to current local time\n      }\n      broadcast ⟨PROPOSAL, h_p, round_p, proposal, validRound_p⟩\n   } else {\n      schedule OnTimeoutPropose(h_p,round_p) to be executed after timeoutPropose(round_p)\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Current ABCI Application Interface in Go\nDESCRIPTION: The current Application interface structure that includes sequential methods for block processing: InitChain, BeginBlock, DeliverTx, EndBlock, and Commit.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-037-deliver-block.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Application interface {\n    // Info and Mempool methods...\n\n    // Consensus Connection\n    InitChain(RequestInitChain) ResponseInitChain    // Initialize blockchain with validators and other info from TendermintCore\n    BeginBlock(RequestBeginBlock) ResponseBeginBlock // Signals the beginning of a block\n    DeliverTx(tx []byte) ResponseDeliverTx           // Deliver a tx for full processing\n    EndBlock(RequestEndBlock) ResponseEndBlock       // Signals the end of a block, returns changes to the validator set\n    Commit() ResponseCommit                          // Commit the state and return the application Merkle root hash\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RequestInitChain Message Structure in Protobuf\nDESCRIPTION: Updates the RequestInitChain message to include more genesis information, including time, chain_id, consensus parameters, validators, and application state bytes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-009-ABCI-design.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestInitChain {\n    int64 time\n    string chain_id\n    ConsensusParams consensus_params\n    repeated Validator validators\n    bytes app_state_bytes\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Node\nDESCRIPTION: Command to initialize the CometBFT root directory, creating a new private key and genesis file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncometbft init\n```\n\n----------------------------------------\n\nTITLE: Building CometBFT Binary\nDESCRIPTION: This command builds the CometBFT binary and places it in the ./build directory of the project.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nmake build\n```\n\n----------------------------------------\n\nTITLE: Implementing gossipRouter Structure in Go\nDESCRIPTION: Defines a gossipRouter structure that keeps track of disabled routes between peers for transaction propagation. Each node maintains a map of source-to-target routes that should not be used for transaction dissemination.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype gossipRouter struct {\n\tmtx cmtsync.RWMutex\n\t// A set of `source -> target` routes that are disabled for disseminating transactions. Source\n\t// and target are node IDs.\n\tdisabledRoutes map[p2p.ID]p2pIDSet\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Symmetric Cryptography Interface in Golang\nDESCRIPTION: Proposed API for a new crypto/encoding/symmetric package that supports algorithm-agnostic encryption and decryption with AEAD ciphers. It includes functions for encryption, decryption, and registering custom AEAD implementations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-013-symmetric-crypto.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\nfunc Encrypt(aead cipher.AEAD, plaintext []byte) (ciphertext []byte, err error)\nfunc Decrypt(key []byte, ciphertext []byte) (plaintext []byte, err error)\nfunc Register(aead cipher.AEAD, algo_name string, NewAead func(key []byte) (cipher.Aead, error)) error\n```\n\n----------------------------------------\n\nTITLE: Verifying Transaction Signature in Go\nDESCRIPTION: Provides a Go function `isValidSignature` that takes a `Transaction` object containing a public key, signature, and message. It uses a hypothetical `crypto.VerifySignature` function from a cryptographic library to check if the signature is valid for the given message and public key.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc isValidSignature(tx Transaction) bool {\n    pubKey := tx.PubKey\n    signature := tx.Signature\n    message := tx.Message\n\n    // Use the cryptographic library to verify the signature\n    return crypto.VerifySignature(pubKey, message, signature)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Block Table in PostgreSQL for CometBFT RPC Companion\nDESCRIPTION: SQL script to create a table for storing Block data in the CometBFT RPC Companion database. The table includes a height field as the primary key and a data field to store the block information as a byte array.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-102-rpc-companion.md#2025-04-22_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n-- TABLE: comet.v1.block\n\nDROP TABLE IF EXISTS comet.v1.block CASCADE;\n\nCREATE TABLE comet.v1.block\n(\n    height  comet.uint64 NOT NULL,\n    data    bytea NOT NULL,\n    CONSTRAINT block_pkey PRIMARY KEY (height)\n);\n```\n\n----------------------------------------\n\nTITLE: Application Request Logging Helper Function\nDESCRIPTION: Implementation of the logABCIRequest function that logs ABCI requests when the ABCIRequestsLoggingEnabled flag is set to true. It uses GetABCIRequestString to convert the request to a string format.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *Application) logABCIRequest(req *abci.Request) error {\n\tif !app.cfg.ABCIRequestsLoggingEnabled {\n\t\treturn nil\n\t}\n\ts, err := GetABCIRequestString(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tapp.logger.Info(s)\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Proposals with CometBFT in Go\nDESCRIPTION: The `ProcessProposal` function processes proposed blocks for the blockchain, validating transactions and identifying banned users via the `isBanTx` function. It ensures banned transactions are rejected and others are accepted, leveraging JSON marshaling for the transaction data. This function requires dependencies like the `context`, `json` packages, and custom models/functions like `abci`, `isBanTx`, and `model.ParseMessage`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n// ProcessProposal validates the proposed block and the transactions and return a status if it was accepted or rejected.\nfunc (app *ForumApp) ProcessProposal(_ context.Context, req *abci.ProcessProposalRequest) (*abci.ProcessProposalResponse, error) {\n\tapp.logger.Info(\"Executing Application ProcessProposal\")\n\n\tbannedUsers := make(map[string]struct{}, 0)\n\n\tfinishedBanTxIdx := len(req.Txs)\n\tfor i, tx := range req.Txs {\n\t\tif !isBanTx(tx) {\n\t\t\tfinishedBanTxIdx = i\n\t\t\tbreak\n\t\t}\n\t\tvar parsedBan model.BanTx\n\t\terr := json.Unmarshal(tx, &parsedBan)\n\t\tif err != nil {\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, err\n\t\t}\n\t\tbannedUsers[parsedBan.UserName] = struct{}{}\n\t}\n\n\tfor _, tx := range req.Txs[finishedBanTxIdx:] {\n\t\t// From this point on, there should be no BanTxs anymore\n\t\t// If there is one, ParseMessage will return an error as the\n\t\t// format of the two transactions is different.\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, err\n\t\t}\n\t\tif _, ok := bannedUsers[msg.Sender]; ok {\n\t\t\t// sending us a tx from a banned user\n\t\t\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_REJECT}, nil\n\t\t}\n\t}\n\treturn &abci.ProcessProposalResponse{Status: abci.PROCESS_PROPOSAL_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NOP Mempool in CometBFT\nDESCRIPTION: TOML configuration for enabling the 'nop' mempool in CometBFT, which disables standard mempool functionality and allows applications to implement alternative transaction dissemination mechanisms.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-111-nop-mempool.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[mempool]\n# The type of mempool for this CometBFT node to use.\n#\n# Valid types of mempools supported by CometBFT:\n# - \"flood\" : clist mempool with flooding gossip protocol (default)\n# - \"nop\"   : nop-mempool (app has implemented an alternative tx dissemination mechanism)\ntype = \"nop\"\n```\n\n----------------------------------------\n\nTITLE: Defining ThresholdMultiSignaturePubKey struct for K of N Multisignatures in Golang\nDESCRIPTION: Implementation of a K of N threshold multisignature public key struct that implements the crypto.Pubkey interface. It contains a threshold K and an array of public keys, with N derived from the length of the pubkeys array.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-019-multisigs.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\ntype ThresholdMultiSignaturePubKey struct { // K of N threshold multisig\n\tK       uint               `json:\"threshold\"`\n\tPubkeys []crypto.Pubkey    `json:\"pubkeys\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExtendVote in Go with CometBFT\nDESCRIPTION: Implementation of ExtendVote method that extends pre-commit votes with curse words as vote extensions. Returns vote extension data stored in app.CurseWords.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/7.vote-extension.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) ExtendVote(_ context.Context, _ *abci.ExtendVoteRequest) (*abci.ExtendVoteResponse, error) {\n\tapp.logger.Info(\"Executing Application ExtendVote\")\n\n\treturn &abci.ExtendVoteResponse{VoteExtension: []byte(app.CurseWords)}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ConsensusParams Structure in Go\nDESCRIPTION: Defines the structure of consensus parameters used in CometBFT. The structure includes BlockSize, TxSize, and BlockGossip parameters that control blockchain capacity limits.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-005-consensus-params.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ConsensusParams struct {\n    BlockSize\n    TxSize\n    BlockGossip\n}\n\ntype BlockSize struct {\n    MaxBytes int\n    MaxTxs int\n    MaxGas int\n}\n\ntype TxSize struct {\n    MaxBytes int\n    MaxGas int\n}\n\ntype BlockGossip struct {\n    BlockPartSizeBytes int\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Light Client Verification Logic in Go\nDESCRIPTION: Presents the Go implementation for the `VerifyToTarget` function, which orchestrates the light client's core verification process. It initializes a `LightStore` with a trusted `root` block, then iteratively fetches (`FetchLightBlock`) and validates (`ValidAndVerified`) light blocks from a `primary` peer until the `targetHeight` is reached or an error occurs. The function updates the `LightStore` based on verification outcomes and uses a `Schedule` function to determine the next height to process. It returns the final `LightStore` (filtered for verified blocks) and a `Result` indicating success or failure.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_16\n\nLANGUAGE: go\nCODE:\n```\nfunc VerifyToTarget(primary PeerID, root LightBlock,\n                    targetHeight Height) (LightStore, Result) {\n\n    lightStore = new LightStore;\n    lightStore.Update(root, StateVerified, root.verifiedBy);\n    nextHeight := targetHeight;\n\n    for lightStore.LatestVerified.height < targetHeight {\n\n        // Get next LightBlock for verification\n        current, found := lightStore.Get(nextHeight)\n        if !found {\n            current = FetchLightBlock(primary, nextHeight)\n            lightStore.Update(current, StateUnverified, nil)\n        }\n\n        // Verify\n        verdict = ValidAndVerified(lightStore.LatestVerified, current)\n\n        // Decide whether/how to continue\n        if verdict == SUCCESS {\n            lightStore.Update(current, StateVerified, lightStore.LatestVerified.Height)\n        }\n        else if verdict == NOT_ENOUGH_TRUST {\n            // do nothing\n            // the light block current passed validation, but the validator\n            // set is too different to verify it. We keep the state of\n            // current at StateUnverified. For a later iteration, Schedule\n            // might decide to try verification of that light block again.\n        }\n        else {\n            // verdict is some error code\n            lightStore.Update(current, StateFailed, nil)\n            return (nil, ResultFailure)\n        }\n        nextHeight = Schedule(lightStore, nextHeight, targetHeight)\n    }\n    return (lightStore.FilterVerified, ResultSuccess)\n}\n```\n\n----------------------------------------\n\nTITLE: Loading CometBFT Configuration with Viper in Go\nDESCRIPTION: Demonstrates using the Viper library to load and validate the CometBFT configuration (`config.toml`) from the specified home directory. It initializes a default configuration, sets the root path, reads the configuration file, unmarshals it into the config struct, and validates the basic configuration settings. Errors during any step lead to a fatal log message.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nconfig := cfg.DefaultValidatorConfig()\n\nconfig.SetRoot(homeDir)\n\nviper.SetConfigFile(fmt.Sprintf(\"%s/%s\", homeDir, \"config/config.toml\"))\nif err := viper.ReadInConfig(); err != nil {\n    log.Fatalf(\"Reading config: %v\", err)\n}\nif err := viper.Unmarshal(config); err != nil {\n    log.Fatalf(\"Decoding config: %v\", err)\n}\nif err := config.ValidateBasic(); err != nil {\n    log.Fatalf(\"Invalid configuration data: %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Single Header and Commit Validation Logic in Go\nDESCRIPTION: Provides the internal Go implementation for `verifySingle` and related validation helpers. `verifySingle` checks an untrusted header against a trusted state, ensuring increasing height/time and validating header/commit consistency using `validateSignedHeaderAndVals`. It verifies commit trust based on `trustThreshold` for non-adjacent headers using `verifyCommitTrusting` and performs full commit verification using `verifyCommitFull`. These functions rely on auxiliary functions like `hash`, `matchingCommit`, `signers`, and `votingPowerIn`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc verifySingle(trustedState TrustedState,\n                  untrustedSh SignedHeader,\n                  untrustedVs ValidatorSet,\n                  untrustedNextVs ValidatorSet,\n                  trustThreshold float) error {\n\n    untrustedHeader = untrustedSh.Header\n    untrustedCommit = untrustedSh.Commit\n\n    trustedHeader = trustedState.SignedHeader.Header\n    trustedVs = trustedState.ValidatorSet\n\n    if trustedHeader.Height >= untrustedHeader.Height return ErrNonIncreasingHeight\n    if trustedHeader.Time >= untrustedHeader.Time return ErrNonIncreasingTime\n\n    // validate the untrusted header against its commit, vals, and next_vals\n    error = validateSignedHeaderAndVals(untrustedSh, untrustedVs, untrustedNextVs)\n    if error != nil return error\n\n    // check for adjacent headers\n    if untrustedHeader.Height == trustedHeader.Height + 1 {\n        if trustedHeader.NextValidatorsHash != untrustedHeader.ValidatorsHash {\n            return ErrInvalidAdjacentHeaders\n        }\n    } else {\n        error = verifyCommitTrusting(trustedVs, untrustedCommit, untrustedVs, trustThreshold)\n        if error != nil return error\n    }\n\n    // verify the untrusted commit\n    return verifyCommitFull(untrustedVs, untrustedCommit)\n}\n\n// returns nil if header and validator sets are consistent; otherwise returns error\nfunc validateSignedHeaderAndVals(signedHeader SignedHeader, vs ValidatorSet, nextVs ValidatorSet) error {\n    header = signedHeader.Header\n    if hash(vs) != header.ValidatorsHash return ErrInvalidValidatorSet\n    if hash(nextVs) != header.NextValidatorsHash return ErrInvalidNextValidatorSet\n    if !matchingCommit(header, signedHeader.Commit) return ErrInvalidCommitValue\n    return nil\n}\n\n// returns nil if at least single correst signer signed the commit; otherwise returns error\nfunc verifyCommitTrusting(trustedVs ValidatorSet,\n                          commit Commit,\n                          untrustedVs ValidatorSet,\n                          trustLevel float) error {\n\n    totalPower := trustedVs.TotalVotingPower\n    signedPower := votingPowerIn(signers(commit, untrustedVs), trustedVs)\n\n    // check that the signers account for more than max(1/3, trustLevel) of the voting power\n    // this ensures that there is at least single correct validator in the set of signers\n    if signedPower < max(1/3, trustLevel) * totalPower return ErrInsufficientVotingPower\n    return nil\n}\n\n// returns nil if commit is signed by more than 2/3 of voting power of the given validator set\n// return error otherwise\nfunc verifyCommitFull(vs ValidatorSet, commit Commit) error {\n    totalPower := vs.TotalVotingPower;\n    signedPower := votingPowerIn(signers(commit, vs), vs)\n\n    // check the signers account for +2/3 of the voting power\n    if signedPower * 3 <= totalPower * 2 return ErrInvalidCommit\n    return nil\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Handling in Go for Forum Application\nDESCRIPTION: This snippet defines Message-related structs and functions for the Forum Application. It includes operations for appending messages, fetching history, and parsing message data. The code interacts with a Badger database for persistence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/5.model.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage model\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/dgraph-io/badger/v4\"\n)\n\ntype BanTx struct {\n\tUserName string `json:\"username\"`\n}\n\n// Message represents a message sent by a user.\ntype Message struct {\n\tSender  string `json:\"sender\"`\n\tMessage string `json:\"message\"`\n}\n\ntype MsgHistory struct {\n\tMsg string `json:\"history\"`\n}\n\nfunc AppendToChat(db *DB, message Message) (string, error) {\n\thistoryBytes, err := db.Get([]byte(\"history\"))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error fetching history: %w\", err)\n\t}\n\tmsgBytes := string(historyBytes)\n\tmsgBytes = msgBytes + \"{sender:\" + message.Sender + \",message:\" + message.Message + \"}\"\n\treturn msgBytes, nil\n}\n\nfunc FetchHistory(db *DB) (string, error) {\n\thistoryBytes, err := db.Get([]byte(\"history\"))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error fetching history: %w\", err)\n\t}\n\tmsgHistory := string(historyBytes)\n\treturn msgHistory, nil\n}\n\nfunc AppendToExistingMessages(db *DB, message Message) (string, error) {\n\texistingMessages, err := GetMessagesBySender(db, message.Sender)\n\tif err != nil && !errors.Is(err, badger.ErrKeyNotFound) {\n\t\treturn \"\", err\n\t}\n\tif errors.Is(err, badger.ErrKeyNotFound) {\n\t\treturn message.Message, nil\n\t}\n\treturn existingMessages + \";\" + message.Message, nil\n}\n\n// GetMessagesBySender retrieves all messages sent by a specific sender\n// Get Message using String.\nfunc GetMessagesBySender(db *DB, sender string) (string, error) {\n\tvar messages string\n\terr := db.db.View(func(txn *badger.Txn) error {\n\t\titem, err := txn.Get([]byte(sender + \"msg\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalue, err := item.ValueCopy(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmessages = string(value)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn messages, nil\n}\n\n// ParseMessage parse messages.\nfunc ParseMessage(tx []byte) (*Message, error) {\n\tmsg := &Message{}\n\n\t// Parse the message into key-value pairs\n\tpairs := strings.Split(string(tx), \",\")\n\n\tif len(pairs) != 2 {\n\t\treturn nil, errors.New(\"invalid number of key-value pairs in message\")\n\t}\n\n\tfor _, pair := range pairs {\n\t\tkv := strings.Split(pair, \":\")\n\n\t\tif len(kv) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid key-value pair in message: %s\", pair)\n\t\t}\n\n\t\tkey := kv[0]\n\t\tvalue := kv[1]\n\n\t\tswitch strings.ToLower(key) {\n\t\tcase \"sender\":\n\t\t\tmsg.Sender = value\n\t\tcase \"message\":\n\t\t\tmsg.Message = value\n\t\tcase \"history\":\n\t\t\treturn nil, fmt.Errorf(\"reserved key name: %s\", key)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown key in message: %s\", key)\n\t\t}\n\t}\n\n\t// Check if the message contains a sender and message\n\tif msg.Sender == \"\" {\n\t\treturn nil, errors.New(\"message is missing sender\")\n\t}\n\tif msg.Message == \"\" {\n\t\treturn nil, errors.New(\"message is missing message\")\n\t}\n\n\treturn msg, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI CheckTx Method in Go\nDESCRIPTION: Implements the CheckTx method of the ABCI interface. It handles validation of inbound transactions, checking for valid message format, existing users, and banned status.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) CheckTx(_ context.Context, req *abci.CheckTxRequest) (*abci.CheckTxResponse, error) {\n\tapp.logger.Info(\"Executing Application CheckTx\")\n\n\t// Parse the tx message\n\tmsg, err := model.ParseMessage(req.Tx)\n\tif err != nil {\n\t\tapp.logger.Info(\"CheckTx: failed to parse transaction message\", \"message\", msg, \"error\", err)\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeInvalidTxFormat, Log: \"Invalid transaction\", Info: err.Error()}, nil\n\t}\n\n\t// Check for invalid sender\n\tif len(msg.Sender) == 0 {\n\t\tapp.logger.Info(\"CheckTx: failed to parse transaction message\", \"message\", msg, \"error\", \"Sender is missing\")\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeInvalidTxFormat, Log: \"Invalid transaction\", Info: \"Sender is missing\"}, nil\n\t}\n\n\tapp.logger.Debug(\"searching for sender\", \"sender\", msg.Sender)\n\tu, err := app.state.DB.FindUserByName(msg.Sender)\n\n\tif err != nil {\n\t\tif !errors.Is(err, badger.ErrKeyNotFound) {\n\t\t\tapp.logger.Error(\"CheckTx: Error in check tx\", \"tx\", string(req.Tx), \"error\", err)\n\t\t\treturn &abci.CheckTxResponse{Code: CodeTypeEncodingError, Log: \"Invalid transaction\", Info: err.Error()}, nil\n\t\t}\n\t\tapp.logger.Info(\"CheckTx: Sender not found\", \"sender\", msg.Sender)\n\t} else if u != nil && u.Banned {\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeBanned, Log: \"Invalid transaction\", Info: \"User is banned\"}, nil\n\t}\n\tapp.logger.Info(\"CheckTx: success checking tx\", \"message\", msg.Message, \"sender\", msg.Sender)\n\treturn &abci.CheckTxResponse{Code: CodeTypeOK, Log: \"Valid transaction\", Info: \"Transaction validation succeeded\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Configuration\nDESCRIPTION: This command initializes the CometBFT configuration files in a specified directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncometbft init --home /tmp/cometbft-home\n```\n\n----------------------------------------\n\nTITLE: Implementing the ProcessProposal ABCI Method in Go\nDESCRIPTION: Implements the `ProcessProposal` method for the `KVStoreApplication`. CometBFT calls this method to let the application validate a received block proposal before voting on it. This implementation unconditionally accepts all proposals by returning `PROCESS_PROPOSAL_STATUS_ACCEPT`. It's a hook for applications to implement custom validation logic against potentially malicious proposals.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) ProcessProposal(_ context.Context, proposal *abcitypes.ProcessProposalRequest) (*abcitypes.ProcessProposalResponse, error) {\n    return &abcitypes.ProcessProposalResponse{Status: abcitypes.PROCESS_PROPOSAL_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Modular Transaction Hashing in Go\nDESCRIPTION: Implementation of a flexible transaction hashing system using global variables to store the hashing function and formatter. It includes methods to set custom hash functions and formatters, along with utility functions for hashing data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-113-modular-transaction-hashing.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto\"\n\t\"hash\"\n\t\"crypto/sha256\"\n)\n\nvar (\n    // Hash function used for transaction hashing.\n    txHash = crypto.SHA256\n\n    // fmtHash is a function that converts a byte slice to a string.\n    fmtHash = func(bz []byte) string {\n        return fmt.Sprintf(\"%X\", bz)\n    }\n)\n\n// SetTxHash sets the hash function used for transaction hashing.\n//\n// Call this function before starting the node. Changing the hashing function\n// after the chain has started can ONLY be done with a hard fork.\nfunc SetTxHash(h crypto.Hash) {\n    txHash = h\n}\n\n// SetFmtHash sets the function used to convert a checksum to a string.\nfunc SetFmtHash(f func([]byte) string) {\n    fmtHash = f\n}\n\n// Bytes is a wrapper around a byte slice that implements the fmt.Stringer.\ntype Bytes []byte\n\nfunc (bz Bytes) String() string {\n    return fmtHash(bz)\n}\n\nfunc (bz Bytes) Bytes() []byte {\n    return bz\n}\n\n// Sum returns the checksum of the data as Bytes.\nfunc Sum(bz []byte) Bytes {\n\treturn Bytes(TxHash.Hash.Sum(bz))\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Signature Verification in CheckTx (Go)\nDESCRIPTION: Demonstrates how to incorporate signature validation within the `CheckTx` ABCI method of a custom `ForumApp`. It extracts the transaction, calls the `isValidSignature` function, and returns a `CheckTxResponse` with an `InvalidSignature` code if verification fails, otherwise returning an `OK` code. Assumes the existence of `types` and `code` packages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc (app *ForumApp) CheckTx(req types.CheckTxRequest) types.CheckTxResponse {\n    tx := req.Tx\n    // Extract the transaction fields, including the signature and the public key\n    // Verify the signature\n    if !isValidSignature(tx) {\n        return types.CheckTxResponse{\n            Code: code.InvalidSignature,\n            Log:  \"Invalid transaction signature\",\n        }\n    }\n\n    // some other validation...\n\n    return types.CheckTxResponse{Code: code.OK}\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing BadgerDB and Creating Application Instance in Go\nDESCRIPTION: Shows how to initialize a BadgerDB database instance using default options at a path derived from the home directory (`<homeDir>/badger`). It includes error handling for database opening and ensures the database is closed deferredly. Subsequently, it creates an instance of the `KVStoreApplication`, passing the initialized database handle to it.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_15\n\nLANGUAGE: go\nCODE:\n```\ndbPath := filepath.Join(homeDir, \"badger\")\ndb, err := badger.Open(badger.DefaultOptions(dbPath))\nif err != nil {\n    log.Fatalf(\"Opening database: %v\", err)\n}\ndefer func() {\n    if err := db.Close(); err != nil {\n        log.Fatalf(\"Closing database: %v\", err) // Changed to Fatalf based on surrounding code style\n    }\n}()\n\napp := NewKVStoreApplication(db)\n```\n\n----------------------------------------\n\nTITLE: Defining Consensus Events and Messages in Go\nDESCRIPTION: This snippet defines various event and message types used in the consensus algorithm. It includes structures for new height events, proposals, votes, and timeouts. These types are essential for representing the different states and actions in the consensus process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-030-consensus-refactor.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Event interface{}\n\ntype EventNewHeight struct {\n    Height           int64\n    ValidatorId      int\n}\n\ntype EventNewRound HeightAndRound\n\ntype EventProposal struct {\n    Height           int64\n    Round            int\n    Timestamp        Time\n    BlockID          BlockID\n    POLRound         int\n    Sender           int   \n}\n\ntype Majority23PrevotesBlock struct {\n    Height           int64\n    Round            int\n    BlockID          BlockID\n}\n\ntype Majority23PrecommitBlock struct {\n    Height           int64\n    Round            int\n    BlockID          BlockID\n}\n\ntype HeightAndRound struct {\n    Height           int64\n    Round            int\n}\n\ntype Majority23PrevotesAny HeightAndRound\ntype Majority23PrecommitAny HeightAndRound\ntype TimeoutPropose HeightAndRound\ntype TimeoutPrevotes HeightAndRound\ntype TimeoutPrecommit HeightAndRound\n\n\ntype Message interface{}\n\ntype MessageProposal struct {\n    Height           int64\n    Round            int\n    BlockID          BlockID\n    POLRound         int\n}\n\ntype VoteType int\n\nconst (\n\tVoteTypeUnknown VoteType = iota\n\tPrevote\n\tPrecommit\n)\n\n\ntype MessageVote struct {\n    Height           int64\n    Round            int\n    BlockID          BlockID\n    Type             VoteType\n}\n\n\ntype MessageDecision struct {\n    Height           int64\n    Round            int\n    BlockID          BlockID\n}\n\ntype TriggerTimeout struct {\n    Height           int64\n    Round            int\n    Duration         Duration\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Core Consensus Function in Go\nDESCRIPTION: This snippet defines the main Consensus function, which is the heart of the consensus algorithm. It takes an Event and the current State as input, and returns an updated State, a Message to be sent, and a TriggerTimeout. The function handles various event types and updates the consensus state accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-030-consensus-refactor.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc Consensus(event Event, state State) (State, Message, TriggerTimeout) {\n    msg = nil\n    timeout = nil\n\tswitch event := event.(type) {\n    \tcase EventNewHeight:\n    \t\tif event.Height > state.Height {\n    \t\t    state.Height = event.Height\n    \t\t    state.Round = -1\n    \t\t    state.Step = RoundStepPropose\n    \t\t    state.LockedValue = nil\n    \t\t    state.LockedRound = -1\n    \t\t    state.ValidValue = nil\n    \t\t    state.ValidRound = -1\n    \t\t    state.ValidatorId = event.ValidatorId\n    \t\t} \n    \t    return state, msg, timeout\n    \t\n    \tcase EventNewRound:\n    \t\tif event.Height == state.Height and event.Round > state.Round {\n               state.Round = eventRound\n               state.Step = RoundStepPropose\n               if proposer(state.Height, state.Round) == state.ValidatorId {\n                   proposal = state.ValidValue\n                   if proposal == nil {\n                   \t    proposal = getValue()\n                   }\n                   msg =  MessageProposal { state.Height, state.Round, proposal, state.ValidRound }\n               }\n               timeout = TriggerTimeout { state.Height, state.Round, timeoutPropose(state.Round) }\n            }\n    \t    return state, msg, timeout\n    \t\n    \tcase EventProposal:\n    \t\tif event.Height == state.Height and event.Round == state.Round and \n    \t       event.Sender == proposal(state.Height, state.Round) and state.Step == RoundStepPropose { \n    \t       \tif event.POLRound >= state.LockedRound or event.BlockID == state.BlockID or state.LockedRound == -1 {\n    \t       \t\tmsg = MessageVote { state.Height, state.Round, event.BlockID, Prevote }\n    \t       \t}\n    \t       \tstate.Step = RoundStepPrevote\n            }\n    \t    return state, msg, timeout\n    \t\n    \tcase TimeoutPropose:\n    \t\tif event.Height == state.Height and event.Round == state.Round and state.Step == RoundStepPropose {\n    \t\t    msg = MessageVote { state.Height, state.Round, nil, Prevote }\n    \t\t\tstate.Step = RoundStepPrevote\n            }\n    \t    return state, msg, timeout\n    \t\n    \tcase Majority23PrevotesBlock:\n    \t\tif event.Height == state.Height and event.Round == state.Round and state.Step >= RoundStepPrevote and event.Round > state.ValidRound {\n    \t\t    state.ValidRound = event.Round\n    \t\t    state.ValidValue = event.BlockID\n    \t\t    if state.Step == RoundStepPrevote {\n    \t\t    \tstate.LockedRound = event.Round\n    \t\t    \tstate.LockedValue = event.BlockID\n    \t\t    \tmsg = MessageVote { state.Height, state.Round, event.BlockID, Precommit }\n    \t\t    \tstate.Step = RoundStepPrecommit\n    \t\t    }\n            }\n    \t    return state, msg, timeout\n    \t\n    \tcase Majority23PrevotesAny:\n    \t\tif event.Height == state.Height and event.Round == state.Round and state.Step == RoundStepPrevote {\n    \t\t\ttimeout = TriggerTimeout { state.Height, state.Round, timeoutPrevote(state.Round) }\n    \t\t}\n    \t    return state, msg, timeout\n    \t\n    \tcase TimeoutPrevote:\n    \t\tif event.Height == state.Height and event.Round == state.Round and state.Step == RoundStepPrevote {\n    \t\t\tmsg = MessageVote { state.Height, state.Round, nil, Precommit }\n    \t\t\tstate.Step = RoundStepPrecommit\n    \t\t}\n    \t    return state, msg, timeout\n    \t\n    \tcase Majority23PrecommitBlock:\n    \t\tif event.Height == state.Height {\n    \t\t    state.Step = RoundStepCommit\n    \t\t    state.LockedValue = event.BlockID\n    \t\t}\n    \t    return state, msg, timeout\n    \t\t\n    \tcase Majority23PrecommitAny:\n    \t\tif event.Height == state.Height and event.Round == state.Round {\n    \t\t\ttimeout = TriggerTimeout { state.Height, state.Round, timeoutPrecommit(state.Round) }\n    \t\t}\n    \t    return state, msg, timeout\n    \t\n    \tcase TimeoutPrecommit:\n            if event.Height == state.Height and event.Round == state.Round {\n            \tstate.Round = state.Round + 1\n            }\n    \t    return state, msg, timeout\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ABCI-CLI and Example Apps\nDESCRIPTION: Commands to clone the CometBFT repository and install the ABCI-CLI tool and example applications.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/abci-cli.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/cometbft/cometbft.git\ncd cometbft\nmake install_abci\n```\n\n----------------------------------------\n\nTITLE: Verifying a Merkle Proof - Go\nDESCRIPTION: Implements Merkle proof verification for inclusion of a leaf in a tree. Checks that a computed hash from a proof equals the expected root hash, using recursive hashing. Proof struct contains leafHash, index, total, and list of aunts. Inputs: proof, rootHash ([]byte), leaf ([]byte). Output: boolean success. Dependencies: hash functions and proof computation logic. Limits proof tree height (aunts) for DoS protection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc (proof Proof) Verify(rootHash []byte, leaf []byte) bool {\n assert(proof.LeafHash, leafHash(leaf)\n\n computedHash := computeHashFromAunts(proof.Index, proof.Total, proof.LeafHash, proof.Aunts)\n    return computedHash == rootHash\n}\n\nfunc computeHashFromAunts(index, total int, leafHash []byte, innerHashes [][]byte) []byte{\n assert(index < total && index >= 0 && total > 0)\n\n if total == 1{\n  assert(len(proof.Aunts) == 0)\n  return leafHash\n }\n\n assert(len(innerHashes) > 0)\n\n numLeft := getSplitPoint(total) // largest power of 2 less than total\n if index < numLeft {\n  leftHash := computeHashFromAunts(index, numLeft, leafHash, innerHashes[:len(innerHashes)-1])\n  assert(leftHash != nil)\n  return innerHash(leftHash, innerHashes[len(innerHashes)-1])\n }\n rightHash := computeHashFromAunts(index-numLeft, total-numLeft, leafHash, innerHashes[:len(innerHashes)-1])\n assert(rightHash != nil)\n return innerHash(innerHashes[len(innerHashes)-1], rightHash)\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Commit Signatures in CometBFT Light Client (Go)\nDESCRIPTION: The VerifyCommitLight function validates that at least 2/3+ of the signatures from a validator set were for a given blockID. It verifies validator signatures, tracks voting power, and returns early once sufficient voting power has been tallied. The function handles both index-based and address-based validator lookups.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_003_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc VerifyCommitLight(chainID string, vals *ValidatorSet, blockID BlockID,\nheight int64, commit *Commit) error {\n  // run a basic validation of the arguments\n  if err := verifyBasicValsAndCommit(vals, commit, height, blockID); err != nil {\n    return err\n  }\n\n  // calculate voting power needed\n  votingPowerNeeded := vals.TotalVotingPower() * 2 / 3\n\n  var (\n    val                *Validator\n    valIdx             int32\n    seenVals                 = make(map[int32]int, len(commit.Signatures))\n    talliedVotingPower int64 = 0\n    voteSignBytes      []byte\n  )\n  for idx, commitSig := range commit.Signatures {\n    // ignore all commit signatures that are not for the block\n    if !commitSig.ForBlock() {\n      continue\n    }\n\n    // If the vals and commit have a 1-to-1 correspondence we can retrieve\n    // them by index else we need to retrieve them by address\n    if lookUpByIndex {\n      val = vals.Validators[idx]\n    } else {\n      valIdx, val = vals.GetByAddress(commitSig.ValidatorAddress)  \n\n      // if the signature doesn't belong to anyone in the validator set\n      // then we just skip over it\n      if val == nil {\n        continue\n      }\n\n      // because we are getting validators by address we need to make sure\n      // that the same validator doesn't commit twice\n      if firstIndex, ok := seenVals[valIdx]; ok {\n        secondIndex := idx\n        return fmt.Errorf(\"double vote from %v (%d and %d)\", val, firstIndex, secondIndex)\n      }\n      seenVals[valIdx] = idx\n    }\n\n    voteSignBytes = commit.VoteSignBytes(chainID, int32(idx))\n\n    if !val.PubKey.VerifySignature(voteSignBytes, commitSig.Signature) {\n      return fmt.Errorf(\"wrong signature (#%d): %X\", idx, commitSig.Signature)\n    }\n\n    // Add the voting power of the validator\n    // to the tally\n    talliedVotingPower += val.VotingPower\n\n    // check if we have enough signatures and can thus exit early\n    if talliedVotingPower > votingPowerNeeded {\n      return nil\n    }\n  }\n\n  if got, needed := talliedVotingPower, votingPowerNeeded; got <= needed {\n    return ErrNotEnoughVotingPowerSigned{Got: got, Needed: needed}\n  }\n\n  return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Vote Message Structure Definition in CometBFT\nDESCRIPTION: The restructured Vote message definition using binary encoding (Amino/Protobuf) including fixed field types and the SignVoteRequest/Reply messages. The Vote type now directly includes ChainID instead of injecting it during signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\n// vanilla protobuf / amino encoded\nmessage Vote {\n    Version       fixed32                      \n    Height        sfixed64       \n    Round         sfixed32\n    VoteType      fixed32\n    Timestamp     Timestamp         // << using protobuf definition\n    BlockID       BlockID           // << as already defined \n    ChainID       string            // at the end because length could vary a lot\n}\n\n// this is an amino registered type; like currently privval.SignVoteMsg: \n// registered with \"tendermint/socketpv/SignVoteRequest\"\nmessage SignVoteRequest {\n   Vote vote\n}\n\n//  amino registered type\n// registered with \"tendermint/socketpv/SignedVoteReply\"\nmessage SignedVoteReply { \n   Vote      Vote\n   Signature Signature \n   Err       Error\n}\n\n// we will use this type everywhere below\nmessage Error {\n  Type        uint  // error code\n  Description string  // optional description\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running CometBFT with kvstore App using Docker\nDESCRIPTION: This snippet demonstrates how to initialize CometBFT and run a single instance with the built-in kvstore app using Docker. It mounts a volume for persistent data storage.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/DOCKER/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndocker run -it --rm -v \"/tmp:/cometbft\" cometbft/cometbft init\ndocker run -it --rm -v \"/tmp:/cometbft\" cometbft/cometbft node --proxy_app=kvstore\n```\n\n----------------------------------------\n\nTITLE: Installing CometBFT Release\nDESCRIPTION: Commands to checkout the latest v1 release and install CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd cometbft\ngit checkout v1.0.0-rc2\nmake install\n```\n\n----------------------------------------\n\nTITLE: Compiling and Installing CometBFT\nDESCRIPTION: This command compiles CometBFT from source and installs the binary in $GOPATH/bin.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Defining Genesis Block (CMBC-GENESIS.1)\nDESCRIPTION: This definition establishes 'Genesis' as the universally agreed-upon initial block or file that forms the root of the blockchain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-GENESIS.1]\n\nLet *Genesis* be the agreed-upon initial block (file).\n```\n\n----------------------------------------\n\nTITLE: Configuring Empty Block Creation in CometBFT\nDESCRIPTION: Controls whether validators should propose empty blocks when their mempool has no transactions. When true, empty blocks are produced to indicate the chain is operative. When false, blocks are only created when transactions are received or app_hash changes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_88\n\nLANGUAGE: toml\nCODE:\n```\ncreate_empty_blocks = true\n```\n\n----------------------------------------\n\nTITLE: TOML Configuration for Data Companion Service\nDESCRIPTION: Configuration file structure for enabling and configuring the data companion service in CometBFT. It includes options for enabling the service, specifying the companion address, and controlling which data should be included in BlockCommitted requests.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-100-data-companion-push-api.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[data_companion]\n# By default, the data companion service interaction is disabled. It is\n# recommended that this only be enabled on full nodes and not validators so as\n# to minimize the possibility of network instability.\nenabled = false\n\n# Address at which the gRPC companion service server is hosted. It is\n# recommended that this companion service be co-located at least within the same\n# data center as the CometBFT node to reduce the risk of network latencies\n# interfering in node operation.\naddr = \"http://localhost:26659\"\n\n# Controls the BlockCommitted gRPC call.\n[data_companion.block_committed]\n# Enable the BlockCommitted gRPC call. Only relevant if the data companion is\n# enabled.\nenabled = true\n# Additional fields to publish in each BlockCommittedRequest sent to the\n# companion. Available options:\n# - \"finalize_block_response\": Also publish the FinalizeBlock response related\n#                              to the block in the BlockCommittedRequest.\nadditionally_publish = [\"finalize_block_response\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI Interface for State Sync in Protobuf\nDESCRIPTION: Defines the ABCI interface messages for state sync operations including listing available snapshots, offering snapshots to applications, loading snapshot chunks, and applying snapshot chunks during restoration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-053-state-sync-prototype.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\n// Lists available snapshots\nmessage RequestListSnapshots {}\n\nmessage ResponseListSnapshots {\n  repeated Snapshot snapshots = 1;\n}\n\n// Offers a snapshot to the application\nmessage RequestOfferSnapshot {\n  Snapshot snapshot = 1;  // snapshot offered by peers\n  bytes    app_hash = 2;  // light client-verified app hash for snapshot height\n }\n\nmessage ResponseOfferSnapshot {\n  Result result = 1;\n\n  enum Result {\n    accept        = 0;  // Snapshot accepted, apply chunks\n    abort         = 1;  // Abort all snapshot restoration\n    reject        = 2;  // Reject this specific snapshot, and try a different one\n    reject_format = 3;  // Reject all snapshots of this format, and try a different one\n    reject_sender = 4;  // Reject all snapshots from the sender(s), and try a different one\n  }\n}\n\n// Loads a snapshot chunk\nmessage RequestLoadSnapshotChunk {\n  uint64 height = 1;\n  uint32 format = 2;\n  uint32 chunk  = 3; // Zero-indexed\n}\n\nmessage ResponseLoadSnapshotChunk {\n  bytes chunk = 1;\n}\n\n// Applies a snapshot chunk\nmessage RequestApplySnapshotChunk {\n  uint32 index  = 1;\n  bytes  chunk  = 2;\n  string sender = 3;\n }\n\nmessage ResponseApplySnapshotChunk {\n  Result          result         = 1;\n  repeated uint32 refetch_chunks = 2;  // Chunks to refetch and reapply (regardless of result)\n  repeated string reject_senders = 3;  // Chunk senders to reject and ban (regardless of result)\n\n  enum Result {\n    accept          = 0;  // Chunk successfully accepted\n    abort           = 1;  // Abort all snapshot restoration\n    retry           = 2;  // Retry chunk, combine with refetch and reject as appropriate\n    retry_snapshot  = 3;  // Retry snapshot, combine with refetch and reject as appropriate\n    reject_snapshot = 4;  // Reject this snapshot, try a different one but keep sender rejections\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FinalizeBlock Implementation for Block Processing\nDESCRIPTION: Implements the ABCI FinalizeBlock method to process transactions in a block, create database transactions, and prepare state updates using BadgerDB.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) FinalizeBlock(_ context.Context, req *abcitypes.FinalizeBlockRequest) (*abcitypes.FinalizeBlockResponse, error) {\n    var txs = make([]*abcitypes.ExecTxResult, len(req.Txs))\n\n    app.onGoingBlock = app.db.NewTransaction(true)\n    for i, tx := range req.Txs {\n        if code := app.isValid(tx); code != 0 {\n            log.Printf(\"Error in tx in if\")\n            txs[i] = &abcitypes.ExecTxResult{Code: code}\n        } else {\n            parts := bytes.SplitN(tx, []byte(\"=\"), 2)\n            key, value := parts[0], parts[1]\n            log.Printf(\"Adding key %s with value %s\", key, value)\n\n            if err := app.onGoingBlock.Set(key, value); err != nil {\n                log.Panicf(\"Error writing to database, unable to execute tx: %v\", err)\n            }\n            log.Printf(\"Successfully added key %s with value %s\", key, value)\n\n            txs[i] = &abcitypes.ExecTxResult{\n                Code: 0,\n                Events: []abcitypes.Event{\n                    {\n                        Type: \"app\",\n                        Attributes: []abcitypes.EventAttribute{\n                            {Key: \"key\", Value: string(key), Index: true},\n                            {Key: \"value\", Value: string(value), Index: true},\n                        },\n                    },\n                },\n            }\n        }\n    }\n\n    return &abcitypes.FinalizeBlockResponse{\n        TxResults:      txs,\n        NextBlockDelay: 1 * time.Second,\n    }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AttackDetector Function in Go for CometBFT Light Client\nDESCRIPTION: This function implements the main attack detection logic. It checks blocks from secondaries against the primary trace, generates evidence if conflicts are found, and handles replacement of faulty secondaries.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc AttackDetector(root LightBlock, primary_trace []LightBlock)\n                   ([]InternalEvidence) {\n\n    Evidences := new []InternalEvidence;\n\n    for each secondary in Secondaries {\n        lb, result := FetchLightBlock(secondary,primary_trace.Latest().Header.Height);\n        if result != ResultSuccess {\n            Replace_Secondary(root);\n        }\n        else if lb.Header != primary_trace.Latest().Header {\n  \n            // we replay the primary trace with the secondary, in\n            // order to generate evidence that we can submit to the\n            // secondary. We return the evidence + the trace the\n            // secondary told us that spans the evidence at its local store\n\n            EvidenceForSecondary, newroot, secondary_trace, result :=\n                    CreateEvidenceForPeer(secondary,\n                                          root,\n                                          primary_trace);\n            if result == FaultyPeer {\n                Replace_Secondary(root);\n            }\n            else if result == FoundEvidence {\n                // the conflict is not bogus\n                Evidences.Add(EvidenceForSecondary);\n                // we replay the secondary trace with the primary, ...\n                EvidenceForPrimary, _, result :=\n                        CreateEvidenceForPeer(primary,\n                                              newroot,\n                                              secondary_trace);\n                if result == FoundEvidence {\n                    Evidences.Add(EvidenceForPrimary);\n                }\n                // At this point we do not care about the other error\n                // codes. We already have generated evidence for an\n                // attack and need to stop the lightclient. It does not\n                // help to call replace_primary. Also we will use the\n                // same primary to check with other secondaries in\n                // later iterations of the loop\n            }\n            // In the case where the secondary reports NoEvidence\n            // after initially it reported a conflicting header.\n            // secondary is faulty\n            Replace_Secondary(root);\n        }\n    }\n    return Evidences;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating and Verifying Light Blocks in Go\nDESCRIPTION: Function to check if a new light block should be trusted based on a previously verified light block. It performs various checks on the untrusted block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc ValidAndVerified(trusted LightBlock, untrusted LightBlock) Result\n```\n\n----------------------------------------\n\nTITLE: Setting Experimental Database Key Layout in CometBFT\nDESCRIPTION: Configures the representation of keys in the database. Users can choose between v1 (legacy layout) and v2 (experimental order-preserving representation). Migration is required when switching from v1 to v2, and switching back is not supported.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_94\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_db_key_layout = 'v1'\n```\n\n----------------------------------------\n\nTITLE: Loading Private Validator Key Files in Go\nDESCRIPTION: Illustrates how to load the private validator key and state files using `privval.LoadFilePV`. It retrieves the file paths from the loaded CometBFT configuration object (`config.PrivValidatorKeyFile()`, `config.PrivValidatorStateFile()`). This private validator is used for signing consensus messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_16\n\nLANGUAGE: go\nCODE:\n```\npv := privval.LoadFilePV(\n    config.PrivValidatorKeyFile(),\n    config.PrivValidatorStateFile(),\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Logger Interface for Tendermint in Go\nDESCRIPTION: The core Logger interface that will be implemented by all Tendermint libraries, providing methods for different log levels and context addition.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-001-logging.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n# log.go\ntype Logger interface {\n    Debug(msg string, keyvals ...interface{}) error\n    Info(msg string, keyvals ...interface{}) error\n    Error(msg string, keyvals ...interface{}) error\n\n\t  With(keyvals ...interface{}) Logger\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing VerifyVoteExtension in Go with CometBFT\nDESCRIPTION: Implementation of VerifyVoteExtension method that validates vote extensions by checking for duplicate curse words and ensuring the word limit is not exceeded. Returns acceptance or rejection status based on validation rules.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/7.vote-extension.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) VerifyVoteExtension(_ context.Context, req *abci.VerifyVoteExtensionRequest) (*abci.VerifyVoteExtensionResponse, error) {\n\tapp.logger.Info(\"Executing Application VerifyVoteExtension\")\n\n\tif _, ok := app.valAddrToPubKeyMap[string(req.ValidatorAddress)]; !ok {\n\t\treturn nil, errors.New(\"unknown validator\")\n\t}\n\n\tcurseWords := strings.Split(string(req.VoteExtension), \"|\")\n\tif hasDuplicateWords(curseWords) {\n\t\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_REJECT}, nil\n\t}\n\n\tif len(curseWords) > CurseWordsLimitVE {\n\t\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_REJECT}, nil\n\t}\n\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BlockID Structure in Go\nDESCRIPTION: Defines BlockID and PartSetHeader structs used to represent block structures in the CometBFT consensus algorithm. Includes methods to check if a BlockID is nil or complete, aiding in vote/proposal validation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype BlockID struct {\n Hash        []byte\n PartsHeader PartSetHeader\n}\n\ntype PartSetHeader struct {\n Hash  []byte\n Total int\n}\n```\n\n----------------------------------------\n\nTITLE: Database Initialization for CometBFT Application\nDESCRIPTION: Code snippet that initializes a Badger database for the ABCI application. It sets up the database path and handles open/close operations with proper error handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\ndbPath := filepath.Join(homeDir, \"badger\")\ndb, err := badger.Open(badger.DefaultOptions(dbPath))\nif err != nil {\n    log.Fatalf(\"Opening database: %v\", err)\n}\ndefer func() {\n    if err := db.Close(); err != nil {\n        log.Fatalf(\"Closing database: %v\", err)\n    }\n}()\n\napp := NewKVStoreApplication(db)\n```\n\n----------------------------------------\n\nTITLE: Calculating Address from Public Key in Go\nDESCRIPTION: Implementation of address calculation by hashing a public key using SHA256 and truncating to first 20 bytes. This is used to generate validator addresses in the CometBFT network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nconst (\n  TruncatedSize = 20\n)\n\nfunc SumTruncated(bz []byte) []byte {\n  hash := sha256.Sum256(bz)\n  return hash[:TruncatedSize]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CryptoProviderPV in Go\nDESCRIPTION: This code snippet shows the implementation of CryptoProviderPV, which uses the CryptoProvider interface to provide PrivValidator functionality. It includes methods for signing votes, proposals, and arbitrary bytes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-117-cryptoprovider-implementation.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// CryptoProviderPV is the implementation of PrivValidator using CryptoProvider's methods\ntype CryptoProviderPV struct {\n    provider CryptoProvider\n}\n\n// NewCryptoProviderPV creates a new instance of CryptoProviderPV\nfunc NewCryptoProviderPV(provider CryptoProvider) (*CryptoProviderPV, error) {\n    return &CryptoProviderPV{provider: provider}, nil\n}\n\n// SignVote signs a canonical representation of the vote. If signExtension is true, it also signs the vote extension.\nfunc (pv *CryptoProviderPV) SignVote(chainID string, vote *Vote, signExtension bool) error {\n    signer := pv.provider.GetSigner()\n\n    // code for getting voteBytes goes here\n    // voteBytes := ...\n\n    // The underlying signer needs these parameters so we pass them through SignerOpts\n    options := SignerOpts{\n        \"chainID\": chainID,\n        \"vote\":    vote,\n    }\n\n    sig, _ := signer.Sign(voteBytes, options)\n    vote.Signature = sig\n    return nil\n}\n\n// SignProposal signs a canonical representation of the proposal\nfunc (pv *CryptoProviderPV) SignProposal(chainID string, proposal *Proposal) error {\n    signer := pv.provider.GetSigner()\n\n    // code for getting proposalBytes goes here\n    // proposalBytes := ...\n\n    // The underlying signer needs these parameters so we pass them through SignerOpts\n    options := SignerOpts{\n        \"chainID\":  chainID,\n        \"proposal\": proposal,\n    }\n\n    sig, _ := signer.Sign(proposalBytes, options)\n    proposal.Signature = sig\n    return nil\n}\n\n// SignBytes signs an arbitrary array of bytes\nfunc (pv *CryptoProviderPV) SignBytes(bytes []byte) ([]byte, error) {\n    signer := pv.provider.GetSigner()\n    return signer.Sign(bytes, SignerOpts{})\n}\n```\n\n----------------------------------------\n\nTITLE: Querying the Application State\nDESCRIPTION: This curl command queries the application state for a specific key using the abci_query endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"cometbft\"'\n```\n\n----------------------------------------\n\nTITLE: Deriving Secp256k1 Address from Public Key - Go\nDESCRIPTION: Computes a secp256k1 address by applying SHA256 followed by RIPEMD160 to a 33-byte public key. This operation compresses identity data for validator and account addressing. Prerequisites: 33-byte pubkey. Dependencies: SHA256 and RIPEMD160 implementations. Output: 20-byte address. Usage shown inline for CometBFT's cryptographic addressing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\naddress = RIPEMD160(SHA256(pubkey))\n```\n\n----------------------------------------\n\nTITLE: Updating Application with Evidence in Go\nDESCRIPTION: This snippet shows how the BlockExecutor updates the application with evidence from the evidence pool. It calls the Update method on the evidence pool to get a simplified format of evidence to be sent to the application via BeginBlock.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nabciResponses.BeginBlock.ByzantineValidators = evpool.Update(block, state)\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Nodes in a Cluster\nDESCRIPTION: Commands to start CometBFT nodes in a cluster configuration. Each node is configured with a home directory and a list of persistent peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --home ./mytestnet/node0 --proxy_app=kvstore --p2p.persistent_peers=\"ID1@IP1:26656,ID2@IP2:26656,ID3@IP3:26656,ID4@IP4:26656\"\ncometbft node --home ./mytestnet/node1 --proxy_app=kvstore --p2p.persistent_peers=\"ID1@IP1:26656,ID2@IP2:26656,ID3@IP3:26656,ID4@IP4:26656\"\ncometbft node --home ./mytestnet/node2 --proxy_app=kvstore --p2p.persistent_peers=\"ID1@IP1:26656,ID2@IP2:26656,ID3@IP3:26656,ID4@IP4:26656\"\ncometbft node --home ./mytestnet/node3 --proxy_app=kvstore --p2p.persistent_peers=\"ID1@IP1:26656,ID2@IP2:26656,ID3@IP3:26656,ID4@IP4:26656\"\n```\n\n----------------------------------------\n\nTITLE: Replacing Tendermint Core Dependency with CometBFT in Go Modules\nDESCRIPTION: Command to update go.mod file to replace Tendermint Core with CometBFT v0.34.27 while preserving the original module URL to minimize migration impact.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/UPGRADING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo mod edit -replace github.com/tendermint/tendermint=github.com/cometbft/cometbft@v0.34.27\n```\n\n----------------------------------------\n\nTITLE: Querying Consensus Parameters via RPC in CometBFT\nDESCRIPTION: A shell command that queries the consensus parameters from a locally running CometBFT node via its RPC endpoint on port 26657. This retrieves the current SynchronyParams configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncurl localhost:26657/consensus_params\n```\n\n----------------------------------------\n\nTITLE: Committing State Changes with BadgerDB in Go\nDESCRIPTION: The `Commit` method finalizes transactions by committing Badger transactions, ensuring application state persistence. Successful commitment of the Badger transaction wraps up the block execution cycle by making pending changes permanent.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc (app KVStoreApplication) Commit(_ context.Context, commit *abcitypes.CommitRequest) (*abcitypes.CommitResponse, error) {\n    return &abcitypes.CommitResponse{}, app.onGoingBlock.Commit()\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"context\"\n    \"errors\"\n    abcitypes \"github.com/cometbft/cometbft/abci/types\"\n    \"github.com/dgraph-io/badger/v4\"\n    \"log\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Validator and ValidatorUpdate Message Structures in Protobuf\nDESCRIPTION: Definition of two distinct message types: Validator (containing address and power, used in RequestBeginBlock) and ValidatorUpdate (containing public key and power, used in ResponseEndBlock). This separation addresses the need to avoid sending large quantum public keys with every block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-018-ABCI-Validators.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Validator {\n    bytes address\n    int64 power\n}\n\nmessage ValidatorUpdate {\n    PubKey pub_key\n    int64 power\n}\n```\n\n----------------------------------------\n\nTITLE: Protobuf Message Length Encoding Example\nDESCRIPTION: Example showing unsigned varint-based message length encoding used in the CometBFT Socket Protocol for length-prefixing messages before Protobuf3 serialization.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_client_server.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nunsigned varint + protobuf3 encoded message\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Configuration\nDESCRIPTION: Command to initialize CometBFT configuration files in a specified home directory, generating private validator keys, node keys, and genesis file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ncometbft init --home /tmp/cometbft-home\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Interface for CometBFT P2P Message Scheduling\nDESCRIPTION: Defines the queue interface for QoS scheduling of Envelopes, used at contention points in the Router for inbound and outbound message handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\n// queue does QoS scheduling for Envelopes, enqueueing and dequeueing according\n// to some policy. Queues are used at contention points, i.e.:\n// - Receiving inbound messages to a single channel from all peers.\n// - Sending outbound messages to a single peer from all channels.\ntype queue interface {\n    // enqueue returns a channel for submitting envelopes.\n    enqueue() chan<- Envelope\n\n    // dequeue returns a channel ordered according to some queueing policy.\n    dequeue() <-chan Envelope\n\n    // close closes the queue. After this call enqueue() will block, so the\n    // caller must select on closed() as well to avoid blocking forever. The\n    // enqueue() and dequeue() channels will not be closed.\n    close()\n\n    // closed returns a channel that's closed when the scheduler is closed.\n    closed() <-chan struct{}\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Message Publishing in Go\nDESCRIPTION: Demonstrates two approaches for asynchronous message publishing: using channels for data transmission and invoking callback functions. This snippet illustrates the concept of publishing messages to subscribers in separate goroutines.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfor each subscriber {\n    out := subscriber.outc\n    go func() {\n        out <- msg\n    }\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nfor each subscriber {\n    go subscriber.callbackFn()\n}\n```\n\n----------------------------------------\n\nTITLE: Querying CometBFT node status\nDESCRIPTION: cURL command to get the status of the running CometBFT node via RPC.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s localhost:26657/status\n```\n\n----------------------------------------\n\nTITLE: Defining the PartSetHeader Structure in CometBFT\nDESCRIPTION: Defines the `PartSetHeader` structure used within CometBFT's `BlockID`. It specifies the total number of block parts (`Total`) and the Merkle root (`Hash`) of the serialized block parts, used for gossiping.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n| Name  | Type                      | Description                       | Validation           |\n|-------|---------------------------|-----------------------------------|----------------------|\n| Total | int32                     | Total amount of parts for a block | Must be > 0          |\n| Hash  | slice of bytes (`[]byte`) | MerkleRoot of a serialized block  | Must be of length 32 |\n```\n\n----------------------------------------\n\nTITLE: Setting a key-value pair in the KVStore\nDESCRIPTION: cURL command to set a key-value pair in the KVStore application via a transaction.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"name=satoshi\"'\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service for PrivValidatorAPI in Protobuf\nDESCRIPTION: This code snippet defines the gRPC service for the PrivValidatorAPI, including methods for getting public keys, signing votes, and signing proposals. It also defines the request and response message structures for each method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-063-privval-grpc.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nservice PrivValidatorAPI {\n  rpc GetPubKey(tendermint.proto.privval.PubKeyRequest) returns (tendermint.proto.privval.PubKeyResponse);\n  rpc SignVote(tendermint.proto.privval.SignVoteRequest) returns (tendermint.proto.privval.SignedVoteResponse);\n  rpc SignProposal(tendermint.proto.privval.SignProposalRequest) returns (tendermint.proto.privval.SignedProposalResponse);\n\n  message PubKeyRequest {\n  string chain_id = 1;\n}\n\n// PubKeyResponse is a response message containing the public key.\nmessage PubKeyResponse {\n  tendermint.crypto.PublicKey pub_key = 1 [(gogoproto.nullable) = false];\n}\n\n// SignVoteRequest is a request to sign a vote\nmessage SignVoteRequest {\n  tendermint.types.Vote vote     = 1;\n  string                chain_id = 2;\n}\n\n// SignedVoteResponse is a response containing a signed vote or an error\nmessage SignedVoteResponse {\n  tendermint.types.Vote vote  = 1 [(gogoproto.nullable) = false];\n}\n\n// SignProposalRequest is a request to sign a proposal\nmessage SignProposalRequest {\n  tendermint.types.Proposal proposal = 1;\n  string                    chain_id = 2;\n}\n\n// SignedProposalResponse is response containing a signed proposal or an error\nmessage SignedProposalResponse {\n  tendermint.types.Proposal proposal = 1 [(gogoproto.nullable) = false];\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Blocking Message Send to Peer in Go\nDESCRIPTION: This method attempts to send a message to the peer, immediately returning false if the channel's send queue is full.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) TrySend(e Envelope) bool\n```\n\n----------------------------------------\n\nTITLE: Defining Core Consensus Types in Go\nDESCRIPTION: Defines the basic types for the refactored consensus implementation including Event enumeration, Message enumeration, and State structure which together model the consensus algorithm's inputs and outputs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-030-consensus-refactor.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Event int\n\nconst (\n\tEventUnknown Event = iota\n\tEventProposal\n\tMajority23PrevotesBlock\n\tMajority23PrecommitBlock\n\tMajority23PrevotesAny\n\tMajority23PrecommitAny\n\tTimeoutNewRound\n\tTimeoutPropose\n\tTimeoutPrevotes\n\tTimeoutPrecommit\n)\n\ntype Message int\n\nconst (\n\tMeesageUnknown Message = iota\n\tMessageProposal\n\tMessageVotes\n\tMessageDecision\n)\n\ntype State struct {\n\theight      uint64\n\tround       uint64\n\tstep        uint64\n\tlockedValue interface{} // TODO: Define proper type.\n\tlockedRound interface{} // TODO: Define proper type.\n\tvalidValue  interface{} // TODO: Define proper type.\n\tvalidRound  interface{} // TODO: Define proper type.\n\t// From the original notes: valid(v)\n\tvalid       interface{} // TODO: Define proper type.\n\t// From the original notes: proposer(h, r)\n\tproposer    interface{} // TODO: Define proper type.\n}\n\nfunc Consensus(Event, State) (State, Message) {\n\t// Consolidate implementation.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventSink Interface in Go\nDESCRIPTION: Introduces the EventSink interface that all supported sinks must implement. It includes methods for indexing block and transaction events, searching events, and retrieving specific transactions or blocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-065-custom-event-indexing.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype EventSink interface {\n  IndexBlockEvents(types.EventDataNewBlockHeader) error\n  IndexTxEvents([]*abci.TxResult) error\n\n  SearchBlockEvents(context.Context, *query.Query) ([]int64, error)\n  SearchTxEvents(context.Context, *query.Query) ([]*abci.TxResult, error)\n\n  GetTxByHash([]byte) (*abci.TxResult, error)\n  HasBlock(int64) (bool, error)\n\n  Type() EventSinkType\n  Stop() error\n}\n```\n\n----------------------------------------\n\nTITLE: Broadcast API Endpoints in CometBFT\nDESCRIPTION: Lists the three endpoints available for broadcasting transactions in CometBFT, each with different processing levels.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n/broadcast_tx_async\n/broadcast_tx_sync\n/broadcast_tx_commit\n```\n\n----------------------------------------\n\nTITLE: Verifying Untrusted Header in Go\nDESCRIPTION: This function verifies an untrusted header against a trusted state. It checks the header time, validates the validator sets, and performs single verification or bisection if needed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nreturn (trustedState, ErrInvalidHeaderTime)\n}\n\nuntrustedVs, error := Validators(untrustedHeight)\nif error != nil return (trustedState, ErrRequestFailed)\n\nuntrustedNextVs, error := Validators(untrustedHeight + 1)\nif error != nil return (trustedState, ErrRequestFailed)\n\nerror = verifySingle(\n         trustedState,\n         untrustedSh,\n         untrustedVs,\n         untrustedNextVs,\n         trustThreshold)\n\nif fatalError(error) return (trustedState, error)\n\nif error == nil {\n    // the untrusted header is now trusted.\n    newTrustedState = TrustedState(untrustedSh, untrustedNextVs)\n    return (newTrustedState, nil)\n}\n\n// at this point in time we need to do bisection\npivotHeight := ceil((trustedHeader.Height + untrustedHeight) / 2)\n\nerror, newTrustedState = VerifyBisection(pivotHeight,\n                                         trustedState,\n                                         trustThreshold,\n                                         trustingPeriod,\n                                         clockDrift,\n                                         now)\nif error != nil return (newTrustedState, error)\n\nreturn VerifyBisection(untrustedHeight,\n                       newTrustedState,\n                       trustThreshold,\n                       trustingPeriod,\n                       clockDrift,\n                       now)\n```\n\n----------------------------------------\n\nTITLE: Main Verification Function in Go\nDESCRIPTION: Core function for light client verification. It iteratively verifies light blocks up to the target height using various helper functions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc VerifyToTarget(primary PeerID, lightStore LightStore,\n                    targetHeight Height) (LightStore, Result) {\n\n    nextHeight := targetHeight\n\n    for lightStore.LatestVerified.height < targetHeight {\n\n        // Get next LightBlock for verification\n        current, found := lightStore.Get(nextHeight)\n        if !found {\n            current = FetchLightBlock(primary, nextHeight)\n            lightStore.Update(current, StateUnverified)\n        }\n\n        // Verify\n        verdict = ValidAndVerified(lightStore.LatestVerified, current)\n\n        // Decide whether/how to continue\n        if verdict == SUCCESS {\n            lightStore.Update(current, StateVerified)\n        }\n        else if verdict == NOT_ENOUGH_TRUST {\n            // do nothing\n   // the light block current passed validation, but the validator\n            // set is too different to verify it. We keep the state of\n   // current at StateUnverified. For a later iteration, Schedule\n   // might decide to try verification of that light block again.\n        }\n        else {\n            // verdict is some error code\n            lightStore.Update(current, StateFailed)\n            // possibly remove all LightBlocks from primary\n            return (lightStore, ResultFailure)\n        }\n        nextHeight = Schedule(lightStore, nextHeight, targetHeight)\n    }\n    return (lightStore, ResultSuccess)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Block Data with Go gRPC Client\nDESCRIPTION: Example code showing how to initialize a gRPC client connection and fetch block data by height using CometBFT's provided client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/grpc.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n     \"github.com/cometbft/cometbft/rpc/grpc/client\"\n)\n\nctx := context.Background()\n\n// Service Client\naddr := \"0.0.0.0:26090\"\nconn, err := client.New(ctx, addr, client.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nblock, err := conn.GetBlockByHeight(ctx, height)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with the `block`\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Block Commit Data with curl and jq\nDESCRIPTION: Example command showing how to fetch block height and hash information from a CometBFT RPC endpoint using curl and jq. This data is needed for state sync configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/state-sync.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s https://233.123.0.140:26657/commit | jq \"{height: .result.signed_header.header.height, hash: .result.signed_header.commit.block_id.hash}\"\n```\n\n----------------------------------------\n\nTITLE: Handling CheckTx Failure and Peer Banning in CometBFT Mempool (Go)\nDESCRIPTION: This snippet demonstrates how to handle CheckTx failures, potentially ban peers, and manage the cache for invalid transactions in the CometBFT mempool. It includes logic for different configuration options and introduces new data structures for tracking peer failures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-101-p2p-bad-peers-checktx.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\nif (r.CheckTx.Code == abci.CodeTypeOK) && postCheckErr == nil {\n    // Check Tx passed\n} else {\n// ignore bad transaction\n    mem.logger.Debug(\n      \"rejected bad transaction\",\n      \"tx\", types.Tx(tx).Hash(),\n      \"peerID\", peerP2PID,\n      \"res\", r,\n      \"err\", postCheckErr,\n    )\n    mem.metrics.FailedTxs.Add(1)\n\n    mem.banPeer(peerP2PID)\n\n    if !mem.config.KeepInvalidTxsInCache {\n      // remove from cache (it might be good later)\n      mem.cache.Remove(tx)\n    } else {\n      // If transactins stay in the cache, remember they failed\n      mem.cache.invalidCachedTx.Store(tx.Key(), true)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Transactions with CheckTx in Go\nDESCRIPTION: This function handles validation of inbound transactions in the Forum Application. It checks if the transaction is a valid message, if the user exists in the database, and if the user is not banned.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) CheckTx(_ context.Context, req *abci.CheckTxRequest) (*abci.CheckTxResponse, error) {\n\tapp.logger.Info(\"Executing Application CheckTx\")\n\n\t// Parse the tx message\n\tmsg, err := model.ParseMessage(req.Tx)\n\tif err != nil {\n\t\tapp.logger.Info(\"CheckTx: failed to parse transaction message\", \"message\", msg, \"error\", err)\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeInvalidTxFormat, Log: \"Invalid transaction\", Info: err.Error()}, nil\n\t}\n\n\t// Check for invalid sender\n\tif len(msg.Sender) == 0 {\n\t\tapp.logger.Info(\"CheckTx: failed to parse transaction message\", \"message\", msg, \"error\", \"Sender is missing\")\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeInvalidTxFormat, Log: \"Invalid transaction\", Info: \"Sender is missing\"}, nil\n\t}\n\n\tapp.logger.Debug(\"searching for sender\", \"sender\", msg.Sender)\n\tu, err := app.state.DB.FindUserByName(msg.Sender)\n\n\tif err != nil {\n\t\tif !errors.Is(err, badger.ErrKeyNotFound) {\n\t\t\tapp.logger.Error(\"CheckTx: Error in check tx\", \"tx\", string(req.Tx), \"error\", err)\n\t\t\treturn &abci.CheckTxResponse{Code: CodeTypeEncodingError, Log: \"Invalid transaction\", Info: err.Error()}, nil\n\t\t}\n\t\tapp.logger.Info(\"CheckTx: Sender not found\", \"sender\", msg.Sender)\n\t} else if u != nil && u.Banned {\n\t\treturn &abci.CheckTxResponse{Code: CodeTypeBanned, Log: \"Invalid transaction\", Info: \"User is banned\"}, nil\n\t}\n\tapp.logger.Info(\"CheckTx: success checking tx\", \"message\", msg.Message, \"sender\", msg.Sender)\n\treturn &abci.CheckTxResponse{Code: CodeTypeOK, Log: \"Valid transaction\", Info: \"Transaction validation succeeded\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Application\nDESCRIPTION: Command to build the application with automatic dependency refresh.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ngo build -mod=mod\n```\n\n----------------------------------------\n\nTITLE: Extending Pruning Service API for Indexer Pruning\nDESCRIPTION: Extension to the pruning service Protocol Buffer definition that adds support for pruning transaction and block event indices. Includes methods for setting and getting retain heights for both the transaction and block indexers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\n// PruningService provides privileged access to specialized pruning\n// functionality on the CometBFT node to help control node storage.\nservice PruningService {\n\n\n    // SetTxIndexerRetainHeightRequest indicates to the node that it can safely\n    // prune all tx indices up to the specified retain height.\n    rpc SetTxIndexerRetainHeight(SetTxIndexerRetainHeightRequest) returns (SetTxIndexerRetainHeightResponse);\n\n    // GetTxIndexerRetainHeight returns information about the retain height\n    // parameters used by the node to influence TxIndexer pruning\n    rpc GetTxIndexerRetainHeight(GetTxIndexerRetainHeightRequest) returns (GetTxIndexerRetainHeightResponse);\n\n    // SetBlockIndexerRetainHeightRequest indicates to the node that it can safely\n    // prune all block indices up to the specified retain height.\n    rpc SetBlockIndexerRetainHeight(SetBlockIndexerRetainHeightRequest) returns (SetBlockIndexerRetainHeightResponse);\n\n    // GetBlockIndexerRetainHeight returns information about the retain height\n    // parameters used by the node to influence BlockIndexer pruning\n    rpc GetBlockIndexerRetainHeight(GetBlockIndexerRetainHeightRequest) returns (GetBlockIndexerRetainHeightResponse);\n\n\n}\n\nmessage SetTxIndexerRetainHeightRequest {\n    uint64 height = 1;\n}\n\nmessage SetTxIndexerRetainHeightResponse {}\n\nmessage GetTxIndexerRetainHeightRequest {}\n\nmessage GetTxIndexerRetainHeightResponse {\n    uint64 height = 1;\n}\n\nmessage SetBlockIndexerRetainHeightRequest {\n    uint64 height = 1;\n}\n\nmessage SetBlockIndexerRetainHeightResponse {}\n\nmessage GetBlockIndexerRetainHeightRequest {}\n\nmessage GetBlockIndexerRetainHeightResponse {\n    uint64 height = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Canonical Vote Validation in Go\nDESCRIPTION: Specifies the conditions under which a CanonicalVote is valid for signing, including the message type, height, round, and valid/empty BlockID.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nv.Type == 0x1 || v.Type == 0x2\nv.Height > 0\nv.Round >= 0\nv.BlockID.IsNil() || v.BlockID.IsComplete()\n```\n\n----------------------------------------\n\nTITLE: Implementing Prepare Proposal Phase in Rust\nDESCRIPTION: Introduces a new ABCI method for the Prepare Proposal phase, allowing block proposers to perform application-dependent work to optimize block data before network distribution.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn PrepareProposal(Block) -> BlockData\n```\n\n----------------------------------------\n\nTITLE: Configuring Consensus Timeouts in CometBFT using TOML\nDESCRIPTION: Sets various timeout parameters for the consensus algorithm, including propose, prevote, precommit, and commit timeouts. These values affect the behavior and performance of the consensus process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_107\n\nLANGUAGE: toml\nCODE:\n```\n[consensus]\n...\n\ntimeout_propose = \"3s\"\ntimeout_propose_delta = \"500ms\"\ntimeout_prevote = \"1s\"\ntimeout_prevote_delta = \"500ms\"\ntimeout_precommit = \"1s\"\ntimeout_precommit_delta = \"500ms\"\ntimeout_commit = \"1s\"\n```\n\n----------------------------------------\n\nTITLE: Configuring ABCI application connection in CometBFT\nDESCRIPTION: Specifies the TCP or UNIX socket address of the ABCI application or selects a built-in ABCI application. This parameter defines how CometBFT communicates with the blockchain application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nproxy_app = \"tcp://127.0.0.1:26658\"\n```\n\n----------------------------------------\n\nTITLE: Handling CheckTx Requests for Lane Assignment\nDESCRIPTION: Implementation of the CheckTx method that assigns transactions to appropriate lanes. The method uses a deterministic function to assign a lane ID based on transaction content.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/mempool-lanes.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *Application) CheckTx(ctx context.Context, req *types.CheckTxRequest) (*types.CheckTxResponse, error) {\n  ...\n  laneID := assignLane(req.Tx)\n  return &types.CheckTxResponse{Code: CodeTypeOK, GasWanted: 1, LaneId: laneID}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Transactions to CometBFT Node\nDESCRIPTION: Demonstrates how to send transactions to the CometBFT node using the broadcast_tx_commit RPC method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"abcd\"'\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"name=satoshi\"'\n```\n\n----------------------------------------\n\nTITLE: Defining Block Processor Structure and State Management in Go\nDESCRIPTION: Defines the Processor structure that maintains state for block processing including height cursor, blocks, and peer tracking. This structure allows efficient block processing and management of dependencies on peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ntype Processor struct {\n\theight int64 // the height cursor\n\tstate ...\n\tblocks [height]*Block\t // keep a set of blocks in memory until they are processed\n\tblockPeers [height]PeerID // keep track of which heights came from which peerID\n\tlastTouch timestamp\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Function for Message Retrieval in Go\nDESCRIPTION: This Go function implements the Query method for the ForumApp. It handles requests to fetch message history or messages from a specific sender, returning the results as JSON.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/4.query-message.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) Query(_ context.Context, query *abci.QueryRequest) (*abci.QueryResponse, error) {\n\tapp.logger.Info(\"Executing Application Query\")\n\n\tresp := abci.QueryResponse{Key: query.Data}\n\n\t// Parse sender from query data\n\tsender := string(query.Data)\n\n\tif sender == \"history\" {\n\t\tmessages, err := model.FetchHistory(app.state.DB)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresp.Log = messages\n\t\tresp.Value = []byte(messages)\n\n\t\treturn &resp, nil\n\t}\n\t// Retrieve all message sent by the sender\n\tmessages, err := model.GetMessagesBySender(app.state.DB, sender)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert the messages to JSON and return as query result\n\tresultBytes, err := json.Marshal(messages)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp.Log = string(resultBytes)\n\tresp.Value = resultBytes\n\n\treturn &resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Persistent Peers String for CometBFT Cluster\nDESCRIPTION: A Bash script to compile the persistent peers string needed for setting up a CometBFT cluster. It takes IP addresses as arguments and generates the required string format.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#!/bin/bash\n\n# Check if the required argument is provided\nif [ $# -eq 0 ]; then\n    echo \"Usage: $0 <ip1> <ip2> <ip3> ...\"\n    exit 1\nfi\n\n# Command to run on each IP\nBASE_COMMAND=\"cometbft show_node_id --home ./mytestnet/node\"\n\n# Initialize an array to store results\nPERSISTENT_PEERS=\"\"\n\n# Iterate through provided IPs\nfor i in \"${!@}\"; do\n    IP=\"${!i}\"\n    NODE_IDX=$((i - 1))  # Adjust for zero-based indexing\n\n    echo \"Getting ID of $IP (node $NODE_IDX)...\"\n\n    # Run the command on the current IP and capture the result\n    ID=$($BASE_COMMAND$NODE_IDX)\n\n    # Store the result in the array\n    PERSISTENT_PEERS+=\"$ID@$IP:26656\"\n\n    # Add a comma if not the last IP\n    if [ $i -lt $# ]; then\n        PERSISTENT_PEERS+=\",\"\n    fi\ndone\n\necho \"$PERSISTENT_PEERS\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Validator Node Parameters in TOML\nDESCRIPTION: Configuration settings for a CometBFT validator node specifying peer exchange settings, persistent peers, and security parameters to protect the validator from network attacks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/validators.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\npex = false\npersistent_peers = \"list of sentry nodes\"\nprivate_peer_ids = \"none\"\nunconditional_peer_ids = \"optionally sentry node IDs\"\naddr_book_strict = false\ndouble_sign_check_height = 10\n```\n\n----------------------------------------\n\nTITLE: Defining TimeoutParams Message in Protocol Buffers\nDESCRIPTION: The new TimeoutParams message structure to be added to the params.proto file, containing six timeout parameters that will replace the existing eight parameters in the config.toml. These parameters control various timeout behaviors in the Tendermint consensus algorithm.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-074-timeout-params.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage TimeoutParams {\n google.protobuf.Duration propose = 1;\n google.protobuf.Duration propose_delta = 2;\n google.protobuf.Duration vote = 3;\n google.protobuf.Duration vote_delta = 4;\n google.protobuf.Duration commit = 5;\n bool bypass_commit_timeout = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Proposed ABCI Application Interface in Go\nDESCRIPTION: The proposed simplified Application interface with DeliverBlock method that would allow for parallel transaction processing, along with the required request and response structures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-037-deliver-block.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Application interface {\n    // Info and Mempool methods...\n\n    // Consensus Connection\n    InitChain(RequestInitChain) ResponseInitChain           // Initialize blockchain with validators and other info from TendermintCore\n    DeliverBlock(RequestDeliverBlock) ResponseDeliverBlock  // Deliver full block\n    Commit() ResponseCommit                                 // Commit the state and return the application Merkle root hash\n}\n\ntype RequestDeliverBlock struct {\n    Hash                 []byte\n    Header               Header\n    Txs                  Txs\n    LastCommitInfo       LastCommitInfo\n    ByzantineValidators  []Evidence\n}\n\ntype ResponseDeliverBlock struct {\n    ValidatorUpdates      []ValidatorUpdate\n    ConsensusParamUpdates *ConsensusParams\n    Tags                  []kv.Pair\n    TxResults             []ResponseDeliverTx\n}\n```\n\n----------------------------------------\n\nTITLE: CheckTx Implementation for Transaction Validation\nDESCRIPTION: Implements the ABCI CheckTx method to validate incoming transactions before they are added to the mempool or broadcast to other nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) CheckTx(_ context.Context, check *abcitypes.CheckTxRequest) (*abcitypes.CheckTxResponse, error) {\n    code := app.isValid(check.Tx)\n    return &abcitypes.CheckTxResponse{Code: code}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block Signing Predicate (CMBC-FUNC-SIGN.1)\nDESCRIPTION: Defines the 'signs(b,c)' predicate, which holds true if the commit information in light block 'c' is a valid potential commit for the preceding light block 'b'. This essentially verifies the sequential link between two consecutive blocks based on validator signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-FUNC-SIGN.1]\n\nLet *b* and *c* be two light blocks with *b.Header.Height + 1 =\nc.Header.Height*. We define the predicate **signs(b,c)** to hold\niff *c.Header.LastCommit* is in *PossibleCommit(b)*.\n[[CMBC-SOUND-DISTR-POSS-COMMIT.1]][CMBC-SOUND-DISTR-POSS-COMMIT-link].\n```\n\n----------------------------------------\n\nTITLE: Implementing DB Interface for GoLevelDB in Go\nDESCRIPTION: Implementation of the DB interface for GoLevelDB, providing methods for basic operations like Get, Set, Delete, Close, along with database statistics and iteration capabilities.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/custom-db.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage goleveldb\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"github.com/syndtr/goleveldb/leveldb\"\n\t\"github.com/syndtr/goleveldb/leveldb/errors\"\n\t\"github.com/syndtr/goleveldb/leveldb/opt\"\n\t\"github.com/syndtr/goleveldb/leveldb/util\"\n)\n\ntype GoLevelDB struct {\n\tdb *leveldb.DB\n}\n\nfunc NewGoLevelDB(name string, dir string) (*GoLevelDB, error) {\n    dbPath := filepath.Join(dir, name+\".db\")\n\tdb, err := leveldb.OpenFile(dbPath, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdatabase := &GoLevelDB{\n\t\tdb: db,\n\t}\n\treturn database, nil\n}\n\n// Get implements DB.\nfunc (db *GoLevelDB) Get(key []byte) ([]byte, error) {\n\tif len(key) == 0 {\n\t\treturn nil, errKeyEmpty\n\t}\n\tres, err := db.db.Get(key, nil)\n\tif err != nil {\n\t\tif err == errors.ErrNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Has implements DB.\nfunc (db *GoLevelDB) Has(key []byte) (bool, error) {\n\tbytes, err := db.Get(key)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn bytes != nil, nil\n}\n\n// Set implements DB.\nfunc (db *GoLevelDB) Set(key []byte, value []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\tif value == nil {\n\t\treturn errValueNil\n\t}\n\terr := db.db.Put(key, value, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetSync implements DB.\nfunc (db *GoLevelDB) SetSync(key []byte, value []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\tif value == nil {\n\t\treturn errValueNil\n\t}\n\n\terr := db.db.Put(key, value, &opt.WriteOptions{Sync: true})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Delete implements DB.\nfunc (db *GoLevelDB) Delete(key []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\n\terr := db.db.Delete(key, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// DeleteSync implements DB.\nfunc (db *GoLevelDB) DeleteSync(key []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\terr := db.db.Delete(key, &opt.WriteOptions{Sync: true})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Close implements DB.\nfunc (db *GoLevelDB) Close() error {\n\treturn db.db.Close()\n}\n\n// Print implements DB.\nfunc (db *GoLevelDB) Print() error {\n\tstr, err := db.db.GetProperty(\"leveldb.stats\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Printf(\"%v\\n\", str)\n\n\titr := db.db.NewIterator(nil, nil)\n\tfor itr.Next() {\n\t\tkey := itr.Key()\n\t\tvalue := itr.Value()\n\t\tfmt.Printf(\"[%X]:\\t[%X]\\n\", key, value)\n\t}\n\treturn nil\n}\n\n// Stats implements DB.\nfunc (db *GoLevelDB) Stats() map[string]string {\n\tkeys := []string{\n\t\t\"leveldb.num-files-at-level{n}\",\n\t\t\"leveldb.stats\",\n\t\t\"leveldb.sstables\",\n\t\t\"leveldb.blockpool\",\n\t\t\"leveldb.cachedblock\",\n\t\t\"leveldb.openedtables\",\n\t\t\"leveldb.alivesnaps\",\n\t\t\"leveldb.aliveiters\",\n\t}\n\n\tstats := make(map[string]string)\n\tfor _, key := range keys {\n\t\tstr, err := db.db.GetProperty(key)\n\t\tif err == nil {\n\t\t\tstats[key] = str\n\t\t}\n\t}\n\treturn stats\n}\n\n// NewBatch implements DB.\nfunc (db *GoLevelDB) NewBatch() Batch {\n\treturn newGoLevelDBBatch(db)\n}\n\n\n//  Iterator implements DB.\nfunc (db *GoLevelDB) Iterator(start, end []byte) (Iterator, error) {\n\tif (start != nil && len(start) == 0) || (end != nil && len(end) == 0) {\n\t\treturn nil, errKeyEmpty\n\t}\n\titr := db.db.NewIterator(&util.Range{Start: start, Limit: end}, nil)\n\treturn newGoLevelDBIterator(itr, start, end, false), nil\n}\n\n// ReverseIterator implements DB.\nfunc (db *GoLevelDB) ReverseIterator(start, end []byte) (Iterator, error) {\n\tif (start != nil && len(start) == 0) || (end != nil && len(end) == 0) {\n\t\treturn nil, errKeyEmpty\n\t}\n\titr := db.db.NewIterator(&util.Range{Start: start, Limit: end}, nil)\n\treturn newGoLevelDBIterator(itr, start, end, true), nil\n}\n\n// Compact implements DB.\nfunc (db *GoLevelDB) Compact(start, end []byte) error {\n\treturn db.db.CompactRange(util.Range{Start: start, Limit: end})\n}\n```\n\n----------------------------------------\n\nTITLE: Preparing Block Proposals with PrepareProposal in Go\nDESCRIPTION: This function prepares a proposal for the next block in the blockchain. It filters transactions containing curse words, creates ban transactions for offending users, and ensures no transactions from banned users are included.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) PrepareProposal(_ context.Context, req *abci.PrepareProposalRequest) (*abci.PrepareProposalResponse, error) {\n\tapp.logger.Info(\"Executing Application PrepareProposal\")\n\n\t// Get the curse words from for all vote extensions received at the end of last height.\n\tvoteExtensionCurseWords := app.getWordsFromVe(req.LocalLastCommit.Votes)\n\n\tcurseWords := strings.Split(voteExtensionCurseWords, \"|\")\n\tif hasDuplicateWords(curseWords) {\n\t\treturn nil, errors.New(\"duplicate words found\")\n\t}\n\n\t// Prepare req puts the BanTx first, then adds the other transactions\n\t// ProcessProposal should verify this\n\tproposedTxs := make([][]byte, 0)\n\tfinalProposal := make([][]byte, 0)\n\tbannedUsersString := make(map[string]struct{})\n\tfor _, tx := range req.Txs {\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal tx in PrepareProposal: %w\", err)\n\t\t}\n\t\t// Adding the curse words from vote extensions too\n\t\tif !hasCurseWord(msg.Message, voteExtensionCurseWords) {\n\t\t\tproposedTxs = append(proposedTxs, tx)\n\t\t\tcontinue\n\t\t}\n\t\t// If the message contains curse words then ban the user by\n\t\t// creating a \"ban transaction\" and adding it to the final proposal\n\t\tbanTx := model.BanTx{UserName: msg.Sender}\n\t\tbannedUsersString[msg.Sender] = struct{}{}\n\t\tresultBytes, err := json.Marshal(banTx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the ban tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal ban tx in PrepareProposal: %w\", err)\n\t\t}\n\t\tfinalProposal = append(finalProposal, resultBytes)\n\t}\n\n\t// Need to loop again through the proposed Txs to make sure there is none left by a user that was banned\n\t// after the tx was accepted\n\tfor _, tx := range proposedTxs {\n\t\t// there should be no error here as these are just transactions we have checked and added\n\t\tmsg, err := model.ParseMessage(tx)\n\t\tif err != nil {\n\t\t\t// this should never happen since the tx should have been validated by CheckTx\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal tx in PrepareProposal: %w\", err)\n\t\t}\n\t\t// If the user is banned then include this transaction in the final proposal\n\t\tif _, ok := bannedUsersString[msg.Sender]; !ok {\n\t\t\tfinalProposal = append(finalProposal, tx)\n\t\t}\n\t}\n\treturn &abci.PrepareProposalResponse{Txs: finalProposal}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Committing Application State in CometBFT Forum App (Go)\nDESCRIPTION: Implements the Commit method to save the current application state. It commits the ongoing block changes and saves the state to persistent storage.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nfunc (app *ForumApp) Commit(_ context.Context, _ *abci.CommitRequest) (*abci.CommitResponse, error) {\n\tapp.logger.Info(\"Executing Application Commit\")\n\n\tif err := app.onGoingBlock.Commit(); err != nil {\n\t\treturn nil, err\n\t}\n\terr := saveState(&app.state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &abci.CommitResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LightBlock Data Type in Go\nDESCRIPTION: This snippet defines the `LightBlock` struct, which is a core data type in the light client verification protocol. It encapsulates a blockchain header, a commit, and a validator set. This structure is integral to handling the block verification logic.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype LightBlock struct {\n  Header          Header\n  Commit          Commit\n  Validators      ValidatorSet\n}\n```\n\n----------------------------------------\n\nTITLE: Adding GetSenders Method to Mempool Interface in Go\nDESCRIPTION: Extends the Mempool interface with a GetSenders method that returns a list of node IDs from which a transaction was received. This is crucial for tracking transaction propagation paths in the DOG protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// GetSenders returns the list of node IDs from which we have received a transaction.\nGetSenders(txKey types.TxKey) ([]p2p.ID, error)\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Module and Adding Dependencies\nDESCRIPTION: Initializes the Go module and adds CometBFT as a dependency.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngo mod init kvstore\n```\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/cometbft/cometbft@v1.0\n```\n\n----------------------------------------\n\nTITLE: Traversing Light Blocks Backwards for Historical Verification Chain - Go\nDESCRIPTION: Provides a full Go function, Backwards, that reconstructs a LightStore with verified blocks from a trusted root block down to a specified targetHeight by iteratively fetching blocks by decreasing height from a primary peer. It checks hash linkage between blocks, updating LightStore and tracking verification provenance. Inputs: primary peer (PeerID), root LightBlock, targetHeight (Height). Outputs: the constructed LightStore and a Result. Fails if block hashes do not match; otherwise, yields a chain of trust rooted at the supplied block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_22\n\nLANGUAGE: Go\nCODE:\n```\nfunc Backwards (primary PeerID, root LightBlock, targetHeight Height)\n               (LightStore, Result) {\n  \n    lb := root;\n    lightStore := new LightStore;\n    lightStore.Update(lb, StateTrusted, lb.verifiedBy)\n\n    latest := lb.Header\n    for i := lb.Header.height - 1; i >= targetHeight; i-- {\n        // here we download height-by-height. We might first download all\n        // headers down to targetHeight and then check them.\n        current := FetchLightBlock(primary,i)\n        if (hash(current) != latest.Header.LastBlockId) {\n            return (nil, ResultFailure)\n        }\n        else {\n            // latest and current are linked together by LastBlockId\n            // therefore it is not relevant which we verified first\n            // for consistency, we store latest was veried using\n            // current so that the verifiedBy is always pointing down\n            // the chain\n            lightStore.Update(current, StateTrusted, nil)\n            lightStore.Update(latest, StateTrusted, current.Header.Height)\n        }\n        latest = current\n    }\n    return (lightStore, ResultSuccess)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ProcessProposal Request and Response in Protobuf\nDESCRIPTION: Specifies the structure of the ProcessProposal request and response messages. The request includes details about the proposed block, while the response indicates whether the proposal is accepted or rejected.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ProcessProposalRequest {\n  repeated bytes txs = 1;\n  CommitInfo proposed_last_commit = 2;\n  repeated Misbehavior misbehavior = 3;\n  bytes hash = 4;\n  int64 height = 5;\n  google.protobuf.Timestamp time = 6;\n  bytes next_validators_hash = 7;\n  bytes proposer_address = 8;\n}\n\nmessage ProcessProposalResponse {\n  ProposalStatus status = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Scheduler Routine for Blockchain Message Handling in Go\nDESCRIPTION: Defines a scheduleRoutine function that handles blockchain-related scheduling by delegating to a scheduler component. It processes block response messages and other message types, sending resulting actions to the output channel.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc scheduleRoutine(input chan Message, output chan Message) {\n\tschelduer = NewScheduler(...)\n\tfor {\n\t\tmsg := <-msgs\n\t\tswitch msg := input.(type) {\n\t\t\tcase bcBlockResponseMessage:\n\t\t\t\toutput <- scheduler.handleBlockResponse(msg)\n\t\t\t...\n\t\t\tcase stop:\n\t\t\t\tschedule.stop()\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Application\nDESCRIPTION: Command to start the CometBFT application with the specified home directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n./kvstore -cmt-home /tmp/cometbft-home\n```\n\n----------------------------------------\n\nTITLE: Defining ConsensusParams and VersionParams messages in Protocol Buffers\nDESCRIPTION: These Protocol Buffers message definitions for ConsensusParams and VersionParams include fields for block_size, evidence_params, version, block_version, and app_version to communicate version updates through EndBlock in ABCI.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-016-protocol-versions.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ConsensusParams {\n\n  BlockSize block_size\n  EvidenceParams evidence_params\n  VersionParams version\n}\n\nmessage VersionParams {\n    uint64 block_version\n    uint64 app_version\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Initial Priority for New Validators (Pseudocode)\nDESCRIPTION: This pseudocode snippet specifies how the initial accumulated priority (`A(V)`) is calculated for a newly added validator (`V`). It is set to -1.125 times the total voting power (`P`) of the validator set (including the new validator `V`). This penalty prevents validators from gaining an unfair advantage by repeatedly leaving and rejoining the set and ensures they start further back in the metaphorical queue.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n    A(V) = -1.125 *  P\n```\n\n----------------------------------------\n\nTITLE: Committing Application State in Go\nDESCRIPTION: The function `Commit` ensures the persistence of application state changes which were implemented during the `FinalizeBlock` operation. It involves calling the `Commit` method on a transaction block (`app.onGoingBlock`), followed by saving the updated application state using the `saveState` function. This operation depends on functions and data structures capable of handling database commits and state persistence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/3.send-message.md#2025-04-22_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\n// Commit the application state.\nfunc (app *ForumApp) Commit(_ context.Context, _ *abci.CommitRequest) (*abci.CommitResponse, error) {\n\tapp.logger.Info(\"Executing Application Commit\")\n\n\tif err := app.onGoingBlock.Commit(); err != nil {\n\t\treturn nil, err\n\t}\n\terr := saveState(&app.state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &abci.CommitResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Current CListMempool Data Structure Fields in Golang\nDESCRIPTION: The current fields of the CListMempool data structure that store and provide access to transactions. These will be modified to support multiple lanes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-118-mempool-lanes.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\ntxs    *clist.CList // Concurrent list of mempool entries.\ntxsMap sync.Map     // Map of type TxKey -> *clist.CElement, for quick access to elements in txs.\n```\n\n----------------------------------------\n\nTITLE: Isolating Misbehaving Validators - Tendermint - Go\nDESCRIPTION: Implements the isolateMisbehavingProcesses function to identify and return the validator addresses likely responsible for a detected attack, according to the type of violation in the provided attack evidence. This function expects evidence and a blockchain prefix as input, determining the mode of attack (lunatic, equivocation, or amnesia) and computing the responsible validators using helper functions. It assumes certain blockchain conditions and checks, and will raise errors if preconditions are not satisfied.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc isolateMisbehavingProcesses(ev LightClientAttackEvidence, bc Blockchain) []ValidatorAddress {\n\n    reference := bc[ev.conflictingBlock.Header.Height].Header\n    ev_header := ev.conflictingBlock.Header\n\n    ref_commit := bc[ev.conflictingBlock.Header.Height + 1].Header.LastCommit // + 1 !!\n    ev_commit := ev.conflictingBlock.Commit\n\n    if violatesTMValidity(reference, ev_header) {\n        // lunatic light client attack\n        signatories := Signers(ev.ConflictingBlock.Commit)\n        bonded_vals := Addresses(bc[ev.CommonHeight].NextValidators)\n        return intersection(signatories,bonded_vals)\n\n    }\n    // If this point is reached the validator sets in reference and ev_header are identical\n    else if RoundOf(ref_commit) == RoundOf(ev_commit) {\n        // equivocation light client attack\n        return intersection(Signers(ref_commit), Signers(ev_commit))\n    }\n    else {\n        // amnesia light client attack\n        return IsolateAmnesiaAttacker(ev, bc)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Commit Structure with CommitSig in Go\nDESCRIPTION: The redesigned Commit structure with deduplicated fields and a new CommitSig type that includes only essential information, reducing block size significantly while maintaining necessary functionality.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-025-commit.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Commit struct {\n    Height  int64\n    Round   int\n    BlockID    BlockID      `json:\"block_id\"`\n    Precommits []CommitSig `json:\"precommits\"`\n}\n\ntype CommitSig struct {\n    BlockID  BlockIDFlag\n    ValidatorAddress Address\n    Timestamp time.Time\n    Signature []byte\n}\n\n\n// indicate which BlockID the signature is for\ntype BlockIDFlag int\n\nconst (\n\tBlockIDFlagAbsent BlockIDFlag = iota // vote is not included in the Commit.Precommits\n\tBlockIDFlagCommit                    // voted for the Commit.BlockID\n\tBlockIDFlagNil                       // voted for nil\n)\n```\n\n----------------------------------------\n\nTITLE: Querying Data from CometBFT Node\nDESCRIPTION: Shows how to query data from the CometBFT node using the abci_query RPC method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"abcd\"'\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"name\"'\n```\n\n----------------------------------------\n\nTITLE: Defining Transport Interface for P2P Communication in Go\nDESCRIPTION: Interface specification for the Transport abstraction that provides connection-oriented mechanisms for exchanging data with peers. It supports multiple protocols, endpoint discovery, accepting inbound connections, and initiating outbound connections.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Transport is a connection-oriented mechanism for exchanging data with a peer.\ntype Transport interface {\n    // Protocols returns the protocols supported by the transport. The Router\n    // uses this to pick a transport for an Endpoint.\n    Protocols() []Protocol\n\n    // Endpoints returns the local endpoints the transport is listening on, if any.\n    // How to listen is transport-dependent, e.g. MConnTransport uses Listen() while\n    // MemoryTransport starts listening via MemoryNetwork.CreateTransport().\n    Endpoints() []Endpoint\n\n    // Accept waits for the next inbound connection on a listening endpoint, blocking\n    // until either a connection is available or the transport is closed. On closure,\n    // io.EOF is returned and further Accept calls are futile.\n    Accept() (Connection, error)\n\n    // Dial creates an outbound connection to an endpoint.\n    Dial(context.Context, Endpoint) (Connection, error)\n\n    // Close stops accepting new connections, but does not close active connections.\n    Close() error\n}\n```\n\n----------------------------------------\n\nTITLE: Overall Reactor Interaction Sequence (ABNF)\nDESCRIPTION: This ABNF grammar provides a simplified overview of the expected sequence of method calls from the p2p layer to a single reactor. It outlines the main phases: registration, startup (`OnStart`), repeated peer management cycles, and shutdown (`OnStop`). It notes that `peer-management` represents interactions with a single peer, and multiple such interactions can occur concurrently for different peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_0\n\nLANGUAGE: abnf\nCODE:\n```\nstart           = registration on-start *peer-management on-stop\nregistration    = stream-descriptors set-switch\n\n; Refers to a single peer, a reactor must support multiple concurrent peers\npeer-management = init-peer start-peer stop-peer\nstart-peer      = [*receive] (connected-peer / start-error)\nconnected-peer  = add-peer *receive\nstop-peer       = [peer-error] remove-peer\n\n; Service interface\non-start           = %s\"OnStart()\"\non-stop            = %s\"OnStop()\"\n; Reactor interface\nstream-descriptors = %s\"StreamDescriptors()\"\nset-switch         = %s\"SetSwitch(*Switch)\"\ninit-peer          = %s\"InitPeer(Peer)\"\nadd-peer           = %s\"AddPeer(Peer)\"\nremove-peer        = %s\"RemovePeer(Peer, reason)\"\nreceive            = %s\"Receive(Envelope)\"\n\n; Errors, for reference\nstart-error     = %s\"log(Error starting peer)\"\npeer-error      = %s\"log(Stopping peer for error)\"\n```\n\n----------------------------------------\n\nTITLE: Generating Multi-Version Testnets with Specific Ratios in Shell\nDESCRIPTION: Uses the testnet generator (`./build/generator`) with the `-m` flag to create manifests for multi-version testnets. This specific command configures testnets where approximately 1/3rd of the nodes run CometBFT v0.34.21 and 2/3rds run v0.34.22. Output is directed to `networks/generated/`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n# Generate testnets randomly choosing between v0.34.21 (making up 1/3rd of the\n# network) and v0.34.22 (making up 2/3rds of the network).\n./build/generator -m \"v0.34.21:1,v0.34.22:2\" -d networks/generated/\n```\n\n----------------------------------------\n\nTITLE: Defining Sign/Skip Match Condition (CMBC-SIGN-SKIP-MATCH.1)\nDESCRIPTION: Defines the 'sign-skip-match(a,b,c,t)' property. It asserts that if a block 'a' is sequentially rooted ('sequ-rooted(a)') and two blocks 'b' and 'c' of the same height can both be verified from 'a' via skip-tracing ('skip-trace(a,b,t)' and 'skip-trace(a,c,t)'), then their headers must be identical ('b.Header = c.Header'). If this property evaluates to false, it indicates conflicting headers and thus an attack.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-SIGN-SKIP-MATCH.1]\n\nLet *a*, *b*, *c*, be light blocks and *t* a time, we define\n*sign-skip-match(a,b,c,t) = true* iff the following implication\nevaluates to true:\n\n- *sequ-rooted(a)* and\n- *b.Header.Height = c.Header.Height* and\n- *skip-trace(a,b,t)*\n- *skip-trace(a,c,t)*\n\nimplies *b.Header = c.Header*.\n```\n\n----------------------------------------\n\nTITLE: Define Core Light Client Data Structures in Go\nDESCRIPTION: This Go code defines the fundamental data structures used for light client verification. It includes structs for `Header` (block metadata like height, time, validator hashes), `SignedHeader` (header plus commit), `ValidatorSet` (list of validators and total power), `Validator` (individual validator details like address and voting power), and `TrustedState` (combining a signed header and its corresponding validator set). These structures are essential for representing and processing blockchain state within the light client protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n ```go\n   type Header struct {\n        Height               int64\n        Time                 Time          // the chain time when the header (block) was generated\n\n        LastBlockID          BlockID       // prev block info\n        ValidatorsHash       []byte        // hash of the validators for the current block\n        NextValidatorsHash   []byte        // hash of the validators for the next block\n   }\n\n   type SignedHeader struct {\n        Header        Header\n        Commit        Commit            // commit for the given header\n   }\n\n   type ValidatorSet struct {\n        Validators         []Validator\n        TotalVotingPower   int64\n   }\n\n   type Validator struct {\n        Address       Address           // validator address (we assume validator's addresses are unique)\n        VotingPower   int64             // validator's voting power\n   }\n\n   type TrustedState {\n        SignedHeader   SignedHeader\n        ValidatorSet   ValidatorSet\n   }\n ```\n```\n\n----------------------------------------\n\nTITLE: Connecting to CometBFT Peers via RPC\nDESCRIPTION: Example of using the /dial_seeds RPC endpoint to connect a running CometBFT node to seed nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\ncurl 'localhost:26657/dial_seeds?seeds=\\[\"f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656\",\"0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656\"\\]'\n```\n\n----------------------------------------\n\nTITLE: CometBFT Genesis Configuration File\nDESCRIPTION: Example of a genesis.json file used to initialize a CometBFT network, including validator information and chain details.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"validators\" : [\n    {\n      \"pub_key\" : {\n        \"value\" : \"h3hk+QE8c6QLTySp8TcfzclJw/BG79ziGB/pIA+DfPE=\",\n        \"type\" : \"tendermint/PubKeyEd25519\"\n      },\n      \"power\" : 10,\n      \"name\" : \"\"\n    }\n  ],\n  \"app_hash\" : \"\",\n  \"chain_id\" : \"test-chain-rDlYSN\",\n  \"genesis_time\" : \"0001-01-01T00:00:00Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI InitChain Method in Go\nDESCRIPTION: Implements the InitChain method of the ABCI interface. It initializes the blockchain with information sent from CometBFT, such as validators and consensus parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) InitChain(_ context.Context, req *abci.InitChainRequest) (*abci.InitChainResponse, error) {\n\tapp.logger.Info(\"Executing Application InitChain\")\n\n\tfor _, v := range req.Validators {\n\t\terr := app.updateValidator(v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tappHash := app.state.Hash()\n\n\t// This parameter can also be set in the genesis file\n\treq.ConsensusParams.Feature.VoteExtensionsEnableHeight.Value = 1\n\treturn &abci.InitChainResponse{ConsensusParams: req.ConsensusParams, AppHash: appHash}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Message to Peer in Go\nDESCRIPTION: This method sends a message to the peer, blocking for up to 10 seconds if the channel's send queue is full.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) Send(e Envelope) bool\n```\n\n----------------------------------------\n\nTITLE: Running a Simple CometBFT 4-Node E2E Test (Shell)\nDESCRIPTION: Executes a basic 4-node end-to-end test scenario. This involves changing to the `test/e2e` directory, building the test runner using `make`, and then running the test defined in the `networks/simple.toml` configuration file using the built runner executable (`./build/runner`) with the `-f` flag specifying the file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd test/e2e\nmake && ./build/runner -f networks/simple.toml\n```\n\n----------------------------------------\n\nTITLE: Snapshot Store Interface in Golang\nDESCRIPTION: Defines the interface for a snapshot store that applications must implement to support local state sync. This interface provides methods for managing snapshots including saving, loading, listing, and deleting snapshots and their chunks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-104-out-of-band-state-sync.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\n// Delete a snapshot for a certain height\nfunc (s *Store) Delete(height uint64, format uint32) error\n\n// Retrieves a snapshot for a certain height\nfunc (s *Store) Get(height uint64, format uint32) (*Snapshot, error)\n\n// List recent snapshots, in reverse order (newest first)\nfunc (s *Store) List() ([]*Snapshot, error)\n\n// Loads a snapshot (both metadata and binary chunks). The chunks must be consumed and closed.\n// Returns nil if the snapshot does not exist.\nfunc (s *Store) Load(height uint64, format uint32) (*Snapshot, <-chan io.ReadCloser, error)\n\n// LoadChunk loads a chunk from disk, or returns nil if it does not exist. The caller must call\n// Close() on it when done.\nfunc (s *Store) LoadChunk(height uint64, format, chunk uint32) (io.ReadCloser, error)\n\n// Save saves a snapshot to disk, returning it.\nfunc (s *Store) Save(height uint64, format uint32, chunks <-chan io.ReadCloser) (*Snapshot, error)\n\n// PathChunk generates a snapshot chunk path.\nfunc (s *Store) PathChunk(height uint64, format, chunk uint32) string\n```\n\n----------------------------------------\n\nTITLE: Configuring DOG Protocol\nDESCRIPTION: Setting to enable/disable the DOG gossip protocol for transaction dissemination.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_69\n\nLANGUAGE: toml\nCODE:\n```\ndog_protocol_enabled = true\n```\n\n----------------------------------------\n\nTITLE: Subscribing to NewBlock Events\nDESCRIPTION: JSON-RPC request to subscribe to NewBlock events through the Websocket connection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/subscription.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe\",\n    \"id\": 0,\n    \"params\": {\n        \"query\": \"tm.event='NewBlock'\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactor Demultiplexing Routine in Go\nDESCRIPTION: Defines a demuxRoutine function that distributes messages to different processing components while acting as a pacemaker for time-based events. It handles incoming messages and time check events, routing them to scheduler, processor, and IO message queues.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc demuxRoutine(msgs, scheduleMsgs, processorMsgs, ioMsgs) {\n\ttimer := time.NewTicker(interval)\n\tfor {\n\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\tnow := evTimeCheck{time.Now()}\n\t\t\t\tschedulerMsgs <- now\n\t\t\t\tprocessorMsgs <- now\n\t\t\t\tioMsgs <- now\n\t\t\tcase msg:= <- msgs:\n\t\t\t\tmsg.time = time.Now()\n\t\t\t\t// These channels should produce backpressure before\n\t\t\t\t// being full to avoid starving each other\n\t\t\t\tschedulerMsgs <- msg\n\t\t\t\tprocessorMsgs <- msg\n\t\t\t\tioMesgs <- msg\n\t\t\t\tif msg == stop {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Lanes and Priorities in Go Application\nDESCRIPTION: Example of defining lane IDs and their priorities within an Application struct. The code shows how to set up a map of lane priorities and define a default lane constant.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/mempool-lanes.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nconst defaultLane = \"C\"\n\ntype Application struct {\n  ...\n  lanePriorities map[string]uint32\n}\n\nfunc NewApplication(...) *Application {\n  ...\n  return &Application{\n    ...\n    lanePriorities: map[string]uint32{\n      \"A\": 100,\n      \"B\": 50,\n      defaultLane: 10,\n      \"D\": 1,\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying CometBFT Installation\nDESCRIPTION: This command checks the installed version of CometBFT to verify the installation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncometbft version\n```\n\n----------------------------------------\n\nTITLE: Defining Validator Message Structure in Protobuf\nDESCRIPTION: Updates the Validator message to include an address field along with the existing pub_key and power fields.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-009-ABCI-design.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Validator {\n    bytes address\n    PubKey pub_key\n    int64 power\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PeerUpdates Subscription System for CometBFT P2P Events\nDESCRIPTION: The PeerUpdates system provides a subscription mechanism for peer status updates. It allows reactors to receive real-time notifications about peer connections and disconnections in an ordered, guaranteed fashion.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// Subscribe subscribes to peer updates. The caller must consume the peer updates\n// in a timely fashion and close the subscription when done, to avoid stalling the\n// PeerManager as delivery is semi-synchronous, guaranteed, and ordered.\nfunc (m *PeerManager) Subscribe() *PeerUpdates\n\n// PeerUpdate is a peer update event sent via PeerUpdates.\ntype PeerUpdate struct {\n    NodeID NodeID\n    Status PeerStatus\n}\n\n// PeerStatus is a peer status.\ntype PeerStatus string\n\nconst (\n    PeerStatusUp   PeerStatus = \"up\"   // Connected and ready.\n    PeerStatusDown PeerStatus = \"down\" // Disconnected.\n)\n\n// PeerUpdates is a real-time peer update subscription.\ntype PeerUpdates struct { ... }\n\n// Updates returns a channel for consuming peer updates.\nfunc (pu *PeerUpdates) Updates() <-chan PeerUpdate\n\n// Close closes the peer updates subscription.\nfunc (pu *PeerUpdates) Close()\n```\n\n----------------------------------------\n\nTITLE: Connecting LightBlocks for Trust Verification in LightStore - Go\nDESCRIPTION: Drafts a function to find and return a LightBlock from the LightStore of lower height than specified, which can be directly verified by a given LightBlock. This is essential to maintain the chain of trust when traversing forks or divergences and supports light client logic for block validation. Inputs are light store, a reference block, and target height. Assumes all verified lightblocks form an uninterrupted chain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc Connector (lightStore LightStore, lb LightBlock, h Height) (LightBlock, bool)\n\n```\n\n----------------------------------------\n\nTITLE: Defining PotentialAmnesiaEvidence Structure in Golang\nDESCRIPTION: This structure represents potential evidence of amnesia attacks where a validator has voted in more than one round for a different block. It contains two votes from the same validator for different blocks and a timestamp.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-056-light-client-amnesia-attacks.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\ntype PotentialAmnesiaEvidence struct {\n\tVoteA *types.Vote\n\tVoteB *types.Vote\n\n\tHeightstamp int64\n}\n```\n\n----------------------------------------\n\nTITLE: Commit Implementation for State Persistence\nDESCRIPTION: Implements the ABCI Commit method to finalize and persist state changes by committing the BadgerDB transaction.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc (app KVStoreApplication) Commit(_ context.Context, commit *abcitypes.CommitRequest) (*abcitypes.CommitResponse, error) {\n    return &abcitypes.CommitResponse{}, app.onGoingBlock.Commit()\n}\n```\n\n----------------------------------------\n\nTITLE: Adding BadgerDB Dependency and Constructor Update in Go\nDESCRIPTION: This snippet shows how to set up the BadgerDB dependency and update the application's constructor to handle database operations. Dependencies include BadgerDB libraries, and it requires initializing the `KVStoreApplication` structure with a BadgerDB instance. The constructor sets up the application to track database transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype KVStoreApplication struct {\n    db           *badger.DB\n    onGoingBlock *badger.Txn\n}\n\nvar _ abcitypes.Application = (*KVStoreApplication)(nil)\n\nfunc NewKVStoreApplication(db *badger.DB) *KVStoreApplication {\n    return &KVStoreApplication{db: db}\n}\n```\n\nLANGUAGE: go\nCODE:\n```\nimport(\n    \"context\"\n    abcitypes \"github.com/cometbft/cometbft/abci/types\"\n    \"github.com/dgraph-io/badger/v4\"\n)\n```\n\nLANGUAGE: go\nCODE:\n```\n_ = NewKVStoreApplication(nil)\n```\n\n----------------------------------------\n\nTITLE: Implementing Events in FinalizeBlockResponse with Go\nDESCRIPTION: Example of how to structure Events in a FinalizeBlockResponse in Go. Shows how to create multiple events with different types and attributes, demonstrating the flexible event system for block metadata.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_basic_concepts.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nabci.FinalizeBlockResponse{\n // ...\nEvents: []abci.Event{\n {\n  Type: \"validator.provisions\",\n  Attributes: []abci.EventAttribute{\n   abci.EventAttribute{Key: \"address\", Value: \"...\", Index: true},\n   abci.EventAttribute{Key: \"amount\", Value: \"...\", Index: true},\n   abci.EventAttribute{Key: \"balance\", Value: \"...\", Index: true},\n  },\n },\n {\n  Type: \"validator.provisions\",\n  Attributes: []abci.EventAttribute{\n   abci.EventAttribute{Key: \"address\", Value: \"...\", Index: true},\n   abci.EventAttribute{Key: \"amount\", Value: \"...\", Index: false},\n   abci.EventAttribute{Key: \"balance\", Value: \"...\", Index: false},\n  },\n },\n {\n  Type: \"validator.slashed\",\n  Attributes: []abci.EventAttribute{\n   abci.EventAttribute{Key: \"address\", Value: \"...\", Index: false},\n   abci.EventAttribute{Key: \"amount\", Value: \"...\", Index: true},\n   abci.EventAttribute{Key: \"reason\", Value: \"...\", Index: true},\n  },\n },\n // ...\n},\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a StateObserver Interface in Go for CometBFT\nDESCRIPTION: Implementation of a strongly typed event observer interface for consensus state, replacing the generic pub/sub mechanism with compile-time guarantees. Each method corresponds to a specific event type without returning errors, following a fire-and-forget pattern.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\npackage consensus\n\n// StateObserver is specific to the consensus.State struct, and all of its\n// methods are called from within consensus.State instead of using an \"event\n// bus\". This allows for greater compile-time guarantees through doing away with\n// the generic pub/sub mechanism in the event bus.\n//\n// Note how all methods are infallible (i.e. they do not return any errors).\n// This is functionally equivalent to the fire-and-forget pattern implemented by\n// the event bus.\n//\n// Also note how method names are prefixed by the name of the relevant producer\n// of events (in this case \"ConsensusState\", corresponding to the\n// consensus.State struct). This is intentional to allow composition of\n// observers of multiple different components without function names clashing.\n//\n// Finally, given that this is just straightforward Go, it is up to either the\n// caller or the callee to decide how to handle the concurrency of certain\n// events. The event bus approach, by contrast, is always concurrent and relies\n// on Go channels, which could end up filling up and causing back-pressure into\n// the caller (already observed in slow WebSocket subscribers).\ntype StateObserver interface {\n    ConsensusStateNewRoundStep(ev EventDataRoundState)\n    ConsensusStateTimeoutPropose(ev EventDataRoundState)\n    ConsensusStateTimeoutWait(ev EventDataRoundState)\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Status Response Event in FastSync Controller\nDESCRIPTION: This function handles the status response event from a peer. It updates the peer's stats, potentially sends a block request, and manages timeouts based on the current state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_21\n\nLANGUAGE: go\nCODE:\n```\nfunc handleEventStatusResponse(event EventStatusResponse, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error) {\n  if _, ok := state.PeerMap[event.PeerID]; !ok {\n    peerStats = PeerStats{ -1, -1 }\n  } else {\n    peerStats = state.PeerMap[event.PeerID]\n  }\n\n  if event.Height > peerStats.Height { peerStats.Height = event.Height }\n  // if there are no pending requests for this peer, try to send him a request for block\n  if peerStats.PendingRequest == -1 {\n    msg = createBlockRequestMessages(state, event.PeerID, peerStats.Height)\n    // msg is nil if no request for block can be made to a peer at this point in time\n    if msg != nil {\n      peerStats.PendingRequests = msg.Height\n      state.PendingRequestsNum++\n      // when a request for a block is sent to a peer, a response timeout is triggered. If no corresponding block is sent by the peer\n      // during response timeout period, then the peer is considered faulty and is removed from the peer set.\n      timeout = ResponseTimeoutTrigger{ msg.PeerID, msg.Height, PeerTimeout }\n    } else if state.PendingRequestsNum == 0 {\n      // if there are no pending requests and no new request can be placed to the peer, termination timeout is triggered.\n      // If termination timeout expires and we are still at the same height and there are no pending requests, the \"fast-sync\"\n      // mode is finished and we switch to `ModeConsensus`.\n      timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }\n    }\n  }\n  state.PeerMap[event.PeerID] = peerStats\n  return state, msg, timeout, error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PeerBehaviour Interface in Go\nDESCRIPTION: This snippet defines the PeerBehaviour interface with methods for signaling good and error behaviors of peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-039-peer-behaviour.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype PeerBehaviour interface {\n    Behaved(peer Peer, reason GoodBehaviourPeer)\n    Errored(peer Peer, reason ErrorBehaviourPeer)\n}\n```\n\n----------------------------------------\n\nTITLE: Vote Verification in Go\nDESCRIPTION: Method to verify a vote signature against a public key using the chain ID. Validates the validator address and signature bytes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc (vote *Vote) Verify(chainID string, pubKey crypto.PubKey) error {\n if !bytes.Equal(pubKey.Address(), vote.ValidatorAddress) {\n  return ErrVoteInvalidValidatorAddress\n }\n v := vote.ToProto()\n if !pubKey.VerifyBytes(types.VoteSignBytes(chainID, v), vote.Signature) {\n  return ErrVoteInvalidSignature\n }\n return nil\n}\n```\n\n----------------------------------------\n\nTITLE: VerifyVoteExtension Request/Response Protocol Definition\nDESCRIPTION: Defines the protocol buffer message structure for VerifyVoteExtension requests and responses. The request includes block hash, validator address, height, and vote extensions. The response includes a verification status.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_8\n\nLANGUAGE: protobuf\nCODE:\n```\n// Request\nMessage VerifyVoteExtensionRequest {\n    bytes hash = 1;                    // Block hash\n    bytes validator_address = 2;       // Validator address\n    int64 height = 3;                 // Block height\n    bytes vote_extension = 4;          // Vote extension data\n    bytes non_rp_vote_extension = 5;   // Non-replicated vote extension\n}\n\n// Response \nMessage VerifyVoteExtensionResponse {\n    VerifyStatus status = 1;           // Accept/Reject status\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Unconditional Peer IDs in CometBFT (TOML)\nDESCRIPTION: Specifies a list of node IDs that are allowed to connect even when connection limits are exceeded. These peers don't count towards the inbound or outbound peer limits.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_48\n\nLANGUAGE: toml\nCODE:\n```\nunconditional_peer_ids = \"\"\n```\n\n----------------------------------------\n\nTITLE: Getting Block Retain Height in CometBFT\nDESCRIPTION: Go code example demonstrating how to retrieve the current block retain height using the privileged gRPC client in CometBFT. This returns both the application and pruning service retain heights.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nretainHeight, err := conn.GetBlockRetainHeight(ctx)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with\n    // `retainHeight.App`\n    // `retainHeight.PruningService`\n}\n```\n\n----------------------------------------\n\nTITLE: Peer Banning Logic in CometBFT Mempool (Go)\nDESCRIPTION: This function implements the logic for banning peers based on their history of sending invalid transactions. It tracks the number of failures and the time of the last failure, potentially triggering a ban request to the p2p layer if the threshold is reached.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-101-p2p-bad-peers-checktx.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\nfunc (mem* ClistMempool) banPeer(peerID NodeID) {\n    numFails := 0\n      // Check whether this peer has sent us transactions that fail\n    if val, ok := mem.peerFailureMap[peerID]; ok {\n      lastFailureT := val.lastFailure\n      numFails = val.numFails\n    // if the failure was recent enough, update the number of failures and\n    // ban peer if applicable\n    if time.Since(lastFailureT) <= failureResetInterval {\n      if numFails == maxAllowedFailures - 1 {\n          // Send Ban request to p2p\n        }\n      }\n    }\n    // Update the time of the last failure\n    mem.peerFailureMap[peerID] = { time.Now(), numFailures + 1}\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Peer Exchange (PEX) Reactor in CometBFT (TOML)\nDESCRIPTION: Enables or disables the peer exchange (PEX) reactor. When enabled, nodes can exchange addresses of potential peers. Disabled nodes can only connect to configured persistent peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_53\n\nLANGUAGE: toml\nCODE:\n```\npex = true\n```\n\n----------------------------------------\n\nTITLE: Defining TrustOptions Structure in Go for Weak Subjectivity\nDESCRIPTION: This code snippet defines the TrustOptions structure used to initialize a light client with weak subjectivity. It includes fields for trust period, trust height, trust hash, and a callback function for confirmation steps.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-044-lite-client-with-weak-subjectivity.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype TrustOptions struct {\n    // Required: only trust commits up to this old.\n    // Should be equal to the unbonding period minus some delta for evidence reporting.\n    TrustPeriod time.Duration `json:\"trust-period\"`\n\n    // Option 1: TrustHeight and TrustHash can both be provided\n    // to force the trusting of a particular height and hash.\n    // If the latest trusted height/hash is more recent, then this option is\n    // ignored.\n    TrustHeight int64  `json:\"trust-height\"`\n    TrustHash   []byte `json:\"trust-hash\"`\n\n    // Option 2: Callback can be set to implement a confirmation\n    // step if the trust store is uninitialized, or expired.\n    Callback func(height int64, hash []byte) error\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Light Client Attacks in Golang\nDESCRIPTION: Detects light client attacks by comparing a trace of verified light blocks from a primary peer against a witness peer. This process identifies conflicting headers and constructs a trace of attack evidence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/notes-on-evidence-handling.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc DetectLightClientAttacks(primary PeerID,\n                              primary_trace []LightBlock,\n                              witness PeerID) (LightClientAttackEvidence, LightClientAttackEvidence) {\n    primary_lca_evidence, witness_trace = DetectLightClientAttack(primary_trace, witness)\n\n    witness_lca_evidence = nil\n    if witness_trace != nil {\n        witness_lca_evidence, _ = DetectLightClientAttack(witness_trace, primary)\n    }\n    return primary_lca_evidence, witness_lca_evidence\n}\n\nfunc DetectLightClientAttack(trace []LightBlock, peer PeerID) (LightClientAttackEvidence, []LightBlock) {\n\n    lightStore = new LightStore().Update(trace[0], StateTrusted)\n\n    for i in 1..len(trace)-1 {\n        lightStore, result = VerifyToTarget(peer, lightStore, trace[i].Header.Height)\n\n        if result == ResultFailure then return (nil, nil)\n\n        current = lightStore.Get(trace[i].Header.Height)\n\n        // if obtained header is the same as in the trace we continue with a next height\n        if current.Header == trace[i].Header continue\n\n        // we have identified a conflicting header\n        commonBlock = trace[i-1]\n        conflictingBlock = trace[i]\n\n        return (LightClientAttackEvidence { conflictingBlock, commonBlock.Header.Height },\n                Trace(lightStore, trace[i-1].Header.Height, trace[i].Header.Height))\n    }\n    return (nil, nil)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PrepareProposal Request and Response Parameters in Protobuf\nDESCRIPTION: Protobuf-style definition of the request and response parameters for the PrepareProposal method. It includes field types, descriptions, and field numbers for both request and response.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage PrepareProposalRequest {\n  int64 max_tx_bytes = 1;\n  repeated bytes txs = 2;\n  ExtendedCommitInfo local_last_commit = 3;\n  repeated Misbehavior misbehavior = 4;\n  int64 height = 5;\n  google.protobuf.Timestamp time = 6;\n  bytes next_validators_hash = 7;\n  bytes proposer_address = 8;\n}\n\nmessage PrepareProposalResponse {\n  repeated bytes txs = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating LocalClient in Go\nDESCRIPTION: Function to create a new LocalClient instance. This client provides full mutex protection for all ABCI calls, ensuring thread safety for applications that are not thread-safe.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/abci-clients.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc NewLocalClient(mtx *cmtsync.Mutex, app types.Application) Client\n```\n\n----------------------------------------\n\nTITLE: Response Format for CometBFT API Results\nDESCRIPTION: Example of a standard JSON-RPC 2.0 response structure from the CometBFT API, including block height, gas usage, transaction results, events, validator updates, and consensus parameter updates.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"height\": \"12\",\n    \"total_gas_used\": \"100\",\n    \"txs_results\": [\n      {\n        \"code\": \"0\",\n        \"data\": \"\",\n        \"log\": \"not enough gas\",\n        \"info\": \"\",\n        \"gas_wanted\": \"100\",\n        \"gas_used\": \"100\",\n        \"events\": [\n          {\n            \"type\": \"app\",\n            \"attributes\": [\n              {\n                \"key\": \"YWN0aW9u\",\n                \"value\": \"c2VuZA==\",\n                \"index\": false\n              }\n            ]\n          }\n        ],\n        \"codespace\": \"ibc\"\n      }\n    ],\n    \"begin_block_events\": [\n      {\n        \"type\": \"app\",\n        \"attributes\": [\n          {\n            \"key\": \"YWN0aW9u\",\n            \"value\": \"c2VuZA==\",\n            \"index\": false\n          }\n        ]\n      }\n    ],\n    \"end_block\": [\n      {\n        \"type\": \"app\",\n        \"attributes\": [\n          {\n            \"key\": \"YWN0aW9u\",\n            \"value\": \"c2VuZA==\",\n            \"index\": false\n          }\n        ]\n      }\n    ],\n    \"validator_updates\": [\n      {\n        \"pub_key\": {\n          \"type\": \"tendermint/PubKeyEd25519\",\n          \"value\": \"9tK9IT+FPdf2qm+5c2qaxi10sWP+3erWTKgftn2PaQM=\"\n        },\n        \"power\": \"300\"\n      }\n    ],\n    \"consensus_params_updates\": {\n      \"block\": {\n        \"max_bytes\": \"22020096\",\n        \"max_gas\": \"1000\",\n        \"time_iota_ms\": \"1000\"\n      },\n      \"evidence\": {\n        \"max_age\": \"100000\"\n      },\n      \"validator\": {\n        \"pub_key_types\": [\n          \"ed25519\"\n        ]\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Connections in Shell\nDESCRIPTION: This snippet shows the log output when CometBFT starts three connections (mempool, consensus, and query) to the application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:27.364] Starting multiAppConn                        module=proxy impl=multiAppConn\nI[10-04|13:54:27.366] Starting localClient                         module=abci-client connection=query impl=localClient\nI[10-04|13:54:27.366] Starting localClient                         module=abci-client connection=mempool impl=localClient\nI[10-04|13:54:27.367] Starting localClient                         module=abci-client connection=consensus impl=localClient\n```\n\n----------------------------------------\n\nTITLE: Defining Block Structure with Transaction Replacements in Protocol Buffers\nDESCRIPTION: This code snippet defines a Protocol Buffers message structure for a Block that includes transaction replacements. It introduces a new Replacement message type to track replaced transactions within a block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-015-abci++-tx-mutation.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Block {\n...\n  repeated Replacement replacements = 5;\n}\n\nmessage Replacement {\n  bytes          included_tx_key   = 1;\n  repeated bytes replaced_txs_keys = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages to All Peers - CometBFT Switch API - Go\nDESCRIPTION: Broadcast(e Envelope) allows a reactor to asynchronously send a message to all connected peers. The method returns a channel of booleans indicating the send success for each peer. This operation is not blocking and internally creates background threads for each send. It depends on Envelope and Peer.Send(e) being compatible; note that the result channel's outputs cannot be directly mapped to specific peers and message marshalling is not optimized.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) Broadcast(e Envelope) chan bool\n```\n\n----------------------------------------\n\nTITLE: Defining BatchVerifier Interface in Go\nDESCRIPTION: This code snippet defines the BatchVerifier interface with Add and Verify methods for batch verification of signatures. It allows adding entries (public key, signature, and message) and verifying them in batch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-064-batch-verification.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype BatchVerifier interface {\n  Add(key crypto.Pubkey, signature, message []byte) error // Add appends an entry into the BatchVerifier.\n  Verify() bool // Verify verifies all the entries in the BatchVerifier. If the verification fails it is unknown which entry failed and each entry will need to be verified individually.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Updated DuplicateVoteEvidence Struct in Go\nDESCRIPTION: This code shows the updated DuplicateVoteEvidence struct with additional fields for ABCI-specific information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype DuplicateVoteEvidence {\n  VoteA *Vote\n  VoteB *Vote\n\n  // abci specific information\n\tTotalVotingPower int64\n\tValidatorPower   int64\n\tTimestamp        time.Time\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Incoming Transactions in Mempool\nDESCRIPTION: Models the action for receiving transactions from users. Ensures transactions don't already exist in the mempool and integrates them using a specified function.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_11\n\nLANGUAGE: bluespec\nCODE:\n```\naction receiveTxFromUser(node, tx, _tryAddTx) =\n    node._tryAddTx(incomingMsgs, None, tx)\n```\n\n----------------------------------------\n\nTITLE: Defining LightClientAttackEvidence Structure in Go\nDESCRIPTION: This code snippet defines a structure for light client attack evidence. It contains a conflicting block and the common height where the divergence occurred.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n\tConflictingBlock *LightBlock\n\tCommonHeight     int64\n}\n```\n\n----------------------------------------\n\nTITLE: Forum Application Directory Structure\nDESCRIPTION: The directory structure for the ABCI 2.0 Forum Application showing the organization of source files across different packages including abci implementation, models, and configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/2.intro-forumApp.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n- abci\n    - app.go\n    - config.go\n    - state.go\n    - util.go\n- model\n    - db.go\n    - messages.go\n    - user.go\n- forum.go\n- app.toml\n```\n\n----------------------------------------\n\nTITLE: Querying Block Results in CometBFT (HTTP Request)\nDESCRIPTION: This snippet demonstrates how to query block results using an HTTP GET request to the CometBFT API. It shows both the default request for the latest block results and a request for a specific block height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/block_results\n\n\ncurl  http://127.0.0.1:26657/v1/block_results?height=1\n```\n\n----------------------------------------\n\nTITLE: Implementing Block Response Handler in Processor in Go\nDESCRIPTION: Defines the handleBlockResponse method that processes incoming blocks, verifies them, and applies them to the state. It manages the internal height cursor and tracks which blocks were received from which peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc (proc *Processor) handleBlockResponse(peerID, block) {\n    if block.height <= height || block[block.height] {\n\t} else if blocks[block.height] {\n\t\treturn errDuplicateBlock{}\n\t} else  {\n\t\tblocks[block.height] = block\n\t}\n\n\tif blocks[height] && blocks[height+1] {\n\t\t... = state.Validators.VerifyCommit(...)\n\t\t... = store.SaveBlock(...)\n\t\tstate, err = blockExec.ApplyBlock(...)\n\t\t...\n\t\tif err == nil {\n\t\t\tdelete blocks[height]\n\t\t\theight++\n\t\t\tlastTouch = msg.time\n\t\t\treturn pcBlockProcessed{height-1}\n\t\t} else {\n\t\t\t... // Delete all unprocessed block from the peer\n\t\t\treturn pcBlockProcessError{peerID, height}\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: LightBlockResponse Protocol Buffer Message Definition\nDESCRIPTION: Protocol buffer message definition for the response containing a light block with header, commit, and validator set data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\nmessage LightBlockResponse {\n  Header header = 1;\n  Commit commit = 2;\n  ValidatorSet validator_set = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StartRound Function in PBTS Algorithm\nDESCRIPTION: Function that initiates a new consensus round with time synchronization. Handles block time checking, proposal creation, and timeout scheduling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts-algorithm_001_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunction StartRound(round) {\n  blockTime ← block time of block h_p - 1\n  waitingTime ← blockTime + 2 * ACCURACY + MSGDELAY - now_p\n  round_p ← round\n  step_p ← propose\n  if proposer(h_p, round_p) = p {\n    wait until now_p > blockTime // new wait condition\n    if validValue_p != nil {\n      proposal ← (validValue_p, now_p) // added \"now_p\"\n    }\n    else {\n      proposal ← (getValue(), now_p)   // added \"now_p\"\n    }\n    broadcast ⟨PROPOSAL, h_p, round_p, proposal, validRound_p⟩\n  }\n  else {\n    schedule OnTimeoutPropose(h_p,round_p) to be executed after max(timeoutPropose(round_p), waitingTime)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Response\nDESCRIPTION: These commands decode the base64-encoded key and value from the query response.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\necho \"Y29tZXRiZnQ=\" | base64 -d\necho \"cm9ja3M=\" | base64 -d\n```\n\n----------------------------------------\n\nTITLE: Declaring FetchLightBlock Function Signature in Go\nDESCRIPTION: Defines the Go signature for the `FetchLightBlock` function, responsible for retrieving a complete `LightBlock` from a specified peer. It takes a `PeerID` and `Height`, performs RPC calls using `Commit` and `Validators` internally, and returns the resulting `LightBlock`. The description covers preconditions, postconditions based on peer correctness (returning a consistent or arbitrary block), and error conditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_15\n\nLANGUAGE: go\nCODE:\n```\nfunc FetchLightBlock(peer PeerID, height Height) LightBlock\n```\n\n----------------------------------------\n\nTITLE: Executing CometBFT Debug Dump Command\nDESCRIPTION: Command to periodically dump debugging data into compressed archives. Requires output directory path and home directory as parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncometbft debug dump </path/to/out> --home=</path/to/app.d>\n```\n\n----------------------------------------\n\nTITLE: Trust Period Verification Formula\nDESCRIPTION: Formula defining the trust period validation check for validator sets. It specifies when a validator set can be trusted based on header time.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\nh.Time + TRUSTED_PERIOD > now\n```\n\n----------------------------------------\n\nTITLE: Defining Block Header Structure in Protobuf\nDESCRIPTION: Header message definition containing block metadata including version, chain ID, height, timestamps, and various hashes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Header {\n  tendermint.version.Consensus version              = 1;\n  string                       chain_id             = 2;\n  int64                        height               = 3;\n  google.protobuf.Timestamp    time                 = 4;\n  BlockID                      last_block_id        = 5;\n  bytes                        last_commit_hash     = 6;\n  bytes                        data_hash            = 7;\n  bytes                        validators_hash      = 8;\n  bytes                        next_validators_hash = 9;\n  bytes                        consensus_hash       = 10;\n  bytes                        app_hash             = 11;\n  bytes                        last_results_hash    = 12;\n  bytes                        evidence_hash        = 13;\n  bytes                        proposer_address     = 14;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data by Hash in CometBFT (JSONRPC Request)\nDESCRIPTION: This snippet shows how to query a block by its hash using a JSONRPC POST request to the CometBFT API. It includes the full JSON payload for the request.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"block_by_hash\\\",\\\"params\\\":{\\\"hash\\\":\\\"0xD70952032620CC4E2737EB8AC379806359D8E0B17B0488F627997A0B043ABDED\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Backwards Light Client Verification in Go\nDESCRIPTION: Function that performs backwards verification of light blocks from a minimum verified height down to a target height. It downloads and verifies blocks height-by-height, checking hash consistency with the previous block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunc Backwards (primary PeerID, lightStore LightStore, targetHeight Height)\n               (LightStore, Result) {\n  \n    lb,res = lightStore.MinVerified()\n    if res = false {\n        return (lightStore, ResultFailure)\n    }\n\n    latest := lb.Header\n    for i := lb.Header.height - 1; i >= targetHeight; i-- {\n        // here we download height-by-height. We might first download all\n        // headers down to targetHeight and then check them.\n        current := FetchLightBlock(primary,i)\n        if (hash(current) != latest.Header.LastBlockId) {\n            return (lightStore, ResultFailure)\n        }\n        else {\n            lightStore.Update(current, StateVerified)\n            // **Open Question:** Do we need a new state type for\n            // backwards verified light blocks?\n        }\n        latest = current\n    }\n    return (lightStore, ResultSuccess)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI Info and Query Methods in Go\nDESCRIPTION: Implements the Info and Query methods of the ABCI interface. Info returns application information, while Query handles querying the application state for specific information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) Info(_ context.Context, _ *abci.InfoRequest) (*abci.InfoResponse, error) {\n\treturn &abci.InfoResponse{\n\t\tVersion:         version.ABCIVersion,\n\t\tAppVersion:      ApplicationVersion,\n\t\tLastBlockHeight: app.state.Height,\n\n\t\tLastBlockAppHash: app.state.Hash(),\n\t}, nil\n}\n\nfunc (app *ForumApp) Query(_ context.Context, query *abci.QueryRequest) (*abci.QueryResponse, error) {\n\tapp.logger.Info(\"Executing Application Query\")\n\n\tresp := abci.QueryResponse{Key: query.Data}\n\n\t// Parse sender from query data\n\tsender := string(query.Data)\n\n\tif sender == \"history\" {\n\t\tmessages, err := model.FetchHistory(app.state.DB)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresp.Log = messages\n\t\tresp.Value = []byte(messages)\n\n\t\treturn &resp, nil\n\t}\n\t// Retrieve all message sent by the sender\n\tmessages, err := model.GetMessagesBySender(app.state.DB, sender)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert the messages to JSON and return as query result\n\tresultBytes, err := json.Marshal(messages)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp.Log = string(resultBytes)\n\tresp.Value = resultBytes\n\n\treturn &resp, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data by Hash in CometBFT (HTTP Request)\nDESCRIPTION: This snippet demonstrates how to query a block by its hash using an HTTP GET request to the CometBFT API.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/block_by_hash?hash=0xD70952032620CC4E2737EB8AC379806359D8E0B17B0488F627997A0B043ABDED\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for BroadcastTxSync in CometBFT\nDESCRIPTION: HTTP request example for the broadcast_tx_sync endpoint that returns after CheckTx is executed but before DeliverTx.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_31\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/broadcast_tx_sync?tx=encoded_tx\n```\n\n----------------------------------------\n\nTITLE: ABCIQuery Response in CometBFT\nDESCRIPTION: Example JSON response from the abci_query endpoint showing the requested data with a Merkle proof.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_45\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"error\": \"\",\n  \"result\": {\n    \"response\": {\n      \"log\": \"exists\",\n      \"height\": \"0\",\n      \"proof\": \"010114FED0DAD959F36091AD761C922ABA3CBF1D8349990101020103011406AA2262E2F448242DF2C2607C3CDC705313EE3B0001149D16177BC71E445476174622EA559715C293740C\",\n      \"key\": \"Y29tZXRiZnQ=\",\n      \"value\": \"cm9ja3M=\",\n      \"index\": \"-1\",\n      \"code\": \"0\"\n    }\n  },\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trusted Hash for State Sync in CometBFT (TOML)\nDESCRIPTION: Sets the header hash obtained from a trusted source for state synchronization. Must be a hex-encoded number or empty string, with empty string only allowed when state sync is disabled.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_75\n\nLANGUAGE: toml\nCODE:\n```\ntrust_hash = \"\"\n```\n\n----------------------------------------\n\nTITLE: Setting Empty Blocks Interval in CometBFT\nDESCRIPTION: Defines how long a validator should wait before proposing an empty block. This parameter works in conjunction with create_empty_blocks to control the frequency of empty block creation when no transactions are available.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_89\n\nLANGUAGE: toml\nCODE:\n```\ncreate_empty_blocks_interval = \"0s\"\n```\n\n----------------------------------------\n\nTITLE: Defining AggregatedSignature Message Structure in Protobuf\nDESCRIPTION: Proposed Protobuf message structure for implementing aggregated signatures in the Block.Commit structure. It includes fields for representing validator votes, aggregated signatures for 'yea' and 'nay' votes, and BitArrays for tracking validator participation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-018-bls-agg-exploration.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage AggregatedSignature {\n  // yeas is a BitArray representing which validators in the active validator\n  // set issued a 'yea' vote for the block.\n  tendermint.libs.bits.BitArray yeas = 1;\n\n  // absent is a BitArray representing which validators in the active\n  // validator set did not issue votes for the block.\n  tendermint.libs.bits.BitArray absent = 2;\n\n  // yea_signature is an aggregated signature produced from all of the vote\n  // signatures for the block.\n  repeated bytes yea_signature = 3;\n\n  // nay_signature is an aggregated signature produced from all of the vote\n  // signatures from votes for 'nil' for this block.\n  // nay_signature should be made from all of the validators that were both not\n  // in the 'yeas' BitArray and not in the 'absent' BitArray.\n  repeated bytes nay_signature = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ABCI Request to String for Logging\nDESCRIPTION: Implementation of GetABCIRequestString which converts an ABCI request to a base64-encoded string format with special markers to identify it in logs. It uses protocol buffer marshaling to serialize the request.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc GetABCIRequestString(req *abci.Request) (string, error) {\n\tb, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treqStr := base64.StdEncoding.EncodeToString(b)\n\treturn AbciReq + reqStr + AbciReq, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Transaction Data Bytes in CometBFT (Go)\nDESCRIPTION: This Go function, MaxDataBytes, computes the maximum number of bytes available for transaction data in a CometBFT consensus block, factoring in overheads such as the block header, protobuf block overhead, the commit section for validators, and the total size of evidence. It depends on several configuration parameters and helper functions (MaxHeaderBytes, MaxOverheadForBlock, MaxCommitBytes). Inputs are the block byte limit (maxBytes), total evidence size (evidenceBytes), and validator count (valsCount). The output is the maximum allowable size for transaction data; exceeding this would violate consensus rules. The function should only be used when evidence is present.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/creating-proposal.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nfunc MaxDataBytes(maxBytes, evidenceBytes int64, valsCount int) int64 {\n  return maxBytes -\n  MaxOverheadForBlock -\n  MaxHeaderBytes -\n  MaxCommitBytes(valsCount) -\n  evidenceBytes\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Remote Validators Function Signature in Go\nDESCRIPTION: Defines the Go signature for the `Validators` function, used for an RPC call to fetch the validator set for a given block height. It accepts a height (`int64`) and returns the `ValidatorSet` and an error. The description outlines expected outcomes depending on node correctness and communication timeliness, along with error scenarios.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc Validators(height int64) (ValidatorSet, error)\n```\n\n----------------------------------------\n\nTITLE: Peer Banning Functionality - Go\nDESCRIPTION: This snippet defines the mempool's banPeer function, which increments the failure count for a peer and initiates a ban if the threshold is exceeded. Implemented in Go, this function checks failure intervals and updates the peer failure map accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\n\nfunc (mem* ClistMempool) banPeer(peerID NodeID) {\n    numFails := 0\n      // Check whether this peer has sent us transactions that fail\n    if val, ok := mem.peerFailureMap[peerID]; ok {\n      lastFailureT := val.lastFailure\n      numFails = val.numFails\n    // if the failure was recent enough, update the number of failures and \n    // ban peer if applicable\n    if time.Since(lastFailureT) <= failureResetInterval {\n      if numFails == maxAllowedFailures - 1 {\n          // Send Ban request to p2p \n        }\n      }\n    }\n    // Update the time of the last failure     \n    mem.peerFailureMap[peerID] = { time.Now(), numFailures + 1}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Info Requests in CometBFT Application\nDESCRIPTION: Implementation of the Info method that responds to handshake requests from a CometBFT node. The application provides lane priorities and default lane information to initialize the mempool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/mempool-lanes.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *Application) Info(ctx context.Context, req *types.InfoRequest) (*types.InfoResponse, error) {\n  ...\n  return &types.InfoResponse{\n    ...\n    LanePriorities:   app.lanePriorities,\n    DefaultLane:      defaultLane,\n  }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Light Client Attack Evidence Procedure in Go\nDESCRIPTION: A function to validate light client attack evidence against a blockchain state. It retrieves the common block and checks if conflicting headers exist, ensuring the validity and verification constraints are adhered to.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/notes-on-evidence-handling.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc IsValid(lcaEvidence LightClientAttackEvidence, bc Blockchain) boolean {\n    commonBlock = GetLightBlock(bc, lcaEvidence.CommonHeight)\n    if commonBlock == nil return false\n\n    // Note that trustingPeriod in ValidAndVerified is set to UNBONDING_PERIOD\n    verdict = ValidAndVerified(commonBlock, lcaEvidence.ConflictingBlock)\n    conflictingHeight = lcaEvidence.ConflictingBlock.Header.Height\n\n    return verdict == OK and bc[conflictingHeight].Header != lcaEvidence.ConflictingBlock.Header\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Database Provider with CometBFT in Go\nDESCRIPTION: Example of how to provide a custom database implementation when constructing a new CometBFT node, replacing the default pebbledb with goleveldb.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/custom-db.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ncustomDBProvider := func(ctx *cmtdb.DBContext) (cmtdb.DB, error) {\n    return goleveldb.NewGoLevelDB(ctx.ID, ctx.Config.DBDir())\n}\n\nnode, err := nm.NewNode(\n    context.Background(),\n    config,\n    pv,\n    nodeKey,\n    proxy.NewLocalClientCreator(app),\n    nm.DefaultGenesisDocProviderFunc(config),\n    customDBProvider,\n    nm.DefaultMetricsProvider(config.Instrumentation),\n    logger)\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Node\nDESCRIPTION: This command starts the CometBFT node, connecting it to the ABCI application via a Unix socket.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ncometbft node --home /tmp/cometbft-home --proxy_app=unix://example.sock\n```\n\n----------------------------------------\n\nTITLE: Splitting a Block into Parts using MakeParts - Go\nDESCRIPTION: Demonstrates use of the MakeParts function to encode a Block object using Protobuf and divide it into Parts for gossipping or storage. Requires Protobuf serialization and the definition of Block and Part types. Inputs: block (Block struct). Output: []Part. Enforces a max part size (65536 bytes) and part count (1601). Used for efficient peer-to-peer data transfer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc MakeParts(block Block) []Part\n```\n\n----------------------------------------\n\nTITLE: Receiving CometBFT Status Response in JSON\nDESCRIPTION: Provides the JSON format of a typical response to a status request, containing node info, sync data, and validator info.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": -1,\n  \"result\": {\n    \"node_info\": {\n      \"protocol_version\": {\n        \"p2p\": \"8\",\n        \"block\": \"11\",\n        \"app\": \"0\"\n      },\n      \"id\": \"b93270b358a72a2db30089f3856475bb1f918d6d\",\n      \"listen_addr\": \"tcp://0.0.0.0:26656\",\n      \"network\": \"cosmoshub-4\",\n      \"version\": \"v0.34.8\",\n      \"channels\": \"40202122233038606100\",\n      \"moniker\": \"aib-hub-node\",\n      \"other\": {\n        \"tx_index\": \"on\",\n        \"rpc_address\": \"tcp://0.0.0.0:26657\"\n      }\n    },\n    \"sync_info\": {\n      \"latest_block_hash\": \"50F03C0EAACA8BCA7F9C14189ACE9C05A9A1BBB5268DB63DC6A3C848D1ECFD27\",\n      \"latest_app_hash\": \"2316CFF7644219F4F15BEE456435F280E2B38955EEA6D4617CCB6D7ABF781C22\",\n      \"latest_block_height\": \"5622165\",\n      \"latest_block_time\": \"2021-03-25T14:00:43.356134226Z\",\n      \"earliest_block_hash\": \"1455A0C15AC49BB506992EC85A3CD4D32367E53A087689815E01A524231C3ADF\",\n      \"earliest_app_hash\": \"E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855\",\n      \"earliest_block_height\": \"5200791\",\n      \"earliest_block_time\": \"2019-12-11T16:11:34Z\",\n      \"catching_up\": false\n    },\n    \"validator_info\": {\n      \"address\": \"38FB765D0092470989360ECA1C89CD06C2C1583C\",\n      \"pub_key\": {\n        \"type\": \"tendermint/PubKeyEd25519\",\n        \"value\": \"Z+8kntVegi1sQiWLYwFSVLNWqdAUGEy7lskL78gxLZI=\"\n      },\n      \"voting_power\": \"0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vote Extension API in Rust for CometBFT\nDESCRIPTION: Defines two functions for extending votes and verifying vote extensions. ExtendVote generates unsigned and self-authenticating app vote data, while VerifyVoteExtension validates the extended vote data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn ExtendVote(height: u64, round: u64) -> (UnsignedAppVoteData, SelfAuthenticatingAppData)\nfn VerifyVoteExtension(signed_app_vote_data: Vec<u8>, self_authenticating_app_vote_data: Vec<u8>) -> bool\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT\nDESCRIPTION: Command to initialize CometBFT with a specified home directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncometbft init --home /tmp/forum-app\n```\n\n----------------------------------------\n\nTITLE: Defining FeatureParams in Go for CometBFT PBTS Compatibility\nDESCRIPTION: This Go struct defines the FeatureParams, which includes the PbtsEnableHeight to ensure backwards compatibility when enabling PBTS in CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-112-proposer-based-timestamps.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype FeatureParams struct {\n        PbtsEnableHeight int64 `json:\"pbts_enable_height\"`\n        ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore FilterVerified Function Signature in Go\nDESCRIPTION: Specifies the signature for the `FilterVerified` method on the `LightStore`. This function returns a new `LightStore` instance containing only the light blocks from the original store whose state is `StateVerified`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) FilterVerified() LightStore\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore Update Function Signature in Go\nDESCRIPTION: Specifies the signature for the `Update` method on the `LightStore`. This function updates an existing `lightBlock` within the store. It sets the block's state to the provided `verifiedState` and its verification root to the given `root-height`. It assumes the `lightBlock` is already part of the lightstore.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Update(lightBlock LightBlock, verfiedState\nVerifiedState, root-height Height)\n```\n\n----------------------------------------\n\nTITLE: Loading CometBFT Node Key in Go\nDESCRIPTION: Demonstrates loading the node's P2P key from the file specified in the CometBFT configuration (`config.NodeKeyFile()`) using `nodekey.LoadNodeKey` (assuming `nodekey` is from `github.com/cometbft/cometbft/p2p/key` or similar). This key is essential for identifying the node within the CometBFT peer-to-peer network. Includes basic error handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_17\n\nLANGUAGE: go\nCODE:\n```\nnodeKey, err := nodekey.LoadNodeKey(config.NodeKeyFile())\nif err != nil {\n    return nil, fmt.Errorf(\"failed to load node's key: %w\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing CometBFT\nDESCRIPTION: Installs the CometBFT package using 'go install' and verifies the installation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo install github.com/cometbft/cometbft/cmd/cometbft@v1.0\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cometbft version\nv1.0.0\n```\n\n----------------------------------------\n\nTITLE: Main Function for ABCI Application\nDESCRIPTION: Main function that initializes and starts the ABCI application with a Badger database backend. It handles command-line flags, sets up the database, creates the application instance, and starts the ABCI server with graceful shutdown handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    abciserver \"github.com/cometbft/cometbft/abci/server\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"path/filepath\"\n    \"syscall\"\n\n    \"github.com/dgraph-io/badger/v4\"\n    cmtlog \"github.com/cometbft/cometbft/libs/log\"\n)\n\nvar homeDir string\nvar socketAddr string\n\nfunc init() {\n    flag.StringVar(&homeDir, \"kv-home\", \"\", \"Path to the kvstore directory (if empty, uses $HOME/.kvstore)\")\n    flag.StringVar(&socketAddr, \"socket-addr\", \"unix://example.sock\", \"Unix domain socket address (if empty, uses \\\"unix://example.sock\\\"\")\n}\n\nfunc main() {\n    flag.Parse()\n    if homeDir == \"\" {\n        homeDir = os.ExpandEnv(\"$HOME/.kvstore\")\n    }\n\n    dbPath := filepath.Join(homeDir, \"badger\")\n    db, err := badger.Open(badger.DefaultOptions(dbPath))\n    if err != nil {\n        log.Fatalf(\"Opening database: %v\", err)\n    }\n\n    defer func() {\n        if err := db.Close(); err != nil {\n            log.Fatalf(\"Closing database: %v\", err)\n        }\n    }()\n\n    app := NewKVStoreApplication(db)\n    logger := cmtlog.NewLogger(os.Stdout)\n\n    server := abciserver.NewSocketServer(socketAddr, app)\n    server.SetLogger(logger)\n\n    if err := server.Start(); err != nil {\n        fmt.Fprintf(os.Stderr, \"error starting socket server: %v\", err)\n\n        os.Exit(1)\n    }\n    defer server.Stop()\n\n    c := make(chan os.Signal, 1)\n    signal.Notify(c, os.Interrupt, syscall.SIGTERM)\n    <-c\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fanout Observer in Go for CometBFT\nDESCRIPTION: Implementation of a fanout observer that dispatches events to multiple observers. This enables pub/sub functionality similar to the EventBus but with type safety and explicit concurrency control.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\ntype StateFanoutObserver struct {\n    observers []StateObserver\n}\n\nfunc NewStateFanoutObserver(observers ...StateObserver) *StateFanoutObserver {\n    return &StateFanoutObserver{\n        observers: observers,\n    }\n}\n\nfunc (o *StateFanoutObserver) ConsensusStateNewRoundStep(ev EventDataRoundState) {\n    for _, obs := range o.observers {\n        obs.ConsensusStateNewRoundStep(ev)\n    }\n}\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Running a Local 4-Node CometBFT Network using Make\nDESCRIPTION: This snippet shows the commands to build and run a local 4-node CometBFT network using Make commands. It builds Linux binaries, creates a Docker image for local nodes, and starts the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/DOCKER/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nmake build-linux\nmake build-docker-localnode\nmake localnet-start\n```\n\n----------------------------------------\n\nTITLE: Transaction Addition and Deduplication in Mempool - Bluespec\nDESCRIPTION: Defines actions for adding transactions to a node's mempool, distinguishing between first-time and duplicate transactions based on cache state. These actions update both the mempool structure and the sender tracking, respecting validity checks and ensuring no redundant addition of senders. Optional sender logic allows differentiation between user and peer sources.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_5\n\nLANGUAGE: bluespec\nCODE:\n```\naction tryAddTx(node, _incomingMsgs, optionalSender, tx) = \n    if (not(hash(tx).in(node.Cache())))\n        node.tryAddFirstTimeTx(_incomingMsgs, optionalSender, tx)\n    else\n        node.processDuplicateTx(_incomingMsgs, optionalSender, tx)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\naction tryAddFirstTimeTx(node, _incomingMsgs, optionalSender, tx) = all {\n    mempool' = mempool.update(node, st => {\n        cache: st.cache.join(hash(tx)),\n        txs: if (valid(tx)) st.txs.append(tx) else st.txs,\n        ...st }),\n    senders' = senders.update(node, ss =>\n        if (valid(tx)) ss.addSender(tx, optionalSender) else ss),\n    incomingMsgs' = _incomingMsgs,\n    peers' = peers,\n}\n```\n\nLANGUAGE: bluespec\nCODE:\n```\naction processDuplicateTx(node, _incomingMsgs, optionalSender, tx) = all {\n    senders' = senders.update(node, ss =>\n        if (node.Txs().includes(tx)) ss.addSender(tx, optionalSender) else ss),\n    mempool' = mempool,\n    incomingMsgs' = _incomingMsgs,\n    peers' = peers,\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Transaction Data Bytes Without Evidence in CometBFT (Go)\nDESCRIPTION: The MaxDataBytesNoEvidence function calculates the maximum permissible bytes for transaction data in a CometBFT block without accounting for any evidence. It subtracts the maximum overhead for the block, header, and commit section from the total byte allowance. Parameters include the block size ceiling (maxBytes) and validator count (valsCount). Returns the maximum bytes allowed for transaction data, assuming no evidence is present, and is typically used for checking individual transaction sizes before mempool acceptance.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/creating-proposal.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc MaxDataBytesNoEvidence(maxBytes int64, valsCount int) int64 {\n  return maxBytes -\n    MaxOverheadForBlock -\n    MaxHeaderBytes -\n    MaxCommitBytes(valsCount)\n}\n```\n\n----------------------------------------\n\nTITLE: Minimum Verified Height Query Function\nDESCRIPTION: Function that returns the light block with the minimum height in the store that has been verified. Returns both the light block and a boolean indicating if such a block exists.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) MinVerified() (LightBlock, bool)\n```\n\n----------------------------------------\n\nTITLE: Using UnsyncLocalClient in Go\nDESCRIPTION: Example of creating and using an UnsyncLocalClient. This demonstrates how to initialize the client with a thread-safe application and make ABCI calls without mutex protection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/abci-clients.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    abcicli \"github.com/cometbft/cometbft/abci/client\"\n    \"github.com/cometbft/cometbft/abci/types\"\n)\n\n// Create your ABCI application\napp := MyThreadSafeApplication{}\n\n// Create an unsynchronized local client\nclient := abcicli.NewUnsyncLocalClient(app)\n\n// Start the client\nif err := client.Start(); err != nil {\n    // Handle error\n}\n\n// Use the client to make ABCI calls\n// Note: No mutex protection on these calls!\nresp, err := client.Info(ctx, &types.InfoRequest{})\n```\n\n----------------------------------------\n\nTITLE: Setting Total Mempool Size\nDESCRIPTION: Configuration for maximum total size in bytes for all transactions in mempool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_64\n\nLANGUAGE: toml\nCODE:\n```\nmax_txs_bytes = 67108864\n```\n\n----------------------------------------\n\nTITLE: Implementing gRPC Server API for CometBFT in Go\nDESCRIPTION: Defines the Go API for constructing and configuring a gRPC server within CometBFT. It provides a flexible design using functional options pattern to enable specific services and customize server behavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-106-grpc-api.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage server\n\n// Option is any function that allows for configuration of the gRPC server\n// during its creation.\ntype Option func(*serverBuilder)\n\n// WithVersionService enables the version service on the CometBFT gRPC server.\n//\n// (Similar methods should be provided for every other service that can be\n// exposed via the gRPC interface)\nfunc WithVersionService() Option {\n    // ...\n}\n\n// WithGRPCOption allows one to specify Google gRPC server options during the\n// construction of the CometBFT gRPC server.\nfunc WithGRPCOption(opt grpc.ServerOption) Option {\n    // ...\n}\n\n// Serve constructs and runs a CometBFT gRPC server using the given listener and\n// options.\nfunc Serve(listener net.Listener, opts ...Option) error {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Genesis JSON Configuration for CometBFT\nDESCRIPTION: Example of a genesis.json file defining the initial CometBFT state, including chain ID, consensus parameters, and validator information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"genesis_time\": \"2023-01-21T11:17:42.341227868Z\",\n  \"chain_id\": \"test-chain-ROp9KF\",\n  \"initial_height\": \"0\",\n  \"consensus_params\": {\n    \"block\": {\n      \"max_bytes\": \"4194304\",\n      \"max_gas\": \"10000000\",\n    },\n    \"evidence\": {\n      \"max_age_num_blocks\": \"100000\",\n      \"max_age_duration\": \"172800000000000\",\n      \"max_bytes\": 51200,\n    },\n    \"validator\": {\n      \"pub_key_types\": [\n        \"ed25519\"\n      ]\n    }\n  },\n  \"validators\": [\n    {\n      \"address\": \"B547AB87E79F75A4A3198C57A8C2FDAF8628CB47\",\n      \"pub_key\": {\n        \"type\": \"tendermint/PubKeyEd25519\",\n        \"value\": \"P/V6GHuZrb8rs/k1oBorxc6vyXMlnzhJmv7LmjELDys=\"\n      },\n      \"power\": \"10\",\n      \"name\": \"\"\n    }\n  ],\n  \"app_hash\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Marking a Peer as Good - CometBFT Switch API - Go\nDESCRIPTION: The MarkPeerAsGood(peer Peer) function informs the Switch that a peer has demonstrated favorable behavior, influencing network peer discovery and address book reputation. It requires a Peer instance as input and has no return value. This method is primarily used by the consensus reactor based on protocol-specific heuristics; its effects are internal to peer management and the PEX protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) MarkPeerAsGood(peer Peer)\n```\n\n----------------------------------------\n\nTITLE: Attack Detection Function in Go Light Client\nDESCRIPTION: The function `AttackDetector` processes a primary trace and verifies it against secondary peers to detect potential attacks. Delegates evidence generation to `CreateEvidenceForPeer` in cases of discrepancies. Relies on a set of peers and involves possible replacement of secondaries if proven faulty. Requires a list of light blocks and returns any evidence found.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_001_reviewed.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc AttackDetector(root LightBlock, primary_trace []LightBlock)\n                   ([]InternalEvidence) {\n\n    Evidences := new []InternalEvidence;\n\n    for each secondary in Secondaries {\n        // we replay the primary trace with the secondary, in\n        // order to generate evidence that we can submit to the\n        // secondary. We return the evidence + the trace the\n        // secondary told us that spans the evidence at its local store\n\n        EvidenceForSecondary, newroot, secondary_trace, result :=\n                CreateEvidenceForPeer(secondary,\n                          root,\n           primary_trace);\n        if result == FaultyPeer {\n            Replace_Secondary(root);\n        }\n        else if result == FoundEvidence {\n            // the conflict is not bogus\n            Evidences.Add(EvidenceForSecondary);\n            // we replay the secondary trace with the primary, ...\n            EvidenceForPrimary, _, result :=\n        CreateEvidenceForPeer(primary,\n                                          newroot,\n                                          secondary_trace);\n            if result == FoundEvidence {\n                Evidences.Add(EvidenceForPrimary);\n            }\n            // At this point we do not care about the other error\n            // codes. We already have generated evidence for an\n            // attack and need to stop the lightclient. It does not\n            // help to call replace_primary. Also we will use the\n            // same primary to check with other secondaries in\n            // later iterations of the loop\n         }\n         // In the case where the secondary reports NoEvidence\n         // we do nothing\n    }\n    return Evidences;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Batch Interface for GoLevelDB in Go\nDESCRIPTION: Implementation of the Batch interface for GoLevelDB, providing methods for batch operations like Set, Delete, and Write with synchronous options.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/custom-db.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage goleveldb\n\nimport (\n\t\"github.com/syndtr/goleveldb/leveldb\"\n\t\"github.com/syndtr/goleveldb/leveldb/opt\"\n)\n\ntype goLevelDBBatch struct {\n\tdb    *GoLevelDB\n\tbatch *leveldb.Batch\n}\n\nfunc newGoLevelDBBatch(db *GoLevelDB) *goLevelDBBatch {\n\treturn &goLevelDBBatch{\n\t\tdb:    db,\n\t\tbatch: new(leveldb.Batch),\n\t}\n}\n\n// Set implements Batch.\nfunc (b *goLevelDBBatch) Set(key, value []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\tif value == nil {\n\t\treturn errValueNil\n\t}\n\tif b.batch == nil {\n\t\treturn errBatchClosed\n\t}\n\tb.batch.Put(key, value)\n\treturn nil\n}\n\n// Delete implements Batch.\nfunc (b *goLevelDBBatch) Delete(key []byte) error {\n\tif len(key) == 0 {\n\t\treturn errKeyEmpty\n\t}\n\tif b.batch == nil {\n\t\treturn errBatchClosed\n\t}\n\tb.batch.Delete(key)\n\treturn nil\n}\n\n// Write implements Batch.\nfunc (b *goLevelDBBatch) Write() error {\n\treturn b.write(false)\n}\n\n// WriteSync implements Batch.\nfunc (b *goLevelDBBatch) WriteSync() error {\n\treturn b.write(true)\n}\n\nfunc (b *goLevelDBBatch) write(sync bool) error {\n\tif b.batch == nil {\n\t\treturn errBatchClosed\n\t}\n\n\terr := b.db.db.Write(b.batch, &opt.WriteOptions{Sync: sync})\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Make sure batch cannot be used afterwards. Callers should still call Close(), for errors.\n\treturn b.Close()\n}\n\n// Close implements Batch.\nfunc (b *goLevelDBBatch) Close() error {\n\tif b.batch != nil {\n\t\tb.batch.Reset()\n\t\tb.batch = nil\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Last Signed State in Go\nDESCRIPTION: Code snippet to update the LastSigned state after a message is signed. Ensures accuracy in tracking the most recent proposal or vote signed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\ns.Height = m.Height\ns.Round = m.Round\ns.Type = m.Type\n```\n\n----------------------------------------\n\nTITLE: Generating Evidence Against Peers in Go\nDESCRIPTION: This function `CreateEvidenceForPeer` compares a given trace of light blocks against a peer’s response. It checks for discrepancies between block headers to gather evidence and replace faulty peers. Requires a peer ID, root block, and light store as input; returns a tuple including any evidence found or error results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_001_reviewed.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc CreateEvidenceForPeer(peer PeerID, root LightBlock, trace LightStore)\n                          (Evidence, LightBlock, LightStore, result) {\n\n    common := root;\n\n    for i in 1 .. len(trace) {\n        auxLS, result := VerifyToTarget(peer, common, trace[i].Header.Height)\n  \n        if result != ResultSuccess {\n            // something went wrong; peer did not provide a verifiable block\n            return (nil, nil, nil, FaultyPeer)\n        }\n        else {\n            if auxLS.LatestVerified().Header != trace[i].Header {\n                // the header reported by the peer differs from the\n                // reference header in trace but both could be\n                // verified from common in one step.\n                // we can create evidence for submission to the secondary\n                ev := new InternalEvidence;\n                ev.Evidence.ConflictingBlock := trace[i];\n                ev.Evidence.CommonHeight := common.Height;\n                ev.Peer := peer\n                return (ev, common, auxLS, FoundEvidence)\n            }\n            else {\n                // the peer agrees with the trace, we move common forward\n                // we could delete auxLS as it will be overwritten in\n                // the next iteration\n                common := trace[i]\n            }\n        }\n    }\n    return (nil, nil, nil, NoEvidence)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CreateEvidenceForPeer Function in Go for CometBFT Light Client\nDESCRIPTION: This function creates evidence for conflicting blocks between a peer and the primary trace. It verifies blocks step-by-step and generates evidence if a conflicting block is found.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\nfunc CreateEvidenceForPeer(peer PeerID, root LightBlock, trace LightStore)\n                          (Evidence, LightBlock, LightStore, result) {\n\n    common := root;\n\n    for i in 1 .. len(trace) {\n        auxLS, result := VerifyToTarget(peer, common, trace[i].Header.Height)\n  \n        if result != ResultSuccess {\n            // something went wrong; peer did not provide a verifiable block\n            return (nil, nil, nil, FaultyPeer)\n        }\n        else {\n            if auxLS.LatestVerified().Header != trace[i].Header {\n                // the header reported by the peer differs from the\n                // reference header in trace but both could be\n                // verified from common in one step.\n                // we can create evidence for submission to the secondary\n                ev := new InternalEvidence;\n                ev.Evidence.ConflictingBlock := trace[i];\n                // CommonHeight is used to indicate the type of attack\n                // if the CommonHeight != ConflictingBlock.Height this \n                // is by definition a lunatic attack else it is an\n                // equivocation attack\n                ev.Evidence.CommonHeight := common.Height;\n                ev.Peer := peer\n                return (ev, common, auxLS, FoundEvidence)\n            }\n            else {\n                // the peer agrees with the trace, we move common forward.\n                // we could delete auxLS as it will be overwritten in\n                // the next iteration\n                common := trace[i]\n            }\n        }\n    }\n    return (nil, nil, nil, NoEvidence)\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Percentage of Missing and Byzantine Validators in CometBFT\nDESCRIPTION: Formula to calculate the percentage of validators that are either missing or byzantine relative to the total validator power. This metric helps monitor consensus health by quantifying validator participation issues.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/metrics.md#2025-04-22_snippet_0\n\nLANGUAGE: md\nCODE:\n```\n((consensus\\_byzantine\\_validators\\_power + consensus\\_missing\\_validators\\_power) / consensus\\_validators\\_power) * 100\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data by Height in CometBFT (JSON Response)\nDESCRIPTION: This snippet shows the JSON response structure when querying a block by height. It includes block metadata, header information, transaction data, evidence, and commit signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"block_id\": {\n      \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n      \"parts\": {\n        \"total\": 1,\n        \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n      }\n    },\n    \"block\": {\n      \"header\": {\n        \"version\": {\n          \"block\": \"10\",\n          \"app\": \"0\"\n        },\n        \"chain_id\": \"cosmoshub-2\",\n        \"height\": \"12\",\n        \"time\": \"2019-04-22T17:01:51.701356223Z\",\n        \"last_block_id\": {\n          \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n          \"parts\": {\n            \"total\": 1,\n            \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n          }\n        },\n        \"last_commit_hash\": \"21B9BC845AD2CB2C4193CDD17BFC506F1EBE5A7402E84AD96E64171287A34812\",\n        \"data_hash\": \"970886F99E77ED0D60DA8FCE0447C2676E59F2F77302B0C4AA10E1D02F18EF73\",\n        \"validators_hash\": \"D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0\",\n        \"next_validators_hash\": \"D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0\",\n        \"consensus_hash\": \"0F2908883A105C793B74495EB7D6DF2EEA479ED7FC9349206A65CB0F9987A0B8\",\n        \"app_hash\": \"223BF64D4A01074DC523A80E76B9BBC786C791FB0A1893AC5B14866356FCFD6C\",\n        \"last_results_hash\": \"\",\n        \"evidence_hash\": \"\",\n        \"proposer_address\": \"D540AB022088612AC74B287D076DBFBC4A377A2E\"\n      },\n      \"data\": [\n        \"yQHwYl3uCkKoo2GaChRnd+THLQ2RM87nEZrE19910Z28ABIUWW/t8AtIMwcyU0sT32RcMDI9GF0aEAoFdWF0b20SBzEwMDAwMDASEwoNCgV1YXRvbRIEMzEwMRCd8gEaagom61rphyEDoJPxlcjRoNDtZ9xMdvs+lRzFaHe2dl2P5R2yVCWrsHISQKkqX5H1zXAIJuC57yw0Yb03Fwy75VRip0ZBtLiYsUqkOsPUoQZAhDNP+6LY+RUwz/nVzedkF0S29NZ32QXdGv0=\"\n      ],\n      \"evidence\": [\n        {\n          \"type\": \"string\",\n          \"height\": 0,\n          \"time\": 0,\n          \"total_voting_power\": 0,\n          \"validator\": {\n            \"pub_key\": {\n              \"type\": \"tendermint/PubKeyEd25519\",\n              \"value\": \"A6DoBUypNtUAyEHWtQ9bFjfNg8Bo9CrnkUGl6k6OHN4=\"\n            },\n            \"voting_power\": 0,\n            \"address\": \"string\"\n          }\n        }\n      ],\n      \"last_commit\": {\n        \"height\": 0,\n        \"round\": 0,\n        \"block_id\": {\n          \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n          \"parts\": {\n            \"total\": 1,\n            \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n          }\n        },\n        \"signatures\": [\n          {\n            \"type\": 2,\n            \"height\": \"1262085\",\n            \"round\": 0,\n            \"block_id\": {\n              \"hash\": \"112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7\",\n              \"parts\": {\n                \"total\": 1,\n                \"hash\": \"38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD\"\n              }\n            },\n            \"timestamp\": \"2019-08-01T11:39:38.867269833Z\",\n            \"validator_address\": \"000001E443FD237E4B616E2FA69DF4EE3D49A94F\",\n            \"validator_index\": 0,\n            \"signature\": \"DBchvucTzAUEJnGYpNvMdqLhBAHG4Px8BsOBB3J3mAFCLGeuG7uJqy+nVngKzZdPhPi8RhmE/xcw/M9DOJjEDg==\"\n          }\n        ]\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ProofOperator Interface in Go\nDESCRIPTION: Defines the ProofOperator interface that enables layered and extensible Merkle proofs. The interface contains methods for executing proof verification (Run), retrieving the proof key (GetKey), and converting to a protocol buffer representation (ProofOp).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-026-general-merkle-proof.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ProofOperator interface {\n    Run([][]byte) ([][]byte, error)\n    GetKey() []byte\n    ProofOp() ProofOp\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Payload for /validators RPC Endpoint\nDESCRIPTION: Shows an example JSON payload for a POST request to the `/validators` RPC endpoint. This includes the JSON-RPC version, a unique request ID, the method name `validators`, and parameters specifying the target block `height`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\n// POST /validators\n{\n \"jsonrpc\": \"2.0\",\n \"id\": \"ccc84631-dfdb-4adc-b88c-5291ea3c2cfb\", // UUID v4, unique per request\n \"method\": \"validators\",\n \"params\": {\n  \"height\": 1234\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Misbehavior and Updating IBC State - Go\nDESCRIPTION: Defines a function draft for verifying evidence of misbehavior (forks) using a proof structure (PoF) within a client state. The intended logic is to compare blocks and traces in the proof, check trust relationships, and update the frozen state of the client on detection of a fork. It operates under the assumption that the IBC's local header store and the proof's trusted block are in sync at the same height, and updates state based on minimum detected fork height. Preconditions and detailed error handling are outlined in comments. Requires IBC context, definitions from ICS 007, and CMBC-FUNC.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc checkMisbehaviorAndUpdateState(cs: ClientState, PoF: LightNodeProofOfFork)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Evidence Interface in Go\nDESCRIPTION: This code snippet defines the initial Evidence interface in Go, which includes methods for retrieving height, time, address, and other properties of the evidence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Evidence interface { //existing\n  Height() int64                                     // height of the offense\n  Time() time.Time                                   // time of the offense\n  Address() []byte                                   // address of the offending validator\n  Bytes() []byte                                     // bytes which comprise the evidence\n  Hash() []byte                                      // hash of the evidence\n  Verify(chainID string, pubKey crypto.PubKey) error // verify the evidence\n  Equal(Evidence) bool                               // check equality of evidence\n\n  ValidateBasic() error\n  String() string\n}\n```\n\n----------------------------------------\n\nTITLE: Secp256k1 Private Validator Key Configuration in CometBFT (JSON)\nDESCRIPTION: Example of a priv_validator_key.json file using Secp256k1 encryption. Contains the wallet address, public key, and private key for consensus signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/priv_validator_key.json.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"address\": \"E5B4F106D46A46820308C49B5F92DC22D9F9ACFA\",\n  \"pub_key\": {\n    \"type\": \"tendermint/PubKeySecp256k1\",\n    \"value\": \"AhRzbjoZaiyrbCE/yJ6gwIBXjwzl8+H7W8KMAphJVUzt\"\n  },\n  \"priv_key\": {\n    \"type\": \"tendermint/PrivKeySecp256k1\",\n    \"value\": \"Lfa2uW//4KGvzLXhtoHGfI5Yd2DA2gC7pOfHSkFheGg=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Primary Node - Cosmos Light Client Supervisor - Go\nDESCRIPTION: Declares the Replace_Primary function, which manages peer set reconfiguration by promoting a secondary node to primary, based on a provided trusted LightBlock. Requires a nonempty FullNodes set and the ability to cross-fetch a block for agreement, ensuring preconditions are met before role transitions. On success, the previous primary is demoted to the FaultyNodes set; error handling should address cases where FullNodes is empty.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nReplace_Primary(root-of-trust LightBlock)\n```\n\n----------------------------------------\n\nTITLE: Implementing VerifyAndDetect Function for Light Client in Go\nDESCRIPTION: This function verifies light blocks and detects potential attacks in the CometBFT light client protocol. It handles various scenarios including trusted blocks, cross-checking, forward verification, and backwards verification. The function returns an updated light store and a result indicating success, failure, or detected attack.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc VerifyAndDetect (lightStore LightStore, targetHeight Height)\n                     (LightStore, Result) {\n\n    b1, r1 = lightStore.Get(targetHeight)\n    if r1 == true {\n        if b1.State == StateTrusted {\n            // block already there and trusted\n            return (lightStore, ResultSuccess)\n  }\n  else {\n            // We have a lightblock in the store, but it has not been \n            // cross-checked by now. We do that now.\n            root_of_trust, auxLS := lightstore.TraceTo(b1);\n   \n            // Cross-check\n            Evidences := AttackDetector(root_of_trust, auxLS);\n            if Evidences.Empty {\n                // no attack detected, we trust the new lightblock\n                lightStore.Update(auxLS.Latest(), \n                                  StateTrusted, \n                                  verfiedLS.Latest().verification-root);\n                return (lightStore, OK);\n            }\n            else {\n                // there is an attack, we exit\n  submitEvidence(Evidences);\n                return(lightStore, ErrorAttack);\n            }\n        }\n    }\n\n    // get the lightblock with maximum height smaller than targetHeight\n    // would typically be the heights, if we always move forward\n    root_of_trust, r2 = lightStore.LatestPrevious(targetHeight);\n\n    if r2 = false {\n        // there is no lightblock from which we can do forward\n        // (skipping) verification. Thus we have to go backwards.\n        // No cross-check needed. We trust hashes. Therefore, we\n        // directly return the result\n        return Backwards(primary, lightStore.Lowest(), targetHeight)\n    }\n    else {\n        // Forward verification + detection\n        result := NoResult;\n        while result != ResultSuccess {\n            verifiedLS,result := VerifyToTarget(primary,\n                                                root_of_trust,\n                                                nextHeight);\n            if result == ResultFailure {\n                // pick new primary (promote a secondary to primary)\n                Replace_Primary(root_of_trust);\n            }\n            else if result == ResultExpired {\n                return (lightStore, result)\n            }\n        }\n\n        // Cross-check\n        Evidences := AttackDetector(root_of_trust, verifiedLS);\n        if Evidences.Empty {\n            // no attack detected, we trust the new lightblock\n            verifiedLS.Update(verfiedLS.Latest(), \n                              StateTrusted, \n                              verfiedLS.Latest().verification-root);\n            lightStore.store_chain(verifidLS);\n            return (lightStore, OK);\n        }\n        else {\n            // there is an attack, we exit\n            return(lightStore, ErrorAttack);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Discovery Time for State Sync in CometBFT (TOML)\nDESCRIPTION: Sets the maximum time to spend discovering snapshots before switching to blocksync. If set to 0, state sync will try indefinitely.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_77\n\nLANGUAGE: toml\nCODE:\n```\nmax_discovery_time = \"2m\"\n```\n\n----------------------------------------\n\nTITLE: User Transaction and Peer Message Processing Actions - Bluespec\nDESCRIPTION: Specifies protocol steps for user-submitted transactions, peer message handling, transaction dissemination, node joining, and node disconnection. These blueprint actions decompose protocol logic into discrete steps for simulation or reasoning, highlighting non-deterministic choices and updates to key state components like mempool, senders, peers, and incoming messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_4\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nnondet tx = oneOf(AllTxs)\nnode.receiveTxFromUser(tx, tryAddTx),\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nnode.receiveFromPeer(handleMessage),\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nall {\n    node.disseminateNextTx(mkTargetNodes, TxMsg),\n    senders' = senders,\n},\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nall {\n    pickNodeAndJoin,\n    mempool' = mempool,\n    senders' = senders,\n},\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork) \nall {\n    require(size(nodesInNetwork) > 1),\n    // Disconnect node and remove node from other peers' connections.\n    peers' = peers\n        .disconnect(node)\n        .updateMultiple(nodesInNetwork, ps => ps.exclude(Set(node))),\n    incomingMsgs' = incomingMsgs,\n    mempool' = mempool,\n    senders' = senders,\n},\n```\n\n----------------------------------------\n\nTITLE: InitChain Request Structure\nDESCRIPTION: Defines the request structure for the InitChain method used during genesis\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\n| Name             | Type                                            | Description                                         | Field Number |\n|------------------|-------------------------------------------------|-----------------------------------------------------|--------------||\n| time             | [google.protobuf.Timestamp][protobuf-timestamp] | Genesis time                                        | 1            |\n| chain_id         | string                                          | ID of the blockchain.                               | 2            |\n| consensus_params | [ConsensusParams](#consensusparams)             | Initial consensus-critical parameters.              | 3            |\n| validators       | repeated [ValidatorUpdate](#validatorupdate)    | Initial genesis validators, sorted by voting power. | 4            |\n| app_state_bytes  | bytes                                           | Serialized initial application state. JSON bytes.   | 5            |\n| initial_height   | int64                                           | Height of the initial block (typically `1`).        | 6            |\n```\n\n----------------------------------------\n\nTITLE: ABCI Evidence Structure in Go\nDESCRIPTION: This struct defines the format of evidence that the application will receive. It includes fields for the evidence type, offending validator, height and time of the offense, and total voting power of the validator set.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ntype Evidence struct {\n\tType EvidenceType `protobuf:\"varint,1,opt,name=type,proto3,enum=tendermint.abci.EvidenceType\" json:\"type,omitempty\"`\n\tValidator Validator `protobuf:\"bytes,2,opt,name=validator,proto3\" json:\"validator\"`\n\tHeight int64 `protobuf:\"varint,3,opt,name=height,proto3\" json:\"height,omitempty\"`\n\tTime time.Time `protobuf:\"bytes,4,opt,name=time,proto3,stdtime\" json:\"time\"`\n\tTotalVotingPower int64 `protobuf:\"varint,5,opt,name=total_voting_power,json=totalVotingPower,proto3\" json:\"total_voting_power,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Unconfirmed Transactions in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving unconfirmed transactions from the mempool. The endpoint supports limiting the number of transactions returned through the limit parameter.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_25\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/unconfirmed_txs\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"unconfirmed_txs\\\", \\\"params\\\":{\\\"limit\\\":\\\"20\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Subscription Usage Example in Go\nDESCRIPTION: Demonstrates how to use the Subscription struct in a select statement, handling incoming messages and subscription cancellation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nsubscription, err := pubsub.Subscribe(...)\nif err != nil {\n  // ...\n}\nfor {\nselect {\n  case msgAndTags <- subscription.Out():\n    // ...\n  case <-subscription.Canceled():\n    return subscription.Err()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Block in CometBFT Blockchain\nDESCRIPTION: This Go code snippet describes the recursive state execution equation and the Execute function. It showcases how a block is executed against the application state using ABCIApp, modifying the validator set and consensus parameters. Key dependencies include the application interface (`ABCIApp`) and the state along with block parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nstate(initialHeight) = InitialState\nstate(h+1) <- Execute(state(h), ABCIApp, block(h))\n```\n\nLANGUAGE: Go\nCODE:\n```\nfunc Execute(state State, app ABCIApp, block Block) State {\n // Function ApplyBlock executes block of transactions against the app and returns the new root hash of the app state,\n // modifications to the validator set and the changes of the consensus parameters.\n AppHash, ValidatorChanges, ConsensusParamChanges := app.ApplyBlock(block)\n\n nextConsensusParams := UpdateConsensusParams(state.ConsensusParams, ConsensusParamChanges)\n return State{\n  ChainID:         state.ChainID,\n  InitialHeight:   state.InitialHeight,\n  LastResults:     abciResponses.DeliverTxResults,\n  AppHash:         AppHash,\n  LastValidators:  state.Validators,\n  Validators:      state.NextValidators,\n  NextValidators:  UpdateValidators(state.NextValidators, ValidatorChanges),\n  ConsensusParams: nextConsensusParams,\n  Version: {\n   Consensus: {\n    AppVersion: nextConsensusParams.Version.AppVersion,\n   },\n  },\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service for Remote Mempool in CometBFT\nDESCRIPTION: Protocol Buffer definition for the RemoteMempoolService which enables CometBFT validators to interact with a remote mempool. The service includes methods for fetching transactions, removing transactions after block commitment, and receiving notifications about available transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-110-remote-mempool.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\npackage tendermint.services.remote_mempool.v1;\n\n// RemoteMempoolService is implemented by a remote mempool instance. A CometBFT\n// validator makes use of a client generated from this interface definition to\n// interact with the remote mempool.\n//\n// It is up to the implementer of the remote mempool to define transaction\n// submission mechanisms/interfaces.\nservice RemoteMempoolService {\n    // Fetch allows a CometBFT validator to obtain the next batch of\n    // transactions to be included during PrepareProposal when the current node\n    // is a proposer.\n    rpc Fetch(FetchRequest) returns (FetchResponse);\n\n    // Remove takes a set of transaction keys and removes the corresponding\n    // transactions from the mempool.\n    //\n    // This will only be called after the block is committed by consensus.\n    rpc Remove(RemoveRequest) returns (RemoveResponse);\n\n    // TxsAvailable streams notifications back to the client that new\n    // transactions are available in the mempool.\n    //\n    // The mempool is expected to stream a TxsAvailableResponse as it has\n    // transactions available. A response, however, is only expected in two\n    // cases:\n    //\n    // 1. Once for each newly encountered height (as supplied to the mempool via\n    //    the Remove request).\n    //\n    // 2. Upon initiation of the TxsAvailable call. This caters for instances\n    //    where the consensus engine may have failed and restarted.\n    //\n    // The consensus engine will only ever make one call to TxsAvailable and\n    // will attempt to keep the connection alive.\n    rpc TxsAvailable(TxsAvailableRequest) returns (stream TxsAvailableResponse);\n}\n\nmessage FetchRequest {\n    // Fetch as many transactions as possible that cumulatively take up at most\n    // this number of bytes. Setting this value to -1 implies no limit (this\n    // implies that the remote mempool is fully in control of this value).\n    int64 max_bytes = 1;\n}\n\nmessage FetchResponse {\n    // Transactions to be included in the proposal.\n    repeated bytes txs = 1;\n}\n\nmessage RemoveRequest {\n    // The current height of the chain.\n    uint64 height = 1;\n\n    // A list of IDs of transactions to be removed from the mempool. At present\n    // this is a list of SHA256 hashes of the transactions.\n    repeated bytes tx_ids = 2;\n}\n\nmessage RemoveResponse {}\n\nmessage TxsAvailableRequest {}\n\n// TxsAvailableResponse is to be sent once upon initiation of the TxsAvailable\n// request, as well as once for each new height, iff new transactions are\n// available to be fetched by the consensus engine.\n//\n// If a TxsAvailableResponse is sent more than once per height, the consensus\n// engine is expected to ignore the extra messages.\nmessage TxsAvailableResponse {\n    // Supplied for informational purposes to the consensus engine to indicate\n    // the height seen by the mempool during the last call to Remove.\n    uint64 last_reap_height = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Seed Mode in CometBFT (TOML)\nDESCRIPTION: Enables or disables seed mode. In seed mode, the node becomes an online address book, providing addresses to incoming connections without sharing other data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_54\n\nLANGUAGE: toml\nCODE:\n```\nseed_mode = false\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Handling Logic in Go\nDESCRIPTION: Core function that handles different types of events based on the current mode of operation, processing events specific to FastSync and Consensus modes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_19\n\nLANGUAGE: go\nCODE:\n```\nfunc handleEvent(state ControllerState, event Event) (ControllerState, Message, TimeoutTrigger, Error) {\n  msg = nil\n  timeout = nil\n  error = nil\n\n  switch state.Mode {\n  case ModeConsensus:\n    switch event := event.(type) {\n    case EventBlockRequest:\n      msg = createBlockResponseMessage(state, event)\n      return state, msg, timeout, error\n    default:\n      error = \"Only respond to BlockRequests while in ModeConsensus!\"\n      return state, msg, timeout, error\n    }\n\n  case ModeFastSync:\n    switch event := event.(type) {\n    case EventBlockRequest:\n      msg = createBlockResponseMessage(state, event)\n      return state, msg, timeout, error\n\n    case EventStatusResponse:\n      return handleEventStatusResponse(event, state)\n\n    case EventRemovePeer:\n      return handleEventRemovePeer(event, state)\n\n    case EventBlockResponse:\n      return handleEventBlockResponse(event, state)\n\n    case EventResponseTimeout:\n      return handleEventResponseTimeout(event, state)\n\n    case EventTerminationTimeout:\n      // Termination timeout is triggered in case of empty peer set and in case there are no pending requests.\n      // If this timeout expires and in the meantime no new peers are added or new pending requests are made\n      // then `fast-sync` mode terminates by switching to `ModeConsensus`.\n      // Note that termination timeout should be higher than the response timeout.\n      if state.Height == event.Height && state.PendingRequestsNum == 0 { state.State = ConsensusMode }\n      return state, msg, timeout, error\n\n    default:\n      error = \"Received unknown event type!\"\n      return state, msg, timeout, error\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Schedule and Block State Structures in Go\nDESCRIPTION: This snippet defines the core structures for the schedule system, including block states, the main schedule struct, and methods for managing block states and generating block request messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\ntype blockState int\n\nconst (\n\tblockStateNew = iota\n\tblockStatePending,\n\tblockStateReceived,\n\tblockStateProcessed\n)\n\ntype schedule {\n    // a list of blocks in which blockState\n\tblockStates        map[height]blockState\n\n    // a map of which blocks are available from which peers\n\tblockPeers         map[height]map[p2p.ID]scPeer\n\n    // a map of peerID to schedule specific peer struct `scPeer`\n\tpeers              map[p2p.ID]scPeer\n\n    // a map of heights to the peer we are waiting for a response from\n\tpending map[height]scPeer\n\n\ttargetPending  int // the number of blocks we want in blockStatePending\n\ttargetReceived int // the number of blocks we want in blockStateReceived\n\n\tpeerTimeout        int\n\tpeerMinSpeed       int\n}\n\nfunc (sc *schedule) numBlockInState(state blockState) uint32 {\n\tnum := 0\n\tfor i := sc.minHeight(); i <= sc.maxHeight(); i++ {\n\t\tif sc.blockState[i] == state {\n\t\t\tnum++\n\t\t}\n\t}\n\treturn num\n}\n\n\nfunc (sc *schedule) popSchedule(maxRequest int) []scBlockRequestMessage {\n\t// We only want to schedule requests such that we have less than sc.targetPending and sc.targetReceived\n\t// This ensures we don't saturate the network or flood the processor with unprocessed blocks\n\ttodo := min(sc.targetPending - sc.numBlockInState(blockStatePending), sc.numBlockInState(blockStateReceived))\n\tevents := []scBlockRequestMessage{}\n\tfor i := sc.minHeight(); i < sc.maxMaxHeight(); i++ {\n\t\tif todo == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif blockStates[i] == blockStateNew {\n\t\t\tpeer = sc.selectPeer(blockPeers[i])\n\t\t\tsc.blockStates[i] = blockStatePending\n\t\t\tsc.pending[i] = peer\n\t\t\tevents = append(events, scBlockRequestMessage{peerID: peer.peerID, height: i})\n\t\t\ttodo--\n\t\t}\n\t}\n\treturn events\n}\n\ntype scPeer struct {\n\tpeerID               p2p.ID\n\tnumOutstandingRequest int\n\tlastTouched          time.Time\n\tmonitor              flow.Monitor\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving the Latest Previous Trusted Light Block by Height - Go\nDESCRIPTION: Defines the method signature for LatestPrevious, a Go method on LightStore that retrieves the most recent, not expired, trusted light block below a given height. Uses the store's tracking of trusted blocks; returns (LightBlock, bool) indicating presence. Users must ensure height is meaningful for their query; outputs the block and a Boolean flag.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\nfunc (ls LightStore) LatestPrevious(height Height) (LightBlock, bool)\n```\n\n----------------------------------------\n\nTITLE: ReverseSync Function Signature in Go\nDESCRIPTION: Function signature for the ReverseSync process that fetches and verifies blocks until reaching a block that meets the historical requirements.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc ReverseSync(max_historical_height int64, max_historical_time time.Time) error\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Definition for HaveTx Message\nDESCRIPTION: Protocol Buffer definition for the HaveTx message, which is sent by a node to inform another node that it already has a specific transaction. The tx_key field contains the transaction hash.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nmessage HaveTx {\n  bytes tx_key = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Flood Protocol State - Bluespec\nDESCRIPTION: Specifies the initial action for protocol state setup, combining the underlying mempool initialization and setting senders mappings to empty for all nodes. This ensures a clean start where no transactions have been disseminated or received. It must be called at the beginning of any simulation or model execution.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_3\n\nLANGUAGE: bluespec\nCODE:\n```\naction init = all {\n    MP_init,\n    senders' = NodeIDs.mapBy(n => Map()),\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to CometBFT Websocket\nDESCRIPTION: Command to establish a Websocket connection to a CometBFT node using wscat CLI tool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/subscription.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nwscat -c ws://127.0.0.1:26657/websocket\n```\n\n----------------------------------------\n\nTITLE: Implementing PSQLEventSink in Go for CometBFT\nDESCRIPTION: Go code implementing the PSQLEventSink, which conforms to the EventSink interface. It includes methods for creating a new sink, indexing block events, and indexing transaction events. Some methods like SearchBlockEvents are not implemented.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-065-custom-event-indexing.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc NewEventSink(connStr, chainID string) (*EventSink, error) {\n\tdb, err := sql.Open(driverName, connStr)\n\t// ...\n\n\treturn &EventSink{\n\t\tstore:   db,\n\t\tchainID: chainID,\n\t}, nil\n}\n\nfunc (es *EventSink) IndexBlockEvents(h types.EventDataNewBlockHeader) error {\n\tts := time.Now().UTC()\n\n\treturn runInTransaction(es.store, func(tx *sql.Tx) error {\n\t\t// Add the block to the blocks table and report back its row ID for use\n\t\t// in indexing the events for the block.\n\t\tblockID, err := queryWithID(tx, `\nINSERT INTO blocks (height, chain_id, created_at)\n  VALUES ($1, $2, $3)\n  ON CONFLICT DO NOTHING\n  RETURNING rowid;\n`, h.Header.Height, es.chainID, ts)\n\t\t// ...\n\n\t\t// Insert the special block meta-event for height.\n\t\tif err := insertEvents(tx, blockID, 0, []abci.Event{\n\t\t\tmakeIndexedEvent(types.BlockHeightKey, fmt.Sprint(h.Header.Height)),\n\t\t}); err != nil {\n\t\t\treturn fmt.Errorf(\"block meta-events: %w\", err)\n\t\t}\n\t\t// Insert all the block events. Order is important here,\n\t\tif err := insertEvents(tx, blockID, 0, h.ResultBeginBlock.Events); err != nil {\n\t\t\treturn fmt.Errorf(\"begin-block events: %w\", err)\n\t\t}\n\t\tif err := insertEvents(tx, blockID, 0, h.ResultEndBlock.Events); err != nil {\n\t\t\treturn fmt.Errorf(\"end-block events: %w\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (es *EventSink) IndexTxEvents(txrs []*abci.TxResult) error {\n\tts := time.Now().UTC()\n\n\tfor _, txr := range txrs {\n\t\t// Encode the result message in protobuf wire format for indexing.\n\t\tresultData, err := proto.Marshal(txr)\n\t\t// ...\n\n\t\t// Index the hash of the underlying transaction as a hex string.\n\t\ttxHash := fmt.Sprintf(\"%X\", types.Tx(txr.Tx).Hash())\n\n\t\tif err := runInTransaction(es.store, func(tx *sql.Tx) error {\n\t\t\t// Find the block associated with this transaction.\n\t\t\tblockID, err := queryWithID(tx, `\nSELECT rowid FROM blocks WHERE height = $1 AND chain_id = $2;\n`, txr.Height, es.chainID)\n\t\t\t// ...\n\n\t\t\t// Insert a record for this tx_result and capture its ID for indexing events.\n\t\t\ttxID, err := queryWithID(tx, `\nINSERT INTO tx_results (block_id, index, created_at, tx_hash, tx_result)\n  VALUES ($1, $2, $3, $4, $5)\n  ON CONFLICT DO NOTHING\n  RETURNING rowid;\n`, blockID, txr.Index, ts, txHash, resultData)\n\t\t\t// ...\n\n\t\t\t// Insert the special transaction meta-events for hash and height.\n\t\t\tif err := insertEvents(tx, blockID, txID, []abci.Event{\n\t\t\t\tmakeIndexedEvent(types.TxHashKey, txHash),\n\t\t\t\tmakeIndexedEvent(types.TxHeightKey, fmt.Sprint(txr.Height)),\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"indexing transaction meta-events: %w\", err)\n\t\t\t}\n\t\t\t// Index any events packaged with the transaction.\n\t\t\tif err := insertEvents(tx, blockID, txID, txr.Result.Events); err != nil {\n\t\t\t\treturn fmt.Errorf(\"indexing transaction events: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SearchBlockEvents is not implemented by this sink, and reports an error for all queries.\nfunc (es *EventSink) SearchBlockEvents(ctx context.Context, q *query.Query) ([]int64, error)\n\n// SearchTxEvents is not implemented by this sink, and reports an error for all queries.\nfunc (es *EventSink) SearchTxEvents(ctx context.Context, q *query.Query) ([]*abci.TxResult, error)\n\n// GetTxByHash is not implemented by this sink, and reports an error for all queries.\nfunc (es *EventSink) GetTxByHash(hash []byte) (*abci.TxResult, error)\n\n// HasBlock is not implemented by this sink, and reports an error for all queries.\nfunc (es *EventSink) HasBlock(h int64) (bool, error)\n```\n\n----------------------------------------\n\nTITLE: Performing CometBFT-Application Handshake in Shell\nDESCRIPTION: This snippet demonstrates the log output during the handshake process between CometBFT and the application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:27.367] ABCI Handshake                               module=consensus appHeight=90 appHash=E0FBAFBF6FCED8B9786DDFEB1A0D4FA2501BADAD\nI[10-04|13:54:27.368] ABCI Replay Blocks                           module=consensus appHeight=90 storeHeight=90 stateHeight=90\nI[10-04|13:54:27.368] Completed ABCI Handshake - CometBFT and App are synced module=consensus appHeight=90 appHash=E0FBAFBF6FCED8B9786DDFEB1A0D4FA2501BADAD\n```\n\n----------------------------------------\n\nTITLE: Defining Auxiliary Helper Functions for Light Client Verification in Go\nDESCRIPTION: Defines several auxiliary Go functions used within the light client verification logic. `matchingCommit` checks if a commit corresponds to a given header hash. `signers` identifies the validators from a set that correctly signed a commit (computationally potentially expensive). `votingPowerIn` calculates the voting power of a subset of validators (`v1`) based on their power in a potentially different set (`v2`). `hash` computes the hash of a given validator set.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n```go\n    // returns true if the commit is for the header, ie. if it contains\n    // the correct hash of the header; otherwise false\n    func matchingCommit(header Header, commit Commit) bool\n\n    // returns the set of validators from the given validator set that\n    // committed the block (that correctly signed the block)\n    // it assumes signature verification so it can be computationally expensive\n    func signers(commit Commit, validatorSet ValidatorSet) []Validator\n\n    // returns the voting power the validators in v1 have according to their voting power in set v2\n    // it does not assume signature verification\n    func votingPowerIn(v1 []Validator, v2 ValidatorSet) int64\n\n    // returns hash of the given validator set\n    func hash(v2 ValidatorSet) []byte\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Light Client Attack Evidence Structs in Go\nDESCRIPTION: Defines the structure LightClientAttackEvidence for encapsulating details about a detected attack, namely the conflicting block and the common height where the fork happens, and InternalEvidence for wrapping the attack evidence with a peer identifier for attribution. These types require the LightBlock and PeerID types, which are expected to be available in the CometBFT codebase, as dependencies. Inputs are the properties of each struct, and outputs are Go values of the respective evidence types; these types are constrained to the available block and peer representations in the system.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_001_reviewed.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n    ConflictingBlock   LightBlock\n    CommonHeight       int64\n}\n```\n\nLANGUAGE: go\nCODE:\n```\ntype InternalEvidence struct {\n    Evidence           LightClientAttackEvidence\n    Peer               PeerID\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Peer Catchup Sleep Interval in Golang for CometBFT Mempool\nDESCRIPTION: This code snippet implements an optimization in the mempool's broadcastTxRoutine. It checks if a peer is lagging behind and introduces a sleep interval before attempting to send a transaction, potentially reducing unnecessary network traffic and improving performance for catching-up nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-103-incoming-txs-when-catching-up.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\nif peerState.GetHeight() < memTx.Height()-1 {\n  time.Sleep(PeerCatchupSleepIntervalMS * time.Millisecond)\n  continue\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing gRPC Client API for CometBFT in Go\nDESCRIPTION: Defines the Go client API for interacting with a CometBFT node via gRPC. It provides a Client interface that combines all service clients, along with options for configuring connection security and other gRPC dial options.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-106-grpc-api.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage client\n\ntype Option func(*clientBuilder)\n\n// Client defines the full client interface for interacting with a CometBFT node\n// via its gRPC.\ntype Client interface {\n    ApplicationServiceClient\n    BlockResultsServiceClient\n    BlockServiceClient\n    NodeServiceClient\n    TransactionServiceClient\n    VersionServiceClient\n\n\t// Close the connection to the server. Any subsequent requests will fail.\n\tClose() error\n}\n\n// WithInsecure disables transport security for the underlying client\n// connection.\n//\n// A shortcut for using grpc.WithTransportCredentials and\n// insecure.NewCredentials from google.golang.org/grpc.\nfunc WithInsecure() Option {\n    // ...\n}\n\n// WithGRPCDialOption allows passing lower-level gRPC dial options through to\n// the gRPC dialer when creating the client.\nfunc WithGRPCDialOption(opt ggrpc.DialOption) Option {\n    // ...\n}\n\n// New constructs a client for interacting with a CometBFT node via gRPC.\n//\n// Makes no assumptions about whether or not to use TLS to connect to the given\n// address. To connect to a gRPC server without using TLS, use the WithInsecure\n// option.\n//\n// To connect to a gRPC server with TLS, use the WithGRPCDialOption option with\n// the appropriate gRPC credentials configuration. See\n// https://pkg.go.dev/google.golang.org/grpc#WithTransportCredentials\nfunc New(ctx context.Context, addr string, opts ...Option) (Client, error) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DeliverTx in CounterApplication (Go)\nDESCRIPTION: Modified DeliverTx method in CounterApplication to restore the original transaction count before processing. This ensures consistency between the CheckBlock and DeliverTx phases.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-029-check-tx-consensus.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *CounterApplication) DeliverTx(tx []byte) types.ResponseDeliverTx {\n   if app.serial {\n      app.txCount = app.originalTxCount   //restore the txCount state\n   }\n   app.txCount++\n   return types.ResponseDeliverTx{Code: code.CodeTypeOK}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Entry Struct for Batch Verification in Go\nDESCRIPTION: This code snippet shows a simple implementation of an entry struct used in batch verification. It contains fields for public key, signature, and message.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-064-batch-verification.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype entry struct {\n  pubKey crypto.Pubkey\n  signature []byte\n  message []byte\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Reception in Blockchain Reactor in Go\nDESCRIPTION: Defines the Receive method for the BlockchainReactor which forwards incoming messages to the main message channel for processing by the appropriate routines.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (bcR *BlockchainReactor) Receive(...) {\n\t...\n\tr.msgs <- msg\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Light Client in CometBFT\nDESCRIPTION: Function signature for creating a new light client. It can be created from scratch or using a trusted store. The function requires chainID, trust options, primary provider, witnesses, and a trusted store.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-046-light-client-implementation.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc NewClient(\n\tchainID string,\n\ttrustOptions TrustOptions,\n\tprimary provider.Provider,\n\twitnesses []provider.Provider,\n\ttrustedStore store.Store,\n\toptions ...Option) (*Client, error) {\n```\n\n----------------------------------------\n\nTITLE: Defining CryptoProvider Interface in Go\nDESCRIPTION: This code snippet defines the CryptoProvider interface, which aggregates functionalities for signing, verifying, hashing, and providing metadata.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-117-cryptoprovider-implementation.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// CryptoProvider aggregates the functionalities of signing, verifying, and hashing, and provides metadata.\ntype CryptoProvider interface {\n    // GetSigner returns an instance of Signer.\n    GetSigner() Signer\n\n    // GetVerifier returns an instance of Verifier.\n    GetVerifier() Verifier\n\n    // GetHasher returns an instance of Hasher.\n    GetHasher() Hasher\n\n    // Metadata returns metadata for the crypto provider.\n    Metadata() ProviderMetadata\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Event Structure in Protobuf\nDESCRIPTION: Protobuf schema for the Event structure used to associate metadata with transactions and blocks. Events contain a type field and a list of attributes that are key-value pairs with an index flag for searchability.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_basic_concepts.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Event {\n  string                  type       = 1;\n  repeated EventAttribute attributes = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P External Address in TOML\nDESCRIPTION: Sets the TCP address that peers should use to connect to the node. Useful when running on non-routable addresses or cloud services.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_40\n\nLANGUAGE: toml\nCODE:\n```\nexternal_address = \"\"\n```\n\n----------------------------------------\n\nTITLE: Stopping a Peer on Error - CometBFT Switch API - Go\nDESCRIPTION: StopPeerForError(peer Peer, reason interface{}) allows a reactor to forcibly disconnect a peer due to protocol or communication errors. It takes a Peer and an error reason (as any interface) as parameters and returns nothing. If the peer is persistent, reconnection will be attempted by the Switch. The typical usage is for handling bad protocol messages or unrecoverable peer failures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) StopPeerForError(peer Peer, reason interface{})\n```\n\n----------------------------------------\n\nTITLE: Initializing Sequential-Supervisor Function in Go\nDESCRIPTION: The Sequential-Supervisor function manages the lightclient's primary operations including initialization, verification, and light block cross-checking. It uses LCInitData for setup and loops until an error or attack is detected.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc Sequential-Supervisor (initdata LCInitData) (Error) {\n\n    lightStore,result := InitLightClient(initData);\n    if result != OK {\n        return result;\n    }\n\n    loop {\n        // get the next height\n        nextHeight := input();\n  \n        lightStore,result := VerifyAndDetect(lightStore, nextHeight);\n  \n        if result == OK {\n            output(LightStore.Get(targetHeight));\n   // we only output a trusted lightblock\n        }\n        else {\n            return result\n        }\n        // QUESTION: is it OK to generate output event in normal case,\n        // and terminate with failure in the (light client) attack case?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Block Response Messages in Go\nDESCRIPTION: Function that creates a block response message to be sent to a requesting peer, checking if the peer exists in the peer map and handling accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_20\n\nLANGUAGE: go\nCODE:\n```\nfunc createBlockResponseMessage(state ControllerState, event BlockRequest) MessageToSend {\n  msgToSend = nil\n  if _, ok := state.PeerMap[event.PeerID]; !ok { peerStats = PeerStats{-1, -1} }\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving Previously Verified LightBlocks from LightStore - Go\nDESCRIPTION: This function fetches the most recent verified LightBlock in the LightStore before a specified height, facilitating efficient traversal or synchronization operations. It supports relayer or light client operations by enabling reverse lookups over trusted chains of blocks. The return includes the block and a boolean indicating success. Requires the LightStore implementation and Height types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) GetPreviousVerified(height Height) (LightBlock, bool)\n\n```\n\n----------------------------------------\n\nTITLE: CometBFT Block Creation Cycle in Shell\nDESCRIPTION: This snippet demonstrates the log output during a standard block creation cycle in CometBFT, including entering a new round, proposing a block, receiving votes, and committing a block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:30.393] enterNewRound(91/0). Current: 91/0/RoundStepNewHeight module=consensus\nI[10-04|13:54:30.393] enterPropose(91/0). Current: 91/0/RoundStepNewRound module=consensus\nI[10-04|13:54:30.393] enterPropose: Our turn to propose            module=consensus proposer=125B0E3C5512F5C2B0E1109E31885C4511570C42 privValidator=\"PrivValidator{125B0E3C5512F5C2B0E1109E31885C4511570C42 LH:90, LR:0, LS:3}\"\nI[10-04|13:54:30.394] Signed proposal                              module=consensus height=91 round=0 proposal=\"Proposal{91/0 1:21B79872514F (-1,:0:000000000000) {/10EDEDD7C84E.../}}\"\nI[10-04|13:54:30.397] Received complete proposal block             module=consensus height=91 hash=F671D562C7B9242900A286E1882EE64E5556FE9E\nI[10-04|13:54:30.397] enterPrevote(91/0). Current: 91/0/RoundStepPropose module=consensus\nI[10-04|13:54:30.397] enterPrevote: ProposalBlock is valid         module=consensus height=91 round=0\nI[10-04|13:54:30.398] Signed and pushed vote                       module=consensus height=91 round=0 vote=\"Vote{0:125B0E3C5512 91/00/1(Prevote) F671D562C7B9 {/89047FFC21D8.../}}\" err=null\nI[10-04|13:54:30.401] Added to prevote                             module=consensus vote=\"Vote{0:125B0E3C5512 91/00/1(Prevote) F671D562C7B9 {/89047FFC21D8.../}}\" prevotes=\"VoteSet{H:91 R:0 T:1 +2/3:F671D562C7B9242900A286E1882EE64E5556FE9E:1:21B79872514F BA{1:X} map[]}\"\nI[10-04|13:54:30.401] enterPrecommit(91/0). Current: 91/0/RoundStepPrevote module=consensus\nI[10-04|13:54:30.401] enterPrecommit: +2/3 prevoted proposal block. Locking module=consensus hash=F671D562C7B9242900A286E1882EE64E5556FE9E\nI[10-04|13:54:30.402] Signed and pushed vote                       module=consensus height=91 round=0 vote=\"Vote{0:125B0E3C5512 91/00/2(Precommit) F671D562C7B9 {/80533478E41A.../}}\" err=null\nI[10-04|13:54:30.404] Added to precommit                           module=consensus vote=\"Vote{0:125B0E3C5512 91/00/2(Precommit) F671D562C7B9 {/80533478E41A.../}}\" precommits=\"VoteSet{H:91 R:0 T:2 +2/3:F671D562C7B9242900A286E1882EE64E5556FE9E:1:21B79872514F BA{1:X} map[]}\"\nI[10-04|13:54:30.404] enterCommit(91/0). Current: 91/0/RoundStepPrecommit module=consensus\nI[10-04|13:54:30.405] Finalizing commit of block with 0 txs        module=consensus height=91 hash=F671D562C7B9242900A286E1882EE64E5556FE9E root=E0FBAFBF6FCED8B9786DDFEB1A0D4FA2501BADAD\nI[10-04|13:54:30.405] Block{\n  Header{\n    ChainID:        test-chain-3MNw2N\n    Height:         91\n    Time:           2017-10-04 13:54:30.393 +0000 UTC\n    NumTxs:         0\n    LastBlockID:    F15AB8BEF9A6AAB07E457A6E16BC410546AA4DC6:1:D505DA273544\n    LastCommit:     56FEF2EFDB8B37E9C6E6D635749DF3169D5F005D\n    Data:\n    Validators:     CE25FBFF2E10C0D51AA1A07C064A96931BC8B297\n    App:            E0FBAFBF6FCED8B9786DDFEB1A0D4FA2501BADAD\n  }#F671D562C7B9242900A286E1882EE64E5556FE9E\n  Data{\n\n  }#\n  Commit{\n    BlockID:    F15AB8BEF9A6AAB07E457A6E16BC410546AA4DC6:1:D505DA273544\n    Precommits: Vote{0:125B0E3C5512 90/00/2(Precommit) F15AB8BEF9A6 {/FE98E2B956F0.../}}\n  }#56FEF2EFDB8B37E9C6E6D635749DF3169D5F005D\n}#F671D562C7B9242900A286E1882EE64E5556FE9E module=consensus\nI[10-04|13:54:30.408] Executed block                               module=state height=91 validTxs=0 invalidTxs=0\nI[10-04|13:54:30.410] Committed state                              module=state height=91 txs=0 hash=E0FBAFBF6FCED8B9786DDFEB1A0D4FA2501BADAD\nI[10-04|13:54:30.410] Recheck txs                                  module=mempool numtxs=0 height=91\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction Structure for Priority-Based Mempool in Go\nDESCRIPTION: Go struct definition for the Tx type used in the new priority-based mempool. The struct contains the raw transaction data, priority and sender information from CheckTx responses, and an index field for the priority queue implementation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-067-mempool-refactor.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Tx struct {\n  // Tx represents the raw binary transaction data.\n  Tx []byte\n\n  // Priority defines the transaction's priority as specified by the application\n  // in the ResponseCheckTx response.\n  Priority int64\n\n  // Sender defines the transaction's sender as specified by the application in\n  // the ResponseCheckTx response.\n  Sender string\n\n  // Index defines the current index in the priority queue index. Note, if\n  // multiple Tx indexes are needed, this field will be removed and each Tx\n  // index will have its own wrapped Tx type.\n  Index int\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterator Interface for GoLevelDB in Go\nDESCRIPTION: Implementation of the Iterator interface for GoLevelDB, providing methods for key-value iteration with forward and reverse direction support, domain validation, and error handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/custom-db.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage goleveldb\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/syndtr/goleveldb/leveldb/iterator\"\n)\n\ntype goLevelDBIterator struct {\n\tsource    iterator.Iterator\n\tstart     []byte\n\tend       []byte\n\tisReverse bool\n\tisInvalid bool\n}\n\nfunc newGoLevelDBIterator(source iterator.Iterator, start, end []byte, isReverse bool) *goLevelDBIterator {\n\tif isReverse {\n\t\tif end == nil {\n\t\t\tsource.Last()\n\t\t} else {\n\t\t\tvalid := source.Seek(end)\n\t\t\tif valid {\n\t\t\t\teoakey := source.Key() // end or after key\n\t\t\t\tif bytes.Compare(end, eoakey) <= 0 {\n\t\t\t\t\tsource.Prev()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsource.Last()\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif start == nil {\n\t\t\tsource.First()\n\t\t} else {\n\t\t\tsource.Seek(start)\n\t\t}\n\t}\n\treturn &goLevelDBIterator{\n\t\tsource:    source,\n\t\tstart:     start,\n\t\tend:       end,\n\t\tisReverse: isReverse,\n\t\tisInvalid: false,\n\t}\n}\n\n// Domain implements Iterator.\nfunc (itr *goLevelDBIterator) Domain() (start []byte, end []byte) {\n\treturn itr.start, itr.end\n}\n\n// Valid implements Iterator.\nfunc (itr *goLevelDBIterator) Valid() bool {\n\t// Once invalid, forever invalid.\n\tif itr.isInvalid {\n\t\treturn false\n\t}\n\n\t// If source errors, invalid.\n\tif err := itr.Error(); err != nil {\n\t\titr.isInvalid = true\n\t\treturn false\n\t}\n\n\t// If source is invalid, invalid.\n\tif !itr.source.Valid() {\n\t\titr.isInvalid = true\n\t\treturn false\n\t}\n\n\t// If key is end or past it, invalid.\n\tstart := itr.start\n\tend := itr.end\n\tkey := itr.source.Key()\n\n\tif itr.isReverse {\n\t\tif start != nil && bytes.Compare(key, start) < 0 {\n\t\t\titr.isInvalid = true\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\tif end != nil && bytes.Compare(end, key) <= 0 {\n\t\t\titr.isInvalid = true\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Valid\n\treturn true\n}\n\n// Key implements Iterator.\n// The caller should not modify the contents of the returned slice.\n// Instead, the caller should make a copy and work on the copy.\nfunc (itr *goLevelDBIterator) Key() []byte {\n\titr.assertIsValid()\n\treturn itr.source.Key()\n}\n\n// Value implements Iterator.\n// The caller should not modify the contents of the returned slice.\n// Instead, the caller should make a copy and work on the copy.\nfunc (itr *goLevelDBIterator) Value() []byte {\n\titr.assertIsValid()\n\treturn itr.source.Value()\n}\n\n// Next implements Iterator.\nfunc (itr *goLevelDBIterator) Next() {\n\titr.assertIsValid()\n\tif itr.isReverse {\n\t\titr.source.Prev()\n\t} else {\n\t\titr.source.Next()\n\t}\n}\n\n// Error implements Iterator.\nfunc (itr *goLevelDBIterator) Error() error {\n\treturn itr.source.Error()\n}\n\n// Close implements Iterator.\nfunc (itr *goLevelDBIterator) Close() error {\n\titr.source.Release()\n\treturn nil\n}\n\nfunc (itr goLevelDBIterator) assertIsValid() {\n\tif !itr.Valid() {\n\t\tpanic(\"iterator is invalid\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Block Commit Response Format\nDESCRIPTION: Example JSON response from the commit endpoint showing the block height and hash in the required format for state sync configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/state-sync.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"height\": \"273\",\n  \"hash\": \"188F4F36CBCD2C91B57509BBF231C777E79B52EE3E0D90D06B1A25EB16E6E23D\"\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing ABCI Evidence in BeginBlock\nDESCRIPTION: This code snippet shows the location of the ABCI evidence definition in the protocol buffer file. It demonstrates how evidence is passed to the application in a reduced form during the BeginBlock process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-045-abci-evidence.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[evidence is passed over\\nABCI](https://github.com/tendermint/tendermint/blob/main/proto/tendermint/abci/types.proto#L354)\n```\n\n----------------------------------------\n\nTITLE: Streaming Latest Height Updates with Go\nDESCRIPTION: Implementation example of subscribing to and processing a stream of latest block height updates using gRPC streaming.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/grpc.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\"github.com/cometbft/cometbft/rpc/grpc/client\"\n)\n\nctx := context.Background()\n\n// Service Client\naddr := \"0.0.0.0:26090\"\nconn, err := client.New(ctx, addr, client.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nstream, err := conn.GetLatestHeight(ctx)\nif err != nil {\n    // Do something with the error\n}\n\nfor {\n    select {\n    case <- ctx.Done():\n        return\n    case latestHeight, ok := <-stream:\n        if ok {\n            if latestHeight.Error != nil {\n                // Do something with error\n            } else {\n                // Latest Height -> latestHeight.Height\n            }\n        } else {\n            return\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying StartRound Function for Proposer-Based Time in Go Pseudo-code\nDESCRIPTION: Compares the `StartRound` function from the original Tendermint arXiv paper specification with the modified version for Proposer-Based Time. The modified version introduces a wait condition (`wait until now_p > block time of block h_p - 1`) before the proposer creates a proposal and includes the proposer's current time (`now_p`) alongside the value in the proposal message `(value, now_p)`. This change aims to tie the block time more closely to the proposer's clock, assuming synchronized clocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts_001_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunction StartRound(round) {\n round_p ← round\n step_p ← propose\n if proposer(h_p, round_p) = p {\n\n \n  if validValue_p != nil {\n\n   proposal ← validValue_p\n  } else {\n\n   proposal ← getValue()\n  }\n   broadcast ⟨PROPOSAL, h_p, round_p, proposal, validRound_p⟩\n } else {\n  schedule OnTimeoutPropose(h_p,round_p) to \n   be executed after timeoutPropose(round_p)\n }\n}\n```\n```\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunction StartRound(round) {\n round_p ← round\n step_p ← propose\n if proposer(h_p, round_p) = p {\n  // new wait condition\n  wait until now_p > block time of block h_p - 1\n  if validValue_p != nil {\n   // add \"now_p\"\n   proposal ← (validValue_p, now_p) \n  } else {\n   // add \"now_p\"\n   proposal ← (getValue(), now_p) \n  }\n  broadcast ⟨PROPOSAL, h_p, round_p, proposal, validRound_p⟩\n } else {\n  schedule OnTimeoutPropose(h_p,round_p) to \n   be executed after timeoutPropose(round_p)\n }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Updating CommitSig Structure in Go\nDESCRIPTION: Modifies the CommitSig struct by removing the Timestamp field, which is no longer used in the proposer-based timestamp mechanism.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-071-proposer-based-timestamps.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype CommitSig struct {\n\tBlockIDFlag      BlockIDFlag `json:\"block_id_flag\"`\n\tValidatorAddress Address     `json:\"validator_address\"`\n\tSignature        []byte      `json:\"signature\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Indexer Retain Height with CometBFT Privileged Client in Go\nDESCRIPTION: Code example for setting the transaction indexer retain height using CometBFT's privileged service client. This determines the height up to which the node will keep transaction indexed data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\"github.com/cometbft/cometbft/rpc/grpc/client/privileged\"\n)\n\nctx := context.Background()\n\n// Privileged Service Client\naddr := \"0.0.0.0:26091\"\nconn, err := privileged.New(ctx, addr, privileged.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nerr := conn.SetTxIndexerRetainHeight(ctx, height)\nif err != nil {\n    // Do something with the error\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Validator Information in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving validator information. The validators endpoint allows fetching validator data for a specific block height with pagination support.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/validators\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"validators\\\",\\\"params\\\":{\\\"height\\\":\\\"1\\\", \\\"page\\\":\\\"1\\\", \\\"per_page\\\":\\\"20\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Setting Block Indexer Retain Height with CometBFT Privileged Client in Go\nDESCRIPTION: Code example for setting the block indexer retain height using CometBFT's privileged service client. This determines the height up to which the node will keep block indexed data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\"github.com/cometbft/cometbft/rpc/grpc/client/privileged\"\n)\n\nctx := context.Background()\n\n// Privileged Service Client\naddr := \"0.0.0.0:26091\"\nconn, err := privileged.New(ctx, addr, privileged.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nerr := conn.SetBlockIndexerRetainHeight(ctx, height)\nif err != nil {\n    // Do something with the error\n}\n```\n\n----------------------------------------\n\nTITLE: Making JSON-RPC Request to CometBFT Endpoint\nDESCRIPTION: Example of making a JSON-RPC request to the CometBFT endpoint to fetch a block at height 5 using curl.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-102-rpc-companion.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' http://cosmos.host:26657\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types for Fast Sync Protocol in Go\nDESCRIPTION: Definition of message types used in the Fast Sync protocol communication between nodes, including status requests/responses and block requests/responses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Message int\nconst (\n  MessageUnknown Message = iota\n  MessageStatusRequest\n  MessageStatusResponse\n  MessageBlockRequest\n  MessageBlockResponse\n)\n```\n\n----------------------------------------\n\nTITLE: Defining LightBlock Data Structure in Go\nDESCRIPTION: Definition of the core LightBlock data structure used by the light client protocol. It contains a Header, Commit, and ValidatorSet which are essential for verification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype LightBlock struct {\n  Header          Header\n  Commit          Commit\n  Validators      ValidatorSet\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Header Verification with Time Checks in Go\nDESCRIPTION: Implements the `VerifySingle` function in Go, which attempts to validate an untrusted header (`untrustedSh`), its validator set (`untrustedVs`), and the next validator set (`untrustedNextVs`) against a known trusted state (`trustedState`). It ensures the trusted state is within its `trustingPeriod` and the untrusted header's time is within the allowed `clockDrift` relative to the current `now`. It relies on the internal `verifySingle` for core validation logic. Also includes the `isWithinTrustedPeriod` helper function.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc VerifySingle(untrustedSh SignedHeader,\n                  untrustedVs ValidatorSet,\n                  untrustedNextVs ValidatorSet,\n                  trustedState TrustedState,\n                  trustThreshold float,\n                  trustingPeriod Duration,\n                  clockDrift Duration,\n                  now Time) (TrustedState, error) {\n\n    if untrustedSh.Header.Time > now + clockDrift {\n        return (trustedState, ErrInvalidHeaderTime)\n    }\n\n    trustedHeader = trustedState.SignedHeader.Header\n    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {\n        return (state, ErrHeaderNotWithinTrustedPeriod)\n    }\n\n    // we assume that time it takes to execute verifySingle function\n    // is several order of magnitudes smaller than trustingPeriod\n    error = verifySingle(\n                trustedState,\n                untrustedSh,\n                untrustedVs,\n                untrustedNextVs,\n                trustThreshold)\n\n    if error != nil return (state, error)\n\n    // the untrusted header is now trusted\n    newTrustedState = TrustedState(untrustedSh, untrustedNextVs)\n    return (newTrustedState, nil)\n}\n\n// return true if header is within its light client trusted period; otherwise returns false\nfunc isWithinTrustedPeriod(header Header,\n                           trustingPeriod Duration,\n                           now Time) bool {\n\n    return header.Time + trustedPeriod > now\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing StorePeerBehaviour for Testing in Go\nDESCRIPTION: This snippet introduces a StorePeerBehaviour implementation for unit testing, which stores peer behaviors instead of acting on them.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-039-peer-behaviour.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype ErrorBehaviours map[Peer][]ErrorBehaviourPeer\ntype GoodBehaviours map[Peer][]GoodBehaviourPeer\n\ntype StorePeerBehaviour struct {\n    eb ErrorBehaviours\n    gb GoodBehaviours\n}\n\nfunc NewStorePeerBehaviour() *StorePeerBehaviour{\n    return &StorePeerBehaviour{\n        eb: make(ErrorBehaviours),\n        gb: make(GoodBehaviours),\n    }\n}\n\nfunc (spb StorePeerBehaviour) Errored(peer Peer, reason ErrorBehaviourPeer) {\n    if _, ok := spb.eb[peer]; !ok {\n        spb.eb[peer] = []ErrorBehaviours{reason}\n    } else {\n        spb.eb[peer] = append(spb.eb[peer], reason)\n    }\n}\n\nfunc (mpb *StorePeerBehaviour) GetErrored() ErrorBehaviours {\n    return mpb.eb\n}\n\n\nfunc (spb StorePeerBehaviour) Behaved(peer Peer, reason GoodBehaviourPeer) {\n    if _, ok := spb.gb[peer]; !ok {\n        spb.gb[peer] = []GoodBehaviourPeer{reason}\n    } else {\n        spb.gb[peer] = append(spb.gb[peer], reason)\n    }\n}\n\nfunc (spb *StorePeerBehaviour) GetBehaved() GoodBehaviours {\n    return spb.gb\n}\n```\n\n----------------------------------------\n\nTITLE: Adding New Consensus Parameters in CometBFT\nDESCRIPTION: This diff shows the addition of new SynchronyParams and FeatureParams to the ConsensusParams struct, which are required for implementing PBTS in CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-112-proposer-based-timestamps.md#2025-04-22_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ntype ConsensusParams struct {\n        Block     BlockParams     `json:\"block\"`\n        Evidence  EvidenceParams  `json:\"evidence\"`\n        Validator ValidatorParams `json:\"validator\"`\n        Version   VersionParams   `json:\"version\"`\n        ABCI      ABCIParams      `json:\"abci\"`\n++      Synchrony SynchronyParams `json:\"synchrony\"`\n++      Feature   FeatureParams   `json:\"feature\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Remote Commit Function Signature in Go\nDESCRIPTION: Defines the Go signature for the `Commit` function, which performs an RPC call to a full node to retrieve the signed header for a specific block height. It takes a height (`int64`) and returns the `SignedHeader` and an error. The description details expected behavior based on node correctness and potential error conditions like timeouts or preconditions not being met.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc Commit(height int64) (SignedHeader, error)\n```\n\n----------------------------------------\n\nTITLE: Validating ABCI Execution in Go\nDESCRIPTION: This function checks if an ABCI execution is valid according to the grammar and execution type. It parses the execution, handles errors, and verifies the root symbols match the expected type (CleanStart or Recovery).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\ndescription: fmt.Sprintf(\"Invalid execution: parser was expecting one of [%v], got [%v] instead.\", expectedTokens, unexpectedToken),\nheight:      err.Line - 1,\n}\nerrors = append(errors, e)\n}\nif len(errors) != 0 {\nreturn errors\n}\neType := symbols.NT_Recovery\nif isCleanStart {\neType = symbols.NT_CleanStart\n}\nroots := bsrForest.GetRoots()\nfor _, r := range roots {\nfor _, s := range r.Label.Slot().Symbols {\nif s == eType {\nreturn nil\n}\n}\n}\ne := &Error{\ndescription: \"The execution is not of valid type.\",\nheight:      0,\n}\nerrors = append(errors, e)\nreturn errors\n```\n\n----------------------------------------\n\nTITLE: Implementing redundancyControl Structure in Go\nDESCRIPTION: Defines a redundancyControl structure that monitors transaction redundancy and adjusts propagation parameters. It tracks first-time transactions versus duplicates and can block HaveTx messages when redundancy exceeds target thresholds.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\ntype redundancyControl struct {\n\ttxsPerAdjustment int64\n\n\t// Pre-computed upper and lower bounds of accepted redundancy.\n\tlowerBound float64\n\tupperBound float64\n\n\tmtx          cmtsync.RWMutex\n\tfirstTimeTxs int64 // number of transactions received for the first time\n\tduplicates   int64 // number of duplicate transactions\n\n\t// If true, do not send HaveTx messages.\n\tblockHaveTx atomic.Bool\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Peer Channel Support in Go\nDESCRIPTION: This method checks if the peer supports a given channel, which is useful before attempting to send messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) HasChannel(chID byte) bool\n```\n\n----------------------------------------\n\nTITLE: Getting Configuration Values with CometBFT CLI\nDESCRIPTION: Commands to retrieve specific configuration values from CometBFT config using the get command. Demonstrates how to access both nested (mempool.size) and top-level (moniker) configuration values.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/confix/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncometbft config get mempool.size # gets the value mempool.size\ncometbft config get moniker # gets the value moniker\n```\n\n----------------------------------------\n\nTITLE: Defining Blockchain State Structure in Go\nDESCRIPTION: This snippet defines the `State` struct, which contains critical blockchain information such as chain ID, block heights, validator sets, and consensus parameters. These elements are essential for validating blocks but are not included in the block headers themselves. Dependencies include the Go types library.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/state.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype State struct {\n    ChainID        string\n    InitialHeight  int64\n\n    LastBlockHeight int64\n    LastBlockID     types.BlockID\n    LastBlockTime   time.Time\n\n    Version     Version\n    LastResults []Result\n    AppHash     []byte\n\n    LastValidators ValidatorSet\n    Validators     ValidatorSet\n    NextValidators ValidatorSet\n\n    ConsensusParams ConsensusParams\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Forks in IBC Consensus via Relayer Monitoring - Go\nDESCRIPTION: Implements a relayer-side function to detect chain forks by comparing the latest consensus state on the IBC component with the relayer's local light store. If a mismatch is found, it locates the common root and generates a new proof of fork for reporting. The function manages missing block lookups, invokes light client verification, and builds new misbehavior proofs. Dependencies include LightStore, IBCComponent, and block verification infrastructure. Inputs are the IBC component and the relayer's light store; outputs are a proof of fork or nil, with error status.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc DetectIBCFork(ibc IBCComponent, lightStore LightStore) (LightNodeProofOfFork, Error) {\n    cs = ibc.queryClientState(ibc);\n lb, found := lightStore.Get(cs.Header.Height)\n    if !found {\n **TODO:** need verify to target\n        lb, result = LightClient.Main(primary, lightStore, cs.Header.Height)\n  // [LCV-FUNC-IBCMAIN.1]\n  **TODO** decide what to do following the outcome of Issue #499\n\n  // I guess here we have to get into the light client\n\n    }\n if cs != lb {\n     // IBC component disagrees with my primary.\n  // I fetch the\n     ibcLightBlock, lblock, ibcStore, result := commonRoot(lightStore, ibc, lb)\n  pof = new LightNodeProofOfFork;\n  pof.TrustedBlock := ibcLightBlock\n  pof.PrimaryTrace := ibcStore + cs\n  pof.SecondaryTrace :=  lightStore.Subtrace(lblock.Header.Height,\n                                    lb.Header.Height);\n        return(pof, Fork)\n }\n return(nil , NoFork)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adjusting Redundancy in Bluespec\nDESCRIPTION: This snippet defines the 'adjustRedundancy' action in Bluespec, responsible for maintaining the target redundancy level of nodes within a network. It includes logic for sending 'ResetRoute' messages to random peers and resetting counters to ensure accurate redundancy recalculations. Dependencies include functions like 'controllerActions' and mechanisms for non-deterministic peer selection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_3\n\nLANGUAGE: bluespec\nCODE:\n```\naction adjustRedundancy(node) =\n    nondet randomPeer = oneOf(node.Peers())\n    val res = node.RC().controllerActions()\n    val updatedNodeRC = res._1\n    val sendResetRoute = res._2\n    all {\n        incomingMsgs' = \n            if (sendResetRoute) \n                node.send(incomingMsgs, randomPeer, ResetRouteMsg)\n            else incomingMsgs,\n        rc' = rc.put(node, updatedNodeRC.resetCounters()),\n    }\n```\n\n----------------------------------------\n\nTITLE: Testing the Pure Consensus Function in Go\nDESCRIPTION: Demonstrates how the refactored consensus implementation can be tested by feeding a sequence of events with expected outcomes, significantly simplifying test setup compared to the previous approach.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-030-consensus-refactor.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc TestConsensusXXX(t *testing.T) {\n\ttype expected struct {\n\t\tmessage Message\n\t\tstate   State\n\t}\n\n\t// Setup order of events, initial state and expectation.\n\tvar (\n\t\tevents = []struct {\n\t\t\tevent Event\n\t\t\twant  expected\n\t\t}{\n\t\t// ...\n\t\t}\n\t\tstate = State{\n\t\t// ...\n\t\t}\n\t)\n\n\tfor _, e := range events {\n\t\tstate, msg = Consensus(e.event, state)\n\n\t\t// Test message expectation.\n\t\tif msg != e.want.message {\n\t\t\tt.Fatalf(\"have %v, want %v\", msg, e.want.message)\n\t\t}\n\n\t\t// Test state expectation.\n\t\tif !reflect.DeepEqual(state, e.want.state) {\n\t\t\tt.Fatalf(\"have %v, want %v\", state, e.want.state)\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Commit Data via HTTP and JSONRPC in CometBFT\nDESCRIPTION: Examples for making commit data requests using HTTP and JSONRPC methods. The commit endpoint retrieves block commit information for a specified height or the latest commit if no height is provided.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/commit\n\n\ncurl  http://127.0.0.1:26657/v1/commit?height=1\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"commit\\\",\\\"params\\\":{\\\"height\\\":\\\"1\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Bytes for Mempool Reaping in Go\nDESCRIPTION: This code snippet demonstrates how to calculate the upper bound for reaping transactions from the mempool in CometBFT. It accounts for the exact last commit size, maximum evidence bytes, and other constants to determine the available space for transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-020-block-size.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nExactLastCommitBytes = {number of validators currently enabled} * {MaxVoteBytes}\nMaxEvidenceBytesPerBlock = MaxBytes / 10\nExactEvidenceBytes = cs.evpool.PendingEvidence(MaxEvidenceBytesPerBlock) * MaxEvidenceBytes\n\nmempool.ReapMaxBytes(MaxBytes - MaxAminoOverheadForBlock - ExactLastCommitBytes - ExactEvidenceBytes - MaxHeaderBytes)\n```\n\n----------------------------------------\n\nTITLE: Defining NodeAddress Structure for CometBFT Peer Identification\nDESCRIPTION: The NodeAddress structure and related functions for managing peer addresses in URL format. It includes parsing, validation, and resolution of node addresses into transport endpoints.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n// NodeID is a hex-encoded crypto.Address. It must be lowercased\n// (for uniqueness) and of length 40.\ntype NodeID string\n\n// NodeAddress is a node address URL. It differs from a transport Endpoint in\n// that it contains the node's ID, and that the address hostname may be resolved\n// into multiple IP addresses (and thus multiple endpoints).\n//\n// If the URL is opaque, i.e. of the form \"scheme:opaque\", then the opaque part\n// is expected to contain a node ID.\ntype NodeAddress struct {\n    NodeID   NodeID\n    Protocol Protocol\n    Hostname string\n    Port     uint16\n    Path     string\n}\n\n// ParseNodeAddress parses a node address URL into a NodeAddress, normalizing\n// and validating it.\nfunc ParseNodeAddress(urlString string) (NodeAddress, error)\n\n// Resolve resolves a NodeAddress into a set of Endpoints, e.g. by expanding\n// out a DNS hostname to IP addresses.\nfunc (a NodeAddress) Resolve(ctx context.Context) ([]Endpoint, error)\n```\n\n----------------------------------------\n\nTITLE: Batch Hashing of Items - Go\nDESCRIPTION: Hashes each input byte array using SHA256 for subsequent use in MerkleRoot computations. Useful when inputs are not already pre-hashed. Assumes each item is []byte. Input: items ([][]byte). Output: ([][]byte) with each element hashed. Requires SHA256 implementation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc Hashes(items [][]byte) [][]byte {\n    return SHA256 of each item\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Encodings for Cryptographic Keys in CometBFT\nDESCRIPTION: Shows the JSON encoding format for different types of cryptographic keys in CometBFT, including Ed25519 private and public keys, and Secp256k1 private and public keys. Each example demonstrates the structure with type and value fields.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/crypto/README.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nExample JSON encodings:\n\ned25519.PrivKey     - {\"type\":\"tendermint/PrivKeyEd25519\",\"value\":\"EVkqJO/jIXp3rkASXfh9YnyToYXRXhBr6g9cQVxPFnQBP/5povV4HTjvsy530kybxKHwEi85iU8YL0qQhSYVoQ==\"}\ned25519.PubKey      - {\"type\":\"tendermint/PubKeyEd25519\",\"value\":\"AT/+aaL1eB0477Mud9JMm8Sh8BIvOYlPGC9KkIUmFaE=\"}\ncrypto.PrivKeySecp256k1   - {\"type\":\"tendermint/PrivKeySecp256k1\",\"value\":\"zx4Pnh67N+g2V+5vZbQzEyRerX9c4ccNZOVzM9RvJ0Y=\"}\ncrypto.PubKeySecp256k1    - {\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"A8lPKJXcNl5VHt1FK8a244K9EJuS4WX1hFBnwisi0IJx\"}\n```\n\n----------------------------------------\n\nTITLE: Heartbeat Message Structure Definition in CometBFT\nDESCRIPTION: Binary encoded Heartbeat message format with SignHeartbeatRequest and SignHeartbeatReply messages. This defines the validator heartbeat mechanism with proper request/response pattern.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\nmessage Heartbeat {\n\tValidatorAddress Address \n\tValidatorIndex   int     \n\tHeight           int64   \n\tRound            int     \n\tSequence         int     \n}\n// amino registered with \"tendermint/socketpv/SignHeartbeatRequest\"\nmessage SignHeartbeatRequest {\n   Hb Heartbeat\n}\n\n// amino registered with \"tendermint/socketpv/SignHeartbeatReply\"\nmessage SignHeartbeatReply { \n   Hb     Heartbeat\n   Sig    Signature \n   Err    Error     // as defined above\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Transactions to Mempool in Bluespec\nDESCRIPTION: This snippet defines the process for adding transactions to a node's mempool using DOG and Flood protocols. Transactions are processed differently based on whether they are first-time or duplicate transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_15\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction tryAddTx(node, _incomingMsgs, optionalSender, tx) = \n    if (not(hash(tx).in(node.Cache())))\n        node.tryAddFirstTimeTx(_incomingMsgs, optionalSender, tx)\n    else\n        node.processDuplicateTx(_incomingMsgs, optionalSender, tx)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction tryAddFirstTimeTx(node, _incomingMsgs, optionalSender, tx) = \n    all {\n        node.Flood::tryAddFirstTimeTx(_incomingMsgs, optionalSender, tx),\n        rc' = rc.update(node, increaseFirstTimeTxs),\n        dr' = dr,\n    }\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction processDuplicateTx(node, _incomingMsgs, optionalSender, tx) =\n    val _rc = node.RC().increaseDuplicateTxs()\n    val updatedVars = node.replyHaveTx(_incomingMsgs, _rc, optionalSender, tx)\n    val _incomingMsgs1 = updatedVars._1\n    val _rc1 = updatedVars._2\n    all {\n        node.Flood::processDuplicateTx(_incomingMsgs1, optionalSender, tx),\n        rc' = rc.put(node, _rc1),\n        dr' = dr,\n    }\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\npure def replyHaveTx(node, _incomingMsgs, _rc, optionalSender, tx) =\n    if (optionalSender.isSome() and not(_rc.isHaveTxBlocked))\n        val targets = optionalSender.optionToSet()\n        (node.multiSend(_incomingMsgs, targets, HaveTxMsg(hash(tx))), _rc.blockHaveTx())\n    else (_incomingMsgs, _rc)\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Events via cURL\nDESCRIPTION: Example cURL command to query a paginated set of transactions by their events using the /tx_search RPC endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncurl \"localhost:26657/tx_search?query=\\\"message.sender='cosmos1...'\\\"&prove=true\"\n```\n\n----------------------------------------\n\nTITLE: Socket Protocol Error Handling Reference\nDESCRIPTION: Code reference showing how any error condition in the socket protocol is terminal not only to the request but to the entire ABCI client\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-021-socket-protocol.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nclient/socket_client.go#L149\n```\n\n----------------------------------------\n\nTITLE: Representing Senders State for Transactions - Bluespec\nDESCRIPTION: Introduces the state variable 'senders' as a mapping from node IDs to a mapping of transaction IDs to lists of peer node IDs. This records, for each node and transaction, the peers that sent the transaction to the node. List tracking (instead of set) is designed to preserve sender ordering, which may be required by protocols like DOG.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_1\n\nLANGUAGE: bluespec\nCODE:\n```\nvar senders: NodeID -> TxID -> List[NodeID]\n```\n\n----------------------------------------\n\nTITLE: Cloning CometBFT Repository\nDESCRIPTION: These commands clone the CometBFT repository from GitHub and change the current directory to the cloned repository.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/cometbft/cometbft.git\ncd cometbft\n```\n\n----------------------------------------\n\nTITLE: Defining the Commit Structure in CometBFT\nDESCRIPTION: Defines the `Commit` structure in CometBFT, which aggregates commit signatures from validators for a specific block. It includes the block height, consensus round, the corresponding `BlockID`, and an array of `CommitSig` objects.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n| Name       | Type                             | Description                                                          | Validation                                                                                                                         |\n|------------|----------------------------------|----------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|\n| Height     | int64                            | Height at which this commit was created.                             | Must be >= 0.                                                                                                                      |\n| Round      | int32                            | Round that the commit corresponds to.                                | Must be >= 0.                                                                                                                      |\n| BlockID    | [BlockID](#blockid)              | The blockID of the corresponding block.                              | If Height > 0, then it cannot be the [BlockID](#blockid) of a nil block.                                                           |\n| Signatures | Array of [CommitSig](#commitsig) | Array of commit signatures that correspond to current validator set. | If Height > 0, then the length of signatures must be > 0 and adhere to the validation of each individual [Commitsig](#commitsig).  |\n```\n\n----------------------------------------\n\nTITLE: Defining Channel and Related Types in Go for CometBFT P2P\nDESCRIPTION: Defines the Channel struct and related types for bidirectional Protobuf message exchange between peers. Includes ChannelID, Envelope, and PeerError types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// ChannelID is an arbitrary channel ID.\ntype ChannelID uint16\n\n// Channel is a bidirectional channel to exchange Protobuf messages with peers.\ntype Channel struct {\n    ID          ChannelID        // Channel ID.\n    In          <-chan Envelope  // Inbound messages (peers to reactors).\n    Out         chan<- Envelope  // outbound messages (reactors to peers)\n    Error       chan<- PeerError // Peer error reporting.\n    messageType proto.Message    // Channel's message type, for e.g. unmarshaling.\n}\n\n// Close closes the channel, also closing Out and Error.\nfunc (c *Channel) Close() error\n\n// Envelope specifies the message receiver and sender.\ntype Envelope struct {\n    From      NodeID        // Sender (empty if outbound).\n    To        NodeID        // Receiver (empty if inbound).\n    Broadcast bool          // Send to all connected peers, ignoring To.\n    Message   proto.Message // Message payload.\n}\n\n// PeerError is a peer error reported via the Error channel.\ntype PeerError struct {\n    NodeID   NodeID\n    Err      error\n}\n```\n\n----------------------------------------\n\nTITLE: Vote Signing Rules in Go\nDESCRIPTION: Outlines detailed conditions under which a vote can be signed based on height, round, and step, relative to previous signatures. Prevents double signing by ensuring sequential integrity.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nv.Height > s.Height\nv.Height == s.Height && v.Round > s.Round\nv.Height == s.Height && v.Round == s.Round && v.Step == 0x1 && s.Step == 0x20\nv.Height == s.Height && v.Round == s.Round && v.Step == 0x2 && s.Step != 0x2\n```\n\n----------------------------------------\n\nTITLE: Enabling State Synchronization in CometBFT (TOML)\nDESCRIPTION: Configures whether state synchronization is enabled on first start. State sync allows rapid bootstrapping of new nodes by fetching state machine snapshots from peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_72\n\nLANGUAGE: toml\nCODE:\n```\nenable = false\n```\n\n----------------------------------------\n\nTITLE: Reactor Registration Sequence (ABNF)\nDESCRIPTION: This ABNF snippet details the registration phase for a reactor. Before the node starts, the p2p layer calls `StreamDescriptors()` to get the channels the reactor handles, followed by `SetSwitch(*Switch)` to provide the reactor with a reference to the p2p switch for future interactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_1\n\nLANGUAGE: abnf\nCODE:\n```\nregistration    = stream-descriptors set-switch\n```\n\n----------------------------------------\n\nTITLE: Finding Common Ancestor LightBlocks Between Relayer and IBC - Go\nDESCRIPTION: Defines a routine to identify the latest common ancestor (root) block between the relayer's light store and the IBC component's known consensus states. Retrieves IBC's consensus heights, queries blocks at those heights, and searches for a connector block that allows one-step verification. Returns both chain blocks, the relevant light store, and the result status. Dependencies include access to LightStore, IBCComponent, and Height types, as well as a Connector helper function.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc commonRoot(lightStore LightStore, ibc IBCComponent, lblock\nLightBlock) (LightBlock, LightBlock, LightStore, Result) {\n\n    auxLS.Init\n\n       // first we ask for the heights the ibc component is aware of\n  ibcHeights = ibc.QueryHeightsRange(\n                     ibc.id,\n                     lightStore.LowestVerified().Height,\n                     lblock.Height - 1);\n  // this function does not exist yet. Alternatively, we may\n  // request all transactions that installed headers via CosmosSDK\n\n\n        for {\n            h, result = max(ibcHeights)\n   if result = Empty {\n       return (_, _, _, NoRoot)\n      }\n      ibcLightBlock = ibc.queryChainConsensusState(h)\n   auxLS.Update(ibcLightBlock, StateVerified);\n      connector, result := Connector(lightStore, ibcLightBlock, lblock.Header.Height)\n      if result = success {\n       return (ibcLightBlock, connector, auxLS, Success)\n   }\n   else{\n       ibcHeights.remove(h)\n      }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Provider Interface for CometBFT Light Client\nDESCRIPTION: The Provider interface represents a node that supplies blockchain data to the light client. It can be a full node or another light client, and exposes methods to retrieve signed headers and validator sets.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-046-light-client-implementation.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Provider interface {\n\tChainID() string\n\n\tSignedHeader(height int64) (*types.SignedHeader, error)\n\tValidatorSet(height int64) (*types.ValidatorSet, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Light Client Sequential Supervisor Loop in Go\nDESCRIPTION: This Go pseudocode outlines the `Sequential-Supervisor` function for the CometBFT light client. It iteratively verifies blocks from the primary node (`VerifyToTarget`), handles primary replacement on failure (`Replace_Primary`), and cross-checks verified blocks with secondaries using `Forkdetector`. If a fork is detected, proofs (`PoFs`) are submitted, and the function exits; otherwise, the verified block is marked as trusted (`StateTrusted`), and the loop continues. It assumes initialized `lightStore` and empty `PoFs` as preconditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/discussions.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc Sequential-Supervisor () (Error) {\n    loop {\n     // get the next height\n        nextHeight := input();\n  \n  // Verify\n        result := NoResult;\n        while result != ResultSuccess {\n            lightStore,result := VerifyToTarget(primary, lightStore, nextHeight);\n            if result == ResultFailure {\n    // pick new primary (promote a secondary to primary)\n    /// and delete all lightblocks above\n             // LastTrusted (they have not been cross-checked)\n             Replace_Primary();\n   }\n        }\n  \n  // Cross-check\n        PoFs := Forkdetector(lightStore, PoFs);\n        if PoFs.Empty {\n      // no fork detected with secondaries, we trust the new\n   // lightblock\n            LightStore.Update(testedLB, StateTrusted);\n        }\n        else {\n      // there is a fork, we submit the proofs and exit\n            for i, p range PoFs {\n                SubmitProofOfFork(p);\n            }\n            return(ErrorFork);\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for BroadcastEvidence in CometBFT\nDESCRIPTION: JSON-RPC request example for the broadcast_evidence method that submits evidence of validator misbehavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_47\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"broadcast_evidence\\\",\\\"params\\\":{\\\"evidence\\\":\\\"JSON_EVIDENCE_encoded\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Complete Trust Value Calculation for Tendermint Trust Metric\nDESCRIPTION: The complete formula for calculating the trust value, combining the proportional, integral, and derivative components to provide a comprehensive measure of peer trustworthiness.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_3\n\nLANGUAGE: math\nCODE:\n```\nTrustValue[i] = a * R[i] + b * H[i] + c(D[i]) * D[i]\n```\n\n----------------------------------------\n\nTITLE: Fetching Block Results with Go gRPC Client\nDESCRIPTION: Code example demonstrating how to fetch block results data using the gRPC client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/grpc.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nblockResults, err := conn.GetBlockResults(ctx, height)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with the `blockResults`\n}\n```\n\n----------------------------------------\n\nTITLE: Complete priv_validator_state.json Example in JSON\nDESCRIPTION: A comprehensive example of priv_validator_state.json showing the state after signing a block at height 36. It includes height, round, step, signature, and signbytes fields, demonstrating how the file appears after validator activity.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/priv_validator_state.json.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"height\": \"36\",\n  \"round\": 0,\n  \"step\": 3,\n  \"signature\": \"N813twXq5yC84wKGrD85X79iXPwtVytGdD3j8btwZ5ZyAAHSkNt6NBWvrTJUcMLqefPfG3SBdPHdfOedieeYCg==\",\n  \"signbytes\": \"76080211240000000000000022480A20D1823B950D1A0FD7335B4E63D2B65CF9D0CEAC13DF4E9E2DFB4765D2C69C74D0122408011220DB69B3B750BBCEAB4BC86BB1847D3E0DDB342EFAFE5731605C61A828265E09802A0C08CDF288AF0610A88CA8FE023211746573742D636861696E2D4866644B6E44\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing High-Level Header Verification at Specific Height in Go\nDESCRIPTION: Defines the `VerifyHeaderAtHeight` function in Go, serving as a high-level entry point for verifying a header at a specific `untrustedHeight`. It first checks if the current `trustedState` is still within its `trustingPeriod`. If valid, it calls `VerifyBisection` to perform the potentially multi-step verification process. It re-checks the trusting period after `VerifyBisection` returns to ensure the entire process completed within the validity window of the original trusted state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc VerifyHeaderAtHeight(untrustedHeight int64,\n                          trustedState TrustedState,\n                          trustThreshold float,\n                          trustingPeriod Duration,\n                          clockDrift Duration) (TrustedState, error)) {\n\n    trustedHeader := trustedState.SignedHeader.Header\n\n    now := System.Time()\n    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {\n        return (trustedState, ErrHeaderNotWithinTrustedPeriod)\n    }\n\n    newTrustedState, err := VerifyBisection(untrustedHeight,\n                                            trustedState,\n                                            trustThreshold,\n                                            trustingPeriod,\n                                            clockDrift,\n                                            now)\n\n    if err != nil return (trustedState, err)\n\n    now = System.Time()\n    if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {\n        return (trustedState, ErrHeaderNotWithinTrustedPeriod)\n    }\n\n    return (newTrustedState, err)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Forming ABCI Evidence in Go\nDESCRIPTION: This code snippet demonstrates how ABCI evidence is formed in the Update function. It creates an ABCI evidence object for each validator involved in the evidence, including details such as evidence type, validator info, height, time, and total voting power.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfor _, val := range evInfo.Validators {\n  abciEv = append(abciEv, &abci.Evidence{\n    Type: evType,\n    Validator: val,\n    Height: evInfo.ev.Height(),\n    Time: evInfo.time,\n    TotalVotingPower: evInfo.totalVotingPower\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Updated CometBFT Genesis File with New Validator\nDESCRIPTION: Example of an updated genesis.json file including a newly added validator for a CometBFT network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"validators\" : [\n    {\n      \"pub_key\" : {\n        \"value\" : \"h3hk+QE8c6QLTySp8TcfzclJw/BG79ziGB/pIA+DfPE=\",\n        \"type\" : \"tendermint/PubKeyEd25519\"\n      },\n      \"power\" : 10,\n      \"name\" : \"\"\n    },\n    {\n      \"pub_key\" : {\n        \"value\" : \"l9X9+fjkeBzDfPGbUM7AMIRE6uJN78zN5+lk5OYotek=\",\n        \"type\" : \"cometbft/PubKeyEd25519\"\n      },\n      \"power\" : 10,\n      \"name\" : \"\"\n    }\n  ],\n  \"app_hash\" : \"\",\n  \"chain_id\" : \"test-chain-rDlYSN\",\n  \"genesis_time\" : \"0001-01-01T00:00:00Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CheckBlock Method in BlockExecutor (Go)\nDESCRIPTION: Proposed implementation of a CheckBlock method in BlockExecutor to verify transaction validity before prevoting. This method iterates through all transactions in a block and calls CheckTxAsync on each.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-029-check-tx-consensus.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (blockExec *BlockExecutor) CheckBlock(block *types.Block) error {\n   // check txs of block.\n   for _, tx := range block.Txs {\n      reqRes := blockExec.proxyApp.CheckTxAsync(tx)\n      reqRes.Wait()\n      if reqRes.Response == nil || reqRes.Response.GetCheckTx() == nil || reqRes.Response.GetCheckTx().Code != abci.CodeTypeOK {\n         return errors.Errorf(\"tx %v check failed. response: %v\", tx, reqRes.Response)\n      }\n   }\n   return nil\n}\n```\n\n----------------------------------------\n\nTITLE: RPC Client Initialization in Go\nDESCRIPTION: Example showing how to initialize an RPC client with the new versioned WebSocket endpoint in CometBFT v1.0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\n// The WebSocket endpoint in the following example is assumed to be available\n// at http://localhost:26657/v1/websocket\nrpcClient, err := client.New(\"http://localhost:26657/v1\")\n```\n\n----------------------------------------\n\nTITLE: Defining Multisignature struct in Golang\nDESCRIPTION: Implementation of the Multisignature struct that holds the intermediate state as signatures are collected. It contains a bit array indicating which signers have signed and an array of the actual signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-019-multisigs.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\ntype Multisignature struct {\n\tBitArray    CryptoBitArray // Documented later\n\tSigs        [][]byte\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for BroadcastTxAsync in CometBFT\nDESCRIPTION: JSON-RPC request example for the broadcast_tx_async method that returns immediately without waiting for CheckTx or DeliverTx results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_35\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"broadcast_tx_async\\\",\\\"params\\\":{\\\"tx\\\":\\\"a/encoded_tx/c\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Modifying Decision Rule (Lines 49-54) for Proposer-Based Time in Go Pseudo-code\nDESCRIPTION: Compares the consensus rule for making a decision based on PROPOSAL and PRECOMMIT messages (originally lines 49-54 in the arXiv paper) with the Proposer-Based Time version. The modified rule requires receiving PRECOMMIT messages referencing an identifier that includes both value and time `id(v,t)`. Upon successful validation and collection of `2f+1` such PRECOMMITs, the decision `decision_p[h_p]` now includes both the value `v` and the proposed time `t` as a tuple `(v,t)`, incorporating the proposer-based time into the final block decision.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts_001_draft.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n```go\nupon ⟨PROPOSAL, h_p, r, v, ∗⟩ from proposer(h_p, r) \n AND 2f + 1 ⟨PRECOMMIT, h_p, r, id(v)⟩ \n while decisionp[h_p] = nil do {\n  if valid(v) {\n\n   decision_p [h_p] = v\n   h_p ← h_p + 1\n   reset lockedRound_p , lockedValue_p, validRound_p and \n    validValue_p to initial values and empty message log \n   StartRound(0)\n  }\n }\n```\n```\n\nLANGUAGE: go\nCODE:\n```\n```go\nupon ⟨PROPOSAL, h_p, r, (v,t), ∗⟩ from proposer(h_p, r) \n AND 2f + 1 ⟨PRECOMMIT, h_p, r, id(v,t)⟩\n while decisionp[h_p] = nil do {\n  if valid(v) {\n   // decide on time too\n   decision_p [h_p] = (v,t) \n   h_p ← h_p + 1\n   reset lockedRound_p , lockedValue_p, validRound_p and \n    validValue_p to initial values and empty message log \n   StartRound(0)\n  }\n }\n```\n```\n\n----------------------------------------\n\nTITLE: Message Handling and Transaction Dissemination Logic - Bluespec\nDESCRIPTION: Handles incoming peer messages by attempting to add received transactions to the node's mempool, using sender attribution to avoid redundant dissemination. Defines target peer selection for outgoing dissemination: each node pushes transactions only to peers that are not listed as prior senders, enforcing the main constraint of the Flood protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_6\n\nLANGUAGE: bluespec\nCODE:\n```\naction handleMessage(node, _incomingMsgs, sender, msg) =\n    match msg {\n    | TxMsg(tx) => node.tryAddTx(_incomingMsgs, Some(sender), tx)\n    }\n```\n\nLANGUAGE: bluespec\nCODE:\n```\ndef mkTargetNodes(node, tx) =\n    node.Peers().exclude(node.sendersOf(hash(tx)).listToSet())\n```\n\n----------------------------------------\n\nTITLE: Creating UnsyncLocalClient in Go\nDESCRIPTION: Function to create a new UnsyncLocalClient instance. This client reduces synchronization overhead by only maintaining a mutex over the callback mechanism, not over application method calls.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/abci-clients.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc NewUnsyncLocalClient(app types.Application) Client\n```\n\n----------------------------------------\n\nTITLE: Defining the Client Interface for CometBFT Light Client in Go\nDESCRIPTION: The Client interface represents a light client connected to a single blockchain. It provides methods for verifying headers, retrieving trusted headers and validators, and querying configuration options.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-046-light-client-implementation.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Client interface {\n\t// verify new headers\n\tVerifyHeaderAtHeight(height int64, now time.Time) (*types.SignedHeader, error)\n\tVerifyHeader(newHeader *types.SignedHeader, newVals *types.ValidatorSet, now time.Time) error\n\tUpdate(now time.Time) (*types.SignedHeader, error)\n\n\t// get trusted headers & validators\n\tTrustedHeader(height int64) (*types.SignedHeader, error)\n\tTrustedValidatorSet(height int64) (valSet *types.ValidatorSet, heightUsed int64, err error)\n\tLastTrustedHeight() (int64, error)\n\tFirstTrustedHeight() (int64, error)\n\n\t// query configuration options\n\tChainID() string\n\tPrimary() provider.Provider\n\tWitnesses() []provider.Provider\n\n\tCleanup() error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Peer Structure in Go for CometBFT\nDESCRIPTION: This snippet defines the Peer structure used in CometBFT's blockchain reactor. It includes fields for tracking peer state, last interaction times, pending requests, and the peer's reported height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\ntype Peer struct {\n\tlastTouched timestamp\n\tlastDownloaded timestamp\n\tpending map[height]struct{}\n\theight height // max height for the peer\n\tstate {\n\t\tpending,   // we know the peer but not the height\n\t\tactive,    // we know the height\n\t\ttimeout    // the peer has timed out\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout Commit in CometBFT\nDESCRIPTION: Configures how long a node waits after committing a block before starting the next height. This parameter gives nodes time to gather additional precommits beyond the mandatory +2/3 requirement, enhancing safety guarantees.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_86\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_commit = \"1s\"\n```\n\n----------------------------------------\n\nTITLE: Examining Conflicting Header Against Trace in Go\nDESCRIPTION: This function examines a conflicting header against a trace of light blocks. It takes a trace, target block, source provider, and current time as input parameters, and returns a slice of light blocks, a light block, and an error.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (c *Client) examineConflictingHeaderAgainstTrace(\n\ttrace []*types.LightBlock,\n\ttargetBlock *types.LightBlock,\n\tsource provider.Provider,\n\tnow time.Time,\n\t) ([]*types.LightBlock, *types.LightBlock, error)\n```\n\n----------------------------------------\n\nTITLE: Requesting Consensus Parameters in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving consensus parameters. This endpoint retrieves the rules governing block validation, evidence handling, and validator operations at a specific block height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_23\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/consensus_params\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"consensus_params\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Updated Evidence Interface in Go\nDESCRIPTION: This code snippet shows the updated Evidence interface with simplified methods, allowing for both individual and batch evidence types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype Evidence interface {  //proposed\n  Height() int64                                     // height of the offense\n  Bytes() []byte                                     // bytes which comprise the evidence\n  Hash() []byte                                      // hash of the evidence\n  ValidateBasic() error\n  String() string\n}\n```\n\n----------------------------------------\n\nTITLE: Original Commit and Vote Structures in Go\nDESCRIPTION: The original implementation of Commit structure containing a list of precommits where each precommit includes the complete Vote structure, leading to significant data redundancy.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-025-commit.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Commit struct {\n    BlockID    BlockID `json:\"block_id\"`\n    Precommits []*Vote `json:\"precommits\"`\n}\n\ntype Vote struct {\n    ValidatorAddress Address   `json:\"validator_address\"`\n    ValidatorIndex   int       `json:\"validator_index\"`\n    Height           int64     `json:\"height\"`\n    Round            int       `json:\"round\"`\n    Timestamp        time.Time `json:\"timestamp\"`\n    Type             byte      `json:\"type\"`\n    BlockID          BlockID   `json:\"block_id\"`\n    Signature        []byte    `json:\"signature\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Verify Function for Header Verification in CometBFT\nDESCRIPTION: Pure function for verifying blockchain headers. It handles both adjacent and non-adjacent headers, comparing either hashes directly or verifying that a sufficient portion of trusted validators are still present in the new validator set.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-046-light-client-implementation.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc Verify(\n\tchainID string,\n\ttrustedHeader *types.SignedHeader, // height=X\n\ttrustedVals *types.ValidatorSet, // height=X or height=X+1\n\tuntrustedHeader *types.SignedHeader, // height=Y\n\tuntrustedVals *types.ValidatorSet, // height=Y\n\ttrustingPeriod time.Duration,\n\tnow time.Time,\n\tmaxClockDrift time.Duration,\n\ttrustLevel tmmath.Fraction) error {\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Definition for Abstract Mempool Message\nDESCRIPTION: Protocol Buffer definition for the abstract Message type that includes all possible mempool message types: Txs for transactions, HaveTx for duplicate notification, and ResetRoute for route reset.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// Message is an abstract mempool message.\nmessage Message {\n  // Sum of all possible messages.\n  oneof sum {\n    Txs txs = 1;\n    HaveTx have_tx = 2;\n    ResetRoute reset_route = 3;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Propose Timeout for Consensus in CometBFT (TOML)\nDESCRIPTION: Defines how long a node waits for the proposal block before prevoting nil. Should be large enough to account for common-case propagation delays of Proposal and BlockPart messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_82\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_propose = \"3s\"\n```\n\n----------------------------------------\n\nTITLE: Proposed ProposeTx Method for ABCI Interface\nDESCRIPTION: Definition of the proposed ProposeTx method signature for the ABCI interface, which would allow applications to propose specific transactions for inclusion in blocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-023-ABCI-propose-tx.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nProposeTx(RequestProposeTx) ResponseProposeTx\n```\n\n----------------------------------------\n\nTITLE: Detecting Divergence in Light Client in Go\nDESCRIPTION: This function is responsible for detecting divergence in the light client. It takes a primary trace of light blocks and the current time as input parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (c *Client) detectDivergence(primaryTrace []*types.LightBlock, now time.Time) error\n```\n\n----------------------------------------\n\nTITLE: Defining the Part Structure in CometBFT\nDESCRIPTION: Defines the `Part` structure used for gossiping blocks in CometBFT. Each part contains its index, the byte payload, and a Merkle proof (`Proof`) for verification against the `PartSetHeader`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| Name  | Type            | Description                       | Validation           |\n|-------|-----------------|-----------------------------------|----------------------|\n| index | int32           | Total amount of parts for a block | Must be >= 0         |\n| bytes | bytes           | MerkleRoot of a serialized block  | Must be of length 32 |\n| proof | [Proof](#proof) | MerkleRoot of a serialized block  | Must be of length 32 |\n```\n\n----------------------------------------\n\nTITLE: Processing Old PREVOTE Messages in PBTS\nDESCRIPTION: Handler for processing previous round PREVOTE messages, ensuring value consistency across rounds with different proposed times.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts-algorithm_001_draft.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nupon timely(⟨PROPOSAL, h_p, round_p, (v, tprop), vr⟩) from proposer(h_p, round_p) AND 2f + 1 ⟨PREVOTE, h_p, vr, id((v, tvote)⟩ \nwhile step_p = propose ∧ (vr ≥ 0 ∧ vr < round_p) do {\n  if valid(v) ∧ (lockedRound_p ≤ vr ∨ lockedValue_p = v) {\n    broadcast ⟨PREVOTE, h_p, roundp, id(v, tprop)⟩\n  }\n  else {\n    broadcast ⟨PREVOTE, hp, roundp, nil⟩\n  }\n  step_p ← prevote\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Router Struct and Methods for CometBFT P2P Networking\nDESCRIPTION: Defines the Router struct and its methods for maintaining peer connections and routing messages between peers and channels in CometBFT's P2P network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// Router maintains peer transport connections and routes messages between\n// peers and channels.\ntype Router struct {\n    // Some details have been omitted below.\n\n    logger          log.Logger\n    options         RouterOptions\n    nodeInfo        NodeInfo\n    privKey         crypto.PrivKey\n    peerManager     *PeerManager\n    transports      []Transport\n\n    peerMtx         sync.RWMutex\n    peerQueues      map[NodeID]queue\n\n    channelMtx      sync.RWMutex\n    channelQueues   map[ChannelID]queue\n}\n\n// OpenChannel opens a new channel for the given message type. The caller must\n// close the channel when done, before stopping the Router. messageType is the\n// type of message passed through the channel.\nfunc (r *Router) OpenChannel(id ChannelID, messageType proto.Message) (*Channel, error)\n\n// Start starts the router, connecting to peers and routing messages.\nfunc (r *Router) Start() error\n\n// Stop stops the router, disconnecting from all peers and stopping message routing.\nfunc (r *Router) Stop() error\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Seed Nodes in TOML\nDESCRIPTION: Sets a comma-separated list of seed nodes to connect to when the node needs addresses of potential peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_41\n\nLANGUAGE: toml\nCODE:\n```\nseeds = \"\"\n```\n\n----------------------------------------\n\nTITLE: Testing ABCI Grammar Compliance in Go\nDESCRIPTION: Go test function that verifies if node executions follow the ABCI 2.0 grammar. It creates a grammar checker, fetches ABCI requests from each node, and validates whether they conform to the expected sequence defined in the grammar.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc TestCheckABCIGrammar(t *testing.T) {\n\tchecker := grammar.NewGrammarChecker(grammar.DefaultConfig())\n\ttestNode(t, func(t *testing.T, node e2e.Node) {\n\t\tt.Helper()\n\t\tif !node.Testnet.ABCITestsEnabled {\n\t\t\treturn\n\t\t}\n\t\texecutions, err := fetchABCIRequests(t, node.Name)\n\t\trequire.NoError(t, err)\n\t\tfor i, e := range executions {\n\t\t\tisCleanStart := i == 0\n\t\t\t_, err := checker.Verify(e, isCleanStart)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mempool Cache Size\nDESCRIPTION: Setting for internal cache size for tracking previously seen transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_65\n\nLANGUAGE: toml\nCODE:\n```\ncache_size = 10000\n```\n\n----------------------------------------\n\nTITLE: Outputting Network Information Response in JSON\nDESCRIPTION: Illustrates the typical JSON response for a network information request, detailing the listening state, listeners, and connected peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"listening\": true,\n    \"listeners\": [\n      \"Listener(@)\"\n    ],\n    \"n_peers\": \"1\",\n    \"peers\": [\n      {\n        \"node_id\": \"5576458aef205977e18fd50b274e9b5d9014525a\",\n        \"url\": \"tcp://5576458aef205977e18fd50b274e9b5d9014525a@95.179.155.35:26656\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Cached Transactions and Peer Banning in CometBFT Mempool (Go)\nDESCRIPTION: This snippet shows how to handle transactions already in the cache, including tracking senders and potentially banning peers for invalid cached transactions. It introduces new data structures for managing peer failures and invalid cached transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-101-p2p-bad-peers-checktx.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\ntype PeerFailure struct {\n  lastFailure time.Time\n  numFailures int8\n}\n\ntype LRUTxCache struct {\n// Keeping track of invalid transactions within the cache ;\n  invalidCachedTx map[types.TxKey]bool\n}\n\ntype CListMempool struct {\n // ..existing fields\n  peerFailureMap map[nodeID]*PeerFailure\n\n}\n\nif !mem.cache.Push(tx) { // if the transaction already exists in the cache\n  // Record a new sender for a tx we've already seen.\n  // Note it's possible a tx is still in the cache but no longer in the mempool\n  // (eg. after committing a block, txs are removed from mempool but not cache),\n  // so we only record the sender for txs still in the mempool.\n  if e, ok := mem.txsMap.Load(tx.Key()); ok {\n    memTx := e.(*clist.CElement).Value.(*mempoolTx)\n    memTx.senders.LoadOrStore(txInfo.SenderID, true)\n    // TODO: consider punishing peer for dups,\n    // its non-trivial since invalid txs can become valid,\n    // but they can spam the same tx with little cost to them atm.\n  }\n\n  // If transaction was invalid, we need to remember the peer information\n  if _, ok := mem.cache.invalidCachedTx.Load(tx.Key); ok {\n      mem.banPeer(peerID)\n  }\n  return mempool.ErrTxInCache\n}\n```\n\n----------------------------------------\n\nTITLE: Event Send Loop in Go\nDESCRIPTION: This snippet shows the main send loop in Tendermint's pubsub system. It demonstrates how events are continuously processed and sent to subscribers in a loop.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-005-event-system.rst#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n- `send loop <https://github.com/tendermint/tendermint/blob/main/libs/pubsub/pubsub.go#L381-L402>`_\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for CheckTx in CometBFT\nDESCRIPTION: JSON-RPC request example for the check_tx method that validates a transaction without executing it.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_38\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"check_tx\\\",\\\"params\\\":{\\\"tx\\\":\\\"a/encoded_tx/c\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore TraceTo Function Signature in Go\nDESCRIPTION: Specifies the signature for the `TraceTo` method on the `LightStore`. Given a `lightBlock`, this function finds a trusted `LightBlock` (`root`) in the store with a height less than the input `lightBlock`. It returns this `root` and a new `LightStore` containing all light blocks forming a verification trace from `root` up to and including the input `lightBlock`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) TraceTo(lightBlock LightBlock) (LightBlock, LightStore)\n```\n\n----------------------------------------\n\nTITLE: Querying Block Results in CometBFT (JSONRPC Request)\nDESCRIPTION: This snippet shows how to query block results using a JSONRPC POST request to the CometBFT API. It includes the full JSON payload for the request.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"block_results\\\",\\\"params\\\":{\\\"height\\\":\\\"1\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Grammar Parser Verification Function in Go\nDESCRIPTION: Partial implementation of the verify function that uses the generated lexer and parser to check if an execution string conforms to the ABCI grammar. It creates error messages for invalid tokens found during parsing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (g *Checker) verify(execution string, isCleanStart bool) []*Error {\n\terrors := make([]*Error, 0)\n\tlexer := lexer.New([]rune(execution))\n\tbsrForest, errs := parser.Parse(lexer)\n\tfor _, err := range errs {\n\t\texp := []string{}\n\t\tfor _, ex := range err.Expected {\n\t\t\texp = append(exp, ex)\n\t\t}\n\t\texpectedTokens := strings.Join(exp, \",\")\n\t\tunexpectedToken := err.Token.TypeID()\n\t\te := &Error{\n```\n\n----------------------------------------\n\nTITLE: Adding Events in Go Application's FinalizeBlock Method\nDESCRIPTION: Example Go code showing how to add transaction and block events in an application's FinalizeBlock method, which will be indexed by CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *Application) FinalizeBlock(_ context.Context, req *types.FinalizeBlockRequest) (*types.FinalizeBlockResponse, error) {\n    //...\n    tx_results[0] := &types.ExecTxResult{\n        Code: CodeTypeOK,\n        // With every transaction we can emit a series of events. To make it simple, we just emit the same events.\n        Events: []types.Event{\n            {\n                Type: \"app\",\n                Attributes: []types.EventAttribute{\n                    {Key: \"creator\", Value: \"Cosmoshi Netowoko\", Index: true},\n                    {Key: \"key\", Value: key, Index: true},\n                    {Key: \"index_key\", Value: \"index is working\", Index: true},\n                    {Key: \"noindex_key\", Value: \"index is working\", Index: false},\n                },\n            },\n            {\n                Type: \"app\",\n                Attributes: []types.EventAttribute{\n                    {Key: \"creator\", Value: \"Cosmoshi\", Index: true},\n                    {Key: \"key\", Value: value, Index: true},\n                    {Key: \"index_key\", Value: \"index is working\", Index: true},\n                    {Key: \"noindex_key\", Value: \"index is working\", Index: false},\n                },\n            },\n        },\n    }\n\n    block_events = []types.Event{\n        {\n            Type: \"loan\",\n            Attributes: []types.EventAttribute{\n                {Key: \"account_no\", Value: \"1\", Index: true},\n                {Key: \"amount\", Value: \"200\", Index: true},\n            },\n        },\n        {\n            Type: \"loan\",\n            Attributes: []types.EventAttribute{\n                {Key: \"account_no\", Value: \"2\", Index: true},\n                {Key: \"amount\", Value: \"300\", Index: true},\n            },\n        },\n    }\n    return &types.FinalizeBlockResponse{TxResults: tx_results, Events: block_events, NextBlockDelay: 1 * time.Second}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Light Client in Go\nDESCRIPTION: Implements the `InitLightClient` function in Go, responsible for initializing the light client based on the provided `LCInitData`. It determines the initial trusted block by checking `TrustedBlock`, `TrustedHash`/`TrustedHeight`, or `Genesis` in order. If necessary, it fetches the block from the primary provider and verifies it (either by hash matching or genesis validator signatures). An optional `CrossCheck` against witness providers is performed for consistency before initializing and returning the `LightStore`. The helper function `CrossCheck` verifies a block's hash against multiple witnesses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_002_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc InitLightClient(initData LCInitData) (LightStore, Error) {\n    var initialBlock LightBlock\n\n    switch {\n    case LCInitData.TrustedBlock != nil:\n        // we trust the block from a prior initialization\n        initialBlock = LCInitData.TrustedBlock\n\n    case LCInitData.TrustedHash != nil:\n        untrustedBlock := FetchLightBlock(PeerList.Primary(), LCInitData.TrustedHeight)\n        \n\n        // verify that the hashes match\n        if untrustedBlock.Hash() != LCInitData.TrustedHash {\n            return nil, Error(\"Primary returned block with different hash\")\n        }\n        // after checking the hash we now trust the block\n        initialBlock = untrustedBlock        \n    }\n    case LCInitData.Genesis != nil:\n        untrustedBlock := FetchLightBlock(PeerList.Primary(), LCInitData.Genesis.InitialHeight)\n        \n        // verify that 2/3+ of the validator set signed the untrustedBlock\n        if err := VerifyCommitFull(untrustedBlock.Commit, LCInitData.Genesis.Validators); err != nil {\n            return nil, err\n        }\n\n        // we can now trust the block\n        initialBlock = untrustedBlock\n    default:\n        return nil, Error(\"No initial data was provided\")\n\n    // This is done in the golang version but is optional and not strictly part of the protocol\n    if err := CrossCheck(initialBlock, PeerList.Witnesses()); err != nil {\n        return nil, err\n    }\n\n    // initialize light store\n    lightStore := new LightStore;\n    lightStore.Add(newBlock);\n    return (lightStore, OK);\n}\n\nfunc CrossCheck(lb LightBlock, witnesses []Provider) error {\n    for _, witness := range witnesses {\n        witnessBlock := FetchLightBlock(witness, lb.Height)\n\n        if witnessBlock.Hash() != lb.Hash() {\n            return Error(\"Witness has different block\")\n        }\n    }\n    return OK\n}\n```\n\n----------------------------------------\n\nTITLE: Running CometBFT Node\nDESCRIPTION: Command to start a CometBFT node, optionally specifying an in-process ABCI application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node\n```\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --proxy_app=kvstore\n```\n\n----------------------------------------\n\nTITLE: Defining P2P Message Types for Reverse Sync in Protobuf\nDESCRIPTION: Defines two new Protobuf message types for the reverse sync protocol: LightBlockRequest for requesting light blocks at specific heights and LightBlockResponse for delivering light blocks containing headers, commits and validator sets.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-068-reverse-sync.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage LightBlockRequest {\n  uint64 height = 1;\n}\n\nmessage LightBlockResponse {\n  tendermint.types.LightBlock light_block = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Timeout Vote Delta in CometBFT\nDESCRIPTION: Sets how much the timeout_vote increases with each round of consensus. This parameter controls the linear increase of timeouts when consensus fails to commit a block, with the formula: timeout_vote + r * timeout_vote_delta.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_85\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_vote_delta = \"500ms\"\n```\n\n----------------------------------------\n\nTITLE: Detecting Peer Disconnection in Bluespec\nDESCRIPTION: Handles detection of peer disconnections, updating the network status to exclude or manage peers accordingly. It verifies disconnected peers and updates relevant structures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_13\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nall {\n    require(node.disconnectedPeers().nonEmpty()),\n    nondet peer = oneOf(node.disconnectedPeers()) \n    node.updateDisconnectedPeer(peer),\n    mempool' = mempool,\n    senders' = senders,\n},\n```\n\n----------------------------------------\n\nTITLE: BroadcastTxAsync Response in CometBFT\nDESCRIPTION: Example JSON response from the broadcast_tx_async endpoint showing the transaction hash and initial validation result.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_36\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"code\": \"0\",\n    \"data\": \"\",\n    \"log\": \"\",\n    \"codespace\": \"ibc\",\n    \"hash\": \"0D33F2F03A5234F38706E43004489E061AC40A2E\"\n  },\n  \"error\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Lane ID in CheckTxResponse Protobuf Message\nDESCRIPTION: Extension of the CheckTxResponse protobuf message to include a lane_id field that allows applications to specify which lane a transaction belongs to. If the lane_id is empty, the transaction is assigned to the default lane.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-118-mempool-lanes.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage CheckTxResponse {\n  ...\n  string lane_id = 12;\n}\n```\n\n----------------------------------------\n\nTITLE: Processing New PREVOTE Messages in PBTS\nDESCRIPTION: Handler for processing current round PREVOTE messages, updating locked and valid values based on consensus rules.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts-algorithm_001_draft.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nupon timely(⟨PROPOSAL, h_p, round_p, (v,t), ∗⟩) from proposer(h_p, round_p) AND 2f + 1 ⟨PREVOTE, h_p, round_p, id(v,t)⟩ while valid(v) ∧ step_p ≥ prevote for the first time do {\n  if step_p = prevote {\n    lockedValue_p ← v\n    lockedRound_p ← round_p\n    broadcast ⟨PRECOMMIT, h_p, round_p, id(v,t))⟩ \n    step_p ← precommit\n  }\n  validValue_p ← v \n  validRound_p ← round_p\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore Get Function Signature in Go\nDESCRIPTION: Specifies the signature for the `Get` method on the `LightStore`. This function retrieves a `LightBlock` corresponding to the provided `height`. It returns the `LightBlock` and a boolean value which is `true` if a block at the specified height exists in the store, and `false` otherwise.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Get(height Height) (LightBlock, bool)\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Outbound Peers in CometBFT (TOML)\nDESCRIPTION: Sets the maximum number of outbound peer connections. Outbound connections are initiated by this node. This setting works with max_num_inbound_peers to define the total P2P connections maintained.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_47\n\nLANGUAGE: toml\nCODE:\n```\nmax_num_outbound_peers = 10\n```\n\n----------------------------------------\n\nTITLE: Implementing Connection Interface in Go for CometBFT P2P Communication\nDESCRIPTION: Definition of the Connection interface which represents an established connection between two endpoints. This interface provides methods for handshaking, message exchange, endpoint information, and connection closure.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Connection represents an established connection between two endpoints.\ntype Connection interface {\n    // Handshake executes a node handshake with the remote peer. It must be\n    // called once the connection is established, and returns the remote peer's\n    // node info and public key. The caller is responsible for validation.\n    Handshake(context.Context, NodeInfo, crypto.PrivKey) (NodeInfo, crypto.PubKey, error)\n\n    // ReceiveMessage returns the next message received on the connection,\n    // blocking until one is available. Returns io.EOF if closed.\n    ReceiveMessage() (ChannelID, []byte, error)\n\n    // SendMessage sends a message on the connection. Returns io.EOF if closed.\n    SendMessage(ChannelID, []byte) error\n\n    // LocalEndpoint returns the local endpoint for the connection.\n    LocalEndpoint() Endpoint\n\n    // RemoteEndpoint returns the remote endpoint for the connection.\n    RemoteEndpoint() Endpoint\n\n    // Close closes the connection.\n    Close() error\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Light Block Link with Expected Preconditions and Results - Go\nDESCRIPTION: Defines the Go function signature for ValidAndVerified, outlining preconditions, state transitions, and result semantics for verifying that an untrusted light block is valid with respect to a previously trusted light block. Dependencies include LightBlock types, trust periods, and commit validation logic. Requires soundness checks, validator signatures, and height/time consistency between trusted and untrusted blocks. On success, outputs a Result indicating the linkage validity, or errors if preconditions fail.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\nfunc ValidAndVerified(trusted LightBlock, untrusted LightBlock) Result\n```\n\n----------------------------------------\n\nTITLE: New CListMempool Data Structure Fields for Lanes in Golang\nDESCRIPTION: The proposed modifications to the CListMempool data structure to support multiple lanes, including maps for transactions and their corresponding lanes, and fields to store lane configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-118-mempool-lanes.md#2025-04-22_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\nlanes   map[Lane]*clist.CList\ntxsMap  sync.Map // Map of type TxKey -> *clist.CElement, for quick access to elements in lanes.\ntxLanes sync.Map // Map of type TxKey -> Lane, for quick access to the lane corresponding to a tx.\n\n// Fixed variables set during initialization.\ndefaultLane Lane\nsortedLanes []Lane // Lanes sorted by priority\n```\n\n----------------------------------------\n\nTITLE: Checking BlockID Nil and Completeness in Go\nDESCRIPTION: Defines methods IsNil and IsComplete for BlockID to determine if it represents a nil block or a complete one, respectively. These methods are key for deciding the validity of proposals or votes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nb.Hash == nil\nb.PartsHeader.Total == 0\nb.PartsHeader.Hash == nil\n```\n\nLANGUAGE: Go\nCODE:\n```\nlen(b.Hash) == 32\nb.PartsHeader.Total > 0\nlen(b.PartsHeader.Hash) == 32\n```\n\n----------------------------------------\n\nTITLE: Implementing Blockchain Reactor Lifecycle Management in Go\nDESCRIPTION: Defines the Start method for the BlockChainReactor which initializes message channels and launches goroutines for processing, scheduling, and IO operations. This design facilitates parallel processing with clear lifecycle management.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *BlockChainReactor) Start() {\n\tr.msgs := make(chan Message, maxInFlight)\n\tschedulerMsgs := make(chan Message)\n\tprocessorMsgs := make(chan Message)\n\tioMsgs := make(chan Message)\n\n\tgo processorRoutine(processorMsgs, r.msgs)\n\tgo scheduleRoutine(schedulerMsgs, r.msgs)\n\tgo ioRoutine(ioMsgs, r.msgs)\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Address Book Strictness in TOML\nDESCRIPTION: Enables strict address routability rules, disallowing non-routable IP addresses in the address book. Set to false for testing on private networks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_45\n\nLANGUAGE: toml\nCODE:\n```\naddr_book_strict = true\n```\n\n----------------------------------------\n\nTITLE: Defining EventAttribute Structure in Protobuf\nDESCRIPTION: Protobuf schema for EventAttribute that consists of a key, value, and an index flag. The index flag is used to indicate whether the attribute should be indexed by the CometBFT indexer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_basic_concepts.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage EventAttribute {\n  string key   = 1;\n  string value = 2;\n  bool   index = 3;  // nondeterministic\n}\n```\n\n----------------------------------------\n\nTITLE: New CometBFT Validator Private Key File\nDESCRIPTION: Example of a newly generated priv_validator_key.json file for a CometBFT validator.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"address\" : \"5AF49D2A2D4F5AD4C7C8C4CC2FB020131E9C4902\",\n  \"pub_key\" : {\n    \"value\" : \"l9X9+fjkeBzDfPGbUM7AMIRE6uJN78zN5+lk5OYotek=\",\n    \"type\" : \"tendermint/PubKeyEd25519\"\n  },\n  \"priv_key\" : {\n    \"value\" : \"EDJY9W6zlAw+su6ITgTKg2nTZcHAH1NMTW5iwlgmNDuX1f35+OR4HMN88ZtQzsAwhETq4k3vzM3n6WTk5ii16Q==\",\n    \"type\" : \"tendermint/PrivKeyEd25519\"\n  },\n  \"last_step\" : 0,\n  \"last_round\" : \"0\",\n  \"last_height\" : \"0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Main Function to Create KVStore Application\nDESCRIPTION: Modified main function to create an instance of the KVStoreApplication.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    fmt.Println(\"Hello, CometBFT\")\n\n    _ = NewKVStoreApplication()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block Response Event Structure in Go\nDESCRIPTION: Structure for block response events that are generated when a block response message is received, containing the block, commit, peer ID, and peer height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\ntype EventBlockResponse struct {\n  Height             int64\n  Block              Block\n  Commit             Commit\n  PeerID             ID\n  PeerHeight         int64\n}\n```\n\n----------------------------------------\n\nTITLE: BroadcastEvidence Response in CometBFT\nDESCRIPTION: Example JSON response from the broadcast_evidence endpoint after submitting evidence of validator misbehavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_48\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"error\": \"\",\n  \"result\": \"\",\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Decision Making Process in PBTS\nDESCRIPTION: Final decision rule that processes PRECOMMIT messages and finalizes consensus on both value and time.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts-algorithm_001_draft.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nupon ⟨PROPOSAL, h_p, r, (v,t), ∗⟩ from proposer(h_p, r) AND 2f + 1 ⟨PRECOMMIT, h_p, r, id(v,t)⟩ while decisionp[h_p] = nil do {\n  if valid(v) {\n    decision_p [h_p] = (v,t) // decide on time too\n    h_p ← h_p + 1\n    reset lockedRound_p , lockedValue_p, validRound_p and validValue_p to initial values and empty message log \n    StartRound(0)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BlockService gRPC API for CometBFT in Protocol Buffers\nDESCRIPTION: This Protocol Buffers definition specifies the BlockService gRPC interface that allows clients to retrieve block information from CometBFT. It includes methods for getting the latest block height via streaming and retrieving complete blocks by their height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\npackage tendermint.services.block.v1;\n\nimport \"tendermint/abci/types.proto\";\nimport \"tendermint/types/types.proto\";\nimport \"tendermint/types/block.proto\";\n\n// BlockService provides information about blocks.\nservice BlockService {\n    // GetLatestHeight returns a stream of the latest block heights committed by\n    // the network. This is a long-lived stream that is only terminated by the\n    // server if an error occurs. The caller is expected to handle such\n    // disconnections and automatically reconnect.\n    rpc GetLatestHeight(GetLatestHeightRequest) returns (stream GetLatestHeightResponse) {}\n\n    // GetByHeight attempts to retrieve the block at a particular height.\n    rpc GetByHeight(GetByHeightRequest) returns (GetByHeightResponse) {}\n}\n\nmessage GetLatestHeightRequest {}\n\n// GetLatestHeightResponse provides the height of the latest committed block.\nmessage GetLatestHeightResponse {\n    // The height of the latest committed block. Will be 0 if no data has been\n    // committed yet.\n    uint64 height = 1;\n}\n\nmessage GetByHeightRequest {\n    // The height of the block to get. Set to 0 to return the latest block.\n    uint64 height = 1;\n}\n\nmessage GetByHeightResponse {\n    // The ID associated with the relevant block.\n    tendermint.types.BlockID block_id = 1;\n    // Block data for the requested height.\n    tendermint.types.Block block = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Start Peer Sequence (ABNF)\nDESCRIPTION: This ABNF grammar details the process after `InitPeer` is called. The p2p layer attempts to start the peer's communication routines. If successful, `AddPeer(Peer)` is called (`connected-peer`), potentially preceded or followed by message reception (`Receive`). If starting fails (e.g., due to a misbehaving peer), an error is logged (`start-error`), and `AddPeer` is not called for that instance.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_4\n\nLANGUAGE: abnf\nCODE:\n```\nstart-peer      = [*receive] (connected-peer / start-error)\nconnected-peer  = add-peer *receive\n```\n\n----------------------------------------\n\nTITLE: Defining Snapshot Data Structure in Protobuf\nDESCRIPTION: Defines the Snapshot message structure used to represent application state snapshots. Each snapshot includes height, format version, number of chunks, a hash for verification, and application-specific metadata.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-053-state-sync-prototype.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Snapshot {\n  uint64 height   = 1;  // The height at which the snapshot was taken\n  uint32 format   = 2;  // The application-specific snapshot format\n  uint32 chunks   = 3;  // Number of chunks in the snapshot\n  bytes  hash     = 4;  // Arbitrary snapshot hash - should be equal only for identical snapshots\n  bytes  metadata = 5;  // Arbitrary application metadata\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Public and Private Key Protocol Buffer Messages for CometBFT\nDESCRIPTION: Protocol Buffer message definitions for cryptographic keys in CometBFT. The messages use oneof fields to support different key types, currently only including ed25519. These definitions replace the previous Amino encoding format used for keys.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-054-crypto-encoding-2.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage PubKey {\n  oneof key {\n    bytes ed25519 = 1;\n  }\n\nmessage PrivKey {\n  oneof sum {\n    bytes ed25519 = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Propose Timeout Delta for Consensus in CometBFT (TOML)\nDESCRIPTION: Specifies how much the propose timeout increases with each round. Timeouts increase linearly over rounds to adapt to network conditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_83\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_propose_delta = \"500ms\"\n```\n\n----------------------------------------\n\nTITLE: Defining Peer Connection States in ABNF\nDESCRIPTION: This ABNF snippet defines the possible states and transitions for peer connections in CometBFT. It shows that a peer can receive messages before being fully connected, and that a connected peer can receive multiple messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_6\n\nLANGUAGE: abnf\nCODE:\n```\nstart-peer      = [*receive] (connected-peer / start-error)\nconnected-peer  = add-peer *receive\n```\n\n----------------------------------------\n\nTITLE: Example Transaction Result Response in CometBFT JSON-RPC\nDESCRIPTION: Example JSON response showing a transaction result from CometBFT, including transaction hash, height, index, and execution results with gas usage and tags.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_30\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"hash\": \"D70952032620CC4E2737EB8AC379806359D8E0B17B0488F627997A0B043ABDED\",\n    \"height\": \"1000\",\n    \"index\": 0,\n    \"tx_result\": {\n      \"log\": \"[{\\\"msg_index\\\":\\\"0\\\",\\\"success\\\":true,\\\"log\\\":\\\"\\\"}]\",\n      \"gas_wanted\": \"200000\",\n      \"gas_used\": \"28596\",\n      \"tags\": [\n        {\n          \"key\": \"YWN0aW9u\",\n          \"value\": \"c2VuZA==\",\n          \"index\": false\n        }\n      ]\n    },\n    \"tx\": \"5wHwYl3uCkaoo2GaChQmSIu8hxpJxLcCuIi8fiHN4TMwrRIU/Af1cEG7Rcs/6LjTl7YjRSymJfYaFAoFdWF0b20SCzE0OTk5OTk1MDAwEhMKDQoFdWF0b20SBDUwMDAQwJoMGmoKJuta6YchAwswBShaB1wkZBctLIhYqBC3JrAI28XGzxP+rVEticGEEkAc+khTkKL9CDE47aDvjEHvUNt+izJfT4KVF2v2JkC+bmlH9K08q3PqHeMI9Z5up+XMusnTqlP985KF+SI5J3ZOIhhNYWRlIGJ5IENpcmNsZSB3aXRoIGxvdmU=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Signable Interface Implementation in CometBFT\nDESCRIPTION: The modified Signable interface that no longer requires a ChainID parameter since it's now included directly in the message types. The implementation shows how messages are binary marshaled for signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_5\n\nLANGUAGE: golang\nCODE:\n```\ntype Signable interface {\n\tSignBytes() []byte\n}\n\n```\n\nLANGUAGE: golang\nCODE:\n```\n// type T is one of vote, sign, proposal\nfunc (tp *T) SignBytes() []byte {\n\tbz, err := cdc.MarshalBinary(tp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bz\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Timeout for broadcast_tx_commit in CometBFT RPC (TOML)\nDESCRIPTION: Specifies the maximum time the server waits for a transaction to be committed when a client uses the `/broadcast_tx_commit` RPC endpoint. The value must be a duration string (e.g., \"10s\"). Setting it higher than \"10s\" increases the global HTTP write timeout. Using `/broadcast_tx_sync` is generally recommended over this endpoint in production.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_26\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_broadcast_tx_commit = \"10s\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Commit from Full Node in Go\nDESCRIPTION: RPC function to fetch a signed header of a specific height from a full node. It returns a SignedHeader or an error.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc Commit(height int64) (SignedHeader, error)\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Pruning Service in TOML\nDESCRIPTION: Enables the gRPC pruning service, which is considered a privileged service. This only controls API accessibility, not whether pruning is performed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_38\n\nLANGUAGE: toml\nCODE:\n```\nenabled = false\n```\n\n----------------------------------------\n\nTITLE: Defining Network Join Action in Bluespec\nDESCRIPTION: Defines the `joinNetwork` action, which allows a node currently outside the network to join. The action requires the node to have no current peers. It updates the `peers` state by assigning the specified `peerSet` to the joining `node` and adding the `node` to the peer sets of the nodes in `peerSet`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_12\n\nLANGUAGE: bluespec\nCODE:\n```\naction joinNetwork(node, peerSet) = all {\n    // The node must not be connected to the network.\n    require(node.Peers().isEmpty()),\n    peers' = peers\n        // Assign to node the set of new peers.\n        .put(node, peerSet)\n        // Add node as a new peer to the set of connecting peers.\n        .updateMultiple(peerSet, ps => ps.join(node)),\n    incomingMsgs' = incomingMsgs,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Light Client Initialization Data Structure in Go\nDESCRIPTION: Defines the `LCInitData` struct in Go. This structure holds the necessary data for initializing a light client. It requires one of three potential trust sources: a previously trusted `LightBlock`, a `GenesisDoc`, or a combination of `TrustedHash` and `TrustedHeight`. Only one of these components should be provided for a valid initialization.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_002_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype LCInitData struct {\n    TrustedBlock   LightBlock\n    Genesis        GenesisDoc\n    TrustedHash    []byte\n    TrustedHeight  int64\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Senders Method to Entry Interface in Go\nDESCRIPTION: Extends the Entry interface in the mempool package to include a Senders method that returns the list of peers that have sent a particular transaction. This enables tracking the sources of each transaction.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n// Senders returns the list of registered peers that sent us the transaction.\nSenders() []p2p.ID\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Tendermint Loggers in Go\nDESCRIPTION: Example code demonstrating how to instantiate, configure and use the new logger system in a Tendermint application, including setting log levels and adding context fields.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-001-logging.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nlogger := log.NewTmLogger(os.Stdout)\nlogger.SetLevel(config.GetString(\"log_level\"))\nnode.SetLogger(log.With(logger, \"node\", Name))\n```\n\n----------------------------------------\n\nTITLE: Defining Status Report Event Structure in Go\nDESCRIPTION: Structure for status report events that are generated when a status response message is received, containing the peer ID and its reported height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\ntype EventStatusReport struct {\n  PeerID ID\n  Height int64\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Registered Types in JSON - CometBFT - JSON\nDESCRIPTION: This code snippet demonstrates the custom JSON encoding format for registered type objects within CometBFT. Each object includes a \"type\" field specifying the type name and a \"value\" field holding type-specific data (here, as base64-encoded bytes for a public key). Dependencies include having type registration infrastructure in CometBFT and understanding base64 serialization for cryptographic material. The expected input is the object to be encoded and the output is a JSON object matching this template; consumers must interpret and handle the typed value accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"<type name>\",\n  \"value\": <JSON>\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"tendermint/PubKeyEd25519\",\n  \"value\": \"uZ4h63OFWuQ36ZZ4Bd6NF+/w9fWUwrOncrQsackrsTk=\"\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Secondary Node - Cosmos Light Client Supervisor - Go\nDESCRIPTION: Defines the Replace_Secondary function, which removes a specified secondary node (by address) judged faulty and promotes a new node from FullNodes, while also maintaining root-of-trust invariant via block verification. The function expects FullNodes to be nonempty and requires that a replacement candidate is consistent with the root-of-trust LightBlock. If replacement is not possible due to precondition failures, error handling is required.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nReplace_Secondary(addr Address, root-of-trust LightBlock)\n```\n\n----------------------------------------\n\nTITLE: Setting Mempool Recheck Timeout\nDESCRIPTION: Configuration for the timeout duration when waiting for CheckTx responses during recheck.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_59\n\nLANGUAGE: toml\nCODE:\n```\nrecheck_timeout = \"1000ms\"\n```\n\n----------------------------------------\n\nTITLE: Defining the ExtendedCommit Structure in CometBFT\nDESCRIPTION: Defines the `ExtendedCommit` structure in CometBFT, an enhanced version of `Commit`. It includes the height, round, BlockID, and an array of `ExtendedCommitSig` objects, which contain not only the commit signatures but also vote extensions and their corresponding signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n| Name               | Type                                     | Description                                                                         | Validation                                                                                                               |\n|--------------------|------------------------------------------|-------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| Height             | int64                                    | Height at which this commit was created.                                            | Must be >= 0                                                                                                             |\n| Round              | int32                                    | Round that the commit corresponds to.                                               | Must be >= 0                                                                                                             |\n| BlockID            | [BlockID](#blockid)                      | The blockID of the corresponding block.                                             | Must adhere to the validation rules of [BlockID](#blockid).                                                              |\n| ExtendedSignatures | Array of [ExtendedCommitSig](#commitsig) | The current validator set's commit signatures, extension, and extension signatures. | Length of signatures must be > 0 and adhere to the validation of each individual [ExtendedCommitSig](#extendedcommitsig) |\n```\n\n----------------------------------------\n\nTITLE: Implementing LunaticEvidence Struct in Go\nDESCRIPTION: This code defines a potential LunaticEvidence struct for individual lunatic attacks in the light client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype LunaticEvidence struct { // individual lunatic attack\n  header *Header\n  commonHeight int64\n  vote *Vote\n\n  timestamp time.Time // once again taken from the block time at the height of the common header\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block Information Structure in Go\nDESCRIPTION: Structure used to store information about downloaded blocks, including the block itself, its commit certificate, and the ID of the peer from which it was received.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_17\n\nLANGUAGE: go\nCODE:\n```\ntype BlockInfo struct {\n  Block  Block\n  Commit Commit\n  PeerID ID                // a peer from which we received the corresponding Block and Commit\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Genesis Data in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving the complete genesis document. For large genesis documents, the genesis_chunked endpoint should be used instead to avoid errors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_19\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/genesis\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"genesis\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Validator Information Response Format in CometBFT API\nDESCRIPTION: Example response structure for the validators endpoint showing block height, validator details including address, public key, voting power, and proposer priority. Also includes pagination information with count and total validators.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"block_height\": \"55\",\n    \"validators\": [\n      {\n        \"address\": \"000001E443FD237E4B616E2FA69DF4EE3D49A94F\",\n        \"pub_key\": {\n          \"type\": \"tendermint/PubKeyEd25519\",\n          \"value\": \"9tK9IT+FPdf2qm+5c2qaxi10sWP+3erWTKgftn2PaQM=\"\n        },\n        \"voting_power\": \"239727\",\n        \"proposer_priority\": \"-11896414\"\n      }\n    ],\n    \"count\": \"1\",\n    \"total\": \"25\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting an Observer on Consensus State in Go\nDESCRIPTION: A method that allows setting an observer on the consensus.State struct. This provides a way to inject different observers for different purposes, such as testing or production use.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\npackage consensus\n\nfunc (cs *State) SetObserver(obs StateObserver) {\n    cs.observer = obs\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Chunked Genesis Data in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving the genesis document in chunks. This endpoint is designed for transferring large genesis documents by breaking them into manageable pieces.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_21\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/genesis_chunked?chunk=0\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"genesis_chunked\\\",\\\"params\\\":{\\\"chunk\\\":0}}\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Registered Reactors - CometBFT Switch API - Go\nDESCRIPTION: Reactor(name string) provides runtime access from one reactor to another by name, returning a Reactor instance. Mostly used for inter-reactor coordination (such as block sync coordinating with consensus), it takes a string argument and returns a Reactor interface. Overuse is discouraged to maintain reactor independence; careful name management is required to avoid misrouting.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) Reactor(name string) Reactor\n```\n\n----------------------------------------\n\nTITLE: Executing Proper Debug-Level Logging in Go\nDESCRIPTION: Example of a proper debug-level log message for module initialization, targeting consensus engine developers. The message starts with a capital letter and includes minimal necessary context.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nlogger.Debug(\"Starting reactor\", \"module\", \"consensus\")\n```\n\n----------------------------------------\n\nTITLE: Adding Priority and Sender Fields to ResponseCheckTx in ABCI Protocol\nDESCRIPTION: A protocol buffer diff that adds two new fields to the ResponseCheckTx message: priority (int64) for transaction prioritization and sender (string) to identify the transaction sender. These fields allow applications to communicate transaction priority information to the Tendermint mempool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-067-mempool-refactor.md#2025-04-22_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nmessage ResponseCheckTx {\n  uint32         code       = 1;\n  bytes          data       = 2;\n  string         log        = 3;  // nondeterministic\n  string         info       = 4;  // nondeterministic\n  int64          gas_wanted = 5 [json_name = \"gas_wanted\"];\n  int64          gas_used   = 6 [json_name = \"gas_used\"];\n  repeated Event events     = 7 [(gogoproto.nullable) = false, (gogoproto.jsontag) = \"events,omitempty\"];\n  string         codespace  = 8;\n+ int64          priority   = 9;\n+ string         sender     = 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Searching for Transactions\nDESCRIPTION: This curl command searches for transactions using the tx_search endpoint with a specific query.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"localhost:26657/tx_search?query=\\\"app.key='cometbft'\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining MisbehaviorType Enum in Protobuf\nDESCRIPTION: Protobuf definition for the MisbehaviorType enum used to classify types of validator misbehavior. Includes three types: unknown, duplicate vote, and light client attack, which are used in the evidence system.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_basic_concepts.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\n// The type of misbehavior committed by a validator.\nenum MisbehaviorType {\n  // Unknown\n  MISBEHAVIOR_TYPE_UNKNOWN = 0;\n  // Duplicate vote\n  MISBEHAVIOR_TYPE_DUPLICATE_VOTE = 1;\n  // Light client attack\n  MISBEHAVIOR_TYPE_LIGHT_CLIENT_ATTACK = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Schedule Function Implementation in Go\nDESCRIPTION: Function to determine the next height to be verified in the light client protocol. Takes lightStore, nextHeight, and targetHeight as parameters and returns a Height value based on verification conditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc Schedule(lightStore, nextHeight, targetHeight) Height\n```\n\n----------------------------------------\n\nTITLE: Handling PROPOSE Message Reception in PBTS\nDESCRIPTION: Rule for processing timely PROPOSE messages, implementing validation and broadcasting PREVOTE messages based on proposal contents.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts-algorithm_001_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nupon timely(⟨PROPOSAL, h_p, round_p, (v,t), −1⟩) from proposer(h_p, round_p) while step_p = propose do {\n  if valid(v) ∧ (lockedRound_p = −1 ∨ lockedValue_p = v) {\n    broadcast ⟨PREVOTE, h_p, round_p, id(v,t)⟩ \n  }\n  else {\n    broadcast ⟨PREVOTE, h_p, round_p, nil⟩ \n  }\n  step_p ← prevote\n}\n```\n\n----------------------------------------\n\nTITLE: Explaining AddChannel Method for Channel Registration in CometBFT Transport\nDESCRIPTION: The AddChannel method registers a channel in the transport by adding its ID to the supported channel IDs list in the NodeInfo record. This method is called before the node starts, typically in the CustomReactors constructor.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/implementation/transport.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## Supported channels\n\nThe `AddChannel` method registers a channel in the transport.\n\nThe channel ID is added to the list of supported channel IDs,\nstored in the local `NodeInfo` record.\n\nThe `NodeInfo` record is exchanged with peers in the version handshake.\nFor this reason, this method is not invoked with a started transport.\n\n> The only call to this method is performed in the `CustomReactors` constructor\n> option of a node, i.e., before the node is started.\n> Note that the default list of supported channel IDs, including the default reactors,\n> is provided to the transport as its original `NodeInfo` record.\n```\n\n----------------------------------------\n\nTITLE: Defining the BlockID Structure in CometBFT\nDESCRIPTION: Defines the `BlockID` structure in CometBFT. It contains two distinct Merkle roots: the header hash (`Hash`) and the hash of the block parts (`PartSetHeader`), along with the total number of parts implicitly via the PartSetHeader. Both hash components have specific validation requirements.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Name          | Type                            | Description                                                                                                                                                      | Validation                                                             |\n|---------------|---------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------|\n| Hash          | slice of bytes (`[]byte`)       | MerkleRoot of all the fields in the header (ie. `MerkleRoot(header)`.                                                                                            | hash must be of length 32                                              |\n| PartSetHeader | [PartSetHeader](#partsetheader) | Used for secure gossiping of the block during consensus, is the MerkleRoot of the complete serialized block cut into parts (ie. `MerkleRoot(MakeParts(block))`). | Must adhere to the validation rules of [PartSetHeader](#partsetheader) |\n```\n\n----------------------------------------\n\nTITLE: Defining Pure Function for Node Disconnection in Bluespec\nDESCRIPTION: Defines a pure function `disconnect` that models a node leaving the network. It takes the current peer map `_peers` and a `node` ID, and returns an updated map where the specified node's peer set is empty. A TODO comment highlights the need to check for network partitioning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_8\n\nLANGUAGE: bluespec\nCODE:\n```\npure def disconnect(_peers, node) =\n    // TODO: check that the network does not become disconnected; we don't want to model that.\n    _peers.put(node, Set())\n```\n\n----------------------------------------\n\nTITLE: Configuring Privileged gRPC Endpoints in TOML\nDESCRIPTION: Sets the address for privileged gRPC endpoints which should never be exposed to the public internet. If not specified, privileged endpoints will be disabled.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_37\n\nLANGUAGE: toml\nCODE:\n```\nladdr = \"\"\n```\n\n----------------------------------------\n\nTITLE: InitChain Response Structure\nDESCRIPTION: Defines the response structure for the InitChain method including validator and consensus parameters\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\n| Name             | Type                                         | Description                                      | Field Number | Deterministic |\n|------------------|----------------------------------------------|--------------------------------------------------|--------------|---------------|\n| consensus_params | [ConsensusParams](#consensusparams)          | Initial consensus-critical parameters (optional) | 1            | Yes           |\n| validators       | repeated [ValidatorUpdate](#validatorupdate) | Initial validator set (optional).                | 2            | Yes           |\n| app_hash         | bytes                                        | Initial application hash.                        | 3            | Yes           |\n```\n\n----------------------------------------\n\nTITLE: Implementing TrustMetricStore for Managing Multiple Metrics in Go\nDESCRIPTION: Definition of the TrustMetricStore which manages multiple trust metrics with persistent storage. Provides methods for accessing individual peer metrics and handling peer disconnection events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\n// TrustMetricStore - Manages all trust metrics for peers\ntype TrustMetricStore struct {\n    cmn.BaseService\n\n    // Private elements\n}\n\n// OnStart implements Service\nfunc (tms *TrustMetricStore) OnStart(context.Context) error { return nil }\n\n// OnStop implements Service\nfunc (tms *TrustMetricStore) OnStop() {}\n\n// NewTrustMetricStore returns a store that saves data to the DB\n// and uses the config when creating new trust metrics\nfunc NewTrustMetricStore(db dbm.DB, tmc TrustMetricConfig) *TrustMetricStore {}\n\n// Size returns the number of entries in the trust metric store\nfunc (tms *TrustMetricStore) Size() int {}\n\n// GetPeerTrustMetric returns a trust metric by peer key\nfunc (tms *TrustMetricStore) GetPeerTrustMetric(key string) *TrustMetric {}\n\n// PeerDisconnected pauses the trust metric associated with the peer identified by the key\nfunc (tms *TrustMetricStore) PeerDisconnected(key string) {}\n\n// ------------------------------------------------------------------------------------------------\n// For example\n\ndb := dbm.NewDB(\"trusthistory\", \"goleveldb\", dirPathStr)\ntms := NewTrustMetricStore(db, DefaultConfig())\n\ntm := tms.GetPeerTrustMetric(key)\ntm.BadEvents(1)\n\ntms.PeerDisconnected(key)\n```\n\n----------------------------------------\n\nTITLE: Extending Votes with Curse Words in CometBFT Forum App (Go)\nDESCRIPTION: Implements the ExtendVote method to add curse words as vote extensions. It returns the application's curse words as the vote extension.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nfunc (app *ForumApp) ExtendVote(_ context.Context, _ *abci.ExtendVoteRequest) (*abci.ExtendVoteResponse, error) {\n\tapp.logger.Info(\"Executing Application ExtendVote\")\n\n\treturn &abci.ExtendVoteResponse{VoteExtension: []byte(app.CurseWords)}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LightClientAttackEvidence Struct with ABCI Fields in Go\nDESCRIPTION: This code defines the LightClientAttackEvidence struct with additional ABCI-specific fields for more detailed information about the attack.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n  ConflictingBlock *LightBlock\n  CommonHeight int64 // the last height at which the primary provider and witness provider had the same header\n\n  // abci specific information\n\tByzantineValidators []*Validator // validators in the validator set that misbehaved in creating the conflicting block\n\tTotalVotingPower    int64        // total voting power of the validator set at the common height\n\tTimestamp           time.Time    // timestamp of the block at the common height\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Duplicate IP Connections in CometBFT (TOML)\nDESCRIPTION: Enables or disables the guard against peers connecting from the same IP. When set to true, multiple connections from the same IP address are allowed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_56\n\nLANGUAGE: toml\nCODE:\n```\nallow_duplicate_ip = false\n```\n\n----------------------------------------\n\nTITLE: Defining Response Timeout Event Structure in Go\nDESCRIPTION: Structure for response timeout events that are generated when a response timeout expires, containing the peer ID and the height for which the timeout occurred.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\ntype EventTimeoutResponse struct {\n  PeerID ID\n  Height int64\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Canonical Proposal Structure in Go\nDESCRIPTION: Defines the CanonicalProposal struct for signing, detailing the required fields and types. Used to ensure that proposals meet certain conditions before signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ntype CanonicalProposal struct {\n Type      SignedMsgType // type alias for byte\n Height    int64         `binary:\"fixed64\"`\n Round     int64         `binary:\"fixed64\"`\n POLRound  int64         `binary:\"fixed64\"`\n BlockID   BlockID\n Timestamp time.Time\n ChainID   string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RequestInfo message in Protocol Buffers\nDESCRIPTION: This Protocol Buffers message definition for RequestInfo includes fields for version, block_version, and p2p_version to support protocol versioning in ABCI communication.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-016-protocol-versions.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestInfo {\n  string version\n  uint64 block_version\n  uint64 p2p_version\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Process Routine for Blockchain Message Handling in Go\nDESCRIPTION: Defines a processRoutine function that handles blockchain-related messages by delegating to a processor component. It processes block request messages and other message types, sending resulting actions to the output channel.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc processRoutine(input chan Message, output chan Message) {\n\tprocessor := NewProcessor(..)\n\tfor {\n\t\tmsg := <- input\n\t\tswitch msg := msg.(type) {\n\t\t\tcase bcBlockRequestMessage:\n\t\t\t\toutput <- processor.handleBlockRequest(msg))\n\t\t\t...\n\t\t\tcase stop:\n\t\t\t\tprocessor.stop()\n\t\t\t\tbreak;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Proposal Message Structure Definition in CometBFT\nDESCRIPTION: Binary encoded Proposal message format with corresponding SignProposalRequest and SignProposalReply messages. This defines the message flow for consensus proposals with proper error handling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_3\n\nLANGUAGE: proto\nCODE:\n```\n// vanilla protobuf / amino encoded\nmessage Proposal {                      \n    Height            sfixed64       \n    Round             sfixed32\n    Timestamp         Timestamp         // << using protobuf definition\n    BlockPartsHeader  PartSetHeader     // as already defined\n    POLRound          sfixed32\n    POLBlockID        BlockID           // << as already defined    \n}\n \n// amino registered with \"tendermint/socketpv/SignProposalRequest\"\nmessage SignProposalRequest {\n   Proposal proposal\n}\n\n// amino registered with \"tendermint/socketpv/SignProposalReply\"\nmessage SignProposalReply { \n   Prop   Proposal\n   Sig    Signature \n   Err    Error     // as defined above\n}\n```\n\n----------------------------------------\n\nTITLE: Replaying WAL Messages in CometBFT Shell\nDESCRIPTION: This snippet shows the log output when CometBFT replays messages from the Write-Ahead Log (WAL).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:30.390] Catchup by replaying consensus messages      module=consensus height=91\nI[10-04|13:54:30.390] Replay: New Step                             module=consensus height=91 round=0 step=RoundStepNewHeight\nI[10-04|13:54:30.390] Replay: Done                                 module=consensus\n```\n\n----------------------------------------\n\nTITLE: Channel Handling in Publisher in Go\nDESCRIPTION: Illustrates how the publisher treats buffered and unbuffered channels differently. It blocks on unbuffered channels and uses non-blocking sends on buffered channels, terminating slow subscriptions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfor each subscription {\n    out := subscription.outChan\n    if cap(out) == 0 {\n        // block on unbuffered channel\n        out <- msg\n    } else {\n        // don't block on buffered channels\n        select {\n            case out <- msg:\n            default:\n                // set the error, notify on the cancel chan\n                subscription.err = fmt.Errorf(\"client is too slow for msg)\n                close(subscription.cancelChan)\n\n                // ... unsubscribe and close out\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Evidence Structure in Go\nDESCRIPTION: Wrapper structure for light client attack evidence that includes the peer ID associated with the evidence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\ntype InternalEvidence struct {\n    Evidence           LightClientAttackEvidence\n    Peer               PeerID\n}\n```\n\n----------------------------------------\n\nTITLE: Function InitLightClient in Go\nDESCRIPTION: The InitLightClient function initializes the light client using provided LCInitData. It sets up new blocks and manages verification via peer interactions until a trusted state is achieved or an error occurs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc InitLightClient (initData LCInitData) (LightStore, Error) {\n\n    if LCInitData.LightBlock != nil {\n        // we trust the provided initial block.\n        newblock := LCInitData.LightBlock\n    }\n    else {\n        genesisBlock := makeblock(initData.genesisDoc);\n\n        result := NoResult;\n        while result != ResultSuccess {\n            current = FetchLightBlock(PeerList.primary(), genesisBlock.Header.Height + 1)\n            // QUESTION: is the height with \"+1\" OK?\n\n            if CANNOT_VERIFY = ValidAndVerify(genesisBlock, current) {\n                Replace_Primary();\n            }\n            else {\n                result = ResultSuccess\n            }\n        }\n  \n        // cross-check\n  auxLS := new LightStore\n  auxLS.Add(current)\n        Evidences := AttackDetector(genesisBlock, auxLS)\n        if Evidences.Empty {\n            newBlock := current\n        }\n        else {\n            // [LC-SUMBIT-EVIDENCE.1]\n            submitEvidence(Evidences);\n            return(nil, ErrorAttack);\n        }\n    }\n\n    lightStore := new LightStore;\n    lightStore.Add(newBlock);\n    return (lightStore, OK);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DOG Protocol Adjustment Interval in CometBFT Mempool (TOML)\nDESCRIPTION: Sets the interval for adjusting redundancy level in the DOG protocol. Higher values result in slower convergence to stable redundancy levels. May need adjustment in high-latency networks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_71\n\nLANGUAGE: toml\nCODE:\n```\ndog_adjust_interval = 1000\n```\n\n----------------------------------------\n\nTITLE: gRPC API Definition for DataCompanionService\nDESCRIPTION: Protobuf definition for a gRPC service that allows CometBFT to publish block data and execution results to an external companion service. It includes message types for requests, responses, and different error scenarios.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-100-data-companion-push-api.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nimport \"tendermint/abci/types.proto\";\nimport \"tendermint/types/block.proto\";\n\n// DataCompanionService allows CometBFT to publish certain data generated by\n// the consensus engine to a single external consumer with specific reliability\n// guarantees.\n//\n// Note that implementers of this service must take into account the possibility\n// that CometBFT may re-send data that was previously sent. Therefore\n// the service should simply ignore previously seen data instead of responding\n// with errors to ensure correct functioning of the node, as responding with an\n// error is taken as a signal to CometBFT that it must crash and await\n// operator intervention.\nservice DataCompanionService {\n    // BlockCommitted is called after a block has been committed. This method is\n    // also called on CometBFT startup to ensure that the service received the\n    // last committed block, in case there was previously a transport failure.\n    //\n    // If an error is returned, CometBFT will crash.\n    rpc BlockCommitted(BlockCommittedRequest) returns (BlockCommittedResponse) {}\n}\n\n// BlockCommittedRequest contains at least the data for the block that was just\n// committed. If enabled, it also contains the ABCI FinalizeBlock response data\n// related to the block in this request.\nmessage BlockCommittedRequest {\n    // The block data for the block that was just committed.\n    tendermint.types.Block                         block = 1;\n    // The FinalizeBlockResponse related to the block in this request. This\n    // field is optional, depending on the CometBFT node's configuration.\n    optional tendermint.abci.FinalizeBlockResponse finalize_block_response = 2;\n}\n\n// BlockCommittedResponse is either empty upon success, or returns one or more\n// errors. Note that returning any errors here will cause CometBFT to crash.\nmessage BlockCommittedResponse {\n    // If an error occurred during the companion's processing of the request.\n    optional Error error = 1;\n}\n\n// Error can be one of several different types of errors.\nmessage Error {\n    oneof error {\n        UnexpectedBlockError unexpected_block_err = 1;\n        UnexpectedFieldError unexpected_field_err = 2;\n        ExpectedFieldError   expected_field_err   = 3;\n    }\n}\n\n// UnexpectedBlockError is returned by the server when CometBFT sent it a\n// block that is ahead of the block expected by the server.\nmessage UnexpectedBlockError {\n    // The height of the block expected by the server.\n    int64 expected_height = 1;\n}\n\n// UnexpectedFieldError is returned by the server when CometBFT sent it a\n// message containing an unexpected field. For instance, if the companion\n// expects only the `block` field but not `finalize_block_response`, but somehow\n// the companion receives a value for `finalize_block_response`, it should\n// return this error because it indicates that either CometBFT or the data\n// companion are most likely incorrectly configured.\nmessage UnexpectedFieldError {\n    // The name of the field whose value was expected to be empty, but was not.\n    string field_name = 1;\n}\n\n// ExpectedFieldError is returned by the server when CometBFT sent it a\n// message containing an empty field value for a field it was expecting to be\n// populated. If this occurs, it indicates that either CometBFT or the data\n// companion are most likely incorrectly configured.\nmessage ExpectedFieldError {\n    // The name of the field whose value was expected to be populated, but was\n    // empty.\n    string field_name = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Connected Peers - CometBFT Switch API - Go\nDESCRIPTION: This method signature defines Peers(), a function provided by the Switch interface to return the current concurrency-safe set of connected peers (IPeerSet). It is essential for reactors to maintain awareness of the network state. Dependency is the implementation of the Switch and IPeerSet interfaces within the CometBFT codebase. The method takes no parameters and outputs an IPeerSet; concurrency safety and lifetime management of peer handlers must be considered.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) Peers() IPeerSet\n```\n\n----------------------------------------\n\nTITLE: Checking Peer Running Status in Go\nDESCRIPTION: This method returns a boolean indicating whether the peer's send and receive routines are still running.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) IsRunning() bool\n```\n\n----------------------------------------\n\nTITLE: ValidatorSetUpdates Event Response\nDESCRIPTION: Example JSON response for a ValidatorSetUpdates event showing validator changes including address, public key, voting power, and proposer priority.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/subscription.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"query\": \"tm.event='ValidatorSetUpdates'\",\n        \"data\": {\n            \"type\": \"tendermint/event/ValidatorSetUpdates\",\n            \"value\": {\n              \"validator_updates\": [\n                {\n                  \"address\": \"09EAD022FD25DE3A02E64B0FE9610B1417183EE4\",\n                  \"pub_key\": {\n                    \"type\": \"tendermint/PubKeyEd25519\",\n                    \"value\": \"ww0z4WaZ0Xg+YI10w43wTWbBmM3dpVza4mmSQYsd0ck=\"\n                  },\n                  \"voting_power\": \"10\",\n                  \"proposer_priority\": \"0\"\n                }\n              ]\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Transactions via WebSocket\nDESCRIPTION: JSON request payload for subscribing to transactions with specific tags via WebSocket using the /subscribe RPC endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subscribe\",\n  \"id\": \"0\",\n  \"params\": {\n    \"query\": \"message.sender='cosmos1...'\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LightStore Data Structure in Go\nDESCRIPTION: Definition of the LightStore structure that stores LightBlocks received from peers or initialization. This is the main storage component for the light client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype LightStore struct {\n ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Incoming Message Queues State Variable in Bluespec\nDESCRIPTION: Declares the state variable `incomingMsgs`, which maps each `NodeID` to a list (queue) of incoming messages. Each message in the list is a tuple containing the sender's `NodeID` and the message content (`msg`). This models ordered message delivery via a single reliable channel, with `msg` being a type variable for different protocols.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_3\n\nLANGUAGE: bluespec\nCODE:\n```\nvar incomingMsgs: NodeID -> List[(NodeID, msg)]\n```\n\n----------------------------------------\n\nTITLE: SignedMsgType Enum Definition\nDESCRIPTION: Protobuf enum defining the types of signed messages in consensus, including prevote, precommit, and proposal types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_13\n\nLANGUAGE: proto\nCODE:\n```\nenum SignedMsgType {\n\n  SIGNED_MSG_TYPE_UNKNOWN = 0;\n  // Votes\n  SIGNED_MSG_TYPE_PREVOTE   = 1;\n  SIGNED_MSG_TYPE_PRECOMMIT = 2;\n\n  // Proposal\n  SIGNED_MSG_TYPE_PROPOSAL = 32;\n}\n```\n\n----------------------------------------\n\nTITLE: Node Initialization in Bluespec\nDESCRIPTION: The 'DOG_init' action initializes nodes, setting starting states for various components like Flood initiation and redundancy counters. It utilizes a map function for setting initial states across node IDs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_7\n\nLANGUAGE: bluespec\nCODE:\n```\naction DOG_init = all {\n    Flood::init,\n    dr' = NodeIDs.mapBy(_ => Set()),\n    rc' = NodeIDs.mapBy(_ => initialRCState)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LightClientAttackEvidence Structure in Go\nDESCRIPTION: This code snippet defines the LightClientAttackEvidence data structure used for identifying and documenting attacks on a lightclient. It holds information on the conflicting block and its height. This structure is crucial for initializing attack evidence within Tendermint-based Cosmos blockchains.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n    ConflictingBlock   LightBlock\n    CommonHeight       int64\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseInitChain Message Structure in Protobuf\nDESCRIPTION: Updates the ResponseInitChain message to allow the application to specify the initial validator set and consensus parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-009-ABCI-design.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ResponseInitChain {\n    ConsensusParams consensus_params\n    repeated Validator validators\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Light Block from Peer in Go\nDESCRIPTION: Function to fetch a LightBlock from a peer at a specific height. It calls Commit and Validators RPCs and returns a LightBlock.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc FetchLightBlock(peer PeerID, height Height) LightBlock\n```\n\n----------------------------------------\n\nTITLE: Solution 3 - Required Extended Commits\nDESCRIPTION: Details a two-mode system (catch-up and consensus) requiring extended commits for mode switching, providing stronger safety guarantees but complicating upgrades.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-100-abci-vote-extension-propag.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n**Solution 3.** *Require extended commits to be available at switching time*.\n```\n\n----------------------------------------\n\nTITLE: Subscription Struct and Methods in Go\nDESCRIPTION: Defines a Subscription struct and its associated methods for managing subscriptions. This includes methods for accessing the output channel, checking for cancellation, and retrieving errors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Subscription struct {\n  // private fields\n}\n\nfunc (s *Subscription) Out() <-chan MsgAndTags\nfunc (s *Subscription) Canceled() <-chan struct{}\nfunc (s *Subscription) Err() error\n```\n\n----------------------------------------\n\nTITLE: Implementing Protobuf Wrapper Interface for EchoMessage - Go\nDESCRIPTION: Implements the Wrapper interface for the EchoMessage type, enabling automatic wrapping and unwrapping of PingMessage and PongMessage for transmission via channels. The Wrap method sets the inner field based on message type, while Unwrap extracts the original message; error handling ensures only known message types are processed. Depends on the proto.Message interface and assumes generated types for the EchoMessage union.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc (m *EchoMessage) Wrap(inner proto.Message) error {\\n    switch inner := inner.(type) {\\n    case *PingMessage:\\n        m.Inner = &EchoMessage_PingMessage{Ping: inner}\\n    case *PongMessage:\\n        m.Inner = &EchoMessage_PongMessage{Pong: inner}\\n    default:\\n        return fmt.Errorf(\\\"unknown message %T\\\", inner)\\n    }\\n    return nil\\n}\\n\\nfunc (m *EchoMessage) Unwrap() (proto.Message, error) {\\n    switch inner := m.Inner.(type) {\\n    case *EchoMessage_PingMessage:\\n        return inner.Ping, nil\\n    case *EchoMessage_PongMessage:\\n        return inner.Pong, nil\\n    default:\\n        return nil, fmt.Errorf(\\\"unknown message %T\\\", inner)\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PeerManager Interface for CometBFT Peer Lifecycle Management\nDESCRIPTION: The core methods of the PeerManager interface for handling peer lifecycle events such as dialing, accepting connections, and disconnections. These methods manage the state transitions of peers in the P2P network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// DialNext returns a peer address to dial, blocking until one is available.\nfunc (m *PeerManager) DialNext(ctx context.Context) (NodeAddress, error)\n\n// DialFailed reports a dial failure for the given address.\nfunc (m *PeerManager) DialFailed(address NodeAddress) error\n\n// Dialed reports a successful outbound connection to the given address.\nfunc (m *PeerManager) Dialed(address NodeAddress) error\n\n// Accepted reports a successful inbound connection from the given node.\nfunc (m *PeerManager) Accepted(peerID NodeID) error\n\n// Ready reports the peer as fully routed and ready for use.\nfunc (m *PeerManager) Ready(peerID NodeID) error\n\n// EvictNext returns a peer ID to disconnect, blocking until one is available.\nfunc (m *PeerManager) EvictNext(ctx context.Context) (NodeID, error)\n\n// Disconnected reports a peer disconnection.\nfunc (m *PeerManager) Disconnected(peerID NodeID) error\n```\n\n----------------------------------------\n\nTITLE: Defining next_block_delay Field in FinalizeBlockResponse Protobuf Message\nDESCRIPTION: Protobuf definition for the new next_block_delay field in FinalizeBlockResponse, which will allow ABCI applications to dynamically control the delay between block commitment and the next block proposal.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-115-predictable-block-times.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage FinalizeBlockResponse {\n  // ...\n  // The delay between this block and the time when the next block is proposed.\n  google.protobuf.Duration next_block_delay = 6\n      [(gogoproto.nullable) = false, (gogoproto.stdduration) = true];\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Companion Pruning in CometBFT\nDESCRIPTION: Configuration to enable data companion pruning in CometBFT. This allows the data companion to influence the node pruning mechanism, ensuring the proper retention of blocks and block results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[storage.pruning.data_companion]\n\n# Whether automatic pruning respects values set by the data companion. Disabled\n# by default. All other parameters in this section are ignored when this is\n# disabled.\n#\n# If disabled, only the application retain height will influence block pruning\n# (but not block results pruning). Only enabling this at a later stage will\n# potentially mean that blocks below the application-set retain height at the\n# time will not be available to the data companion.\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Verifying Blocks in FastSync Controller\nDESCRIPTION: This function verifies blocks sequentially, executing verified blocks and managing failed verifications.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_26\n\nLANGUAGE: go\nCODE:\n```\nfunc verifyBlocks(state State) State {\n  done = false\n  for !done {\n    block = state.Store[height]\n    if block != nil {\n      verified = verify block.Block using block.Commit // return `true` is verification succeed, 'false` otherwise\n\n      if verified {\n        block.Execute()   // executing block is costly operation so it might make sense executing asynchronously\n        state.Height++\n      } else {\n        // if block verification failed, then it is added to `FailedRequests` and the peer is removed from the peer set\n        add(state.FailedRequests, height)\n        state.Store[height] = nil\n        if _, ok := state.PeerMap[block.PeerID]; ok {\n          pendingRequest = state.PeerMap[block.PeerID].PendingRequest\n          // if there is a pending request sent to the peer that is just to be removed from the peer set, add it to `FailedRequests`\n          if pendingRequest != -1 {\n            add(state.FailedRequests, pendingRequest)\n            state.PendingRequestsNum--\n          }\n          delete(state.PeerMap, event.PeerID)\n        }\n        done = true\n      }\n    } else { done = true }\n  }\n  return state\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Companion for Pruning in CometBFT using TOML\nDESCRIPTION: Configures the automatic pruning function to respect values set by the data companion. This affects block and block results pruning behavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_98\n\nLANGUAGE: toml\nCODE:\n```\nenabled = false\n```\n\n----------------------------------------\n\nTITLE: Info Method Response Structure\nDESCRIPTION: Defines the response structure for the Info method including application state information\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\n| Name                | Type   | Description                                                               | Field Number | Deterministic |\n|---------------------|--------|---------------------------------------------------------------------------|--------------|---------------|\n| data                | string | Some arbitrary information                                                | 1            | N/A           |\n| version             | string | The application software semantic version                                 | 2            | N/A           |\n| app_version         | uint64 | The application version                                                   | 3            | N/A           |\n| last_block_height   | int64  | Latest height for which the app persisted its state                       | 4            | N/A           |\n| last_block_app_hash | bytes  | Latest AppHash returned by `FinalizeBlock`                                | 5            | N/A           |\n| lane_priorities     | map<string, uint32>  | Map of lane identifiers and their corresponding priorities  | 6            | N/A           |\n| default_lane        | uint32  | The identifier of the default lane                                       | 7            | N/A           |\n```\n\n----------------------------------------\n\nTITLE: Non-blocking Send Implementation in Go\nDESCRIPTION: Shows how to implement a non-blocking send operation when publishing messages to subscribers. This approach helps avoid the 'slow client problem' by skipping subscribers with full buffers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfor each subscriber {\n    out := subscriber.outc\n    select {\n        case out <- msg:\n        default:\n            log(\"subscriber %v buffer is full, skipping...\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Transaction Indexer Retain Height in CometBFT using Go\nDESCRIPTION: Example code for checking the current value of the transaction indexer retain height using the CometBFT privileged service client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nretainHeight, err := conn.GetTxIndexerRetainHeight(ctx)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with the `retainHeight` value\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Block Indexer Retain Height in CometBFT using Go\nDESCRIPTION: Example code for checking the current value of the block indexer retain height using the CometBFT privileged service client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nretainHeight, err := conn.GetBlockIndexerRetainHeight(ctx)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with the `retainHeight` value\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Validator State File Path in TOML for CometBFT\nDESCRIPTION: Specifies the path to the JSON file containing the last sign state of a validator. The path can be relative to $CMTHOME or an absolute path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\npriv_validator_state_file = \"data/priv_validator_state.json\"\n```\n\n----------------------------------------\n\nTITLE: PBTS Proposal Validation Implementation in Go\nDESCRIPTION: Implementation of the proposal validation logic that checks for timely and valid proposals. Includes checks for locked rounds and broadcasts appropriate PREVOTE messages based on validation results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-algorithm.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nupon ⟨PROPOSAL, h_p, round_p, v, −1⟩ from proposer(h_p, round_p) while step_p = propose do {\n   if timely(v.time) ∧ valid(v) ∧ (lockedRound_p = −1 ∨ lockedValue_p = v) {\n      broadcast ⟨PREVOTE, h_p, round_p, id(v)⟩ \n   }\n   else {\n      broadcast ⟨PREVOTE, h_p, round_p, nil⟩ \n   }\n   step_p ← prevote\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Ed25519 Address from Public Key - Go\nDESCRIPTION: Computes an address by hashing a 32-byte Ed25519 public key with SHA256 and truncating to the first 20 bytes. This function is used to create a compact identifier for an Ed25519 public key, which is integral to validator identification and consensus in CometBFT. Inputs: pubkey ([]byte, length 32). Output: address ([]byte, length 20). Dependency: Access to a SHA256 hash function.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\naddress = SHA256(pubkey)[:20]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Peer Key-Value Store Data in Go\nDESCRIPTION: This method retrieves data from the peer's key-value store, which is used to share peer-specific state between reactors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) Get(key string) interface{}\n```\n\n----------------------------------------\n\nTITLE: Header Verification in Go\nDESCRIPTION: Code snippet showing how to verify that a trusted header's last block ID matches the hash of the new header being verified.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nheader[height].LastBlockID == hash(header[height-1])\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI FinalizeBlock Method in Go\nDESCRIPTION: Implements the FinalizeBlock method of the ABCI interface. It processes the decided block, handling ban transactions and regular messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *ForumApp) FinalizeBlock(_ context.Context, req *abci.FinalizeBlockRequest) (*abci.FinalizeBlockResponse, error) {\n\tapp.logger.Info(\"Executing Application FinalizeBlock\")\n\n\t// Iterate over Tx in current block\n\tapp.onGoingBlock = app.state.DB.GetDB().NewTransaction(true)\n\trespTxs := make([]*abci.ExecTxResult, len(req.Txs))\n\tfinishedBanTxIdx := len(req.Txs)\n\tfor i, tx := range req.Txs {\n\t\tvar err error\n\n\t\tif !isBanTx(tx) {\n\t\t\tfinishedBanTxIdx = i\n\t\t\tbreak\n\t\t}\n\t\tbanTx := new(model.BanTx)\n```\n\n----------------------------------------\n\nTITLE: Querying Application State via CometBFT RPC using curl (Bash)\nDESCRIPTION: This command uses curl to query the application state via the CometBFT node's `/abci_query` RPC endpoint. It sends the sender's name (`data=\"Ron\"`) as the query data to retrieve the associated message stored by the application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"Ron\"'\n```\n\n----------------------------------------\n\nTITLE: Configuring RPC Servers for State Sync in CometBFT (TOML)\nDESCRIPTION: Specifies a comma-separated list of RPC servers for light client verification and state data retrieval during node bootstrapping. At least two servers are required for state sync to work.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_73\n\nLANGUAGE: toml\nCODE:\n```\nrpc_servers = \"\"\n```\n\n----------------------------------------\n\nTITLE: Defining EventCache struct in Go\nDESCRIPTION: Defines the EventCache struct which buffers events for a Fireable interface. All events are cached, and filtering occurs on Flush.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype EventCache struct {\n    // contains filtered or unexported fields\n}\n```\n\n----------------------------------------\n\nTITLE: Setting RPC Server Listen Address in TOML for CometBFT\nDESCRIPTION: Specifies the TCP or UNIX socket address for the RPC server to listen on. This exposes the RPC server endpoints, which have OpenAPI specifications available through Swagger UI.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\nladdr = \"tcp://127.0.0.1:26657\"\n```\n\n----------------------------------------\n\nTITLE: Basic Proposer Selection Algorithm Logic (Pseudocode)\nDESCRIPTION: This pseudocode outlines the core proposer selection mechanism. For each validator in the set (`vset`), its accumulated priority (`A(i)`) is increased by its voting power (`VP(i)`). The validator with the highest priority is selected as the proposer (`prop`). The selected proposer's priority is then decreased by the total voting power (`P`) of the set to move it back in the queue.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n    def ProposerSelection (vset):\n\n        // compute priorities and elect proposer\n        for each validator i in vset:\n            A(i) += VP(i)\n        prop = max(A)\n        A(prop) -= P\n```\n\n----------------------------------------\n\nTITLE: Creating Block Request Message in FastSync Controller\nDESCRIPTION: This utility function creates a block request message based on the current state and peer information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_25\n\nLANGUAGE: go\nCODE:\n```\nfunc createBlockRequestMessage(state ControllerState, peerID ID, peerHeight int64) MessageToSend {\n  msg = nil\n  blockHeight = -1\n  r = find request in state.FailedRequests such that r <= peerHeight // returns `nil` if there are no such request\n  // if there is a height in failed requests that can be downloaded from the peer send request to it\n  if r != nil {\n    blockNumber = r\n    delete(state.FailedRequests, r)\n  } else if state.MaxRequestPending < peerHeight {\n  // if height of the maximum pending request is smaller than peer height, then ask peer for next block\n    state.MaxRequestPending++\n    blockHeight = state.MaxRequestPending // increment state.MaxRequestPending and then return the new value\n  }\n\n  if blockHeight > -1 { msg = MessageToSend { peerID, MessageBlockRequest { blockHeight } }\n  return msg\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining the Lowest Trusted Light Block Within Trusting Period - Go\nDESCRIPTION: Specifies the LightStore method signature for Lowest(), returning the trusted LightBlock with the minimal height within the current trust window. Input: none (operates on ls); output is the corresponding LightBlock, subject to trust period constraints. No explicit error signaling is included.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\nfunc (ls LightStore) Lowest() (LightBlock)\n```\n\n----------------------------------------\n\nTITLE: Defining CanonicalVote Signing Structure - CometBFT - Protobuf\nDESCRIPTION: This snippet provides the protobuf message definition for CanonicalVote as used in CometBFT's consensus message signing. The structure enforces fixed-size encoding for the first three fields (type, height, round) to allow deterministic field offsets for signature generation and verification (especially in HSMs). Dependencies include protobuf tooling and alignment with the consensus signing specification; inputs are the canonical message field values and the output is a length-prefixed protobuf message representing the canonical vote to be signed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage CanonicalVote {\n  SignedMsgType             type      = 1;\n  sfixed64                  height    = 2;  // canonicalization requires fixed size encoding here\n  sfixed64                  round     = 3;  // canonicalization requires fixed size encoding here\n  CanonicalBlockID          block_id  = 4;\n  google.protobuf.Timestamp timestamp = 5;\n  string                    chain_id  = 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Updated CheckTx Implementation in Go\nDESCRIPTION: Example showing the new CheckTx method usage with response handling in CometBFT v1.0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\nreqRes, err := CheckTx(tx, sender)\n// check `err` here\ncb(reqRes.Response.GetCheckTx())\n```\n\n----------------------------------------\n\nTITLE: Implementing CheckBlock in CounterApplication (Go)\nDESCRIPTION: Example implementation of the CheckBlock method in a CounterApplication. This method validates transaction size and nonce, updating the transaction count accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-029-check-tx-consensus.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *CounterApplication) CheckBlock(block types.Request_CheckBlock) types.ResponseCheckBlock {\n   if app.serial {\n   \t  app.originalTxCount = app.txCount   //backup the txCount state\n      for _, tx := range block.CheckBlock.Block.Txs {\n         if len(tx) > 8 {\n            return types.ResponseCheckBlock{\n               Code: code.CodeTypeEncodingError,\n               Log:  fmt.Sprintf(\"Max tx size is 8 bytes, got %d\", len(tx))}\n         }\n         tx8 := make([]byte, 8)\n         copy(tx8[len(tx8)-len(tx):], tx)\n         txValue := binary.BigEndian.Uint64(tx8)\n         if txValue < uint64(app.txCount) {\n            return types.ResponseCheckBlock{\n               Code: code.CodeTypeBadNonce,\n               Log:  fmt.Sprintf(\"Invalid nonce. Expected >= %v, got %v\", app.txCount, txValue)}\n         }\n         app.txCount++\n      }\n   }\n   return types.ResponseCheckBlock{Code: code.CodeTypeOK}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Block Results Retain Height for Data Companion in CometBFT using TOML\nDESCRIPTION: Configures the initial value for the data companion block results retain height if not explicitly set. This affects the minimum height of block results retained during pruning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_100\n\nLANGUAGE: toml\nCODE:\n```\ninitial_block_results_retain_height = 0\n```\n\n----------------------------------------\n\nTITLE: Info Method Request Structure\nDESCRIPTION: Defines the request structure for the Info method with fields for version information\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\n| Name          | Type   | Description                            | Field Number |\n|---------------|--------|----------------------------------------|--------------||\n| version       | string | The CometBFT software semantic version | 1            |\n| block_version | uint64 | The CometBFT Block version             | 2            |\n| p2p_version   | uint64 | The CometBFT P2P version               | 3            |\n| abci_version  | string | The CometBFT ABCI semantic version     | 4            |\n```\n\n----------------------------------------\n\nTITLE: Configuring Pruning Interval in CometBFT using TOML\nDESCRIPTION: Sets the time period between automated background pruning operations. This determines how frequently the system performs pruning tasks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_97\n\nLANGUAGE: toml\nCODE:\n```\ninterval = \"10s\"\n```\n\n----------------------------------------\n\nTITLE: Transaction Validation Helper Method\nDESCRIPTION: Implements a helper method to validate transactions in key=value format. Returns 0 for valid transactions and 1 for invalid ones.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *KVStoreApplication) isValid(tx []byte) uint32 {\n    // check format\n    parts := bytes.Split(tx, []byte(\"=\"))\n    if len(parts) != 2 {\n        return 1\n    }\n    return 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Controller Operation Modes in Go\nDESCRIPTION: Enumeration of the operation modes for the Controller state machine, including FastSync for catching up and Consensus for participating in the consensus protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_14\n\nLANGUAGE: go\nCODE:\n```\ntype Mode int\nconst (\n  ModeUnknown Mode = iota\n  ModeFastSync\n  ModeConsensus\n)\n```\n\n----------------------------------------\n\nTITLE: DOG Protocol Redundancy Control Algorithm in Go\nDESCRIPTION: This code snippet describes the algorithm for controlling redundancy in the DOG protocol. It computes the ratio between duplicate and unique transactions and adjusts route disabling based on configured thresholds.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n  redundancy := duplicateTxs / firstTimeTxs\n  if redundancy < r.redundancyLowerBound:\n    peer.send(Reset)\n  if redundancy > redundancyUpperBound\n    enableRouteDisabling() \n```\n\n----------------------------------------\n\nTITLE: Defining TrustMetric Interface in Go\nDESCRIPTION: Core definition of the TrustMetric struct and its methods for tracking peer reliability. Methods allow pausing/stopping metrics, recording good/bad events, and retrieving trust values/scores.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// TrustMetric - keeps track of peer reliability\ntype TrustMetric struct {\n    // Private elements.\n}\n\n// Pause tells the metric to pause recording data over time intervals.\n// All method calls that indicate events will unpause the metric\nfunc (tm *TrustMetric) Pause() {}\n\n// Stop tells the metric to stop recording data over time intervals\nfunc (tm *TrustMetric) Stop() {}\n\n// BadEvents indicates that an undesirable event(s) took place\nfunc (tm *TrustMetric) BadEvents(num int) {}\n\n// GoodEvents indicates that a desirable event(s) took place\nfunc (tm *TrustMetric) GoodEvents(num int) {}\n\n// TrustValue gets the dependable trust value; always between 0 and 1\nfunc (tm *TrustMetric) TrustValue() float64 {}\n\n// TrustScore gets a score based on the trust value always between 0 and 100\nfunc (tm *TrustMetric) TrustScore() int {}\n\n// NewMetric returns a trust metric with the default configuration\nfunc NewMetric() *TrustMetric {}\n\n// ------------------------------------------------------------------------------------------------\n// For example\n\ntm := NewMetric()\n\ntm.BadEvents(1)\nscore := tm.TrustScore()\n\ntm.Stop()\n```\n\n----------------------------------------\n\nTITLE: Setting Non-Persistent Peer Gossip Limits\nDESCRIPTION: Experimental setting to limit number of non-persistent peers receiving transaction broadcasts.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_68\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_max_gossip_connections_to_non_persistent_peers = 0\n```\n\n----------------------------------------\n\nTITLE: Setting PostgreSQL Connection for Transaction Indexer in CometBFT using TOML\nDESCRIPTION: Configures the PostgreSQL connection string for the 'psql' indexer. This is required when using PostgreSQL for transaction indexing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_102\n\nLANGUAGE: toml\nCODE:\n```\npsql-conn = \"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring database directory in CometBFT\nDESCRIPTION: Specifies the directory path where the CometBFT database is stored. Can be a relative path (appended to $CMTHOME) or an absolute path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\ndb_dir = \"data\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Database Backend in TOML\nDESCRIPTION: Configuration for setting pebbledb as the default database backend in CometBFT v1.0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\ndb_backend = \"pebbledb\"\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Address Book File Path in TOML\nDESCRIPTION: Sets the path to the address book file where peer addresses and information are stored.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_44\n\nLANGUAGE: toml\nCODE:\n```\naddr_book_file = \"config/addrbook.json\"\n```\n\n----------------------------------------\n\nTITLE: Defining the Version Structure in CometBFT\nDESCRIPTION: Defines the `Version` structure, specifically the consensus version, used in CometBFT. It contains block and app version numbers (uint64) which must match the corresponding state versions during validation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Name  | type   | Description                                                                                                                                    | Validation                                                                                                      |\n|-------|--------|------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------|\n| Block | uint64 | This number represents the block version and must be the same throughout an operational network                                                | Must be equal to block version being used in a network (`block.Version.Block == state.Version.Consensus.Block`) |\n| App   | uint64 | App version is decided on by the application. Read [here](https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_app_requirements.md) | `block.Version.App == state.Version.Consensus.App`                                                              |\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Inspect Process\nDESCRIPTION: Basic command to start the inspect process without additional parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncometbft inspect\n```\n\n----------------------------------------\n\nTITLE: Defining Safety and Liveness Properties of Flood Protocol - Bluespec\nDESCRIPTION: Implements protocol properties for verification: ensuring that a transaction in any node's mempool will eventually reach all nodes (liveness), and guaranteeing that nodes do not resend transactions to their senders (safety/invariant). Utilizes temporal logic, comprehensions, and set operations over the state. Used for model-checking and reasoning about the protocol's correctness.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_7\n\nLANGUAGE: bluespec\nCODE:\n```\ndef txInAllMempools(tx) =\n    NodeIDs.forall(n => n.Txs().includes(tx))\n```\n\nLANGUAGE: bluespec\nCODE:\n```\ntemporal txInPoolGetsDisseminated = \n    AllTxs.forall(tx => \n        NodeIDs.exists(node =>\n            node.Txs().includes(tx) implies eventually(txInAllMempools(tx))))\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nval dontSendBackToSender =\n    NodeIDs.forall(nodeA => \n        NodeIDs.forall(nodeB => \n            AllTxs.forall(tx =>\n                nodeB.sendersOf(hash(tx)).includes(nodeA) \n                implies\n                not(nodeA.IncomingMsgs().includes((nodeB, TxMsg(tx))))\n    )))\n```\n\n----------------------------------------\n\nTITLE: Handling Duplicate Transactions and Banning Logic - Go\nDESCRIPTION: This snippet outlines logic for handling duplicate transactions already present in the cache. It discusses mechanisms for tracking sender peers and indicates possible adjustments for banning based on transaction validity.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\n\nif !mem.cache.Push(tx) { // if the transaction already exists in the cache\n  // Record a new sender for a tx we've already seen.\n  // Note it's possible a tx is still in the cache but no longer in the mempool\n  // (eg. after committing a block, txs are removed from mempool but not cache),\n  // so we only record the sender for txs still in the mempool.\n  if e, ok := mem.txsMap.Load(tx.Key()); ok {\n    memTx := e.(*clist.CElement).Value.(*mempoolTx)\n    memTx.senders.LoadOrStore(txInfo.SenderID, true)\n    // TODO: consider punishing peer for dups,\n    // its non-trivial since invalid txs can become valid,\n    // but they can spam the same tx with little cost to them atm.\n  }\n\n  // If transaction was invalid, we need to remember the peer information\n  if _, ok := mem.cache.invalidCachedTx.Load(tx.Key); ok {\n      mem.banPeer(peerID)  \n  }\n  return mempool.ErrTxInCache\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Chunk Request Timeout for State Sync in CometBFT (TOML)\nDESCRIPTION: Sets the timeout duration before re-requesting a chunk during state sync, possibly from a different peer. Must be at least 5 seconds when state sync is enabled.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_79\n\nLANGUAGE: toml\nCODE:\n```\nchunk_request_timeout = \"10s\"\n```\n\n----------------------------------------\n\nTITLE: Defining FilePV struct in Go\nDESCRIPTION: This code defines the FilePV struct which combines FilePVKey and FilePVLastSignState. It represents the complete PrivValidator structure, maintaining separation between mutable and immutable parts.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-034-priv-validator-file-structure.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype FilePV struct {\n\tKey           FilePVKey\n\tLastSignState FilePVLastSignState\n}\n```\n\n----------------------------------------\n\nTITLE: Proposal Signing Rules in Go\nDESCRIPTION: Specifies conditions under which a proposal can be signed in terms of its height and round relative to the LastSigned state. Critical for enforcing signing order.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\np.Height > s.Height\np.Height == s.Height && p.Round > s.Round\n```\n\n----------------------------------------\n\nTITLE: Defining RequestProposeTx and ResponseProposeTx Message Structures\nDESCRIPTION: Protocol buffer message definitions for the RequestProposeTx and ResponseProposeTx structures that would be used in the new ABCI ProposeTx method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-023-ABCI-propose-tx.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestProposeTx {\n  int64 next_block_height = 1; // height of the block the proposed tx would be part of\n  Validator proposer = 2; // the proposer details\n}\n\nmessage ResponseProposeTx {\n  int64 num_tx = 1; // the number of tx to include in proposed block\n  repeated bytes txs = 2; // ordered transaction data to include in block\n  bool exclusive = 3; // whether the block should include other transactions (from `mempool`)\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging Major Release Version\nDESCRIPTION: Commands for creating and pushing a signed Git tag for a major release version, which triggers the actual release process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a v2.0.0 -s -m 'Release v2.0.0'\ngit push origin v2.0.0\n```\n\n----------------------------------------\n\nTITLE: Defining Redundancy Controller in DOG Protocol in Quint\nDESCRIPTION: Implementation of the Redundancy Controller (RC) with a feedback mechanism to maintain optimal transaction redundancy. The controller tracks first-time and duplicate transactions to adjust network behavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_2\n\nLANGUAGE: bluespec\nCODE:\n```\nvar rc: NodeID -> RedundancyController\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nfirstTimeTxs: int,\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nduplicateTxs: int,\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nisHaveTxBlocked: bool,\n```\n\nLANGUAGE: bluespec\nCODE:\n```\ndef RC(node) = rc.get(node)\nval initialRCState = { firstTimeTxs: 0, duplicateTxs: 0, isHaveTxBlocked: false }\npure def increaseFirstTimeTxs(_rc) = { firstTimeTxs: _rc.firstTimeTxs + 1, ..._rc }\npure def increaseDuplicateTxs(_rc) = { duplicateTxs: _rc.duplicateTxs + 1, ..._rc }\npure def resetCounters(_rc) = { firstTimeTxs: 0, duplicateTxs: 0, ..._rc }\npure def unblockHaveTx(_rc) = { isHaveTxBlocked: false, ..._rc }\npure def blockHaveTx(_rc) = { isHaveTxBlocked: true, ..._rc }\n```\n\nLANGUAGE: bluespec\nCODE:\n```\npure def redundancy(_rc) =\n    if (_rc.firstTimeTxs == 0) \n        upperBound \n    else \n        _rc.duplicateTxs / _rc.firstTimeTxs\n```\n\nLANGUAGE: bluespec\nCODE:\n```\npure def controllerActions(_rc) =\n    if (_rc.firstTimeTxs + _rc.duplicateTxs == 0)\n        (_rc, false)\n    else if (_rc.redundancy() < lowerBound)\n        (_rc, true)\n    else if (_rc.redundancy() >= upperBound)\n        (_rc.unblockHaveTx(), false)\n    else \n        (_rc, false)\n```\n\n----------------------------------------\n\nTITLE: Configuring Colored Logging with Instance Identifiers in Go\nDESCRIPTION: Example of advanced logger configuration that applies different colors based on the instance field value, demonstrating how to implement conventions for log formatting and visual distinction.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-001-logging.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ncolorFn := func(keyvals ...interface{}) term.FgBgColor {\n\t\tfor i := 1; i < len(keyvals); i += 2 {\n\t\t\tif keyvals[i] == \"instance\" && keyvals[i+1] == \"1\" {\n\t\t\t\treturn term.FgBgColor{Fg: term.Blue}\n\t\t\t} else if keyvals[i] == \"instance\" && keyvals[i+1] == \"1\" {\n\t\t\t\treturn term.FgBgColor{Fg: term.Red}\n\t\t\t}\n\t\t}\n\t\treturn term.FgBgColor{}\n\t}\nlogger := term.NewLogger(os.Stdout, log.NewTmLogger, colorFn)\n\nc1 := NewConsensusReactor(...)\nc1.SetLogger(log.With(logger, \"instance\", 1))\n\nc2 := NewConsensusReactor(...)\nc2.SetLogger(log.With(logger, \"instance\", 2))\n```\n\n----------------------------------------\n\nTITLE: Implementing ValidatorUpdate in Go\nDESCRIPTION: This snippet outlines `ValidatorUpdate`, which determines the adjustment of validator power and identity through public keys. Dependencies include Protobuf for proper serialization. Input includes changes in validator power and identity, critical for maintaining network consensus.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/state.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\ntype ValidatorUpdate struct {\n\tPower       int64  `protobuf:\"varint,2,opt,name=power,proto3\" json:\"power,omitempty\"`\n\tPubKeyBytes []byte `protobuf:\"bytes,3,opt,name=pub_key_bytes,json=pubKeyBytes,proto3\" json:\"pub_key_bytes,omitempty\"`\n\tPubKeyType  string `protobuf:\"bytes,4,opt,name=pub_key_type,json=pubKey_type,json=pubKeyType,proto3\" json:\"pub_key_type,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Experimental Close on Slow Client for CometBFT RPC (TOML)\nDESCRIPTION: EXPERIMENTAL: Changes the behavior for slow WebSocket clients. When set to `true`, the connection is closed if the client cannot keep up with reading events. When `false` (default), events are silently dropped, leading to potential unpredictability. Enabling this provides a more predictable outcome for slow clients.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_25\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_close_on_slow_client = false\n```\n\n----------------------------------------\n\nTITLE: Configuring Experimental Subscription Buffer Size in CometBFT RPC (TOML)\nDESCRIPTION: EXPERIMENTAL: Defines the maximum number of events that will be buffered for each subscription before the server closes the subscription due to the client not consuming events quickly enough. Higher values allow for handling higher event rates but increase memory usage. The minimum allowed value is 100.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_23\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_subscription_buffer_size = 200\n```\n\n----------------------------------------\n\nTITLE: Implementing Tendermint Logger with Formatting in Go\nDESCRIPTION: Implementation of a Tendermint logger that conforms to the Logger interface and provides functionality for formatting logs in the desired output style and setting log levels.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-001-logging.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n# tm_logger.go\n// NewTmLogger returns a logger that encodes keyvals to the Writer in\n// tm format.\nfunc NewTmLogger(w io.Writer) Logger {\n  return &tmLogger{kitlog.NewLogfmtLogger(w)}\n}\n\nfunc (l tmLogger) SetLevel(level string() {\n  switch (level) {\n    case \"debug\":\n      l.sourceLogger = level.NewFilter(l.sourceLogger, level.AllowDebug())\n  }\n}\n\nfunc (l tmLogger) Info(msg string, keyvals ...interface{}) error {\n  l.sourceLogger.Log(\"msg\", msg, keyvals...)\n}\n\n# log.go\nfunc With(logger Logger, keyvals ...interface{}) Logger {\n  kitlog.With(logger.sourceLogger, keyvals...)\n}\n```\n\n----------------------------------------\n\nTITLE: Upgrading CometBFT Installation\nDESCRIPTION: These commands update the local repository to the latest version from the main branch and reinstall CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ngit pull origin main\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuring CometBFT for No Empty Blocks\nDESCRIPTION: Configuration options to prevent CometBFT from producing empty blocks, either via command line flag or config file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --consensus.create_empty_blocks=false\n```\n\nLANGUAGE: toml\nCODE:\n```\n[consensus]\ncreate_empty_blocks = false\n```\n\n----------------------------------------\n\nTITLE: Handling Response Timeout Event in FastSync Controller\nDESCRIPTION: This function manages the response timeout event, removing unresponsive peers and managing failed requests.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_24\n\nLANGUAGE: go\nCODE:\n```\nfunc handleEventResponseTimeout(event, state) {\n  if _, ok := state.PeerMap[event.PeerID]; ok {\n    peerStats = state.PeerMap[event.PeerID]\n    // if a response timeout expires and the peer hasn't delivered the block, the peer is removed from the peer list and\n    // the request is added to the `FailedRequests` so the block can be downloaded from other peer\n  if peerStats.PendingRequest == event.Height {\n    add(state.FailedRequests, pendingRequest)\n    delete(state.PeerMap, event.PeerID)\n    state.PendingRequestsNum--\n    // if peer set is empty, then termination timeout is triggered\n    if state.PeerMap.isEmpty() {\n      timeout = TimeoutTrigger{ state.Height, TerminationTimeout }\n    }\n  }\n  }\n  return state, msg, timeout, error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PeerTransport Interface in Go\nDESCRIPTION: Definition of the PeerTransport interface that will be responsible for emitting and connecting to Peers. This interface provides methods for accepting new peer connections and dialing peers by network address.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-012-peer-transport.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// PeerTransport proxies incoming and outgoing peer connections.\ntype PeerTransport interface {\n\t// Accept returns a newly connected Peer.\n\tAccept() (Peer, error)\n\n\t// Dial connects to a Peer.\n\tDial(NetAddress) (Peer, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sentry Node Parameters in TOML\nDESCRIPTION: Configuration settings for CometBFT sentry nodes that protect validators by acting as intermediaries between the validator and the public network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/validators.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\npex = true\npersistent_peers = \"validator node, optionally other sentry nodes\"\nprivate_peer_ids = \"validator node ID\"\nunconditional_peer_ids = \"validator node ID, optionally sentry node IDs\"\naddr_book_strict = false\n```\n\n----------------------------------------\n\nTITLE: Defining the Flood Gossip Message Types with Quint - Bluespec\nDESCRIPTION: Defines the core message type used in the Flood protocol, specifically a single message variant carrying a transaction (TX). Relies on type TX being defined elsewhere and is foundational for communication between peers in the gossip network. The message is used for transaction forwarding and forms the basis for message handling in subsequent protocol logic.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_0\n\nLANGUAGE: bluespec\nCODE:\n```\ntype Message =\n    | TxMsg(TX)\n```\n\n----------------------------------------\n\nTITLE: Configuring NOP Mempool in TOML\nDESCRIPTION: Configuration example for enabling the no-operation mempool type in CometBFT v1.0 config.toml file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[mempool]\n# - \"nop\"   : nop-mempool (short for no operation; the ABCI app is responsible\n# for storing, disseminating and proposing txs). \"create_empty_blocks=false\"\n# is not supported.\ntype = \"nop\"\n```\n\n----------------------------------------\n\nTITLE: Setting Vote Timeout for Consensus in CometBFT (TOML)\nDESCRIPTION: Defines how long a node waits after receiving +2/3 conflicting prevotes/precommits before pre-committing nil or starting a new round. Crucial for handling conflicting votes and achieving consensus.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_84\n\nLANGUAGE: toml\nCODE:\n```\ntimeout_vote = \"1s\"\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseInfo message in Protocol Buffers\nDESCRIPTION: This Protocol Buffers message definition for ResponseInfo includes fields for data, version, app_version, last_block_height, and last_block_app_hash to return version information in ABCI responses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-016-protocol-versions.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ResponseInfo {\n  string data\n\n  string version\n  uint64 app_version\n\n  int64 last_block_height\n  bytes last_block_app_hash\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Consensus Executor in Go\nDESCRIPTION: This snippet defines the ConsensusExecutor function, which is responsible for managing the overall consensus process. It initializes the consensus state, handles incoming messages and timeouts, and calls the Consensus function to progress through the consensus rounds. It also manages vote sets and triggers appropriate events based on voting results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-030-consensus-refactor.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc ConsensusExecutor() {\n\tproposal = nil\n\tvotes = HeightVoteSet { Height: 1 }\n\tstate = State {\n\t\tHeight:       1\n\t\tRound:        0          \n\t\tStep:         RoundStepPropose\n\t\tLockedValue:  nil\n\t\tLockedRound:  -1\n\t\tValidValue:   nil\n\t\tValidRound:   -1\n\t}\n\t\n\tevent = EventNewHeight {1, id}\n\tstate, msg, timeout = Consensus(event, state)\n\t\n\tevent = EventNewRound {state.Height, 0}\n\tstate, msg, timeout = Consensus(event, state)\n\t\n\tif msg != nil {\n\t\tsend msg\n\t}\n\t\n\tif timeout != nil {\n\t\ttrigger timeout\n\t}\n\t\n\tfor {\n\t\tselect {\n\t\t    case message := <- msgCh:\n\t\t    \tswitch msg := message.(type) {\n\t\t    \t    case MessageProposal:\n\t\t    \t        \n\t\t    \t    case MessageVote:\t\n\t\t    \t    \tif msg.Height == state.Height {\n\t\t    \t    \t\tnewVote = votes.AddVote(msg)\n\t\t    \t    \t\tif newVote {\n\t\t    \t    \t\t\tswitch msg.Type {\n                                \tcase Prevote:\n                                \t\tprevotes = votes.Prevotes(msg.Round)\n                                \t\tif prevotes.WeakCertificate() and msg.Round > state.Round {\n                                \t\t\tevent = EventNewRound { msg.Height, msg.Round }\n                                \t\t\tstate, msg, timeout = Consensus(event, state)\n                                \t\t\tstate = handleStateChange(state, msg, timeout)\n                                \t\t}\t\n                                \t\t\n                                \t\tif blockID, ok = prevotes.TwoThirdsMajority(); ok and blockID != nil {\n                                \t\t    if msg.Round == state.Round and hasBlock(blockID) {\n                                \t\t    \tevent = Majority23PrevotesBlock { msg.Height, msg.Round, blockID }\n                                \t\t    \tstate, msg, timeout = Consensus(event, state)\n                                \t\t    \tstate = handleStateChange(state, msg, timeout)\n                                \t\t    } \n                                \t\t    if proposal != nil and proposal.POLRound == msg.Round and hasBlock(blockID) {\n                                \t\t        event = EventProposal {\n                                                        Height: state.Height\n                                                        Round:  state.Round\n                                                        BlockID: blockID\n                                                        POLRound: proposal.POLRound\n                                                        Sender: message.Sender\n                                \t\t        }\n                                \t\t        state, msg, timeout = Consensus(event, state)\n                                \t\t        state = handleStateChange(state, msg, timeout)\n                                \t\t    }\n                                \t\t}\n                                \t\t\n                                \t\tif prevotes.HasTwoThirdsAny() and msg.Round == state.Round {\n                                \t\t\tevent = Majority23PrevotesAny { msg.Height, msg.Round, blockID }\n                                \t\t\tstate, msg, timeout = Consensus(event, state)\n                                            state = handleStateChange(state, msg, timeout)\n                                \t\t}\n                                \t\t\n                                \tcase Precommit:\t\n                                \t\t\n\t\t    \t    \t\t    }\n\t\t    \t    \t    }\n\t\t    \t        }\n\t\t    case timeout := <- timeoutCh:\n\t\t    \n\t\t    case block := <- blockCh:\t\n\t\t    \t\n\t\t}\n\t}\n}\n\t\nfunc handleStateChange(state, msg, timeout) State {\n\tif state.Step == Commit {\n\t\tstate = ExecuteBlock(state.LockedValue)\n\t}\t\n\tif msg != nil {\n\t\tsend msg\n\t}\t\n\tif timeout != nil {\n\t\ttrigger timeout\n\t}\t\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Incoming Messages in Bluespec\nDESCRIPTION: Defines how different incoming messages from peers are processed by the node. Each message type (e.g., transaction message, reset route message) triggers distinct procedures within the node.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_16\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction handleMessage(node, _incomingMsgs, sender, msg) =\n    match msg {\n    | TxMsg(tx) => node.tryAddTx(_incomingMsgs, Some(sender), tx)\n    | HaveTxMsg(txID) => node.handleHaveTxMessage(_incomingMsgs, sender, txID)\n    | ResetRouteMsg => node.handleResetRouteMessage(_incomingMsgs, sender)\n    }\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction handleHaveTxMessage(node, _incomingMsgs, sender, txID) = all {\n    val txSenders = node.sendersOf(txID)\n    dr' = dr.update(node, drs => \n        if (length(txSenders) > 0) drs.disableRoute((txSenders[0], sender)) else drs),\n    incomingMsgs' = _incomingMsgs,\n    peers' = peers,\n    mempool' = mempool,\n    senders' = senders,\n    rc' = rc,\n}\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction handleResetRouteMessage(node, _incomingMsgs, sender) = all {\n    nondet randomRoute = oneOf(node.DisabledRoutes().routesWithTarget(sender))\n    dr' = dr.update(node, drs => drs.enableRoute(randomRoute)),\n    incomingMsgs' = _incomingMsgs,\n    peers' = peers,\n    mempool' = mempool,\n    senders' = senders,\n    rc' = rc,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Network Topology Parameter in Bluespec\nDESCRIPTION: Defines the `InitialPeers` constant parameter as a map from each `NodeID` to a set of its initial peer `NodeID`s. This specifies the static network connections at the beginning of the system's operation or simulation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_2\n\nLANGUAGE: bluespec\nCODE:\n```\nconst InitialPeers: NodeID -> Set[NodeID]\n```\n\n----------------------------------------\n\nTITLE: Storing Pending Transactions in Mempool\nDESCRIPTION: Defines the 'txs' list in 'MempoolState' to store pending transactions. Assumes no maximum capacity and that all transactions in 'txs' are in 'cache' as well.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_6\n\nLANGUAGE: bluespec\nCODE:\n```\ntxs: List[TX],\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data by Height in CometBFT (HTTP Request)\nDESCRIPTION: This snippet demonstrates how to query a block by height using an HTTP GET request to the CometBFT API. It shows both the default request for the latest block and a request for a specific block height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/block\n\ncurl http://127.0.0.1:26657/v1/block?height=1\n```\n\n----------------------------------------\n\nTITLE: Searching Transactions\nDESCRIPTION: cURL command to search for transactions using the tx_search endpoint with a specific query.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"localhost:26657/tx_search?query=\\\"app.key='cometbft'\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Time Check Handler in Processor in Go\nDESCRIPTION: Defines the handleTimeCheckEv method that manages timeouts in the processor. It checks if the last activity was too long ago and triggers timeout handling when necessary.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc handleTimeCheckEv(time) {\n\tif time - lastTouch > timeout {\n\t\t// Timeout the processor\n\t\t...\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI Application Interface\nDESCRIPTION: Creates a new file 'app.go' with the basic structure for the ABCI application interface.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    abcitypes \"github.com/cometbft/cometbft/abci/types\"\n    \"context\"\n)\n\ntype KVStoreApplication struct{}\n\nvar _ abcitypes.Application = (*KVStoreApplication)(nil)\n\nfunc NewKVStoreApplication() *KVStoreApplication {\n    return &KVStoreApplication{}\n}\n\nfunc (app *KVStoreApplication) Info(_ context.Context, info *abcitypes.InfoRequest) (*abcitypes.InfoResponse, error) {\n    return &abcitypes.InfoResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) Query(_ context.Context, req *abcitypes.QueryRequest) (*abcitypes.QueryResponse, error) {\n    return &abcitypes.QueryResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) CheckTx(_ context.Context, check *abcitypes.CheckTxRequest) (*abcitypes.CheckTxResponse, error) {\n\treturn &abcitypes.CheckTxResponse{Code: 0}, nil\n}\n\nfunc (app *KVStoreApplication) InitChain(_ context.Context, chain *abcitypes.InitChainRequest) (*abcitypes.InitChainResponse, error) {\n    return &abcitypes.InitChainResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) PrepareProposal(_ context.Context, proposal *abcitypes.PrepareProposalRequest) (*abcitypes.PrepareProposalResponse, error) {\n    return &abcitypes.PrepareProposalResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ProcessProposal(_ context.Context, proposal *abcitypes.ProcessProposalRequest) (*abcitypes.ProcessProposalResponse, error) {\n    return &abcitypes.ProcessProposalResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) FinalizeBlock(_ context.Context, req *abcitypes.FinalizeBlockRequest) (*abcitypes.FinalizeBlockResponse, error) {\n    return &abcitypes.FinalizeBlockResponse{}, nil\n}\n\nfunc (app KVStoreApplication) Commit(_ context.Context, commit *abcitypes.CommitRequest) (*abcitypes.CommitResponse, error) {\n    return &abcitypes.CommitResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ListSnapshots(_ context.Context, snapshots *abcitypes.ListSnapshotsRequest) (*abcitypes.ListSnapshotsResponse, error) {\n    return &abcitypes.ListSnapshotsResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) OfferSnapshot(_ context.Context, snapshot *abcitypes.OfferSnapshotRequest) (*abcitypes.OfferSnapshotResponse, error) {\n    return &abcitypes.OfferSnapshotResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) LoadSnapshotChunk(_ context.Context, chunk *abcitypes.LoadSnapshotChunkRequest) (*abcitypes.LoadSnapshotChunkResponse, error) {\n    return &abcitypes.LoadSnapshotChunkResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) ApplySnapshotChunk(_ context.Context, chunk *abcitypes.ApplySnapshotChunkRequest) (*abcitypes.ApplySnapshotChunkResponse, error) {\n    return &abcitypes.ApplySnapshotChunkResponse{Result: abcitypes.APPLY_SNAPSHOT_CHUNK_RESULT_ACCEPT}, nil\n}\n\nfunc (app KVStoreApplication) ExtendVote(_ context.Context, extend *abcitypes.ExtendVoteRequest) (*abcitypes.ExtendVoteResponse, error) {\n    return &abcitypes.ExtendVoteResponse{}, nil\n}\n\nfunc (app *KVStoreApplication) VerifyVoteExtension(_ context.Context, verify *abcitypes.VerifyVoteExtensionRequest) (*abcitypes.VerifyVoteExtensionResponse, error) {\n    return &abcitypes.VerifyVoteExtensionResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Persistent Peers in TOML\nDESCRIPTION: Sets a comma-separated list of nodes to maintain persistent connections with. The node will attempt to reconnect if connections are lost.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_42\n\nLANGUAGE: toml\nCODE:\n```\npersistent_peers = \"\"\n```\n\n----------------------------------------\n\nTITLE: Stop Peer Sequence (ABNF)\nDESCRIPTION: This ABNF snippet describes the peer disconnection process. The p2p layer may log an error (`peer-error`) depending on the reason for stopping, and then invokes `RemovePeer(Peer, reason)` on the reactor after the peer's communication routines have been halted. The reactor should cease interaction with this peer instance upon receiving this call.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_5\n\nLANGUAGE: abnf\nCODE:\n```\nstop-peer       = [peer-error] remove-peer\n```\n\n----------------------------------------\n\nTITLE: Querying the ABCI application state\nDESCRIPTION: cURL command to query the state of the ABCI application through CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"abcd\"'\n```\n\n----------------------------------------\n\nTITLE: Peer Management Sequence (ABNF)\nDESCRIPTION: This ABNF snippet focuses on the interaction sequence for managing a single peer connection from the reactor's perspective. It involves initializing the peer (`InitPeer`), attempting to start communication routines (`start-peer`), and eventually stopping the peer connection (`stop-peer`). Reactors must handle multiple such sequences concurrently for different peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_3\n\nLANGUAGE: abnf\nCODE:\n```\n; Refers to a single peer, a reactor must support multiple concurrent peers\npeer-management = init-peer start-peer stop-peer\n```\n\n----------------------------------------\n\nTITLE: Defining LightClientAttackEvidence - Tendermint - Go\nDESCRIPTION: Defines the LightClientAttackEvidence struct, used for reporting evidence of a light client attack in the Tendermint consensus algorithm. This struct requires that a conflicting block and its associated common height are recorded. It is depended upon by the main isolator logic and supporting verification functions, and expects a LightBlock as the conflicting block and an int64 for the common height as inputs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n    ConflictingBlock   LightBlock\n    CommonHeight       int64\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ForumApp Struct and Dependencies in Go\nDESCRIPTION: Defines the ForumApp struct and implements a constructor function NewForumApp. It initializes the app state, loads configuration, and sets up the validator map.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ForumApp struct {\n\tabci.BaseApplication\n\tvalAddrToPubKeyMap map[string]crypto.PublicKey\n\tCurseWords         string\n\tstate              AppState\n\tonGoingBlock       *badger.Txn\n\tlogger             log.Logger\n}\n\nfunc NewForumApp(dbDir string, appConfigPath string, logger log.Logger) (*ForumApp, error) {\n\tdb, err := model.NewDB(dbDir)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initializing database: %w\", err)\n\t}\n\tcfg, err := LoadConfig(appConfigPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error loading config file: %w\", err)\n\t}\n\n\tcfg.CurseWords = DeduplicateCurseWords(cfg.CurseWords)\n\n\tstate, err := loadState(db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Reading the validators from the DB because CometBFT expects the application to have them in memory\n\tvalMap := make(map[string]crypto.PublicKey)\n\tvalidators, err := state.DB.GetValidators()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't load validators: %w\", err)\n\t}\n\tfor _, v := range validators {\n\t\tpubKey, err := cryptoencoding.PubKeyFromTypeAndBytes(v.PubKeyType, v.PubKeyBytes)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can't decode public key: %w\", err)\n\t\t}\n\n\t\tvalMap[string(pubKey.Address())] = pubKey\n\t}\n\n\treturn &ForumApp{\n\t\tstate:              state,\n\t\tvalAddrToPubKeyMap: valMap,\n\t\tCurseWords:         cfg.CurseWords,\n\t\tlogger:             logger,\n\t}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Latest Trusted Light Block in Go\nDESCRIPTION: Function to get the highest verified light block that has been checked by the detector from the LightStore.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) LatestTrusted() LightBlock\n```\n\n----------------------------------------\n\nTITLE: Implementing Peer Addition in Blockchain Reactor in Go\nDESCRIPTION: Defines the AddPeer method for the BlockchainReactor which notifies the system of a new peer by sending a peer addition event to the main message channel.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *BlockchainReactor) AddPeer(peer p2p.Peer) {\n\t...\n\tr.msgs <- bcAddPeerEv{peer.ID}\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UpdateTransactionGossipList Protocol Messages in Protobuf\nDESCRIPTION: Protocol buffer message definitions for the UpdateTransactionGossipList request and response. The request includes a max_size parameter to limit transaction count, while the response contains a list of transaction bytes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-025-support-app-side-mempool.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage UpdateTransactionGossipListRequest {\n  int64 max_size = 1; // application cannot provide more than `max_size` transactions.\n}\n\nmessage UpdateTransactionGossipListResponse {\n  repeated bytes = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Misbehavior Checking Handler Interface in Go\nDESCRIPTION: This snippet introduces a function signature for submitting evidence of misbehavior to a handler, named checkMisbehaviorAndUpdateState. Written as a Go-like type definition, it describes a function that accepts a byte array (bytes) containing arbitrary evidence and returns nothing (void). The handler must internally verify that submitted evidence signals actual misbehavior (such as a detected fork) before acting upon it. This interface requires defined evidence data structures, mechanisms for consensus state checking, and is essential for flagging protocol halting or misbehavior actions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/req-ibc-detection.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype checkMisbehaviorAndUpdateState = (bytes) => Void\n```\n\n----------------------------------------\n\nTITLE: Initializing Controller State in Go\nDESCRIPTION: Function that initializes a new Controller state with a starting height and block executor, setting the initial mode to FastSync and initializing data structures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_18\n\nLANGUAGE: go\nCODE:\n```\nfunc NewControllerState(startHeight int64, executor BlockExecutor) ControllerState {\n  state = ControllerState {}\n  state.Height = startHeight\n  state.Mode = ModeFastSync\n  state.MaxRequestPending = startHeight - 1\n  state.PendingRequestsNum = 0\n  state.Executor = executor\n  initialize state.PeerMap, state.FailedRequests and state.Store to empty data structures\n  return state\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User Struct in Go for Forum Application\nDESCRIPTION: This snippet defines the User struct with fields for name, moderator status, ban status, message count, version, and schema version. It uses JSON tags for serialization.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/5.model.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage model\n\ntype User struct {\n\tName          string `json:\"name\"`\n\tModerator     bool   `json:\"moderator\"`\n\tBanned        bool   `json:\"banned\"`\n\tNumMessages   int64  `json:\"numMessages\"`\n\tVersion       uint64 `json:\"version\"`\n\tSchemaVersion int    `json:\"schemaVersion\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Response Structures for Process Proposal in Rust\nDESCRIPTION: Defines the response structures for VerifyHeader and ProcessProposal methods, including fields for acceptance and evidence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct ResponseVerifyHeader {\n    accept_header: bool,\n    evidence: Vec<Evidence>\n}\nstruct ResponseProcessProposal {\n    accept_block: bool,\n    evidence: Vec<Evidence>\n}\n```\n\n----------------------------------------\n\nTITLE: Block Consensus Parameters in v0.38.x\nDESCRIPTION: Default block consensus parameters in CometBFT v0.38.x. These control the maximum size and gas limit for blocks in the blockchain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n    \"block\": {\n      \"max_bytes\": \"22020096\",\n      \"max_gas\": \"-1\"\n    },\n```\n\n----------------------------------------\n\nTITLE: Defining Termination Timeout Event Structure in Go\nDESCRIPTION: Structure for termination timeout events that are generated when a termination timeout expires, containing the height for which the timeout occurred.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\ntype EventTimeoutTermination struct {\n  Height int64\n}\n```\n\n----------------------------------------\n\nTITLE: Overview of SignX Request/Reply Communication Flow in CometBFT\nDESCRIPTION: Diagram showing the communication flow between a remote signer (KMS) and Tendermint, with SignXRequest and SignedXReply message formats. This establishes the basic pattern for all validator message exchanges.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\n+--------------+                      +----------------+\n|              |     SignXRequest     |                |\n|Remote signer |<---------------------+  tendermint    |\n| (e.g. KMS)   |                      |                |\n|              +--------------------->|                |\n+--------------+    SignedXReply      +----------------+\n\n\nSignXRequest {\n    x: X\n}\n\nSignedXReply {\n    x: X\n  sig: Signature // []byte\n  err: Error{ \n    code: int\n    desc: string\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring NOP Mempool in TOML\nDESCRIPTION: TOML configuration snippet for setting up a 'nop' (no operation) mempool. This type of mempool delegates transaction storage, dissemination, and proposal to the ABCI application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[mempool]\n\n# The type of mempool for this node to use.\n#\n# Possible types:\n# - \"flood\" : concurrent linked list mempool with flooding gossip protocol\n# (default)\n# - \"nop\"   : nop-mempool (short for no operation; the ABCI app is responsible\n# for storing, disseminating and proposing txs). \"create_empty_blocks=false\"\n# is not supported.\ntype = \"nop\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Allowed Headers in CometBFT RPC (TOML)\nDESCRIPTION: Specifies the list of HTTP headers that client applications are allowed to use when making cross-domain requests to the RPC endpoint. This configuration is essential for web applications interacting with the RPC server from a different origin. The list should contain strings representing valid header names recognized by the Fetch specification's CORS-safelisted request headers, though `Origin` is technically forbidden by the spec but commonly included.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_18\n\nLANGUAGE: toml\nCODE:\n```\ncors_allowed_headers = [\"Origin\", \"Accept\", \"Content-Type\", \"X-Requested-With\", \"X-Server-Time\", ]\n```\n\n----------------------------------------\n\nTITLE: Generating Builder Pattern for Rust Protobuf Structs\nDESCRIPTION: Proposed Rust code generation for a builder pattern API, allowing ergonomic initialization of protobuf-derived structs while maintaining forward compatibility.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-102-rust-gen-builders.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl HelloRequest {\n    pub fn builder() -> self::prost_builders::HelloRequestBuilder {\n        todo!()\n    }\n}\n\npub mod prost_builders {\n    pub struct HelloRequestBuilder {\n        inner: super::HelloRequest,\n    }\n\n    impl HelloRequestBuilder {\n        pub fn version(mut self, version: i32) -> Self {\n            self.inner.version = version;\n            self\n        }\n\n        pub fn flags<T>(mut self, flags: impl IntoIterator<Item = T>) -> Self\n        where T: Into<String>,\n        {\n            self.inner.flags = flags.into_iter().map(Into::into).collect();\n            self\n        }\n\n        pub fn build(self) -> super::HelloRequest {\n            self.inner\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LightBlock Structure in Go\nDESCRIPTION: The LightBlock structure is a core component in the protocol defining block metadata and validation settings. This data type includes parameters like Header, Commit, and Validators which are crucial for the block validation process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype LightBlock struct {\n                Header          Header\n                Commit          Commit\n                Validators      ValidatorSet\n                NextValidators  ValidatorSet\n                Provider        PeerID\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function to Find Disconnected Peers in Bluespec\nDESCRIPTION: Defines the function `disconnectedPeers(node)` which identifies peers of a given `node` that do not reciprocate the connection (i.e., `node` is not in their peer list). This helps in checking the symmetry property of the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_9\n\nLANGUAGE: bluespec\nCODE:\n```\ndef disconnectedPeers(node) = \n    node.Peers().filter(p => not(node.in(p.Peers())))\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Historical Height and Time in Go\nDESCRIPTION: This code calculates the maximum historical height and time parameters needed for determining how far back a node needs to reverse sync for evidence verification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nmax_historical_height = max(state.InitialHeight, state.LastBlockHeight - state.ConsensusParams.EvidenceAgeHeight)\nmax_historical_time = max(GenesisTime, state.LastBlockTime.Sub(state.ConsensusParams.EvidenceAgeTime))\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Server Settings in TOML\nDESCRIPTION: Basic gRPC server configuration in CometBFT's config file to enable the non-privileged services endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/grpc.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[grpc]\nladdr = \"tcp://0.0.0.0:26090\"\n```\n\n----------------------------------------\n\nTITLE: Refactoring Switch Constructor for PeerTransport in Go\nDESCRIPTION: New constructor signature for the Switch component that depends on a PeerTransport instead of directly handling transport concerns. This removes the need to pass P2PConfig to the Switch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-012-peer-transport.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc NewSwitch(transport PeerTransport, opts ...SwitchOption) *Switch\n```\n\n----------------------------------------\n\nTITLE: Setting Redundancy Delta Percent in Bluespec\nDESCRIPTION: This snippet sets the 'TargetRedundancyDeltaPercent' parameter, allowing fluctuations of redundancy levels within specified bounds from the target value. The range provides stability by allowing fluctuation while staying within limits. Typically, a 20% deviation is recommended.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_5\n\nLANGUAGE: bluespec\nCODE:\n```\nconst TargetRedundancyDeltaPercent: int\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nval _delta = TargetRedundancy * TargetRedundancyDeltaPercent / 100\nval lowerBound = TargetRedundancy - _delta\nval upperBound = TargetRedundancy + _delta\n```\n\n----------------------------------------\n\nTITLE: Implementing Merkle Root Calculation - Go\nDESCRIPTION: Recursively computes a Merkle tree root hash for a given list of byte arrays, following RFC 6962. Uses SHA256 with domain separation (prefixes 0x00/0x01) for leaf and inner node hashes. Handles tree balancing by splitting items using the largest power of two less than the list length. Inputs: items ([][]byte). Output: root hash ([]byte). Dependencies: SHA256, append operations, and utility functions for splitting. Expects pre-encoded (e.g., via protobuf) arrays for non-byte data structures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// SHA256([]byte{})\nfunc emptyHash() []byte {\n    return tmhash.Sum([]byte{})\n}\n\n// SHA256(0x00 || leaf)\nfunc leafHash(leaf []byte) []byte {\n return tmhash.Sum(append(0x00, leaf...))\n}\n\n// SHA256(0x01 || left || right)\nfunc innerHash(left []byte, right []byte) []byte {\n return tmhash.Sum(append(0x01, append(left, right...)...))\n}\n\n// largest power of 2 less than k\nfunc getSplitPoint(k int) { ... }\n\nfunc MerkleRoot(items [][]byte) []byte{\n switch len(items) {\n case 0:\n  return emptyHash()\n case 1:\n  return leafHash(items[0])\n default:\n  k := getSplitPoint(len(items))\n  left := MerkleRoot(items[:k])\n  right := MerkleRoot(items[k:])\n  return innerHash(left, right)\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Node Joining Network in Bluespec\nDESCRIPTION: Represents the protocol allowing a node to join the network, ensuring updates across mempool, senders, and redundancy counters. Part of state transitions aligning with the Flood protocol mechanism.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_11\n\nLANGUAGE: bluespec\nCODE:\n```\nall {\n    pickNodeAndJoin,\n    mempool' = mempool,\n    senders' = senders,\n    dr' = dr,\n    rc' = rc,\n},\n```\n\n----------------------------------------\n\nTITLE: Defining Light Client Attack (CMBC-LC-ATTACK.1)\nDESCRIPTION: Defines a 'light client attack' at time 't'. This occurs if an 'attack(a,b,c,t)' condition exists, but there is *no* main chain fork (meaning correct full nodes agree). This implies that faulty nodes have created a conflicting block ('c') specifically to deceive light clients, while the main chain follows a different block ('b').\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-LC-ATTACK.1]\n\nWe say there is a light client attack at time *t*, if\n\n- there is **no** (main chain) fork [[CMBC-MC-FORK.1]](#CMBC-MC-FORK1), and\n- there exist nodes that have computed light blocks *b* and *c* and\n- there exist *a* such that *attack(a,b,c,t)*.\n\nWe say the attack is at height *a.Header.Height*.\n```\n\n----------------------------------------\n\nTITLE: Defining Block Request Message Structure in Go\nDESCRIPTION: Structure for block request messages which specify the height of the block being requested from a peer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype MessageBlockRequest struct {\n  Height int64\n}\n```\n\n----------------------------------------\n\nTITLE: Submitting Attack Evidence to Peers in CometBFT (Go)\nDESCRIPTION: Specifies the function signature for submitEvidence, which accepts a slice of InternalEvidence objects and submits them for each associated peer, likely via a P2P or network layer mechanism, to communicate detected misbehavior in the light client protocol. Dependencies include the definitions of InternalEvidence and the expected submission mechanism within the application. Inputs are a list of InternalEvidence objects corresponding to detected attacks; outputs are not explicitly specified in the signature but are expected to be side-effects of evidence submission. This function assumes that peer identification and evidence formation are handled beforehand, and all submissions must be successful for correct operation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_001_reviewed.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc submitEvidence(Evidences []InternalEvidence)\n```\n\n----------------------------------------\n\nTITLE: Submitting Evidence in Go\nDESCRIPTION: Function signature for submitting a list of internal evidence to their respective peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc submitEvidence(Evidences []InternalEvidence)\n```\n\n----------------------------------------\n\nTITLE: Crash Recovery Sequence Diagram in Mermaid\nDESCRIPTION: A sequence diagram illustrating the crash recovery process between a CometBFT node and companion service, showing how data for a specific height can be resent after a crash to ensure at-least-once delivery.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-100-data-companion-push-api.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant N as Node\n    participant C as Companion\n\n    N->>+C: BlockCommittedRequest (height = 10)\n    C->>-N: BlockCommittedResponse (error = nil)\n    N->>N: Save prune height as 10\n\n    N->>C: BlockCommittedRequest (height = 11)\n    break Node or companion crashes\n        N-->C: Node and companion recover\n    end\n\n    N->>+C: BlockCommittedRequest (height = 11)\n    C->>-N: BlockCommittedResponse (error = nil)\n    N->>N: Save prune height as 11\n```\n\n----------------------------------------\n\nTITLE: Defining Bidirectional Network Invariant in Bluespec\nDESCRIPTION: Defines the `bidirectionalNetwork` invariant property. It asserts that for every node A and every peer B of A, node A must also be a peer of node B. This ensures the peer relationship defined in the `peers` state variable is always symmetric.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_14\n\nLANGUAGE: bluespec\nCODE:\n```\nval bidirectionalNetwork =\n    NodeIDs.forall(nodeA => \n        nodeA.Peers().forall(nodeB => nodeA.in(nodeB.Peers())))\n```\n\n----------------------------------------\n\nTITLE: Checking Vote Extension Signature in Go\nDESCRIPTION: Example of how to check if a validator signed the last block using the new block_id_flag field in VoteInfo structure.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/UPGRADING.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nvoteInfo.block_id_flag != BlockIDFlagAbsent\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing Documentation Update for Backport Branch\nDESCRIPTION: Commands for updating documentation references in a backport branch. This creates a new branch, commits documentation changes, and pushes them to prepare PR for the backport branch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# Create and push the PR.\ngit checkout -b update-docs-v2.x\ngit commit -m \"Update docs for v2.x backport branch.\"\ngit push -u origin update-docs-v2.x\n```\n\n----------------------------------------\n\nTITLE: Describing Cleanup Method for Peer Connection Removal in CometBFT\nDESCRIPTION: The Cleanup method removes a peer's connection from the established connections table and closes the connection. It is called when a peer connection is closed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/implementation/transport.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Cleanup\n\nThe `Cleanup` method receives a `Peer` instance,\nand removes the connection established with a peer from the table of established connections.\nIt also invokes the `Peer` interface method to close the connection associated with a peer.\n\nIt is invoked when the connection with a peer is closed.\n```\n\n----------------------------------------\n\nTITLE: Isolating Amnesia Attacker - Tendermint - Go\nDESCRIPTION: Defines a stub for IsolateAmnesiaAttacker to identify validator addresses responsible for amnesia attacks, when conflicting commits come from different rounds. Context or logic should be referenced to accountability documentation, as detailed implementation is to be determined. The function expects light client evidence and blockchain data as inputs and is called from the main isolation routine.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc IsolateAmnesiaAttacker(ev LightClientAttackEvidence, bc Blockchain) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Determining Commit Round - Tendermint - Go\nDESCRIPTION: Declares RoundOf for extracting the consensus round of a commit. The commit must be well-formed, with all included votes referencing the same round. The function is used to distinguish between equivocation and amnesia attacks by comparing rounds of distinct commits.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc RoundOf(commit Commit) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Setting a human-readable node name in CometBFT\nDESCRIPTION: Defines a custom human-readable name for the node. Used for identification in status reports and local environments, though not required to be unique in the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\nmoniker = \"my.host.name\"\n```\n\n----------------------------------------\n\nTITLE: Encoding Secp256k1 Signatures in CometBFT\nDESCRIPTION: For Secp256k1 signatures, the encoding is defined as r || s, where r and s are both exactly 32 bytes long, encoded in big-endian format. This is similar to Ethereum's encoding but without the leading recovery bit.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-015-crypto-encoding.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n#### Secp256k1\n\nThere isn't a clear canonical representation here.\nSignatures have two elements `r,s`.\nThese bytes are encoded as `r || s`, where `r` and `s` are both exactly\n32 bytes long, encoded big-endian.\nThis is basically Ethereum's encoding, but without the leading recovery bit.\n```\n\n----------------------------------------\n\nTITLE: Defining Signed Message Types in Go\nDESCRIPTION: Defines the SignedMsgType as a byte type for different message types in consensus, including Prevote, Precommit, and Proposal. This type is crucial for categorizing messages in the CometBFT network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n// SignedMsgType is a type of signed message in the consensus.\ntype SignedMsgType byte\n\nconst (\n // Votes\n PrevoteType   SignedMsgType = 0x01\n PrecommitType SignedMsgType = 0x02\n\n // Proposals\n ProposalType SignedMsgType = 0x20\n)\n```\n\n----------------------------------------\n\nTITLE: Isolating Misbehaving Validators in Go\nDESCRIPTION: The isolateMisbehavingProcesses function identifies validators who deviate from the Tendermint protocol. It checks for lunatic attacks, equivocation, and uses an accountability protocol for amnesia attacks. Dependencies include a Blockchain input and evidence data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc isolateMisbehavingProcesses(ev LightClientAttackEvidence, bc Blockchain) []ValidatorAddress {\n\n    reference := bc[ev.conflictingBlock.Header.Height].Header\n    ev_header := ev.conflictingBlock.Header\n\n    ref_commit := bc[ev.conflictingBlock.Header.Height + 1].Header.LastCommit // + 1 !!\n    ev_commit := ev.conflictingBlock.Commit\n\n    if violatesTMValidity(reference, ev_header) {\n        // lunatic light client attack\n        signatories := Signers(ev.ConflictingBlock.Commit)\n        bonded_vals := Addresses(bc[ev.CommonHeight].NextValidators)\n        return intersection(signatories,bonded_vals)\n    }\n    // If this point is reached the validator sets in reference and ev_header are identical\n    else if RoundOf(ref_commit) == RoundOf(ev_commit) {\n        // equivocation light client attack\n        return intersection(Signers(ref_commit), Signers(ev_commit))\n    }\n    else {\n        // amnesia light client attack\n        return IsolateAmnesiaAttacker(ev, bc)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Placeholder for Network Connectivity Invariant in Bluespec\nDESCRIPTION: A comment serving as a placeholder for a future invariant property. This property is intended to ensure that the graph represented by the `peers` state variable remains connected at all times, preventing network partitions (though the implementation is marked as TODO).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_16\n\nLANGUAGE: bluespec\nCODE:\n```\n// TODO: Invariant: all nodes in the network are always connected.\n```\n\n----------------------------------------\n\nTITLE: Define Auxiliary Functions for Mempool State\nDESCRIPTION: This snippet defines auxiliary functions to access various components of a node's mempool state for clarity and modularity within the code.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_8\n\nLANGUAGE: bluespec\nCODE:\n```\ndef Cache(node) = mempool.get(node).cache\ndef Txs(node) = mempool.get(node).txs\ndef TxsIndex(node) = mempool.get(node).txsIndex\n```\n\n----------------------------------------\n\nTITLE: Implementing DeliverTx with Events in Go\nDESCRIPTION: This Go code snippet demonstrates how to implement the DeliverTx function in an ABCI application, including the creation of events. It shows how events would be structured and returned in the ResponseDeliverTx.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-058-event-hashing.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *MyApp) DeliverTx(req types.RequestDeliverTx) types.ResponseDeliverTx {\n    //...\n    events := []abci.Event{\n        {\n            Type: \"transfer\",\n            Attributes: []abci.EventAttribute{\n                {Key: []byte(\"sender\"), Value: []byte(\"Bob\"), Index: true},\n            },\n        },\n    }\n    return types.ResponseDeliverTx{Code: code.CodeTypeOK, Events: events}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Certificate File for CometBFT RPC HTTPS (TOML)\nDESCRIPTION: Specifies the file path to the TLS certificate file used for enabling HTTPS on the RPC server. This requires the corresponding `rpc.tls_key_file` to also be set. If left empty, the server uses HTTP. The path can be absolute or relative to `$CMTHOME/config`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_30\n\nLANGUAGE: toml\nCODE:\n```\ntls_cert_file = \"\"\n```\n\n----------------------------------------\n\nTITLE: Gracefully Stopping a Peer - CometBFT Switch API - Go\nDESCRIPTION: StopPeerGracefully(peer Peer) lets a reactor instruct the Switch to disconnect a peer for non-error reasons, such as after successful address exchange in seed mode. The method takes a Peer as its single argument, returning nothing. It is mainly used by the PEX reactor and ensures all peer routines are stopped cleanly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) StopPeerGracefully(peer Peer)\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Request Body Size for CometBFT RPC (TOML)\nDESCRIPTION: Specifies the maximum permissible size, in bytes, for the body of an incoming RPC request. Requests with bodies larger than this limit will be rejected. The value must be an integer greater than or equal to 0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_28\n\nLANGUAGE: toml\nCODE:\n```\nmax_body_bytes = 1000000\n```\n\n----------------------------------------\n\nTITLE: Defining Controller State Structure in Go\nDESCRIPTION: Structure containing the state managed by the Controller, including current height, operation mode, peer statistics, pending requests, and downloaded blocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_15\n\nLANGUAGE: go\nCODE:\n```\ntype ControllerState struct {\n  Height             int64            // the first block that is not committed\n  Mode               Mode             // mode of operation\n  PeerMap            map[ID]PeerStats // map of peer IDs to peer statistics\n  MaxRequestPending  int64            // maximum height of the pending requests\n  FailedRequests     []int64          // list of failed block requests\n  PendingRequestsNum int              // total number of pending requests\n  Store              []BlockInfo      // contains list of downloaded blocks\n  Executor           BlockExecutor    // store, verify and executes blocks\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Block ID Structure in Protobuf\nDESCRIPTION: BlockID message definition containing block hash and part set header.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage BlockID {\n  bytes         hash            = 1;\n  PartSetHeader part_set_header = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Integral Value for Trust Metric in Tendermint\nDESCRIPTION: Formula for calculating the integral component of the trust value, where H[i] represents the history value at time interval i and b is the weight applied to the contribution of past performance.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n(2) Integral Value = b * H[i]\n```\n\n----------------------------------------\n\nTITLE: Practical Mempool Invariants in CometBFT (Math)\nDESCRIPTION: Modified mempool invariants for practical implementation in CometBFT. These adaptations consider performance constraints and introduce parameters for efficient operation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/mempool.md#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\n**INV2a.** \\forall tx. \\forall p \\in Correct. \\square(tx \\in p.lcommitted \\implies tx \\notin p.mempool)\n\n**INV3a.** \\forall tx. \\forall p \\in Correct. \\square(tx \\in p.hmempool \\implies p.valid[tx] \\in [1, \\beta])\n```\n\n----------------------------------------\n\nTITLE: JSON Schema for CometBFT Log Entries\nDESCRIPTION: Defines the structure of JSON log entries, including properties like log level, timestamp, message, module, and other metadata. This schema is used when log_format is set to 'json'.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://cometbft.com/log.schema.json\",\n  \"title\": \"JSON log\",\n  \"description\": \"A log entry in JSON object format\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"level\": {\n      \"description\": \"log level\",\n      \"type\": \"string\"\n    },\n    \"ts\": {\n      \"description\": \"timestamp in RFC3339Nano format; the trailing zeroes are removed from the seconds field\",\n      \"type\": \"string\"\n    },\n    \"_msg\": {\n      \"description\": \"core log message\",\n      \"type\": \"string\"\n    },\n    \"module\": {\n      \"description\": \"module name that emitted the log\",\n      \"type\": \"string\"\n    },\n    \"impl\": {\n      \"description\": \"some modules point out specific areas or tasks in log entries\",\n      \"type\": \"string\"\n    },\n    \"msg\": {\n      \"description\": \"some entries have more granular messages than just the core _msg\",\n      \"type\": \"string\"\n    },\n    \"height\": {\n      \"description\": \"some entries happen at a specific height\",\n      \"type\": \"integer\",\n      \"exclusiveMinimum\": 0\n    },\n    \"app_hash\": {\n      \"description\": \"some entries happen at a specific app_hash\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [ \"level\", \"ts\", \"_msg\", \"module\" ]\n}\n```\n\n----------------------------------------\n\nTITLE: SubscribeUnbuffered Function Signature in Go\nDESCRIPTION: Defines the signature for the SubscribeUnbuffered function, which uses an unbuffered channel for publishing. This function is not intended to be exposed to users.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nSubscribeUnbuffered(ctx context.Context, clientID string, query Query) (Subscription, error) {\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Data\nDESCRIPTION: cURL command to query the application state for a specific key.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"cometbft\"'\n```\n\n----------------------------------------\n\nTITLE: Referencing CometBFT Load Testing Tool\nDESCRIPTION: Link to the distributed load testing framework specifically designed for CometBFT networks. The tool enables performance testing and stress testing of CometBFT deployments.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/cometbft/cometbft-load-test\n```\n\n----------------------------------------\n\nTITLE: Defining Mempool Invariants in CometBFT (Math)\nDESCRIPTION: Mathematical formalization of mempool invariants in CometBFT. These invariants ensure the consistency and validity of transactions in the mempool, as well as their eventual processing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/mempool.md#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n**INV1.** \\forall tx. \\forall p \\in Correct. \\square(tx \\in p.submitted \\implies tx \\in p.hmempool)\n\n**INV2.** \\forall tx. \\forall p \\in Correct. \\square(tx \\in p.committed \\implies tx \\notin p.mempool)\n\n**INV3.** \\forall tx, \\forall p \\in Correct. \\square(tx \\in p.mempool \\implies p.ledger.valid(tx))\n\n**INV4** \\forall tx. \\forall p \\in Correct. \\square(tx \\in p.mempool \\implies \\lozenge\\square(tx \\in p.committed \\vee \\neg p.ledger.valid(tx)))\n```\n\n----------------------------------------\n\nTITLE: Defining Message Types in DOG Protocol in Quint\nDESCRIPTION: Definition of message types used in the DOG protocol, including transaction messages (TxMsg), notification of already received transactions (HaveTxMsg), and route reset requests (ResetRouteMsg).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_0\n\nLANGUAGE: bluespec\nCODE:\n```\ntype Message =\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n    | TxMsg(TX)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n    | HaveTxMsg(TxID)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\n    | ResetRouteMsg\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Encoding Points of Variability\nDESCRIPTION: Lists the main aspects of Protocol Buffer encoding that can lead to non-deterministic byte representation, including field ordering, repeated field handling, default values, and unknown field processing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-007-deterministic-proto-bytes.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Encoding order of fields within a message.\n2. Encoding order of elements of a repeated field.\n3. Presence or absence of default values.\n4. Serialization of 'unknown' fields.\n```\n\n----------------------------------------\n\nTITLE: Proposed CheckTx Method Signature in Golang\nDESCRIPTION: Shows the proposed new signature of the CheckTx method, removing the callback and txInfo parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-105-refactor-mempool-senders.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\nCheckTx(tx types.Tx) (abcicli.ReqRes, error)\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore LatestVerified Function Signature in Go\nDESCRIPTION: Specifies the signature for the `LatestVerified` method on the `LightStore`. This function is expected to return the `LightBlock` with the highest height that has the state `StateVerified`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) LatestVerified() LightBlock\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing Release Candidate Tag\nDESCRIPTION: Commands for creating a signed annotated git tag for a release candidate and pushing it to the remote repository. This is used after all changes have been merged to the backport branch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngit tag -a v2.0.0-rc1 -s -m \"Release Candidate v2.0.0-rc1\"\ngit push origin v2.0.0-rc1\n```\n\n----------------------------------------\n\nTITLE: Retrieving Validator Addresses - Tendermint - Go\nDESCRIPTION: Defines Addresses for extracting all validator addresses from an array of Validator objects. It is used to form address lists needed for bonded set intersection during identification of lunatic light client attacks. Inputs are arrays of Validator, outputting arrays of their corresponding addresses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc Addresses(vals Validator[]) ValidatorAddress[]\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Allowed Origins in TOML for CometBFT\nDESCRIPTION: Sets a list of origins from which cross-domain requests can be executed. Can be set to an empty array to disable CORS, ['*'] to allow any origin, or a specific list of domain origins.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\ncors_allowed_origins = []\n```\n\n----------------------------------------\n\nTITLE: Defining Skip Trace Verification (CMBC-SKIP-TRACE.1)\nDESCRIPTION: Defines the 'skip-trace(b,c,t)' property, which holds if there exists a sequence of light blocks (a 'verification trace') starting from 'b' and ending at 'c', where each consecutive pair satisfies the 'supports(a(i), a(i+1), t)' predicate at time 't'. This formalizes how a light client can verify block 'c' based on a trusted block 'b' without verifying every intermediate block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-SKIP-TRACE.1]\n\nLet *b* and *c* be light blocks. We define *skip-trace(b,c,t)* if at\ntime t there exists an integer *h* and a sequence *a(1)*, ... *a(h)* s.t.\n\n- *a(1) = b* and\n- *a(h) = c* and\n- *supports( a(i), a(i+1), t)*, for all i, *1 <= i < h*.\n\nWe call such a sequence *a(1)*, ... *a(h)* a **verification trace**.\n```\n\n----------------------------------------\n\nTITLE: Declaring Global Set of Node IDs Parameter in Bluespec\nDESCRIPTION: Declares a constant parameter `NodeIDs` representing the set of all possible node identifiers in the system. This includes nodes that might not be initially connected to the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_1\n\nLANGUAGE: bluespec\nCODE:\n```\nconst NodeIDs: Set[NodeID]\n```\n\n----------------------------------------\n\nTITLE: Peer Message Handling in Bluespec\nDESCRIPTION: Manages incoming messages from peers, determining how the receiving nodes handle these interactions. It uses non-deterministic node selection from the current network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_9\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nnode.receiveFromPeer(handleMessage),\n```\n\n----------------------------------------\n\nTITLE: Defining Event Types for Fast Sync Protocol in Go\nDESCRIPTION: Enumeration of event types that the Controller handles, representing significant occurrences in the network that require protocol action.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype Event int\nconst (\n  EventUnknown Event = iota\n  EventStatusReport\n  EventBlockRequest\n  EventBlockResponse\n  EventRemovePeer\n  EventTimeoutResponse\n  EventTimeoutTermination\n)\n```\n\n----------------------------------------\n\nTITLE: Scheduling the Next Light Block Verification Height - Go\nDESCRIPTION: Specifies the Go function signature for Schedule, which determines the next block height to verify for a light client, given the current LightStore, nextHeight, and targetHeight. The implementation is intentionally under-specified to allow optimization but must satisfy strict postconditions governing the relationship of returned height to the arguments. Inputs: lightStore, nextHeight, targetHeight; Output: Height for next verification attempt.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\nfunc Schedule(lightStore, nextHeight, targetHeight) Height\n```\n\n----------------------------------------\n\nTITLE: Setting Peer Key-Value Store Data in Go\nDESCRIPTION: This method sets data in the peer's key-value store, allowing reactors to share peer-specific state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) Set(key string, data interface{})\n```\n\n----------------------------------------\n\nTITLE: Configuring ABCI Response Discarding in CometBFT Storage\nDESCRIPTION: Controls whether ABCI responses are discarded from the state store to save disk space. When true, ABCI responses will be pruned, but this affects the availability of data for /block_results RPC queries.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_93\n\nLANGUAGE: toml\nCODE:\n```\ndiscard_abci_responses = false\n```\n\n----------------------------------------\n\nTITLE: Defining Peer Statistics Structure in Go\nDESCRIPTION: Structure that stores statistics for each peer, including its current height and any pending block requests sent to that peer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_16\n\nLANGUAGE: go\nCODE:\n```\ntype PeerStats struct {\n  Height             int64\n  PendingRequest     int64             // a request sent to this peer\n}\n```\n\n----------------------------------------\n\nTITLE: BlockPart Message Definition\nDESCRIPTION: Protobuf definition for BlockPart message type referenced in consensus protocol\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-027-p2p-message-bandwidth-report.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\n// Referenced at proto/tendermint/consensus/types.proto#L44\nmessage BlockPart {\n  // Implied from reference but not shown in snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameters for Mempool\nDESCRIPTION: This snippet defines a constant 'AllTxs', representing the set of all potential transactions that the mempool can handle.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_3\n\nLANGUAGE: bluespec\nCODE:\n```\nconst AllTxs: Set[TX]\n```\n\n----------------------------------------\n\nTITLE: Configuring Unconditional Peer IDs and Persistent Peers Max Dial Period in TOML\nDESCRIPTION: This snippet demonstrates the addition of two new parameters in the config.toml file: 'unconditional-peer-ids' for allowing specific peers to connect regardless of limits, and 'persistent-peers-max-dial-period' for setting a maximum interval between connection attempts to persistent peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-050-improved-trusted-peering.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nunconditional-peer-ids = [\"peer_id_1\", \"peer_id_2\", \"peer_id_3\"]\npersistent-peers-max-dial-period = \"1h\"\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Indexer with Custom Table Names\nDESCRIPTION: Example TOML configuration for using PostgreSQL as the indexer with customized table names for blocks, tx_results, events, and attributes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tx-index]\npsql-conn = \"your connection string\"\ntable_blocks = \"cometbft_blocks\"\ntable_tx_results = \"cometbft_tx_results\"\ntable_events = \"cometbft_events\"\ntable_attributes = \"cometbft_attributes\"\n```\n\n----------------------------------------\n\nTITLE: Calculating MessageDelay for Consensus Rounds in Go\nDESCRIPTION: This code snippet demonstrates how to calculate the MessageDelay value for a given consensus round. It implements the relaxation mechanism for the 'Timely' predicate, increasing the MessageDelay by 10% for each additional round.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-112-proposer-based-timestamps.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nMessageDelay(r) = MessageDelay * (1.1)^r\n```\n\n----------------------------------------\n\nTITLE: CometBFT Performance Test Results\nDESCRIPTION: Structured performance test results showing transaction latency statistics across different configurations. Tests vary by number of connections (1,2,4) and transaction rates (200,400,800,1600) with consistent 1024 byte transaction sizes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/img38/200nodes/v038_report_tabbed.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nExperiment ID: 93024f38-a008-443d-9aa7-9ac44c9fe15b  Experiment ID: d65a486e-4712-41b5-9f41-97e491895d2e  Experiment ID: 9c39184b-b8c7-46a2-bacb-40f9961fb7a1\n    Connections: 1                                       Connections: 2                                       Connections: 4\n    Rate: 200                                            Rate: 200                                            Rate: 200\n    Size: 1024                                           Size: 1024                                           Size: 1024\n    Total Valid Tx: 17800                                Total Valid Tx: 33259                                Total Valid Tx: 33259\n    Total Negative Latencies: 0                          Total Negative Latencies: 0                          Total Negative Latencies: 0\n    Minimum Latency: 562.805076ms                        Minimum Latency: 894.026089ms                        Minimum Latency: 2.166875257s\n    Maximum Latency: 7.623963559s                        Maximum Latency: 16.941216187s                       Maximum Latency: 15.701598288s\n    Average Latency: 1.860012628s                        Average Latency: 4.033134276s                        Average Latency: 7.592412668s\n    Standard Deviation: 1.169158915s                     Standard Deviation: 3.427243686s                     Standard Deviation: 2.951797195s\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Go\nDESCRIPTION: These commands set the GOPATH and update the PATH environment variable for Go development. They append the necessary export statements to the .bash_profile file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\necho export GOPATH=\\\"\\$HOME/go\\\" >> ~/.bash_profile\necho export PATH=\\\"\\$PATH:\\$GOPATH/bin\\\" >> ~/.bash_profile\n```\n\n----------------------------------------\n\nTITLE: Getting Type Information in Golang using Reflection\nDESCRIPTION: Helper function to determine the type name of an AEAD implementation using reflection. This supports the algorithm identification feature by creating a mapping from implementation type to algorithm name.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-013-symmetric-crypto.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\nfunc getType(myvar interface{}) string {\n    if t := reflect.TypeOf(myvar); t.Kind() == reflect.Ptr {\n        return \"*\" + t.Elem().Name()\n    } else {\n        return t.Name()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Events to Subscribers in Go\nDESCRIPTION: This code snippet illustrates the send operation in Tendermint's pubsub system. It shows how events are sent to individual subscribers, handling potential blocking and timeouts.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-005-event-system.rst#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n- `send operation <https://github.com/tendermint/tendermint/blob/main/libs/pubsub/pubsub.go#L489-L527>`_\n```\n\n----------------------------------------\n\nTITLE: Defining LightStore Structure in Go\nDESCRIPTION: The LightStore structure holds LightBlocks received from peers or during initialization. It serves as a repository for all LightBlock data necessary for validation and verification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype LightStore struct {\n        ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Light Store in Go\nDESCRIPTION: Function to update the state of a LightBlock in the LightStore. It sets the verified state and the height at which it was verified.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Update(lightBlock LightBlock, \n                            verfiedState VerifiedState\n       verifiedBy Height)\n```\n\n----------------------------------------\n\nTITLE: Handling Error-Level Logging in Go\nDESCRIPTION: Example of proper error-level logging that includes information about the error. This pattern ensures operators have the necessary details to troubleshoot issues.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nlogger.Error(\"Failed to execute important operation\", \"err\", err)\n```\n\n----------------------------------------\n\nTITLE: Configuration Options for Data Companion and Pruning Service\nDESCRIPTION: TOML configuration for the data companion pruning service, including settings for storage pruning, gRPC API endpoints, and privileged service access controls. Defines both normal and privileged gRPC connection settings.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[storage]\n\n#\n# Storage pruning configuration relating only to the data companion.\n#\n[storage.pruning.data_companion]\n\n# Whether automatic pruning respects values set by the data companion. Disabled\n# by default. All other parameters in this section are ignored when this is\n# disabled.\n#\n# If disabled, only the application retain height will influence block pruning\n# (but not block results pruning). Only enabling this at a later stage will\n# potentially mean that blocks below the application-set retain height at the\n# time will not be available to the data companion.\nenabled = false\n\n# The initial value for the data companion block retain height if the data\n# companion has not yet explicitly set one. If the data companion has already\n# set a block retain height, this is ignored.\ninitial_block_retain_height = 0\n\n# The initial value for the data companion block results retain height if the\n# data companion has not yet explicitly set one. If the data companion has\n# already set a block results retain height, this is ignored.\ninitial_block_results_retain_height = 0\n\n#\n# This is the envisaged configuration section for the gRPC API that will be\n# introduced as part of https://github.com/cometbft/cometbft/issues/81\n# (Still a WIP)\n#\n[grpc]\n\n# The host/port on which to expose non-privileged gRPC endpoints.\nladdr = \"tcp://localhost:26654\"\n\n#\n# Configuration for privileged gRPC endpoints, which should **never** be exposed\n# to the public internet.\n#\n[grpc.privileged]\n# The host/port on which to expose privileged gRPC endpoints.\nladdr = \"tcp://localhost:26655\"\n\n#\n# Configuration specifically for the gRPC pruning service, which is considered a\n# privileged service.\n#\n[grpc.privileged.pruning_service]\n\n# Only controls whether the pruning service is accessible via the gRPC API - not\n# whether a previously set pruning service retain height is honoured by the\n# node. That is controlled by settings in the [storage.pruning] section.\n#\n# Disabled by default.\nenabled = false\n```\n\n----------------------------------------\n\nTITLE: Canonical Proposal Validation in Go\nDESCRIPTION: Specifies the conditions under which a CanonicalProposal is valid for signing, including the message type, height, round, POL round, and complete BlockID.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\np.Type == 0x20\np.Height > 0\np.Round >= 0\np.POLRound >= -1\np.BlockID.IsComplete()\n```\n\n----------------------------------------\n\nTITLE: User-Initiated Transaction Handling in Bluespec\nDESCRIPTION: This snippet handles user-initiated transactions, where a node non-deterministically receives a transaction and attempts to add it to its mempool. It selects nodes and transactions from predefined sets.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_8\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nnondet tx = oneOf(AllTxs)\nnode.receiveTxFromUser(tx, tryAddTx),\n```\n\n----------------------------------------\n\nTITLE: Setting Genesis File Path in TOML for CometBFT\nDESCRIPTION: Specifies the path to the JSON file containing initial conditions for the CometBFT blockchain and application state. The path can be relative to $CMTHOME or an absolute path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\ngenesis_file = \"config/genesis.json\"\n```\n\n----------------------------------------\n\nTITLE: Defining Sequentially Rooted Blocks (CMBC-SEQ-ROOTED.1)\nDESCRIPTION: Defines the 'sequ-rooted(b)' property for a light block 'b'. It holds true if there exists a sequential chain of light blocks starting from 'Genesis' up to 'b', where each consecutive pair satisfies the 'signs' predicate. This ensures a block is part of the valid, historical chain.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-SEQ-ROOTED.1]\n\nLet *b* be a light block.\nWe define *sequ-rooted(b)* iff for all *i*, *1 <= i < h = b.Header.Height*,\nthere exist light blocks *a(i)* s.t.\n\n- *a(1) = Genesis* and\n- *a(h) = b* and\n- *signs( a(i) , a(i+1) )*.\n```\n\n----------------------------------------\n\nTITLE: Running ABCI-CLI Basic Commands\nDESCRIPTION: Basic ABCI-CLI commands for echo and info operations against a running ABCI application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/abci-cli.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nabci-cli echo hello\nabci-cli info\n```\n\n----------------------------------------\n\nTITLE: Defining BlockResultsService gRPC API for CometBFT in Protocol Buffers\nDESCRIPTION: This Protocol Buffers definition specifies the BlockResultsService gRPC interface for retrieving execution results associated with specific blocks. It maintains a separate service from BlockService to allow for independent configuration and optimize for different data access patterns.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\npackage tendermint.services.block_results.v1;\n\n// BlockResultsService provides information about the execution results for\n// specific blocks.\nservice BlockResultsService {\n    // GetByHeight attempts to retrieve the execution results associated with a\n    // block of a certain height.\n    rpc GetByHeight(GetByHeightRequest) returns (GetByHeightResponse) {}\n}\n\nmessage GetByHeightRequest {\n    // The height of the block whose results are to be retrieved. Set to 0 to\n    // return the latest block's results.\n    uint64 height = 1;\n}\n\nmessage GetByHeightResponse {\n    // The height associated with the block results.\n    uint64 height = 1;\n\n    // The contents of the FinalizeBlock response, which contain block execution\n    // results.\n    tendermint.abci.ResponseFinalizeBlock finalize_block_response = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Peer Removal Handler in Processor in Go\nDESCRIPTION: Defines the handleRemovePeer method that manages the cleanup when a peer is removed. It reschedules all unprocessed blocks that were received from the removed peer to ensure continued progress.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc (proc *Processor) handleRemovePeer(peerID) {\n\tevents = []\n\t// Delete all unprocessed blocks from peerID\n\tfor i = height; i < len(blocks); i++ {\n\t\tif blockPeers[i] == peerID {\n\t\t\tevents = append(events, pcBlockReschedule{height})\n\n\t\t\tdelete block[height]\n\t\t}\n\t}\n\treturn events\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Broadcast Method Functionality in CometBFT\nDESCRIPTION: This snippet explains the Broadcast method, which sends a message to all connected peers in parallel. It spawns a thread for each peer, calls their Send method, and returns a channel with the boolean results of these calls.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/implementation/switch.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Broadcast\n\nThis method broadcasts a message on a channel, by sending the message in\nparallel to all connected peers.\n\nThe method spawns a thread for each connected peer, invoking the `Send` method\nprovided by each `Peer` instance with the provided message and channel ID.\nThe return value (a boolean) of these calls are redirected to a channel that is\nreturned by the method.\n\n> TODO: detail where this method is invoked:\n>\n> - By the consensus protocol, in `broadcastNewRoundStepMessage`,\n>   `broadcastNewValidBlockMessage`, and `broadcastHasVoteMessage`\n> - By the state sync protocol\n```\n\n----------------------------------------\n\nTITLE: Handling Block Response Event in FastSync Controller\nDESCRIPTION: This function processes the block response event from a peer. It verifies the block, updates the state, and manages subsequent requests and timeouts.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_23\n\nLANGUAGE: go\nCODE:\n```\nfunc handleEventBlockResponse(event EventBlockResponse, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error)\n  if state.PeerMap[event.PeerID] {\n    peerStats = state.PeerMap[event.PeerID]\n    // when expected block arrives from a peer, it is added to the store so it can be verified and if correct executed after.\n    if peerStats.PendingRequest == event.Height {\n      peerStats.PendingRequest = -1\n      state.PendingRequestsNum--\n      if event.PeerHeight > peerStats.Height { peerStats.Height = event.PeerHeight }\n      state.Store[event.Height] = BlockInfo{ event.Block, event.Commit, event.PeerID }\n      // blocks are verified sequentially so adding a block to the store does not mean that it will be immediately verified\n      // as some of the previous blocks might be missing.\n      state = verifyBlocks(state) // it can lead to event.PeerID being removed from peer list\n      if _, ok := state.PeerMap[event.PeerID]; ok {\n        // we try to identify new request for a block that can be asked to the peer\n        msg = createBlockRequestMessage(state, event.PeerID, peerStats.Height)\n        if msg != nil {\n          peerStats.PendingRequests = msg.Height\n          state.PendingRequestsNum++\n          // if request for block is made, response timeout is triggered\n          timeout = ResponseTimeoutTrigger{ msg.PeerID, msg.Height, PeerTimeout }\n        } else if state.PeerMap.isEmpty() || state.PendingRequestsNum == 0 {\n          // if the peer map is empty (the peer can be removed as block verification failed) or there are no pending requests\n          // termination timeout is triggered.\n           timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }\n        }\n      }\n    } else { error = \"Received Block from wrong peer!\" }\n  } else { error = \"Received Block from unknown peer!\" }\n\n  state.PeerMap[event.PeerID] = peerStats\n  return state, msg, timeout, error\n}\n```\n\n----------------------------------------\n\nTITLE: Isolating Amnesia Attackers in Go\nDESCRIPTION: Function IsolateAmnesiaAttacker initiates a protocol to identify responsible parties during an amnesia attack, using the query/response protocol. Returns the validator addresses of attackers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc IsolateAmnesiaAttacker(ev LightClientAttackEvidence, bc Blockchain) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Visualizing Entity Relationships with Mermaid Diagram in CometBFT\nDESCRIPTION: This flowchart shows the relationship between CometBFT, an ABCI application, and the data companion service in the pull model. The diagram illustrates that CometBFT connects to the ABCI app as a client, while the data companion connects to CometBFT as a client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart RL\n    comet[CometBFT]\n    companion[Data Companion]\n    app[ABCI App]\n\n    comet --> app\n    companion --> comet\n```\n\n----------------------------------------\n\nTITLE: Defining Version struct for NodeInfo in Go\nDESCRIPTION: This code defines the Version struct for NodeInfo, including P2P, Block, and App versions. It also includes an 'Other' field for additional version information like software client and SemVer version.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-016-protocol-versions.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Version struct {\n    P2P uint64\n    Block uint64\n    App uint64\n\n    Other []string\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Header Backwards in Go\nDESCRIPTION: This function verifies a header by moving backwards from a trusted header to an untrusted header. It checks for decreasing height and time, and validates the hash chain between headers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc VerifyHeaderBackwards(trustedHeader Header,\n                           untrustedHeader Header,\n                           trustingPeriod Duration,\n                           clockDrift Duration) error {\n\n  if untrustedHeader.Height >= trustedHeader.Height return ErrErrNonDecreasingHeight\n  if untrustedHeader.Time >= trustedHeader.Time return ErrNonDecreasingTime\n\n  now := System.Time()\n  if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {\n    return ErrHeaderNotWithinTrustedPeriod\n  }\n\n  old := trustedHeader\n  for i := trustedHeader.Height - 1; i > untrustedHeader.Height; i-- {\n    untrustedSh, error := Commit(i)\n    if error != nil return ErrRequestFailed\n\n    if (hash(untrustedSh.Header) != old.LastBlockID.Hash) {\n      return ErrInvalidAdjacentHeaders\n    }\n\n    old := untrustedSh.Header\n  }\n\n  if hash(untrustedHeader) != old.LastBlockID.Hash {\n    return ErrInvalidAdjacentHeaders\n  }\n\n  now := System.Time()\n  if !isWithinTrustedPeriod(trustedHeader, trustingPeriod, now) {\n    return ErrHeaderNotWithinTrustedPeriod\n  }\n\n  return nil\n }\n```\n\n----------------------------------------\n\nTITLE: Redundancy Adjustment Loop in Bluespec\nDESCRIPTION: Periodically adjusts node redundancy, iterating over nodes and invoking 'adjustRedundancy'. While time constraints as pre-conditions are ideal, these are simplified here due to existing limitations in the Bluespec Quint environment.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_14\n\nLANGUAGE: bluespec\nCODE:\n```\nall {\n    nondet node = oneOf(nodesInNetwork)\n    node.adjustRedundancy(),\n    peers' = peers,\n    mempool' = mempool,\n    senders' = senders,\n    dr' = dr,\n},\n```\n\n----------------------------------------\n\nTITLE: Tracking Peer Failures - Go\nDESCRIPTION: This prototype Go snippet introduces a datastructure for tracking peer failures regarding transaction validity within the mempool. It leverages additional data maps to handle invalid cached transactions and peer failure counts over time.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\n\n// New datastructure to keep track of peer failures\ntype PeerFailure struct {\n  lastFailure time.Time\n  numFailures int8\n}\n\ntype LRUTxCache struct {\n// Keeping track of invalid transactions within the cache ;\n  invalidCachedTx map[types.TxKey]bool\n}\n\ntype CListMempool struct {\n // ..existing fields\n  peerFailureMap map[nodeID]*PeerFailure\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Block Events via cURL\nDESCRIPTION: Example cURL command to query a paginated set of blocks by their events using the /block_search RPC endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncurl \"localhost:26657/block_search?query=\\\"block.height > 10\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Getting Peer Quit Channel in Go\nDESCRIPTION: This method returns a channel that is closed when the peer is stopped, providing an asynchronous way to check peer status.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) Quit() <-chan struct{}\n```\n\n----------------------------------------\n\nTITLE: Defining Result Enum for ApplySnapshotChunk in Protobuf\nDESCRIPTION: This enum defines the possible results of applying a snapshot chunk in the ApplySnapshotChunk ABCI method. It includes options for accepting, aborting, retrying, and rejecting chunks or snapshots.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nenum Result {\n  UNKNOWN         = 0;  // Unknown result, abort all snapshot restoration\n  ACCEPT          = 1;  // The chunk was accepted.\n  ABORT           = 2;  // Abort snapshot restoration, and don't try any other snapshots.\n  RETRY           = 3;  // Reapply this chunk, combine with `RefetchChunks` and `RejectSenders` as appropriate.\n  RETRY_SNAPSHOT  = 4;  // Restart this snapshot from `OfferSnapshot`, reusing chunks unless instructed otherwise.\n  REJECT_SNAPSHOT = 5;  // Reject this snapshot, try a different one.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring logging levels in CometBFT\nDESCRIPTION: Sets the log level for CometBFT modules. Can specify different log levels for each module or use a single level for all modules. Supports debug, info, error, and none levels.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\nlog_level = \"info\"\n```\n\n----------------------------------------\n\nTITLE: Adjust Interval Configuration in Bluespec\nDESCRIPTION: Sets the 'adjustInterval' parameter, specifying the time between redundancy adjustments. The interval accounts for network latency to prevent over-adjustments, with suggested values starting from 1000ms. It ensures control messages propagate properly before the next adjustment.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_6\n\nLANGUAGE: bluespec\nCODE:\n```\nconst adjustInterval: int\n```\n\n----------------------------------------\n\nTITLE: Defining LightBlock Verification States in Go\nDESCRIPTION: Defines the `VerifiedState` type as an alias for `int` and enumerates the possible states a LightBlock can be in: `StateUnverified`, `StateVerified`, `StateFailed`, and `StateTrusted`. These constants are used throughout the LightStore to track the verification status of stored blocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype VerifiedState int\n\nconst (\n StateUnverified = iota + 1\n StateVerified\n StateFailed\n StateTrusted\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Block Request Event Structure in Go\nDESCRIPTION: Structure for block request events that are generated when a block request message is received, containing the requested height and the requesting peer's ID.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\ntype EventBlockRequest struct {\n  Height int64\n  PeerID p2p.ID\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing LCInitData in Go\nDESCRIPTION: The LCInitData structure is used to initialize the lightclient with a LightBlock or GenesisDoc. It forms the basis for starting the light client with the necessary blockchain data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype LCInitData struct {\n    lightBlock     LightBlock\n    genesisDoc     GenesisDoc\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CommitResponse in Go\nDESCRIPTION: Defines `CommitResponse`, a structure that retains blockchain data and determines block height retention. It requires Protobuf for compliance with serialization protocols. Inputs include data retention details that directly affect block commit operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/state.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ntype CommitResponse struct {\n\t// reserve 1\n\tData         []byte `protobuf:\"bytes,2,opt,name=data,proto3\" json:\"data,omitempty\"`\n\tRetainHeight int64  `protobuf:\"varint,3,opt,name=retain_height,json=retainHeight,proto3\" json:\"retain_height,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Changelog Entries in Markdown\nDESCRIPTION: This snippet demonstrates the correct format for changelog entries in the CometBFT project. It includes the module affected, a description of the change, the related issue or pull request number, and the contributor's name.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n- `[module]` Some description of the change\n  ([\\#1234](https://github.com/cometbft/cometbft/issues/1234): @contributor)\n```\n\n----------------------------------------\n\nTITLE: Creating Initial Go Project Structure\nDESCRIPTION: Sets up the initial project structure and creates a basic 'main.go' file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir kvstore\ncd kvstore\n```\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, CometBFT\")\n}\n```\n\n----------------------------------------\n\nTITLE: Generating ABCI Grammar Parser and Lexer in Bash\nDESCRIPTION: This command generates a new parser and lexer based on the ABCI grammar. It should be run from the test/e2e/ directory after modifying the grammar file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\nmake grammar-gen\n```\n\n----------------------------------------\n\nTITLE: Defining the Data Structure in CometBFT\nDESCRIPTION: Defines the `Data` structure in CometBFT, which serves as a wrapper for a list of transactions (`Txs`). Transactions are represented as arbitrary byte arrays (`[][]byte`), and CometBFT itself does not validate the content of these transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n| Name | Type                       | Description            | Validation                                                                  |\n|------|----------------------------|------------------------|-----------------------------------------------------------------------------|\n| Txs  | Matrix of bytes ([][]byte) | Slice of transactions. | Validation does not occur on this field, this data is unknown to CometBFT |\n```\n\n----------------------------------------\n\nTITLE: Setting Target Redundancy Parameters in Bluespec\nDESCRIPTION: Defines the 'TargetRedundancy' parameter, determining the target redundancy level that the controller should aim to maintain. Zero sets the controller to block 'HaveTx' messages without sending 'ResetRoute' messages, ideal for minimizing bandwidth but not suitable for Byzantine networks. A practical target value is between 0.5 and 1.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_4\n\nLANGUAGE: bluespec\nCODE:\n```\nconst TargetRedundancy: int\n```\n\n----------------------------------------\n\nTITLE: Running Load Tests on CometBFT Network\nDESCRIPTION: This make command runs load tests on the CometBFT network with specified parameters for connections, transaction rate, and total time. It's used to simulate network load during performance testing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nmake runload ITERATIONS=1 LOAD_CONNECTIONS=X LOAD_TX_RATE=Y LOAD_TOTAL_TIME=Z\n```\n\n----------------------------------------\n\nTITLE: Handling Peer Removal Event in FastSync Controller\nDESCRIPTION: This function handles the event of removing a peer from the FastSync process. It updates the state, manages pending requests, and triggers timeouts if necessary.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_22\n\nLANGUAGE: go\nCODE:\n```\nfunc handleEventRemovePeer(event EventRemovePeer, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error) {\n  if _, ok := state.PeerMap[event.PeerID]; ok {\n    pendingRequest = state.PeerMap[event.PeerID].PendingRequest\n    // if a peer is removed from the peer set, its pending request is declared failed and added to the `FailedRequests` list\n    // so it can be retried.\n    if pendingRequest != -1 {\n      add(state.FailedRequests, pendingRequest)\n    }\n    state.PendingRequestsNum--\n    delete(state.PeerMap, event.PeerID)\n    // if the peer set is empty after removal of this peer then termination timeout is triggered.\n    if state.PeerMap.isEmpty() {\n      timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }\n    }\n  } else { error = \"Removing unknown peer!\" }\n  return state, msg, timeout, error\n```\n\n----------------------------------------\n\nTITLE: Making JSON-RPC Request to RPC Companion Endpoint\nDESCRIPTION: Example of making the same JSON-RPC request to the RPC Companion endpoint to fetch a block at height 5 using curl.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-102-rpc-companion.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' http://rpc-companion.host:8080/v1\n```\n\n----------------------------------------\n\nTITLE: Setting Temporary Directory for State Sync in CometBFT (TOML)\nDESCRIPTION: Specifies the temporary directory for state sync snapshot chunks. This setting is unused by CometBFT and defaults to a random name in /tmp.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_78\n\nLANGUAGE: toml\nCODE:\n```\ntemp_dir = \"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Mempool Transaction Recheck\nDESCRIPTION: Setting to enable/disable validity check of transactions in mempool after block finalization.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_58\n\nLANGUAGE: toml\nCODE:\n```\nrecheck = true\n```\n\n----------------------------------------\n\nTITLE: Defining WeightedThresholdMultiSignaturePubKey struct in Golang\nDESCRIPTION: Implementation of a weighted threshold multisignature public key struct that supports assigning different weights to different signers. The signature is valid when the sum of weights from the signers reaches the threshold value.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-019-multisigs.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\ntype WeightedThresholdMultiSignaturePubKey struct {\n\tWeights []uint             `json:\"weights\"`\n\tThreshold uint             `json:\"threshold\"`\n\tPubkeys []crypto.Pubkey    `json:\"pubkeys\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Wait Time for Forward Lunatic Attack Detection in Go\nDESCRIPTION: This code snippet defines the formula for determining how long a light client should wait to detect a forward lunatic attack. It adds the maximum clock drift twice plus a lag period to ensure enough time for witnesses to provide the latest block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n2 * MAX_CLOCK_DRIFT + LAG\n```\n\n----------------------------------------\n\nTITLE: Commit Verification in Go\nDESCRIPTION: Code snippet showing how to verify that a trusted header's last commit hash matches the hash of the new commit being verified.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nheader[height].LastCommitHash == hash(commit[height-1])\n```\n\n----------------------------------------\n\nTITLE: Requesting Health Status via HTTP and JSON-RPC in Shell\nDESCRIPTION: Illustrates HTTP and JSON-RPC requests to check the node's health using curl command. No parameters are required.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/health\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"health\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Alternative CheckTx Response Handling in Go\nDESCRIPTION: Example showing how to wait for CheckTx response processing using the Wait method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\nreqRes, err := CheckTx(tx, sender)\n// check `err` here\nreqRes.Wait()\n```\n\n----------------------------------------\n\nTITLE: SynchronyParams JSON Structure in CometBFT\nDESCRIPTION: The JSON structure showing the synchrony parameters from the RPC response. It includes precision and message_delay values in nanoseconds, which in this example are 505ms and 12s respectively.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"precision\": \"505000000\",\n  \"message_delay\": \"12000000000\"\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore Latest Function Signature in Go\nDESCRIPTION: Specifies the signature for the `Latest` method on the `LightStore`. This function is expected to return the `LightBlock` with the highest height currently stored within the `LightStore`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Latest() LightBlock\n```\n\n----------------------------------------\n\nTITLE: Generating and Running Model Checking Experiments for Detection - Shell\nDESCRIPTION: This snippet demonstrates the command-line sequence to initiate and execute formal verification experiments for attack detection using an experiment CSV (e.g. 004bmc-apalache-ok.csv), followed by batch run execution. Required dependencies include the Apalache model checker, test scripts, and the CSV configuration; outputs include model check results and logs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$DIR/apalache-tests/scripts/mk-run.py --memlimit 28 004bmc-apalache-ok.csv $DIR/apalache . out\n./out/run-all.sh\n\n```\n\n----------------------------------------\n\nTITLE: PTBS Synchrony Parameters in Genesis File\nDESCRIPTION: New parameters for Proposer-Based Timestamps (PBTS) in the genesis file. These control precision and message delay for the PBTS feature.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n    \"synchrony\": {\n        \"precision\": \"505000000\",\n        \"message_delay\": \"15000000000\"\n    },\n```\n\n----------------------------------------\n\nTITLE: Configuring ABCI Connection Mechanism in TOML for CometBFT\nDESCRIPTION: Sets the mechanism used to connect to the ABCI application. Options include 'socket' and 'grpc'. This is used when connecting to the ABCI application over the proxy_app socket.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\nabci = \"socket\"\n```\n\n----------------------------------------\n\nTITLE: Defining ResponseFinalizeBlock Structure in Rust\nDESCRIPTION: Defines the response structure for the FinalizeBlock method, combining elements from the previous EndBlock and DeliverTx responses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nstruct ResponseFinalizeBlock {\n    updates: ResponseEndBlock,\n    tx_results: Vec<ResponseDeliverTx>\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Ed25519 Signatures in CometBFT\nDESCRIPTION: For Ed25519 signatures, the decision is to use the canonical representation. This approach ensures consistency and compatibility with the Ed25519 cryptosystem standards.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-015-crypto-encoding.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n#### Ed25519\n\nUse the canonical representation for signatures.\n```\n\n----------------------------------------\n\nTITLE: Defining Regex Pattern for Event Type and Attribute Key Validation in CometBFT\nDESCRIPTION: This regex pattern defines the allowed format for event types and attribute keys in CometBFT. It enforces that the string must start with a word character (letter or digit) and can contain dots, dashes, and underscores, but must not start with a dash or dot.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_8\n\nLANGUAGE: regex\nCODE:\n```\n^[\\w]+[\\.-\\w]?$\n```\n\n----------------------------------------\n\nTITLE: Version Management for Blockchain Consensus in Go\nDESCRIPTION: This snippet defines the `Version` struct which manages consensus and software version for the blockchain, crucial for ensuring protocol compatibility. Dependencies include links to `ConsensusParams` for protocol coordination. Inputs involve blockchain version details that influence node operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/state.md#2025-04-22_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ntype Version struct {\n  consensus Consensus\n  software string\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Secp256k1 Public Key Byte Layout - Markdown\nDESCRIPTION: Illustrates the structure of a secp256k1 public key in hexadecimal, showing the prefix byte and the x-coordinate field elements. This is intended for reference and explaining the cryptographic compression format used by secp256k1. Inputs: None. Outputs: Visual layout, not functional code. No dependencies.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_3\n\nLANGUAGE: md\nCODE:\n```\n02_4788db786c8825d54dfdbe93e8462408ffb6e5d19703511c8fc8bf60af8f72d0\n   4788db786c8825d54dfdbe93e8462408ffb6e5d19703511c8fc8bf60af8f72d0_c47efb012b928018e99e892cfbfa7e8535de85169682346d66676e47da261498\n```\n\n----------------------------------------\n\nTITLE: Defining ResultC Enum for UnpackSnapshot Response in Protocol Buffers\nDESCRIPTION: Protocol Buffer definition for the ResultC enum used in the UnpackSnapshot ABCI call response. It defines possible outcomes when applying snapshot chunks during local state sync operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-104-out-of-band-state-sync.md#2025-04-22_snippet_4\n\nLANGUAGE: proto\nCODE:\n```\n  enum ResultC {\n    UNKNOWN         = 0;  // Unknown result, abort all snapshot restoration\n    ACCEPT          = 1;  // The chunks were accepted.\n    ABORT           = 2;  // Abort snapshot restoration, and don't try any other snapshots.\n    RETRY_SNAPSHOT  = 3;  // Restart this snapshot from `OfferSnapshot`, reusing chunks unless instructed otherwise.\n    REJECT_SNAPSHOT = 4;  // Reject this snapshot, try a different one.\n  }\n```\n\n----------------------------------------\n\nTITLE: Validator Set Change Transaction Format in CometBFT KVStore\nDESCRIPTION: This snippet shows the format used to effect validator set changes in the KVStoreApplication. The transaction specifies validator public keys, their types, and voting power values. Setting a validator's power to 0 removes them from the set.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/abci/example/kvstore/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n\"val:pubkeytype1!pubkey1!power1,pubkeytype2!pubkey2!power2,pubkeytype3!pubkey3!power3\"\n```\n\n----------------------------------------\n\nTITLE: Defining Evidence List Structure in Protobuf\nDESCRIPTION: EvidenceList message definition for storing block evidence records.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage EvidenceList {\n  repeated Evidence evidence = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for BroadcastTxAsync in CometBFT\nDESCRIPTION: HTTP request example for the broadcast_tx_async endpoint that returns immediately without waiting for CheckTx or DeliverTx results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_34\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/broadcast_tx_async?tx=encoded_tx\n```\n\n----------------------------------------\n\nTITLE: Requesting Unconfirmed Transaction Count in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving the count of unconfirmed transactions. This endpoint provides a summary of mempool transactions without returning the actual transaction data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_27\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/num_unconfirmed_txs\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"num_unconfirmed_txs\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Chain Consensus State Query Interface in Go\nDESCRIPTION: This code defines the function interface for querying consensus state by block height in a handler. Using Go-like syntax, the function, queryChainConsensusState, takes a 64-bit unsigned integer representing the desired block height and returns the corresponding ConsensusState object. Required dependencies include the ConsensusState data structure and the ability to index consensus states by height. The interface is critical for relayers or external systems to read the current or past state of consensus as seen by the handler; implementations should ensure proper bounds and data availability.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/req-ibc-detection.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype queryChainConsensusState = (height: uint64) => ConsensusState\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for BroadcastTxSync in CometBFT\nDESCRIPTION: JSON-RPC request example for the broadcast_tx_sync method that returns after CheckTx is executed but before DeliverTx.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_32\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"broadcast_tx_sync\\\",\\\"params\\\":{\\\"tx\\\":\\\"a/encoded_tx/c\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Indexer in CometBFT using TOML\nDESCRIPTION: Specifies the indexer type to use for transactions. Options include 'kv' for a simple key-value store, 'null' to disable indexing, and 'psql' for PostgreSQL-backed indexing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_101\n\nLANGUAGE: toml\nCODE:\n```\nindexer = \"kv\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Process Proposal Phase in Rust\nDESCRIPTION: Introduces three new ABCI methods for the Process Proposal phase, enabling validators to verify headers, process block proposals, and revert proposals if necessary.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn VerifyHeader(header: Header, isValidator: bool) -> ResponseVerifyHeader {...}\nfn ProcessProposal(block: Block) -> ResponseProcessProposal {...}\nfn RevertProposal(height: usize, round: usize) {...}\n```\n\n----------------------------------------\n\nTITLE: Implementing Peer Banning in CListMempool - Go\nDESCRIPTION: This Go code snippet shows the implementation of a peer banning feature in the CListMempool component, which handles transactions that fail the CheckTx validation. Dependencies include the abci package for CheckTx codes and the internal mempool configuration. The inputs involve transaction data and peer IDs, while outputs include updated metrics and potential changes to the cache.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n\nif (r.CheckTx.Code == abci.CodeTypeOK) && postCheckErr == nil {\n    // Check Tx passed\n} else {\n// ignore bad transaction\n    mem.logger.Debug(\n      \"rejected bad transaction\",\n      \"tx\", types.Tx(tx).Hash(),\n      \"peerID\", peerP2PID,\n      \"res\", r,\n      \"err\", postCheckErr,\n    )\n    mem.metrics.FailedTxs.Add(1)\n\n    mem.banPeer(peerP2PID)\n\n    if !mem.config.KeepInvalidTxsInCache {\n      // remove from cache (it might be good later)\n      mem.cache.Remove(tx)\n    } else {\n      // If transactins stay in the cache, remember they failed\n      mem.cache.invalidCachedTx.Store(tx.Key(), true)\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Quint Module Aggregation for Flood Protocol - Bluespec\nDESCRIPTION: Shows a code fragment from the generated Quint file, organizing the import, export, and modular structure for the Flood protocol. Actual logic is included via code tangling macros that assemble the previously defined message, state, actions, and property segments. This snippet is typically auto-generated and not directly edited by hand.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_8\n\nLANGUAGE: bluespec\nCODE:\n```\n// -*- mode: Bluespec; -*-\n\n// File generated from markdown using https://github.com/driusan/lmt. DO NOT EDIT.\n\nmodule flood {\n    import spells.* from \"./spells\"\n    import mempool.* from \"./mempool\"\n    export mempool.*\n\n    //--------------------------------------------------------------------------\n    // Messages\n    //--------------------------------------------------------------------------\n    <<<messages>>>\n\n    //--------------------------------------------------------------------------\n    // State\n    //--------------------------------------------------------------------------\n    <<<state>>>\n    \n    // Auxiliary definitions\n    <<<auxstate>>>\n\n    //--------------------------------------------------------------------------\n    // Actions\n    //--------------------------------------------------------------------------\n    <<<actions>>>\n\n    action step = any {\n        <<<steps>>>\n    }\n\n    //--------------------------------------------------------------------------\n    // Properties\n    //--------------------------------------------------------------------------\n    <<<properties>>>\n\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing CometBFT Configuration Differences\nDESCRIPTION: Command to show differences between current configuration file and default configuration for a specific version.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/confix/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncometbft config diff v0.38 # gets the diff between defaultHome/config/config.toml and the latest v0.38 config\n```\n\n----------------------------------------\n\nTITLE: Setting Node Key File Path in TOML for CometBFT\nDESCRIPTION: Specifies the path to the JSON file containing the private key for node authentication in the p2p protocol. The path can be relative to $CMTHOME or an absolute path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\nnode_key_file = \"config/node_key.json\"\n```\n\n----------------------------------------\n\nTITLE: Quint Module Template for P2P Specification in Bluespec\nDESCRIPTION: Defines a Quint module template named `p2p`, intended to structure the complete P2P specification. It imports definitions from `./spells` and uses placeholders (e.g., `<<<types>>>`, `<<<params>>>`) which are meant to be substituted with the corresponding Bluespec code snippets defined earlier, likely via a pre-processing tool like `lmt`. This creates a consolidated module file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_17\n\nLANGUAGE: bluespec\nCODE:\n```\n// -*- mode: Bluespec; -*-\n\n// File generated from markdown using https://github.com/driusan/lmt. DO NOT EDIT.\n\nmodule p2p {\n    import spells.* from \"./spells\"\n\n    //--------------------------------------------------------------------------\n    // Types\n    //--------------------------------------------------------------------------\n    <<<types>>>\n    \n    //--------------------------------------------------------------------------\n    // Parameters\n    //--------------------------------------------------------------------------\n    <<<params>>>\n\n    //--------------------------------------------------------------------------\n    // State\n    //--------------------------------------------------------------------------\n    <<<state>>>\n    \n    // Auxiliary definitions\n    <<<auxstate>>>\n\n    //--------------------------------------------------------------------------\n    // Actions\n    //--------------------------------------------------------------------------\n    <<<actions>>>\n    \n    //--------------------------------------------------------------------------\n    // Properties\n    //--------------------------------------------------------------------------\n    <<<properties>>>\n\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ErrorBehaviourPeer Type in Go\nDESCRIPTION: This snippet introduces a concrete ErrorBehaviourPeer type to represent specific error behaviors of peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-039-peer-behaviour.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype ErrorBehaviourPeer int\n\nconst (\n    ErrorBehaviourUnknown = iota\n    ErrorBehaviourBadMessage\n    ErrorBehaviourMessageOutofOrder\n    ...\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Block Retain Height in CometBFT\nDESCRIPTION: Go code example demonstrating how to set the block retain height using the privileged gRPC client in CometBFT. This controls up to which block height data should be preserved.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"github.com/cometbft/cometbft/rpc/grpc/client/privileged\"\n)\n\nctx := context.Background()\n\n// Privileged Service Client\naddr := \"0.0.0.0:26091\"\nconn, err := privileged.New(ctx, addr, privileged.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nerr := conn.SetBlockRetainHeight(ctx, height)\nif err != nil {\n    // Do something with the error\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Fatal Errors in Go\nDESCRIPTION: This function determines if an error is considered fatal in the context of light client verification. It checks for specific error types that indicate serious issues with the verification process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc fatalError(err) bool {\n    return err == ErrHeaderNotWithinTrustedPeriod OR\n           err == ErrInvalidAdjacentHeaders OR\n           err == ErrNonIncreasingHeight OR\n           err == ErrNonIncreasingTime OR\n           err == ErrInvalidValidatorSet OR\n           err == ErrInvalidNextValidatorSet OR\n           err == ErrInvalidCommitValue OR\n           err == ErrInvalidCommit\n}\n```\n\n----------------------------------------\n\nTITLE: Unconfirmed Transaction Count Response Format in CometBFT API\nDESCRIPTION: Example response structure for the num_unconfirmed_txs endpoint showing the count of transactions in the mempool, total count, and total size in bytes. Provides a quick overview of mempool state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_28\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"n_txs\": \"31\",\n    \"total\": \"82\",\n    \"total_bytes\": \"19974\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Go Profiling Listener Address for CometBFT RPC (TOML)\nDESCRIPTION: Sets the listen address (IP:port or just :port format, e.g., \":6060\") for the Go `pprof` HTTP endpoint, used for performance profiling. If this value is an empty string, the profiling endpoint is disabled. HTTP protocol is always assumed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_32\n\nLANGUAGE: toml\nCODE:\n```\npprof_laddr = \"\"\n```\n\n----------------------------------------\n\nTITLE: Auxiliary Getters and Update Functions for Senders Mapping - Bluespec\nDESCRIPTION: Defines helper functions for accessing and updating the senders of transactions. This includes retrieving the sender list for a node, obtaining the sender list for a specific transaction, and updating a transaction's sender list conditionally. Dependencies include the senders state and assumptions about the existence of NodeID, TxID, and hash functions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/flood.md#2025-04-22_snippet_2\n\nLANGUAGE: bluespec\nCODE:\n```\ndef Senders(node) = senders.get(node)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\ndef sendersOf(node, txID) = \n    node.Senders().mapGetDefault(txID, List())\n```\n\nLANGUAGE: bluespec\nCODE:\n```\npure def addSender(_txSenders, tx, optionalSender) = \n    match optionalSender {\n    | Some(sender) => _txSenders.update(hash(tx), ss => \n        if (ss.includes(sender)) ss else ss.append(sender))\n    | None => _txSenders\n    }\n```\n\n----------------------------------------\n\nTITLE: Function makeblock in Go\nDESCRIPTION: The makeblock function generates a LightBlock from a given GenesisDoc for verification purposes. It ensures key LightBlock parameters align with the genesis settings.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc makeblock (genesisDoc GenesisDoc) (lightBlock LightBlock))\n```\n\n----------------------------------------\n\nTITLE: Examples of Poor Logging Practices in Go\nDESCRIPTION: Examples of anti-patterns in logging that should be avoided, including lowercase message starts, excessive data dumping, and inefficient string formatting that impacts performance.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n// Message starts with a lowercase letter, and will probably be called very\n// frequently, effectively spamming operators.\nlogger.Info(\"connected to peer\", \"peerID\", peerID)\n\n// Potentially prints huge quantities of data (unnecessary) in a single message,\n// and at info level, spamming operators.\nlogger.Info(\"Committed block\", \"block\", fmt.Sprintf(\"%v\", block))\n\n// Just as bad as the info-level message above because the (expensive)\n// fmt.Sprintf is always called, regardless of the operator's configured log\n// level, potentially creating a meaningful performance hit.\nlogger.Debug(\"Committed block\", \"block\", fmt.Sprintf(\"%v\", block))\n```\n\n----------------------------------------\n\nTITLE: Implementing Blockchain Reactor Stop Method in Go\nDESCRIPTION: Defines the Stop method for the BlockchainReactor which sends a stop message to the main message channel, signaling all goroutines to terminate.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *BlockchainReactor) Stop() {\n\t...\n\tr.msgs <- stop\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Apalache Verification Check with 10 Steps\nDESCRIPTION: Example command to run Apalache verification check for 10 steps using MC_PBT_2C_2F.tla model with false majority condition.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/tla/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./runApalache.sh check 10 false\n```\n\n----------------------------------------\n\nTITLE: Example Event Structure in JSON\nDESCRIPTION: Demonstrates the JSON structure of an event with a composite key constructed by type and key separated by a dot.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"jack\": [\n  \"account.number\": 100\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring ABCI Response Storage in CometBFT\nDESCRIPTION: Configuration for controlling whether ABCI responses are stored or discarded in CometBFT. This setting affects whether block results pruning will be effective, as block results can only be pruned if they are stored.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n#######################################################\n###         Storage Configuration Options           ###\n#######################################################\n[storage]\n\n# Set to true to discard ABCI responses from the state store, which can save a\n# considerable amount of disk space. Set to false to ensure ABCI responses are\n# persisted. ABCI responses are required for /block_results RPC queries, and to\n# reindex events in the command-line tool.\ndiscard_abci_responses = false\n```\n\n----------------------------------------\n\nTITLE: Defining Block Commit Structure in Protobuf\nDESCRIPTION: Commit message definition containing block height, round, ID and validator signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Commit {\n  int64              height     = 1;\n  int32              round      = 2;\n  BlockID            block_id   = 3;\n  repeated CommitSig signatures = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Submitting Proof of Fork from Relayer to IBC Component - Go\nDESCRIPTION: Implements the main relayer routine for submitting a proof of fork (PoF) to the IBC component. The function checks whether the IBC component already knows the trusted root from the PoF; if so, it submits directly, otherwise it computes a new PoF compatible with the IBC's store using `commonRoot` and `extendPoF`. Key parameters are the relayer light store, PoF object, and the IBC component. Dependencies are the relayer's and IBC's consensus store logic and trusted state querying. Returns status or error, managing possible mismatches in knowledge between relayer and chain state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc SubmitIBCProofOfFork(\n  lightStore LightStore,\n  PoF: LightNodeProofOfFork,\n  ibc IBCComponent) (Error) {\n    if ibc.queryChainConsensusState(PoF.TrustedBlock.Height) = PoF.TrustedBlock {\n  // IBC component has root of PoF on store, we can just submit\n        ibc.submitMisbehaviorToClient(ibc.id,PoF)\n  return Success\n     // note sure about the id parameter\n    }\n    else {\n        // the ibc component does not have the TrustedBlock and might\n  // even be on yet a different branch. We have to compute a PoF\n  // that the ibc component can verify based on its current\n        // knowledge\n\n        ibcLightBlock, lblock, _, result := commonRoot(lightStore, ibc, PoF.TrustedBlock)\n\n     if result = Success {\n   newPoF = extendPoF(ibcLightBlock, lblock, lightStore, PoF)\n      ibc.submitMisbehaviorToClient(ibc.id, newPoF)\n      return Success\n     }\n  else{\n   return CouldNotGeneratePoF\n     }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for ABCIInfo in CometBFT\nDESCRIPTION: HTTP request example for the abci_info endpoint that retrieves information about the application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_40\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/abci_info\n```\n\n----------------------------------------\n\nTITLE: Initializing CometBFT Node\nDESCRIPTION: Creates the required files for a single, local CometBFT node in the $HOME/.cometbft directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/quick-start.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncometbft init\n```\n\n----------------------------------------\n\nTITLE: Transaction Dissemination in Bluespec\nDESCRIPTION: Describes how a node disseminates transactions to its peers. Involves generating a target list of nodes and dispatching transaction messages while tracking senders and redundancy status.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_10\n\nLANGUAGE: bluespec\nCODE:\n```\nnondet node = oneOf(nodesInNetwork)\nall {\n    node.disseminateNextTx(mkTargetNodes, TxMsg),\n    senders' = senders,\n    dr' = dr,\n    rc' = rc,\n},\n```\n\n----------------------------------------\n\nTITLE: Adding Synchrony Parameters to ConsensusParams in Go\nDESCRIPTION: Updates the ConsensusParams struct to include a new SynchronyParams field, which contains the PRECISION and MSGDELAY parameters for proposer-based timestamps.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-071-proposer-based-timestamps.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype ConsensusParams struct {\n\tBlock     BlockParams     `json:\"block\"`\n\tEvidence  EvidenceParams  `json:\"evidence\"`\n\tValidator ValidatorParams `json:\"validator\"`\n\tVersion   VersionParams   `json:\"version\"`\n\tSynchrony SynchronyParams `json:\"synchrony\"`\n}\n\ntype SynchronyParams struct {\n\tMessageDelay time.Duration `json:\"message_delay\"`\n\tPrecision    time.Duration `json:\"precision\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1 - Blockchain Vote Extensions\nDESCRIPTION: Suggests including vote extensions and signatures directly in the blockchain, requiring a hard fork but ensuring complete information availability.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-100-abci-vote-extension-propag.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n**Solution 1.** *Include vote extensions in the blockchain*.\n```\n\n----------------------------------------\n\nTITLE: Analyzing Transaction Latency with `report` (Bash)\nDESCRIPTION: This command executes the `report` tool to analyze transaction latency from a CometBFT blockstore. It specifies the database type as `pebbledb` (`--database-type pebbledb`) and the location of the CometBFT data directory (`--data-dir ~/.cometbft/data`). The tool reads blocks, extracts timestamps from transactions generated by the `load` tool, compares them with block timestamps to calculate latencies, and outputs metrics like min, max, average latency, and standard deviation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/loadtime/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./build/report --database-type pebbledb --data-dir ~/.cometbft/data\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Inbound Peers in CometBFT (TOML)\nDESCRIPTION: Sets the maximum number of inbound peer connections. Inbound connections are initiated by remote nodes. This setting works with max_num_outbound_peers to define the total P2P connections maintained.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_46\n\nLANGUAGE: toml\nCODE:\n```\nmax_num_inbound_peers = 40\n```\n\n----------------------------------------\n\nTITLE: Setting Configuration Values with CometBFT CLI\nDESCRIPTION: Commands to set configuration values in CometBFT using the set command. Shows how to set both numeric values (mempool.size) and string values (moniker) in the configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/confix/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncometbft config set mempool.size 1000 # sets the value mempool.size\ncometbft config set moniker \"foo-1\" # sets the value moniker\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Buffer Capacity in CometBFT\nDESCRIPTION: The default configuration for the event system uses an unbuffered channel for event publishes. This could lead to blocking or slowdowns depending on contention in the event system.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-003-performance-questions.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nevent-buffer-capacity: https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/types/event_bus.go#L14\n```\n\n----------------------------------------\n\nTITLE: Querying Consensus State Heights in IBC Component - Go\nDESCRIPTION: Provides a suggestion for a function to query a range of consensus state heights present in the IBC component, returning all available heights within a specified range. This allows relayers or clients to synchronize or check for gaps/overlaps in their knowledge of consensus states. Key parameters include client identifier and height bounds. Intended for late-joining relayers or for maintaining synchronized state views. Dependent on IBC state queries.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/draft-functions.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc QueryHeightsRange(id, from, to) ([]Height)\n\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore store_chain Function Signature in Go\nDESCRIPTION: Specifies the signature for the `store_chain` method on the `LightStore`. This function takes another `LightStore` instance (`newLS`) as input and adds its contents to the receiver light store (`ls`).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) store_chain(newLS LightStore)\n```\n\n----------------------------------------\n\nTITLE: Defining Block Support Predicate (CMBC-FUNC-SUPPORT.1)\nDESCRIPTION: Defines the 'supports(b,c,t)' predicate used for skipping verification. It holds true if block 'b' is recent enough (within the trusting period relative to time 't') and if block 'c' contains commit signatures from over 1/3 of the validators defined in block 'b'. This implies trust in block 'c' based on 'b', assuming at least one correct validator signed 'c'.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-FUNC-SUPPORT.1]\n\nLet *b* and *c* be two light blocks. We define the predicate\n**supports(b,c,t)** to hold iff\n\n- *t - trustingPeriod < b.Header.Time < t*\n- the voting power in *b.NextValidators* of nodes in *c.Commit*\n  is more than 1/3 of *TotalVotingPower(b.Header.NextValidators)*\n```\n\n----------------------------------------\n\nTITLE: ABCI Consensus Grammar Definition in ABNF\nDESCRIPTION: Grammar specification showing the possible sequences of consensus rounds and proposal handling in CometBFT. Defines the structure for proposer and non-proposer behaviors in consensus rounds.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_example_scenarios.md#2025-04-22_snippet_0\n\nLANGUAGE: abnf\nCODE:\n```\nconsensus-height    = *consensus-round finalize-block commit\nconsensus-round     = proposer / non-proposer\n\nproposer            = [prepare-proposal process-proposal]\nnon-proposer        = [process-proposal]\n```\n\n----------------------------------------\n\nTITLE: Tracking Last Signed State in Go\nDESCRIPTION: Defines a struct LastSigned to track the last message signed's height, round, and type. Facilitates preventing double signing by maintaining recent state information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\ntype LastSigned struct {\n Height int64\n Round int64\n Type SignedMsgType // byte\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Commit Data from CometBFT Node in Bash\nDESCRIPTION: This snippet demonstrates how to query a CometBFT full node for commit data, extracting the height and hash using curl and jq. It's used to obtain semi-trusted hash and height information from multiple nodes for comparison.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/light-client.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -s https://233.123.0.140:26657/commit | jq \"{height: .result.signed_header.header.height, hash: .result.signed_header.commit.block_id.hash}\"\n```\n\n----------------------------------------\n\nTITLE: Checking Go Version\nDESCRIPTION: Verifies the installed version of Go using the 'go version' command.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go version\ngo version go1.23.6 darwin/amd64\n```\n\n----------------------------------------\n\nTITLE: Adaptive Message Delay\nDESCRIPTION: Defines an adaptive message delay parameter that increases with consensus rounds to handle potential misconfiguration of the initial MSGDELAY value.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-sysmodel.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n**[PBTS-MSG-DELAY-ADAPTIVE.0]**\n\nThe adaptive system parameter `MSGDELAY(r)` is defined as follows.\nLets `p` and `q` be any correct processes:\n\n- If `p` sends a proposal message `m` from round `r` at real time `t` and `q` receives `m` at\n  real time `t'`, then `t < t' <= t + MSGDELAY(r)`.\n```\n\n----------------------------------------\n\nTITLE: InitChain Response Type Reference - Golang\nDESCRIPTION: Reference to the InitChain response object containing ConsensusParameter update fields\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-009-consensus-parameter-upgrades.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nabci/types/types.pb.go#L1616\n```\n\n----------------------------------------\n\nTITLE: Solution 2 - Skip Propose Step\nDESCRIPTION: Describes modifying the Tendermint algorithm to skip proposal steps when vote extensions are unavailable, with potential vulnerability to byzantine attacks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-100-abci-vote-extension-propag.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n**Solution 2.** *Skip* propose *step in Tendermint algorithm*.\n```\n\n----------------------------------------\n\nTITLE: Implementing Scheduler Event Handlers in Go\nDESCRIPTION: This snippet defines the event handlers for the scheduler, including functions to handle status responses, block responses, peer errors, and time checks. These functions manage peer interactions and block scheduling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc handleStatusResponse(peerID, height, time) {\n\tschedule.touchPeer(peerID, time)\n\tschedule.setPeerHeight(peerID, height)\n}\n\nfunc handleBlockResponseMessage(peerID, height, block, time) {\n\tschedule.touchPeer(peerID, time)\n\tschedule.markReceived(peerID, height, size(block))\n}\n\nfunc handleNoBlockResponseMessage(peerID, height, time) {\n\tschedule.touchPeer(peerID, time)\n\t// reschedule that block, punish peer...\n    ...\n}\n\nfunc handlePeerError(peerID)  {\n    // Remove the peer, reschedule the requests\n    ...\n}\n\nfunc handleTimeCheckEv(time) {\n\t// clean peer list\n\n    events = []\n\tfor peerID := range schedule.peersNotTouchedSince(time) {\n\t\tpending = schedule.pendingFrom(peerID)\n\t\tschedule.setPeerState(peerID, timedout)\n\t\tschedule.resetBlocks(pending)\n\t\tevents = append(events, peerTimeout{peerID})\n    }\n\n\tevents = append(events, schedule.popSchedule())\n\n\treturn events\n}\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for ABCIInfo in CometBFT\nDESCRIPTION: JSON-RPC request example for the abci_info method that retrieves information about the application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_41\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"abci_info\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Defining ProposalStatus Enumeration in Protocol Buffers\nDESCRIPTION: Defines an enumeration for ProposalStatus used in ProcessProposal responses. It includes UNKNOWN (error state), ACCEPT (valid proposal), and REJECT (invalid proposal) statuses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_11\n\nLANGUAGE: protobuf\nCODE:\n```\nenum ProposalStatus {\n  UNKNOWN = 0; // Unknown status. Returning this from the application is always an error.\n  ACCEPT  = 1; // Status that signals that the application finds the proposal valid.\n  REJECT  = 2; // Status that signals that the application finds the proposal invalid.\n}\n```\n\n----------------------------------------\n\nTITLE: Running and Handling an EchoReactor using Channels - Go\nDESCRIPTION: Shows how to run an echo reactor by wiring a communication channel and subscribing to peer updates. Periodically broadcasts PingMessage to all peers, replies to incoming messages with PongMessage or error, and prints peer status changes. Requires the CometBFT P2P library, correct initialization of p2p.Router, p2p.PeerManager, and relies on Go's concurrency primitives (channels, ticker, context) for operation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\n// RunEchoReactor wires up an echo reactor to a router and runs it.\\nfunc RunEchoReactor(router *p2p.Router, peerManager *p2p.PeerManager) error {\\n    channel, err := router.OpenChannel(1, &EchoMessage{})\\n    if err != nil {\\n        return err\\n    }\\n    defer channel.Close()\\n    peerUpdates := peerManager.Subscribe()\\n    defer peerUpdates.Close()\\n\\n    return EchoReactor(context.Background(), channel, peerUpdates)\\n}\\n\\n// EchoReactor provides an echo service, pinging all known peers until the given\\n// context is canceled.\\nfunc EchoReactor(ctx context.Context, channel *p2p.Channel, peerUpdates *p2p.PeerUpdates) error {\\n    ticker := time.NewTicker(5 * time.Second)\\n    defer ticker.Stop()\\n\\n    for {\\n        select {\\n        // Send ping message to all known peers every 5 seconds.\\n        case <-ticker.C:\\n            channel.Out <- Envelope{\\n                Broadcast: true,\\n                Message:   &PingMessage{Content: \\\"\\ud83d\\udc4b\\\"},\\n            }\\n\\n        // When we receive a message from a peer, either respond to ping, output\\n        // pong, or report peer error on unknown message type.\\n        case envelope := <-channel.In:\\n            switch msg := envelope.Message.(type) {\\n            case *PingMessage:\\n                channel.Out <- Envelope{\\n                    To:      envelope.From,\\n                    Message: &PongMessage{Content: msg.Content},\\n                }\\n\\n            case *PongMessage:\\n                fmt.Printf(\\\"%q replied with %q\\\\n\\\", envelope.From, msg.Content)\\n\\n            default:\\n                channel.Error <- PeerError{\\n                    PeerID: envelope.From,\\n                    Err:    fmt.Errorf(\\\"unexpected message %T\\\", msg),\\n                }\\n            }\\n\\n        // Output info about any peer status changes.\\n        case peerUpdate := <-peerUpdates:\\n            fmt.Printf(\\\"Peer %q changed status to %q\\\", peerUpdate.PeerID, peerUpdate.Status)\\n\\n        // Exit when context is canceled.\\n        case <-ctx.Done():\\n            return nil\\n        }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Validator Listen Address in TOML for CometBFT\nDESCRIPTION: Sets the TCP or UNIX socket listen address for external consensus signing processes to connect. This is used when consensus signing is outsourced from CometBFT, typically to a Hardware Security Module.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\npriv_validator_laddr = \"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Message Reception Action in Bluespec\nDESCRIPTION: Defines the `receiveFromPeer` action, modeling how a node processes an incoming message. It requires the node's incoming message queue to be non-empty, dequeues the first message, extracts the sender and content, and passes them to a generic `handleMessage` function for protocol-specific processing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_11\n\nLANGUAGE: bluespec\nCODE:\n```\naction receiveFromPeer(node, handleMessage) = all {\n    require(length(node.IncomingMsgs()) > 0),\n    // We model receiving of a message as taking the head of the list of\n    // incoming messages and leaving the tail.\n    val someMsg = node.IncomingMsgs().head()\n    val sender = someMsg._1\n    val msg = someMsg._2\n    val _incomingMsgs = incomingMsgs.update(node, tail)\n    handleMessage(node, _incomingMsgs, sender, msg)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Endpoint Structure for Transport Addressing in Go\nDESCRIPTION: Definition of the Endpoint structure that represents transport connection endpoints for P2P communication. It supports both networked (IP-based) and non-networked endpoints with protocol specification, making it flexible for different transport types.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Endpoint represents a transport connection endpoint, either local or remote.\n//\n// Endpoints are not necessarily networked (see e.g. MemoryTransport) but all\n// networked endpoints must use IP as the underlying transport protocol to allow\n// e.g. IP address filtering. Either IP or Path (or both) must be set.\ntype Endpoint struct {\n    // Protocol specifies the transport protocol.\n    Protocol Protocol\n\n    // IP is an IP address (v4 or v6) to connect to. If set, this defines the\n    // endpoint as a networked endpoint.\n    IP net.IP\n\n    // Port is a network port (either TCP or UDP). If 0, a default port may be\n    // used depending on the protocol.\n    Port uint16\n\n    // Path is an optional transport-specific path or identifier.\n    Path string\n}\n\n// Protocol identifies a transport protocol.\ntype Protocol string\n```\n\n----------------------------------------\n\nTITLE: Implementing FinalizeBlock Method in Rust\nDESCRIPTION: Replaces the existing BeginBlock, DeliverTx, and EndBlock methods with a single FinalizeBlock method, allowing for more flexible block execution models.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn FinalizeBlock() -> ResponseFinalizeBlock\n```\n\n----------------------------------------\n\nTITLE: Defining ABCI Commit API with Retain Height in Protocol Buffers\nDESCRIPTION: Protocol Buffer definition extending the ABCI ResponseCommit message with a retain_height field. This allows the application to specify the oldest block height that should be retained, enabling configurable block pruning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-077-block-retention.md#2025-04-22_snippet_0\n\nLANGUAGE: proto\nCODE:\n```\nservice ABCIApplication {\n  rpc Commit(RequestCommit) returns (ResponseCommit);\n}\n\nmessage RequestCommit {}\n\nmessage ResponseCommit {\n  // reserve 1\n  bytes  data          = 2; // the Merkle root hash\n  uint64 retain_height = 3; // the oldest block height to retain\n}\n```\n\n----------------------------------------\n\nTITLE: Running CometBFT E2E Nightly Tests (Shell)\nDESCRIPTION: Executes the end-to-end nightly test suite locally. This involves changing to the `test/e2e` directory, building the test runner and generator using `make`, generating configurations for 5 test groups into the `networks/nightly/` directory with persistence (`-p`), and finally running all generated test scenarios matching the pattern `networks/nightly/*-group*-*.toml` using the `run-multiple.sh` script.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd test/e2e\nmake && ./build/generator -g 5 -d networks/nightly/ -p && ./run-multiple.sh networks/nightly/*-group*-*.toml\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Format in TOML for CometBFT\nDESCRIPTION: Sets the output format of logs to either plain text or JSON. Plain text logs are color-coded by default, while JSON logs provide structured data for each log entry.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\nlog_format = \"plain\"\n```\n\n----------------------------------------\n\nTITLE: Debug Kill Archive Structure\nDESCRIPTION: Directory structure showing the contents of the debug kill archive, including configuration, consensus state, network info, stacktrace, status, and WAL files.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n├── config.toml\n├── consensus_state.json\n├── net_info.json\n├── stacktrace.out\n├── status.json\n└── wal\n```\n\n----------------------------------------\n\nTITLE: Defining Fireable interface in Go\nDESCRIPTION: Defines the Fireable interface for event switches or caches that can fire events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\ntype Fireable interface {\n    FireEvent(event string, data EventData)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Version Marker to CometBFT Config File (TOML)\nDESCRIPTION: Proposed addition of a 'config-version' field to the CometBFT configuration file. This field would indicate the minimum compatible version of CometBFT for the config file, enabling better version detection and automated updates.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-019-config-version.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# THe minimum version of Tendermint compatible with the contents of\n# this configuration file.\nconfig-version = 'v0.35'\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Components in Shell\nDESCRIPTION: This snippet shows the log output when CometBFT starts various components such as the event switch, reactors, and listeners.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:27.374] Starting EventSwitch                         module=types impl=EventSwitch\nI[10-04|13:54:27.375] This node is a validator                     module=consensus\nI[10-04|13:54:27.379] Starting Node                                module=main impl=Node\nI[10-04|13:54:27.381] Local listener                               module=p2p ip=:: port=26656\nI[10-04|13:54:30.386] Starting DefaultListener                     module=p2p impl=Listener(@10.0.2.15:26656)\nI[10-04|13:54:30.387] Starting P2P Switch                          module=p2p impl=\"P2P Switch\"\nI[10-04|13:54:30.387] Starting MempoolReactor                      module=mempool impl=MempoolReactor\nI[10-04|13:54:30.387] Starting BlockchainReactor                   module=blockchain impl=BlockchainReactor\nI[10-04|13:54:30.387] Starting ConsensusReactor                    module=consensus impl=ConsensusReactor\nI[10-04|13:54:30.387] ConsensusReactor                             module=consensus fastSync=false\nI[10-04|13:54:30.387] Starting ConsensusState                      module=consensus impl=ConsensusState\nI[10-04|13:54:30.387] Starting WAL                                 module=consensus wal=/home/vagrant/.cometbft/data/cs.wal/wal impl=WAL\nI[10-04|13:54:30.388] Starting TimeoutTicker                       module=consensus impl=TimeoutTicker\n```\n\n----------------------------------------\n\nTITLE: Calculating Derivative Component for Trust Metric in Tendermint\nDESCRIPTION: Formulas for calculating the derivative component of the trust value, which measures the difference between current behavior and historical behavior, applying a penalty when current behavior is worse than past behavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\nD[i] = R[i] – H[i]\n\n(3) Derivative Value = c(D[i]) * D[i]\n```\n\n----------------------------------------\n\nTITLE: Defining Event Query Response in Go\nDESCRIPTION: Specifies the structure for the event query response, including matched items, pagination information, and cursor details for the oldest and newest items in the log.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-075-rpc-subscription.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype EventReply struct {\n    // The items matching the request parameters, from newest\n    // to oldest, if any were available within the timeout.\n    Items []*EventItem `json:\"items\"`\n\n    // This is true if there is at least one older matching item\n    // available in the log that was not returned.\n    More bool `json:\"more\"`\n\n    // The cursor of the oldest item in the log at the time of this reply,\n    // or \"\" if the log is empty.\n    Oldest string `json:\"oldest\"`\n\n    // The cursor of the newest item in the log at the time of this reply,\n    // or \"\" if the log is empty.\n    Newest string `json:\"newest\"`\n}\n\ntype EventItem struct {\n    // The cursor of this item.\n    Cursor string `json:\"cursor\"`\n\n    // The encoded event data for this item.\n    // The type identifies the structure of the value.\n    Data struct {\n        Type  string          `json:\"type\"`\n        Value json.RawMessage `json:\"value\"`\n    } `json:\"data\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Newton Definition\nDESCRIPTION: Defines the reference Newtonian real-time used for specification purposes, aligned with UTC but not directly accessible to processes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-sysmodel.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n**[PBTS-CLOCK-NEWTON.0]**\n\nThere is a reference Newtonian real-time `t`.\n```\n\n----------------------------------------\n\nTITLE: Detecting Duplicate Words in CometBFT Forum App (Go)\nDESCRIPTION: Implements the hasDuplicateWords function to check for duplicate words in a slice of strings. It uses a map to efficiently detect duplicates.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\nfunc hasDuplicateWords(words []string) bool {\n\twordMap := make(map[string]struct{})\n\n\tfor _, word := range words {\n\t\twordMap[word] = struct{}{}\n\t}\n\n\treturn len(words) != len(wordMap)\n}\n```\n\n----------------------------------------\n\nTITLE: CometBFT State Sync Configuration Options in Bash\nDESCRIPTION: Presents the configuration options that would be added to CometBFT's config file to support local state sync, including options for enabling local sync, specifying snapshot paths, and configuring automatic snapshot dumping.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-104-out-of-band-state-sync.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[statesync]\n# State syncing from a local snapshot\nlocal_sync=false\n# Path to snapshot, will be ignored if local_sync=false\nsnapshot_load_path=\"\"\n# Periodically dump snapshots into archive format (optional)\nauto_snapshot_dump=false\n# If dumping nodes into archive format, set the path to where the file is dumped\n# and the file format\n# This can be changed when using a CLI command\nsnapshot_dump_path=\"\"\nsnapshot_dump_format=\"\"\n```\n\n----------------------------------------\n\nTITLE: New Feature Consensus Parameters\nDESCRIPTION: New feature parameters introduced in CometBFT v1.0. These replace the deprecated ABCI parameters and control vote extensions and PBTS enabling heights.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n    \"feature\": {\n      \"vote_extensions_enable_height\": \"0\",\n      \"pbts_enable_height\": \"0\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Default MultiplexTransport in Go\nDESCRIPTION: Example implementation of the default multiplexTransport struct that accepts TCP connections and upgrades them to multiplexed peers. It includes channel management and configuration for dial timeouts and handshakes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-012-peer-transport.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// multiplexTransport accepts tcp connections and upgrades to multiplexed\n// peers.\ntype multiplexTransport struct {\n\tlistener net.Listener\n\n\tacceptc chan accept\n\tclosec  <-chan struct{}\n\tlistenc <-chan struct{}\n\n\tdialTimeout      time.Duration\n\thandshakeTimeout time.Duration\n\tnodeAddr         NetAddress\n\tnodeInfo         NodeInfo\n\tnodeKey          NodeKey\n\n\t// TODO(xla): Remove when MConnection is refactored into mPeer.\n\tmConfig conn.MConnConfig\n}\n\nvar _ PeerTransport = (*multiplexTransport)(nil)\n\n// NewMTransport returns network connected multiplexed peers.\nfunc NewMTransport(\n\tnodeAddr NetAddress,\n\tnodeInfo NodeInfo,\n\tnodeKey NodeKey,\n) *multiplexTransport\n```\n\n----------------------------------------\n\nTITLE: Defining ChainID Derivation in Markdown\nDESCRIPTION: Specifies how ChainID is derived by hashing the ChainDescriptor. It defines the unique identifier for a blockchain and mentions it should be Bech32 encoded when handled by users.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-017-chain-versions.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\nChainID = TMHASH(ChainDescriptor)\n```\n```\n\n----------------------------------------\n\nTITLE: Docker IPv6 Configuration\nDESCRIPTION: JSON configuration for enabling IPv6 support in Docker daemon, including the IPv6 flag and fixed CIDR configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"ipv6\": true,\n  \"fixed-cidr-v6\": \"2001:db8:1::/64\"\n}\n```\n\n----------------------------------------\n\nTITLE: Unbuffered Event Subscription in CometBFT Indexer\nDESCRIPTION: The event indexer in CometBFT uses an unbuffered subscription to the event system. This could potentially cause writes to the event system to block or slow down.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-003-performance-questions.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nevent-indexer-unbuffered: https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/state/indexer/indexer_service.go#L39\n```\n\n----------------------------------------\n\nTITLE: Fetching Validators from Full Node in Go\nDESCRIPTION: RPC function to fetch the validator set of a specific height from a full node. It returns a ValidatorSet or an error.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc Validators(height int64) (ValidatorSet, error)\n```\n\n----------------------------------------\n\nTITLE: Requesting Transaction Details in CometBFT API\nDESCRIPTION: HTTP and JSONRPC request examples for retrieving details of a specific transaction by its hash. The tx endpoint can optionally return proof that the transaction was included in a block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_29\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/num_unconfirmed_txs\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"num_unconfirmed_txs\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Peer Filtering in TOML for CometBFT\nDESCRIPTION: Determines whether to filter new peer connections through an ABCI query. When set to true, the ABCI application must implement a query to decide if a connection should be kept or dropped.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\nfilter_peers = false\n```\n\n----------------------------------------\n\nTITLE: CometBFT State Bootstrap Command in Script\nDESCRIPTION: Displays the command that bootstraps CometBFT's state and block store from the application's state, which is necessary after restoring an application snapshot.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-104-out-of-band-state-sync.md#2025-04-22_snippet_1\n\nLANGUAGE: script\nCODE:\n```\ncomet bootstrap-state          Bootstrap the state of CometBFT's state and block store from the\n                               application's state\n```\n\n----------------------------------------\n\nTITLE: Defining Node Identifier Type in Bluespec\nDESCRIPTION: Defines the `NodeID` type as a string (`str`) to uniquely identify nodes within the P2P network model. This type serves as the fundamental identifier used throughout the specification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_0\n\nLANGUAGE: bluespec\nCODE:\n```\ntype NodeID = str\n```\n\n----------------------------------------\n\nTITLE: Installing Specific CometBFT Go Package Version\nDESCRIPTION: This command installs a specific version (v0.38) of CometBFT's Go package using the go install command.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngo install github.com/cometbft/cometbft/cmd/cometbft@v0.38\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Services Configuration\nDESCRIPTION: Configuration settings to enable individual gRPC services including version, block, and block results services.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/grpc.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[grpc.version_service]\nenabled = true\n\n[grpc.block_service]\nenabled = true\n\n[grpc.block_results_service]\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Setting Invalid Transaction Cache Behavior\nDESCRIPTION: Configuration to determine whether invalid transactions should be kept in cache.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_66\n\nLANGUAGE: toml\nCODE:\n```\nkeep-invalid-txs-in-cache = false\n```\n\n----------------------------------------\n\nTITLE: Configuring Private Peer IDs in CometBFT (TOML)\nDESCRIPTION: Specifies a list of peer IDs to keep private. These IDs will not be gossiped to other peers when PEX is enabled, allowing for more granular control over peer information sharing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_55\n\nLANGUAGE: toml\nCODE:\n```\nprivate_peer_ids = \"\"\n```\n\n----------------------------------------\n\nTITLE: Example JSON Tags Structure in DeliverTx Response\nDESCRIPTION: Shows the format of tags returned by ABCI applications in the 'data' field of a DeliverTx response. These key-value pairs enable transaction filtering and subscription.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-002-event-subscription.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"abci.account.name\": \"Igor\",\n  \"abci.account.address\": \"0xdeadbeef\",\n  \"tx.gas\": 7\n}\n```\n\n----------------------------------------\n\nTITLE: History Index Calculation for Fading Memories Technique\nDESCRIPTION: Formula for mapping history access requests to actual stored indices, enabling the fading memories technique that optimizes storage while maintaining relevant historical data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_4\n\nLANGUAGE: math\nCODE:\n```\n(4) j = index, where index > 0\n```\n\n----------------------------------------\n\nTITLE: Running Latency vs Throughput Plot Generation\nDESCRIPTION: Example command for generating a PNG plot of latency vs throughput metrics using the latency_throughput.py script. Demonstrates usage with custom title parameter.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/scripts/qa/reporting/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./latency_throughput.py -t 'CometBFT v1.x Latency vs Throughput' ./cmt_v1.png /path/to/results/raw.csv\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing Backport Branch for CometBFT\nDESCRIPTION: Commands for creating a new backport branch for a major version release. This snippet shows how to create a v2.x branch from main and push it to the remote repository.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout -b v2.x\ngit push origin v2.x\n```\n\n----------------------------------------\n\nTITLE: Generating Multi-Version Testnets with Local Code in Shell\nDESCRIPTION: Generates multi-version testnet manifests comparing a specific released version (v0.34.23) with the code currently built locally (`local`). The `-m \"v0.34.23:1,local:2\"` flag specifies that 1/3rd of the network nodes will run v0.34.23 and 2/3rds will run the version built from the local source code. Requires corresponding Docker images.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n# \"local\" refers to the current local code. The E2E node built from the local\n# code will be run on 2/3rds of the network, whereas the v0.34.23 E2E node will\n# be run on the remaining 1/3rd.\n./build/generator -m \"v0.34.23:1,local:2\" -d networks/generated/\n```\n\n----------------------------------------\n\nTITLE: Deprecated Legacy gRPC Configuration\nDESCRIPTION: Example showing the deprecated gRPC configuration parameters that are no longer valid in CometBFT v1.0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[rpc]\n\ngrpc_laddr = \"\"\ngrpc_max_open_connections = 900\n```\n\n----------------------------------------\n\nTITLE: Publishing Events in Go\nDESCRIPTION: This snippet shows the implementation of event publication in Tendermint's pubsub system. It demonstrates how events are sent to subscribers using buffered channels.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-005-event-system.rst#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n- `publication of events <https://github.com/tendermint/tendermint/blob/main/libs/pubsub/pubsub.go#L333-L345>`_\n```\n\n----------------------------------------\n\nTITLE: Creating a new EventCache in Go\nDESCRIPTION: Function to create a new EventCache with an EventSwitch as backend.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc NewEventCache(evsw Fireable) *EventCache\n```\n\n----------------------------------------\n\nTITLE: Listing Cosmos SDK Imports from CometBFT\nDESCRIPTION: A Bash command that lists all packages imported from CometBFT by the Cosmos SDK, including runtime, testing, and cross-testing imports.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-109-reduce-go-api-surface.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo list -json ./... | jq '.Imports, .TestImports, .XTestImports' | grep cometbft | sort | uniq | tr -d '\", '\n```\n\n----------------------------------------\n\nTITLE: Defining Message Delivery Liveness Property in Bluespec\nDESCRIPTION: Defines the temporal property `allMsgsDelivered` using the `eventually` operator. It asserts that the system must eventually reach a state where all nodes have empty incoming message queues, guaranteeing that all messages sent are eventually processed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_15\n\nLANGUAGE: bluespec\nCODE:\n```\ntemporal allMsgsDelivered = \n    eventually(NodeIDs.forall(node => length(node.IncomingMsgs()) == 0))\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for BroadcastEvidence in CometBFT\nDESCRIPTION: HTTP request example for the broadcast_evidence endpoint that submits evidence of validator misbehavior.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_46\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://localhost:26657/v1/broadcast_evidence?evidence=JSON_EVIDENCE_encoded\n```\n\n----------------------------------------\n\nTITLE: Defining Status Request Message Structure in Go\nDESCRIPTION: Structure for status request messages used in the Peer Heartbeat mechanism, which includes a sequence number for tracking requests.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype MessageStatusRequest struct {\n  SeqNum int64     // sequence number of the request\n}\n```\n\n----------------------------------------\n\nTITLE: LightStore Query Functions in Go\nDESCRIPTION: This snippet provides functions to query LightBlocks stored within `LightStore`. `Get` retrieves a `LightBlock` by height, returning false if not found. `LatestVerified` returns the latest `LightBlock` whose state is either `StateVerified` or `StateTrusted`, facilitating the verification lifecycle.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Get(height Height) (LightBlock, bool)\n\nfunc (ls LightStore) LatestVerified() LightBlock\n```\n\n----------------------------------------\n\nTITLE: Defining PubKey Message Structure in Protobuf\nDESCRIPTION: Defines a new structure for PubKey messages, including a type string and data bytes. This allows for flexibility in key types without using enum or oneof.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-009-ABCI-design.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage PubKey {\n    string type\n    bytes data\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Subscriptions per Client in CometBFT RPC (TOML)\nDESCRIPTION: Specifies the maximum number of distinct event queries a single client (identified by its clientID) can subscribe to via the `/subscribe` RPC endpoint. This prevents any single client from overwhelming the server with too many subscriptions. The value must be an integer greater than or equal to 0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_22\n\nLANGUAGE: toml\nCODE:\n```\nmax_subscriptions_per_client = 5\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Encoded Value from CometBFT Query Response (Bash)\nDESCRIPTION: This command uses `echo` to pass the Base64 encoded value (`Ik11c2ljIg==`) from the `/abci_query` response to the `base64 -d` utility, which decodes it back to the original message (`Music`).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\necho Ik11c2ljIg== | base64 -d\n```\n\n----------------------------------------\n\nTITLE: Defining Auxiliary Functions for State Access in Bluespec\nDESCRIPTION: Defines auxiliary helper functions `IncomingMsgs(node)` and `Peers(node)` to provide convenient access to a node's incoming message list and current peer set, respectively, by retrieving them from the main state variables `incomingMsgs` and `peers`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_5\n\nLANGUAGE: bluespec\nCODE:\n```\ndef IncomingMsgs(node) = incomingMsgs.get(node)\ndef Peers(node) = peers.get(node)\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Server and Services in TOML\nDESCRIPTION: Complete configuration for the new gRPC section that supports Data Companion API services, including privileged endpoints and pruning service settings.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n#######################################################\n###       gRPC Server Configuration Options         ###\n#######################################################\n\n#\n# Note that the gRPC server is exposed unauthenticated. It is critical that\n# this server not be exposed directly to the public internet. If this service\n# must be accessed via the public internet, please ensure that appropriate\n# precautions are taken (e.g. fronting with a reverse proxy like nginx with TLS\n# termination and authentication, using DDoS protection services like\n# CloudFlare, etc.).\n#\n\n[grpc]\n\n# TCP or UNIX socket address for the RPC server to listen on. If not specified,\n# the gRPC server will be disabled.\nladdr = \"\"\n\n#\n# Each gRPC service can be turned on/off, and in some cases configured,\n# individually. If the gRPC server is not enabled, all individual services'\n# configurations are ignored.\n#\n\n# The gRPC version service provides version information about the node and the\n# protocols it uses.\n[grpc.version_service]\nenabled = true\n\n# The gRPC block service returns block information\n[grpc.block_service]\nenabled = true\n\n# The gRPC block results service returns block results for a given height. If no height\n# is given, it will return the block results from the latest height.\n[grpc.block_results_service]\nenabled = true\n\n#\n# Configuration for privileged gRPC endpoints, which should **never** be exposed\n# to the public internet.\n#\n[grpc.privileged]\n# The host/port on which to expose privileged gRPC endpoints.\nladdr = \"\"\n\n#\n# Configuration specifically for the gRPC pruning service, which is considered a\n# privileged service.\n#\n[grpc.privileged.pruning_service]\n\n# Only controls whether the pruning service is accessible via the gRPC API - not\n# whether a previously set pruning service retain height is honored by the\n# node. See the [storage.pruning] section for control over pruning.\n#\n# Disabled by default.\nenabled = false\n```\n\n----------------------------------------\n\nTITLE: Calculating Proportional Value for Trust Metric in Tendermint\nDESCRIPTION: Formula for calculating the proportional component of the trust value, where R[i] represents the raw trust value at time interval i and a is the weight applied to the current reports.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n(1) Proportional Value = a * R[i]\n```\n\n----------------------------------------\n\nTITLE: Parsing Experiment Logs - Shell\nDESCRIPTION: This command summarizes and parses model checker logs after experiment completion, producing human-readable results. It is executed after model checking batches for either commit verification or attack detection, requiring Apalache test scripts and correct output directory structure. The output visually confirms run results and aids in debugging.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncd ./out\n$DIR/apalache-tests/scripts/parse-logs.py --human .\n\n```\n\n----------------------------------------\n\nTITLE: Checking Tendermint Consensus Validity - Tendermint - Go\nDESCRIPTION: Implements violatesTMValidity to determine if a provided evidence header fails validity checks against a reference header per Tendermint consensus. It requires both headers to have the same height. The comparison involves key header fields, returning true if any differ, which indicates a Lunatic attack. The logic is integral to correctly categorizing types of validator misbehavior during isolation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc violatesTMValidity(ref Header, ev Header) boolean\n```\n\n----------------------------------------\n\nTITLE: Submitting a Transaction\nDESCRIPTION: cURL command to submit a transaction to the CometBFT node using the broadcast_tx_commit endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"cometbft=rocks\"'\n```\n\n----------------------------------------\n\nTITLE: MsgAndTags Struct Definition in Go\nDESCRIPTION: Defines a MsgAndTags struct used to indicate what tags a message matched when publishing to subscribers. This structure combines the message and its associated tags.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MsgAndTags struct {\n    Msg interface{}\n    Tags TagMap\n}\n```\n\n----------------------------------------\n\nTITLE: LightStore and VerifiedState Enums in Go\nDESCRIPTION: This snippet defines the `LightStore` struct used to store `LightBlock` instances and an enum `VerifiedState` for tracking the verification state of each block. The VerifiedState can be 'StateUnverified', 'StateVerified', 'StateFailed', or 'StateTrusted', important for block state management in the verification process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype LightStore struct {\n ...\n}\n\ntype VerifiedState int\n\nconst (\n StateUnverified = iota + 1\n StateVerified\n StateFailed\n StateTrusted\n)\n```\n\n----------------------------------------\n\nTITLE: Copyright and License Notice\nDESCRIPTION: Specifies the copyright holder (Galois, Inc., 2020) and the SPDX license identifier (Apache-2.0) applicable to all files within the folder containing the Ivy proofs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/ivy-proofs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n```copyright\nCopyright (c) 2020 Galois, Inc.\nSPDX-License-Identifier: Apache-2.0\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up Python Virtual Environment for CometBFT Reporting\nDESCRIPTION: Instructions for creating and activating a Python virtual environment and installing required dependencies for the reporting scripts. Creates a .venv directory and installs packages from requirements.txt.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/scripts/qa/reporting/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create a virtual environment into which to install your dependencies\npython3 -m venv .venv\n\n# Activate the virtual environment\nsource .venv/bin/activate\n\n# Install dependencies listed in requirements.txt\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Generating Testnets with Custom Log Level Configuration in Shell\nDESCRIPTION: Uses the testnet generator (`./build/generator`) to create grouped (`-g 2`) manifests in `networks/nightly/` (`-d`). The `-l` flag specifies a custom `log_level` setting (`\"*:debug,p2p:info\"`) that will be added to the CometBFT configuration within each generated manifest.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\n./build/generator -g 2 -d networks/nightly/ -l \"*:debug,p2p:info\"\n```\n\n----------------------------------------\n\nTITLE: Debugging CometBFT Node with pprof Tools\nDESCRIPTION: Commands for accessing various pprof debugging endpoints of a CometBFT node, including goroutine, heap, threadcreate, block, and mutex profiling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nexport PORT=$(docker port full01 6060 | awk -F: '{print $2}')\n\ngo tool pprof http://localhost:$PORT/debug/pprof/goroutine\ngo tool pprof http://localhost:$PORT/debug/pprof/heap\ngo tool pprof http://localhost:$PORT/debug/pprof/threadcreate\ngo tool pprof http://localhost:$PORT/debug/pprof/block\ngo tool pprof http://localhost:$PORT/debug/pprof/mutex\n```\n\n----------------------------------------\n\nTITLE: Configuring Experimental Database Key Layout in TOML\nDESCRIPTION: Configuration for the experimental_db_key_layout parameter which controls the representation of keys in the database, with v1 as the default value.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n# The representation of keys in the database.\n# The current representation of keys in Comet's stores is considered to be v1\n# Users can experiment with a different layout by setting this field to v2.\n# Note that this is an experimental feature and switching back from v2 to v1\n# is not supported by CometBFT.\n# If the database was initially created with v1, it is necessary to migrate the DB\n# before switching to v2. The migration is not done automatically.\n# v1 - the legacy layout existing in CometBFT prior to v1.\n# v2 - Order preserving representation ordering entries by height.\nexperimental_db_key_layout = \"v1\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Mempool Transaction Broadcasting\nDESCRIPTION: Setting to enable/disable broadcasting of uncommitted transactions to other nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_60\n\nLANGUAGE: toml\nCODE:\n```\nbroadcast = true\n```\n\n----------------------------------------\n\nTITLE: Creating a new EventSwitch in Go\nDESCRIPTION: Function to create a new EventSwitch instance.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc NewEventSwitch() EventSwitch\n```\n\n----------------------------------------\n\nTITLE: Defining Pruning Service API with Protocol Buffers\nDESCRIPTION: Protocol Buffer definition for CometBFT's pruning service, providing gRPC endpoints for controlling block data retention. The service allows setting and retrieving retention heights for blocks and block results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-101-data-companion-pull-api.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\npackage tendermint.services.pruning.v1;\n\n// PruningService provides privileged access to specialized pruning\n// functionality on the CometBFT node to help control node storage.\nservice PruningService {\n    // SetBlockRetainHeightRequest indicates to the node that it can safely\n    // prune all block data up to the specified retain height.\n    //\n    // The lower of this retain height and that set by the application in its\n    // Commit response will be used by the node to determine which heights' data\n    // can be pruned.\n    rpc SetBlockRetainHeight(SetBlockRetainHeightRequest) returns (SetBlockRetainHeightResponse);\n\n    // GetBlockRetainHeight returns information about the retain height\n    // parameters used by the node to influence block retention/pruning.\n    rpc GetBlockRetainHeight(GetBlockRetainHeightRequest) returns (GetBlockRetainHeightResponse);\n\n    // SetBlockResultsRetainHeightRequest indicates to the node that it can\n    // safely prune all block results data up to the specified height.\n    //\n    // The node will always store the block results for the latest height to\n    // help facilitate crash recovery.\n    rpc SetBlockResultsRetainHeight(SetBlockResultsRetainHeightRequest) returns (SetBlockResultsRetainHeightResponse);\n\n    // GetBlockResultsRetainHeight returns information about the retain height\n    // parameters used by the node to influence block results retention/pruning.\n    rpc GetBlockResultsRetainHeight(GetBlockResultsRetainHeightRequest) returns (GetBlockResultsRetainHeightResponse);\n}\n\nmessage SetBlockRetainHeightRequest {\n    uint64 height = 1;\n}\n\nmessage SetBlockRetainHeightResponse {}\n\nmessage GetBlockRetainHeightRequest {}\n\nmessage GetBlockRetainHeightResponse {\n    // The retain height set by the application.\n    uint64 app_retain_height = 1;\n\n    // The retain height set via the pruning service (e.g. by the data\n    // companion) specifically for blocks.\n    uint64 pruning_service_retain_height = 2;\n}\n\nmessage SetBlockResultsRetainHeightRequest {\n    uint64 height = 1;\n}\n\nmessage SetBlockResultsRetainHeightResponse {}\n\nmessage GetBlockResultsRetainHeightRequest {}\n\nmessage GetBlockResultsRetainHeightResponse {\n    // The retain height set by the pruning service (e.g. by the data\n    // companion) specifically for block results.\n    uint64 pruning_service_retain_height = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Commit Signature Structure in Protobuf\nDESCRIPTION: CommitSig message definition containing validator signature details and timestamps.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage CommitSig {\n  BlockIDFlag               block_id_flag     = 1;\n  bytes                     validator_address = 2;\n  google.protobuf.Timestamp timestamp         = 3;\n  bytes                     signature         = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Verified Light Blocks in Go\nDESCRIPTION: Function to return only the verified LightBlocks from the LightStore.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) FilterVerified() LightSTore\n```\n\n----------------------------------------\n\nTITLE: Configuring Peer Query Maj23 Sleep Duration in CometBFT\nDESCRIPTION: Sets the interval between querying peers for +2/3 vote majorities. This parameter controls how frequently the consensus reactor sends VoteSetMaj23 messages to query peers about vote messages they have for a specific block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_92\n\nLANGUAGE: toml\nCODE:\n```\npeer_query_maj23_sleep_duration = \"2s\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum JSON-RPC Batch Request Size in CometBFT RPC (TOML)\nDESCRIPTION: Defines the maximum number of individual RPC requests allowed within a single JSON-RPC batch request. If a batch request exceeds this limit, the server returns an error. Setting the value to 0 disables this limit entirely. The default is 10.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_27\n\nLANGUAGE: toml\nCODE:\n```\nmax_request_batch_size = 10\n```\n\n----------------------------------------\n\nTITLE: Querying State for a Rejected Transaction Sender (Bash)\nDESCRIPTION: This command uses curl to query the application state via `/abci_query` for the sender (`data=\"Malfoy\"`) whose previous transaction containing a curse word was rejected. It expects a 'Key not found' error, confirming the transaction was not persisted.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"Malfoy\"'\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction ID Hash Function\nDESCRIPTION: This code snippet defines a 'TxID' type and a hash function that maps a transaction to its ID. The hash function is a simple identity function in this model.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_2\n\nLANGUAGE: bluespec\nCODE:\n```\ntype TxID = str\npure def hash(tx: TX): TxID = tx\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Version Service in TOML\nDESCRIPTION: Enables the gRPC version service which provides version information about the node and its protocols. This setting is ignored if grpc.laddr is empty.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_34\n\nLANGUAGE: toml\nCODE:\n```\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Defining MVP Plasma Transaction Structure\nDESCRIPTION: Example structure of a deposit transaction in Minimal Viable Plasma, showing the format with zeroed-out inputs and an output in favor of the depositor.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-023-ABCI-propose-tx.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  0, 0, 0, 0, #input1 - zeroed out\n  0, 0, 0, 0, #input2 - zeroed out\n  <depositor_address>, <amount>, #output1 - in favour of depositor\n  0, 0, #output2 - zeroed out\n  <fee>,\n]\n```\n\n----------------------------------------\n\nTITLE: Ed25519 Key Example in node_key.json\nDESCRIPTION: Example of an Ed25519 key in node_key.json. This shows how the public key is concatenated with a zeroed-out private key, which still produces a valid node ID.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/node_key.json.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"priv_key\": {\n    \"type\": \"tendermint/PrivKeyEd25519\",\n    \"value\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxdiypykyf9yp7C81cJTZHKMOvrnGcZiqxlMfyQsaUUA==\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring gRPC Server Address in TOML\nDESCRIPTION: Sets the TCP or UNIX socket address for the gRPC server to listen on. If not specified, the gRPC server will be disabled.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_33\n\nLANGUAGE: toml\nCODE:\n```\nladdr = \"\"\n```\n\n----------------------------------------\n\nTITLE: Merging Specification Repository into Tendermint Core Repository using Git Commands\nDESCRIPTION: A series of Git commands to add the specification repository as a remote, fetch its contents, create a branch, move files to a subdirectory, and merge into the main repository while preserving history.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-076-combine-spec-repo.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add spec git@github.com:tendermint/spec.git\ngit fetch spec\ngit checkout -b spec-master spec/master\nmkdir spec\ngit ls-tree -z --name-only HEAD | xargs -0 -I {} git mv {} subdir/\ngit commit -m \"spec: organize specification prior to merge\"\ngit checkout -b spec-merge-mainline origin/master\ngit merge --allow-unrelated-histories spec-master\n```\n\n----------------------------------------\n\nTITLE: Tidying Go Modules and Rebuilding the Application\nDESCRIPTION: A sequence of bash commands used to resolve Go module dependency issues. `go mod tidy` ensures the `go.mod` and `go.sum` files are consistent by adding missing dependencies and removing unused ones. `go build` then compiles the project after dependencies are tidied.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ngo mod tidy\ngo build\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Generated Testnets in Shell\nDESCRIPTION: Executes a helper script (`./run-multiple.sh`) to run multiple testnets based on a file pattern. In this example, it runs all generated testnets belonging to group 3 located in the `networks/generated/` directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n./run-multiple.sh networks/generated/gen-group3-*.toml\n```\n\n----------------------------------------\n\nTITLE: Running the Default CI Testnet in Shell\nDESCRIPTION: Builds the necessary components using `make` and then runs the CometBFT end-to-end test runner (`./build/runner`) with the CI testnet manifest (`networks/ci.toml`). This command spins up the testnet defined in the specified TOML file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake\n./build/runner -f networks/ci.toml\n```\n\n----------------------------------------\n\nTITLE: CheckTx Response in CometBFT\nDESCRIPTION: Example JSON response from the check_tx endpoint showing transaction validation results including gas estimates and events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_39\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 0,\n  \"jsonrpc\": \"2.0\",\n  \"error\": \"\",\n  \"result\": {\n    \"code\": \"0\",\n    \"data\": \"\",\n    \"log\": \"\",\n    \"info\": \"\",\n    \"gas_wanted\": \"1\",\n    \"gas_used\": \"0\",\n    \"events\": [\n      {\n        \"type\": \"app\",\n        \"attributes\": [\n          {\n            \"key\": \"YWN0aW9u\",\n            \"value\": \"c2VuZA==\",\n            \"index\": false\n          }\n        ]\n      }\n    ],\n    \"codespace\": \"bank\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventData interface in Go\nDESCRIPTION: Defines the EventData interface for generic event data that can be typed and registered with tendermint/go-amino.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype EventData interface {}\n```\n\n----------------------------------------\n\nTITLE: Validator Set Verification in Go\nDESCRIPTION: Code snippet showing how to verify that a header's validator set hash matches the hash of the validator set being verified.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nheader[height-1].ValidatorsHash == hash(validatorSet[height-1])\n```\n\n----------------------------------------\n\nTITLE: Latest Previous Height Query Function\nDESCRIPTION: Function that returns the latest verified light block with height less than the specified height. Returns both the light block and a boolean indicating success.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_001_published.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) LatestPrevious(height Height) (LightBlock, bool)\n```\n\n----------------------------------------\n\nTITLE: Comparing New Header with Witness in Go\nDESCRIPTION: This function compares a new header with a witness node. It takes an error channel, a signed header, a witness provider, and a witness index as input parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc (c *Client) compareNewHeaderWithWitness(errc chan error, h *types.SignedHeader,\n\twitness provider.Provider, witnessIndex int)\n```\n\n----------------------------------------\n\nTITLE: Decoding a secp256k1 Public Key from Base64 - Shell\nDESCRIPTION: Decodes a base64-encoded secp256k1 public key and displays its hexadecimal byte sequence. This is used to inspect the raw byte layout of a public key, which is relevant for address and signature operations. Input: pubkey as base64 string. Output: Hex dump of the 33-byte key. Requires 'base64' and 'xxd' command-line utilities.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\necho AkeI23hsiCXVTf2+k+hGJAj/tuXRlwNRHI/Iv2Cvj3LQ | base64 -d | xxd -p -c 33\n```\n\n----------------------------------------\n\nTITLE: Defining the EvidenceHash Field in CometBFT Block Header\nDESCRIPTION: Specifies the structure and validation for the `EvidenceHash` field within a CometBFT block header. This field contains the Merkle root of evidence related to Byzantine behavior and must be a 32-byte slice.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| EvidenceHash      | slice of bytes (`[]byte`) | MerkleRoot of the evidence of Byzantine behavior included in this block.                                                                                                                                                                                                                                                                                                               | Must  be of length 32                                                                                                                                                                                                                                      |\n```\n\n----------------------------------------\n\nTITLE: Defining Light Client Attack Evidence in Go\nDESCRIPTION: Defines the structure for representing light client attack evidence, which includes a conflicting block and a common height. This data structure is foundational for handling attack detection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/notes-on-evidence-handling.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n    ConflictingBlock   LightBlock\n    CommonHeight       int64\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Grammar for CometBFT E2E Tests\nDESCRIPTION: This grammar defines the sequence of operations in end-to-end (E2E) testing for CometBFT, an open-source blockchain toolkit. It handles various states such as CleanStart and Recovery and delineates how different components interact through rules like InitChain and ConsensusExec. Key states include OfferSnapshot for snapshot offering and ApplyChunk for applying snapshot chunks. The grammar is intended for developers working on protocol testing, with no external dependencies needed other than standard implementation of the CometBFT toolkit. Input operations are expected as the defined grammar strings, and the main output is thus the logical order of blockchain operations simulated for testing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/pkg/grammar/abci_grammar.md#2025-04-22_snippet_0\n\nLANGUAGE: Language Definition\nCODE:\n```\nStart : CleanStart | Recovery;\n\nCleanStart : InitChain ConsensusExec | StateSync ConsensusExec ;\nStateSync : StateSyncAttempts SuccessSync |  SuccessSync ; \nStateSyncAttempts : StateSyncAttempt | StateSyncAttempt StateSyncAttempts ;\nStateSyncAttempt : OfferSnapshot ApplyChunks | OfferSnapshot ;\nSuccessSync : OfferSnapshot ApplyChunks ; \nApplyChunks : ApplyChunk | ApplyChunk ApplyChunks ;  \n\nRecovery :  InitChain ConsensusExec | ConsensusExec ;\n\nConsensusExec : ConsensusHeights ;\nConsensusHeights : ConsensusHeight | ConsensusHeight ConsensusHeights ;\nConsensusHeight : ConsensusRounds FinalizeBlock Commit | FinalizeBlock Commit ;\nConsensusRounds : ConsensusRound | ConsensusRound ConsensusRounds ;\nConsensusRound : Proposer | NonProposer ; \n\nProposer : GotVotes | ProposerSimple | Extend | GotVotes ProposerSimple | GotVotes Extend | ProposerSimple Extend | GotVotes ProposerSimple Extend ; \nProposerSimple : PrepareProposal | PrepareProposal ProcessProposal ;\nNonProposer: GotVotes | ProcessProposal | Extend | GotVotes ProcessProposal | GotVotes Extend | ProcessProposal Extend | GotVotes ProcessProposal Extend ; \nExtend : ExtendVote | GotVotes ExtendVote | ExtendVote GotVotes | GotVotes ExtendVote GotVotes ;\nGotVotes : GotVote | GotVote GotVotes ; \n\nInitChain : \"init_chain\" ;\nFinalizeBlock : \"finalize_block\" ; \nCommit : \"commit\" ;\nOfferSnapshot : \"offer_snapshot\" ;\nApplyChunk : \"apply_snapshot_chunk\" ; \nPrepareProposal : \"prepare_proposal\" ; \nProcessProposal : \"process_proposal\" ;\nExtendVote : \"extend_vote\" ;\nGotVote : \"verify_vote_extension\" ;\n```\n\n----------------------------------------\n\nTITLE: Modifying Proposal Handling Rule (Lines 28-35) for Proposer-Based Time in Go Pseudo-code\nDESCRIPTION: Compares the consensus rule for handling timely PROPOSAL messages (originally lines 28-35 in the arXiv paper) with the modified version for Proposer-Based Time. The change involves extracting both the value `v` and the proposed time `tprop` from the proposal tuple `(v, tprop)`. When broadcasting the PREVOTE message, the identifier now includes both value and time `id(v, tprop)`, ensuring the time proposed by the proposer is propagated and validated.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/v1/pbts_001_draft.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n```go\nupon timely(⟨PROPOSAL, h_p, round_p, v, vr⟩) \n from proposer(h_p, round_p)\n AND 2f + 1 ⟨PREVOTE, h_p, vr, id(v)⟩ \nwhile step_p = propose ∧ (vr ≥ 0 ∧ vr < round_p) do {\n if valid(v) ∧ (lockedRound_p ≤ vr ∨ lockedValue_p = v) {\n  \n  broadcast ⟨PREVOTE, h_p, round_p, id(v)⟩\n } else {\n  broadcast ⟨PREVOTE, hp, round_p, nil⟩\n }\n}\n```\n```\n\nLANGUAGE: go\nCODE:\n```\n```go\nupon timely(⟨PROPOSAL, h_p, round_p, (v, tprop), vr⟩) \n from proposer(h_p, round_p) \n AND 2f + 1 ⟨PREVOTE, h_p, vr, id(v, tvote)⟩ \n while step_p = propose ∧ (vr ≥ 0 ∧ vr < round_p) do {\n  if valid(v) ∧ (lockedRound_p ≤ vr ∨ lockedValue_p = v) {\n   // send hash of v and tprop in PREVOTE message\n   broadcast ⟨PREVOTE, h_p, round_p, id(v, tprop)⟩\n  } else {\n   broadcast ⟨PREVOTE, hp, round_p, nil⟩\n  }\n }\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Trusted Height for State Sync in CometBFT (TOML)\nDESCRIPTION: Defines the height of the trusted header hash for state synchronization. Must be greater than or equal to 0, with 0 only allowed when state sync is disabled.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_74\n\nLANGUAGE: toml\nCODE:\n```\ntrust_height = 0\n```\n\n----------------------------------------\n\nTITLE: Sending Events in CometBFT Event System\nDESCRIPTION: The event system in CometBFT uses channels to send messages to subscribers. This snippet shows how sending an event blocks on the internal channel, which could potentially cause performance issues.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-003-performance-questions.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nevent-send: https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/libs/pubsub/pubsub.go#L338\n```\n\n----------------------------------------\n\nTITLE: Generating, Running, and Parsing Model Checking Experiments - Shell\nDESCRIPTION: This set of commands automates the process of generating batch model-checking runs (with mk-run.py), executing all jobs (with run-all.sh), and parsing log results (with parse-logs.py) after experiment completion. Intended for use in the Apalache verification workflow, these scripts take CSV experiment configurations and perform or analyze TLA+ specification checking, outputting human-readable summaries. Key inputs include experiment batch CSVs and directory locations for Apalache sources and output; outputs are in 'results.csv' and parsed human logs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$DIR/apalache-tests/scripts/mk-run.py --memlimit 28 002bmc-apalache-ok.csv $DIR/apalache . out\n./out/run-all.sh\n\n```\n\nLANGUAGE: sh\nCODE:\n```\ncd ./out\n$DIR/apalache-tests/scripts/parse-logs.py --human .\n\n```\n\n----------------------------------------\n\nTITLE: Building the Go Application using Go Build\nDESCRIPTION: A simple bash command to compile the Go project in the current directory. It produces an executable binary based on the Go source files, primarily `main.go` and `app.go` in this context.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ngo build\n```\n\n----------------------------------------\n\nTITLE: Running Multi-Experiment Latency Analysis\nDESCRIPTION: Example command for running the latency_plotter.py script to generate multiple plots for different experiment configurations and combined analysis.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/scripts/qa/reporting/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./latency_plotter.py v1.0.0-alpha.2 /path/to/results/raw.csv\n```\n\n----------------------------------------\n\nTITLE: Listing SDK Snapshot Manipulation Commands in Script\nDESCRIPTION: Shows the command line interface that the SDK exposes for snapshot manipulation, including commands for deleting, dumping, exporting, listing, loading, and restoring snapshots from the local snapshot store.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-104-out-of-band-state-sync.md#2025-04-22_snippet_0\n\nLANGUAGE: script\nCODE:\n```\ndelete      Delete a snapshot from the local snapshot store\ndump        Dump the snapshot as portable archive format\nexport      Export app state to snapshot store\nlist        List local snapshots\nload        Load a snapshot archive file into snapshot store\nrestore     Restore app state from a snapshot stored in the local snapshot store\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT Node and RPC Server in Shell\nDESCRIPTION: This snippet shows the log output when CometBFT starts the node and the RPC HTTP server.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/how-to-read-logs.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nI[10-04|13:54:30.391] Starting RPC HTTP server on tcp socket 0.0.0.0:26657 module=rpc-server\nI[10-04|13:54:30.392] Started node                                 module=main nodeInfo=\"NodeInfo{id: DF22D7C92C91082324A1312F092AA1DA197FA598DBBFB6526E, moniker: anonymous, network: test-chain-3MNw2N [remote , listen 10.0.2.15:26656], version: 0.11.0-10f361fc ([wire_version=0.6.2 p2p_version=0.5.0 consensus_version=v1/0.2.2 rpc_version=0.7.0/3 tx_index=on rpc_addr=tcp://0.0.0.0:26657])}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Peer Set State Variable in Bluespec\nDESCRIPTION: Declares the state variable `peers`, mapping each `NodeID` to its current set of connected peer `NodeID`s. This represents the dynamic network topology, which changes as nodes join or leave the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_4\n\nLANGUAGE: bluespec\nCODE:\n```\nvar peers: NodeID -> Set[NodeID]\n```\n\n----------------------------------------\n\nTITLE: Defining GenesisDoc Structure in Go\nDESCRIPTION: The GenesisDoc structure contains initialization details like genesis time, chain ID, and validator sets necessary for blockchain setup. It is critical for verifying genesis properties in the light client.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype GenesisDoc struct {\n    GenesisTime     time.Time                `json:\"genesis_time\"`\n    ChainID         string                   `json:\"chain_id\"`\n    InitialHeight   int64                    `json:\"initial_height\"`\n    ConsensusParams *tmproto.ConsensusParams `json:\"consensus_params,omitempty\"`\n    Validators      []GenesisValidator       `json:\"validators,omitempty\"`\n    AppHash         tmbytes.HexBytes         `json:\"app_hash\"`\n    AppState        json.RawMessage          `json:\"app_state,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mempool Size\nDESCRIPTION: Setting for maximum number of transactions allowed in the mempool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_62\n\nLANGUAGE: toml\nCODE:\n```\nsize = 5000\n```\n\n----------------------------------------\n\nTITLE: Starting CometBFT with E2E Proxy App\nDESCRIPTION: Command for starting CometBFT with the e2e proxy application for simplified testing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncometbft start --proxy-app e2e\n```\n\n----------------------------------------\n\nTITLE: Generating Random Testnet Manifests in Shell\nDESCRIPTION: Uses the testnet generator (`./build/generator`) to create random (but deterministic) testnet manifest files. The generated TOML files are placed in the specified directory (`networks/generated/`) via the `-d` flag.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n./build/generator -d networks/generated/\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Private Key File for CometBFT RPC HTTPS (TOML)\nDESCRIPTION: Specifies the file path to the TLS private key file corresponding to the certificate specified in `rpc.tls_cert_file`. Both this and `rpc.tls_cert_file` must be set to enable HTTPS. If left empty, the server uses HTTP. The path can be absolute or relative to `$CMTHOME/config`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_31\n\nLANGUAGE: toml\nCODE:\n```\ntls_key_file = \"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Packet Payload Size in CometBFT (TOML)\nDESCRIPTION: Sets the maximum size of a packet payload in bytes. Messages exchanged via P2P connections are split into packets containing metadata and payload.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_50\n\nLANGUAGE: toml\nCODE:\n```\nmax_packet_msg_payload_size = 1024\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Message Structure in Proto3\nDESCRIPTION: Example protobuf message definition for a HelloRequest, showcasing the structure that will be used to generate Rust code.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-102-rust-gen-builders.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage HelloRequest {\n    int version = 1;\n    repeated string flags = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Block Results Retain Height in CometBFT\nDESCRIPTION: Go code example demonstrating how to set the block results retain height using the privileged gRPC client in CometBFT. This determines up to which height the node will keep block results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"github.com/cometbft/cometbft/rpc/grpc/client/privileged\"\n)\n\nctx := context.Background()\n\n// Privileged Service Client\naddr := \"0.0.0.0:26091\"\nconn, err := privileged.New(ctx, addr, privileged.WithInsecure())\nif err != nil {\n    // Do something with the error\n}\n\nerr := conn.SetBlockResultsRetainHeight(ctx, height)\nif err != nil {\n    // Do something with the error\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Vote Extensions in CometBFT Forum App (Go)\nDESCRIPTION: Implements the getWordsFromVe method to process vote extensions and extract curse words. It ensures no duplicate words and only includes words with majority validator support.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nfunc (app *ForumApp) getWordsFromVe(voteExtensions []abci.ExtendedVoteInfo) string {\n\tcurseWordMap := make(map[string]int)\n\tfor _, vote := range voteExtensions {\n\t\t// This code gets the curse words and makes sure that we do not add them more than once\n\t\t// Thus ensuring each validator only adds one word once\n\t\tcurseWords := strings.Split(string(vote.GetVoteExtension()), \"|\")\n\n\t\tfor _, word := range curseWords {\n\t\t\tif count, ok := curseWordMap[word]; !ok {\n\t\t\t\tcurseWordMap[word] = 1\n\t\t\t} else {\n\t\t\t\tcurseWordMap[word] = count + 1\n\t\t\t}\n\t\t}\n\t}\n\tapp.logger.Info(\"Processed vote extensions\", \"curse_words\", curseWordMap)\n\tmajority := len(app.valAddrToPubKeyMap) / 3 // We define the majority to be at least 1/3 of the validators;\n\n\tvoteExtensionCurseWords := \"\"\n\tfor word, count := range curseWordMap {\n\t\tif count > majority {\n\t\t\tif voteExtensionCurseWords == \"\" {\n\t\t\t\tvoteExtensionCurseWords = word\n\t\t\t} else {\n\t\t\t\tvoteExtensionCurseWords += \"|\" + word\n\t\t\t}\n\t\t}\n\t}\n\treturn voteExtensionCurseWords\n}\n```\n\n----------------------------------------\n\nTITLE: Determining Commit Round in Go\nDESCRIPTION: The RoundOf function identifies the round number within a given commit. Essential for validating that all votes within a commit are from the same round.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nfunc RoundOf(commit Commit) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Default node_key.json Structure in CometBFT\nDESCRIPTION: Example of the default node_key.json file structure, showing the priv_key object with type and value fields. The type specifies the encryption algorithm, while the value contains the base64-encoded private key.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/node_key.json.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"priv_key\": {\n    \"type\": \"tendermint/PrivKeyEd25519\",\n    \"value\": \"jxG2ywUkVPiF4XDW1Dwa5ZfcrC0rEa4iM1y4O5qCMpYxdiypykyf9yp7C81cJTZHKMOvrnGcZiqxlMfyQsaUUA==\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Consensus WAL File Location in CometBFT (TOML)\nDESCRIPTION: Specifies the location of the consensus Write-Ahead Log (WAL) file. The WAL stores consensus messages and events to enable node recovery after crashes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_81\n\nLANGUAGE: toml\nCODE:\n```\nwal_file = \"data/cs.wal/wal\"\n```\n\n----------------------------------------\n\nTITLE: Example JSON Payload for /commit RPC Endpoint\nDESCRIPTION: Provides an example JSON payload for a POST request to the `/commit` RPC endpoint. This structure includes the JSON-RPC version, a unique request ID, the method name `commit`, and parameters containing the desired block `height`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n// POST /commit\n{\n \"jsonrpc\": \"2.0\",\n \"id\": \"ccc84631-dfdb-4adc-b88c-5291ea3c2cfb\", // UUID v4, unique per request\n \"method\": \"commit\",\n \"params\": {\n  \"height\": 1234\n }\n}\n```\n\n----------------------------------------\n\nTITLE: HashedParams Structure Reference - Golang\nDESCRIPTION: Reference to the HashedParams struct showing currently hashed consensus parameters including BlockMaxGas and BlockMaxSize\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-009-consensus-parameter-upgrades.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntypes/params.go#L49\n```\n\n----------------------------------------\n\nTITLE: Querying Block Data by Height in CometBFT (JSONRPC Request)\nDESCRIPTION: This snippet shows how to query a block by height using a JSONRPC POST request to the CometBFT API. It includes the full JSON payload for the request.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"block\\\",\\\"params\\\":{\\\"height\\\":\\\"1\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Viewing Current CometBFT Configuration\nDESCRIPTION: Command to display the current configuration file contents.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/confix/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncometbft config view # views the current config\n```\n\n----------------------------------------\n\nTITLE: Configuring Privileged gRPC Endpoints in CometBFT\nDESCRIPTION: Configuration for setting up the privileged gRPC service address in CometBFT. This enables access to the privileged endpoints which should never be exposed to the public internet.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n#\n# Configuration for privileged gRPC endpoints, which should **never** be exposed\n# to the public internet.\n#\n[grpc.privileged]\n# The host/port on which to expose privileged gRPC endpoints.\nladdr = \"tcp://0.0.0.0:26091\"\n```\n\n----------------------------------------\n\nTITLE: Determining the Minimal-Height Verified Light Block - Go\nDESCRIPTION: Defines the LightStore method MinVerified, which returns the LightBlock with the minimal (earliest) height currently stored as trusted, plus a Boolean presence indicator. Assumes LightStore tracks light blocks with verification status. Outputs the block and a Boolean indicating existence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\nfunc (ls LightStore) MinVerified() (LightBlock, bool)\n```\n\n----------------------------------------\n\nTITLE: Alternative Batch Verification Function Signature in Go\nDESCRIPTION: This code snippet demonstrates an alternative function signature for batch verification, which takes slices of public keys, signatures, and messages. This approach is mentioned as being more error-prone compared to the chosen interface-based design.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-064-batch-verification.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc Verify(keys []crypto.Pubkey, signatures, messages[][]byte) bool\n```\n\n----------------------------------------\n\nTITLE: Test Results Table for 200-node Scenario\nDESCRIPTION: Markdown table showing the test results for the 200-node scenario, including the date, version, and outcome.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/CometBFT-QA-38.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Scenario | Date       | Version                                                    | Result |\n| -------- | ---------- | ---------------------------------------------------------- | ------ |\n| 200-node | 2023-05-21 | v0.38.0-alpha.2 (1f524d12996204f8fd9d41aa5aca215f80f06f5e) | Pass   |\n```\n\n----------------------------------------\n\nTITLE: Installing Latest CometBFT Go Package\nDESCRIPTION: This command installs the latest version of CometBFT's Go package using the go install command.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/install.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo install github.com/cometbft/cometbft/cmd/cometbft@latest\n```\n\n----------------------------------------\n\nTITLE: Stopping Monitoring Services with Docker Compose (Bash)\nDESCRIPTION: This Bash command uses Docker Compose (`docker compose down`) to stop and remove the containers, networks, and potentially volumes associated with the monitoring services previously started with `docker compose up`. It effectively shuts down the local Prometheus and Grafana stack.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/monitoring/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose down\n```\n\n----------------------------------------\n\nTITLE: Generating Prometheus Configuration for CometBFT E2E Tests (Bash)\nDESCRIPTION: These Bash commands are executed from the `test/e2e` directory to generate the necessary `prometheus.yml` configuration file. The `make fast` command builds required components, and the `./build/runner` command generates the Prometheus configuration based on the specified testnet topology (`networks/simple.toml`). This configuration file is essential before starting the monitoring services.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/monitoring/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake fast\n./build/runner -f networks/simple.toml setup\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Open Connections for CometBFT RPC (TOML)\nDESCRIPTION: Defines the maximum number of simultaneous connections (including HTTP and WebSocket connections) that the RPC server will accept. Increasing this value may require adjusting the operating system's file descriptor limit (e.g., using `ulimit`). The default limit is 900, and the value must be greater than 0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_20\n\nLANGUAGE: toml\nCODE:\n```\nmax_open_connections = 900\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial Retain Heights in CometBFT\nDESCRIPTION: Configuration for setting the initial retain heights for blocks and block results in CometBFT. This prevents unwanted pruning of data when the data companion is first activated.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# The initial value for the data companion block retain height if the data\n# companion has not yet explicitly set one. If the data companion has already\n# set a block retain height, this is ignored.\ninitial_block_retain_height = 0\n\n# The initial value for the data companion block results retain height if the\n# data companion has not yet explicitly set one. If the data companion has\n# already set a block results retain height, this is ignored.\ninitial_block_results_retain_height = 10\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Transaction Size\nDESCRIPTION: Configuration for maximum size in bytes for a single transaction.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_63\n\nLANGUAGE: toml\nCODE:\n```\nmax_tx_bytes = 1048576\n```\n\n----------------------------------------\n\nTITLE: Validating Unbonding Period of LightBlocks in Go\nDESCRIPTION: The ValidAndVerifiedUnbonding function checks if the unbonding period conditions between trusted and untrusted light blocks are met. This is crucial for differentiating valid blockchain states from exploited ones.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc ValidAndVerifiedUnbonding(trusted LightBlock, untrusted LightBlock) Result\n```\n\n----------------------------------------\n\nTITLE: Activating Unsafe RPC Endpoints in CometBFT (TOML)\nDESCRIPTION: Controls the activation of potentially dangerous RPC endpoints like `/dial_seeds`, `/dial_peers`, and `/unsafe_flush_mempool`. Setting this to `true` exposes these endpoints, which should be avoided on production systems due to security implications. The default value is `false`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_19\n\nLANGUAGE: toml\nCODE:\n```\nunsafe = false\n```\n\n----------------------------------------\n\nTITLE: Configuring Block Sync in CometBFT using TOML\nDESCRIPTION: TOML configuration snippet for Block Sync in CometBFT. It shows how to set the Block Sync version to use. In v0.37, v1 and v2 of the block sync protocols were deprecated, and v0 is now the recommended default implementation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/block-sync.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n#######################################################\n###       Block Sync Configuration Options          ###\n#######################################################\n[blocksync]\n\n# Block Sync version to use:\n# \n# In v0.37, v1 and v2 of the block sync protocols were deprecated.\n# Please use v0 instead.\n#\n#   1) \"v0\" - the default block sync implementation\nversion = \"v0\"\n```\n\n----------------------------------------\n\nTITLE: Solution 0 - Best Effort Vote Extensions\nDESCRIPTION: Proposes making vote extensions optional in the specification, allowing intermediate nodes to remove vote extensions from precommit messages. This simplifies implementation but weakens guarantees.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-100-abci-vote-extension-propag.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n**Solution 0.** *Vote extensions are made **best effort** in the specification*.\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Bisection Verification Logic (Partial) in Go\nDESCRIPTION: Shows the beginning of the `VerifyBisection` function implementation in Go. This function recursively verifies headers between a `trustedState` and a target `untrustedHeight`. It starts by fetching the signed header for the target height using the `Commit` RPC call. It then checks if the fetched header's timestamp is within the acceptable `clockDrift` relative to the time `now` when the verification process started. The rest of the recursive logic is omitted in this snippet.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc VerifyBisection(untrustedHeight int64,\n                     trustedState TrustedState,\n                     trustThreshold float,\n                     trustingPeriod Duration,\n                     clockDrift Duration,\n                     now Time) (TrustedState, error) {\n\n    untrustedSh, error := Commit(untrustedHeight)\n    if error != nil return (trustedState, ErrRequestFailed)\n\n    untrustedHeader = untrustedSh.Header\n\n    // note that we pass now during the recursive calls. This is fine as\n    // all other untrusted headers we download during recursion will be\n    // for a smaller heights, and therefore should happen before.\n    if untrustedHeader.Time > now + clockDrift {\n```\n```\n\n----------------------------------------\n\nTITLE: Genesis Data Response Format in CometBFT API\nDESCRIPTION: Example response structure for the genesis endpoint containing chain information, consensus parameters, initial validators, and application state. Includes critical blockchain initialization parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"genesis\": {\n      \"genesis_time\": \"2019-04-22T17:00:00Z\",\n      \"chain_id\": \"cosmoshub-2\",\n      \"initial_height\": \"2\",\n      \"consensus_params\": {\n        \"block\": {\n          \"max_bytes\": \"22020096\",\n          \"max_gas\": \"1000\",\n          \"time_iota_ms\": \"1000\"\n        },\n        \"evidence\": {\n          \"max_age\": \"100000\"\n        },\n        \"validator\": {\n          \"pub_key_types\": [\n            \"ed25519\"\n          ]\n        }\n      },\n      \"validators\": [\n        {\n          \"address\": \"B00A6323737F321EB0B8D59C6FD497A14B60938A\",\n          \"pub_key\": {\n            \"type\": \"tendermint/PubKeyEd25519\",\n            \"value\": \"cOQZvh/h9ZioSeUMZB/1Vy1Xo5x2sjrVjlE/qHnYifM=\"\n          },\n          \"power\": \"9328525\",\n          \"name\": \"Certus One\"\n        }\n      ],\n      \"app_hash\": \"\",\n      \"app_state\": {}\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Peer Gossip Sleep Duration in CometBFT\nDESCRIPTION: Sets the internal sleep duration for the consensus reactor when there is no message to send to a peer. This generic sleep allows other reactor routines to run when a reactor routine has no work to do.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_90\n\nLANGUAGE: toml\nCODE:\n```\npeer_gossip_sleep_duration = \"100ms\"\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for CheckTx in CometBFT\nDESCRIPTION: HTTP request example for the check_tx endpoint that validates a transaction without executing it.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_37\n\nLANGUAGE: sh\nCODE:\n```\ncurl  http://127.0.0.1:26657/v1/check_tx?tx=encoded_tx\n```\n\n----------------------------------------\n\nTITLE: Vote Message Definition\nDESCRIPTION: Protobuf definition for Vote message type used in consensus voting\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-027-p2p-message-bandwidth-report.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\n// Referenced at proto/tendermint/types/types.pb.go#L468\nmessage Vote {\n  // Implied from reference but not shown in snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Building ABCI Forum Application\nDESCRIPTION: Commands to build the ABCI v2 forum application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd abci/tutorials/abci-v2-forum-app\ngo build\n```\n\n----------------------------------------\n\nTITLE: Message Delay Parameter\nDESCRIPTION: Specifies the MSGDELAY parameter that bounds the maximum end-to-end delay for proposal message delivery between correct processes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-sysmodel.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n**[PBTS-MSG-DELAY.0]**\n\nThere exists a system parameter `MSGDELAY` for end-to-end delays of proposal messages,\nsuch for any two correct processes `p` and `q`:\n\n- If `p` sends a proposal message `m` at real time `t` and `q` receives `m` at\n  real time `t'`, then `t <= t' <= t + MSGDELAY`.\n```\n\n----------------------------------------\n\nTITLE: Defining RequestBeginBlock Message Structure in Protobuf\nDESCRIPTION: Updates the RequestBeginBlock message to include more comprehensive validator information, including a LastCommitInfo and byzantine validators.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-009-ABCI-design.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestBeginBlock {\n  bytes hash\n  Header header\n  LastCommitInfo last_commit_info\n  repeated Evidence byzantine_validators\n}\n\nmessage LastCommitInfo {\n  int32 CommitRound\n  repeated SigningValidator validators\n}\n\nmessage SigningValidator {\n    Validator validator\n    bool signed_last_block\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Trust Period for State Sync in CometBFT (TOML)\nDESCRIPTION: Defines the period during which validators can be trusted. For Cosmos SDK-based chains, this should typically be about 2/3 of the unbonding period.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_76\n\nLANGUAGE: toml\nCODE:\n```\ntrust_period = \"168h0m0s\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Subscription Clients for CometBFT RPC (TOML)\nDESCRIPTION: Sets the limit on the number of unique client identifiers that can simultaneously subscribe to events using the `/subscribe` RPC endpoint. This helps manage resources consumed by event subscriptions. The value must be an integer greater than or equal to 0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_21\n\nLANGUAGE: toml\nCODE:\n```\nmax_subscription_clients = 100\n```\n\n----------------------------------------\n\nTITLE: Configuring Mempool Type in CometBFT (TOML)\nDESCRIPTION: Specifies the type of mempool to use. 'flood' is the original CometBFT mempool, while 'nop' disables the mempool, leaving transaction handling to the ABCI application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_57\n\nLANGUAGE: toml\nCODE:\n```\ntype = \"flood\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Info-Level Logging in Go for Block Commits\nDESCRIPTION: Example of a proper info-level log message for block commits, targeting operators and application developers. It includes only the necessary information (height and hash) without dumping full block data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nlogger.Info(\"Committed block\", \"height\", height, \"appHash\", appHash)\n```\n\n----------------------------------------\n\nTITLE: Building LaTeX Documentation for CometBFT Consensus Protocol\nDESCRIPTION: Commands to compile the LaTeX documentation into a PDF file. The process requires multiple passes through pdflatex and bibtex to properly generate citations and references.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/consensus-paper/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ pdflatex paper\n$ bibtex paper\n$ pdflatex paper\n$ pdflatex paper\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ open paper.pdf\n```\n\n----------------------------------------\n\nTITLE: Test Results Table for Rotating Node Scenario\nDESCRIPTION: Markdown table showing the test results for the rotating node scenario, including the date, version, and outcome.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/CometBFT-QA-38.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Scenario | Date       | Version                                                    | Result |\n| -------- | ---------- | ---------------------------------------------------------- | ------ |\n| Rotating | 2023-05-23 | v0.38.0-alpha.2 (e9abb116e29beb830cf111b824c8e2174d538838) | Pass   |\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Persistent Peers Max Dial Period in TOML\nDESCRIPTION: Sets the maximum pause between successive connection attempts to persistent peers. A value of \"0s\" applies exponential backoff.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_43\n\nLANGUAGE: toml\nCODE:\n```\npersistent_peers_max_dial_period = \"0s\"\n```\n\n----------------------------------------\n\nTITLE: Getting Block Results Retain Height in CometBFT\nDESCRIPTION: Go code example demonstrating how to retrieve the current block results retain height using the privileged gRPC client in CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nretainHeight, err := conn.GetBlockResultsRetainHeight(ctx)\nif err != nil {\n    // Do something with the error\n} else {\n    // Do something with the `retainHeight` value\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Validator Key File Path in TOML for CometBFT\nDESCRIPTION: Specifies the path to the JSON file containing the private key for the validator in the consensus protocol. The path can be relative to $CMTHOME or an absolute path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\npriv_validator_key_file = \"config/priv_validator_key.json\"\n```\n\n----------------------------------------\n\nTITLE: Lane Type Definition in Golang\nDESCRIPTION: Definition of the Lane type in the mempool implementation, represented as a uint32 to store the priority value of a lane.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-118-mempool-lanes.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\ntype Lane uint32\n```\n\n----------------------------------------\n\nTITLE: Vote Extensions Test Cases Summary\nDESCRIPTION: Markdown table summarizing the test cases for different vote extension sizes, including the test name, extension size, and test date.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/CometBFT-QA-38.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Name     | Extension Size (bytes) | Date       |\n| -------- | ---------------------- | ---------- |\n| baseline | 8 (varint)             | 2023-05-26 |\n| 2k       | 2048                   | 2023-05-29 |\n| 4k       | 4094                   | 2023-05-29 |\n| 8k       | 8192                   | 2023-05-26 |\n| 16k      | 16384                  | 2023-05-26 |\n| 32k      | 32768                  | 2023-05-26 |\n```\n\n----------------------------------------\n\nTITLE: BFT Time Example Configuration\nDESCRIPTION: Example configuration showing voting power distribution and timestamp calculation using the MedianTime method with four validators.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/bft-time.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Four validators p1, p2, p3 and p4, with voting power\\n  distribution: (p1, 23), (p2, 27), (p3, 10), (p4, 10)\\n- Precommit messages: (p1, 100), (p2, 98), (p3, 1000), (p4, 500)\\n- block.LastCommit contains Precommits of validators p2, p3 and p4\\n- MedianTime calculation:\\n  - value 98 (p2) counted 27 times\\n  - value 1000 (p3) counted 10 times\\n  - value 500 (p4) counted 10 times\\n  - Resulting median: 98\n```\n\n----------------------------------------\n\nTITLE: Running Built-in CometBFT Node\nDESCRIPTION: Commands for initializing and starting a CometBFT node with built-in configuration using the e2e application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nmake node\ncometbft init validator\nCMTHOME=$HOME/.cometbft ./build/node ./node/built-in.toml\n```\n\n----------------------------------------\n\nTITLE: Setting Compaction Interval in CometBFT using TOML\nDESCRIPTION: Configures the number of blocks to wait before triggering compaction after pruning. This parameter should be tuned based on the retain height to balance overhead and efficiency.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_96\n\nLANGUAGE: toml\nCODE:\n```\ncompaction_interval = '1000'\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Block Service in TOML\nDESCRIPTION: Enables the gRPC block service which returns block information. This setting is ignored if grpc.laddr is empty.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_35\n\nLANGUAGE: toml\nCODE:\n```\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Setting Block Sync Version in CometBFT (TOML)\nDESCRIPTION: Specifies the version of block synchronization to use. Currently, only 'v0' is supported, with other versions being deprecated.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_80\n\nLANGUAGE: toml\nCODE:\n```\nversion = \"v0\"\n```\n\n----------------------------------------\n\nTITLE: Running a Testnet with a Custom Output Directory in Shell\nDESCRIPTION: Executes the CometBFT end-to-end test runner (`./build/runner`) using the CI testnet manifest (`networks/ci.toml`), but specifies a custom directory (`networks/foo/bar/`) for storing the generated testnet files using the `-d` flag.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./build/runner -f networks/ci.toml -d networks/foo/bar/\n```\n\n----------------------------------------\n\nTITLE: Ed25519 Private Validator Key Configuration in CometBFT (JSON)\nDESCRIPTION: Example of a priv_validator_key.json file using Ed25519 encryption. Contains the wallet address, public key, and private key for consensus signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/priv_validator_key.json.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"address\": \"E74FBE24164CFC4F88E311C3AC92E63D0DC310D8\",\n  \"pub_key\": {\n    \"type\": \"tendermint/PubKeyEd25519\",\n    \"value\": \"UjxDQgVTlHJOZ7axpMl/iczMIJXiQpFxCFjwKGvzYqE=\"\n  },\n  \"priv_key\": {\n    \"type\": \"tendermint/PrivKeyEd25519\",\n    \"value\": \"9giFjwnmAKCAI95l4Q32kXsau+itGrbsvz84CTLxGnJSPENCBVOUck5ntrGkyX+JzMwgleJCkXEIWPAoa/NioQ==\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Proto Files with Make\nDESCRIPTION: Command to automatically format Protocol Buffer definition files using clang-format via a make target.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake proto-format\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for Ivy Proofs using Docker Compose (Bash)\nDESCRIPTION: This shell command uses Docker Compose to build a Docker image based on the configuration specified in a `docker-compose.yml` file (not shown). This image encapsulates the necessary environment, including the Ivy tool, required to check the Tendermint proofs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/ivy-proofs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose build\n```\n\n----------------------------------------\n\nTITLE: Baseline v0.34.x Transaction Rate Comparison Table\nDESCRIPTION: Markdown table showing baseline transaction rates across different connection (c) and rate (r) combinations for comparison purposes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/TMCore-QA-37.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|        |  c=1  |  c=2  |  c=4  |\n| :---   | ----: | ----: | ----: |\n| r=25   |  2225 | 4450  | 8900  |\n| r=50   |  4450 | 8900  | 17800 |\n| r=100  |  8900 | 17800 | 35400 |\n| r=200  | 17800 | 35600 | 37358 |\n```\n\n----------------------------------------\n\nTITLE: Configuring P2P Listen Address in TOML\nDESCRIPTION: Sets the TCP socket address for the P2P service to listen on and accept connections.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_39\n\nLANGUAGE: toml\nCODE:\n```\nladdr = \"tcp://0.0.0.0:26656\"\n```\n\n----------------------------------------\n\nTITLE: Declaring LightStore Add Function Signature in Go\nDESCRIPTION: Specifies the signature for the `Add` method on the `LightStore`. This function is intended to add a `newBlock` (presumably of type `LightBlock`) into the light store. It expects the lightstore to be initially empty as a precondition.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (ls LightStore) Add(newBlock)\n```\n\n----------------------------------------\n\nTITLE: Running Socket-based CometBFT Node\nDESCRIPTION: Commands for initializing and running a CometBFT node using socket-based configuration.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nmake node\ncometbft init validator\ncometbft start\n./build/node ./node.socket.toml\n```\n\n----------------------------------------\n\nTITLE: Implementing ABCI Request Logging in InitChain Method\nDESCRIPTION: Code showing how to create and log an ABCI request in the InitChain method of the Application. An empty request object is created and passed to the logging function.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc (app *Application) InitChain(_ context.Context, req *abci.InitChainRequest) (*abci.InitChainResponse, error) {\n\tr := &abci.Request{Value: &abci.Request_InitChain{InitChain: &abci.InitChainRequest{}}}\n\terr := app.logABCIRequest(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining VerifyStatus Enumeration in Protocol Buffers\nDESCRIPTION: Defines an enumeration for VerifyStatus used in VerifyVoteExtension responses. It includes UNKNOWN (error state), ACCEPT (valid vote extension), and REJECT (invalid vote extension) statuses.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_12\n\nLANGUAGE: protobuf\nCODE:\n```\nenum VerifyStatus {\n  UNKNOWN = 0; // Unknown status. Returning this from the application is always an error.\n  ACCEPT  = 1; // Status that signals that the application finds the vote extension valid.\n  REJECT  = 2; // Status that signals that the application finds the vote extension invalid.\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Block Consensus Parameters in v1.0\nDESCRIPTION: Updated default block consensus parameters in CometBFT v1.0. The max_bytes value has been reduced and max_gas now has a positive limit instead of unlimited.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_22\n\nLANGUAGE: json\nCODE:\n```\n    \"block\": {\n      \"max_bytes\": \"4194304\",\n      \"max_gas\": \"10000000\"\n    },\n```\n\n----------------------------------------\n\nTITLE: Configuring TrustMetric with Custom Parameters in Go\nDESCRIPTION: Definition of the TrustMetricConfig struct for customizing trust metric behavior. Allows configuration of weights for proportional and integral elements, tracking window duration, and interval length.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// TrustMetricConfig - Configures the weight functions and time intervals for the metric\ntype TrustMetricConfig struct {\n    // Determines the percentage given to current behavior\n    ProportionalWeight float64\n\n    // Determines the percentage given to prior behavior\n    IntegralWeight float64\n\n    // The window of time that the trust metric will track events across.\n    // This can be set to cover many days without issue\n    TrackingWindow time.Duration\n\n    // Each interval should be short for adapability.\n    // Less than 30 seconds is too sensitive,\n    // and greater than 5 minutes will make the metric numb\n    IntervalLength time.Duration\n}\n\n// DefaultConfig returns a config with values that have been tested and produce desirable results\nfunc DefaultConfig() TrustMetricConfig {}\n\n// NewMetricWithConfig returns a trust metric with a custom configuration\nfunc NewMetricWithConfig(tmc TrustMetricConfig) *TrustMetric {}\n\n// ------------------------------------------------------------------------------------------------\n// For example\n\nconfig := TrustMetricConfig{\n    TrackingWindow: time.Minute * 60 * 24, // one day\n    IntervalLength:    time.Minute * 2,\n}\n\ntm := NewMetricWithConfig(config)\n\ntm.BadEvents(10)\ntm.Pause()\ntm.GoodEvents(1) // becomes active again\n```\n\n----------------------------------------\n\nTITLE: Referencing Socket Server for ABCI in Go\nDESCRIPTION: This snippet refers to the socket server implementation for ABCI in Go, which handles communication between Tendermint core and applications using a custom remote procedure protocol with wire-format protobuf messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-002-ipc-ecosystem.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n\"abci/server/socket_server.go\"\n```\n\n----------------------------------------\n\nTITLE: Defining EventCallback type in Go\nDESCRIPTION: Defines the EventCallback type as a function that takes EventData as an argument.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype EventCallback func(data EventData)\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Block Retain Height for Data Companion in CometBFT using TOML\nDESCRIPTION: Configures the initial value for the data companion block retain height if not explicitly set. This affects the minimum height of blocks retained during pruning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_99\n\nLANGUAGE: toml\nCODE:\n```\ndouble_sign_check_height = 0\n```\n\n----------------------------------------\n\nTITLE: Chunked Genesis Data Response Format in CometBFT API\nDESCRIPTION: Example response structure for the genesis_chunked endpoint showing chunk index, total number of chunks, and base64-encoded data. This format enables efficient transfer of large genesis documents.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_22\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n     \"chunk\": 0,\n     \"total\": 10,\n     \"data\": \"dGVuZGVybWludAo=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Tendermint Validity Violations in Go\nDESCRIPTION: The violatesTMValidity function verifies whether a given evidence header violates Tendermint's validity properties when compared to a reference header. Ensures validators adhere to predefined consensus integrity checks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc violatesTMValidity(ref Header, ev Header) boolean\n```\n\n----------------------------------------\n\nTITLE: Checking NTP Status with timedatectl\nDESCRIPTION: Shell command to verify NTP service status and enable it if inactive.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ntimedatectl\n```\n\nLANGUAGE: shell\nCODE:\n```\ntimedatectl set-ntp true\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Encoded Key from CometBFT Query Response (Bash)\nDESCRIPTION: This command uses `echo` to pass the Base64 encoded key (`Um9u`) from the `/abci_query` response to the `base64 -d` utility, which decodes it back to the original sender name (`Ron`).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\necho Um9u | base64 -d\n```\n\n----------------------------------------\n\nTITLE: Enabling the Pruning Service in CometBFT\nDESCRIPTION: Configuration for enabling the gRPC pruning service in CometBFT. This makes the pruning service accessible via the gRPC API, allowing external services to influence the pruning mechanism.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/data-companion/pruning.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n#\n# Configuration specifically for the gRPC pruning service, which is considered a\n# privileged service.\n#\n[grpc.privileged.pruning_service]\n\n# Only controls whether the pruning service is accessible via the gRPC API - not\n# whether a previously set pruning service retain height is honored by the\n# node. See the [storage.pruning] section for control over pruning.\n#\n# Disabled by default.\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Configuring Send Rate in CometBFT (TOML)\nDESCRIPTION: Sets the rate at which packets can be sent, in bytes/second. This limit applies to each P2P connection individually.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_51\n\nLANGUAGE: toml\nCODE:\n```\nsend_rate = 5120000\n```\n\n----------------------------------------\n\nTITLE: Documenting Consensus Step Transitions in Byzantine Protocol (Markdown)\nDESCRIPTION: This snippet visually represents the canonical order of the primary steps—NewHeight, Propose, Prevote, Precommit, Commit—used in the round-based consensus state machine at each blockchain height. It succinctly expresses that rounds may be repeated and cyclical, highlighting the core functional states consensus cycles through in an optimal case. It requires only Markdown for diagrammatic rendering, with no external dependencies and is used for conceptual explanation, not direct execution. The input is implicitly the protocol flow; the output is a technical flow representation. Limitations include its abstract, illustrative nature, lacking operational detail.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/consensus.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\nNewHeight -> (Propose -> Prevote -> Precommit)+ -> Commit -> NewHeight ->...\n```\n\n----------------------------------------\n\nTITLE: EditorConfig Example for Non-Go Code Formatting\nDESCRIPTION: A TOML configuration file for EditorConfig that standardizes formatting for non-Go code files like Makefiles, shell scripts, and Protobuf files across different editors and IDEs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/STYLE_GUIDE.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[Makefile]\nindent_style = tab\n\n[*.sh]\nindent_style = tab\n\n[*.proto]\nindent_style = space\nindent_size = 2\n```\n\n----------------------------------------\n\nTITLE: Tagging Minor Release Version\nDESCRIPTION: Commands for creating and pushing a signed Git tag for a minor release, following a similar process to patch releases.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a v2.1.0 -s -m 'Release v2.1.0'\ngit push origin v2.1.0\n```\n\n----------------------------------------\n\nTITLE: Tagging Patch Release Version\nDESCRIPTION: Commands for creating and pushing a signed Git tag for a patch release after changes have been merged to the backport branch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a v2.0.1 -s -m 'Release v2.0.1'\ngit push origin v2.0.1\n```\n\n----------------------------------------\n\nTITLE: Retrieving Peer ID in Go\nDESCRIPTION: This method returns the unique cryptographic ID of a peer, which is used for identification in the p2p network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nfunc (p Peer) ID() p2p.ID\n```\n\n----------------------------------------\n\nTITLE: Starting Monitoring Services with Docker Compose (Bash)\nDESCRIPTION: This Bash command uses Docker Compose (`docker compose up -d`) to start the Prometheus and Grafana services defined in the `compose.yml` file. The `-d` flag runs the containers in detached mode (in the background). This command requires `docker compose` to be installed and the `prometheus.yml` file to exist in the current directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/monitoring/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Defining P2P Layer Initialization Action in Bluespec\nDESCRIPTION: Defines the `P2P_init` action, responsible for setting the initial state of the P2P layer. It initializes `incomingMsgs` for all nodes to empty lists and sets the `peers` state according to the `InitialPeers` parameter.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_10\n\nLANGUAGE: bluespec\nCODE:\n```\naction P2P_init = all {\n    incomingMsgs' = NodeIDs.mapBy(_ => List()),\n    peers' = NodeIDs.mapBy(n => InitialPeers.get(n)),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LightClientAttackEvidence Struct in Go\nDESCRIPTION: This code snippet shows the proposed structure for LightClientAttackEvidence, which is used to protect light clients from attacks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct { // proposed struct in spec\n  ConflictingBlock *LightBlock\n  CommonHeight int64\n  Type  AttackType     // enum: {Lunatic|Equivocation|Amnesia}\n\n  timestamp time.Time // taken from the block time at the common height\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Vote Extensions in CometBFT Forum App (Go)\nDESCRIPTION: Implements the VerifyVoteExtension method to validate vote extensions. It checks for unknown validators, duplicate words, and ensures the curse word limit is not exceeded.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/8.app.md#2025-04-22_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nfunc (app *ForumApp) VerifyVoteExtension(_ context.Context, req *abci.VerifyVoteExtensionRequest) (*abci.VerifyVoteExtensionResponse, error) {\n\tapp.logger.Info(\"Executing Application VerifyVoteExtension\")\n\n\tif _, ok := app.valAddrToPubKeyMap[string(req.ValidatorAddress)]; !ok {\n\t\t// we do not have a validator with this address mapped; this should never happen\n\t\treturn nil, errors.New(\"unknown validator\")\n\t}\n\n\tcurseWords := strings.Split(string(req.VoteExtension), \"|\")\n\tif hasDuplicateWords(curseWords) {\n\t\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_REJECT}, nil\n\t}\n\n\t// ensure vote extension curse words limit has not been exceeded\n\tif len(curseWords) > CurseWordsLimitVE {\n\t\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_REJECT}, nil\n\t}\n\treturn &abci.VerifyVoteExtensionResponse{Status: abci.VERIFY_VOTE_EXTENSION_STATUS_ACCEPT}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Prometheus Metric Images for CometBFT Tests\nDESCRIPTION: This shell command generates images from Prometheus metrics collected during CometBFT tests. It sets up a Python environment, downloads dependencies, and executes a plotting script with specified parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./script/reports/prometheus-gen-images.sh <experiments-prometheus-dir> <start-time> <duration> [<test-case>] [<release-name>]\n```\n\n----------------------------------------\n\nTITLE: CometBFT Initialization Output\nDESCRIPTION: Example output showing successful initialization of CometBFT with key and genesis file locations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nI[2024-04-23|20:16:43.493] Found private validator                      module=main keyFile=/tmp/forum-app/config/priv_validator_key.json stateFile=/tmp/forum-app/data/priv_validator_state.json\nI[2024-04-23|20:16:43.493] Found node key                               module=main path=/tmp/forum-app/config/node_key.json\nI[2024-04-23|20:16:43.493] Found genesis file                           module=main path=/tmp/forum-app/config/genesis.json\n```\n\n----------------------------------------\n\nTITLE: Secp256k1 Key Example in node_key.json\nDESCRIPTION: Example of a Secp256k1 key in node_key.json. This shows the structure for a different encryption algorithm, where only the private key is stored.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/node_key.json.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"priv_key\": {\n    \"type\": \"tendermint/PrivKeySecp256k1\",\n    \"value\": \"2swJ5TwUhhqjJW+CvVbbSnTGxqpYmb2yvib+MHyDJIU=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comment on Cap'n Proto advantages from Erik Grinaker\nDESCRIPTION: A comment from Erik Grinaker discussing the technical advantages of Cap'n Proto over Protocol Buffers, despite ultimately recommending Protocol Buffers due to wider adoption.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-055-protobuf-design.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nCap'n'Proto is awesome. It was written by one of the original Protobuf developers to fix some of its issues, and supports e.g. random access to process huge messages without loading them into memory and an (opt-in) canonical form which would be very useful when determinism is needed (e.g. in the state machine). That said, I suspect Protobuf is the better choice due to wider adoption, although it makes me kind of sad since Cap'n'Proto is technically better.\n```\n\n----------------------------------------\n\nTITLE: Configuring Tendermint Mode in TOML\nDESCRIPTION: Example of how to specify the Tendermint mode in the config.toml file using a template variable that will be populated during initialization.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-052-tendermint-mode.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nmode = \"{{ .BaseConfig.Mode }}\"\n```\n\n----------------------------------------\n\nTITLE: Setting Prometheus Listen Address in CometBFT using TOML\nDESCRIPTION: Configures the address on which to listen for Prometheus collector connections. This determines where the metrics endpoint will be accessible.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_104\n\nLANGUAGE: toml\nCODE:\n```\nprometheus_listen_addr = \":26660\"\n```\n\n----------------------------------------\n\nTITLE: Defining Attack Condition (CMBC-ATTACK.1)\nDESCRIPTION: Formally defines an 'attack' as a situation where the 'sign-skip-match(a,b,c,t)' property is false for some light blocks 'a', 'b', and 'c' at time 't'. This signifies a violation of agreement, where two different headers ('b' and 'c') for the same height can be verified from a common, valid ancestor block 'a'.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-ATTACK.1]\n\nIf there exists three light blocks a, b, and c, with\n*sign-skip-match(a,b,c,t) = false* then we have an *attack*.  We say\nwe have **an attack at height** *b.Header.Height* and write\n*attack(a,b,c,t)*.\n```\n\n----------------------------------------\n\nTITLE: Importing the events package in Go\nDESCRIPTION: Shows how to import the events package from CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/cometbft/cometbft/libs/events\"\n```\n\n----------------------------------------\n\nTITLE: Example of Code Stuttering to Avoid in Go\nDESCRIPTION: An example of naming that should be avoided due to stuttering, where a struct has a field named after itself, creating redundancy in the code. This is considered poor practice in Go.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/STYLE_GUIDE.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype middleware struct {\n\tmiddleware Middleware\n}\n```\n\n----------------------------------------\n\nTITLE: Tagging API Module Version for Release\nDESCRIPTION: Commands for tagging a new version of the API module with proper semantic versioning, which is needed when the last released version is too old or doesn't contain the latest proto changes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a api/v2.0.0 -s -m \"Release api module v2.0.0\" origin/v2.x\ngit push origin api/v2.0.0\n```\n\n----------------------------------------\n\nTITLE: Example Log Level Configuration in TOML Manifest\nDESCRIPTION: Shows an example of the `log_level` setting within a generated TOML testnet manifest. This line is added when the testnet generator is run with the `-l` or `--log-level` flag, configuring the logging verbosity for CometBFT nodes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\nlog_level = \"debug\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Data from CometBFT Test Network\nDESCRIPTION: This make command retrieves all relevant data from the CometBFT testnet into the orchestrating machine. It collects experiment results for further analysis.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nmake retrieve-data\n```\n\n----------------------------------------\n\nTITLE: Generating Grammar Parsers using Make and gogll (Shell)\nDESCRIPTION: This make command, executed from the `e2e` directory, triggers the `gogll` program. `gogll` takes `abci_grammar_clean_start.md` and `abci_grammar_recovery.md` as input and generates Go lexer and parser code, storing it in the respective `grammar-auto` subdirectories. This is the command used to auto-generate the lexer and parser code based on the defined grammars.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/pkg/grammar/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake grammar-gen\n```\n\n----------------------------------------\n\nTITLE: Fetching Blockchain Headers via HTTP and JSON-RPC in Shell\nDESCRIPTION: Details the process of making HTTP and JSON-RPC requests to obtain blockchain headers, using optional height parameters to limit results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/blockchain\n\ncurl http://127.0.0.1:26657/v1/blockchain?minHeight=1&maxHeight=2\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"blockchain\\\",\\\"params\\\":{\\\"minHeight\\\":\\\"1\\\", \\\"maxHeight\\\":\\\"2\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Setting Mempool WAL Directory\nDESCRIPTION: Configuration for the write-ahead log directory path for mempool.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_61\n\nLANGUAGE: toml\nCODE:\n```\nwal_dir = \"\"\n```\n\n----------------------------------------\n\nTITLE: Defining FilePVKey and FilePVLastSignState structs in Go\nDESCRIPTION: This code defines two new structs, FilePVKey for storing immutable parts of PrivValidator, and FilePVLastSignState for storing mutable parts. These structs separate concerns and improve file management.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-034-priv-validator-file-structure.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// FilePVKey stores the immutable part of PrivValidator\ntype FilePVKey struct {\n\tAddress types.Address  `json:\"address\"`\n\tPubKey  crypto.PubKey  `json:\"pub_key\"`\n\tPrivKey crypto.PrivKey `json:\"priv_key\"`\n\n\tfilePath string\n}\n\n// FilePVState stores the mutable part of PrivValidator\ntype FilePVLastSignState struct {\n\tHeight    int64        `json:\"height\"`\n\tRound     int          `json:\"round\"`\n\tStep      int8         `json:\"step\"`\n\tSignature []byte       `json:\"signature,omitempty\"`\n\tSignBytes cmn.HexBytes `json:\"signbytes,omitempty\"`\n\n\tfilePath string\n\tmtx      sync.Mutex\n}\n```\n\n----------------------------------------\n\nTITLE: Registering IPC Methods in Go\nDESCRIPTION: Example code demonstrating the proposed approach for registering RPC routes and event bus topics in components. Shows how components like consensus would receive methods to register endpoints and topics through their constructor.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-016-node-architecture.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Methods from the RPC and event bus that would be passed into the constructor of components like \"consensus\"\n// NOTE: This is a hypothetical construction to convey the idea. An actual implementation may differ.\nfunc RegisterRoute(path string, handler func(http.ResponseWriter, *http.Request))\n\nfunc RegisterTopic(name string) EventPublisher\n\ntype EventPublisher func (context.Context, types.EventData, []abci.Event)\n```\n\n----------------------------------------\n\nTITLE: Querying Prometheus for Timestamp Differences\nDESCRIPTION: PromQL query to calculate the ratio of untimely to timely proposals, helping identify clock synchronization issues.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_0\n\nLANGUAGE: promql\nCODE:\n```\nconsensus_proposal_timestamp_difference_count{is_timely=\"false\"} /\nconsensus_proposal_timestamp_difference_count{is_timely=\"true\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Core Block Structure in Protobuf\nDESCRIPTION: Main Block message definition containing Header, Data, Evidence list and last commit information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Block {\n  Header                        header      = 1;\n  Data                          data        = 2;\n  tendermint.types.EvidenceList evidence    = 3;\n  Commit                        last_commit = 4;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Load Runner for CometBFT Tests\nDESCRIPTION: This make command initializes the load runner for CometBFT performance tests. It's part of the setup process for running load tests on the network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nmake loadrunners-init\n```\n\n----------------------------------------\n\nTITLE: Configuring flush throttle timeout in CometBFT\nDESCRIPTION: Setting for configuring the time to wait before flushing messages out on the connection. This parameter controls how frequently messages are sent over network connections.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_14\n\nLANGUAGE: toml\nCODE:\n```\nflush_throttle_timeout = \"10ms\"\n```\n\n----------------------------------------\n\nTITLE: Validating Unbonding Period and Evidence - Tendermint - Go\nDESCRIPTION: Specifies the ValidAndVerifiedUnbonding function, which evaluates if the provided trusted and untrusted light blocks satisfy unbonding and verification conditions for attack evidence. The main dependency is on properly formed LightBlock inputs; it checks time conditions relative to the unbonding period rather than the trusting period. It outputs a Result used in subsequent decision logic.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc ValidAndVerifiedUnbonding(trusted LightBlock, untrusted LightBlock) Result\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Companion Pruning in TOML\nDESCRIPTION: Configuration for Data Companion pruning service including options to enable the service and set initial retain height values for blocks and block results.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_11\n\nLANGUAGE: toml\nCODE:\n```\n#\n# Storage pruning configuration relating only to the data companion.\n#\n[storage.pruning.data_companion]\n\n# Whether automatic pruning respects values set by the data companion. Disabled\n# by default. All other parameters in this section are ignored when this is\n# disabled.\n#\n# If disabled, only the application retain height will influence block pruning\n# (but not block results pruning). Only enabling this at a later stage will\n# potentially mean that blocks below the application-set retain height at the\n# time will not be available to the data companion.\nenabled = false\n\n# The initial value for the data companion block retain height if the data\n# companion has not yet explicitly set one. If the data companion has already\n# set a block retain height, this is ignored.\ninitial_block_retain_height = 0\n\n# The initial value for the data companion block results retain height if the\n# data companion has not yet explicitly set one. If the data companion has\n# already set a block results retain height, this is ignored.\ninitial_block_results_retain_height = 0\n```\n\n----------------------------------------\n\nTITLE: Defining Remove Peer Event Structure in Go\nDESCRIPTION: Structure for remove peer events that signal the closing of a connection to a peer due to misbehavior, containing the peer's ID.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\ntype EventRemovePeer struct {\n  PeerID ID\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Block Interval in CometBFT\nDESCRIPTION: Configuration to set a delay between the creation of empty blocks in CometBFT, using command line flag or config file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n--consensus.create_empty_blocks_interval=\"5s\"\n```\n\nLANGUAGE: toml\nCODE:\n```\n[consensus]\ncreate_empty_blocks_interval = \"5s\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Open Connections for Instrumentation in CometBFT using TOML\nDESCRIPTION: Sets the maximum number of simultaneous connections for the instrumentation endpoint. A value of 0 allows unlimited connections.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_105\n\nLANGUAGE: toml\nCODE:\n```\nmax_open_connections = 3\n```\n\n----------------------------------------\n\nTITLE: Monitoring Chrony NTP Synchronization\nDESCRIPTION: Shell command to check the status of chrony NTP daemon and tracking information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nchronyc tracking\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Set for Attack Detection - TLA+\nDESCRIPTION: This TLA+ snippet presents concrete parameters (e.g. from LCD_MC4_4_faulty.tla) for testing light client attack detection models. It includes node set definitions, trusting periods, dual correctness flags (for both primary and secondary nodes), and faulty validator rates, establishing the environment for formal analysis of the detection protocol. Used by Apalache model checker in the attack detection experimental phase.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_3\n\nLANGUAGE: TLA+\nCODE:\n```\nAllNodes == {\"n1\", \"n2\", \"n3\", \"n4\"}\nTRUSTED_HEIGHT == 1\nTARGET_HEIGHT == 3\nTRUSTING_PERIOD == 1400     \\* the trusting period in some time units\nCLOCK_DRIFT = 10            \\* how much we assume the local clock is drifting\nREAL_CLOCK_DRIFT = 3        \\* how much the local clock is actually drifting\nIS_PRIMARY_CORRECT == FALSE\nIS_SECONDARY_CORRECT == FALSE\nFAULTY_RATIO == <<1, 3>>    \\* < 1 / 3 faulty validators\n\n```\n\n----------------------------------------\n\nTITLE: Referencing Local ABCI Client in Go\nDESCRIPTION: This snippet refers to the local ABCI client implementation in Go, which optimizes communication between the Tendermint core and applications written in Go by using direct in-process calls.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-002-ipc-ecosystem.md#2025-04-22_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n\"abci/client/local_client.go\"\n```\n\n----------------------------------------\n\nTITLE: Running the Key-Value Store Application\nDESCRIPTION: This command starts the key-value store application with a specified home directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n./kvstore -kv-home /tmp/badger-home\n```\n\n----------------------------------------\n\nTITLE: Running E2E Go Tests Manually Against a Started Testnet in Shell\nDESCRIPTION: Demonstrates how to run the Go end-to-end tests manually. First, it starts the testnet defined in `networks/ci.toml` using the runner's `start` stage. Then, it sets the `E2E_MANIFEST` environment variable to point to the manifest and executes the Go tests located in the `./tests/` directory using `go test`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\n./build/runner -f networks/ci.toml start\nE2E_MANIFEST=networks/ci.toml go test -v ./tests/...\n```\n\n----------------------------------------\n\nTITLE: Defining Version struct for Block Header in Go\nDESCRIPTION: This code snippet defines the Version struct to be included in the block header. It contains fields for Block and App versions, providing a complete description of the consensus-critical protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-016-protocol-versions.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Version struct {\n    Block uint64\n    App uint64\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Good Changelog Entries in Markdown\nDESCRIPTION: Examples of well-written changelog entries that clearly explain the benefits or purpose of changes for users, following the project's standards.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n- `[consensus]` Small transaction throughput improvement (approximately 3-5\\% from preliminary tests) through refactoring the way we use channels ([\\#1111](https://github.com/cometbft/cometbft/issues/1111))\n- `[mempool]` Refactor Go API to be able to easily swap out the current mempool implementation in CometBFT forks ([\\#1112](https://github.com/cometbft/cometbft/issues/1112))\n- `[p2p]` Automatically ban peers when their messages are unsolicited or are received too frequently ([\\#1113](https://github.com/cometbft/cometbft/issues/1113))\n```\n\n----------------------------------------\n\nTITLE: Rendering Package Documentation with Go Templates\nDESCRIPTION: This snippet uses Go templates to render package documentation. It includes the package comment, examples, and iterates through functions to display their documentation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/rpc/core/doc_template.txt#2025-04-22_snippet_0\n\nLANGUAGE: Go Template\nCODE:\n```\n{{with .PDoc}}\n{{comment_md .Doc}}\n{{example_html $ \"\"}}\n\n{{range .Funcs}}{{$name_html := html .Name}}## [{{$name_html}}]({{posLink_url $ .Decl}})\n{{comment_md .Doc}}{{end}}\n{{end}}\n```\n\n----------------------------------------\n\nTITLE: Submitting a Transaction with a Curse Word via CometBFT RPC (Bash)\nDESCRIPTION: This command uses curl to send a transaction containing a potential curse word (`message:muggle`) to the `/broadcast_tx_commit` endpoint. The application logic is expected to reject this transaction during proposal processing (`PrepareProposal`), resulting in a timeout error.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"sender:Malfoy,message:muggle\"'\n```\n\n----------------------------------------\n\nTITLE: Managing systemd-timesyncd Service\nDESCRIPTION: Shell commands to monitor and restart the systemd-timesyncd service.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ntimedatectl timesync-status --monitor\n```\n\nLANGUAGE: shell\nCODE:\n```\ntimedatectl set-ntp false\ntimedatectl set-ntp true\n```\n\n----------------------------------------\n\nTITLE: Setting Tendermint Mode via Command Line\nDESCRIPTION: Command line example showing how to start Tendermint in validator mode using the mode flag.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-052-tendermint-mode.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntendermint start --mode validator\n```\n\n----------------------------------------\n\nTITLE: Setting Instrumentation Namespace in CometBFT using TOML\nDESCRIPTION: Defines the namespace for Prometheus instrumentation metrics. This helps in organizing and identifying metrics from CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_106\n\nLANGUAGE: toml\nCODE:\n```\nnamespace = \"cometbft\"\n```\n\n----------------------------------------\n\nTITLE: Validating Transactions in Mempool\nDESCRIPTION: This snippet models a simple deterministic validation function that always returns true for transactions. It's a placeholder for a more complex application-specific validation process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_1\n\nLANGUAGE: bluespec\nCODE:\n```\npure def valid(tx) = true\n```\n\n----------------------------------------\n\nTITLE: Configuring mempool max_txs_bytes in CometBFT v0.38.x\nDESCRIPTION: Default configuration for the maximum size of all transactions in the mempool in CometBFT v0.38.x. The value has been lowered in v1.0 to reduce resource consumption.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\nmax_txs_bytes = 1073741824\n```\n\n----------------------------------------\n\nTITLE: Structuring RFC Document in Markdown\nDESCRIPTION: This snippet outlines the structure of an RFC document, including sections for changelog, abstract, background, references, and discussion. It provides guidelines for content in each section.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-template.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# RFC {RFC-NUMBER}: {TITLE}\n\n## Changelog\n\n- {date}: {changelog}\n\n## Abstract\n\n> A brief high-level synopsis of the topic of discussion for this RFC, ideally\n> just a few sentences.  This should help the reader quickly decide whether the\n> rest of the discussion is relevant to their interest.\n\n## Background\n\n> Any context or orientation needed for a reader to understand and participate\n> in the substance of the Discussion. If necessary, this section may include\n> links to other documentation or sources rather than restating existing\n> material, but should provide enough detail that the reader can tell what they\n> need to read to be up-to-date.\n\n### References\n\n> Links to external materials needed to follow the discussion may be added here.\n>\n> In addition, if the discussion in a request for comments leads to any design\n> decisions, it may be helpful to add links to the ADR documents here after the\n> discussion has settled.\n\n## Discussion\n\n> This section contains the core of the discussion.\n>\n> There is no fixed format for this section, but ideally changes to this\n> section should be updated before merging to reflect any discussion that took\n> place on the PR that made those changes.\n```\n\n----------------------------------------\n\nTITLE: Monitoring Prevote Delays by Proposer\nDESCRIPTION: PromQL query to analyze the difference in seconds between proposal timestamps and prevotes for each proposer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/proposer-based-timestamps-runbook.md#2025-04-22_snippet_1\n\nLANGUAGE: promql\nCODE:\n```\nsum(consensus_quorum_prevote_delay) by (proposer_address)\n```\n\n----------------------------------------\n\nTITLE: Handling CheckTx Response Code in Go\nDESCRIPTION: Code reference showing where transaction validation occurs in the mempool implementation. This snippet is referenced in the context of handling duplicate transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Reference to mempool/v0/clist_mempool.go#L247\n```\n\n----------------------------------------\n\nTITLE: Disseminating Transactions to Peers\nDESCRIPTION: Defines how a node disseminates transactions to peer nodes by iterating over 'txs'. Nodes send transactions to specified peers using wrapper functions for messaging.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_12\n\nLANGUAGE: bluespec\nCODE:\n```\naction disseminateNextTx(node, _mkTargetNodes, _mkTxMsg) = all {\n    // Check that the current index is within bounds. \n    require(node.TxsIndex() < node.Txs().length()),\n    // Get from the mempool the next transaction to disseminate.\n    val tx = node.Txs()[node.TxsIndex()]\n    all {\n        // Wrap transaction in a message and send it to the target nodes.\n        incomingMsgs' = \n            node.multiSend(incomingMsgs, _mkTargetNodes(node, tx), _mkTxMsg(tx)),\n        // Increase index.\n        mempool' = mempool.update(node, st => { txsIndex: st.txsIndex + 1, ...st }),\n        peers' = peers,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning CometBFT Repository\nDESCRIPTION: Command to clone the CometBFT repository from GitHub.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/cometbft/cometbft\n```\n\n----------------------------------------\n\nTITLE: Running Protobuf Tasks with Make Commands\nDESCRIPTION: Commands for working with Protocol Buffers in the CometBFT project, including linting, compatibility checking, code generation, and formatting.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Lint all of the .proto files\nmake proto-lint\n\n# Check if any of your local changes (prior to committing to the Git repository)\n# are breaking\nmake proto-check-breaking\n\n# Generate Go code from the .proto files\nmake proto-gen\n```\n\n----------------------------------------\n\nTITLE: Defining SynchronyParams in Go for CometBFT PBTS\nDESCRIPTION: This Go struct defines the SynchronyParams, which include Precision and MessageDelay durations used in the PBTS algorithm to determine if a proposed timestamp is acceptable.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-112-proposer-based-timestamps.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype SynchronyParams struct {\n        Precision    time.Duration `json:\"precision,string\"`\n        MessageDelay time.Duration `json:\"message_delay,string\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Building Changelog with Unclog\nDESCRIPTION: Command for building a changelog with the unclog tool without officially releasing the version. This is used during pre-release preparation to collect all changes under the Unreleased heading.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nunclog build -a > CHANGELOG.md\n```\n\n----------------------------------------\n\nTITLE: Querying CometBFT Status via HTTP and JSON-RPC in Shell\nDESCRIPTION: Demonstrates HTTP and JSON-RPC requests to retrieve comprehensive CometBFT status details using curl, without any parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/status\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"status\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Receive Rate in CometBFT (TOML)\nDESCRIPTION: Sets the rate at which packets can be received, in bytes/second. This limit applies to each P2P connection individually.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_52\n\nLANGUAGE: toml\nCODE:\n```\nrecv_rate = 5120000\n```\n\n----------------------------------------\n\nTITLE: Firing an event in EventCache in Go\nDESCRIPTION: Method to cache an event to be fired upon finality in EventCache.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc (evc *EventCache) FireEvent(event string, data EventData)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Network Information via HTTP and JSON-RPC in Shell\nDESCRIPTION: Describes how to make HTTP and JSON-RPC requests to fetch network information using curl. This action also requires no parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl http://127.0.0.1:26657/v1/net_info\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"net_info\\\"}\"\n```\n\n----------------------------------------\n\nTITLE: Using Fanout Observer for Testing in Go\nDESCRIPTION: Example of how to use a fanout observer in testing scenarios. This allows tests to observe events without directly subscribing to the event bus, simplifying test setup and making dependencies explicit.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_4\n\nLANGUAGE: golang\nCODE:\n```\nstate.SetObserver(\n    NewStateFanoutObserver(\n        // An observer specifically for use during testing.\n        newTestStateObserver(),\n        // ... other observers here that would be used in production\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Running condiff Tool for TOML Comparison\nDESCRIPTION: Command to run the condiff tool which performs a keyspace diff between two TOML configuration files.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-019-config-version.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngo run ./scripts/confix/condiff old.toml new.toml\n```\n\n----------------------------------------\n\nTITLE: Submitting a Transaction for a Banned User via CometBFT RPC (Bash)\nDESCRIPTION: This command uses curl to attempt sending a transaction from a user (`sender:Malfoy`) who was previously identified for sending a curse word and may now be banned. The transaction, sent to `/broadcast_tx_commit`, is expected to be rejected during the `CheckTx` phase with a specific error code indicating the user is banned.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"sender:Malfoy,message:heroic\"'\n```\n\n----------------------------------------\n\nTITLE: Updating Vote Structure in Go\nDESCRIPTION: Modifies the Vote struct by removing the Timestamp field, as it is no longer required for the proposer-based timestamp mechanism.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-071-proposer-based-timestamps.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Vote struct {\n\tType             tmproto.SignedMsgType `json:\"type\"`\n\tHeight           int64                 `json:\"height\"`\n\tRound            int32                 `json:\"round\"`\n\tBlockID          BlockID               `json:\"block_id\"` // zero if vote is nil.\n\tValidatorAddress Address               `json:\"validator_address\"`\n\tValidatorIndex   int32                 `json:\"validator_index\"`\n\tSignature        []byte                `json:\"signature\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Pruning Interval in TOML\nDESCRIPTION: Configuration for the pruning interval parameter which controls the time period between automated background pruning operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n# The time period between automated background pruning operations.\ninterval = \"10s\"\n```\n\n----------------------------------------\n\nTITLE: Getting Validator Addresses in Go\nDESCRIPTION: The Addresses function extracts validator addresses from a list of validators. Used in conjunction with other functions to establish validator identities involved in attacks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nfunc Addresses(vals Validator[]) ValidatorAddress[]\n```\n\n----------------------------------------\n\nTITLE: 200-Node Testnet Transaction Rate Table for v0.37.x\nDESCRIPTION: Markdown table showing transaction rates across different connection (c) and rate (r) combinations for the 200-node testnet using v0.37.x.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/TMCore-QA-37.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|        |  c=1  |  c=2  |  c=4  |\n| :---   | ----: | ----: | ----: |\n| r=25   |  2225 | 4450  | 8900  |\n| r=50   |  4450 | 8900  | 17800 |\n| r=100  |  8900 | 17800 | 35600 |\n| r=200  | 17800 | 35600 | 38660 |\n```\n\n----------------------------------------\n\nTITLE: Modifying PrepareProposal API in Rust for CometBFT\nDESCRIPTION: Updates the PrepareProposal function to accept a Block and UnbatchedHeader, returning BlockData and a Header. This change allows for batch optimization of vote extension data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-013-abci++.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn PrepareProposal(Block, UnbatchedHeader) -> (BlockData, Header)\n```\n\n----------------------------------------\n\nTITLE: Installing go-flowrate Package Using Go Get\nDESCRIPTION: Command to install the go-flowrate package using Go's package management system. This package provides flow rate control functionality.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/flowrate/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/mxk/go-flowrate/flowrate\n```\n\n----------------------------------------\n\nTITLE: Setting Persistent Peer Gossip Limits\nDESCRIPTION: Experimental setting to limit number of persistent peers receiving transaction broadcasts.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_67\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_max_gossip_connections_to_persistent_peers = 0\n```\n\n----------------------------------------\n\nTITLE: Tagging API Module for Patch Release\nDESCRIPTION: Commands for tagging a new patch version of the API module when needed for a patch release, using semantic versioning with the api/ prefix.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a api/v2.0.1 -s -m \"Release api module v2.0.1\" origin/v2.x\ngit push origin api/v2.0.1\n```\n\n----------------------------------------\n\nTITLE: Node Disconnection in Bluespec\nDESCRIPTION: Outlines the steps for a node to disconnect from the network, ensuring all relevant attributes and states are updated to reflect this disconnection accurately.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_12\n\nLANGUAGE: bluespec\nCODE:\n```\nall {\n    require(size(nodesInNetwork) > 1),\n    nondet node = oneOf(nodesInNetwork) \n    peers' = peers.disconnect(node),\n    incomingMsgs' = incomingMsgs,\n    mempool' = mempool,\n    senders' = senders,\n    dr' = dr,\n    rc' = rc,\n},\n```\n\n----------------------------------------\n\nTITLE: Querying a specific key from the KVStore\nDESCRIPTION: cURL command to retrieve the value for a specific key from the KVStore application.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/abci_query?data=\"name\"'\n```\n\n----------------------------------------\n\nTITLE: Formatting Git Commit Messages for CometBFT\nDESCRIPTION: This example demonstrates the correct format for git commit messages in the CometBFT project, following the Conventional Commits spec. It includes a type, scope, description, and optional body with issue reference.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nfix(cmd/cometbft/commands/debug): execute p.Signal only when p is not nil\n\n[potentially longer description in the body]\n\nFixes #nnnn\n```\n\n----------------------------------------\n\nTITLE: Alternative Design for Vote and SignedVote Types in CometBFT\nDESCRIPTION: Alternative approach where the Vote type doesn't include a signature, and a separate SignedVote type includes both the Vote and its Signature. This shows the request/reply pattern specific to votes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-024-sign-bytes.md#2025-04-22_snippet_1\n\nLANGUAGE: proto\nCODE:\n```\nVote {\n    // all fields besides signature\n}\n\nSignedVote {\n Vote Vote\n Signature []byte\n}\n\nSignVoteRequest {\n   Vote Vote\n}\n\nSignedVoteReply {\n    Vote SignedVote\n    Err  Error\n}\n```\n\n----------------------------------------\n\nTITLE: Changed P2P Flush Throttle Timeout Parameter in TOML\nDESCRIPTION: The flush_throttle_timeout parameter in the p2p section has had its default value lowered in v1.0 compared to v0.38.x.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_13\n\nLANGUAGE: toml\nCODE:\n```\n# Time to wait before flushing messages out on the connection\nflush_throttle_timeout = \"100ms\"\n```\n\n----------------------------------------\n\nTITLE: Modified Proposer Selection with Priority Centering (Pseudocode)\nDESCRIPTION: This pseudocode presents an enhanced proposer selection algorithm introduced to handle validator set changes more robustly. Before computing priorities, it calculates the average priority (`avg`) of the current validator set (`vset`) and subtracts this average from each validator's accumulated priority (`A(i)`). This centering step helps prevent priority values from drifting towards extreme values due to validator additions or removals. The subsequent steps for increasing priorities based on voting power (`VP(i)`), selecting the proposer (`prop`), and reducing the proposer's priority by the total power (`P`) remain the same as the basic algorithm.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n    def ProposerSelection (vset):\n\n        // center priorities around zero\n        avg = sum(A(i) for i in vset)/len(vset)\n        for each validator i in vset:\n            A(i) -= avg\n\n        // compute priorities and elect proposer\n        for each validator i in vset:\n            A(i) += VP(i)\n        prop = max(A)\n        A(prop) -= P\n```\n\n----------------------------------------\n\nTITLE: Unique Transactions Invariant in Mempool\nDESCRIPTION: This property checks that the list of transactions in the mempool for each node contains no duplicates, crucial for maintaining consistency.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_13\n\nLANGUAGE: bluespec\nCODE:\n```\nval uniqueTxsInMempool = \n    NodeIDs.forall(node => size(node.Txs().listToSet()) == length(node.Txs()))\n```\n\n----------------------------------------\n\nTITLE: Starting Rotating Node Script for CometBFT Tests\nDESCRIPTION: This make command starts a script that creates ephemeral nodes and kills them when they catch up. It's part of the rotating node testnet experiment for CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nmake rotate\n```\n\n----------------------------------------\n\nTITLE: BLST Library Notes - Go Implementation\nDESCRIPTION: Reference to BLST (blast) library implementation in Go, which is actively used in Ethereum 2.0's Prysm client and undergoing formal verification. Benchmarks show public key aggregation of 128 keys takes 2.43ms with 1.5ms signature verification time.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-018-bls-agg-exploration.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nblst public key aggregation: 128 keys = 2.43ms\nsignature verification time = 1.5ms\ntotal verification time = 3.9ms\n```\n\n----------------------------------------\n\nTITLE: Legacy Query Interface Requirement\nDESCRIPTION: Code reference showing that custom indexers must implement legacy search and query APIs for compatibility with event subscription RPC API, though most implementations simply return errors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-012-custom-indexing.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nevent subscription RPC API[event-rpc]\n```\n\n----------------------------------------\n\nTITLE: Publishing Events in CometBFT Consensus\nDESCRIPTION: The consensus system in CometBFT publishes events, which could be affected by slowdowns in the event system due to unbuffered channels and blocking writes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-003-performance-questions.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nconsensus-event-send: https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/internal/consensus/state.go#L1573\n```\n\n----------------------------------------\n\nTITLE: Starting Local Prometheus Server for CometBFT Test Analysis\nDESCRIPTION: This shell command starts a local Prometheus server using data from CometBFT experiments. It kills any running Prometheus server, unzips the database, and bootstraps the server with the downloaded data.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./script/reports/prometheus-start-local.sh <experiments-prometheus-dir>\n```\n\n----------------------------------------\n\nTITLE: Initial Mempool State Configuration\nDESCRIPTION: Specifies the initial configuration for the mempool state across nodes, mapping them to a newly initialized state with empty 'cache' and 'txs'.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_9\n\nLANGUAGE: bluespec\nCODE:\n```\naction MP_init = all {\n    P2P_init,\n    mempool' = NodeIDs.mapBy(n => initialMempoolState),\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecated ABCI Consensus Parameters\nDESCRIPTION: ABCI consensus parameters that have been deprecated in CometBFT v1.0. These parameters should no longer be used in the genesis file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n    \"abci\": {\n      \"vote_extensions_enable_height\": \"0\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Double Sign Check Height in CometBFT\nDESCRIPTION: Sets how many blocks to look back to check for consensus votes before joining consensus. When non-zero, this parameter helps prevent validator double signing by checking if the current consensus key was used for any precommit in the specified block range.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_87\n\nLANGUAGE: toml\nCODE:\n```\ndouble_sign_check_height = 0\n```\n\n----------------------------------------\n\nTITLE: Referencing OpenAPI Specification File in CometBFT\nDESCRIPTION: This code snippet shows the relative path to the OpenAPI specification file that needs to be updated when changes are made to any endpoint in the CometBFT project.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/rpc/core/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n../openapi/openapi.yaml\n```\n\n----------------------------------------\n\nTITLE: Handling Node Disconnection in Bluespec\nDESCRIPTION: Describes the procedure for updating a node's state upon detecting a peer disconnection. The node resets routes related to the peer and adjusts redundancy settings accordingly.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_18\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\naction updateDisconnectedPeer(node, peer) = all {\n    peers' = peers.update(node, ps => ps.exclude(Set(peer))),\n    dr' = dr.update(node, drs => drs.resetRoutes(peer)),\n    node.adjustRedundancy(),\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Go environment variables in Bash\nDESCRIPTION: Adds GOPATH and PATH environment variables to the Bash profile for Go development.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/getting-started.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\necho export GOPATH=\\\"\\$HOME/go\\\" >> ~/.bash_profile\necho export PATH=\\\"\\$PATH:\\$GOPATH/bin\\\" >> ~/.bash_profile\n```\n\n----------------------------------------\n\nTITLE: Migrating CometBFT Configuration Version\nDESCRIPTION: Command to migrate an existing configuration file to a new version. Example shows migration to v0.38 configuration format.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/confix/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncometbft config migrate v0.38 # migrates defaultHome/config/config.toml to the latest v0.38 config\n```\n\n----------------------------------------\n\nTITLE: BlockIDFlag Enum Definition in Go\nDESCRIPTION: Defines the enum representing a validator's participation in consensus, indicating whether they were absent, committed to the majority block, or voted nil.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nenum BlockIDFlag {\n  BLOCK_ID_FLAG_UNKNOWN = 0; // indicates an error condition\n  BLOCK_ID_FLAG_ABSENT  = 1; // the vote was not received\n  BLOCK_ID_FLAG_COMMIT  = 2; // voted for the block that received the majority\n  BLOCK_ID_FLAG_NIL     = 3; // voted for nil\n}\n```\n\n----------------------------------------\n\nTITLE: Test Result Documentation in Markdown\nDESCRIPTION: Documents the test execution details including date and version hash for CometBFT performance testing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/TMCore-QA-34.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n### Test Result\n\n**Result: N/A**\n\nDate: 2022-10-10\n\nVersion: a28c987f5a604ff66b515dd415270063e6fb069d\n```\n\n----------------------------------------\n\nTITLE: Initializing Mempool State\nDESCRIPTION: This snippet initializes the mempool state for each node, mapping nodes to their initial 'MempoolState'.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_4\n\nLANGUAGE: bluespec\nCODE:\n```\nvar mempool: NodeID -> MempoolState\n```\n\n----------------------------------------\n\nTITLE: Setting Peer Gossip Intraloop Sleep Duration in CometBFT\nDESCRIPTION: Configures the upper bound for random sleep duration in consensus reactor. When set to non-zero, random sleeps are inserted in reactor routines to reduce the number of BlockPart and Vote messages sent when waiting for HasProposalBlockPart or HasVote messages.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_91\n\nLANGUAGE: toml\nCODE:\n```\npeer_gossip_intraloop_sleep_duration = \"0s\"\n```\n\n----------------------------------------\n\nTITLE: Defining Mempool Transaction Iterator Index\nDESCRIPTION: Defines an index within 'MempoolState' to track the next transaction to disseminate. It increments with each dissemination operation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_7\n\nLANGUAGE: bluespec\nCODE:\n```\ntxsIndex: int,\n```\n\n----------------------------------------\n\nTITLE: Integrating Mempool in Bluespec Module\nDESCRIPTION: Demonstrates the integration of various components of the mempool within a Bluespec module, including imports, types, parameters, states, actions, and properties.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_14\n\nLANGUAGE: bluespec\nCODE:\n```\n// -*- mode: Bluespec; -*-\n\n// File generated from markdown using https://github.com/driusan/lmt. DO NOT EDIT.\n\nmodule mempool {\n    import spells.* from \"./spells\"\n    import p2p.* from \"./p2p\"\n    export p2p.*\n\n    //--------------------------------------------------------------------------\n    // Types\n    //--------------------------------------------------------------------------\n    <<<types>>>\n\n    //--------------------------------------------------------------------------\n    // Parameters\n    //--------------------------------------------------------------------------\n    <<<params>>>\n\n    //--------------------------------------------------------------------------\n    // State\n    //--------------------------------------------------------------------------\n    <<<state>>>\n    \n    type MempoolState = {\n        <<<mempoolstate>>>\n    }\n    \n    // Auxiliary definitions\n    <<<auxstate>>>\n\n    //--------------------------------------------------------------------------\n    // Actions\n    //--------------------------------------------------------------------------\n    <<<actions>>>\n\n    //--------------------------------------------------------------------------\n    // Properties\n    //--------------------------------------------------------------------------\n    <<<properties>>>\n\n}\n```\n\n----------------------------------------\n\nTITLE: Updating CometBFT Test Configuration\nDESCRIPTION: This series of commands updates the configuration for CometBFT tests, including generating new configs and restarting the network. It's used when changing parameters like vote extension size.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nmake configgen\nANSIBLE_SSH_RETRIES=10 ansible-playbook ./ansible/re-init-testapp.yaml -u root -i ./ansible/hosts --limit=validators -e \"testnet_dir=testnet\" -f 20\nmake restart\n```\n\n----------------------------------------\n\nTITLE: Example Calculation of Initial Priority for New Validator (Pseudocode)\nDESCRIPTION: This pseudocode demonstrates the calculation of the initial priority (`A(p3)`) for a new validator `p3` added to a set with existing validators having voting powers 1 and 3, and `p3` having a voting power of 8. The total power (`P`) is 1 + 3 + 8 = 12. The initial priority is calculated as -1.125 * 12, which approximates to -13 due to integer arithmetic used in the actual implementation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n    A(p3) = -1.125 * (1 + 3 + 8) ~ -13\n```\n\n----------------------------------------\n\nTITLE: Handling Proposer Priority Int64 Overflow - Go\nDESCRIPTION: This snippet defines constants for the max and min values of int64 in Go, preventing overflow or underflow during proposer priority computations. It ensures proposer priorities stay within the int64 limits during selection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\n    MaxInt64  =  1 << 63 - 1\n    MinInt64  = -1 << 63\n```\n\n----------------------------------------\n\nTITLE: Raw Interval Data Access with Fading Memories\nDESCRIPTION: Formula for accessing raw interval data for the current time interval, implementing the fading memories performance optimization that reduces space complexity while maintaining sufficient historical context.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-006-trust-metric.md#2025-04-22_snippet_5\n\nLANGUAGE: math\nCODE:\n```\nR[0] = raw data for current time interval\n```\n\n----------------------------------------\n\nTITLE: Enabling Prometheus Metrics in CometBFT using TOML\nDESCRIPTION: Toggles the presentation of Prometheus metrics at a specified endpoint. When enabled, metrics are served under the '/metrics' endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_103\n\nLANGUAGE: toml\nCODE:\n```\nprometheus = false\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Request Header Size for CometBFT RPC (TOML)\nDESCRIPTION: Defines the maximum allowed total size, in bytes, for the headers of an incoming RPC request. Requests with headers exceeding this size will be rejected. The value must be an integer greater than or equal to 0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_29\n\nLANGUAGE: toml\nCODE:\n```\nmax_header_bytes = 1048576\n```\n\n----------------------------------------\n\nTITLE: Using git bisect for Configuration Tracking\nDESCRIPTION: This code snippet demonstrates the process for using `git bisect` to determine when a configuration setting was removed from the codebase. It shows the steps to initialize the bisect process and how to ascertain checkpoints between endpoints. Requires a Git environment with a local copy of the repository.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-019-config-version.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout master\ngit bisect start\ngit bisect bad\ngit bisect good v0.34.0-dev1\n```\n\nLANGUAGE: shell\nCODE:\n```\nif git grep -q '\\[fastsync\\]' config ; then git bisect good ; else git bisect bad ; fi\n```\n\n----------------------------------------\n\nTITLE: Initial Mempool State Definition\nDESCRIPTION: Defines the 'initialMempoolState' with empty cache, transactions list, and a starting index of zero.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_10\n\nLANGUAGE: bluespec\nCODE:\n```\nval initialMempoolState = {\n    cache: Set(),\n    txs: List(),\n    txsIndex: 0,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Database Compaction in TOML\nDESCRIPTION: Configuration for database compaction parameters which control whether to force database compaction and how frequently to trigger it.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n# If set to true, CometBFT will force compaction to happen for databases that support this feature.\n# and save on storage space. Setting this to true is most benefits when used in combination\n# with pruning as it will physically delete the entries marked for deletion.\n# false by default (forcing compaction is disabled).\ncompact = false\n```\n\nLANGUAGE: toml\nCODE:\n```\n# To avoid forcing compaction every time, this parameter instructs CometBFT to wait\n# the given amount of blocks to be pruned before triggering compaction.\n# It should be tuned depending on the number of items. If your retain height is 1 block,\n# it is too much of an overhead to try compaction every block. But it should also not be a very\n# large multiple of your retain height as it might occur bigger overheads.\ncompaction_interval = \"1000\"\n```\n\n----------------------------------------\n\nTITLE: Running Model Checking with Apalache\nDESCRIPTION: This shell script snippet is used to execute model checking experiments using the Apalache model checker. It requires the Apalache build to be available in a specified directory. The script is essential for verifying the TLA+ specifications and theorem conditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/accountability/Synopsis.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./run.sh\n```\n\n----------------------------------------\n\nTITLE: Example Merkle Tree Layouts with Arbitrary Number of Items - Markdown\nDESCRIPTION: Provides an ASCII visualization of a Merkle tree with 6 and 7 items to explain tree balancing and splitting logic. Used for documentation and education purposes in understanding how leaves and inner nodes are arranged, especially when the number of items is not a power of two. Has no input/output and requires no dependencies.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/encoding.md#2025-04-22_snippet_5\n\nLANGUAGE: md\nCODE:\n```\n   Simple Tree with 6 items           Simple Tree with 7 items\n\n              *                                  *\n             / \\                                / \\\n           /     \\                            /     \\\n         /         \\                        /         \\\n       /             \\                    /             \\\n      *               *                  *               *\n     / \\             / \\                / \\             / \\\n    /   \\           /   \\              /   \\           /   \\\n   /     \\         /     \\            /     \\         /     \\\n  *       *       h4     h5          *       *       *       h6\n / \\     / \\                        / \\     / \\     / \\\nh0  h1  h2 h3                      h0  h1  h2  h3  h4  h5\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Schema from SQL File\nDESCRIPTION: Shell command to create the required PostgreSQL schema for the psql indexer type using the provided schema.sql file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npsql ... -f state/indexer/sink/psql/schema.sql\n```\n\n----------------------------------------\n\nTITLE: Setting the config.toml version in CometBFT\nDESCRIPTION: Specifies the version of the CometBFT binary that created or last modified the config file. Must be a valid semantic version string or empty.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nversion = \"1.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Running Prometheus Metrics Visualization\nDESCRIPTION: Example command for running the prometheus_plotter.py script to generate plots from Prometheus metrics data with specified parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/scripts/qa/reporting/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./prometheus_plotter.py <release_name> <start_time> <window_size> <test_case>\n```\n\n----------------------------------------\n\nTITLE: Detecting Light Client Attacks in Go\nDESCRIPTION: Function signature for the AttackDetector, which takes a trusted root and a verified light store to detect potential attacks and generate evidence.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nEvidences := AttackDetector(root_of_trust, verifiedLS);\n```\n\n----------------------------------------\n\nTITLE: Verification Condition for Sequential Headers\nDESCRIPTION: Formal condition expressing the relationship between signers of an untrusted header and validators of a trusted header for sequential block heights.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\nsigners(untrustedSignedHeader.Commit) \\subseteq validators(trustedHeader.NextValidatorsHash)\n```\n\n----------------------------------------\n\nTITLE: Executing CometBFT Debug Kill Command\nDESCRIPTION: Command to kill a CometBFT process while collecting debug information into a compressed archive. The command requires process ID, output path, and home directory as parameters.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncometbft debug kill <pid> </path/to/out.zip> --home=</path/to/app.d>\n```\n\n----------------------------------------\n\nTITLE: Running Fuzz Tests with Go Tool\nDESCRIPTION: This snippet demonstrates how to execute fuzz tests on specific Tendermint packages using the Go tool. It requires Go 1.20 or newer to leverage native fuzzing capabilities. Commands target 'Mempool', 'P2PSecretConnection', and 'RPCJSONRPCServer' packages, assessing their robustness against unexpected inputs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/fuzz/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Running fuzz tests for various Tendermint components\n\ngo test -fuzz Mempool ./tests\ngo test -fuzz P2PSecretConnection ./tests\ngo test -fuzz RPCJSONRPCServer ./tests\n\n```\n\n----------------------------------------\n\nTITLE: Extracting Signers from Commit in Go\nDESCRIPTION: The Signers function retrieves all validator addresses related to a specific commit. This functionality is crucial in comparing signatories during equivocation detection.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_002_reviewed.md#2025-04-22_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nfunc Signers(commit Commit) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Exporting Raw Latency Data to CSV with `report` (Bash)\nDESCRIPTION: This command runs the `report` tool, similar to the previous example, analyzing a `pebbledb` blockstore located in `~/.cometbft/data`. However, it adds the `--csv out.csv` flag, instructing the tool to output the raw latency data for each experiment (identified by a UUID generated by `load`) into a CSV file named `out.csv` instead of printing summary statistics to the console. This allows for external analysis using other tools.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/loadtime/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./build/report --database-type pebbledb --data-dir ~/.cometbft/data --csv out.csv\n```\n\n----------------------------------------\n\nTITLE: Transaction Dissemination in Bluespec\nDESCRIPTION: Implements the logic for determining target nodes for transaction dissemination. The node avoids sending transactions to peers with disabled routes, managing dissemination based on active peer routes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_17\n\nLANGUAGE: bluespec\nCODE:\n```\n\"actions\" +=\ndef mkTargetNodes(node, tx) =\n    val txSenders = node.sendersOf(hash(tx))\n    val disabledTargets = \n        if (length(txSenders) > 0)\n            node.DisabledRoutes().routesWithSource(txSenders[0]).mapTargets()\n        else Set()\n    node.Peers()\n        .exclude(txSenders.listToSet())\n        .exclude(disabledTargets)\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies List\nDESCRIPTION: Specifies exact versions of Python packages required for the project. Includes libraries for data manipulation (pandas, numpy), visualization (matplotlib), image processing (Pillow), and monitoring (prometheus-pandas).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/scripts/qa/reporting/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncontourpy==1.0.5\ncycler==0.11.0\nfonttools==4.43.0\nkiwisolver==1.4.4\nmatplotlib==3.6.3\nnumpy==1.26.4\npackaging==21.3\nPillow==10.2.0\npyparsing==3.0.9\npython-dateutil==2.8.2\nsix==1.16.0\npandas==1.5.3\nprometheus-pandas==0.3.2\nrequests==2.31.0\n```\n\n----------------------------------------\n\nTITLE: Configuring Experimental WebSocket Write Buffer Size in CometBFT RPC (TOML)\nDESCRIPTION: EXPERIMENTAL: Sets the maximum number of events buffered for each WebSocket client. If a client cannot read events fast enough from the WebSocket, exceeding this buffer can lead to disconnection. Increasing this may help prevent disconnections for slow clients but increases memory usage. It should ideally be set greater than or equal to `experimental_subscription_buffer_size`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_24\n\nLANGUAGE: toml\nCODE:\n```\nexperimental_websocket_write_buffer_size = 200\n```\n\n----------------------------------------\n\nTITLE: Executing TLA+ Model Checker Command\nDESCRIPTION: Shell command to run model checking on MC_PBT_2C_2F.tla specification. Sets length parameter to 8, includes invariant 'Inv', initialization 'CInit', and keeps disabled states with specified flags.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/tla/experiment_data/May2022/MC_PBT_2C_2F.tla/run.txt#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncheck --length=8 --inv=Inv --cinit=CInit --discard-disabled=false MC_PBT_2C_2F.tla\n```\n\n----------------------------------------\n\nTITLE: Defining AmnesiaEvidence Structure in Golang\nDESCRIPTION: This structure combines PotentialAmnesiaEvidence with a ProofOfLockChange to form complete evidence. It's created when an honest node has justification for voting in multiple rounds and provides that proof during the trial period.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-056-light-client-amnesia-attacks.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\ntype AmnesiaEvidence struct {\n\t*types.PotentialAmnesiaEvidence\n\tPolc   *types.ProofOfLockChange\n}\n```\n\n----------------------------------------\n\nTITLE: LightBlockRequest Protocol Buffer Message Definition\nDESCRIPTION: Protocol buffer message definition for requesting a light block at a specific height through the P2P network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-080-reverse-sync.md#2025-04-22_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage LightBlockRequest {\n  uint64 height = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Storage Compaction in CometBFT using TOML\nDESCRIPTION: Sets the compact flag to enable forced compaction for supported databases, saving storage space. This is particularly useful when combined with pruning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_95\n\nLANGUAGE: toml\nCODE:\n```\ncompact = false\n```\n\n----------------------------------------\n\nTITLE: Event Sink Interface Reference\nDESCRIPTION: Reference to the EventSink interface that combines transaction and block indexer interfaces with service plumbing. This interface allows developers to implement custom storage engines for event indexing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-012-custom-indexing.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`EventSink`][esink]\n```\n\n----------------------------------------\n\nTITLE: Running End-to-End Tests for CometBFT\nDESCRIPTION: This bash snippet shows the commands to run end-to-end tests for the CometBFT network. It involves changing to the test directory, building the test runner, and executing it with a specific configuration file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd test/e2e && \\\n  make && \\\n  ./build/runner -f networks/ci.toml\n```\n\n----------------------------------------\n\nTITLE: Running CometBFT Inspect Command\nDESCRIPTION: Command to start the inspect tool for querying CometBFT's state store and block store over RPC. Used for debugging crashed processes.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncometbft inspect --home=</path/to/app.d>\n```\n\n----------------------------------------\n\nTITLE: Mempool Transaction Message Definition\nDESCRIPTION: Protobuf definition for mempool transaction messages\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-027-p2p-message-bandwidth-report.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\n// Referenced at proto/tendermint/mempool/types.proto#L6\nmessage Txs {\n  // Implied from reference but not shown in snippet\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Misbehaving Processes in Go\nDESCRIPTION: Describes the logic for identifying and acting on misbehaving validators in the event of detected light client attacks. It includes functions to identify lunatic, equivocation, and amnesia attacks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/notes-on-evidence-handling.md#2025-04-22_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc detectMisbehavingProcesses(lcAttackEvidence LightClientAttackEvidence, bc Blockchain) []ValidatorAddress {\n   assume IsValid(lcaEvidence, bc)\n\n   // lunatic light client attack\n   if !isValidBlock(current.Header, conflictingBlock.Header) {\n        conflictingCommit = lcAttackEvidence.ConflictingBlock.Commit\n        bondedValidators = GetNextValidators(bc, lcAttackEvidence.CommonHeight)\n\n        return getSigners(conflictingCommit) intersection GetAddresses(bondedValidators)\n\n   // equivocation light client attack\n   } else if current.Header.Round == conflictingBlock.Header.Round {\n        conflictingCommit = lcAttackEvidence.ConflictingBlock.Commit\n        trustedCommit = bc[conflictingBlock.Header.Height+1].LastCommit\n\n        return getSigners(trustedCommit) intersection getSigners(conflictingCommit)\n\n   // amnesia light client attack\n   } else {\n        HandleAmnesiaAttackEvidence(lcAttackEvidence, bc)\n   }\n}\n\n// Block validity in this context is defined by the trusted header.\nfunc isValidBlock(trusted Header, conflicting Header) boolean {\n    return trusted.ValidatorsHash == conflicting.ValidatorsHash and\n           trusted.NextValidatorsHash == conflicting.NextValidatorsHash and\n           trusted.ConsensusHash == conflicting.ConsensusHash and\n           trusted.AppHash == conflicting.AppHash and\n           trusted.LastResultsHash == conflicting.LastResultsHash\n}\n\nfunc getSigners(commit Commit) []ValidatorAddress {\n    signers = []ValidatorAddress\n    for (i, commitSig) in commit.Signatures {\n        if commitSig.BlockIDFlag == BlockIDFlagCommit {\n            signers.append(commitSig.ValidatorAddress)\n        }\n    }\n    return signers\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Consensus Peer Gossip Sleep Duration in TOML\nDESCRIPTION: Configuration for the new peer_gossip_intraloop_sleep_duration parameter in the consensus section with a default value of 0 seconds.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\npeer_gossip_intraloop_sleep_duration = \"0s\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Deprecated Websocket Warning in Tendermint\nDESCRIPTION: Example log warning message for deprecated websocket RPC access that will be removed in a future version.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-019-config-version.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nWARNING: Websocket RPC access is deprecated and will be removed in\\nTendermint v0.37. See https://tinyurl.com/adr075 for more information.\n```\n\n----------------------------------------\n\nTITLE: Defining Status Response Message Structure in Go\nDESCRIPTION: Structure for status response messages that include the sequence number of the corresponding request and the current height of the responding peer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MessageStatusResponse struct {\n  SeqNum int64     // sequence number of the corresponding request\n  Height int64     // current peer height\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Set for Commit Verification - TLA+\nDESCRIPTION: This snippet shows a concrete parameter set (from a file such as MC4_3_faulty.tla) used to instantiate the TLA+ formal specification of the Light Client commit verification protocol. These parameters define the nodes, heights, trusting period, clock drift assumptions, primary correctness, and faulty validator ratio, which guide model-checking scenarios. Requires TLA+ to interpret and is used by Apalache for verifying protocol properties.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_0\n\nLANGUAGE: TLA+\nCODE:\n```\nAllNodes == {\"n1\", \"n2\", \"n3\", \"n4\"}\nTRUSTED_HEIGHT == 1\nTARGET_HEIGHT == 3\nTRUSTING_PERIOD == 1400     \\* the trusting period in some time units\nCLOCK_DRIFT = 10            \\* how much we assume the local clock is drifting\nREAL_CLOCK_DRIFT = 3        \\* how much the local clock is actually drifting\nIS_PRIMARY_CORRECT == FALSE\nFAULTY_RATIO == <<1, 3>>    \\* < 1 / 3 faulty validators\n\n```\n\n----------------------------------------\n\nTITLE: Ensuring Agreement with Less Than a Third Faulty in TLA+\nDESCRIPTION: This TLA+ theorem asserts that when less than a third of processes are faulty, the invariant TypedInv implies Agreement, preventing forks. It is part of the logical reasoning within the TLA+ framework used to ensure consensus properties under certain Byzantine fault conditions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/accountability/Synopsis.md#2025-04-22_snippet_1\n\nLANGUAGE: TLA+\nCODE:\n```\nTHEOREM AgreementWhenLessThanThirdFaulty ==\n    LessThanThirdFaulty /\\ TypedInv => Agreement\n```\n\n----------------------------------------\n\nTITLE: ABCI Protocol Buffer Definition Reference\nDESCRIPTION: References the protocol buffer definition file that contains all ABCI messages and methods specifications. The file is located in the CometBFT repository under the proto directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/README.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nproto/cometbft/abci/v1/types.proto\n```\n\n----------------------------------------\n\nTITLE: Protocol Buffer Definition for ResetRoute Message\nDESCRIPTION: Protocol Buffer definition for the ResetRoute message, which is sent by a node to reset disabled routes and allow transaction forwarding to resume from a specific peer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-119-dog-mempool-gossip.md#2025-04-22_snippet_2\n\nLANGUAGE: proto\nCODE:\n```\nmessage ResetRoute {\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Tendermint Imports in Cosmos SDK\nDESCRIPTION: This code snippet shows a command output listing the number of Tendermint imports in the Cosmos SDK, excluding tests. It helps identify which APIs are most commonly used by external projects.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-060-go-api-stability.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n      1 github.com/tendermint/tendermint/abci/server\n     73 github.com/tendermint/tendermint/abci/types\n      2 github.com/tendermint/tendermint/cmd/tendermint/commands\n      7 github.com/tendermint/tendermint/config\n     68 github.com/tendermint/tendermint/crypto\n      1 github.com/tendermint/tendermint/crypto/armor\n     10 github.com/tendermint/tendermint/crypto/ed25519\n      2 github.com/tendermint/tendermint/crypto/encoding\n      3 github.com/tendermint/tendermint/crypto/merkle\n      3 github.com/tendermint/tendermint/crypto/sr25519\n      8 github.com/tendermint/tendermint/crypto/tmhash\n      1 github.com/tendermint/tendermint/crypto/xsalsa20symmetric\n     11 github.com/tendermint/tendermint/libs/bytes\n      2 github.com/tendermint/tendermint/libs/bytes.HexBytes\n     15 github.com/tendermint/tendermint/libs/cli\n      2 github.com/tendermint/tendermint/libs/cli/flags\n      2 github.com/tendermint/tendermint/libs/json\n     30 github.com/tendermint/tendermint/libs/log\n      1 github.com/tendermint/tendermint/libs/math\n     11 github.com/tendermint/tendermint/libs/os\n      4 github.com/tendermint/tendermint/libs/rand\n      1 github.com/tendermint/tendermint/libs/strings\n      5 github.com/tendermint/tendermint/light\n      1 github.com/tendermint/tendermint/internal/mempool\n      3 github.com/tendermint/tendermint/node\n      5 github.com/tendermint/tendermint/internal/p2p\n      4 github.com/tendermint/tendermint/privval\n     10 github.com/tendermint/tendermint/proto/tendermint/crypto\n      1 github.com/tendermint/tendermint/proto/tendermint/libs/bits\n     24 github.com/tendermint/tendermint/proto/tendermint/types\n      3 github.com/tendermint/tendermint/proto/tendermint/version\n      2 github.com/tendermint/tendermint/proxy\n      3 github.com/tendermint/tendermint/rpc/client\n      1 github.com/tendermint/tendermint/rpc/client/http\n      2 github.com/tendermint/tendermint/rpc/client/local\n      3 github.com/tendermint/tendermint/rpc/core/types\n      1 github.com/tendermint/tendermint/rpc/jsonrpc/server\n     33 github.com/tendermint/tendermint/types\n      2 github.com/tendermint/tendermint/types/time\n      1 github.com/tendermint/tendermint/version\n```\n\n----------------------------------------\n\nTITLE: Verifying ABCI Recovery Grammar Compliance in Go\nDESCRIPTION: This Go function signature defines the `verifyRecovery` method for the `GrammarChecker` type. It takes an `execution` string (representing a sequence of ABCI requests) and utilizes the auto-generated lexer and parser (based on `abci_grammar_recovery.md`) to check if the sequence conforms to the recovery grammar. It returns a slice of `Error` pointers, highlighting any deviations from the expected grammar.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/pkg/grammar/README.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (g *GrammarChecker) verifyRecovery(execution string) []*Error\n```\n\n----------------------------------------\n\nTITLE: Configuring mempool max_txs_bytes in CometBFT v1.0\nDESCRIPTION: Updated default configuration for the maximum size of all transactions in the mempool in CometBFT v1.0. The value has been reduced from the previous version.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_16\n\nLANGUAGE: toml\nCODE:\n```\nmax_txs_bytes = 67108864\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Routing in DOG Protocol in Quint\nDESCRIPTION: Definitions for routing mechanism that filters transaction messages between nodes. Includes route type definition and disabled routes tracking for each node to manage active connections.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/dog.md#2025-04-22_snippet_1\n\nLANGUAGE: bluespec\nCODE:\n```\ntype Route = (NodeID, NodeID)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\nvar dr: NodeID -> Set[Route]\n```\n\nLANGUAGE: bluespec\nCODE:\n```\ndef DisabledRoutes(node) = dr.get(node)\npure def disableRoute(routes, route) = routes.join(route)\npure def enableRoute(routes, route) = routes.exclude(Set(route))\npure def isSourceOrTargetIn(node, route) = node == route._1 or node == route._2\npure def routesWithSource(routes, source) = routes.filter(r => r._1 == source)\npure def routesWithTarget(routes, target) = routes.filter(r => r._2 == target)\npure def mapTargets(routes) = routes.map(r => r._2)\n```\n\nLANGUAGE: bluespec\nCODE:\n```\npure def resetRoutes(routes, peer) = \n    routes.filter(route => not(peer.isSourceOrTargetIn(route)))\n```\n\n----------------------------------------\n\nTITLE: Generating Multi-Version Testnets with Latest Release and Local Code in Shell\nDESCRIPTION: Generates multi-version testnet manifests using the `latest` keyword to automatically detect the most recent non-pre-release tag close to the local version. The `-m \"latest:1,local:2\"` flag configures 1/3rd of the nodes to run the detected latest version and 2/3rds to run the locally built code. Requires corresponding Docker images.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n# Using \"latest\" will cause the generator to auto-detect the latest\n# non-pre-release version tag in the current Git repository that is closest to\n# the CometBFT version in the current local code (as specified in\n# ../../version/version.go).\n#\n# In the example below, if the local version value is \"v0.34.24\",\n# for example, and the latest official release is v0.34.23, then 1/3rd of the\n# network will run v0.34.23 and the remaining 2/3rds will run the E2E node built\n# from the local code.\n./build/generator -m \"latest:1,local:2\" -d networks/generated/\n```\n\n----------------------------------------\n\nTITLE: Defining Non-deterministic Network Join Action in Bluespec\nDESCRIPTION: Defines the `pickNodeAndJoin` action to model spontaneous node joining. It non-deterministically selects a `node` not currently in the network and a non-empty `peerSet` from existing network nodes, then invokes the `joinNetwork` action for them.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_13\n\nLANGUAGE: bluespec\nCODE:\n```\naction pickNodeAndJoin = all {\n    // Pick a node that is not connected to the network.\n    require(NodeIDs.exclude(nodesInNetwork).nonEmpty()),\n    nondet node = oneOf(NodeIDs.exclude(nodesInNetwork))\n    // Pick a non-empty set of nodes in the network to be the node's peers.\n    nondet peerSet = oneOf(nodesInNetwork.powerset().exclude(Set()))\n    node.joinNetwork(peerSet),\n}\n```\n\n----------------------------------------\n\nTITLE: Building Tendermint from Source\nDESCRIPTION: This snippet outlines the steps to create a local build of Tendermint version v0.32. It includes checking out the appropriate branch, fetching dependencies, and preparing the build. Prerequisites include having Go and Make installed.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-019-config-version.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout --track origin/v0.32.x\ngo get golang.org/x/sys/unix\ngo mod tidy\nmake build\nrm -fr -- tmhome\n./build/tendermint --home=tmhome init\ncp tmhome/config/config.toml config-v32.toml\n```\n\n----------------------------------------\n\nTITLE: Defining GoodBehaviourPeer Type in Go\nDESCRIPTION: This snippet introduces a GoodBehaviourPeer type to represent specific good behaviors of peers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-039-peer-behaviour.md#2025-04-22_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype GoodBehaviourPeer int\n\nconst (\n    GoodBehaviourVote = iota\n    GoodBehaviourBlockPart\n    ...\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Pure Functions for Sending Messages in Bluespec\nDESCRIPTION: Defines two pure functions for message transmission: `multiSend` updates the incoming message queues of multiple `targetNodes` by appending a message from `node`, and `send` simplifies this for a single `targetNode`. These model the effect of sending messages on the network state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_6\n\nLANGUAGE: bluespec\nCODE:\n```\npure def multiSend(node, _incomingMsgs, targetNodes, msg) =\n    _incomingMsgs.updateMultiple(targetNodes, ms => ms.append((node, msg)))\npure def send(node, _incomingMsgs, targetNode, msg) =\n    node.multiSend(_incomingMsgs, Set(targetNode), msg)\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS Allowed Methods in TOML for CometBFT\nDESCRIPTION: Specifies a list of HTTP methods that clients are allowed to use with cross-domain requests. Typically includes 'HEAD', 'GET', and 'POST' methods for standard API interactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\ncors_allowed_methods = [\"HEAD\", \"GET\", \"POST\", ]\n```\n\n----------------------------------------\n\nTITLE: Enabling gRPC Block Results Service in TOML\nDESCRIPTION: Enables the gRPC block results service which returns block results for a given height or the latest height if not specified. This setting is ignored if grpc.laddr is empty.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_36\n\nLANGUAGE: toml\nCODE:\n```\nenabled = true\n```\n\n----------------------------------------\n\nTITLE: Implementing SwitchedPeerBehaviour in Go\nDESCRIPTION: This snippet provides a concrete implementation of PeerBehaviour that wraps the existing Switch functionality.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-039-peer-behaviour.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype SwitchedPeerBehaviour struct {\n    sw *Switch\n}\n\nfunc (spb *SwitchedPeerBehaviour) Errored(peer Peer, reason ErrorBehaviourPeer) {\n    spb.sw.StopPeerForError(peer, reason)\n}\n\nfunc (spb *SwitchedPeerBehaviour) Behaved(peer Peer, reason GoodBehaviourPeer) {\n    spb.sw.MarkPeerAsGood(peer)\n}\n\nfunc NewSwitchedPeerBehaviour(sw *Switch) *SwitchedPeerBehaviour {\n    return &SwitchedPeerBehaviour{\n        sw: sw,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Link References in Markdown\nDESCRIPTION: Link references to transaction result indexing and inclusion proof documentation within the markdown file.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-015-abci++-tx-mutation.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[tx-result-index]\n[inclusion-proof]\n```\n\n----------------------------------------\n\nTITLE: Flushing events in EventCache in Go\nDESCRIPTION: Method to fire events by running evsw.FireEvent on all cached events. It blocks and clears cached events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc (evc *EventCache) Flush()\n```\n\n----------------------------------------\n\nTITLE: Generating and Grouping Random Testnets in Shell\nDESCRIPTION: Executes the testnet generator (`./build/generator`) to create random manifests in the `networks/generated/` directory (`-d`). The `-g 8` flag instructs the generator to split the generated testnets into 8 distinct groups, useful for parallel testing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n# Split networks into 8 groups (by filename)\n./build/generator -g 8 -d networks/generated/\n```\n\n----------------------------------------\n\nTITLE: Establishing Accountability in TLA+\nDESCRIPTION: This theorem in TLA+ establishes that either no fork occurs or a fork scenario is accountable under specified conditions. It contributes to the accountability property of the protocol and is part of the broader set of proofs and invariants considered in this TLA+ specification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/accountability/Synopsis.md#2025-04-22_snippet_2\n\nLANGUAGE: TLA+\nCODE:\n```\nTHEOREM AgreementOrFork ==\n    ~FaultyQuorum /\\ TypedInv => Accountability\n```\n\n----------------------------------------\n\nTITLE: Defining Light Client Attack Evidence Structure in Go\nDESCRIPTION: Data structure for representing evidence of a light client attack, including conflicting block information and common height.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_10\n\nLANGUAGE: go\nCODE:\n```\ntype LightClientAttackEvidence struct {\n    ConflictingBlock   LightBlock\n    CommonHeight       int64\n\n    // Evidence also includes application specific data which is not\n    // part of verification but is sent to the application once the\n    // evidence gets committed on chain.\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Schema for CometBFT Event Indexing\nDESCRIPTION: SQL schema definition for the PostgreSQL event sink. It includes tables for blocks, transaction results, events, and attributes, as well as views for easier querying of block and transaction events.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-065-custom-event-indexing.md#2025-04-22_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\n-- Table Definition ----------------------------------------------\n\n-- The blocks table records metadata about each block.\n-- The block record does not include its events or transactions (see tx_results).\nCREATE TABLE blocks (\n  rowid      BIGSERIAL PRIMARY KEY,\n\n  height     BIGINT NOT NULL,\n  chain_id   VARCHAR NOT NULL,\n\n  -- When this block header was logged into the sink, in UTC.\n  created_at TIMESTAMPTZ NOT NULL,\n\n  UNIQUE (height, chain_id)\n);\n\n-- Index blocks by height and chain, since we need to resolve block IDs when\n-- indexing transaction records and transaction events.\nCREATE INDEX idx_blocks_height_chain ON blocks(height, chain_id);\n\n-- The tx_results table records metadata about transaction results.  Note that\n-- the events from a transaction are stored separately.\nCREATE TABLE tx_results (\n  rowid BIGSERIAL PRIMARY KEY,\n\n  -- The block to which this transaction belongs.\n  block_id BIGINT NOT NULL REFERENCES blocks(rowid),\n  -- The sequential index of the transaction within the block.\n  index INTEGER NOT NULL,\n  -- When this result record was logged into the sink, in UTC.\n  created_at TIMESTAMPTZ NOT NULL,\n  -- The hex-encoded hash of the transaction.\n  tx_hash VARCHAR NOT NULL,\n  -- The protobuf wire encoding of the TxResult message.\n  tx_result BYTEA NOT NULL,\n\n  UNIQUE (block_id, index)\n);\n\n-- The events table records events. All events (both block and transaction) are\n-- associated with a block ID; transaction events also have a transaction ID.\nCREATE TABLE events (\n  rowid BIGSERIAL PRIMARY KEY,\n\n  -- The block and transaction this event belongs to.\n  -- If tx_id is NULL, this is a block event.\n  block_id BIGINT NOT NULL REFERENCES blocks(rowid),\n  tx_id    BIGINT NULL REFERENCES tx_results(rowid),\n\n  -- The application-defined type label for the event.\n  type VARCHAR NOT NULL\n);\n\n-- The attributes table records event attributes.\nCREATE TABLE attributes (\n   event_id      BIGINT NOT NULL REFERENCES events(rowid),\n   key           VARCHAR NOT NULL, -- bare key\n   composite_key VARCHAR NOT NULL, -- composed type.key\n   value         VARCHAR NULL,\n\n   UNIQUE (event_id, key)\n);\n\n-- A joined view of events and their attributes. Events that do not have any\n-- attributes are represented as a single row with empty key and value fields.\nCREATE VIEW event_attributes AS\n  SELECT block_id, tx_id, type, key, composite_key, value\n  FROM events LEFT JOIN attributes ON (events.rowid = attributes.event_id);\n\n-- A joined view of all block events (those having tx_id NULL).\nCREATE VIEW block_events AS\n  SELECT blocks.rowid as block_id, height, chain_id, type, key, composite_key, value\n  FROM blocks JOIN event_attributes ON (blocks.rowid = event_attributes.block_id)\n  WHERE event_attributes.tx_id IS NULL;\n\n-- A joined view of all transaction events.\nCREATE VIEW tx_events AS\n  SELECT height, index, chain_id, type, key, composite_key, value, tx_results.created_at\n  FROM blocks JOIN tx_results ON (blocks.rowid = tx_results.block_id)\n  JOIN event_attributes ON (tx_results.rowid = event_attributes.tx_id)\n  WHERE event_attributes.tx_id IS NOT NULL;\n```\n\n----------------------------------------\n\nTITLE: Deprecated skip_timeout_commit parameter in CometBFT v1.0\nDESCRIPTION: The skip_timeout_commit consensus parameter has been deprecated in v1.0 and will be removed in future releases. Users should set timeout_commit=0 instead.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\n# Deprecated: set `timeout_commit` to 0 instead.\nskip_timeout_commit = false\n```\n\n----------------------------------------\n\nTITLE: Generating and Running Counterexample Experiments - Shell\nDESCRIPTION: This pair of shell commands is used to conduct a set of model checking experiments that are intended to result in detected errors/counterexamples, driven from an experiment batch CSV such as 003bmc-apalache-error.csv. They are critical for validating the negative/test boundaries of the commit verification protocol. As before, the process depends on the Apalache tools and the experiment batch file, and outputs logs indicating if errors were found as expected.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$DIR/apalache-tests/scripts/mk-run.py --memlimit 28 003bmc-apalache-error.csv $DIR/apalache . out\n./out/run-all.sh\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Time Representation in CometBFT\nDESCRIPTION: Describes the time format used in CometBFT, which adopts the Google Protocol Buffers `Timestamp` type. This format uses a 64-bit integer for seconds and a 32-bit integer for nanoseconds, aligned with Coordinated Universal Time (UTC).\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nCometBFT uses the [Google.Protobuf.Timestamp](https://protobuf.dev/reference/protobuf/google.protobuf/#timestamp)\nformat, which uses two integers, one 64 bit integer for Seconds and a 32 bit integer for Nanoseconds.\nTime is aligned with the Coordinated Universal Time (UTC).\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 Response\nDESCRIPTION: Commands to decode base64-encoded key-value pairs from the query response.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go-built-in.md#2025-04-22_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\necho \"Y29tZXRiZnQ=\" | base64 -d\necho \"cm9ja3M=\" | base64 -d\n```\n\n----------------------------------------\n\nTITLE: Modified RequestDeliverTx Message with Internal Flag\nDESCRIPTION: Update to the existing RequestDeliverTx message structure to include an 'internal' flag that distinguishes between user-generated and internally proposed transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-023-ABCI-propose-tx.md#2025-04-22_snippet_3\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestDeliverTx {\n\tbytes tx = 1;\n\tbool internal = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Application Runtime Output\nDESCRIPTION: Example output showing the application startup and block production process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nI[2024-07-11|15:00:21.181] Executing Application PrepareProposal\nI[2024-07-11|15:00:21.181] Processed vote extensions                    curse_words=\"map[bad:1 bloodmagic:1 cry:1 muggle:1 rain:1]\"\n```\n\n----------------------------------------\n\nTITLE: Current CheckTx Method Signature in Golang\nDESCRIPTION: Shows the current signature of the CheckTx method in the Mempool interface.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-105-refactor-mempool-senders.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\nCheckTx(tx types.Tx, cb func(*abci.ResponseCheckTx), txInfo TxInfo) error\n```\n\n----------------------------------------\n\nTITLE: Defining Block Data Structure in Protobuf\nDESCRIPTION: Data message definition for storing block transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-024-block-structure-consolidation.md#2025-04-22_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage Data {\n  repeated bytes txs = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Echo and Ping/Pong Messages with Protobuf - Protobuf\nDESCRIPTION: Defines Protobuf message schemas for an echo reactor, encapsulating a oneof field for ping and pong messages. These message structures ('EchoMessage', 'PingMessage', and 'PongMessage') establish the format for serializing and exchanging typed messages in the CometBFT network. The fields allow easy extension by encapsulating variant message types within a parent wrapper.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_10\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage EchoMessage {\\n    oneof inner {\\n        PingMessage ping = 1;\\n        PongMessage pong = 2;\\n    }\\n}\\n\\nmessage PingMessage {\\n    string content = 1;\\n}\\n\\nmessage PongMessage {\\n    string content = 1;\\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a New Validator Key in CometBFT\nDESCRIPTION: Command to generate a new priv_validator_key.json file for a CometBFT validator.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ncometbft gen_validator\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Colors in TOML for CometBFT\nDESCRIPTION: Determines whether log output should be colored. This setting is only relevant when log_format is set to 'plain'. By default, it is set to true for plain text logs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\nlog_colors = true\n```\n\n----------------------------------------\n\nTITLE: Defining Block Response Message Structure in Go\nDESCRIPTION: Structure for block response messages that contain the requested block, its corresponding commit certificate, and the current height of the responding peer.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype MessageBlockResponse struct {\n  Height         int64\n  Block          Block\n  Commit         Commit\n  PeerHeight     int64\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Eventable interface in Go\nDESCRIPTION: Defines the Eventable interface for reactors and other modules to become eventable by setting an EventSwitch.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_9\n\nLANGUAGE: go\nCODE:\n```\ntype Eventable interface {\n    SetEventSwitch(evsw EventSwitch)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fork ChainDescription Structure in Markdown\nDESCRIPTION: Defines the format for ChainDescription when a chain forks or upgrades but continues the same history. It includes the previous ChainID, a marker 'x' to indicate the change, the height at which the change occurred, and the new ForkDescription.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-017-chain-versions.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```\nChainDescription = <ChainID>/x/<Height>/<ForkDescription>\n```\n```\n\n----------------------------------------\n\nTITLE: Running Apalache Verification Check with 2 Steps\nDESCRIPTION: Example command to run Apalache verification check for 2 steps using MC_PBT_3C_1F.tla model.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/tla/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./runApalache.sh check 2\n```\n\n----------------------------------------\n\nTITLE: Listing IBC Go Imports from CometBFT\nDESCRIPTION: A Bash command that lists all packages imported from CometBFT by IBC Go, showing which CometBFT components are needed by this implementation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-109-reduce-go-api-surface.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo list -json ./... | jq '.Imports, .TestImports, .XTestImports' | grep cometbft | sort | uniq | tr -d '\", '\n```\n\n----------------------------------------\n\nTITLE: CometBFT Performance Metrics Log\nDESCRIPTION: Raw performance test results showing transaction processing metrics across different configurations. Tests vary connections (1-4) and rates (200-1600 tx/s) with consistent 1024 byte transaction sizes. Measurements include transaction counts, minimum/maximum/average latencies and standard deviations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/imgs/v1/200nodes/v1_report_tabbed.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nExperiment ID: 73d1ecf6-2dbe-4288-bd84-72e286d939be  Experiment ID: b3447e8e-f85e-48be-bb05-bf1b35b9e8b6  Experiment ID: 7b76c980-4882-4be7-898f-7ba7c4c950a2\n    Connections: 1                                       Connections: 2                                   Connections: 4\n    Rate: 200                                            Rate: 200                                        Rate: 200\n    Size: 1024                                           Size: 1024                                       Size: 1024\n    Total Valid Tx: 17800                                Total Valid Tx: 34600                            Total Valid Tx: 50464\n    Total Negative Latencies: 0                          Total Negative Latencies: 0                      Total Negative Latencies: 0\n    Minimum Latency: 1.710409731s                        Minimum Latency: 1.934148332s                    Minimum Latency: 3.207030208s\n    Maximum Latency: 8.977271598s                        Maximum Latency: 19.921012538s                   Maximum Latency: 22.695517951s\n    Average Latency: 3.873914787s                        Average Latency: 6.759146915s                    Average Latency: 9.394390517s\n    Standard Deviation: 1.80382447s                      Standard Deviation: 4.158131769s                 Standard Deviation: 4.907778924s\n```\n\n----------------------------------------\n\nTITLE: Basic priv_validator_state.json Example in JSON\nDESCRIPTION: A minimal example of priv_validator_state.json showing the initial state with no signed blocks. It contains the height, round, and step fields all set to their initial values.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/priv_validator_state.json.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"height\": \"0\",\n  \"round\": 0,\n  \"step\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Functions for Cosmos Full Node Interaction in Go\nDESCRIPTION: Defines the expected RPC functions `Commit` and `Validators` that a Cosmos Full Node should expose for light client interaction. `Commit` retrieves a signed header (Header with Commit) for a specific height, and `Validators` retrieves the validator set for a specific height. These functions are assumed to be available for the light client verification process.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/README.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n```go\n    // returns signed header: Header with Commit, for the given height\n    func Commit(height int64) (SignedHeader, error)\n\n    // returns validator set for the given height\n    func Validators(height int64) (ValidatorSet, error)\n```\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Request for ABCIQuery in CometBFT\nDESCRIPTION: JSON-RPC request example for the abci_query method that retrieves application-specific data with optional Merkle proof.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_44\n\nLANGUAGE: sh\nCODE:\n```\ncurl -X POST https://localhost:26657/v1 -d \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"abci_query\\\",\\\"params\\\":{\\\"path\\\":\\\"/store/foo/key\\\", \\\"data\\\":\\\"636f6d6574626674\\\", \\\"height\\\":\\\"1\\\", \\\"prove\\\":\\\"true\\\"}}\"\n```\n\n----------------------------------------\n\nTITLE: Debug Dump Archive Structure\nDESCRIPTION: Directory structure showing the contents of the debug dump archive, including consensus state, goroutine info, heap data, network info, status, and WAL files.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/tools/debugging.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n├── consensus_state.json\n├── goroutine.out\n├── heap.out\n├── net_info.json\n├── status.json\n└── wal\n```\n\n----------------------------------------\n\nTITLE: Creating Initial Go Project Structure\nDESCRIPTION: Basic Go code to set up the initial project structure and test the setup.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello, CometBFT\")\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing FinalizeBlock Method in CometBFT\nDESCRIPTION: This snippet provides a link to the FinalizeBlock method documentation in the CometBFT GitHub repository. It's used to indicate where developers can find information about the new mechanism for controlling block delay.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_108\n\nLANGUAGE: markdown\nCODE:\n```\n[`FinalizeBlock`](https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_methods.md#finalizeblock)\n```\n\n----------------------------------------\n\nTITLE: Subscribe Function Signature in Go\nDESCRIPTION: Defines the signature for the Subscribe function, allowing customization of the output channel capacity. By default, it uses a buffered channel with capacity 1.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-033-pubsub.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nSubscribe(ctx context.Context, clientID string, query Query, outCap... int) (Subscription, error) {\n```\n\n----------------------------------------\n\nTITLE: Defining CryptoBitArray struct for efficient bitmap storage in Golang\nDESCRIPTION: Implementation of a space-efficient bit array specifically for cryptographic applications. It stores bits in byte slices and tracks extra bits to optimize storage for large numbers of signers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-019-multisigs.md#2025-04-22_snippet_4\n\nLANGUAGE: golang\nCODE:\n```\ntype CryptoBitArray struct {\n\tExtraBitsStored  byte      `json:\"extra_bits\"` // The number of extra bits in elems.\n\tElems            []byte    `json:\"elems\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Submitting a Valid Transaction via CometBFT RPC using curl (Bash)\nDESCRIPTION: This command uses curl to send a transaction to the CometBFT node's `/broadcast_tx_commit` RPC endpoint. The transaction data (`tx=\"sender:Ron,message:Music\"`) includes a sender and a non-curse word message. It's expected to be successfully processed and included in a block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"sender:Ron,message:Music\"'\n```\n\n----------------------------------------\n\nTITLE: Markdown Reference Links for CometBFT Light Client\nDESCRIPTION: Collection of markdown reference-style links to various sections of the CometBFT light client specification, including verification rules, supervisor components, and data structures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n[[verification]] The specification of the light client verification.\n\n[[supervisor]] The specification of the light client supervisor.\n\n[verification]: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md\n\n[supervisor]: https://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md\n\n[CMBC-FM-2THIRDS-link]: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#cmbc-fm-2thirds1\n\n[CMBC-SOUND-DISTR-POSS-COMMIT-link]: https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#cmbc-sound-distr-poss-commit1\n\n[LCV-SEQ-SAFE-link]:https://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-seq-safe1\n\n[CMBC-VAL-CONTAINS-CORR-link]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#cmbc-val-contains-corr1\n\n[fetch]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-func-fetch1\n\n[LCV-INV-TP1-link]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-inv-tp1\n\n[LCV-LB-link]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-data-lightblock1\n\n[LCV-LS-link]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-data-lightstore2\n\n[LVC-HD-link]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#cmbc-header-fields2\n\n[repl]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/supervisor/supervisor_001_draft.md#lc-func-replace-secondary1\n\n[vtt]:\nhttps://github.com/cometbft/cometbft/blob/main/spec/light-client/verification/verification_002_draft.md#lcv-func-main2\n```\n\n----------------------------------------\n\nTITLE: ABCI Grammar Verification Implementation in Go\nDESCRIPTION: Implementation of the Verify method in the Checker class that validates whether a sequence of ABCI requests conforms to the defined grammar. It filters requests, converts them to an execution string of terminals, and uses the generated parser to check validity.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc (g *Checker) Verify(reqs []*abci.Request, isCleanStart bool) (bool, error) {\n\tif len(reqs) == 0 {\n\t\treturn false, errors.New(\"execution with no ABCI calls\")\n\t}\n\tfullExecution := g.getExecutionString(reqs)\n\tr := g.filterRequests(reqs)\n\t// Check if the execution is incomplete.\n\tif len(r) == 0 {\n\t\treturn true, nil\n\t}\n\texecution := g.getExecutionString(r)\n\terrors := g.verify(execution, isCleanStart)\n\tif errors == nil {\n\t\treturn true, nil\n\t}\n\treturn false, fmt.Errorf(\"%v\\nFull execution:\\n%v\", g.combineErrors(errors, g.cfg.NumberOfErrorsToShow), g.addHeightNumbersToTheExecution(fullExecution))\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Invalid Transactions in Cache - Go\nDESCRIPTION: This Go snippet demonstrates how to handle transactions marked as 'never valid' within the transaction cache. It checks the KeepInvalidTxsInCache configuration and adjusts the cache accordingly. The implementation focuses on managing space efficiently by determining whether to keep transactions in the cache or rerun CheckTx when encountered again.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-026-p2p-bad-peers-checktx.md#2025-04-22_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nif !mem.config.KeepInvalidTxsInCache || r.CheckTx.Code == abci.NeverValid {\n  // remove from cache (it might be good later or is never valid, we'll most likely don't see it again)\n    mem.cache.Remove(tx)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Tendermint Ivy Proofs via Docker Compose (Bash)\nDESCRIPTION: This shell command uses Docker Compose to execute the Tendermint Ivy proofs within a container. It runs the 'tendermint-proof' service defined in the `docker-compose.yml` file, which likely invokes the `ivy_check` command on the proof files. The output from `ivy_check` is directed to a subdirectory within `./output/`. Prerequisites include having Docker and Docker Compose installed, and having successfully built the image using `docker-compose build`.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/ivy-proofs/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose run tendermint-proof\n```\n\n----------------------------------------\n\nTITLE: Generating and Running Counterexample Experiments for Detection - Shell\nDESCRIPTION: This shell command sequence is for launching attack detection model-checking experiments intended to produce counterexamples (e.g. using 005bmc-apalache-error.csv) and running all experiments in batch. As with other experiment runners, Apalache scripts and the batch configuration file are required. Output is a set of logs indicating error-findings, serving as regression or property violation checks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/README.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$DIR/apalache-tests/scripts/mk-run.py --memlimit 28 005bmc-apalache-error.csv $DIR/apalache . out\n./out/run-all.sh\n\n```\n\n----------------------------------------\n\nTITLE: Defining the ProposerAddress Field in CometBFT Block Header\nDESCRIPTION: Specifies the structure and validation for the `ProposerAddress` field within a CometBFT block header. This field identifies the original block proposer, whose address must belong to the current validator set and be a 20-byte slice.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/data_structures.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| ProposerAddress   | slice of bytes (`[]byte`) | Address of the original proposer of the block. Validator must be in the current validatorSet.                                                                                                                                                                                                                                                                                          | Must  be of length 20                                                                                                                                                                                                                                      |\n```\n\n----------------------------------------\n\nTITLE: Defining Message to Send Structure in Go\nDESCRIPTION: Wrapper structure that contains a message to be sent and the ID of the peer to which it should be sent.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_13\n\nLANGUAGE: go\nCODE:\n```\ntype MessageToSend struct {\n  PeerID  ID\n  Message Message\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ExtendVote Request and Response in Protobuf\nDESCRIPTION: Specifies the structure of the ExtendVote request and response messages. The request includes details about the proposed block, while the response contains vote extensions to be signed by CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/abci/abci++_methods.md#2025-04-22_snippet_7\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage ExtendVoteRequest {\n  bytes hash = 1;\n  int64 height = 2;\n  google.protobuf.Timestamp time = 3;\n  repeated bytes txs = 4;\n  CommitInfo proposed_last_commit = 5;\n  repeated Misbehavior misbehavior = 6;\n  bytes next_validators_hash = 7;\n  bytes proposer_address = 8;\n}\n\nmessage ExtendVoteResponse {\n  bytes vote_extension = 1;\n  bytes non_rp_extension = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Current CheckTx Async Implementation in Golang\nDESCRIPTION: Shows the current pattern for handling callbacks on New transaction requests in the mempool's CheckTx method.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-105-refactor-mempool-senders.md#2025-04-22_snippet_0\n\nLANGUAGE: golang\nCODE:\n```\nreqRes, err := mem.proxyAppConn.CheckTxAsync(context.TODO(), &abci.RequestCheckTx{Tx: tx})\nreqRes.SetCallback(mem.reqResCb(tx, txInfo, cb))\n```\n\n----------------------------------------\n\nTITLE: Referencing ADR 101 in Markdown\nDESCRIPTION: This code snippet demonstrates how to create a reference link in Markdown to ADR 101, which defines the gRPC APIs for retrieving block information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-106-separate-stateful-methods.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n[ADR 101]: https://github.com/cometbft/cometbft/blob/main/docs/architecture/adr-101-data-companion-pull-api.md\n```\n\n----------------------------------------\n\nTITLE: Implementing Backfill Function in Reactor for Reverse Sync in Go\nDESCRIPTION: Definition of the backfill function in the Reactor that fetches, verifies, and stores necessary historical light blocks to participate in consensus and validate evidence. This function implements the core reverse sync functionality.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-068-reverse-sync.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// Backfill fetches, verifies, and stores necessary history\n// to participate in consensus and validate evidence.\nfunc (r *Reactor) backfill(state State) error {}\n```\n\n----------------------------------------\n\nTITLE: VS Code Configuration for Protocol Buffers\nDESCRIPTION: Recommended Visual Studio Code settings for working with Protocol Buffer files in the CometBFT project, specifying the proto path.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"protoc\": {\n    \"options\": [\n      \"--proto_path=${workspaceRoot}/proto\",\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Helper function signatures for Multisignature operations in Golang\nDESCRIPTION: Function signatures for helper methods to manipulate multisignatures, including converting a single signature to a multisignature, finding the index of a public key, and adding signatures to a multisignature.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-019-multisigs.md#2025-04-22_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\nfunc SigToMultisig(sig []byte, n int)\nfunc GetIndex(pk crypto.Pubkey, []crypto.Pubkey)\nfunc AddSignature(sig Signature, index int, multiSig *Multisignature)\n```\n\n----------------------------------------\n\nTITLE: Configuring Remote Mempool in CometBFT\nDESCRIPTION: Configuration entries for enabling and configuring the remote mempool in CometBFT's config.toml file. This includes settings to specify the mempool type, the URL for the gRPC interface, and timeout values for reaping transactions and checking transaction availability.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-110-remote-mempool.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[mempool]\n# The type of mempool for this CometBFT node to use.\n#\n# Valid types of mempools supported by CometBFT:\n# - \"local\"  : Default clist mempool with flooding gossip protocol\n# - \"remote\" : Remote mempool in a separate process\ntype = \"remote\"\n\n#\n# Configuration specific to the remote mempool. If mempool.type is not \"remote\",\n# this section will be ignored.\n#\n# A remote mempool is only usable by a validator node. Turning on the remote\n# mempool for a full node will simply disable any mempool-related functionality\n# on that full node, and the full node will not interact with any mempool at\n# all.\n#\n[mempool.remote]\n# The base URL for the gRPC interface to the remote mempool.\nurl = \"http://localhost:28880\"\n\n# The timeout for reaping (removing) transaction data after a block has been\n# committed.\ntimeout_reap = \"1s\"\n\n# The timeout for initiating the TxsAvailable call.\ntimeout_txs_available = \"1s\"\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapper Interface for CometBFT P2P Message Wrapping\nDESCRIPTION: Defines the Wrapper interface for Protobuf messages that can contain multiple inner message types, allowing channels to support multiple message types transparently.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-062-p2p-architecture.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\n// Wrapper is a Protobuf message that can contain a variety of inner messages.\n// If a Channel's message type implements Wrapper, the channel will\n// automatically (un)wrap passed messages using the container type, such that\n// the channel can transparently support multiple message types.\ntype Wrapper interface {\n    proto.Message\n\n    // Wrap will take a message and wrap it in this one.\n    Wrap(proto.Message) error\n\n    // Unwrap will unwrap the inner message contained in this message.\n    Unwrap() (proto.Message, error)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling EndBlockResponse in Block Execution for Go\nDESCRIPTION: Defines `EndBlockResponse`, which plays a crucial role in block execution by updating validators and consensus parameters. It requires Protobuf dependencies for serialization of validator updates and events. The expected input includes updates to validators and consensus parameters, deeply affecting blockchain operations.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/core/state.md#2025-04-22_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ntype EndBlockResponse struct {\n\tValidatorUpdates      []ValidatorUpdate       `protobuf:\"bytes,1,rep,name=validator_updates,json=validatorUpdates,proto3\" json:\"validator_updates\"`\n\tConsensusParamUpdates *types1.ConsensusParams `protobuf:\"bytes,2,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3\" json:\"consensus_param_updates,omitempty\"`\n\tEvents                []Event                 `protobuf:\"bytes,3,rep,name=events,proto3\" json:\"events,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to CometBFT Peers via Command Line\nDESCRIPTION: Example of using the cometbft node command to connect to seed nodes in a CometBFT network.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --p2p.seeds \"f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656,0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656\"\n```\n\n----------------------------------------\n\nTITLE: Defining Ledger Properties in CometBFT (Math)\nDESCRIPTION: Formal mathematical definitions of ledger properties including gap-freedom, agreement, validity, and termination. These properties ensure the consistency and reliability of the blockchain ledger.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/mempool.md#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n* (Gap-freedom) \\forall i \\in \\mathbb{N}. \\forall p \\in Correct. \\square(p.ledger[i] \\neq \\bot \\implies (i=0 \\vee p.ledger[i-1] \\neq \\bot))\n* (Agreement) \\forall i \\in \\mathbb{N}. \\forall p,q \\in Correct. \\square((p.ledger[i] = \\bot) \\vee (q.ledger[i] = \\bot) \\vee (p.ledger[i] = q.ledger[i]))\n* (Validity) \\forall p \\in Correct. \\exists q \\in Processes. \\forall i \\in \\mathbb{N}. \\square(tx \\in p.ledger[i] \\implies tx \\in \\bigcup_q q.submitted[i])\n* (Termination) \\forall p \\in Correct. \\square((h=p.height \\wedge p.submitted[h] \\neq \\varnothing) \\implies \\lozenge(p.height>h))\n```\n\n----------------------------------------\n\nTITLE: Extending ABCI InfoResponse with Lane Priorities in Protobuf\nDESCRIPTION: Protobuf definition extending the ABCI InfoResponse to include lane priorities and default lane information. This allows applications to communicate their lane configuration to CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-118-mempool-lanes.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage InfoResponse {\n  ...\n  map<string, uint32> lane_priorities = 6;\n  uint32 default_lane = 7;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventSwitch interface in Go\nDESCRIPTION: Defines the EventSwitch interface that combines service.Service, Fireable, and methods for managing event listeners.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/internal/events/README.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\ntype EventSwitch interface {\n    service.Service\n    Fireable\n\n    AddListenerForEvent(listenerID, event string, cb EventCallback)\n    RemoveListenerForEvent(event string, listenerID string)\n    RemoveListener(listenerID string)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ABCI 2.0 Grammar in ABNF\nDESCRIPTION: Modified grammar definition for ABCI 2.0 protocol written in ABNF syntax for the gogll parser generator. This grammar defines valid sequences of ABCI method calls including clean start, recovery, and consensus execution paths.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-108-e2e-abci++.md#2025-04-22_snippet_3\n\nLANGUAGE: abnf\nCODE:\n```\nStart : CleanStart | Recovery;\n\nCleanStart : InitChain ConsensusExec | StateSync ConsensusExec ;\nStateSync : StateSyncAttempts SuccessSync |  SuccessSync ;\nStateSyncAttempts : StateSyncAttempt | StateSyncAttempt StateSyncAttempts ;\nStateSyncAttempt : OfferSnapshot ApplyChunks | OfferSnapshot ;\nSuccessSync : OfferSnapshot ApplyChunks ;\nApplyChunks : ApplyChunk | ApplyChunk ApplyChunks ;\n\nRecovery :  InitChain ConsensusExec | ConsensusExec ;\n\nConsensusExec : ConsensusHeights ;\nConsensusHeights : ConsensusHeight | ConsensusHeight ConsensusHeights ;\nConsensusHeight : ConsensusRounds FinalizeBlock Commit | FinalizeBlock Commit ;\nConsensusRounds : ConsensusRound | ConsensusRound ConsensusRounds ;\nConsensusRound : Proposer | NonProposer ;\n\nProposer : GotVotes | ProposerSimple | Extend | GotVotes ProposerSimple | GotVotes Extend | ProposerSimple Extend | GotVotes ProposerSimple Extend ;\nProposerSimple : PrepareProposal | PrepareProposal ProcessProposal ;\nNonProposer: GotVotes | ProcessProposal | Extend | GotVotes ProcessProposal | GotVotes Extend | ProcessProposal Extend | GotVotes ProcessProposal Extend ;\nExtend : ExtendVote | GotVotes ExtendVote | ExtendVote GotVotes | GotVotes ExtendVote GotVotes ;\nGotVotes : GotVote | GotVote GotVotes ;\n\nInitChain : \"init_chain\" ;\nFinalizeBlock : \"finalize_block\" ;\nCommit : \"commit\" ;\nOfferSnapshot : \"offer_snapshot\" ;\nApplyChunk : \"apply_snapshot_chunk\" ;\nPrepareProposal : \"prepare_proposal\" ;\nProcessProposal : \"process_proposal\" ;\nExtendVote : \"extend_vote\" ;\nGotVote : \"verify_vote_extension\" ;\n```\n\n----------------------------------------\n\nTITLE: Implementing IO Routine for Peer Communication in Go\nDESCRIPTION: Defines an ioRoutine function that handles communication with peers. It processes various message types like block requests and status requests, routing them to the appropriate peers and handling errors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-043-blockchain-riri-org.md#2025-04-22_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc (r *BlockchainReacor) ioRoutine(ioMesgs chan Message, outMsgs chan Message) {\n\t...\n\tfor {\n\t\tmsg := <-ioMsgs\n\t\tswitch msg := msg.(type) {\n\t\t\tcase scBlockRequestMessage:\n\t\t\t\tqueued := r.sendBlockRequestToPeer(...)\n\t\t\t\tif queued {\n\t\t\t\t\toutMsgs <- ioSendQueued{...}\n\t\t\t\t}\n\t\t\tcase scStatusRequestMessage\n\t\t\t\tr.sendStatusRequestToPeer(...)\n\t\t\tcase bcPeerError\n\t\t\t\tr.Switch.StopPeerForError(msg.src)\n\t\t\t\t...\n\t\t\t...\n\t\t\tcase bcFinished\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting DOG Protocol Redundancy\nDESCRIPTION: Configuration for the desired transaction redundancy level in DOG protocol.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_70\n\nLANGUAGE: toml\nCODE:\n```\ndog_target_redundancy = 1\n```\n\n----------------------------------------\n\nTITLE: Processing Health Status Response in JSON\nDESCRIPTION: Shows the expected JSON response for a health status request, indicating a successful node heartbeat validation.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": -1,\n  \"result\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Fast Compiling and Running a Simple Testnet in Shell\nDESCRIPTION: Performs a faster compilation using `make fast`, which builds a slim Docker image with the pre-compiled binary. It then runs the test runner (`./build/runner`) with the simple testnet manifest (`networks/simple.toml`). This is useful for quicker iterations during development.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nmake fast\n./build/runner -f networks/simple.toml\n```\n\n----------------------------------------\n\nTITLE: Building the Application\nDESCRIPTION: This command builds the application, refreshing dependencies automatically.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngo build -mod=mod # use -mod=mod to automatically refresh the dependencies\n```\n\n----------------------------------------\n\nTITLE: Defining ConflictingHeadersTrace Structure in Go\nDESCRIPTION: This code snippet defines a structure for conflicting headers trace, which was previously considered as an approach to handling evidence. It contains an array of signed headers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-047-handling-evidence-from-light-client.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype ConflictingHeadersTrace struct {\n  Headers []*types.SignedHeader\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Request for ABCIQuery in CometBFT\nDESCRIPTION: HTTP request example for the abci_query endpoint that retrieves application-specific data with optional Merkle proof.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_43\n\nLANGUAGE: sh\nCODE:\n```\ncurl 'http://127.0.0.1:26657/v1/abci_query?path=\"/store/foo/key\"&data=0x636f6d6574626674&height=1&prove=true'\n```\n\n----------------------------------------\n\nTITLE: Defining Event Query Parameters in Go\nDESCRIPTION: Defines the structure for event query parameters, including filter specifications, result limits, cursor-based pagination, and wait time for long-polling.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-075-rpc-subscription.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype EventParams struct {\n    // Optional filter spec. If nil or empty, all items are eligible.\n    Filter *Filter `json:\"filter\"`\n\n    // The maximum number of eligible results to return.\n    // If zero or negative, the server will report a default number.\n    MaxResults int `json:\"max_results\"`\n\n    // Return only items after this cursor. If empty, the limit is just\n    // before the beginning of the event log.\n    After string `json:\"after\"`\n\n    // Return only items before this cursor.  If empty, the limit is just\n    // after the head of the event log.\n    Before string `json:\"before\"`\n\n    // Wait for up to this long for events to be available.\n    WaitTime time.Duration `json:\"wait_time\"`\n}\n\ntype Filter struct {\n    Query string `json:\"query\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Store Interface for CometBFT Light Client\nDESCRIPTION: The Store interface defines methods for persisting and retrieving headers and validator sets. It allows saving, querying, and deleting signed headers and validator sets, as well as managing the store size through pruning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-046-light-client-implementation.md#2025-04-22_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype Store interface {\n\tSaveSignedHeaderAndValidatorSet(sh *types.SignedHeader, valSet *types.ValidatorSet) error\n\tDeleteSignedHeaderAndValidatorSet(height int64) error\n\n\tSignedHeader(height int64) (*types.SignedHeader, error)\n\tValidatorSet(height int64) (*types.ValidatorSet, error)\n\n\tLastSignedHeaderHeight() (int64, error)\n\tFirstSignedHeaderHeight() (int64, error)\n\n\tSignedHeaderAfter(height int64) (*types.SignedHeader, error)\n\n\tPrune(size uint16) error\n\n\tSize() uint16\n}\n```\n\n----------------------------------------\n\nTITLE: Removed Mempool Configuration Parameter in TOML\nDESCRIPTION: Example of the max_batch_bytes parameter that has been removed from the mempool section in CometBFT v1.0.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/upgrades/v0.38-to-v1.0.md#2025-04-22_snippet_12\n\nLANGUAGE: toml\nCODE:\n```\nmax_batch_bytes = 0\n```\n\n----------------------------------------\n\nTITLE: Sample Non-Deterministic Code Patterns to Avoid\nDESCRIPTION: Examples of programming patterns that should be avoided to maintain determinism in blockchain applications across different languages. These include random number generation, thread race conditions, system clock usage, uninitialized memory, floating point operations, and language-specific random behaviors.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/introduction/README.md#2025-04-22_snippet_0\n\nLANGUAGE: generic\nCODE:\n```\n- random number generators (without deterministic seeding)\n- race conditions on threads\n- system clock usage\n- uninitialized memory (in C/C++)\n- floating point arithmetic\n- language-specific random features (e.g. map iteration in Go)\n```\n\n----------------------------------------\n\nTITLE: Running Forum Application\nDESCRIPTION: Command to run the ABCI forum application with a specified home directory.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/9.run-app.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./abci-v2-forum-app --home /tmp/forum-app\n```\n\n----------------------------------------\n\nTITLE: Configuring Double Sign Check Height in TOML\nDESCRIPTION: Configuration parameter in config.toml that specifies how many recent blocks to check for existing votes with the validator's consensus key. Setting this value to 0 disables the check.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-051-double-signing-risk-reduction.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\ndouble_sign_check_height = {{ .Consensus.DoubleSignCheckHeight }}\n```\n\n----------------------------------------\n\nTITLE: Submitting a Transaction\nDESCRIPTION: This curl command submits a transaction to the CometBFT application using the broadcast_tx_commit endpoint.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/go.md#2025-04-22_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s 'localhost:26657/broadcast_tx_commit?tx=\"cometbft=rocks\"'\n```\n\n----------------------------------------\n\nTITLE: CometBFT Private Validator Key File\nDESCRIPTION: Example of a priv_validator_key.json file containing private key information for a CometBFT validator.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"last_step\" : 0,\n  \"last_round\" : \"0\",\n  \"address\" : \"B788DEDE4F50AD8BC9462DE76741CCAFF87D51E2\",\n  \"pub_key\" : {\n    \"value\" : \"h3hk+QE8c6QLTySp8TcfzclJw/BG79ziGB/pIA+DfPE=\",\n    \"type\" : \"tendermint/PubKeyEd25519\"\n  },\n  \"last_height\" : \"0\",\n  \"priv_key\" : {\n    \"value\" : \"JPivl82x+LfVkp8i3ztoTjY6c6GJ4pBxQexErOCyhwqHeGT5ATxzpAtPJKnxNx/NyUnD8Ebv3OIYH+kgD4N88Q==\",\n    \"type\" : \"tendermint/PrivKeyEd25519\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction Type in Mempool\nDESCRIPTION: This snippet defines a transaction type 'TX' as a string, representing transaction content in the mempool. It ensures that each transaction is uniquely identified.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_0\n\nLANGUAGE: bluespec\nCODE:\n```\ntype TX = str\n```\n\n----------------------------------------\n\nTITLE: Load vs Connections Matrix\nDESCRIPTION: Table showing transaction processing results across different combinations of connections (c) and transaction rates (r) to find the saturation point. Numbers represent total transactions processed in 90 seconds.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/TMCore-QA-34.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n|        |  c=1  |  c=2  |  c=4  |\n| :---   | ----: | ----: | ----: |\n| r=25   |  2225 | 4450  | 8900  |\n| r=50   |  4450 | 8900  | 17800 |\n| r=100  |  8900 | 17800 | 35600 |\n| r=200  | 17800 | 35600 | 38660 |\n```\n\n----------------------------------------\n\nTITLE: Markdown Redirect Link\nDESCRIPTION: A markdown link redirecting to the new documentation location\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/blockchain/state.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# State\n\nDeprecated see [core/state.md](../core/state.md)\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Indexing in TOML\nDESCRIPTION: Shows the TOML configuration for the tx_index section, allowing operators to configure which backend database to use for indexing transactions.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/guides/app-dev/indexing-transactions.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[tx-index]\n\n# The backend database to back the indexer.\n# If indexer is \"null\", no indexer service will be used.\n#\n# The application will set which txs to index. In some cases a node operator will be able\n# to decide which txs to index based on configuration set in the application.\n#\n# Options:\n#   1) \"null\"\n#   2) \"kv\" (default) - the simplest possible indexer, backed by pebbledb.\n#     - When \"kv\" is chosen \"tx.height\" and \"tx.hash\" will always be indexed.\n#   3) \"psql\" - the indexer services backed by PostgreSQL.\n# indexer = \"kv\"\n```\n\n----------------------------------------\n\nTITLE: Replacing EventBus Publishing with Observer Pattern in Go\nDESCRIPTION: A code diff showing how to replace event bus publishing with a direct observer call. This simplifies the code by removing error handling and making the event flow more explicit.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_2\n\nLANGUAGE: golang\nCODE:\n```\n-        if err := cs.eventBus.PublishEventNewRoundStep(rs); err != nil {\n-            cs.Logger.Error(\"failed publishing new round step\", \"err\", err)\n-        }\n+        // Notify the observer\n+        cs.observer.ConsensusStateNewRoundStep(rs)\n```\n\n----------------------------------------\n\nTITLE: Implementing DuplicateVoteEvidence Struct in Go\nDESCRIPTION: This code defines the DuplicateVoteEvidence struct, which represents evidence of a validator voting twice in the same round.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-059-evidence-composition-and-lifecycle.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype DuplicateVoteEvidence struct {\n  VoteA *Vote\n  VoteB *Vote\n\n  timestamp time.Time // taken from the block time\n}\n```\n\n----------------------------------------\n\nTITLE: Modified Consensus Algorithm Line 23 Changes\nDESCRIPTION: Shows the modification to line 23 of the consensus algorithm to handle validity checks differently. The change allows skipping valid(v) calls when the proposed block matches validValue or lockedValue.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-105-non-det-process-proposal.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\n// Original\n23: if valid(v) ∧ (lockedRound_p = −1 ∨ lockedValue_p = v) then\n\n// Modified\n23a: validValMatch := (validRound_p ≠ -1 ∧ validValue_p = v)\n23b: if [lockedRound_p = −1 ∧ (validValMatch ∨ valid(v))] ∨ lockedValue_p=v then\n```\n\n----------------------------------------\n\nTITLE: Listing Commit Signers - Tendermint - Go\nDESCRIPTION: Specifies the Signers function, which returns a list of validator addresses that signed a particular commit. The output is used for intersection operations during attacker isolation and is critical for attributing blame based on seen signatures.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/attacks/isolate-attackers_001_draft.md#2025-04-22_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc Signers(commit Commit) []ValidatorAddress\n```\n\n----------------------------------------\n\nTITLE: Sending Transactions to CometBFT Node\nDESCRIPTION: Examples of sending transactions to a CometBFT node using curl, demonstrating different encoding methods.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://localhost:26657/broadcast_tx_commit?tx=\\\"abcd\\\"\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl 'http://localhost:26657/broadcast_tx_commit?tx=\"hello\"'\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://localhost:26657/broadcast_tx_commit?tx=\\\"hello\\\"\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl 'http://localhost:26657/broadcast_tx_commit?tx=\"€5\"'\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl http://localhost:26657/broadcast_tx_commit?tx=0x01020304\n```\n\nLANGUAGE: sh\nCODE:\n```\ncurl --data-binary '{\"jsonrpc\":\"2.0\",\"id\":\"anything\",\"method\":\"broadcast_tx_commit\",\"params\": {\"tx\": \"AQIDBA==\"}}' -H 'Content-Type:text/plain;' http://localhost:26657\n```\n\n----------------------------------------\n\nTITLE: Defining BlockParams with LastResultsEvents in Protobuf\nDESCRIPTION: This snippet shows the proposed addition of the 'last_results_events' field to the BlockParams message in the Protobuf definition. It allows specifying a list of events to be hashed into the LastResultsHash.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-058-event-hashing.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\n@ proto/tendermint/abci/types.proto:295 @ message BlockParams {\n  int64 max_bytes = 1;\n  // Note: must be greater or equal to -1\n  int64 max_gas = 2;\n  // List of events, which will be hashed into the LastResultsHash\n  repeated string last_results_events = 3;\n}\n```\n\n----------------------------------------\n\nTITLE: ABCIInfo Response in CometBFT\nDESCRIPTION: Example JSON response from the abci_info endpoint showing application version information.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_42\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"response\": {\n      \"data\": \"{\\\"size\\\":0}\",\n      \"version\": \"0.16.1\",\n      \"app_version\": \"1314126\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extended ABCI Application Interface with CheckBlock (Go)\nDESCRIPTION: Proposed extension of the ABCI Application interface to include a new CheckBlock method. This allows applications to implement custom logic for validating blocks before prevoting.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-029-check-tx-consensus.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype Application interface {\n   // Info/Query Connection\n   Info(RequestInfo) ResponseInfo                // Return application info\n   Query(RequestQuery) ResponseQuery             // Query for state\n\n   // Mempool Connection\n   CheckTx(tx []byte) ResponseCheckTx // Validate a tx for the mempool\n\n   // Consensus Connection\n   InitChain(RequestInitChain) ResponseInitChain // Initialize blockchain with validators and other info from TendermintCore\n   CheckBlock(RequestCheckBlock) ResponseCheckBlock\n   BeginBlock(RequestBeginBlock) ResponseBeginBlock // Signals the beginning of a block\n   DeliverTx(tx []byte) ResponseDeliverTx           // Deliver a tx for full processing\n   EndBlock(RequestEndBlock) ResponseEndBlock       // Signals the end of a block, returns changes to the validator set\n   Commit() ResponseCommit                          // Commit the state and return the application Merkle root hash\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Spec Dependencies with Mermaid in Markdown\nDESCRIPTION: A Mermaid flowchart diagram that illustrates the dependencies between the different specification files in the project. It shows how flood and dog specs depend on mempool, which depends on p2p.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```mermaid\nflowchart TB\n    flood --> mempool --> p2p;\n    dog --> flood;\n    dog --> mempool;\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Cosmos Hub Imports from Tendermint\nDESCRIPTION: A Bash command that lists all packages imported from Tendermint Core by the Cosmos Hub, which still uses the older v0.34.x series.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-109-reduce-go-api-surface.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo list -json ./... | jq '.Imports, .TestImports, .XTestImports' | grep 'tendermint/tendermint' | sort | uniq | tr -d '\", '\n```\n\n----------------------------------------\n\nTITLE: Defining ProofOfLockChange Structure in Golang\nDESCRIPTION: This structure represents a Proof of Lock Change (PoLC) that honest nodes generate when they vote for a different block in a later round. It contains the votes that justified changing the lock and the public key of the validator.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-056-light-client-amnesia-attacks.md#2025-04-22_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\ntype ProofOfLockChange struct {\n\tVotes []*types.Vote\n\tPubKey crypto.PubKey\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Persistent Peers in CometBFT\nDESCRIPTION: Examples of connecting to persistent peers using both the command line and RPC endpoint in CometBFT.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/explanation/core/using-cometbft.md#2025-04-22_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ncometbft node --p2p.persistent_peers \"429fcf25974313b95673f58d77eacdd434402665@10.11.12.13:26656,96663a3dd0d7b9d17d4c8211b191af259621c693@10.11.12.14:26656\"\n\ncurl 'localhost:26657/dial_peers?persistent=true&peers=\\[\"429fcf25974313b95673f58d77eacdd434402665@10.11.12.13:26656\",\"96663a3dd0d7b9d17d4c8211b191af259621c693@10.11.12.14:26656\"\\]'\n```\n\n----------------------------------------\n\nTITLE: Querying Peer Counts by Connection Type - CometBFT Switch API - Go\nDESCRIPTION: This method, NumPeers(), exposes to reactors the ability to retrieve counts of outbound, inbound, and currently dialing peers. Utilized for diagnostic purposes and connection management, it takes no parameters and returns three integers. Main dependencies are accurate peer tracking in the Switch implementation; note that 'dialing' peers are not yet connected.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/p2p-api.md#2025-04-22_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc (sw *Switch) NumPeers() (outbound, inbound, dialing int)\n```\n\n----------------------------------------\n\nTITLE: Generating Latency Images for CometBFT Tests\nDESCRIPTION: This shell command runs a script to generate latency images from CometBFT test results. It processes a blockstore database, generates raw results, sets up a Python environment, and creates various latency plots.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n./script/reports/latencies-gen-images.sh <experiments-blockstore-dir>\n```\n\n----------------------------------------\n\nTITLE: Executing TLA+ Model Check with Parameters\nDESCRIPTION: Command to run TLA+ model checker with length=8, inv=Inv, cinit=CInit parameters and disabled discarding set to false. Used for formal verification of the MC_PBT_3C_1F specification.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/tla/experiment_data/May2022/MC_PBT_3C_1F.tla/run.txt#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncheck --length=8 --inv=Inv --cinit=CInit --discard-disabled=false MC_PBT_3C_1F.tla\n```\n\n----------------------------------------\n\nTITLE: Configuring Flush Throttle Timeout in CometBFT (TOML)\nDESCRIPTION: Sets the time to wait before flushing messages out on a connection. A value of 0ms makes flushing immediate, which may reduce latency but could degrade throughput.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/config/config.toml.md#2025-04-22_snippet_49\n\nLANGUAGE: toml\nCODE:\n```\nflush_throttle_timeout = \"10ms\"\n```\n\n----------------------------------------\n\nTITLE: Publishing Proto Files to Buf Schema Registry in Bash\nDESCRIPTION: A sequence of Bash commands to check out a specific CometBFT release, validate protocol buffer files, and publish them to the Buf schema registry with proper versioning.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout v2.0.0-rc1\ncd proto\nbuf lint\nbuf dep update\nbuf build\nbuf push --tag \"$(git rev-parse HEAD)\"\n```\n\n----------------------------------------\n\nTITLE: Defining Canonical Vote Structure in Go\nDESCRIPTION: Defines the CanonicalVote struct for signing, detailing the required fields and types. Ensures votes meet specific criteria before signing.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/signing.md#2025-04-22_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\ntype CanonicalVote struct {\n Type      SignedMsgType // type alias for byte\n Height    int64         `binary:\"fixed64\"`\n Round     int64         `binary:\"fixed64\"`\n BlockID   BlockID\n Timestamp time.Time\n ChainID   string\n}\n```\n\n----------------------------------------\n\nTITLE: Scaling and Centering of Proposer Priorities - Markdown\nDESCRIPTION: This snippet demonstrates the logic for scaling proposer priorities to ensure differences do not exceed twice the total voting power. It adjusts priorities by centering them around zero and reassigning based on voting power.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-selection.md#2025-04-22_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n    def ProposerSelection (vset):\n\n        // scale the priority values\n        diff = max(A)-min(A)\n        threshold = 2 * P\n     if  diff > threshold:\n            scale = diff/threshold\n            for each validator i in vset:\n          A(i) = A(i)/scale\n\n        // center priorities around zero\n        avg = sum(A(i) for i in vset)/len(vset)\n        for each validator i in vset:\n            A(i) -= avg\n\n        // compute priorities and elect proposer\n        for each validator i in vset:\n            A(i) += VP(i)\n        prop = max(A)\n        A(prop) -= P\n```\n\n----------------------------------------\n\nTITLE: BroadcastTxSync Response in CometBFT\nDESCRIPTION: Example JSON response from the broadcast_tx_sync endpoint showing the transaction hash and initial validation result.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_33\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"code\": \"0\",\n    \"data\": \"\",\n    \"log\": \"\",\n    \"codespace\": \"ibc\",\n    \"hash\": \"0D33F2F03A5234F38706E43004489E061AC40A2E\"\n  },\n  \"error\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Clock Precision Specification\nDESCRIPTION: Defines the PRECISION parameter that bounds the maximum difference between synchronized process clocks.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/consensus/proposer-based-timestamp/pbts-sysmodel.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n**[PBTS-CLOCK-PRECISION.0]**\n\nThere exists a system parameter `PRECISION`, such that\nfor any two processes `p` and `q`, with local clocks `C_p` and `C_q`:\n\n- If `p` and `q` are equipped with synchronized clocks,\n then for any real-time `t` we have `|C_p(t) - C_q(t)| <= PRECISION`.\n```\n\n----------------------------------------\n\nTITLE: Configuring CometBFT Indexers in TOML\nDESCRIPTION: TOML configuration for CometBFT indexers, including the new PostgreSQL event sink. It allows specifying multiple indexers and additional connection parameters for the PostgreSQL sink.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-065-custom-event-indexing.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tx_index]\n\nindexer = [\n  \"kv\",\n  \"psql\"\n]\n\npqsql_conn = \"postgresql://<user>:<password>@<host>:<port>/<db>?<opts>\"\n```\n\n----------------------------------------\n\nTITLE: Generating Transaction Load with `load` (Bash)\nDESCRIPTION: This command runs the `load` tool to generate transaction load against a CometBFT node accessible via WebSocket. It specifies 1 connection (`-c 1`), a test duration of 10 seconds (`-T 10`), a transaction rate of 1000 tx/sec (`-r 1000`), and a transaction size of 1024 bytes (`-s 1024`). It uses the `sync` broadcast method (`--broadcast-tx-method sync`) and targets a local CometBFT node's WebSocket endpoint (`--endpoints ws://localhost:26657/websocket`). The tool leverages the `cometbft-load-test` framework.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/loadtime/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./build/load \\\n    -c 1 -T 10 -r 1000 -s 1024 \\\n    --broadcast-tx-method sync \\\n    --endpoints ws://localhost:26657/websocket\n```\n\n----------------------------------------\n\nTITLE: Reactor Service Lifecycle (ABNF)\nDESCRIPTION: This ABNF snippet shows the overall lifecycle context incorporating the `Service` interface methods. A reactor undergoes registration, then its `OnStart()` method is called. It then enters the main operational phase managing peers (`*peer-management`). Finally, upon node shutdown, its `OnStop()` method is invoked. `OnStart` and `OnStop` are expected to be called only once.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/p2p/reactor-api/reactor.md#2025-04-22_snippet_2\n\nLANGUAGE: abnf\nCODE:\n```\nstart           = registration on-start *peer-management on-stop\n```\n\n----------------------------------------\n\nTITLE: Referencing GitHub Pull Requests in Markdown\nDESCRIPTION: These code snippets show how to create reference links to specific GitHub pull requests using Markdown syntax.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-106-separate-stateful-methods.md#2025-04-22_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n[#1209]: https://github.com/cometbft/cometbft/pull/1209\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n[#1168]: https://github.com/cometbft/cometbft/pull/1168\n```\n\n----------------------------------------\n\nTITLE: Building Loadtime Tools using Make (Bash)\nDESCRIPTION: This command executes the `build` target defined in the project's Makefile. It compiles the `loadtime` tools (`load` and `report`) and places the resulting executable binaries into the `./build/` directory relative to the Makefile's location. This is the standard way to prepare the tools for execution.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/loadtime/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake build\n```\n\n----------------------------------------\n\nTITLE: Destroying Terraform Resources for CometBFT Tests\nDESCRIPTION: This make command destroys all Terraform-managed resources used for the CometBFT tests. It's a crucial cleanup step to prevent unnecessary resource usage and costs.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nmake terraform-destroy\n```\n\n----------------------------------------\n\nTITLE: Entity Relationship Diagram in Mermaid for CometBFT Data Companion\nDESCRIPTION: A flowchart showing the relationships between CometBFT, the ABCI App, and the Data Companion service. CometBFT acts as a client that connects to both the ABCI App and Data Companion servers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-100-data-companion-push-api.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart RL\n    comet[CometBFT]\n    companion[Data Companion]\n    app[ABCI App]\n\n    comet --> app\n    comet --> companion\n```\n\n----------------------------------------\n\nTITLE: Stopping CometBFT Test Network\nDESCRIPTION: This make command stops the CometBFT test network after experiments are completed. It's part of the cleanup process for the test environment.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/qa/method.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nmake stop-network\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Unsigned Integer Domains in PostgreSQL for CometBFT\nDESCRIPTION: This SQL snippet defines custom domains for uint8, uint32, and uint64 in PostgreSQL to accurately store CometBFT data types. It includes value constraints to ensure data integrity and proper representation of unsigned integers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-102-rpc-companion.md#2025-04-22_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- DOMAIN: comet.uint8\n\nDO $$ BEGIN\nCREATE DOMAIN comet.uint8 AS numeric;\n\nALTER DOMAIN comet.uint8\n    ADD CONSTRAINT value_max CHECK (VALUE <= '255'::numeric);\n\nALTER DOMAIN comet.uint8\n    ADD CONSTRAINT value_positive CHECK (VALUE >= 0::numeric);\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- DOMAIN: comet.uint32\n\nDO $$ BEGIN\nCREATE DOMAIN comet.uint32 AS numeric;\n\nALTER DOMAIN comet.uint32\n    ADD CONSTRAINT value_max CHECK (VALUE <= '4294967295'::numeric);\n\nALTER DOMAIN comet.uint32\n    ADD CONSTRAINT value_positive CHECK (VALUE >= 0::numeric);\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n\n-- DOMAIN: comet.uint64\n\nDO $$ BEGIN\nCREATE DOMAIN comet.uint64\n    AS numeric;\n\nALTER DOMAIN comet.uint64 OWNER TO postgres;\n\nALTER DOMAIN comet.uint64\n    ADD CONSTRAINT value_max CHECK (VALUE <= '18446744073709551615'::numeric);\n\nALTER DOMAIN comet.uint64\n    ADD CONSTRAINT value_positive CHECK (VALUE >= 0::numeric);\nEXCEPTION\n    WHEN duplicate_object THEN null;\nEND $$;\n```\n\n----------------------------------------\n\nTITLE: Redefining LastCommitInfo and VoteInfo Message Structures in Protobuf\nDESCRIPTION: Updated message definitions for LastCommitInfo (containing round and commit votes) and VoteInfo (containing validator info and whether they signed the last block). This replaces the previous SigningValidator structure with a more appropriately named VoteInfo.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-018-ABCI-Validators.md#2025-04-22_snippet_1\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage LastCommitInfo {\n  int64 round\n  repeated VoteInfo commit_votes\n}\n\nmessage VoteInfo {\n    Validator validator\n    bool signed_last_block\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Main Chain Fork (CMBC-MC-FORK.1)\nDESCRIPTION: Defines a 'main chain fork' at time 't'. This occurs if an 'attack(a,b,c,t)' condition exists, and crucially, two different *correct* full nodes have decided on the conflicting blocks 'b' and 'c', respectively. This distinguishes a fork affecting full nodes from a light client-specific attack.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/detection_003_reviewed.md#2025-04-22_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n[CMBC-MC-FORK.1]\n\nWe say there is a (main chain) fork at time *t* if\n\n- there are two correct full nodes *i* and *j* and\n- *i* is different from *j* and\n- *i* has decided on *b* and\n- *j* has decided on *c* and\n- there exist *a* such that *attack(a,b,c,t)*.\n```\n\n----------------------------------------\n\nTITLE: Creating a Flexible Test Observer with Function Overrides in Go\nDESCRIPTION: Implementation of a test observer that allows inline definition of event handlers. This provides a flexible way to capture and test specific events without implementing all observer methods.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/rfc-107-event-observer.md#2025-04-22_snippet_5\n\nLANGUAGE: golang\nCODE:\n```\ntype testObserver struct {\n    newRoundStep   func(EventDataRoundState)\n    timeoutPropose func(EventDataRoundState)\n    // ...\n}\n\nfunc (o *testObserver) ConsensusStateNewRoundStep(ev EventDataRoundState) {\n    if o.newRoundStep != nil {\n        o.newRoundStep(ev)\n    }\n}\n\n// ...\n\nfunc TestCustomObserver(t *testing.T) {\n    testObs := &testObserver{}\n    testObs.newRoundStep = func(ev EventDataRoundState) {\n        // Custom code here called upon new round step\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Deterministic Byte Reordering Algorithm\nDESCRIPTION: Detailed steps for transforming serialized Protocol Buffer messages into a canonical representation by applying specific ordering and filtering rules.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-007-deterministic-proto-bytes.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n1. Does not add any of the data from unknown fields into the type to hash.\n2. Reordered all message fields to be in tag-sorted order.\n3. Reordered the contents of all `repeated` fields to be in lexicographically sorted order.\n4. Deleted all default values from the byte representation.\n5. Recursively performed these operations on any length-delimited subfields.\n```\n\n----------------------------------------\n\nTITLE: Defining Timeout Trigger Types in Go\nDESCRIPTION: Enumeration of timeout triggers used by the Controller to manage timeouts for responses and protocol termination.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-040-blockchain-reactor-refactor.md#2025-04-22_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype TimeoutTrigger int\nconst (\n  TimeoutUnknown TimeoutTrigger = iota\n  TimeoutResponseTrigger\n  TimeoutTerminationTrigger\n)\n```\n\n----------------------------------------\n\nTITLE: Defining ChainDescription Structure in Markdown\nDESCRIPTION: Defines the format for ChainDescription, which is a complete immutable description of a blockchain. It includes NetworkName, BlockVersion, AppVersion, StateHash, ValHash, and ConsensusParamsHash.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/tendermint-core/adr-017-chain-versions.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\nChainDescription = <NetworkName>/<BlockVersion>/<AppVersion>/<StateHash>/<ValHash>/<ConsensusParamsHash>\n```\n```\n\n----------------------------------------\n\nTITLE: Unconfirmed Transactions Response Format in CometBFT API\nDESCRIPTION: Example response structure for the unconfirmed_txs endpoint showing the number of transactions, total count, total bytes, and base64-encoded transaction data. Contains transactions waiting to be included in a block.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/rpc/README.md#2025-04-22_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"result\": {\n    \"n_txs\": \"82\",\n    \"total\": \"82\",\n    \"total_bytes\": \"19974\",\n    \"txs\": [\n      \"gAPwYl3uCjCMTXENChSMnIkb5ZpYHBKIZqecFEV2tuZr7xIUA75/FmYq9WymsOBJ0XSJ8yV8zmQKMIxNcQ0KFIyciRvlmlgcEohmp5wURXa25mvvEhQbrvwbvlNiT+Yjr86G+YQNx7kRVgowjE1xDQoUjJyJG+WaWBwSiGannBRFdrbma+8SFK2m+1oxgILuQLO55n8mWfnbIzyPCjCMTXENChSMnIkb5ZpYHBKIZqecFEV2tuZr7xIUQNGfkmhTNMis4j+dyMDIWXdIPiYKMIxNcQ0KFIyciRvlmlgcEohmp5wURXa25mvvEhS8sL0D0wwgGCItQwVowak5YB38KRIUCg4KBXVhdG9tEgUxMDA1NBDoxRgaagom61rphyECn8x7emhhKdRCB2io7aS/6Cpuq5NbVqbODmqOT3jWw6kSQKUresk+d+Gw0BhjiggTsu8+1voW+VlDCQ1GRYnMaFOHXhyFv7BCLhFWxLxHSAYT8a5XqoMayosZf9mANKdXArA=\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Handler Verification Interface in Go\nDESCRIPTION: This code snippet declares the type for a handler function that processes new headers, named checkValidityAndUpdateState. Written in Go-like pseudo-code, it represents a function type that takes a Header object as input and has no return value (void). This function encapsulates logic for header validation, trust period checks, and consensus state updates and is intended as part of a handler interface for IBC/Cosmos. Dependencies include Header data structure and underlying consensus state mechanisms. On invocation, it should update the local lightstore if the header passes verification checks. Only newer headers are accepted, and verification failures result in dropped headers.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/detection/req-ibc-detection.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype checkValidityAndUpdateState = (Header) => Void\n```\n\n----------------------------------------\n\nTITLE: Caching Received Transaction IDs\nDESCRIPTION: This snippet defines a cache within the 'MempoolState' to store transaction IDs. The cache is assumed to be infinitely large, preventing overflow.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/mempool.md#2025-04-22_snippet_5\n\nLANGUAGE: bluespec\nCODE:\n```\ncache: Set[TxID],\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing API Module Tag\nDESCRIPTION: Commands for creating a signed annotated git tag for the API module and pushing it to the repository. Used when a new version of the API module needs to be released with a pre-release.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/RELEASES.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit tag -a api/v2.0.0-rc1 -s -m \"Release api module v2.0.0-rc1\" origin/v2.x\ngit push origin api/v2.0.0-rc1\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual E2E Tests within Go Code\nDESCRIPTION: Illustrates how to set environment variables (`E2E_MANIFEST`, `E2E_TESTNET_DIR`, `E2E_NODE`) directly within a Go test file's `init` function. This allows running or debugging specific tests against a pre-started testnet from an IDE or editor without needing to set environment variables externally.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/test/e2e/README.md#2025-04-22_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc init() {\n\t// This can be used to manually specify a testnet manifest and/or node to\n\t// run tests against. The testnet must have been started by the runner first.\n\tos.Setenv(\"E2E_MANIFEST\", \"networks/ci.toml\")\n\tos.Setenv(\"E2E_TESTNET_DIR\", \"networks/foo\")\n\tos.Setenv(\"E2E_NODE\", \"validator01\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Auxiliary Values for Network Membership in Bluespec\nDESCRIPTION: Defines two derived values: `nodesInNetwork` computes the set of nodes currently connected (having peers), and `nodesNotInNetwork` computes the set of nodes not currently connected. These are calculated based on the current `peers` state.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/mempool/gossip/p2p.md#2025-04-22_snippet_7\n\nLANGUAGE: bluespec\nCODE:\n```\nval nodesInNetwork = NodeIDs.filter(node => node.Peers().nonEmpty())\nval nodesNotInNetwork = NodeIDs.exclude(nodesInNetwork)\n```\n\n----------------------------------------\n\nTITLE: Examples of Poor Changelog Entries in Markdown\nDESCRIPTION: Examples of inadequate changelog entries that lack sufficient detail about the changes and their impact on users.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/CONTRIBUTING.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n- `[consensus]` Refactor channel usage\n- `[mempool]` Make API generic\n- `[p2p]` Ban for PEX message abuse\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running CometBFT Forum Node in Go\nDESCRIPTION: Main program for running a Forum Application blockchain node. Handles configuration loading, database setup, node initialization, and HTTP server startup. Includes signal handling for graceful shutdown.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/tutorials/forum-application/6.main.md#2025-04-22_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/spf13/viper\"\n\n\t\"github.com/cometbft/cometbft/abci/tutorials/abci-v2-forum-app/abci\"\n\tcfg \"github.com/cometbft/cometbft/config\"\n\tcmtflags \"github.com/cometbft/cometbft/libs/cli/flags\"\n\tcmtlog \"github.com/cometbft/cometbft/libs/log\"\n\tnm \"github.com/cometbft/cometbft/node\"\n\t\"github.com/cometbft/cometbft/p2p\"\n\t\"github.com/cometbft/cometbft/privval\"\n\t\"github.com/cometbft/cometbft/proxy\"\n)\n\nvar homeDir string\n\nfunc init() {\n\tflag.StringVar(&homeDir, \"home\", \"\", \"Path to the CometBFT config directory (if empty, uses $HOME/.forumapp)\")\n}\n\nfunc main() {\n\tflag.Parse()\n\tif homeDir == \"\" {\n\t\thomeDir = os.ExpandEnv(\"$HOME/.forumapp\")\n\t}\n\n\tconfig := cfg.DefaultConfig()\n\tconfig.SetRoot(homeDir)\n\tviper.SetConfigFile(fmt.Sprintf(\"%s/%s\", homeDir, \"config/config.toml\"))\n\n\tif err := viper.ReadInConfig(); err != nil {\n\t\tlog.Fatalf(\"failed to read config: %v\", err)\n\t}\n\n\tlogger := cmtlog.NewLogger(os.Stdout)\n\tlogger, err := cmtflags.ParseLogLevel(config.LogLevel, logger, cfg.DefaultLogLevel)\n\tif err != nil {\n\t\tlog.Printf(\"failed to parse log level: %v\", err)\n\t\tdefer os.Exit(1)\n\t}\n\n\tdbPath := filepath.Join(homeDir, \"forum-db\")\n\tappConfigPath := \"app.toml\"\n\tapp, err := abci.NewForumApp(dbPath, appConfigPath, logger)\n\tif err != nil {\n\t\tlog.Printf(\"failed to create Forum Application: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tnodeKey, err := nodekey.LoadNodeKey(config.NodeKeyFile())\n\tif err != nil {\n\t\tlog.Printf(\"failed to load node key: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tpv := privval.LoadFilePV(\n\t\tconfig.PrivValidatorKeyFile(),\n\t\tconfig.PrivValidatorStateFile(),\n\t)\n\n\tnode, err := nm.NewNode(\n\t\tcontext.Background(),\n\t\tconfig,\n\t\tpv,\n\t\tnodeKey,\n\t\tproxy.NewLocalClientCreator(app),\n\t\tnm.DefaultGenesisDocProviderFunc(config),\n\t\tcfg.DefaultDBProvider,\n\t\tnm.DefaultMetricsProvider(config.Instrumentation),\n\t\tlogger,\n\t)\n\tif err != nil {\n\t\tlog.Printf(\"failed to create CometBFT node\")\n\t\tos.Exit(1)\n\t}\n\n\tif err := node.Start(); err != nil {\n\t\tlog.Printf(\"failed to start CometBFT node\")\n\t\tos.Exit(1)\n\t}\n\tdefer func() {\n\t\t_ = node.Stop()\n\t\tnode.Wait()\n\t}()\n\n\thttpAddr := \"127.0.0.1:8080\"\n\n\tserver := &http.Server{\n\t\tAddr:              httpAddr,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t}\n\n\tif err := server.ListenAndServe(); err != nil {\n\t\tlog.Printf(\"failed to start HTTP server: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigCh\n\n\tlog.Println(\"Forum application stopped\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OfferPendingTransaction Request and Response in Protobuf\nDESCRIPTION: This code snippet defines the Protobuf messages for the OfferPendingTransaction request and response. It includes fields for the transaction, gossip list size, and gossip status, replacing the previous CheckTx call.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/docs/references/rfc/tendermint-core/rfc-025-support-app-side-mempool.md#2025-04-22_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\nmessage RequestOfferPendingTransaction {\n  bytes  tx = 1;\n  int64 gossip_list_max_size = 2;\n  int64 gossip_list_current_size = 3;\n}\n\nmessage ResponseOfferPendingTransaction {\n  GossipStatus  gossip_status = 1;\n  enum GossipStatus {\n    UNKNOWN  = 0;\n    GOSSIP = 1;\n    NO_GOSSIP = 2;\n  }\n  repeated bytes removals =2\n}\n```\n\n----------------------------------------\n\nTITLE: Proving Typed Invariant Inductiveness in TLA+\nDESCRIPTION: This TLA+ theorem proves that the TypedInv is an inductive invariant under the condition that less than two-thirds of processes are faulty. It utilizes the Apalache model checker to validate this theorem against fixed instances. The theorem is written with TLA+ syntax and should be understood within the context of TLA+ specifications and model checking.\nSOURCE: https://github.com/cometbft/cometbft/blob/main/spec/light-client/accountability/Synopsis.md#2025-04-22_snippet_0\n\nLANGUAGE: TLA+\nCODE:\n```\nTHEOREM TypedInvIsInductive ==\n    \\/ FaultyQuorum\n    \\//\\ Init => TypedInv\n      /\\ TypedInv /\\ [Next]_vars => TypedInv'\n```"
  }
]