[
  {
    "owner": "redis",
    "repo": "ioredis",
    "content": "TITLE: Basic Usage of ioredis in Node.js\nDESCRIPTION: Demonstrates importing ioredis, creating a Redis instance, and performing basic operations like set, get, and zadd. It shows both callback and promise-based approaches.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst Redis = require(\"ioredis\");\n\nconst redis = new Redis();\n\nredis.set(\"mykey\", \"value\");\n\nredis.get(\"mykey\", (err, result) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result); // Prints \"value\"\n  }\n});\n\nredis.get(\"mykey\").then((result) => {\n  console.log(result); // Prints \"value\"\n});\n\nredis.zadd(\"sortedSet\", 1, \"one\", 2, \"dos\", 4, \"quatro\", 3, \"three\");\nredis.zrange(\"sortedSet\", 0, 2, \"WITHSCORES\").then((elements) => {\n  console.log(elements);\n});\n\nredis.set(\"mykey\", \"hello\", \"EX\", 10);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis Cluster with ioredis - JavaScript\nDESCRIPTION: This snippet illustrates connecting to a Redis Cluster using ioredis in Node.js. It demonstrates providing a list of startup nodes (host and port) to the Cluster constructor and executing basic Redis commands (e.g., 'set', 'get'). Dependencies include the 'ioredis' module. The input is an array of node configs, and the output is a cluster-enabled Redis client.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_36\n\nLANGUAGE: javascript\nCODE:\n```\nconst Redis = require(\"ioredis\");\n\nconst cluster = new Redis.Cluster([\n  {\n    port: 6380,\n    host: \"127.0.0.1\",\n  },\n  {\n    port: 6381,\n    host: \"127.0.0.1\",\n  },\n]);\n\ncluster.set(\"foo\", \"bar\");\ncluster.get(\"foo\", (err, res) => {\n  // res === 'bar'\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Pub/Sub Messaging in Redis Cluster Mode with ioredis in JavaScript\nDESCRIPTION: This snippet illustrates publishing and subscribing to messages in Redis Cluster mode using ioredis. It creates two Cluster instances: one for publishing and another for subscribing, with the 'message' event handler logging incoming messages for a specific channel. It is expected that both instances are connected to the same cluster nodes; inputs are channel names and message payloads, and output is the logged message. Limitations include the need for proper cluster connectivity and the fact that only one node handles the subscription per channel for deduplication.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_42\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst nodes = [\n  /* nodes */\n];\nconst pub = new Redis.Cluster(nodes);\nconst sub = new Redis.Cluster(nodes);\nsub.on(\"message\", (channel, message) => {\n  console.log(channel, message);\n});\n\nsub.subscribe(\"news\", () => {\n  pub.publish(\"news\", \"highlights\");\n});\n```\n\n----------------------------------------\n\nTITLE: Performing and Handling Transactions with ioredis (JavaScript)\nDESCRIPTION: Demonstrates chaining transaction commands using ioredis, starting a transaction with multi(), queuing commands with set/get, and executing them with exec. Illustrates error handling for transactions when command arguments are invalid, returning structured errors in the callback. This usage requires an initialized ioredis client (e.g., const redis = new Redis()), and expects JavaScript-style callback functions. Parameters are key-value pairs or commands for Redis, output is an array of results or an error object; only valid when using the ioredis client.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec((err, results) => {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec((err, results) => {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis\n  .multi()\n  .set(\"foo\", \"bar\", (err, result) => {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec((err, result) => {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis\n  .multi([\n    [\"set\", \"foo\", \"bar\"],\n    [\"get\", \"foo\"],\n  ])\n  .exec(() => {\n    /* ... */\n  });\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n----------------------------------------\n\nTITLE: Batch Command Execution with Pipeline in ioredis JavaScript\nDESCRIPTION: Demonstrates using a Pipeline instance in ioredis to batch multiple Redis commands for higher performance. Shows command queuing, promise-based execution, callback chaining, and array-based construction. Inputs are a sequence of Redis commands and their parameters, outputs are result arrays matching command order, where each element is an error/result tuple. Useful for reducing network round-trips when executing multiple commands in bulk.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec((err, results) => {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec((err, results) => {});\n\n// `exec` also returns a Promise:\nconst promise = redis.pipeline().set(\"foo\", \"bar\").get(\"foo\").exec();\npromise.then((result) => {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Custom Lua Commands with ioredis (JavaScript)\nDESCRIPTION: Explains how to define custom commands with Lua scripts using ioredis's defineCommand() and the 'scripts' constructor option. Shows both static (preset number) and dynamic (variable number) key counts, and demonstrates invoking custom commands standalone or within pipelines. This feature enables extended Redis command functionality with backend Lua, suitable for advanced use cases or performance optimizations; dependencies: a running Redis server, ioredis, and JavaScript callback syntax.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis();\n\n// This will define a command myecho:\nredis.defineCommand(\"myecho\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Now `myecho` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.myecho(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `myechoBuffer` is also defined automatically to return buffers instead of strings:\nredis.myechoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set(\"foo\", \"bar\").myecho(\"k1\", \"k2\", \"a1\", \"a2\").exec();\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  scripts: {\n    myecho: {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Key Prefixing with Custom Commands and Pipelines in ioredis (JavaScript)\nDESCRIPTION: Illustrates setting a global keyPrefix option so all Redis key operations are automatically prepended with a namespace, e.g., 'foo:'. Shows compatibility of prefixing with both built-in and custom (Lua-defined) commands, and integration with pipelining and transaction patterns. Warnings are provided for commands such as KEYS and SCAN or reply keys, where prefixing does not apply. Prerequisite: ioredis instantiated with the keyPrefix option.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nconst fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"myecho\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .myecho(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis via rediss URL with ioredis - JavaScript\nDESCRIPTION: This snippet demonstrates how to connect to a Redis service requiring TLS by specifying the 'rediss://' URL scheme when instantiating ioredis in Node.js. No additional configuration is necessary apart from the URL. The input is a valid 'rediss://' connection string, and the output is a secure Redis connection object.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis(\"rediss://redis.my-service.com\");\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis with ioredis\nDESCRIPTION: Shows various ways to connect to Redis using ioredis, including specifying host, port, password, and using Redis URL strings.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nnew Redis();\nnew Redis(6380);\nnew Redis(6379, \"192.168.1.1\");\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379,\n  host: \"127.0.0.1\",\n  username: \"default\",\n  password: \"my-top-secret\",\n  db: 0,\n});\n\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n\nnew Redis(\"redis://username:authpassword@127.0.0.1:6380/4\");\n```\n\n----------------------------------------\n\nTITLE: Storing Binary Data with ioredis set in JavaScript\nDESCRIPTION: Provides a concise example showing binary data storage in Redis using ioredis by passing a Buffer as the value to 'set'. No special method is neededâ€”just pass a Buffer directly for true binary data. Input is a Buffer; output is a status from Redis for the set operation.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nredis.set(\"foo\", Buffer.from([0x62, 0x75, 0x66]));\n```\n\n----------------------------------------\n\nTITLE: Retrieving Binary Data with getBuffer in ioredis JavaScript\nDESCRIPTION: Shows how to retrieve binary (Buffer) data using the 'getBuffer' method of ioredis, rather than getting a UTF-8 string. Requires ioredis. Input is the key name; output is a Buffer object from Redis, allowing safe manipulation of non-textual or binary values.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst result = await redis.getBuffer(\"foo\");\n// result is `<Buffer 62 75 66>`\n```\n\n----------------------------------------\n\nTITLE: Setting and Fetching Old Value as Buffer with setBuffer in ioredis JavaScript\nDESCRIPTION: Demonstrates how to use 'setBuffer' in ioredis to both set a value and retrieve the previous one as a Buffer. Uses the 'GET' option of Redis SET to get the old value atomically. Inputs include the key, new value, and 'GET' flag; output is the previous value as a Buffer. Useful for binary-safe replacements. Requires ioredis.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst result = await redis.setBuffer(\"foo\", \"new value\", \"GET\");\n// result is `<Buffer 62 75 66>` as `GET` indicates returning the old value.\n```\n\n----------------------------------------\n\nTITLE: Command-specific Callbacks and Array Construction in Pipeline (ioredis, JavaScript)\nDESCRIPTION: Highlights advanced pipelining usage in ioredis by attaching individual callbacks to commands and constructing pipelines from arrays. Each pipelined command can have its own callback to process the response, and the 'exec' callback receives the complete result array. Requires ioredis. Inputs are array-formatted command sequences or chained method calls; outputs include immediate per-command results and the entire pipeline's result set.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", (err, result) => {\n    // result === 'bar'\n  })\n  .exec((err, result) => {\n    // result[1][1] === 'bar'\n  });\n\n// Array-based pipeline construction\nredis\n  .pipeline([\n    [\"set\", \"foo\", \"bar\"],\n    [\"get\", \"foo\"],\n  ])\n  .exec(() => {\n    /* ... */\n  });\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Channels with ioredis Pub/Sub in JavaScript\nDESCRIPTION: Shows how to use ioredis as a subscriber listening to two channels ('my-channel-1', 'my-channel-2'). Handles subscription events, errors, and processes both string and Buffer messages using event listeners. Requires the ioredis package and a Redis server. Accepts subscribed channels as input, outputs received messages to the console, and logs subscription status or errors. Useful for channel-based message consumption in real-time applications.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// subscriber.js\n\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nredis.subscribe(\"my-channel-1\", \"my-channel-2\", (err, count) => {\n  if (err) {\n    // Just like other commands, subscribe() can fail for some reasons,\n    // ex network issues.\n    console.error(\"Failed to subscribe: %s\", err.message);\n  } else {\n    // `count` represents the number of channels this client are currently subscribed to.\n    console.log(\n      `Subscribed successfully! This client is currently subscribed to ${count} channels.`\n    );\n  }\n});\n\nredis.on(\"message\", (channel, message) => {\n  console.log(`Received ${message} from ${channel}`);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\n// It's useful when the messages are binary data.\nredis.on(\"messageBuffer\", (channel, message) => {\n  // Both `channel` and `message` are buffers.\n  console.log(channel, message);\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming Redis Streams Using ioredis in JavaScript\nDESCRIPTION: Demonstrates asynchronous consumption of messages from a Redis stream using ioredis with async/await. The function 'listenForMessage' reads new stream entries using XREAD, processes each with a callback, and recursively calls itself with the last seen stream ID for continuous processing. Dependencies: ioredis and Node.js 8+ for async/await. Inputs include the last stream ID, outputs are processed via 'processMessage'. Suitable for real-time stream processing applications.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nconst processMessage = (message) => {\n  console.log(\"Id: %s. Data: %O\", message[0], message[1]);\n};\n\nasync function listenForMessage(lastId = \"$\") {\n  // `results` is an array, each element of which corresponds to a key.\n  // Because we only listen to one key (mystream) here, `results` only contains\n  // a single element. See more: https://redis.io/commands/xread#return-value\n  const results = await redis.xread(\"block\", 0, \"STREAMS\", \"mystream\", lastId);\n  const [key, messages] = results[0]; // `key` equals to \"mystream\"\n\n  messages.forEach(processMessage);\n\n  // Pass the last id of the results to the next round.\n  await listenForMessage(messages[messages.length - 1][0]);\n}\n\nlistenForMessage();\n```\n\n----------------------------------------\n\nTITLE: Pattern-based Subscription and Wildcard Events with ioredis Pub/Sub in JavaScript\nDESCRIPTION: Provides an example of subscribing to channels using patterns and handling wildcard events using ioredis in Node.js. The code subscribes with a pattern, triggering 'pmessage' or 'pmessageBuffer' events for matching channels. Requires ioredis. Inputs include the channel pattern; outputs are handled in event listeners. Supports consuming from multiple dynamic channels in a scalable manner.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nredis.psubscribe(\"pat?ern\", (err, count) => {});\n\n// Event names are \"pmessage\"/\"pmessageBuffer\" instead of \"message/messageBuffer\".\nredis.on(\"pmessage\", (pattern, channel, message) => {});\nredis.on(\"pmessageBuffer\", (pattern, channel, message) => {});\n```\n\n----------------------------------------\n\nTITLE: Monitoring Redis Commands Using ioredis MONITOR API (JavaScript)\nDESCRIPTION: Provides samples of using the monitor() method to observe all Redis server commands in real time. Shows both callback and async/await usage, including how to subscribe to monitor events and properly disconnect the monitor instance. Ensures developers have control over instrumentation for debugging or analytics; requires a running Redis server and ioredis client. Only monitoring commands are valid once monitor is enabled on the connection.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nredis.monitor((err, monitor) => {\n  monitor.on(\"monitor\", (time, args, source, database) => {});\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nasync () => {\n  const monitor = await redis.monitor();\n  monitor.on(\"monitor\", console.log);\n  // Any other tasks\n  monitor.disconnect();\n};\n```\n\n----------------------------------------\n\nTITLE: Filtering and Customizing Redis Key Scans with scanStream Options in ioredis (JavaScript)\nDESCRIPTION: This snippet shows how to configure the scanStream method in ioredis by passing options for pattern matching, type filtering, and batch size. The options object allows specifying a pattern ('match'), a Redis type ('type'), and an approximate number of elements returned per call ('count'), enabling targeted scans for specific keys and data types. This is suited for Redis v2.8+ (type filter requires Redis v6.0+) and requires the ioredis library.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // only return objects that match a given type,\n  // (requires Redis >= 6.0)\n  type: \"zset\",\n  // returns approximately 100 elements per call\n  count: 100,\n});\n```\n\n----------------------------------------\n\nTITLE: Scanning Elements of a Redis ZSet with zscanStream in ioredis (JavaScript)\nDESCRIPTION: This snippet demonstrates using zscanStream to iterate over elements in a Redis ZSet ('sorted set') with the option to filter elements according to a matching pattern. The method is analogous to scanStream but requires the ZSet key as the first argument. The stream yields matching elements which can be processed as needed. Requires ioredis, Node.js, and a Redis server with the target ZSet key.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nconst stream = redis.zscanStream(\"myhash\", {\n  match: \"age:??\",\n});\n```\n\n----------------------------------------\n\nTITLE: Hash Table Key Scanning Without Values Using hscanStream and noValues Option in ioredis (JavaScript)\nDESCRIPTION: This code showcases scanning a Redis hash table to retrieve only the field names (keys) without their associated values, using the hscanStream method with the noValues option set to true. This pattern is useful for efficiently obtaining only keys when values are not needed. Requires ioredis connected to a Redis server and a valid hash key.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\",\n  noValues: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Pausing and Resuming Key Scan Streams for Async Operations in ioredis (JavaScript)\nDESCRIPTION: This snippet describes how to integrate asynchronous tasks (such as migrating keys to another database) within the scanStream's data event by pausing the stream until the async operations complete. The stream is paused before starting async tasks and resumed upon their completion, ensuring controlled processing. Requires ioredis, Node.js, and an implementation of migrateKeyToMySQL.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nconst stream = redis.scanStream();\nstream.on(\"data\", (resultKeys) => {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", () => {\n  console.log(\"done migration\");\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto-Reconnect Delay with retryStrategy in ioredis (JavaScript)\nDESCRIPTION: This snippet illustrates how to configure the reconnect delay strategy by providing a retryStrategy function to the ioredis constructor. The delay increases linearly with the number of reconnection attempts, up to a maximum, and determines the time (in ms) to wait before attempting to reconnect after a disconnection. If a non-number is returned, auto-reconnect will stop. Requires ioredis and Node.js.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy(times) {\n    const delay = Math.min(times * 50, 2000);\n    return delay;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Limiting Auto-Reconnect Attempts per Command with maxRetriesPerRequest (JavaScript, ioredis)\nDESCRIPTION: This snippet demonstrates setting the maxRetriesPerRequest configuration for ioredis, specifying the maximum number of retry attempts for each command before giving up and returning an error. Setting it to 1 limits each command to a single retry on connection loss. This prevents unbounded waiting but can result in failed commands if reconnection is slow. Requires ioredis and Node.js.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  maxRetriesPerRequest: 1,\n});\n```\n\n----------------------------------------\n\nTITLE: Separating Publisher and Subscriber Connections with ioredis Pub/Sub in JavaScript\nDESCRIPTION: Illustrates best practice for using separate Redis connections in Node.js when both publishing and subscribing in a single process. The code creates two independent Redis clients ('sub' and 'pub'), ensuring each instance is dedicated to either publishing or subscribing. Requires ioredis. This avoids mode conflicts inherent to Redis connections during pub/sub operations. Input/output depends on further event handlers or publishing logic supplied by the developer.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst sub = new Redis();\nconst pub = new Redis();\n\nsub.subscribe(/* ... */); // From now, `sub` enters the subscriber mode.\nsub.on(\"message\" /* ... */);\n\nsetInterval(() => {\n  // `pub` can be used to publish messages, or send other regular commands (e.g. `hgetall`)\n  // because it's not in the subscriber mode.\n  pub.publish(/* ... */);\n}, 1000);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis with TLS Proxy using ioredis - JavaScript\nDESCRIPTION: This snippet demonstrates how to connect to a Redis instance through a TLS proxy (such as stunnel) using the ioredis library in Node.js. It sets the 'tls' option with certificate authority details loaded via 'fs.readFileSync'. Dependencies include 'ioredis' and 'fs' modules. Parameters such as 'host' and TLS options (like 'ca') are required. Expected input is the Redis server host and the path to the certificate file; the output is a secured Redis connection object.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  host: \"localhost\",\n  tls: {\n    // Refer to `tls.connect()` section in\n    // https://nodejs.org/api/tls.html\n    // for all supported options\n    ca: fs.readFileSync(\"cert.pem\"),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis with Empty TLS Options using ioredis - JavaScript\nDESCRIPTION: This snippet shows how to connect to a Redis server with TLS enabled by explicitly specifying an empty 'tls' object in the ioredis options. This can be used when default TLS settings are sufficient and client authentication is not required. The Redis host should support TLS connections.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  host: \"redis.my-service.com\",\n  tls: {},\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis with Sentinel via ioredis - JavaScript\nDESCRIPTION: This snippet demonstrates connection to a Redis service managed by Sentinel for high availability, using ioredis. The configuration includes a list of sentinel hosts, the name of the master, and optional Sentinel-related options. After connecting, standard Redis commands (e.g., 'set') can be used. The client automatically fails over to a new master in case of failure.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  sentinels: [\n    { host: \"localhost\", port: 26379 },\n    { host: \"localhost\", port: 26380 },\n  ],\n  name: \"mymaster\",\n});\n\nredis.set(\"foo\", \"bar\");\n```\n\n----------------------------------------\n\nTITLE: Using TLS Profiles for Redis.com Cloud in ioredis - JavaScript\nDESCRIPTION: This example shows how to use pre-configured TLS profiles (such as 'RedisCloudFixed') for connecting to Redis.com Cloud with ioredis. The 'tls' option can be set to a profile name or to an object with additional customization (like client certificate keys). Note that TLS profiles may be deprecated in future versions, so explicit TLS options are preferred. Inputs are host and profile (with optional key), output is a secure connection.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_32\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  host: \"localhost\",\n  tls: \"RedisCloudFixed\",\n});\n\nconst redisWithClientCertificate = new Redis({\n  host: \"localhost\",\n  tls: {\n    profile: \"RedisCloudFixed\",\n    key: \"123\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Preferred Slaves with Sentinel Replica Selection in ioredis - JavaScript\nDESCRIPTION: This snippet details how to use the 'preferredSlaves' option in ioredis to influence which slave instance is selected when connecting as a replica in Sentinel mode. The example shows both array and function formats for specifying preferred slaves. The input is a list or function operating over available slave objects, and the output is a connection to a chosen slave (or random if the preference fails).\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\n// available slaves format\nconst availableSlaves = [{ ip: \"127.0.0.1\", port: \"31231\", flags: \"slave\" }];\n\n// preferredSlaves array format\nlet preferredSlaves = [\n  { ip: \"127.0.0.1\", port: \"31231\", prio: 1 },\n  { ip: \"127.0.0.1\", port: \"31232\", prio: 2 },\n];\n\n// preferredSlaves function format\npreferredSlaves = function (availableSlaves) {\n  for (let i = 0; i < availableSlaves.length; i++) {\n    const slave = availableSlaves[i];\n    if (slave.ip === \"127.0.0.1\") {\n      if (slave.port === \"31234\") {\n        return slave;\n      }\n    }\n  }\n  // if no preferred slaves are available a random one is used\n  return false;\n};\n\nconst redis = new Redis({\n  sentinels: [\n    { host: \"127.0.0.1\", port: 26379 },\n    { host: \"127.0.0.1\", port: 26380 },\n  ],\n  name: \"mymaster\",\n  role: \"slave\",\n  preferredSlaves: preferredSlaves,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Sentinel Retry Strategy in ioredis - JavaScript\nDESCRIPTION: This code defines a sample 'sentinelRetryStrategy' function for ioredis Sentinel mode, specifying how reconnection delay grows when all sentinels are unreachable. The input is the count of retry attempts, and output is the delay in milliseconds for the next retry. Used as a configuration function in the Redis client options.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_35\n\nLANGUAGE: javascript\nCODE:\n```\nfunction (times) {\n  const delay = Math.min(times * 10, 1000);\n  return delay;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Cluster Retry and Startup Nodes in ioredis - JavaScript\nDESCRIPTION: These snippets demonstrate customizing the 'clusterRetryStrategy' and modifying 'startupNodes' in ioredis Cluster mode. The 'clusterRetryStrategy' function controls retry delay after connection failure, while setting 'startupNodes' can dynamically change the nodes to reconnect to. Inputs include retry attempt counts and node lists; outputs are delay values (ms) and cluster configuration changes.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_37\n\nLANGUAGE: javascript\nCODE:\n```\nfunction (times) {\n  const delay = Math.min(100 + times * 2, 2000);\n  return delay;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nfunction (times) {\n  this.startupNodes = [{ port: 6790, host: '127.0.0.1' }];\n  return Math.min(100 + times * 2, 2000);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Read-Write Splitting with ioredis Cluster in JavaScript\nDESCRIPTION: This snippet shows how to set up a Redis.Cluster instance with the 'scaleReads' option to direct read operations to slave nodes and write operations to masters for load balancing in a Redis cluster. It relies on the 'ioredis' library and expects a correctly configured Redis cluster with master and slave nodes. The cluster is initialized with scaleReads set to 'slave', so write operations (e.g., set) are sent to the masters, while read operations (e.g., get) are routed to slaves; note that due to replica lag, reads may not always reflect the latest write. Inputs include the cluster node addresses and scaleReads option; outputs are standard Redis command responses. Limitations include possible replication delay between masters and slaves.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_38\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cluster = new Redis.Cluster(\n  [\n    /* nodes */\n  ],\n  {\n    scaleReads: \"slave\",\n  }\n);\ncluster.set(\"foo\", \"bar\"); // This query will be sent to one of the masters.\ncluster.get(\"foo\", (err, res) => {\n  // This query will be sent to one of the slaves.\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Commands Across Multiple Cluster Nodes with ioredis in JavaScript\nDESCRIPTION: This snippet demonstrates sending commands to multiple nodes of a Redis cluster by fetching them via the 'nodes' method on a Cluster instance. Using ioredis, it retrieves slave nodes to flush their databases and master nodes to list their keys concurrently using Promise.all. The code expects an initialized Redis cluster client and leverages cluster awareness for administrative commands across the distributed cluster. Inputs are role parameters ('slave', 'master') to nodes(); outputs are arrays of results from each node (e.g., for 'keys'). This approach assumes a functional cluster and does not handle per-node errors individually.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_39\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Send `FLUSHDB` command to all slaves:\nconst slaves = cluster.nodes(\"slave\");\nPromise.all(slaves.map((node) => node.flushdb()));\n\n// Get keys of all the masters:\nconst masters = cluster.nodes(\"master\");\nPromise.all(\n  masters\n    .map((node) => node.keys())\n    .then((keys) => {\n      // keys: [['key1', 'key2'], ['key3', 'key4']]\n    })\n);\n```\n\n----------------------------------------\n\nTITLE: Specifying natMap as a Function for Redis Cluster in JavaScript\nDESCRIPTION: This code demonstrates configuring the 'natMap' option as a function in ioredis, offering dynamic mapping between internal cluster node addresses and externally accessible endpoints. The function takes an internal address key and, based on custom logic (e.g., inspecting the port), returns the corresponding external address or null if not mapped. This is useful for scenarios where address mappings are computed at runtime or only the node port is known. Input is the address key; output is the mapped host/port object or null. The code expects that ioredis and the cluster environment are properly set up.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_41\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001,\n    },\n  ],\n  {\n    natMap: (key) => {\n      if(key.indexOf('30001')) {\n        return { host: \"203.0.113.73\", port: 30001 };\n      }\n\n      return null;\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Cluster NAT Mapping with natMap Option in JavaScript\nDESCRIPTION: This snippet shows how to set up NAT (Network Address Translation) mapping rules for a Redis cluster using the 'natMap' option in ioredis. It initializes a Redis.Cluster with an array of externally accessible cloud IPs and maps internal (private) addresses to public-facing endpoints, needed when the cluster is behind NAT or running in cloud/Docker environments. The cluster instance expects the mapping dictionary specifying correspondence of internal node addresses to reachable public addresses. The limitation is that 'natMap' requires knowledge of internal to external address pairs in advance.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_40\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"203.0.113.73\",\n      port: 30001,\n    },\n  ],\n  {\n    natMap: {\n      \"10.0.1.230:30001\": { host: \"203.0.113.73\", port: 30001 },\n      \"10.0.1.231:30001\": { host: \"203.0.113.73\", port: 30002 },\n      \"10.0.1.232:30001\": { host: \"203.0.113.73\", port: 30003 },\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Using Sharded Pub/Sub in Redis Cluster with ssubscribe and spublish in JavaScript\nDESCRIPTION: This snippet demonstrates enabling sharded Pub/Sub support in ioredis by setting the 'shardedSubscribers' option to true in a Redis Cluster. It then shows registering an 'smessage' event listener, subscribing to multiple channels residing in the same hash slot with 'ssubscribe', and publishing a message with 'spublish'. This approach is designed for scalable Pub/Sub in large clusters. Key requirements are correct hash slots for channels and enabling shardedSubscribers. Inputs are channel names and messages; output is count of subscriptions and published message confirmation. Constraints include the need for channels to map to the same slot per ssubscribe call.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_43\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cluster: Cluster = new Cluster([{host: host, port: port}], {shardedSubscribers: true});\n\n//Register the callback\ncluster.on(\"smessage\", (channel, message) => {\n    console.log(message);\n});\n\n        \n//Subscribe to the channels on the same slot\ncluster.ssubscribe(\"channel{my}:1\", \"channel{my}:2\").then( ( count: number ) => {\n    console.log(count);\n}).catch( (err) => {\n    console.log(err);\n});\n\n//Publish a message\ncluster.spublish(\"channel{my}:1\", \"This is a test message to my first channel.\").then((value: number) => {\n    console.log(\"Published a message to channel{my}:1\");\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Password-Protected Redis Cluster (ioredis, JavaScript)\nDESCRIPTION: This snippet shows how to connect to a password-protected Redis Cluster using ioredis in JavaScript. It demonstrates passing cluster node addresses and specifying the \"password\" option within \"redisOptions\" to authenticate all nodes using the same password. Dependency: ioredis NPM package. Inputs: array of nodes and password. Output: initialized Cluster object. All error handling uses default behavior.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_44\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst cluster = new Redis.Cluster(nodes, {\n  redisOptions: {\n    password: \"your-cluster-password\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Per-Node Password Configuration in Redis Cluster (ioredis, JavaScript)\nDESCRIPTION: This example demonstrates connecting to a Redis Cluster where nodes may have different passwords. Node-level password configuration is provided in the first parameter, while a fallback password is set in the \"redisOptions\". Dependencies: ioredis package. Key parameters are the node list with individual \"port\" and \"password\" fields, and the fallback \"redisOptions.password\". Output: Cluster object connects each node with its specific password or uses fallback if not set.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_45\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst cluster = new Redis.Cluster(\n  [\n    // Use password \"password-for-30001\" for 30001\n    { port: 30001, password: \"password-for-30001\" },\n    // Don't use password when accessing 30002\n    { port: 30002, password: null },\n    // Other nodes will use \"fallback-password\"\n  ],\n  {\n    redisOptions: {\n      password: \"fallback-password\",\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Connecting to AWS ElastiCache Redis Cluster with TLS (ioredis, JavaScript)\nDESCRIPTION: This snippet explains connecting to an AWS ElastiCache Redis Cluster using ioredis with TLS enabled. The \"dnsLookup\" option is provided to avoid certificate validation errors, and the \"tls\" key is present within \"redisOptions\" for secure connections. Dependency: ioredis and Node.js, with Node TLS support. Inputs include the ElastiCache cluster endpoint and port. Output: A secure Redis.Cluster instance.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_46\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cluster = new Redis.Cluster(\n  [\n    {\n      host: \"clustercfg.myCluster.abcdefg.xyz.cache.amazonaws.com\",\n      port: 6379,\n    },\n  ],\n  {\n    dnsLookup: (address, callback) => callback(null, address),\n    redisOptions: {\n      tls: {},\n    },\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Enabling Autopipelining in ioredis for HTTP Requests (JavaScript)\nDESCRIPTION: This example demonstrates how to use ioredis with the \"enableAutoPipelining\" option enabled to improve throughput of multiple Redis commands in response to HTTP requests. Dependencies: ioredis, http (Node.js core). The Redis client is initialized with autopipelining, and a basic HTTP server fetches values by key. Inputs: HTTP GET requests with key query param; Output: Returned Redis value. Constraints: For use in non-blocking Node.js applications; all commands issued within one event loop tick are pipelined automatically.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_47\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"./built\");\nconst http = require(\"http\");\n\nconst db = new Redis({ enableAutoPipelining: true });\n\nconst server = http.createServer((request, response) => {\n  const key = new URL(request.url, \"https://localhost:3000/\").searchParams.get(\n    \"key\"\n  );\n\n  db.get(key, (err, value) => {\n    response.writeHead(200, { \"Content-Type\": \"text/plain\" });\n    response.end(value);\n  });\n});\n\nserver.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Handling ReplyError in ioredis (JavaScript)\nDESCRIPTION: This snippet illustrates how ioredis reports Redis server errors using the ReplyError class. Dependencies: ioredis package. A call to \"set\" without required arguments triggers an error passed as the first argument to the callback. Inputs: single key; Output: error object, verified to be an instance of Redis.ReplyError. Useful for understanding error propagation in ioredis.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_48\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n// This command causes a reply error since the SET command requires two arguments.\nredis.set(\"foo\", (err) => {\n  err instanceof Redis.ReplyError;\n});\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages with ioredis Pub/Sub in JavaScript\nDESCRIPTION: Demonstrates a simple Redis publisher using ioredis that sends random messages to either 'my-channel-1' or 'my-channel-2' every second. Requires the ioredis library as a dependency. Publishes JSON-formatted messages to dynamically selected channels and logs output to the console. Input is generated randomly; outputs are sent to Redis and console. Can be used as part of a pub/sub messaging pattern and expects a running Redis server.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n// publisher.js\n\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nsetInterval(() => {\n  const message = { foo: Math.random() };\n  // Publish to my-channel-1 or my-channel-2 randomly.\n  const channel = `my-channel-${1 + Math.round(Math.random())}`;\n\n  // Message can be either a string or a buffer\n  redis.publish(channel, JSON.stringify(message));\n  console.log(\"Published %s to %s\", message, channel);\n}, 1000);\n```\n\n----------------------------------------\n\nTITLE: Using showFriendlyErrorStack for Debugging with ioredis (JavaScript)\nDESCRIPTION: This code enables the \"showFriendlyErrorStack\" option in ioredis to get developer-friendly error stacks. Dependency: ioredis. When enabled, error stacks will reference the user code location where the Redis command is issued, not just internal ioredis frames. Inputs: initialization option; Output: improved error stack trace. Should not be used in production for performance reasons.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_49\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require(\"ioredis\");\nconst redis = new Redis({ showFriendlyErrorStack: true });\nredis.set(\"foo\");\n```\n\n----------------------------------------\n\nTITLE: Getting Pipeline Length in ioredis JavaScript\nDESCRIPTION: Shows how to get the number of queued commands in an ioredis pipeline. The 'length' property on the pipeline instance returns this count, allowing dynamic introspection before execution. Input: a pipeline with added commands. Output: integer representing command count. Useful for diagnostics or flow control.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst length = redis.pipeline().set(\"foo\", \"bar\").get(\"foo\").length;\n// length === 2\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging for ioredis with DEBUG Env Variable (Shell)\nDESCRIPTION: This code demonstrates how to set the DEBUG environment variable to enable verbose logging for ioredis at runtime. Dependency: UNIX-like terminal and ioredis. The command runs a Node.js application with ioredis debug logs enabled. Useful for troubleshooting integration issues.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_51\n\nLANGUAGE: Shell\nCODE:\n```\nDEBUG=ioredis:* node app.js\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream to Incrementally Scan Redis Keys with ioredis in JavaScript\nDESCRIPTION: This snippet illustrates how to use the ioredis library to create a readable stream for incrementally scanning all the keys in a Redis database using the scanStream method. It demonstrates registering handlers for the 'data' and 'end' events to process each batch of keys as they are received. The keys are printed to the console, and the stream automatically iterates until all keys are visited. This approach avoids server blocking and handles potential duplicates as per the SCAN command semantics. Requires: Node.js and the ioredis library, with an active Redis instance.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis();\n// Create a readable stream (object mode)\nconst stream = redis.scanStream();\nstream.on(\"data\", (resultKeys) => {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (let i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", () => {\n  console.log(\"all keys have been visited\");\n});\n```\n\n----------------------------------------\n\nTITLE: Installing ioredis and TypeScript Declarations\nDESCRIPTION: Shows how to install ioredis using npm and optionally add TypeScript declarations for Node.js in a TypeScript project.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install ioredis\n\nnpm install --save-dev @types/node\n```\n\n----------------------------------------\n\nTITLE: Setting Expiry on Keys with ioredis in JavaScript\nDESCRIPTION: Shows how to set a time-to-live (TTL) for a Redis key using the 'set' method of ioredis to mark it for expiration. This approach uses the 'EX' option to specify expiration in seconds, in this example setting a key to expire after 60 seconds. Requires ioredis. Inputs are the key, data, expiry mode, and timeout; output is a status string from Redis.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nredis.set(\"key\", \"data\", \"EX\", 60);\n// Equivalent to redis command \"SET key data EX 60\", because on ioredis set method,\n// all arguments are passed directly to the redis server.\n```\n\n----------------------------------------\n\nTITLE: Transforming Command Arguments and Replies with ioredis Transformers (JavaScript)\nDESCRIPTION: Shows how to customize the serialization and interpretation of command arguments and responses using setArgumentTransformer and setReplyTransformer. Includes built-in examples for converting objects/maps into flat arrays for HMSET/MSET, and formatting HGETALL replies as either objects or arrays of arrays (especially for buffer/binary data compatibility). Transformers improve developer ergonomics and allow for specialized data handling; dependencies are the ioredis client and (when transforming maps) optional internal utilities.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", (args) => {\n  if (args.length === 2) {\n    if (args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0], ...utils.convertMapToArray(args[1])];\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0], ...utils.convertObjectToArray(args[1])];\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", (result) => {\n  if (Array.isArray(result)) {\n    const obj = {};\n    for (let i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", (err, result) => {\n  // result === 'v1';\n});\n\nredis.mset(\n  new Map([\n    [\"k3\", \"v3\"],\n    [\"k4\", \"v4\"],\n  ])\n);\nredis.get(\"k3\", (err, result) => {\n  // result === 'v3';\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nRedis.Command.setReplyTransformer(\"hgetall\", (result) => {\n  const arr = [];\n  for (let i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", (err, result) => {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm - Shell\nDESCRIPTION: Installs all necessary dependencies for the Express and ioredis application using npm. Requires Node.js and npm to be installed. When run, it reads the package.json to install Express, ioredis, and any other defined dependencies. There are no required parameters; the working directory should contain the correct package.json. Output includes progress and status of installations.\nSOURCE: https://github.com/redis/ioredis/blob/main/examples/express/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n\n```\n\n----------------------------------------\n\nTITLE: Starting the Express-ioredis Application - Shell\nDESCRIPTION: Starts the Express server that uses ioredis, relying on the npm start script as defined in package.json. Assumes prior successful installation of dependencies. The command launches the server, which is expected to be accessible at http://localhost:3000. It does not accept parameters and is intended to be run from the application's root directory. Output includes server logs or startup messages.\nSOURCE: https://github.com/redis/ioredis/blob/main/examples/express/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm start\n\n```\n\n----------------------------------------\n\nTITLE: Running Tests for ioredis Project (npm test, Shell)\nDESCRIPTION: This command snippet shows how to execute the ioredis test suite using npm. Prerequisite: Local Redis server running at 127.0.0.1:6379. The command triggers the test script defined in package.json. All Redis data will be flushed between tests, so use caution if data persistence is required.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_50\n\nLANGUAGE: Shell\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Redis Class Instantiation\nDESCRIPTION: Correct way to instantiate Redis class in modern versions\nSOURCE: https://github.com/redis/ioredis/blob/main/CHANGELOG.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew Redis()\n```\n\n----------------------------------------\n\nTITLE: Custom Redis Error-Based Reconnection with reconnectOnError in ioredis (JavaScript)\nDESCRIPTION: This code example configures ioredis to reconnect automatically when specific Redis errors (such as 'READONLY') are encountered, using the reconnectOnError option. The provided function checks the error message and returns true to trigger reconnection. Optionally, returning 2 will also cause ioredis to resend the failed command after reconnecting. Useful for certain failover scenarios. Requires ioredis and Node.js.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({\n  reconnectOnError(err) {\n    const targetError = \"READONLY\";\n    if (err.message.includes(targetError)) {\n      // Only reconnect when the error contains \"READONLY\"\n      return true; // or `return 1;`\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Promise Implementation in ioredis - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to override the default native Promise used by ioredis with Bluebird for extended promise capabilities. It requires the ioredis and bluebird npm modules and shows how to check the constructor of returned promises to verify which implementation is in use. Key parameters include the choice of Promise library assigned to Redis.Promise. The configuration can be changed at runtime, and all code using ioredis will use the current Promise implementation. Inputs are ioredis options and code using Redis commands. Outputs are promise objects constructed with the configured Promise library. Note that switching away from native Promise may be necessary if your code relies on Bluebird-specific methods (e.g., timeout).\nSOURCE: https://github.com/redis/ioredis/blob/main/CHANGELOG.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Redis = require('ioredis')\\nRedis.Promise = require('bluebird')\\n\\nconst redis = new Redis()\\n\\n// Use bluebird\\nassert.equal(redis.get().constructor, require('bluebird'))\\n\\n// You can change the Promise implementation at any time:\\nRedis.Promise = global.Promise\\nassert.equal(redis.get().constructor, global.Promise)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis with Lazy Connect Mode - JavaScript\nDESCRIPTION: This snippet demonstrates establishing a lazy connection to a Redis server using ioredis in JavaScript. By passing the 'lazyConnect: true' option to the Redis constructor, the connection does not start immediately. Instead, calling redis.connect() initiates the connection, and the returned promise resolves once the client status is 'ready'. The only dependency is the ioredis package. Key input is the Redis options object. The expected output is a resolved promise when the connection is fully available for use (not when it is just established). This approach is useful for deferring connection setup until explicitly needed. The snippet illustrates how to verify the connection's readiness by checking redis.status.\nSOURCE: https://github.com/redis/ioredis/blob/main/CHANGELOG.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst redis = new Redis({ lazyConnect: true })\\nredis.connect().then(() => {\\n  assert(redis.status === 'ready')\\n})\n```\n\n----------------------------------------\n\nTITLE: Node.js Redis URI Connection Example\nDESCRIPTION: Example of connecting to Redis using URI format with username and authentication\nSOURCE: https://github.com/redis/ioredis/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew Redis(\"redis://username:authpassword@127.0.0.1:6380/4\")\n```\n\n----------------------------------------\n\nTITLE: Disabling the Redis Offline Queue with enableOfflineQueue in ioredis (JavaScript)\nDESCRIPTION: This snippet configures ioredis to disable the offline queue feature by setting enableOfflineQueue to false. Normally, commands issued before the connection is ready are queued for later execution; disabling this causes such commands to be rejected immediately. This setting is useful for applications requiring strict connection and command success guarantees. Requires ioredis and Node.js.\nSOURCE: https://github.com/redis/ioredis/blob/main/README.md#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nconst redis = new Redis({ enableOfflineQueue: false });\n```\n\n----------------------------------------\n\nTITLE: Redis URI Connection Without Username\nDESCRIPTION: Example of connecting to Redis using URI format without a username\nSOURCE: https://github.com/redis/ioredis/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\")\n```"
  }
]