[
  {
    "owner": "paradigmxyz",
    "repo": "artemis",
    "content": "TITLE: Implementing OpenSea to Sudoswap NFT Arbitrage Contract with Inline Yul Assembly\nDESCRIPTION: A contract that buys NFTs from OpenSea's Seaport protocol and sells them to Sudoswap pools for profit. The implementation uses inline Yul assembly for gas optimization and includes constant memory pointers, selectors, and a specialized assembly block for executing the arbitrage.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/README.md#2025-04-16_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Seaport} from \"../src/protocols/Seaport/contracts/Seaport.sol\";\nimport {LSSVMPairETH} from \"../src/protocols/LSSVMPairFactory/contracts/LSSVMPairETH.sol\";\nimport {BasicOrderParameters} from \"../src/protocols/Seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {IERC721} from \"../src/protocols/LSSVMPairFactory/contracts/imports/IERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract SudoOpenseaArbFast is Owned {\n\n    // Function and Error Selectors\n    uint256 constant fulfillBasicOrderSelector = 0xfb0f3ee1;\n    uint256 constant approveSelector = 0x095ea7b3;\n    uint256 constant swapNFTsForTokenSelector = 0xb1d3f1c1;\n    uint256 constant NoProfitSelector = 0xe39aafee;\n\n    // Memory Pointers\n    uint256 constant selectorMemPtr = 0x00;\n    uint256 constant argument0MemPtr = 0x20;\n    uint256 constant argument1MemPtr = 0x40;\n    uint256 constant argument2MemPtr = 0x60;\n    uint256 constant argument3MemPtr = 0x80;\n    uint256 constant argument4MemPtr = 0xa0;\n    uint256 constant argument5MemPtr = 0xc0;\n    uint256 constant argument6MemPtr = 0xe0;\n    uint256 constant callArumentsMemPtr = 0x1c;\n    uint256 constant errorMemPtr = 0x1c;\n    uint256 constant nftIdsMemPtr = 0xa0;\n    uint256 constant basicOrderParametersMemPtr = 0x20;\n\n    // Calldata Pointers\n    uint256 constant basicOrderParametersCdPtr = 0x64;\n    uint256 constant offerTokenCdPtr = 0x104;\n    uint256 constant offerIdentifierCdPtr = 0x124;\n    uint256 constant sudoPoolCdPtr = 0x44;\n\n    // Lengths\n    uint256 constant fulfillBasicOrderBaseLen = 0x24;\n    uint256 constant approveLen = 0x44;\n    uint256 constant swapNFTsForTokenLen = 0xe4;\n    uint256 constant wordLen = 0x20;\n    uint256 constant nftIdsLen = 0x01;\n\n    // Misc\n    uint256 constant zero = 0x00;\n\n    address constant seaport = 0x00000000000001ad428e4906aE43D8F9852d0dD6;\n\n    constructor() Owned(msg.sender) {}\n\n    function executeArb(BasicOrderParameters calldata, uint256 paymentValue, address payable sudo_pool) public {\n        assembly {\n            let initialBalance := selfbalance()\n            let offerIdentifier := calldataload(0x124)\n            let basicOrderLen := sub(calldatasize(), 0x64)\n\n            // buy NFT on opensea\n            mstore(selectorMemPtr, fulfillBasicOrderSelector)\n            mstore(argument0MemPtr, basicOrderParametersMemPtr)\n            calldatacopy(argument1MemPtr, basicOrderParametersCdPtr, basicOrderLen)\n            call_unwrap(\n                gas(),\n                seaport,\n                paymentValue,\n                callArumentsMemPtr,\n                add(basicOrderLen, fulfillBasicOrderBaseLen),\n                zero,\n                zero\n            )\n\n            // set approval for sudo pool\n            mstore(selectorMemPtr, approveSelector)\n            mstore(argument0MemPtr, sudo_pool)\n            mstore(argument1MemPtr, offerIdentifier)\n            call_unwrap(\n                gas(),\n                calldataload(offerTokenCdPtr),\n                zero,\n                callArumentsMemPtr,\n                approveLen,\n                zero,\n                zero\n            )\n\n            // sell into pool\n            mstore(selectorMemPtr, swapNFTsForTokenSelector)\n            mstore(argument0MemPtr, nftIdsMemPtr)\n            mstore(argument1MemPtr, zero)\n            mstore(argument2MemPtr, address())\n            mstore(argument3MemPtr, zero)\n            mstore(argument4MemPtr, zero)\n            mstore(argument5MemPtr, nftIdsLen)\n            mstore(argument6MemPtr, offerIdentifier)\n            call_unwrap(\n                gas(),\n                sudo_pool,\n                zero,\n                callArumentsMemPtr,\n                swapNFTsForTokenLen,\n                zero,\n                zero\n            )\n\n            // revert if no profit\n            if iszero(gt(selfbalance(), initialBalance)) {\n                mstore(zero, NoProfitSelector)\n                revert(errorMemPtr, wordLen)\n            }\n\n            function call_unwrap(g, addr, val, argMemPtr, arglen, retMemPtr, retlen) {\n                if iszero(call(g, addr, val, argMemPtr, arglen, retMemPtr, retlen)) {\n                    returndatacopy(zero, zero, returndatasize())\n                    revert(zero, returndatasize())\n                }\n            }\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenSeaV2Client and Fulfilling Listing in Rust\nDESCRIPTION: This snippet demonstrates how to create an OpenSeaV2Client instance and use it to fulfill a listing. It includes setting up the client with an API key, creating a FulfillListingRequest with specific listing details, and sending the request.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/clients/opensea-v2/README.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet client = OpenSeaV2Client::new(OpenSeaApiConfig { api_key });\n\nlet req = FulfillListingRequest {\n    listing: Listing {\n        hash: H256::from_str(\n            \"0xce83ef67f520d74d081aa4da9588ee6743d3aa64caff98a7dddf214e10469929\",\n        )\n        .unwrap(),\n        chain: Chain::Mainnet,\n        protocol_version: ProtocolVersion::V1_4,\n    },\n    fulfiller: Fulfiller {\n        address: H160::from_str(\"0xD77F375A33b1109e82f3C46A30537F1E019708eB\").unwrap(),\n    },\n};\nlet resp = client.fulfill_listing(req).await;\nprintln!(\"{:?}\", resp);\n```\n\n----------------------------------------\n\nTITLE: Implementing Artemis Engine with Chainbound Integration\nDESCRIPTION: Main application code demonstrating how to set up and run an Artemis engine with Chainbound's Fiber Collector for mempool monitoring and Echo Executor for MEV bundle submission. Shows initialization of providers, signers, and engine components.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/clients/chainbound/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Arc;\n\nuse artemis_core::{engine::Engine, types::ExecutorMap};\nuse chainbound_artemis::{Action, EchoExecutor, Event, FiberCollector, StreamType};\nuse ethers::{prelude::rand, providers::Provider, signers::LocalWallet};\n\n#[tokio::main]\npub async fn main() -> anyhow::Result<()> {\n    // Join the Chainbound Discord at https://discord.com/invite/J4KNdeCYGX\n    // or write to <sales@chainbound.io> to get a free trial.\n    let api_key = std::env::var(\"CHAINBOUND_API_KEY\")?;\n\n    // You can select your desired object type to stream here.\n    // Please refer to the documentation at https://fiber.chainbound.io/docs/intro for more details.\n    //\n    // Possible values are:\n    // - StreamType::Transactions: new pending transactions in the mempool\n    // - StreamType::ExecutionHeaders: new execution headers (blocks) without the transactions\n    // - StreamType::ExecutionPayloads: new blocks with header + all transactions included\n    // - StreamType::BeaconBlocks: new beacon blocks (ETH2 consensus-layer blocks)\n    let stream_type = StreamType::Transactions;\n\n    // Simply create a new collector\n    let fiber_collector = Box::new(FiberCollector::new(api_key.clone(), stream_type).await);\n\n    // Now create the Echo Executor to send your bundles to your desired block builders.\n    // We also need to instantiate a regular HTTP provider middleware, and two signers\n    // (one to actually sign the transactions, one for Flashbots' authentication header)\n    //\n    // For more info, please refer to the documentation at https://echo.chainbound.io/docs/architecture\n    let provider = Arc::new(Provider::connect(\"wss://eth.llamarpc.com\").await.unwrap());\n    let tx_signer = LocalWallet::new(&mut rand::thread_rng()); // or any other signer\n    let auth_signer = LocalWallet::new(&mut rand::thread_rng()); // or any other signer\n    let echo_executor = Box::new(EchoExecutor::new(provider, tx_signer, auth_signer, api_key));\n\n    let executor_map = ExecutorMap::new(echo_executor, |action| match action {\n        Action::SendBundle(bundle) => Some(bundle),\n    });\n\n    // And add these components to your Artemis engine\n    let mut engine: Engine<Event, Action> = Engine::default();\n    engine.add_collector(fiber_collector);\n    engine.add_executor(Box::new(executor_map));\n\n    // --- bootstrap your trading strategy here ---\n\n    // Finally, run the engine\n    if let Ok(mut set) = engine.run().await {\n        while let Some(res) = set.join_next().await {\n            println!(\"res: {:?}\", res);\n        }\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Using stdStorage for Storage Manipulation in Solidity\nDESCRIPTION: Example demonstrating the stdStorage utility to find and manipulate contract storage slots without knowing the storage layout. Shows how to target regular variables, mappings, and structs.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    using stdStorage for StdStorage;\n\n    Storage test;\n\n    function setUp() public {\n        test = new Storage();\n    }\n\n    function testFindExists() public {\n        // Lets say we want to find the slot for the public\n        // variable `exists`. We just pass in the function selector\n        // to the `find` command\n        uint256 slot = stdstore.target(address(test)).sig(\"exists()\").find();\n        assertEq(slot, 0);\n    }\n\n    function testWriteExists() public {\n        // Lets say we want to write to the slot for the public\n        // variable `exists`. We just pass in the function selector\n        // to the `checked_write` command\n        stdstore.target(address(test)).sig(\"exists()\").checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    // It supports arbitrary storage layouts, like assembly based storage locations\n    function testFindHidden() public {\n        // `hidden` is a random hash of a bytes, iteration through slots would\n        // not find it. Our mechanism does\n        // Also, you can use the selector instead of a string\n        uint256 slot = stdstore.target(address(test)).sig(test.hidden.selector).find();\n        assertEq(slot, uint256(keccak256(\"my.random.var\")));\n    }\n\n    // If targeting a mapping, you have to pass in the keys necessary to perform the find\n    // i.e.:\n    function testFindMapping() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.map_addr.selector)\n            .with_key(address(this))\n            .find();\n        // in the `Storage` constructor, we wrote that this address' value was 1 in the map\n        // so when we load the slot, we expect it to be 1\n        assertEq(uint(vm.load(address(test), bytes32(slot))), 1);\n    }\n\n    // If the target is a struct, you can specify the field depth:\n    function testFindStruct() public {\n        // NOTE: see the depth parameter - 0 means 0th field, 1 means 1st field, etc.\n        uint256 slot_for_a_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(0)\n            .find();\n\n        uint256 slot_for_b_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(1)\n            .find();\n\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_a_field))), 1);\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_b_field))), 2);\n    }\n}\n\n// A complex storage contract\ncontract Storage {\n    struct UnpackedStruct {\n        uint256 a;\n        uint256 b;\n    }\n\n    constructor() {\n        map_addr[msg.sender] = 1;\n    }\n\n    uint256 public exists = 1;\n    mapping(address => uint256) public map_addr;\n    // mapping(address => Packed) public map_packed;\n    mapping(address => UnpackedStruct) public map_struct;\n    mapping(address => mapping(address => uint256)) public deep_map;\n    mapping(address => mapping(address => UnpackedStruct)) public deep_map_struct;\n    UnpackedStruct public basicStruct = UnpackedStruct({\n        a: 1,\n        b: 2\n    });\n\n    function hidden() public view returns (bytes32 t) {\n        // an extremely hidden storage slot\n        bytes32 slot = keccak256(\"my.random.var\");\n        assembly {\n            t := sload(slot)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying SudoOpenseaArb Contract in Solidity\nDESCRIPTION: Demonstrates how to deploy the precompiled SudoOpenseaArb contract from the SudoOpenseaArbCompiled library. The deployment sets the caller as the owner of the contract.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/README.md#2025-04-16_snippet_0\n\nLANGUAGE: solidity\nCODE:\n```\n// deploys the contract where the caller is the owner.\naddress deployment = SudoOpenseaArbCompiled.deploy();\n\n// returns the initialization code.\nbytes memory initcode = SudoOpenseaArbCompiled.initcode;\n```\n\n----------------------------------------\n\nTITLE: Using console2.log for Debugging in Solidity Tests\nDESCRIPTION: Example of importing and using the console2.log utility for debugging in Solidity tests, which provides properly decoded logs in Forge traces.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console2.sol\";\n...\nconsole2.log(someValue);\n```\n\n----------------------------------------\n\nTITLE: Using console.log in Solidity Tests\nDESCRIPTION: Demonstrates how to use console.log for debugging in Forge tests. It shows two different import methods for console logging, with a recommendation to use console2.sol for better log decoding in Forge traces.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_4\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console2.sol\";\n...\nconsole2.log(someValue);\n```\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console.sol\";\n...\nconsole.log(someValue);\n```\n\n----------------------------------------\n\nTITLE: Displaying Solmate Contract Structure in ML\nDESCRIPTION: This code snippet presents the structure of Solmate contracts using an ML-like syntax. It outlines various components including auth, mixins, tokens, and utilities, each with brief descriptions.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_0\n\nLANGUAGE: ml\nCODE:\n```\nauth\n├─ Owned — \"Simple single owner authorization\"\n├─ Auth — \"Flexible and updatable auth pattern\"\n├─ authorities\n│  ├─ RolesAuthority — \"Role based Authority that supports up to 256 roles\"\n│  ├─ MultiRolesAuthority — \"Flexible and target agnostic role based Authority\"\nmixins\n├─ ERC4626 — \"Minimal ERC4626 tokenized Vault implementation\"\ntokens\n├─ WETH — \"Minimalist and modern Wrapped Ether implementation\"\n├─ ERC20 — \"Modern and gas efficient ERC20 + EIP-2612 implementation\"\n├─ ERC721 — \"Modern, minimalist, and gas efficient ERC721 implementation\"\n├─ ERC1155 — \"Minimalist and gas efficient standard ERC1155 implementation\"\nutils\n├─ SSTORE2 — \"Library for cheaper reads and writes to persistent storage\"\n├─ CREATE3 — \"Deploy to deterministic addresses without an initcode factor\"\n├─ LibString — \"Library for creating string representations of uint values\"\n├─ SafeCastLib — \"Safe unsigned integer casting lib that reverts on overflow\"\n├─ SignedWadMath — \"Signed integer 18 decimal fixed point arithmetic library\"\n├─ MerkleProofLib — \"Efficient merkle tree inclusion proof verification library\"\n├─ ReentrancyGuard — \"Gas optimized reentrancy protection for smart contracts\"\n├─ FixedPointMathLib — \"Arithmetic library with operations for fixed-point numbers\"\n├─ Bytes32AddressLib — \"Library for converting between addresses and bytes32 values\"\n├─ SafeTransferLib — \"Safe ERC20/ETH transfer lib that handles missing return values\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Contract Structure Hierarchy in ML\nDESCRIPTION: This code block presents the hierarchical structure of the Solmate contract library using ML notation, organizing contracts into categories like auth, mixins, tokens, and utils with descriptions for each component.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_0\n\nLANGUAGE: ml\nCODE:\n```\nauth\n├─ Owned — \"Simple single owner authorization\"\n├─ Auth — \"Flexible and updatable auth pattern\"\n├─ authorities\n│  ├─ RolesAuthority — \"Role based Authority that supports up to 256 roles\"\n│  ├─ MultiRolesAuthority — \"Flexible and target agnostic role based Authority\"\nmixins\n├─ ERC4626 — \"Minimal ERC4626 tokenized Vault implementation\"\ntokens\n├─ WETH — \"Minimalist and modern Wrapped Ether implementation\"\n├─ ERC20 — \"Modern and gas efficient ERC20 + EIP-2612 implementation\"\n├─ ERC721 — \"Modern, minimalist, and gas efficient ERC721 implementation\"\n├─ ERC1155 — \"Minimalist and gas efficient standard ERC1155 implementation\"\nutils\n├─ SSTORE2 — \"Library for cheaper reads and writes to persistent storage\"\n├─ CREATE3 — \"Deploy to deterministic addresses without an initcode factor\"\n├─ LibString — \"Library for creating string representations of uint values\"\n├─ SafeCastLib — \"Safe unsigned integer casting lib that reverts on overflow\"\n├─ SignedWadMath — \"Signed integer 18 decimal fixed point arithmetic library\"\n├─ MerkleProofLib — \"Efficient merkle tree inclusion proof verification library\"\n├─ ReentrancyGuard — \"Gas optimized reentrancy protection for smart contracts\"\n├─ FixedPointMathLib — \"Arithmetic library with operations for fixed-point numbers\"\n├─ Bytes32AddressLib — \"Library for converting between addresses and bytes32 values\"\n├─ SafeTransferLib — \"Safe ERC20/ETH transfer lib that handles missing return values\"\n```\n\n----------------------------------------\n\nTITLE: Defining BasicOrderParameters Struct in Solidity\nDESCRIPTION: Defines the BasicOrderParameters struct used in the executeArb function. This struct contains various parameters related to order execution in the Seaport protocol.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/README.md#2025-04-16_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nstruct BasicOrderParameters {\n    address considerationToken;                     // 0x24\n    uint256 considerationIdentifier;                // 0x44\n    uint256 considerationAmount;                    // 0x64\n    address payable offerer;                        // 0x84\n    address zone;                                   // 0xa4\n    address offerToken;                             // 0xc4\n    uint256 offerIdentifier;                        // 0xe4\n    uint256 offerAmount;                            // 0x104\n    BasicOrderType basicOrderType;                  // 0x124\n    uint256 startTime;                              // 0x144\n    uint256 endTime;                                // 0x164\n    bytes32 zoneHash;                               // 0x184\n    uint256 salt;                                   // 0x1a4\n    bytes32 offererConduitKey;                      // 0x1c4\n    bytes32 fulfillerConduitKey;                    // 0x1e4\n    uint256 totalOriginalAdditionalRecipients;      // 0x204\n    AdditionalRecipient[] additionalRecipients;     // 0x224\n    bytes signature;                                // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AdditionalRecipient Struct in Solidity\nDESCRIPTION: Defines the AdditionalRecipient struct used in the BasicOrderParameters. This struct contains information about additional recipients in an order.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/README.md#2025-04-16_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n```\n\n----------------------------------------\n\nTITLE: Using stdError for Error Testing in Solidity\nDESCRIPTION: Example of using the stdError utility to test for specific error types in Solidity tests. This demonstrates how to expect an arithmetic error when a function underflows.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function testExpectArithmetic() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n}\n\ncontract ErrorsTest {\n    function arithmeticError(uint256 a) public {\n        uint256 a = a - 100;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using stdError in Solidity Tests\nDESCRIPTION: Example of using stdError contract for expecting reverts in Forge tests. It demonstrates how to use the arithmeticError from stdError.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_1\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    ErrorsTest test;\n\n    function setUp() public {\n        test = new ErrorsTest();\n    }\n\n    function testExpectArithmetic() public {\n        vm.expectRevert(stdError.arithmeticError);\n        test.arithmeticError(10);\n    }\n}\n\ncontract ErrorsTest {\n    function arithmeticError(uint256 a) public {\n        uint256 a = a - 100;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using stdCheats for Address Pranking in Solidity Tests\nDESCRIPTION: Example showing how to use the stdCheats utility to manipulate the sender address and balance in tests. Demonstrates both hoax (one-time prank with ETH) and startHoax (persistent prank with ETH).\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// Inherit the stdCheats\ncontract StdCheatsTest is Test {\n    Bar test;\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testHoax() public {\n        // we call `hoax`, which gives the target address\n        // eth and then calls `prank`\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n\n        // overloaded to allow you to specify how much eth to\n        // initialize the address with\n        hoax(address(1337), 1);\n        test.bar{value: 1}(address(1337));\n    }\n\n    function testStartHoax() public {\n        // we call `startHoax`, which gives the target address\n        // eth and then calls `startPrank`\n        //\n        // it is also overloaded so that you can specify an eth amount\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n}\n\ncontract Bar {\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using stdCheats in Solidity Tests\nDESCRIPTION: Shows how to use stdCheats for pranking and hoaxing in Forge tests. It includes examples of using hoax and startHoax functions to manipulate sender address and balance.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_3\n\nLANGUAGE: solidity\nCODE:\n```\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\ncontract StdCheatsTest is Test {\n    Bar test;\n    function setUp() public {\n        test = new Bar();\n    }\n\n    function testHoax() public {\n        hoax(address(1337));\n        test.bar{value: 100}(address(1337));\n\n        hoax(address(1337), 1);\n        test.bar{value: 1}(address(1337));\n    }\n\n    function testStartHoax() public {\n        startHoax(address(1337));\n        test.bar{value: 100}(address(1337));\n        test.bar{value: 100}(address(1337));\n        vm.stopPrank();\n        test.bar(address(this));\n    }\n}\n\ncontract Bar {\n    function bar(address expectedSender) public payable {\n        require(msg.sender == expectedSender, \"!prank\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Legacy console.log for Hardhat Compatibility\nDESCRIPTION: Example of importing and using the legacy console.log utility for Hardhat compatibility, with a note about the limitations regarding uint256 and int256 types.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_5\n\nLANGUAGE: solidity\nCODE:\n```\n// import it indirectly via Test.sol\nimport \"forge-std/Test.sol\";\n// or directly import it\nimport \"forge-std/console.sol\";\n...\nconsole.log(someValue);\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for Artemis-Chainbound Integration\nDESCRIPTION: Cargo.toml configuration showing required dependencies for integrating Artemis with Chainbound services. Includes core dependencies for Artemis, Chainbound integration, Ethers, Tokio async runtime, and error handling.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/clients/chainbound/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nartemis-core = { git = \"https://github.com/paradigmxyz/artemis.git\" }\nchainbound-artemis = { git = \"https://github.com/paradigmxyz/artemis.git\" }\n\n# the following dependencies are also used in this example\nethers = {  version = \"2\", features = [\"ws\", \"rustls\"] }\ntokio = { version = \"1.18\", features = [\"full\"] }\nanyhow = \"1.0.70\"\n```\n\n----------------------------------------\n\nTITLE: Running Opensea Sudoswap Arbitrage Strategy in Shell\nDESCRIPTION: Command to run the Opensea Sudoswap arbitrage strategy with required parameters such as WebSocket URL, API keys, private key, contract address, and bid percentage.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run -- --wss <INFURA_OR_ALCHEMY_KEY> --opensea-api-key <OPENSEA_API_KEY> --private-key <PRIVATE_KEY> --arb-contract-address <ARB_CONTRACT_ADDRESS> --bid-percentage <BID_PERCENTAGE>\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Bindings for Solidity Contracts\nDESCRIPTION: Command to regenerate Rust bindings for the Solidity contracts used in the strategy.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nforge bind --bindings-path ./bindings --root ./contracts --crate-name bindings\n```\n\n----------------------------------------\n\nTITLE: Generating Rust Bindings for Solidity Contracts\nDESCRIPTION: Command to regenerate Rust bindings from Solidity contracts using Forge bind tool. Creates type-safe Rust interfaces for contract interaction.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nforge bind --bindings-path ./bindings --root ./contracts --crate-name bindings --overwrite\n```\n\n----------------------------------------\n\nTITLE: Installing Solmate with Foundry in Shell\nDESCRIPTION: This code snippet shows how to install Solmate using Foundry, a popular Ethereum development tool. It uses the 'forge install' command to add Solmate to your project.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nforge install transmissions11/solmate\n```\n\n----------------------------------------\n\nTITLE: Installing Solmate with Foundry\nDESCRIPTION: This code snippet shows how to install the Solmate library using the Foundry Ethereum development environment via the forge command line tool.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nforge install transmissions11/solmate\n```\n\n----------------------------------------\n\nTITLE: Installing Solmate with NPM for Hardhat or Truffle in Shell\nDESCRIPTION: This code snippet demonstrates how to install Solmate using NPM for Hardhat or Truffle, which are popular Ethereum development frameworks. It uses the 'npm install' command to add Solmate to your project.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install solmate\n```\n\n----------------------------------------\n\nTITLE: Installing Solmate with Hardhat or Truffle\nDESCRIPTION: This code snippet demonstrates how to install the Solmate library using npm for Hardhat or Truffle development environments.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/solmate/README.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install solmate\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Opensea V2 Rust Bindings\nDESCRIPTION: This snippet shows the commands for checking, testing, and building the Opensea V2 Rust bindings. It includes options for both debug and release builds.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/clients/opensea-v2/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo check\ncargo test\ncargo build [--release]\n```\n\n----------------------------------------\n\nTITLE: Running Solidity Tests with Alchemy/Infura Key\nDESCRIPTION: Command to run Solidity tests for the strategy. Requires an Alchemy or Infura key for access to Ethereum mainnet.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nETH_MAINNET_HTTP=<YOUR_KEY> forge test --root ./contracts\n```\n\n----------------------------------------\n\nTITLE: Running Solidity Tests with Forge\nDESCRIPTION: Command to execute Solidity tests using Forge test runner. Requires an Ethereum RPC URL for mainnet access.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nETH_MAINNET_HTTP=<YOUR_RPC_URL> forge test --root ./contracts\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests for the Strategy\nDESCRIPTION: Command to execute Rust tests for the MEV Share Uniswap arbitrage strategy.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests\nDESCRIPTION: Command to execute Rust test suite for the arbitrage strategy implementation.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Artemis in Shell\nDESCRIPTION: Command to run all tests for the Artemis project using Cargo.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --all\n```\n\n----------------------------------------\n\nTITLE: Verifying Huff Compiler Output with Forge Script\nDESCRIPTION: Bash command to run a Forge script that verifies the Huff compiler output matches the expected bytecode. Requires FFI to be enabled and the Huff compiler to be installed.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# runs the script with ffi enabled.\n# `huffc` is required for verification.\nforge script ./scripts/VerifyHuff.s.sol --ffi\n```\n\n----------------------------------------\n\nTITLE: Installing Forge Standard Library using Forge\nDESCRIPTION: Command to install the Forge Standard Library in a Foundry project using the forge command line tool.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/mev-share-uni-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nforge install foundry-rs/forge-std\n```\n\n----------------------------------------\n\nTITLE: Installing Forge Standard Library with Forge\nDESCRIPTION: Command to install the Forge Standard Library using Forge package manager.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nforge install foundry-rs/forge-std\n```\n\n----------------------------------------\n\nTITLE: Cloning Artemis Repository in Shell\nDESCRIPTION: Commands to clone the Artemis GitHub repository and navigate to the project directory.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/paradigmxyz/artemis\ncd artemis\n```\n\n----------------------------------------\n\nTITLE: Using stdStorage in Solidity Tests\nDESCRIPTION: Demonstrates the usage of stdStorage for finding and writing to storage slots in Forge tests. It includes examples of finding slots for various variable types and structures.\nSOURCE: https://github.com/paradigmxyz/artemis/blob/main/crates/strategies/opensea-sudo-arb/contracts/lib/forge-std/README.md#2025-04-16_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nimport \"forge-std/Test.sol\";\n\ncontract TestContract is Test {\n    using stdStorage for StdStorage;\n\n    Storage test;\n\n    function setUp() public {\n        test = new Storage();\n    }\n\n    function testFindExists() public {\n        uint256 slot = stdstore.target(address(test)).sig(\"exists()\").find();\n        assertEq(slot, 0);\n    }\n\n    function testWriteExists() public {\n        stdstore.target(address(test)).sig(\"exists()\").checked_write(100);\n        assertEq(test.exists(), 100);\n    }\n\n    function testFindHidden() public {\n        uint256 slot = stdstore.target(address(test)).sig(test.hidden.selector).find();\n        assertEq(slot, uint256(keccak256(\"my.random.var\")));\n    }\n\n    function testFindMapping() public {\n        uint256 slot = stdstore\n            .target(address(test))\n            .sig(test.map_addr.selector)\n            .with_key(address(this))\n            .find();\n        assertEq(uint(vm.load(address(test), bytes32(slot))), 1);\n    }\n\n    function testFindStruct() public {\n        uint256 slot_for_a_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(0)\n            .find();\n\n        uint256 slot_for_b_field = stdstore\n            .target(address(test))\n            .sig(test.basicStruct.selector)\n            .depth(1)\n            .find();\n\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_a_field))), 1);\n        assertEq(uint(vm.load(address(test), bytes32(slot_for_b_field))), 2);\n    }\n}\n```"
  }
]