[
  {
    "owner": "modelcontextprotocol",
    "repo": "typescript-sdk",
    "content": "TITLE: Creating an Echo Server with MCP (TypeScript)\nDESCRIPTION: This snippet creates a simple echo server using the MCP TypeScript SDK. It defines a resource, a tool, and a prompt, all named 'echo', that simply echo back the input message. It uses the `@modelcontextprotocol/sdk/server/mcp.js` module and `zod` for input validation.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"Echo\",\n  version: \"1.0.0\"\n});\n\nserver.resource(\n  \"echo\",\n  new ResourceTemplate(\"echo://{message}\", { list: undefined }),\n  async (uri, { message }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Resource echo: ${message}`\n    }]\n  })\n);\n\nserver.tool(\n  \"echo\",\n  { message: z.string() },\n  async ({ message }) => ({\n    content: [{ type: \"text\", text: `Tool echo: ${message}` }]\n  })\n);\n\nserver.prompt(\n  \"echo\",\n  { message: z.string() },\n  ({ message }) => ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please process this message: ${message}`\n      }\n    }]\n  })\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple MCP Server\nDESCRIPTION: This TypeScript code creates a simple MCP server with a calculator tool and a dynamic greeting resource. It demonstrates how to define tools and resources using the SDK and connect to a standard input/output transport.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"Demo\",\n  version: \"1.0.0\"\n});\n\n// Add an addition tool\nserver.tool(\"add\",\n  { a: z.number(), b: z.number() },\n  async ({ a, b }) => ({\n    content: [{ type: \"text\", text: String(a + b) }]\n  })\n);\n\n// Add a dynamic greeting resource\nserver.resource(\n  \"greeting\",\n  new ResourceTemplate(\"greeting://{name}\", { list: undefined }),\n  async (uri, { name }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Hello, ${name}!`\n    }]\n  })\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Writing MCP Clients with the SDK (TypeScript)\nDESCRIPTION: This snippet demonstrates writing an MCP client using the SDK. It initializes a client, connects it to a server via `StdioClientTransport`, and then calls several methods to interact with the server, including listing prompts and resources, getting a specific prompt, reading a resource, and calling a tool.  It uses the `@modelcontextprotocol/sdk/client/index.js` and `@modelcontextprotocol/sdk/client/stdio.js` modules.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\n\nconst transport = new StdioClientTransport({\n  command: \"node\",\n  args: [\"server.js\"]\n});\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\"\n  }\n);\n\nawait client.connect(transport);\n\n// List prompts\nconst prompts = await client.listPrompts();\n\n// Get a prompt\nconst prompt = await client.getPrompt({\n  name: \"example-prompt\",\n  arguments: {\n    arg1: \"value\"\n  }\n});\n\n// List resources\nconst resources = await client.listResources();\n\n// Read a resource\nconst resource = await client.readResource({\n  uri: \"file:///example.txt\"\n});\n\n// Call a tool\nconst result = await client.callTool({\n  name: \"example-tool\",\n  arguments: {\n    arg1: \"value\"\n  }\n});\n\n```\n\n----------------------------------------\n\nTITLE: Dynamic Server Updates in MCP (TypeScript)\nDESCRIPTION: This snippet demonstrates how to dynamically add, update, or remove tools after the MCP server is connected. It creates a server with two tools: `listMessages` and `putMessage`. Initially, `putMessage` is disabled. The `upgradeAuthTool` allows enabling `putMessage` based on user authentication, dynamically updating the available tools and emitting `listChanged` notifications. The paramSchema of `upgradeAuthTool` is changed dynamically based on the permission level, and the tool itself is removed when admin access is obtained.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"Dynamic Example\",\n  version: \"1.0.0\"\n});\n\nconst listMessageTool = server.tool(\n  \"listMessages\",\n  { channel: z.string() },\n  async ({ channel }) => ({\n    content: [{ type: \"text\", text: await listMessages(channel) }]\n  })\n);\n\nconst putMessageTool = server.tool(\n  \"putMessage\",\n  { channel: z.string(), message: z.string() },\n  async ({ channel, message }) => ({\n    content: [{ type: \"text\", text: await putMessage(channel, string) }]\n  })\n);\n// Until we upgrade auth, `putMessage` is disabled (won't show up in listTools)\nputMessageTool.disable()\n\nconst upgradeAuthTool = server.tool(\n  \"upgradeAuth\",\n  { permission: z.enum([\"write', vadmin\"])},\n  // Any mutations here will automatically emit `listChanged` notifications\n  async ({ permission }) => {\n    const { ok, err, previous } = await upgradeAuthAndStoreToken(permission)\n    if (!ok) return {content: [{ type: \"text\", text: `Error: ${err}` }]}\n\n    // If we previously had read-only access, 'putMessage' is now available\n    if (previous === \"read\") {\n      putMessageTool.enable()\n    }\n\n    if (permission === 'write') {\n      // If we've just upgraded to 'write' permissions, we can still call 'upgradeAuth' \n      // but can only upgrade to 'admin'. \n      upgradeAuthTool.update({\n        paramSchema: { permission: z.enum([\"admin\"]) }, // change validation rules\n      })\n    } else {\n      // If we're now an admin, we no longer have anywhere to upgrade to, so fully remove that tool\n      upgradeAuthTool.remove()\n    }\n  }\n)\n\n// Connect as normal\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Async MCP Tool with API Call\nDESCRIPTION: This code creates an asynchronous tool that fetches weather data from an external API. It takes a city as a parameter, calls the API, and returns the weather data as text content.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Async tool with external API call\nserver.tool(\n  \"fetch-weather\",\n  { city: z.string() },\n  async ({ city }) => {\n    const response = await fetch(`https://api.weather.com/${city}`);\n    const data = await response.text();\n    return {\n      content: [{ type: \"text\", text: data }]\n    };\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamic MCP Resource\nDESCRIPTION: This code creates a dynamic resource with parameters using `ResourceTemplate`. It takes a `userId` parameter and returns a personalized greeting based on that parameter.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Dynamic resource with parameters\nserver.resource(\n  \"user-profile\",\n  new ResourceTemplate(\"users://{userId}/profile\", { list: undefined }),\n  async (uri, { userId }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Profile data for user ${userId}`\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple MCP Tool\nDESCRIPTION: This code demonstrates creating a simple tool that calculates BMI (Body Mass Index). It takes weight and height as parameters and returns the calculated BMI as text content.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Simple tool with parameters\nserver.tool(\n  \"calculate-bmi\",\n  {\n    weightKg: z.number(),\n    heightM: z.number()\n  },\n  async ({ weightKg, heightM }) => ({\n    content: [{\n      type: \"text\",\n      text: String(weightKg / (heightM * heightM))\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Client-Side Backwards Compatibility with SSE TypeScript\nDESCRIPTION: This code snippet demonstrates client-side backwards compatibility with the deprecated HTTP+SSE transport.  It attempts to connect using the `StreamableHTTPClientTransport` first. If that fails with a 4xx error (indicating an older server), it falls back to using the `SSEClientTransport`. It requires `@modelcontextprotocol/sdk` and `@modelcontextprotocol/sdk/client/index.js`, `@modelcontextprotocol/sdk/client/streamableHttp.js`, and `@modelcontextprotocol/sdk/client/sse.js`.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nlet client: Client|undefined = undefined\nconst baseUrl = new URL(url);\ntry {\n  client = new Client({\n    name: 'streamable-http-client',\n    version: '1.0.0'\n  });\n  const transport = new StreamableHTTPClientTransport(\n    new URL(baseUrl)\n  );\n  await client.connect(transport);\n  console.log(\"Connected using Streamable HTTP transport\");\n} catch (error) {\n  // If that fails with a 4xx error, try the older SSE transport\n  console.log(\"Streamable HTTP connection failed, falling back to SSE transport\");\n  client = new Client({\n    name: 'sse-client',\n    version: '1.0.0'\n  });\n  const sseTransport = new SSEClientTransport(baseUrl);\n  await client.connect(sseTransport);\n  console.log(\"Connected using SSE transport\");\n}\n```\n\n----------------------------------------\n\nTITLE: Proxy OAuth Requests with ProxyOAuthServerProvider TypeScript\nDESCRIPTION: This code demonstrates how to proxy OAuth requests to an external authorization provider using the `ProxyOAuthServerProvider` class from the `@modelcontextprotocol/sdk` package. It sets up an Express app and configures the `mcpAuthRouter` to use the proxy provider, allowing for custom token validation and client management.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from 'express';\nimport { ProxyOAuthServerProvider, mcpAuthRouter } from '@modelcontextprotocol/sdk';\n\nconst app = express();\n\nconst proxyProvider = new ProxyOAuthServerProvider({\n    endpoints: {\n        authorizationUrl: \"https://auth.external.com/oauth2/v1/authorize\",\n        tokenUrl: \"https://auth.external.com/oauth2/v1/token\",\n        revocationUrl: \"https://auth.external.com/oauth2/v1/revoke\",\n    },\n    verifyAccessToken: async (token) => {\n        return {\n            token,\n            clientId: \"123\",\n            scopes: [\"openid\", \"email\", \"profile\"],\n        }\n    },\n    getClient: async (client_id) => {\n        return {\n            client_id,\n            redirect_uris: [\"http://localhost:3000/callback\"],\n        }\n    }\n})\n\napp.use(mcpAuthRouter({\n    provider: proxyProvider,\n    issuerUrl: new URL(\"http://auth.external.com\"),\n    baseUrl: new URL(\"http://mcp.example.com\"),\n    serviceDocumentationUrl: new URL(\"https://docs.example.com/\"),\n}))\n```\n\n----------------------------------------\n\nTITLE: Streamable HTTP Server with Session Management\nDESCRIPTION: This code demonstrates setting up a Streamable HTTP server with session management for handling client requests and server-to-client notifications. It uses Express.js to create the HTTP server and manages sessions by storing transports in a map.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\nimport { randomUUID } from \"node:crypto\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\"\n\n\n\nconst app = express();\napp.use(express.json());\n\n// Map to store transports by session ID\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\n// Handle POST requests for client-to-server communication\napp.post('/mcp', async (req, res) => {\n  // Check for existing session ID\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  let transport: StreamableHTTPServerTransport;\n\n  if (sessionId && transports[sessionId]) {\n    // Reuse existing transport\n    transport = transports[sessionId];\n  } else if (!sessionId && isInitializeRequest(req.body)) {\n    // New initialization request\n    transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () => randomUUID(),\n      onsessioninitialized: (sessionId) => {\n        // Store the transport by session ID\n        transports[sessionId] = transport;\n      }\n    });\n\n    // Clean up transport when closed\n    transport.onclose = () => {\n      if (transport.sessionId) {\n        delete transports[transport.sessionId];\n      }\n    };\n    const server = new McpServer({\n      name: \"example-server\",\n      version: \"1.0.0\"\n    });\n\n    // ... set up server resources, tools, and prompts ...\n\n    // Connect to the MCP server\n    await server.connect(transport);\n  } else {\n    // Invalid request\n    res.status(400).json({\n      jsonrpc: '2.0',\n      error: {\n        code: -32000,\n        message: 'Bad Request: No valid session ID provided',\n      },\n      id: null,\n    });\n    return;\n  }\n\n  // Handle the request\n  await transport.handleRequest(req, res, req.body);\n});\n\n// Reusable handler for GET and DELETE requests\nconst handleSessionRequest = async (req: express.Request, res: express.Response) => {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send('Invalid or missing session ID');\n    return;\n  }\n  \n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n};\n\n// Handle GET requests for server-to-client notifications via SSE\napp.get('/mcp', handleSessionRequest);\n\n// Handle DELETE requests for session termination\napp.delete('/mcp', handleSessionRequest);\n\napp.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Low-Level MCP Server Implementation (TypeScript)\nDESCRIPTION: This snippet demonstrates a low-level MCP server implementation using the core `Server` class from the `@modelcontextprotocol/sdk/server/index.js` module. It directly handles `ListPromptsRequestSchema` and `GetPromptRequestSchema`, defining a single example prompt. This allows for fine-grained control over request handling but requires more manual configuration compared to using `McpServer`.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nconst server = new Server(\n  {\n    name: \"example-server\",\n    version: \"1.0.0\"\n  },\n  {\n    capabilities: {\n      prompts: {}\n    }\n  }\n);\n\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  return {\n    prompts: [{\n      name: \"example-prompt\",\n      description: \"An example prompt template\",\n      arguments: [{\n        name: \"arg1\",\n        description: \"Example argument\",\n        required: true\n      }]\n    }]\n  };\n});\n\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  if (request.params.name !== \"example-prompt\") {\n    throw new Error(\"Unknown prompt\");\n  }\n  return {\n    description: \"Example prompt\",\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Example prompt text\"\n      }\n    }]\n  };\n});\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n\n```\n\n----------------------------------------\n\nTITLE: Server-Side Backwards Compatibility with SSE TypeScript\nDESCRIPTION: This code snippet demonstrates server-side backwards compatibility by supporting both Streamable HTTP and older SSE clients.  It creates an Express app and configures endpoints for both transport types.  Legacy SSE clients connect via the `/sse` endpoint, while modern clients use `/mcp` with Streamable HTTP. Requires `@modelcontextprotocol/sdk/server/mcp.js`, `@modelcontextprotocol/sdk/server/streamableHttp.js`, and `@modelcontextprotocol/sdk/server/sse.js`.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\n\nconst server = new McpServer({\n  name: \"backwards-compatible-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst app = express();\napp.use(express.json());\n\n// Store transports for each session type\nconst transports = {\n  streamable: {} as Record<string, StreamableHTTPServerTransport>,\n  sse: {} as Record<string, SSEServerTransport>\n};\n\n// Modern Streamable HTTP endpoint\napp.all('/mcp', async (req, res) => {\n  // Handle Streamable HTTP transport for modern clients\n  // Implementation as shown in the \"With Session Management\" example\n  // ...\n});\n\n// Legacy SSE endpoint for older clients\napp.get('/sse', async (req, res) => {\n  // Create SSE transport for legacy clients\n  const transport = new SSEServerTransport('/messages', res);\n  transports.sse[transport.sessionId] = transport;\n  \n  res.on(\"close\", () => {\n    delete transports.sse[transport.sessionId];\n  });\n  \n  await server.connect(transport);\n});\n\n// Legacy message endpoint for older clients\napp.post('/messages', async (req, res) => {\n  const sessionId = req.query.sessionId as string;\n  const transport = transports.sse[sessionId];\n  if (transport) {\n    await transport.handlePostMessage(req, res, req.body);\n  } else {\n    res.status(400).send('No transport found for sessionId');\n  }\n});\n\napp.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Stateless HTTP Server with MCP in Express.js (TypeScript)\nDESCRIPTION: This snippet demonstrates a stateless HTTP server using Express.js and the MCP TypeScript SDK. It creates a new MCP server and transport instance for each request to ensure isolation and prevent request ID collisions when handling concurrent requests. The server handles POST requests to the `/mcp` endpoint and returns errors for GET and DELETE requests.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst app = express();\napp.use(express.json());\n\napp.post('/mcp', async (req: Request, res: Response) => {\n  // In stateless mode, create a new instance of transport and server for each request\n  // to ensure complete isolation. A single instance would cause request ID collisions\n  // when multiple clients connect concurrently.\n  \n  try {\n    const server = getServer(); \n    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: undefined,\n    });\n    await server.connect(transport);\n    await transport.handleRequest(req, res, req.body);\n    res.on('close', () => {\n      console.log('Request closed');\n      transport.close();\n      server.close();\n    });\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\napp.get('/mcp', async (req: Request, res: Response) => {\n  console.log('Received GET MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\napp.delete('/mcp', async (req: Request, res: Response) => {\n  console.log('Received DELETE MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`MCP Stateless Streamable HTTP Server listening on port ${PORT}`);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Persistent Storage Mode\nDESCRIPTION: This TypeScript code snippet demonstrates how to configure session management with persistent storage using a database event store.  It sets `sessionIdGenerator` to create a UUID and `eventStore` to a database-backed implementation, enabling resumability through the database.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nsessionIdGenerator: () => randomUUID(),\neventStore: databaseEventStore\n```\n\n----------------------------------------\n\nTITLE: Building an SQLite Explorer with MCP (TypeScript)\nDESCRIPTION: This snippet demonstrates building an SQLite explorer using the MCP TypeScript SDK. It defines a 'schema' resource that retrieves the table schemas from a SQLite database and a 'query' tool that executes arbitrary SQL queries. The code uses `sqlite3` for database interaction and `zod` for input validation. The `promisify` utility is used to convert the asynchronous callbacks of `sqlite3` into Promises.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport sqlite3 from \"sqlite3\";\nimport { promisify } from \"util\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"SQLite Explorer\",\n  version: \"1.0.0\"\n});\n\n// Helper to create DB connection\nconst getDb = () => {\n  const db = new sqlite3.Database(\"database.db\");\n  return {\n    all: promisify<string, any[]>(db.all.bind(db)),\n    close: promisify(db.close.bind(db))\n  };\n};\n\nserver.resource(\n  \"schema\",\n  \"schema://main\",\n  async (uri) => {\n    const db = getDb();\n    try {\n      const tables = await db.all(\n        \"SELECT sql FROM sqlite_master WHERE type='table'\"\n      );\n      return {\n        contents: [{\n          uri: uri.href,\n          text: tables.map((t: {sql: string}) => t.sql).join(\"\\n\")\n        }]\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n\nserver.tool(\n  \"query\",\n  { sql: z.string() },\n  async ({ sql }) => {\n    const db = getDb();\n    try {\n      const results = await db.all(sql);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(results, null, 2)\n        }]\n      };\n    } catch (err: unknown) {\n      const error = err as Error;\n      return {\n        content: [{\n          type: \"text\",\n          text: `Error: ${error.message}`\n        }],\n        isError: true\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Static MCP Resource\nDESCRIPTION: This code demonstrates how to create a static resource using the `server.resource` method. The resource is associated with a URI and returns predefined text content.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Static resource\nserver.resource(\n  \"config\",\n  \"config://app\",\n  async (uri) => ({\n    contents: [{\n      uri: uri.href,\n      text: \"App configuration here\"\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Stateless Mode in Streamable HTTP Transport\nDESCRIPTION: This TypeScript code snippet shows how to configure the `StreamableHTTPServerTransport` to operate in stateless mode by setting `sessionIdGenerator` to `undefined`.  This disables session management, making the server suitable for simple API proxies.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nsessionIdGenerator: undefined\n```\n\n----------------------------------------\n\nTITLE: Creating an MCP Prompt\nDESCRIPTION: This code creates an MCP prompt for code review. It takes code as input and returns a message prompting the LLM to review the code.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nserver.prompt(\n  \"review-code\",\n  { code: z.string() },\n  ({ code }) => ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please review this code:\\n\\n${code}`\n      }\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Running Backwards Compatible Server Example\nDESCRIPTION: This command runs a server that supports both Streamable HTTP and SSE transports for backwards compatibility, using `tsx` for execution.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n```\n\n----------------------------------------\n\nTITLE: Running Backwards Compatible Client\nDESCRIPTION: Runs the backwards compatible client using `tsx` to execute the `streamableHttpWithSseFallbackClient.ts` script. This client is designed to work with both legacy SSE and Streamable HTTP servers.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnpx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n```\n\n----------------------------------------\n\nTITLE: Running Streamable HTTP Server with Notifications\nDESCRIPTION: This command launches a Streamable HTTP server that sends server notifications, such as resource list changes. It utilizes `tsx` to execute the TypeScript file.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/server/standaloneSseWithGetStreamableHttp.ts\n```\n\n----------------------------------------\n\nTITLE: Running JSON Response Mode Server Example\nDESCRIPTION: This command starts a server using the Streamable HTTP transport, configured to use JSON response mode. It demonstrates how to handle responses directly in the response body without SSE, using `tsx` for execution.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/server/jsonResponseStreamableHttp.ts\n```\n\n----------------------------------------\n\nTITLE: Running Backwards Compatible Server\nDESCRIPTION: Starts a backwards compatible server using `tsx` that supports both SSE and Streamable HTTP protocols, by executing the `sseAndStreamableHttpCompatibleServer.ts` script.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnpx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n```\n\n----------------------------------------\n\nTITLE: Running Streamable HTTP Client Example\nDESCRIPTION: This command executes the simple streamable HTTP client example using `tsx`, a TypeScript execution tool.  It connects to a streamable HTTP server and demonstrates basic client-server interaction.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/client/simpleStreamableHttp.ts\n```\n\n----------------------------------------\n\nTITLE: Initializing an MCP Server Instance\nDESCRIPTION: This code snippet initializes an instance of the McpServer class. It sets the server's name and version, which are part of the MCP specification for identifying the server.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new McpServer({\n  name: \"My App\",\n  version: \"1.0.0\"\n});\n```\n\n----------------------------------------\n\nTITLE: Running Streamable HTTP Server\nDESCRIPTION: Starts a Streamable HTTP server using `tsx` to execute the `simpleStreamableHttp.ts` script. This server uses the newer protocol version 2025-03-26.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpx tsx src/examples/server/simpleStreamableHttp.ts\n```\n\n----------------------------------------\n\nTITLE: Running Simple Streamable HTTP Server Example\nDESCRIPTION: This command executes the simple streamable HTTP server using `tsx`. It demonstrates a basic server setup with Express and the Streamable HTTP transport.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/server/simpleStreamableHttp.ts\n```\n\n----------------------------------------\n\nTITLE: Running Build and Test Commands for MCP TypeScript SDK\nDESCRIPTION: This snippet shows various npm and npx commands for building, linting, and testing the MCP TypeScript SDK. It includes commands for building ESM and CJS versions, running ESLint, executing all tests, and running specific tests.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CLAUDE.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build        # Build ESM and CJS versions\nnpm run lint         # Run ESLint\nnpm test             # Run all tests\nnpx jest path/to/file.test.ts  # Run specific test file\nnpx jest -t \"test name\"        # Run tests matching pattern\n```\n\n----------------------------------------\n\nTITLE: Running Legacy SSE Server\nDESCRIPTION: Starts a legacy SSE server using `tsx` to execute the `simpleSseServer.ts` script. This server implements the older protocol version 2024-11-05.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpx tsx src/examples/server/simpleSseServer.ts\n```\n\n----------------------------------------\n\nTITLE: Installing the MCP TypeScript SDK\nDESCRIPTION: This command installs the Model Context Protocol TypeScript SDK using npm. It allows developers to use the SDK in their TypeScript projects for building MCP clients and servers.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @modelcontextprotocol/sdk\n```\n\n----------------------------------------\n\nTITLE: Running Deprecated SSE Transport Server Example\nDESCRIPTION: This command executes the deprecated SSE transport server using `tsx`. This server is primarily for testing backwards compatibility with older clients.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/server/simpleSseServer.ts\n```\n\n----------------------------------------\n\nTITLE: Starting the Server in Bash\nDESCRIPTION: Command for starting the server component for running examples. This is useful when testing or demonstrating the SDK's functionality.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm run server\n```\n\n----------------------------------------\n\nTITLE: Running an MCP Server with stdio Transport\nDESCRIPTION: This code snippet sets up an MCP server to run via standard input/output (stdio). It imports the necessary modules, initializes the server and transport, and then connects the server to the transport to start receiving messages.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new McpServer({\n  name: \"example-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Running the Client in Bash\nDESCRIPTION: Command for executing the client component for examples. This can be used in conjunction with the server to test full functionality.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnpm run client\n```\n\n----------------------------------------\n\nTITLE: Running Linting in Bash\nDESCRIPTION: Command for checking code style compliance using the project's linting rules. This helps maintain consistent code style across the project.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run lint\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Bash\nDESCRIPTION: Command for executing the test suite to verify the code works correctly. Tests should be run before submitting a pull request.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Building the Project in Bash\nDESCRIPTION: Command for building the project from source code using npm. This compiles the TypeScript code and prepares it for testing or use.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies in Bash\nDESCRIPTION: Command for installing all required dependencies for the project using npm. This should be run after cloning the repository.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Cloning the Repository in Bash\nDESCRIPTION: Command for cloning the forked repository to the local machine. This is the first step in the setup process after forking the repository.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/YOUR-USERNAME/typescript-sdk.git\n```\n\n----------------------------------------\n\nTITLE: Running Backwards Compatible Client Example\nDESCRIPTION: This command runs the backwards compatible client, which attempts to connect to a server using Streamable HTTP first, and falls back to SSE if the initial connection fails. It utilizes `tsx` for execution.\nSOURCE: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n```"
  }
]