[
  {
    "owner": "jcrist",
    "repo": "msgspec",
    "content": "TITLE: Defining Schema with msgspec Struct Class\nDESCRIPTION: Demonstrates how to define a message schema using Python type annotations with msgspec.Struct to create a User class with typed fields and default values.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/index.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct):\n...     \"\"\"A new type describing a User\"\"\"\n...     name: str\n...     groups: set[str] = set()\n...     email: str | None = None\n```\n\n----------------------------------------\n\nTITLE: Defining Message Schema using Python Type Annotations\nDESCRIPTION: Example showing how to define a User class using msgspec.Struct with type annotations for name, groups, and email fields. Demonstrates struct definition with default values and optional fields.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct):\n...     \"\"\"A new type describing a User\"\"\"\n...     name: str\n...     groups: set[str] = set()\n...     email: str | None = None\n```\n\n----------------------------------------\n\nTITLE: Defining a User Struct in Python with msgspec\nDESCRIPTION: This snippet demonstrates how to define a Struct representing a user with required and optional fields. It shows the syntax for field annotations and default values.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Set, Optional\n\n>>> class User(msgspec.Struct):\n...     \"\"\"A struct describing a user\"\"\"\n...     name : str\n...     email : Optional[str] = None\n...     groups : Set[str] = set()\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON with Validation using msgspec\nDESCRIPTION: Demonstrates decoding JSON data back into Python objects with schema validation. Includes both successful decoding and a validation error example when incoming data doesn't match schema.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/index.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.decode(msg, type=User)\nUser(name='alice', groups={\"admin\", \"engineering\"}, email=None)\n\n>>> msgspec.json.decode(b'{\"name\":\"bob\",\"groups\":[123]}', type=User)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `str`, got `int` - at `$.groups[0]`\n```\n\n----------------------------------------\n\nTITLE: Basic JSON and MessagePack Decoding in Python\nDESCRIPTION: Demonstrates basic decoding of JSON and MessagePack data into Python objects using msgspec's decode functions.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> # Decode JSON\n... msgspec.json.decode(b'{\"hello\":\"world\"}')\n{'hello': 'world'}\n\n>>> # Decode msgpack\n... msgspec.msgpack.decode(b'\\x81\\xa5hello\\xa5world')\n{'hello': 'world'}\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Constraints for a User Struct in Python\nDESCRIPTION: Demonstrates how to define a User struct with complex constraints using msgspec.Struct and various annotations. It includes constraints on string patterns, set length, and numeric ranges.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom msgspec import Struct, Meta\n\nUnixName = Annotated[\n    str, Meta(min_length=1, max_length=32, pattern=\"^[a-z_][a-z0-9_-]*$\")\n]\n\nclass User(Struct):\n    name: UnixName\n    groups: Annotated[set[UnixName], Meta(max_length=16)] = set()\n    cpu_limit: Annotated[float, Meta(ge=0.1, le=8)] = 1\n    mem_limit: Annotated[int, Meta(ge=256, le=8192)] = 1024\n```\n\n----------------------------------------\n\nTITLE: Basic JSON and MessagePack Encoding in Python\nDESCRIPTION: Demonstrates basic encoding of Python dictionaries to JSON and MessagePack formats using msgspec's encode functions.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> # Encode as JSON\n... msgspec.json.encode({\"hello\": \"world\"})\nb'{\"hello\":\"world\"}'\n\n>>> # Encode as msgpack\n... msgspec.msgpack.encode({\"hello\": \"world\"})\nb'\\x81\\xa5hello\\xa5world'\n```\n\n----------------------------------------\n\nTITLE: Using Tagged Unions with msgspec.Struct\nDESCRIPTION: Demonstrates how to implement tagged unions in msgspec for disambiguating between multiple struct types in a serialized message. Shows both basic configuration with tag=True and custom configuration with tag_field and tag.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Get(msgspec.Struct):\n...     key: str\n\n>>> msg = msgspec.json.encode(Get(\"my key\"))\n\n>>> msg  # No type information present in the message\nb'{\"key\":\"my key\"}'\n\n>>> msgspec.json.decode(msg, type=Get)\nGet(key='my key')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Union\n\n>>> # Pass in ``tag=True`` to tag the structs using the default configuration\n... class Get(msgspec.Struct, tag=True):\n...     key: str\n\n>>> class Put(msgspec.Struct, tag=True):\n...     key: str\n...     val: str\n\n>>> msg = msgspec.json.encode(Get(\"my key\"))\n\n>>> msg  # \"type\" is the tag field, \"Get\" is the tag\nb'{\"type\":\"Get\",\"key\":\"my key\"}'\n\n>>> # Create a decoder for decoding either Get or Put\n... dec = msgspec.json.Decoder(Union[Get, Put])\n\n>>> # The tag value is used to determine the message type\n... dec.decode(b'{\"type\": \"Put\", \"key\": \"my key\", \"val\": \"my val\"}')\nPut(key='my key', val='my val')\n\n>>> dec.decode(b'{\"type\": \"Get\", \"key\": \"my key\"}')\nGet(key='my key')\n\n>>> # A tagged union can also contain non-struct types.\n... msgspec.json.decode(\n...     b'123',\n...     type=Union[Get, Put, int]\n... )\n123\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Union\n\n>>> # Create a base class for tagged structs, where:\n... # - the tag field is \"op\"\n... # - the tag is the class name lowercased\n... class TaggedBase(msgspec.Struct, tag_field=\"op\", tag=str.lower):\n...     pass\n\n>>> # Use the base class to pass on the configuration\n... class Get(TaggedBase):\n...     key: str\n\n>>> class Put(TaggedBase):\n...     key: str\n...     val: str\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Tagged Unions in msgspec\nDESCRIPTION: Demonstrates how to encode and decode tagged unions with msgspec, where the 'op' field serves as a tag to determine the message type during decoding.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> msg = msgspec.json.encode(Get(\"my key\"))\n\n>>> msg  # \"op\" is the tag field, \"get\" is the tag\nb'{\"op\":\"get\",\"key\":\"my key\"}'\n\n>>> # Create a decoder for decoding either Get or Put\n... dec = msgspec.json.Decoder(Union[Get, Put])\n\n>>> # The tag value is used to determine the message type\n... dec.decode(b'{\"op\": \"put\", \"key\": \"my key\", \"val\": \"my val\"}')\nPut(key='my key', val='my val')\n\n>>> dec.decode(b'{\"op\": \"get\", \"key\": \"my key\"}')\nGet(key='my key')\n```\n\n----------------------------------------\n\nTITLE: Defining and Generating JSON Schema with msgspec in Python\nDESCRIPTION: Example showing how to define structured types using msgspec.Struct and generate JSON Schema. Demonstrates use of constraints, optional fields, and custom types with annotations.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/jsonschema.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\nfrom msgspec import Struct, Meta\nfrom typing import Annotated, Optional\n\n\n# A float constrained to values > 0\nPositiveFloat = Annotated[float, Meta(gt=0)]\n\n\nclass Dimensions(Struct):\n    \"\"\"Dimensions for a product, all measurements in centimeters\"\"\"\n    length: PositiveFloat\n    width: PositiveFloat\n    height: PositiveFloat\n\n\nclass Product(Struct):\n    \"\"\"A product in a catalog\"\"\"\n    id: int\n    name: str\n    price: PositiveFloat\n    tags: set[str] = set()\n    dimensions: Optional[Dimensions] = None\n\n\n# Generate a schema for a list of products\nschema = msgspec.json.schema(list[Product])\n\n# Print out that schema as JSON\nprint(msgspec.json.encode(schema))\n```\n\n----------------------------------------\n\nTITLE: Using MsgSpec's Struct Class\nDESCRIPTION: Demonstrates MsgSpec's custom Struct class for defining structured data types. Shows encoding/decoding behavior, default value handling, and field validation.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Set, Optional\n\n>>> class User(msgspec.Struct):\n...     name: str\n...     groups: Set[str] = set()\n...     email: Optional[str] = None\n\n>>> alice = User(\"alice\", groups={\"admin\", \"engineering\"})\n\n>>> msgspec.json.encode(alice)\nb'{\"name\":\"alice\",\"groups\":[\"admin\",\"engineering\"],\"email\":null}'\n\n>>> msg = b\"\"\"\n... {\n...     \"name\": \"bob\",\n...     \"email\": \"bob@company.com\",\n```\n\n----------------------------------------\n\nTITLE: Encoding msgspec Struct to JSON\nDESCRIPTION: Shows how to create a User instance and encode it to JSON using msgspec.json.encode. Demonstrates object instantiation, property access, and serialization.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/index.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> alice = User(\"alice\", groups={\"admin\", \"engineering\"})\n\n>>> alice\nUser(name='alice', groups={\"admin\", \"engineering\"}, email=None)\n\n>>> msg = msgspec.json.encode(alice)\n\n>>> msg\nb'{\"name\":\"alice\",\"groups\":[\"admin\",\"engineering\"],\"email\":null}'\n```\n\n----------------------------------------\n\nTITLE: Efficient Decoding Using msgspec Decoder\nDESCRIPTION: Shows how to create and use a dedicated Decoder instance for more efficient multiple decoding operations.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> # Create a JSON decoder\n... decoder = msgspec.json.Decoder()\n\n>>> # Decode JSON using the decoder\n... decoder.decode(b'{\"hello\":\"world\"}')\n{'hello': 'world'}\n```\n\n----------------------------------------\n\nTITLE: Decoding and Validating Messages with msgspec\nDESCRIPTION: Shows how to decode JSON data back into Python objects with schema validation, including error handling for invalid data types.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.decode(msg, type=User)\nUser(name='alice', groups={\"admin\", \"engineering\"}, email=None)\n\n>>> msgspec.json.decode(b'{\"name\":\"bob\",\"groups\":[123]}', type=User)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `str`, got `int` - at `$.groups[0]`\n```\n\n----------------------------------------\n\nTITLE: Using Structs and Demonstrating Automatic Method Generation in Python\nDESCRIPTION: This snippet shows how to create and use Struct instances, demonstrating the automatically generated methods like __init__, __repr__, and __eq__.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> alice = User(\"alice\", groups={\"admin\", \"engineering\"})\n\n>>> alice\nUser(name='alice', email=None, groups={'admin', 'engineering'})\n\n>>> bob = User(\"bob\", email=\"bob@company.com\")\n\n>>> bob\nUser(name='bob', email='bob@company.com', groups=set())\n\n>>> alice.name\n\"alice\"\n\n>>> bob.groups\nset()\n\n>>> alice == bob\nFalse\n\n>>> alice == User(\"alice\", groups={\"admin\", \"engineering\"})\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Types in MsgSpec\nDESCRIPTION: Shows how to define and use generic types in MsgSpec for reusing common message structures. The example creates a generic Paginated struct type for storing pagination information in API responses.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\nfrom typing import Generic, TypeVar\n\n# A type variable for the item type\nT = TypeVar(\"T\")\n\nclass Paginated(msgspec.Struct, Generic[T]):\n    \"\"\"A generic paginated API wrapper, parametrized by the item type.\"\"\"\n    page: int        # The current page number\n    per_page: int    # Number of items per page\n    total: int       # The total number of items found\n    items: list[T]   # Items returned, up to `per_page` in length\n```\n\n----------------------------------------\n\nTITLE: Defining Structs with Default Values in Python\nDESCRIPTION: This snippet demonstrates different ways to specify default values for Struct fields, including static defaults, dynamic defaults using default_factory, and built-in empty mutable collections.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from msgspec import Struct, field\n\n>>> import uuid\n\n>>> class Example(Struct):\n...     a: int = 1\n...     b: uuid.UUID = field(default_factory=uuid.uuid4)\n...     c: list[int] = []\n\n>>> Example()\nExample(a=1, b=UUID('f63219d5-e9ca-4ae8-afd0-cba30e84222d'), c=[])\n\n>>> Example(a=2)\nExample(a=2, b=UUID('319a6c0f-2841-4439-8bc8-2c1daf7d77a2'), c=[])\n\n>>> Example().c is Example().c  # new list instance used each time\nFalse\n```\n\n----------------------------------------\n\nTITLE: Dataclasses Integration with MsgSpec\nDESCRIPTION: Shows how Python dataclasses are serialized to objects/maps. Demonstrates field validation during decoding and support for duck-typing with EdgeDB Objects.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from dataclasses import dataclass\n\n>>> @dataclass\n... class Person:\n...     name: str\n...     age: int\n\n>>> carol = Person(name=\"carol\", age=32)\n\n>>> msg = msgspec.json.encode(carol)\n\n>>> msgspec.json.decode(msg, type=Person)\nPerson(name='carol', age=32)\n\n>>> wrong_type = b'{\"name\": \"doug\", \"age\": \"thirty\"}'\n\n>>> msgspec.json.decode(wrong_type, type=Person)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$.age`\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import edgedb\n\n>>> client = edgedb.create_client()\n\n>>> alice = client.query_single(\n...     \"SELECT User {name, dob} FILTER .name = <str>$name LIMIT 1\",\n...     name=\"Alice\"\n... )\n\n>>> alice\nObject{name := 'Alice', dob := datetime.date(1984, 3, 1)}\n\n>>> msgspec.json.encode(alice)\nb'{\"id\":\"a6b951cc-2d00-11ee-91aa-b3f17e9898ce\",\"name\":\"Alice\",\"dob\":\"1984-03-01\"}'\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom JSON Support with Msgspec Converters in Python\nDESCRIPTION: Example implementation of JSON serialization support using msgspec converter functions with the standard library's json module. Demonstrates the encode/decode functions and shows how schema validation works when decoding structured data.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/converters.rst#2025-04-18_snippet_0\n\nLANGUAGE: ipython\nCODE:\n```\nIn [1]: import json\n   ...: from typing import Any\n   ...: \n   ...: import msgspec\n\nIn [2]: def encode(obj):\n   ...:     return json.dumps(msgspec.to_builtins(obj))\n\nIn [3]: def decode(msg, type=Any):\n   ...:     return msgspec.convert(json.loads(msg), type=type)\n\nIn [4]: class Point(msgspec.Struct):\n   ...:     x: int\n   ...:     y: int\n\nIn [5]: x = Point(1, 2)\n\nIn [6]: msg = encode(x)  # Encoding a high-level type works\n\nIn [7]: msg\n'{\"x\": 1, \"y\": 2}'\n\nIn [8]: decode(msg, type=Point)  # Decoding a high-level type works\nPoint(x=1, y=2)\n\nIn [9]: decode('{\"x\": \"oops\", \"y\": 2}', type=Point)  # Schema mismatches error\n---------------------------------------------------------------------------\nValidationError                           Traceback (most recent call last)\nCell In[9], line 1\n----> 1 decode('{\"x\": \"oops\", \"y\": 2}', type=Point)  # Schema mismatches error\n\nCell In[3], line 2, in decode(msg, type)\n      1 def decode(msg, type=Any):\n----> 2     return msgspec.convert(json.loads(msg), type=type)\n\nValidationError: Expected `int`, got `str` - at `$.x`\n```\n\n----------------------------------------\n\nTITLE: Efficient Encoding Using msgspec Encoder\nDESCRIPTION: Shows how to create and use a dedicated Encoder instance for more efficient multiple encoding operations.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> # Create a JSON encoder\n... encoder = msgspec.json.Encoder()\n\n>>> # Encode as JSON using the encoder\n... encoder.encode({\"hello\": \"world\"})\nb'{\"hello\":\"world\"}'\n```\n\n----------------------------------------\n\nTITLE: Testing Schema Evolution Compatibility in Python\nDESCRIPTION: Demonstrates backward and forward compatibility between old and new schema versions using JSON encoding/decoding. Shows how default values handle missing fields and extra fields are skipped.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/schema-evolution.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> old_dec = msgspec.json.Decoder(User)\n\n>>> new_dec = msgspec.json.Decoder(User2)\n\n>>> new_msg = msgspec.json.encode(\n...     User2(\"bob\", groups={\"finance\"}, phone=\"512-867-5309\")\n... )\n\n>>> old_dec.decode(new_msg)  # deserializing a new msg with an older decoder\nUser(name='bob', groups={'finance'}, email=None)\n\n>>> old_msg = msgspec.json.encode(\n...     User(\"alice\", groups={\"admin\", \"engineering\"})\n... )\n\n>>> new_dec.decode(old_msg) # deserializing an old msg with a new decoder\nUser2(name=\"alice\", groups={\"admin\", \"engineering\"}, email=None, phone=None)\n```\n\n----------------------------------------\n\nTITLE: Introspecting Constrained Types in Python using msgspec\nDESCRIPTION: Shows how to use msgspec.inspect.type_info with types that have constraints applied using Annotated and Meta.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/inspect.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Annotated\n\n>>> from msgspec import Meta\n\n>>> PositiveInt = Annotated[int, Meta(gt=0)]\n\n>>> msgspec.inspect.type_info(PositiveInt)\nIntType(gt=0, ge=None, lt=None, le=None, multiple_of=None)\n```\n\n----------------------------------------\n\nTITLE: Forbidding Unknown Fields in msgspec\nDESCRIPTION: Demonstrates how to configure a Struct to reject messages with unknown fields, which can help catch typos and ensure data integrity.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> class Example(msgspec.Struct, forbid_unknown_fields=True):\n...     field_one: int\n...     field_two: bool = False\n\n>>> msgspec.json.decode(\n...     b'{\"field_one\": 1, \"field_twoo\": true}',  # oops, a typo\n...     type=Example\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Object contains unknown field `field_twoo`\n```\n\n----------------------------------------\n\nTITLE: Using Enum Types in MsgSpec\nDESCRIPTION: Shows how enum.Enum, enum.IntEnum, and enum.StrEnum types are handled in MsgSpec. Enums encode as their member values and can be decoded if all values are strings or integers. Includes an example of using _missing_ for case-insensitive enum handling.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import enum\n\n>>> class Fruit(enum.Enum):\n...     APPLE = \"apple\"\n...     BANANA = \"banana\"\n\n>>> msgspec.json.encode(Fruit.APPLE)\nb'\"apple\"'\n\n>>> msgspec.json.decode(b'\"apple\"', type=Fruit)\n<Fruit.APPLE: 'apple'>\n\n>>> msgspec.json.decode(b'\"grape\"', type=Fruit)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid enum value 'grape'\n\n>>> class JobState(enum.IntEnum):\n...     CREATED = 0\n...     RUNNING = 1\n...     SUCCEEDED = 2\n...     FAILED = 3\n\n>>> msgspec.json.encode(JobState.RUNNING)\nb'1'\n\n>>> msgspec.json.decode(b'2', type=JobState)\n<JobState.SUCCEEDED: 2>\n\n>>> msgspec.json.decode(b'4', type=JobState)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid enum value 4\n```\n\n----------------------------------------\n\nTITLE: Creating Tagged Union Structs with Msgspec\nDESCRIPTION: Demonstrates creating tagged union structs for Get and Put operations, showing how they serialize to/from JSON arrays. Uses the tag=True and array_like=True parameters to control serialization format.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Union\n\n>>> class Get(msgspec.Struct, tag=True, array_like=True):\n...     key: str\n\n>>> class Put(msgspec.Struct, tag=True, array_like=True):\n...     key: str\n...     val: str\n\n>>> msgspec.json.encode(Get(\"my key\"))\nb'[\"Get\",\"my key\"]'\n\n>>> msgspec.json.decode(\n...     b'[\"Put\", \"my key\", \"my val\"]',\n...     type=Union[Get, Put]\n... )\nPut(key='my key', val='my val')\n```\n\n----------------------------------------\n\nTITLE: Dictionary Handling in MsgSpec\nDESCRIPTION: Explains how Python dictionaries are encoded/decoded as objects/maps in all supported protocols. Shows type checking for keys and values with examples of validation errors.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode({\"x\": 1, \"y\": 2})\nb'{\"x\":1,\"y\":2}'\n\n>>> from typing import Dict\n\n>>> # Decode as a Dict of str -> int\n... msgspec.json.decode(b'{\"x\":1,\"y\":2}', type=Dict[str, int])\n{\"x\": 1, \"y\": 2}\n\n>>> # Oops, there's a mistyped value\n... msgspec.json.decode(b'{\"x\":1,\"y\":\"oops\"}', type=Dict[str, int])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[...]`\n```\n\n----------------------------------------\n\nTITLE: Using TypedDict with MsgSpec\nDESCRIPTION: Demonstrates TypedDict support in MsgSpec for specifying different types for different dictionary values. Shows encoding/decoding behavior and validation errors for mismatched types.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import TypedDict\n\n>>> class Person(TypedDict):\n...     name: str\n...     age: int\n\n>>> ben = {\"name\": \"ben\", \"age\": 25}\n\n>>> msg = msgspec.json.encode(ben)\n\n>>> msgspec.json.decode(msg, type=Person)\n{'name': 'ben', 'age': 25}\n\n>>> wrong_type = b'{\"name\": \"chad\", \"age\": \"twenty\"}'\n\n>>> msgspec.json.decode(wrong_type, type=Person)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$.age`\n```\n\n----------------------------------------\n\nTITLE: Reusing JSON Decoder in Python with msgspec\nDESCRIPTION: Shows how to create and reuse a typed JSON decoder for multiple decoding operations, improving performance in repetitive decoding scenarios.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> decoder = msgspec.json.Decoder(list[int])  # Create once\n\n>>> for data in input_buffers:\n...     msg = decoder.decode(data)  # reuse multiple times\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON with Type Constraints in Python using msgspec\nDESCRIPTION: Demonstrates how to use msgspec to decode JSON data with type constraints, specifically for a list of integers. It shows both successful decoding and an error case when the data doesn't match the specified type.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> msgspec.json.decode(b\"[1, 2, 3]\", type=list[int])\n[1, 2, 3]\n\n>>> msgspec.json.decode(b'[1, 2, \"oops\"]', type=list[int])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[2]`\n```\n\n----------------------------------------\n\nTITLE: Type Validation in msgspec.Struct\nDESCRIPTION: Explains the type validation approach in msgspec, which validates types during decoding but not during normal instance creation. Shows examples of both behaviors to illustrate the difference.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Point(msgspec.Struct):\n...     x: float\n...     y: float\n\n>>> # Improper types in *your* code aren't checked at runtime\n... Point(x=1, y=\"oops\")\nPoint(x=1, y='oops')\n\n>>> # Improper types when decoding *are* checked at runtime\n... msgspec.json.decode(b'{\"x\": 1.0, \"y\": \"oops\"}', type=Point)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `float`, got `str` - at `$.y`\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Datetime Objects in JSON\nDESCRIPTION: Demonstrates encoding and decoding of datetime objects in JSON, including both timezone-aware and timezone-naive datetimes.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import datetime\n\n>>> tz = datetime.timezone(datetime.timedelta(hours=6))\n\n>>> tz_aware = datetime.datetime(2021, 4, 2, 18, 18, 10, 123, tzinfo=tz)\n\n>>> msg = msgspec.json.encode(tz_aware)\n\n>>> msg\nb'\"2021-04-02T18:18:10.000123+06:00\"'\n\n>>> msgspec.json.decode(msg, type=datetime.datetime)\ndatetime.datetime(2021, 4, 2, 18, 18, 10, 123, tzinfo=datetime.timezone(datetime.timedelta(seconds=21600)))\n\n>>> tz_naive = datetime.datetime(2021, 4, 2, 18, 18, 10, 123)\n\n>>> msg = msgspec.json.encode(tz_naive)\n\n>>> msg\nb'\"2021-04-02T18:18:10.000123\"'\n\n>>> msgspec.json.decode(msg, type=datetime.datetime)\ndatetime.datetime(2021, 4, 2, 18, 18, 10, 123)\n\n>>> msgspec.json.decode(b'\"oops\"', type=datetime.datetime)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid RFC3339 encoded datetime\n\n>>> msgspec.json.decode(b\"1617405490.000123\", type=datetime.datetime)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `datetime`, got `float`\n\n>>> msgspec.json.decode(b\"1617405490.000123\", type=datetime.datetime, strict=False)\n```\n\n----------------------------------------\n\nTITLE: Loading and Parsing GeoJSON with msgspec\nDESCRIPTION: Demonstrates loading GeoJSON data using a custom msgspec-based parser. The example loads a Canada GeoJSON file and accesses its properties. The parser automatically validates the structure and converts it to high-level objects.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/geojson.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec_geojson\n\nwith open(\"canada.json\", \"rb\") as f:\n    data = f.read()\n\ncanada = msgspec_geojson.loads(data)\n\ntype(canada)  # loaded as high-level, validated object\n# Out[4]: msgspec_geojson.FeatureCollection\n\ncanada.features[0].properties\n# Out[5]: {'name': 'Canada'}\n```\n\n----------------------------------------\n\nTITLE: Using Array-Like Structs in MsgSpec\nDESCRIPTION: Demonstrates how to create and use array-like structs in MsgSpec for more compact serialization. Array-like structs serialize fields in their defined order rather than as key-value pairs, improving performance at the cost of human-readable field names.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Set, Optional\n\n>>> class User(msgspec.Struct, array_like=True):\n...     name: str\n...     groups: Set[str] = set()\n...     email: Optional[str] = None\n\n>>> alice = User(\"alice\", groups={\"admin\", \"engineering\"})\n\n>>> msgspec.json.encode(alice)\nb'[\"alice\",[\"admin\",\"engineering\"],null]'\n\n>>> msgspec.json.decode(b'[\"bob\"]', type=User)\nUser(name=\"bob\", groups=[], email=None)\n\n>>> msgspec.json.decode(b'[\"carol\", [\"admin\"], null, [\"extra\", \"field\"]]', type=User)\nUser(name=\"carol\", groups=[\"admin\"], email=None)\n\n>>> msgspec.json.decode(b'[\"david\", [\"finance\", 123]]')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `str`, got `int` - at `$[1][1]`\n```\n\n----------------------------------------\n\nTITLE: Using Raw Types for Efficient Message Processing\nDESCRIPTION: Demonstrates using msgspec.Raw for handling pre-encoded messages and delayed decoding of nested structures\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> # Create a new `Raw` object wrapping a pre-encoded message\n... fragment = msgspec.Raw(b'{\"x\": 1, \"y\": 2}')\n\n>>> # Compose a larger message containing the pre-encoded fragment\n... msg = {\"a\": 1, \"b\": fragment}\n\n>>> # During encoding, the raw message is efficiently copied into\n... # the output buffer, avoiding any extra encoding cost\n... msgspec.json.encode(msg)\nb'{\"a\":1,\"b\":{\"x\": 1, \"y\": 2}}'\n```\n\n----------------------------------------\n\nTITLE: Implementing TOML Support with Msgspec Converters in Python\nDESCRIPTION: Example implementation of TOML serialization support using msgspec converter functions with the tomllib module. Shows how to configure the converter to handle TOML-specific features like native datetime types and string-only keys.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/converters.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\nimport tomllib\nfrom typing import Any\n\nimport msgspec\n\ndef decode(msg, *, type=Any, dec_hook=None):\n    return msgspec.convert(\n        toml.loads(msg),\n        type,\n        builtin_types=(datetime.datetime, datetime.date, datetime.time),\n        str_keys=True,\n        dec_hook=dec_hook,\n    )\n```\n\n----------------------------------------\n\nTITLE: Array-like Encoding for Performance Optimization\nDESCRIPTION: Demonstrates how to configure a Struct to encode as an array for improved performance, eliminating field names from the encoded message.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> class Point2(msgspec.Struct, array_like=True):\n...     x: int\n...     y: int\n\n>>> msgspec.json.encode(Point2(1, 2))\nb'[1,2]'\n\n>>> msgspec.json.decode(b'[3,4]', type=Point2)\nPoint2(x=3, y=4)\n```\n\n----------------------------------------\n\nTITLE: Processing conda-forge's repodata.json with Python\nDESCRIPTION: A Python script that benchmarks different JSON libraries by parsing the conda-forge repository metadata file, extracting package names and sizes, and finding the top 10 packages by file size. It compares standard json, ujson, orjson, simdjson, and msgspec libraries.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/conda-repodata.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n../../../examples/conda-repodata/query_repodata.py\n```\n\n----------------------------------------\n\nTITLE: Reusing Output Buffer for MessagePack Encoding in Python with msgspec\nDESCRIPTION: Shows how to allocate a single bytearray buffer and reuse it for encoding multiple messages, potentially improving performance in high-frequency encoding scenarios.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nencoder = msgspec.msgpack.Encoder()\n\n# Allocate a single shared buffer\nbuffer = bytearray()\n\nfor msg in msgs:\n    # Encode a message into the buffer at the start of the buffer.\n    # Note that this overwrites any previous contents.\n    encoder.encode_into(msg, buffer)\n\n    # Write the buffer to the socket\n    socket.sendall(buffer)\n```\n\n----------------------------------------\n\nTITLE: Implementing Case-Insensitive Enums with _missing_ Method\nDESCRIPTION: Demonstrates how to implement case-insensitive enum handling in MsgSpec using the _missing_ method. This allows for more flexible enum value matching during deserialization.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import enum\n\n>>> class Fruit(enum.Enum):\n...     APPLE = \"apple\"\n...     BANANA = \"banana\"\n...\n...     @classmethod\n...     def _missing_(cls, name):\n...         \"\"\"Called to handle missing enum values\"\"\"\n...         # Normalize value to lowercase\n...         value = name.lower()\n...         # Return valid enum value, or None if invalid\n...         return cls._value2member_map_.get(value)\n\n>>> msgspec.json.decode(b'\"apple\"', type=Fruit)\n<Fruit.APPLE: \"apple\">\n\n>>> msgspec.json.decode(b'\"ApPlE\"', type=Fruit)\n<Fruit.APPLE: \"apple\">\n\n>>> msgspec.json.decode(b'\"grape\"', type=Fruit)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid enum value 'grape'\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Lists and Sets with MsgSpec\nDESCRIPTION: Demonstrates how MsgSpec handles Python list, tuple, set, and frozenset objects. Shows encoding to JSON arrays and decoding with type validation for collections.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode([1, 2, 3])\nb'[1,2,3]'\n\n>>> msgspec.json.encode({1, 2, 3})\nb'[1,2,3]'\n\n>>> msgspec.json.decode(b'[1,2,3]', type=set)\n{1, 2, 3}\n\n>>> from typing import Set\n\n>>> # Decode as a set of ints\n... msgspec.json.decode(b'[1, 2, 3]', type=Set[int])\n{1, 2, 3}\n\n>>> # Oops, all elements should be ints\n... msgspec.json.decode(b'[1, 2, \"oops\"]', type=Set[int])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[2]`\n```\n\n----------------------------------------\n\nTITLE: Encoding Line-Delimited JSON Efficiently in Python with msgspec\nDESCRIPTION: Demonstrates an efficient method to encode line-delimited JSON messages using a pre-allocated buffer, avoiding unnecessary copying of data.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\n\nencoder = msgspec.json.Encoder()\n\n# Allocate a buffer. We recommend using a small non-empty buffer to\n# avoid reallocating for small messages. Choose something larger than\n# your common message size, but not excessively large.\nbuffer = bytearray(64)\n\n# Encode into the existing buffer.\nencoder.encode_into([\"my\", \"message\"], buffer)\n\n# Append a newline character without copying\nbuffer.extend(b\"\\n\")\n\n# Write the full buffer to a socket/file/etc...\nsocket.sendall(buffer)\n```\n\n----------------------------------------\n\nTITLE: Working with NamedTuple in MsgSpec\nDESCRIPTION: Shows how typing.NamedTuple and collections.namedtuple work with MsgSpec. Demonstrates serialization to arrays, type checking during decoding, and support for duck-typing with EdgeDB NamedTuples.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import NamedTuple\n\n>>> class Person(NamedTuple):\n...     name: str\n...     age: int\n\n>>> ben = Person(\"ben\", 25)\n\n>>> msg = msgspec.json.encode(ben)\n\n>>> msgspec.json.decode(msg, type=Person)\nPerson(name='ben', age=25)\n\n>>> wrong_type = b'[\"chad\", \"twenty\"]'\n\n>>> msgspec.json.decode(wrong_type, type=Person)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[1]`\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> import edgedb\n\n>>> client = edgedb.create_client()\n\n>>> alice = client.query_single(\n...     \"SELECT (name := 'Alice', dob := <cal::local_date>'1984-03-01')\"\n... )\n\n>>> alice\n(name := 'Alice', dob := datetime.date(1984, 3, 1))\n\n>>> msgspec.json.encode(alice)\nb'[\"Alice\",\"1984-03-01\"]'\n```\n\n----------------------------------------\n\nTITLE: Implementing Post-Init Processing for Structs in Python\nDESCRIPTION: This example shows how to use the __post_init__ method for additional initialization logic or validation in Structs.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Interval(msgspec.Struct):\n...     low: float\n...     high: float\n...\n...     def __post_init__(self):\n...         if self.low > self.high:\n...             raise ValueError(\"`low` may not be greater than `high`\")\n\n>>> Interval(1, 2)  # valid interval\nInterval(low=1, high=2)\n\n>>> Interval(2, 1)  # invalid interval\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 6, in __post_init__\nValueError: `low` may not be greater than `high`\n\n>>> msgspec.json.decode(b'{\"low\": 2, \"high\": 1}', type=Interval)  # invalid interval from JSON\nTraceback (most recent call last):\n  File \"<stdin>\", line 6, in __post_init__\nValueError: `low` may not be greater than `high`\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: `low` may not be greater than `high`\n```\n\n----------------------------------------\n\nTITLE: Implementing Length-Prefix Framing with MessagePack in Python using msgspec\nDESCRIPTION: Illustrates how to efficiently implement length-prefix framing for MessagePack-encoded messages using a pre-allocated buffer and avoiding excessive copying.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\n\nencoder = msgspec.msgpack.Encoder()\n\n# Allocate a buffer. We recommend using a small non-empty buffer to\n# avoid reallocating for small messages. Choose something larger than\n# your common message size, but not excessively large.\nbuffer = bytearray(64)\n\n# Encode into the existing buffer, offset by 4 bytes at the front to\n# store the length prefix.\nencoder.encode_into(msg, buffer, 4)\n\n# Encode the message length as a 4 byte big-endian integer, and\n# prefix the message with it (without copying).\nn = len(msg) - 4\nbuffer[:4] = n.to_bytes(4, \"big\")\n\n# Write the buffer to a socket/file/etc...\nsocket.sendall(buffer)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom MessagePack Extension for Complex Numbers\nDESCRIPTION: Implements enc_hook and ext_hook to serialize complex numbers as a MessagePack extension type using a binary representation. This approach embeds type information in the message, allowing untyped decoding.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/extending.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\nimport struct\nfrom typing import Any\n\n# All extension types need a unique integer designator so the decoder knows\n# which type they're decoding. Here we arbitrarily choose 1, but any integer\n# between 0 and 127 (inclusive) would work.\nCOMPLEX_TYPE_CODE = 1\n\ndef enc_hook(obj: Any) -> Any:\n    if isinstance(obj, complex):\n        # encode the complex number into a 16 byte buffer\n        data = struct.pack('dd', obj.real, obj.imag)\n\n        # Return an `Ext` object so msgspec serializes it as an extension type.\n        return msgspec.msgpack.Ext(COMPLEX_TYPE_CODE, data)\n    else:\n        # Raise a NotImplementedError for other types\n        raise NotImplementedError(f\"Objects of type {type(obj)} are not supported\")\n\n\ndef ext_hook(code: int, data: memoryview) -> Any:\n    if code == COMPLEX_TYPE_CODE:\n        # This extension type represents a complex number, decode the data\n        # buffer accordingly.\n        real, imag = struct.unpack('dd', data)\n        return complex(real, imag)\n    else:\n        # Raise a NotImplementedError for other extension type codes\n        raise NotImplementedError(f\"Extension type code {code} is not supported\")\n\n\n# Create an encoder and a decoder using the custom callbacks\nenc = msgspec.msgpack.Encoder(enc_hook=enc_hook)\ndec = msgspec.msgpack.Decoder(ext_hook=ext_hook)\n\n# Define a message that contains complex numbers\nmsg = {\"roots\": [0, 0.75, 1 + 0.5j, 1 - 0.5j]}\n\n# Encode and decode the message to show that things work\nbuf = enc.encode(msg)\nmsg2 = dec.decode(buf)\nassert msg == msg2  # True\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Function Signatures for msgspec Extension\nDESCRIPTION: Shows the required function signatures for enc_hook, dec_hook, and ext_hook callbacks used to extend msgspec's type support. These hooks allow conversion between custom types and natively supported types.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/extending.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef enc_hook(obj: Any) -> Any:\n    \"\"\"Given an object that msgspec doesn't know how to serialize by\n    default, convert it into an object that it does know how to\n    serialize\"\"\"\n    pass\n\ndef dec_hook(type: Type, obj: Any) -> Any:\n    \"\"\"Given a type in a schema, convert ``obj`` (composed of natively\n    supported objects) into an object of type ``type``.\n\n    Any `TypeError` or `ValueError` exceptions raised by this method will\n    be considered \"user facing\" and converted into a `ValidationError` with\n    additional context. All other exceptions will be raised directly.\n    \"\"\"\n    pass\n\ndef ext_hook(code: int, data: memoryview) -> Any:\n    \"\"\"MessagePack only. Given an extension type code and data buffer,\n    deserialize whatever custom object the extension type represents\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Omitting Default Values in msgspec Serialization\nDESCRIPTION: Demonstrates how to configure msgspec to omit default values from encoded messages using omit_defaults=True, which can reduce message size and improve performance.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct, omit_defaults=True):\n...     name : str\n...     email : Optional[str] = None\n...     groups : Set[str] = set()\n\n>>> alice = User(\"alice\")\n\n>>> msgspec.json.encode(alice)  # default values are omitted\nb'{\"name\":\"alice\"}'\n\n>>> bob = User(\"bob\", email=\"bob@company.com\")\n\n>>> msgspec.json.encode(bob)\nb'{\"name\":\"bob\",\"email\":\"bob@company.com\"}'\n```\n\n----------------------------------------\n\nTITLE: Defining Keyword-Only Structs in Python\nDESCRIPTION: This snippet demonstrates how to create Structs with keyword-only parameters using the kw_only option, allowing for more flexible field ordering.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> class Example(msgspec.Struct, kw_only=True):\n...     a: str = \"\"\n...     b: int  # this is fine with kw_only=True\n\n>>> Example(a=\"example\", b=123)\nExample(a='example', b=123)\n\n>>> class Base(msgspec.Struct, kw_only=True):\n...     a: str = \"\"\n...     b: int\n\n>>> class Subclass(Base):\n...     c: float\n...     d: bytes = b\"\"\n```\n\n----------------------------------------\n\nTITLE: Time Object Handling in Python with msgspec\nDESCRIPTION: Shows handling of timezone-aware and timezone-naive time objects using msgspec. Demonstrates encoding to RFC3339 compatible strings and decoding back to time objects.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import datetime\n>>> tz = datetime.timezone(datetime.timedelta(hours=6))\n>>> tz_aware = datetime.time(18, 18, 10, 123, tzinfo=tz)\n>>> msg = msgspec.json.encode(tz_aware)\n>>> msg\nb'\"18:18:10.000123+06:00\"'\n>>> msgspec.json.decode(msg, type=datetime.time)\ndatetime.time(18, 18, 10, 123, tzinfo=datetime.timezone(datetime.timedelta(seconds=21600)))\n>>> tz_naive = datetime.time(18, 18, 10, 123)\n>>> msg = msgspec.json.encode(tz_naive)\n>>> msg\nb'\"18:18:10.000123\"'\n>>> msgspec.json.decode(msg, type=datetime.time)\ndatetime.time(18, 18, 10, 123)\n>>> msgspec.json.decode(b'\"oops\"', type=datetime.time)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid RFC3339 encoded time\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types in MsgSpec\nDESCRIPTION: Shows how typing.Literal can be used to validate that decoded values match a predefined set of valid values. Literal types can be composed of None, int values, str values, or nested Literal types.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Literal\n\n>>> msgspec.json.decode(b'1', type=Literal[1, 2, 3])\n1\n\n>>> msgspec.json.decode(b'\"one\"', type=Literal[\"one\", \"two\", \"three\"])\n'one'\n\n>>> msgspec.json.decode(b'4', type=Literal[1, 2, 3])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid enum value 4\n\n>>> msgspec.json.decode(b'\"bad\"', type=Literal[1, 2, 3])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str`\n```\n\n----------------------------------------\n\nTITLE: Key-Value Store Client Usage\nDESCRIPTION: Interactive Python session demonstrating client usage including connecting to the server and performing key-value operations like put, get, list_keys, and delete\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/asyncio-kv.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nIn [1]: from kv import Client\n\nIn [2]: client = await Client.create()\n\nIn [3]: await client.put(\"foo\", \"bar\")\n\nIn [4]: await client.put(\"fizz\", \"buzz\")\n\nIn [5]: await client.get(\"foo\")\nOut[5]: 'bar'\n\nIn [6]: await client.list_keys()\nOut[6]: ['fizz', 'foo']\n\nIn [7]: await client.delete(\"fizz\")\n\nIn [8]: await client.list_keys()\nOut[8]: ['foo']\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with msgspec.Struct in Python 3.10+\nDESCRIPTION: Shows how to use msgspec.Struct types in Python 3.10+ pattern matching blocks. Demonstrates a Point class example with different match cases for various coordinate patterns.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# NOTE: this example requires Python 3.10+\n>>> import msgspec\n\n>>> class Point(msgspec.Struct):\n...     x: float\n...     y: float\n\n>>> def where_is(point):\n...     match point:\n...         case Point(0, 0):\n...             print(\"Origin\")\n...         case Point(0, y):\n...             print(f\"Y={y}\")\n...         case Point(x, 0):\n...             print(f\"X={x}\")\n...         case Point():\n...             print(\"Somewhere else\")\n...         case _:\n...             print(\"Not a point\")\n\n>>> where_is(Point(0, 6))\n\"Y=6\"\n```\n\n----------------------------------------\n\nTITLE: Using UNSET Type in MsgSpec\nDESCRIPTION: Explains the usage of msgspec.UNSET, a singleton object that indicates a field has no set value. This is useful for distinguishing between missing fields and fields explicitly set to None during serialization and deserialization.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from msgspec import Struct, UnsetType, UNSET, json\n\n>>> class Example(Struct):\n...     x: int\n...     y: int | None | UnsetType = UNSET  # a field, defaulting to UNSET\n\n>>> json.encode(Example(1))  # y is UNSET\nb'{\"x\":1}'\n\n>>> json.encode(Example(1, UNSET))  # y is UNSET\nb'{\"x\":1}'\n\n>>> json.encode(Example(1, None))  # y is None\nb'{\"x\":1,\"y\":null}'\n\n>>> json.encode(Example(1, 2))  # y is 2\nb'{\"x\":1,\"y\":2}'\n\n>>> json.decode(b'{\"x\": 1}', type=Example)  # y defaults to UNSET\nExample(x=1, y=UNSET)\n\n>>> json.decode(b'{\"x\": 1, \"y\": null}', type=Example)  # y is None\nExample(x=1, y=None)\n\n>>> json.decode(b'{\"x\": 1, \"y\": 2}', type=Example)  # y is 2\nExample(x=1, y=2)\n```\n\n----------------------------------------\n\nTITLE: Evolving User Schema with New Field in Python\nDESCRIPTION: Shows how to extend the User schema by adding a new optional phone field while maintaining backward compatibility. Demonstrates proper field addition with defaults.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/schema-evolution.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> class User2(msgspec.Struct):\n...     \"\"\"An updated version of the User struct, now with a phone number\"\"\"\n...     name: str\n...     groups: Set[str] = set()\n...     email: Optional[str] = None\n...     phone : Optional[str] = None\n```\n\n----------------------------------------\n\nTITLE: Bulk Field Renaming with Struct Configuration\nDESCRIPTION: Demonstrates how to rename all fields in a Struct using naming conventions like camelCase, which is useful for matching external API field naming requirements.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Example(msgspec.Struct, rename=\"camel\"):\n...     \"\"\"A struct with fields renamed using camelCase\"\"\"\n...     field_one: int\n...     field_two: str\n\n>>> # Python code uses the original field names\n... ex = Example(1, field_two=\"two\")\n\n>>> # Encoded messages use the renamed field names\n... msgspec.json.encode(ex)\nb'{\"fieldOne\":1,\"fieldTwo\":\"two\"}'\n\n>>> # Decoding uses the renamed field names\n... msgspec.json.decode(b'{\"fieldOne\": 3, \"fieldTwo\": \"four\"}', type=Example)\nExample(field_one=3, field_two='four')\n\n>>> # Decoding errors also use the renamed field names\n... msgspec.json.decode(b'{\"fieldOne\": 5}', type=Example)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Object missing required field `fieldTwo`\n```\n\n----------------------------------------\n\nTITLE: Renaming Individual Fields with msgspec.field\nDESCRIPTION: Shows how to rename specific fields for encoding/decoding using the name parameter in msgspec.field, allowing different names in Python code versus serialized data.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Example(msgspec.Struct):\n...     x: int\n...     y: int\n...     z: int = msgspec.field(name=\"field_z\")  # renamed to \"field_z\"\n\n>>> # Python code uses the original field names\n... ex = Example(x=1, y=2, z=3)\n\n>>> # Encoded messages use the renamed field names\n... msgspec.json.encode(ex)\nb'{\"x\":1,\"y\":2,\"field_z\":3}'\n\n>>> # Decoding also uses the renamed field names\n... msgspec.json.decode(b'{\"x\": 1, \"y\": 2, \"field_z\": 3}', type=Example)\nExample(x=1, y=2, z=3)\n```\n\n----------------------------------------\n\nTITLE: Creating Frozen (Immutable) msgspec.Struct Instances\nDESCRIPTION: Shows how to create immutable and hashable struct types by specifying frozen=True. These instances cannot be modified after creation and can be used as dictionary keys.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> class Point(msgspec.Struct, frozen=True):\n...     \"\"\"This struct is immutable & hashable\"\"\"\n...     x: float\n...     y: float\n...\n\n>>> p = Point(1.0, 2.0)\n\n>>> {p: 1}  # frozen structs are hashable, and can be keys in dicts\n{Point(1.0, 2.0): 1}\n\n>>> p.x = 2.0  # frozen structs cannot be modified after creation\nTraceback (most recent call last):\n    ...\nAttributeError: immutable type: 'Point'\n```\n\n----------------------------------------\n\nTITLE: Dynamic Type Decoding with Raw Types\nDESCRIPTION: Shows how to implement dynamic type decoding based on message content using msgspec.Raw\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Union\n\n>>> class Point1D(msgspec.Struct):\n...     x: int\n\n>>> class Point2D(msgspec.Struct):\n...     x: int\n...     y: int\n\n>>> class Point3D(msgspec.Struct):\n...     x: int\n...     y: int\n...     z: int\n\n>>> class Model(msgspec.Struct):\n...     dimensions: int\n...     point: msgspec.Raw  # use msgspec.Raw to delay decoding the point field\n\n>>> def decode_point(msg: bytes) -> Union[Point1D, Point2D, Point3D]:\n...     model = msgspec.json.decode(msg, type=Model)\n...     if model.dimensions == 1:\n...         point_type = Point1D\n...     elif model.dimensions == 2:\n...         point_type = Point2D\n...     elif model.dimensions == 3:\n...         point_type = Point3D\n...     else:\n...         raise ValueError(\"Too many dimensions!\")\n...     return msgspec.json.decode(model.point, type=point_type)\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Types for Twitter API Data in Python with msgspec\nDESCRIPTION: Illustrates how to define custom Struct types to selectively decode specific fields from a larger JSON object, in this case for Twitter API data.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct):\n...     name: str\n\n>>> class Tweet(msgspec.Struct):\n...     user: User\n...     full_text: str\n...     favorite_count: int\n```\n\n----------------------------------------\n\nTITLE: UUID Handling in Python with msgspec\nDESCRIPTION: Shows serialization of UUID objects in different formats including canonical, hex, and bytes formats. Demonstrates encoding and decoding with format specifications.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import uuid\n>>> u = uuid.UUID(\"c4524ac0-e81e-4aa8-a595-0aec605a659a\")\n>>> msgspec.json.encode(u)\nb'\"c4524ac0-e81e-4aa8-a595-0aec605a659a\"'\n>>> msgspec.json.decode(b'\"c4524ac0-e81e-4aa8-a595-0aec605a659a\"', type=uuid.UUID)\nUUID('c4524ac0-e81e-4aa8-a595-0aec605a659a')\n>>> msgspec.json.decode(b'\"oops\"', type=uuid.UUID)\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid UUID\n```\n\n----------------------------------------\n\nTITLE: Applying Numeric Constraints in Python with msgspec\nDESCRIPTION: Shows how to apply numeric constraints using msgspec.Meta. This example demonstrates a greater-than-or-equal-to constraint on an integer value.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(b'-1', type=Annotated[int, msgspec.Meta(ge=0)])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int` >= 0\n```\n\n----------------------------------------\n\nTITLE: Decoding Paginated User Data with msgspec Structs\nDESCRIPTION: Demonstrates how to define a User struct type and decode a paginated JSON response containing a list of users using msgspec\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nclass User(msgspec.Struct):\n    \"\"\"A user model\"\"\"\n    name: str\n    groups: list[str] = []\n\njson_str = \"\"\"\n{\n    \"page\": 1,\n    \"per_page\": 5,\n    \"total\": 252,\n    \"items\": [\n        {\"name\": \"alice\", \"groups\": [\"admin\"]},\n        {\"name\": \"ben\"},\n        {\"name\": \"carol\", \"groups\": [\"engineering\"]},\n        {\"name\": \"dan\", \"groups\": [\"hr\"]},\n        {\"name\": \"ellen\", \"groups\": [\"engineering\"]}\n    ]\n}\n\"\"\"\n\n# Decode a paginated response containing a list of users\nmsg = msgspec.json.decode(json_str, type=Paginated[User])\nprint(msg)\n```\n\n----------------------------------------\n\nTITLE: Decimal Type Handling in Python with msgspec\nDESCRIPTION: Demonstrates handling of Decimal objects with string and number formats. Shows precision handling and various decoding scenarios across different protocols.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> import decimal\n>>> x = decimal.Decimal(\"1.2345\")\n>>> msg = msgspec.json.encode(x)\n>>> msg\nb'\"1.2345\"'\n>>> msgspec.json.decode(msg, type=decimal.Decimal)\nDecimal('1.2345')\n>>> msgspec.json.decode(b'\"oops\"', type=decimal.Decimal)\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid decimal string\n```\n\n----------------------------------------\n\nTITLE: Applying Mapping Length Constraints in Python with msgspec\nDESCRIPTION: Demonstrates how to apply length constraints to mapping types (like dictionaries) using msgspec.Meta. The example shows an error case when the dictionary exceeds the specified maximum length.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(\n...     b'{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}',\n...     type=Annotated[dict[str, int], msgspec.Meta(max_length=3)]\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `object` of length <= 3\n```\n\n----------------------------------------\n\nTITLE: Working with Abstract Types in msgspec\nDESCRIPTION: Shows how to use abstract collection types for JSON decoding with type validation\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import MutableMapping\n\n>>> msgspec.json.decode(b'{\"x\": 1}', type=MutableMapping[str, int])\n{\"x\": 1}\n\n>>> msgspec.json.decode(b'{\"x\": \"oops\"}', type=MutableMapping[str, int])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[...]`\n```\n\n----------------------------------------\n\nTITLE: Default Behavior of Encoding All Fields in msgspec\nDESCRIPTION: Shows how msgspec encodes all fields in a Struct type by default, including optional fields with default values.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct):\n...     name : str\n...     email : Optional[str] = None\n...     groups : Set[str] = set()\n\n>>> alice = User(\"alice\")\n\n>>> alice  # email & groups are using the default values\nUser(name='alice', email=None, groups=set())\n\n>>> msgspec.json.encode(alice)  # default values are present in encoded message\nb'{\"name\":\"alice\",\"email\":null,\"groups\":[]}'\n```\n\n----------------------------------------\n\nTITLE: Applying String Pattern Constraints in Python with msgspec\nDESCRIPTION: Demonstrates how to apply a regular expression pattern constraint to a string using msgspec.Meta. The example shows an error case when the string doesn't match the specified pattern.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(\n...     b'\"invalid username\"',\n...     type=Annotated[str, msgspec.Meta(pattern=\"^[a-z0-9_]*$\")]\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `str` matching regex '^[a-z0-9_]*$'\n```\n\n----------------------------------------\n\nTITLE: Defining Msgspec Structs at Runtime\nDESCRIPTION: Shows how to dynamically generate msgspec Struct classes at runtime using msgspec.defstruct. Creates a Point class with x and y float coordinates.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> Point = msgspec.defstruct(\"Point\", [(\"x\", float), (\"y\", float)])\n\n>>> p = Point(1.0, 2.0)\n\n>>> p\nPoint(x=1.0, y=2.0)\n```\n\n----------------------------------------\n\nTITLE: Reusing JSON Encoder in Python with msgspec\nDESCRIPTION: Demonstrates how to create and reuse a JSON encoder for multiple encoding operations, avoiding the setup cost for each call.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> encoder = msgspec.json.Encoder()  # Create once\n\n>>> for msg in msgs:\n...     data = encoder.encode(msg)  # reuse multiple times\n```\n\n----------------------------------------\n\nTITLE: Attrs Classes Support in MsgSpec\nDESCRIPTION: Documents how MsgSpec handles attrs classes for serialization and deserialization. Shows encoding/decoding behavior, validation, and support for pre/post init methods.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> from attrs import define\n\n>>> @define\n... class Person:\n...     name: str\n...     age: int\n\n>>> carol = Person(name=\"carol\", age=32)\n\n>>> msg = msgspec.json.encode(carol)\n\n>>> msgspec.json.decode(msg, type=Person)\nPerson(name='carol', age=32)\n\n>>> wrong_type = b'{\"name\": \"doug\", \"age\": \"thirty\"}'\n\n>>> msgspec.json.decode(wrong_type, type=Person)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$.age`\n```\n\n----------------------------------------\n\nTITLE: Using Explicit Dictionary Mapping for Renaming Fields\nDESCRIPTION: Shows how to use an explicit dictionary mapping for renaming fields, which is useful for handling acronyms or matching existing API field names exactly.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#podspec-v1-core\n# An explicit mapping from python name -> JSON field name\nv1podspec_names = {\n    ...\n    \"service_account_name\": \"serviceAccountName\",\n    \"set_hostname_as_fqdn\": \"setHostnameAsFQDN\",\n    ...\n}\n\n# Pass the mapping to `rename` to explicitly rename all fields\nclass V1PodSpec(msgspec.Struct, rename=v1podspec_names):\n    ...\n    service_account_name: str = \"\"\n    set_hostname_as_fqdn: bool = False\n    ...\n```\n\n----------------------------------------\n\nTITLE: Benchmarking msgspec GeoJSON Parsing Performance\nDESCRIPTION: Compares the performance of msgspec GeoJSON parsing with other libraries including orjson, standard json, and the geojson package. The benchmark shows that msgspec is significantly faster than alternatives while providing validation.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/geojson.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%timeit msgspec_geojson.loads(data)  # benchmark msgspec\n# 6.15 ms  13.8 s per loop (mean  std. dev. of 7 runs, 100 loops each)\n\n%timeit orjson.loads(data)  # benchmark orjson\n# 8.67 ms  20.8 s per loop (mean  std. dev. of 7 runs, 100 loops each)\n\n%timeit json.loads(data)  # benchmark json\n# 27.6 ms  102 s per loop (mean  std. dev. of 7 runs, 10 loops each)\n\n%timeit geojson.loads(data)  # benchmark geojson\n# 93.9 ms  88.1 s per loop (mean  std. dev. of 7 runs, 10 loops each)\n```\n\n----------------------------------------\n\nTITLE: Decoding Twitter API JSON Data with Custom Structs in Python using msgspec\nDESCRIPTION: Demonstrates how to use custom Struct types to decode specific fields from a JSON object returned by the Twitter API.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> tweet = msgspec.json.decode(example_json, type=Tweet)\n\n>>> tweet.user.name\n'Twitter Dev'\n\n>>> tweet.user.favorite_count\n70\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Methods to a Struct in Python\nDESCRIPTION: This example shows how to add custom methods to a Struct definition, specifically a method to convert the Struct to a dictionary.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> class Point(msgspec.Struct):\n...     \"\"\"A point in 2D space\"\"\"\n...     x : float\n...     y : float\n...\n...     def to_dict(self):\n...         return {f: getattr(self, f) for f in self.__struct_fields__}\n...\n\n>>> p = Point(1.0, 2.0)\n\n>>> p.to_dict()\n{\"x\": 1.0, \"y\": 2.0}\n```\n\n----------------------------------------\n\nTITLE: Loading and Parsing pyproject.toml Example\nDESCRIPTION: Demonstrates how to load a pyproject.toml file from a URL and parse it using the defined schema. Shows accessing parsed fields and structure of the output.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/pyproject-toml.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pyproject\nimport urllib.request\n\nurl = \"https://raw.githubusercontent.com/encode/starlette/master/pyproject.toml\"\n\nwith urllib.request.urlopen(url) as f:\n    data = f.read()\n\nresult = pyproject.decode(data)  # decode the pyproject.toml\n\nresult.build_system\nresult.project.name\n```\n\n----------------------------------------\n\nTITLE: Basic Type Introspection in Python using msgspec\nDESCRIPTION: Demonstrates the use of msgspec.inspect.type_info and multi_type_info functions to introspect basic types like bool, int, and list[int].\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/inspect.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> msgspec.inspect.type_info(bool)\nBoolType()\n\n>>> msgspec.inspect.type_info(int)\nIntType(gt=None, ge=None, lt=None, le=None, multiple_of=None)\n\n>>> msgspec.inspect.type_info(list[int])  # nested types are traversed\nListType(\n    item_type=IntType(gt=None, ge=None, lt=None, le=None, multiple_of=None),\n    min_length=None,\n    max_length=None\n)\n\n>>> msgspec.inspect.multi_type_info([bool, int])  # inspect multiple types\n(BoolType(), IntType(gt=None, ge=None, lt=None, le=None, multiple_of=None))\n```\n\n----------------------------------------\n\nTITLE: Timedelta Serialization in Python with msgspec\nDESCRIPTION: Demonstrates encoding and decoding of timedelta objects using ISO 8601 duration format. Shows various duration formats and handling of strict vs lax mode.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from datetime import timedelta\n>>> msgspec.json.encode(timedelta(seconds=123))\nb'\"PT123S\"'\n>>> msgspec.json.encode(timedelta(days=1, seconds=30, microseconds=123))\nb'\"P1DT30.000123S\"'\n>>> msgspec.json.decode(b'\"PT123S\"', type=timedelta)\ndatetime.timedelta(seconds=123)\n>>> msgspec.json.decode(b'\"PT1.5M\"', type=timedelta)\ndatetime.timedelta(seconds=90)\n>>> msgspec.json.decode(b'\"oops\"', type=datetime.timedelta)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid ISO8601 duration\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding None in JSON\nDESCRIPTION: Demonstrates how None is encoded to and decoded from JSON using msgspec. Also shows how string 'null' can be decoded to None when strict mode is disabled.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode(None)\nb'null'\n\n>>> msgspec.json.decode(b'null')\nNone\n\n>>> msgspec.json.decode(b'\"null\"', type=None, strict=False)\nNone\n```\n\n----------------------------------------\n\nTITLE: Defining Base User Schema in Python with msgspec\nDESCRIPTION: Creates a User class using msgspec.Struct with required name field and optional groups and email fields. Shows basic structure definition with type hints.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/schema-evolution.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Set, Optional\n\n>>> class User(msgspec.Struct):\n...     \"\"\"A struct representing a user\"\"\"\n...     name: str\n...     groups: Set[str] = set()\n...     email: Optional[str] = None\n```\n\n----------------------------------------\n\nTITLE: DateTime Date Handling in Python with msgspec\nDESCRIPTION: Demonstrates encoding and decoding of datetime.date objects using msgspec with JSON format. Shows conversion to RFC3339 encoded strings and error handling.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import datetime\n>>> date = datetime.date(2021, 4, 2)\n>>> msg = msgspec.json.encode(date)\n>>> msg\nb'\"2021-04-02\"'\n>>> msgspec.json.decode(msg, type=datetime.date)\ndatetime.date(2021, 4, 2)\n>>> msgspec.json.decode(b'\"oops\"', type=datetime.date)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Invalid RFC3339 encoded date\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Floats in JSON\nDESCRIPTION: Shows how floating-point numbers are handled in JSON encoding and decoding. Demonstrates the treatment of non-finite values and automatic conversion of integers to floats.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode(123.0)\nb\"123.0\"\n\n>>> # JSON doesn't support nonfinite values, these serialize as null\n... msgspec.json.encode(float(\"nan\"))\nb\"null\"\n\n>>> msgspec.json.decode(b\"123.0\", type=float)\n123.0\n\n>>> # Ints are automatically converted to floats\n... msgspec.json.decode(b\"123\", type=float)\n123.0\n\n>>> msgspec.json.decode(b'\"123.45\"', type=float, strict=False)\n123.45\n\n>>> msgspec.json.decode(b'\"-inf\"', type=float, strict=False)\n-inf\n```\n\n----------------------------------------\n\nTITLE: Querying EdgeDB and Working with Object Results\nDESCRIPTION: Demonstrates querying EdgeDB to get movie information, displaying the Object return type, and encoding it to JSON using msgspec.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import edgedb\n\n>>> import msgspec\n\n>>> client = edgedb.create_client()\n\n>>> dune = client.query_single(\n...     \"\"\"\n...     SELECT Movie {\n...         title,\n...         actors: {\n...             name\n...         }\n...     }\n...     FILTER .title = 'Dune'\n...     LIMIT 1\n...     \"\"\"\n... )\n\n>>> dune\nObject{title := 'Dune', actors := [Object{name := 'Timothe Chalamet'}, Object{name := 'Zendaya'}]}\n\n>>> type(dune)\nedgedb.Object\n\n>>> json = msgspec.json.encode(dune)\n\n>>> print(msgspec.json.format(json.decode()))  # pretty-print the JSON\n{\n  \"id\": \"b21913c4-3b68-11ee-89b0-2f0b6819503d\",\n  \"title\": \"Dune\",\n  \"actors\": [\n    {\n      \"id\": \"b219195a-3b68-11ee-89b0-5b3794805cc7\",\n      \"name\": \"Timothe Chalamet\"\n    },\n    {\n      \"id\": \"b2192058-3b68-11ee-89b0-f7d83b95fb13\",\n      \"name\": \"Zendaya\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Value Constraints with Annotated and Meta in Python\nDESCRIPTION: Shows how to use typing.Annotated and msgspec.Meta to apply value constraints, specifically for positive integers. It demonstrates successful decoding and an error case when the constraint is violated.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Annotated\n\n>>> PositiveInt = Annotated[int, msgspec.Meta(gt=0)]\n\n>>> msgspec.json.decode(b'[1, 2, 3]', type=list[PositiveInt])\n[1, 2, 3]\n\n>>> msgspec.json.decode(b'[1, 2, -1]', type=list[PositiveInt])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int` >= 1 - at `$[2]`\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Strings in JSON\nDESCRIPTION: Demonstrates string encoding and decoding in JSON, including handling of unicode characters.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode(\"Hello, world!\")\nb'\"Hello, world!\"'\n\n>>> msgspec.json.encode(\" is not escaped\")\nb'\"\\xf0\\x9d\\x84\\x9e is not escaped\"'\n\n>>> msgspec.json.decode(b'\"Hello, world!\"')\n\"Hello, world!\"\n```\n\n----------------------------------------\n\nTITLE: Introspecting Types with Additional Metadata in Python using msgspec\nDESCRIPTION: Shows how msgspec.inspect.type_info handles types with additional metadata like extra_json_schema or title, wrapping them in a Metadata object.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/inspect.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> UnixName = Annotated[\n...     str,\n...     Meta(\n...         min_length=1,\n...         max_length=32,\n...         pattern=\"^[a-z_][a-z0-9_-]*$\",\n...         description=\"A valid UNIX username\"\n...     )\n... ]\n\n>>> msgspec.inspect.type_info(UnixName)\nMetadata(\n    type=StrType(\n        min_length=1,\n        max_length=32,\n        pattern='^[a-z_][a-z0-9_-]*$'\n    ),\n    extra_json_schema={'description': 'A valid UNIX username'}\n)\n```\n\n----------------------------------------\n\nTITLE: Garbage Collection Control in Msgspec Structs\nDESCRIPTION: Demonstrates how garbage collection tracking works with msgspec Structs. Shows how structs with only scalar values aren't tracked while those with container types are tracked by default.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Any\n\n>>> import gc\n\n>>> class Example(msgspec.Struct):\n...     x: Any\n...     y: Any\n\n>>> ex1 = Example(1, \"two\")\n\n>>> # ex1 is untracked, since it only references untracked objects\n... gc.is_tracked(ex1)\nFalse\n\n>>> ex2 = Example([1, 2, 3], (4, 5, 6))\n\n>>> # ex2 is tracked, since it references tracked objects\n... gc.is_tracked(ex2)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Bytes in JSON\nDESCRIPTION: Shows how bytes-like objects are encoded to and decoded from base64-encoded strings in JSON.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> msg = msgspec.json.encode(b\"\\xf0\\x9d\\x84\\x9e\")\n\n>>> msg\nb'\"85+Eng==\"'\n\n>>> msgspec.json.decode(msg, type=bytes)\nb'\\xf0\\x9d\\x84\\x9e'\n\n>>> msgspec.json.decode(msg, type=bytearray)\nbytearray(b'\\xf0\\x9d\\x84\\x9e')\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Booleans in JSON\nDESCRIPTION: Shows how boolean values are encoded to and decoded from JSON. Includes examples of non-strict decoding where various string and number representations are coerced to booleans.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode(True)\nb'true'\n\n>>> msgspec.json.decode(b'true')\nTrue\n\n>>> msgspec.json.decode(b'\"false\"', type=bool, strict=False)\nFalse\n\n>>> msgspec.json.decode(b'\"TRUE\"', type=bool, strict=False)\nTrue\n\n>>> msgspec.json.decode(b'1', type=bool, strict=False)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using NewType in MsgSpec\nDESCRIPTION: Demonstrates how typing.NewType is handled in MsgSpec. NewType types are treated identically to their base type, with support provided to aid static analysis tools like mypy or pyright.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import NewType\n\n>>> UserId = NewType(\"UserId\", int)\n\n>>> msgspec.json.encode(UserId(1234))\nb'1234'\n\n>>> msgspec.json.decode(b'1234', type=UserId)\n1234\n\n>>> msgspec.json.decode(b'\"oops\"', type=UserId)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str`\n```\n\n----------------------------------------\n\nTITLE: Typed Decoding with Structs in Python\nDESCRIPTION: Demonstrates type-safe decoding using msgspec Structs with validation during decoding process.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class User(msgspec.Struct):\n...     name: str\n...     groups: set[str] = set()\n...     email: str | None = None\n\n>>> msgspec.json.decode(\n...     b'{\"name\": \"alice\", \"groups\": [\"admin\", \"engineering\"]}',\n...     type=User\n... )\nUser(name='alice', groups={'admin', 'engineering'}, email=None)\n```\n\n----------------------------------------\n\nTITLE: Equality and Ordering in msgspec.Struct\nDESCRIPTION: Demonstrates how to configure equality and ordering for msgspec.Struct types. Shows enabling ordering with order=True and disabling equality with eq=False.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> class Point(msgspec.Struct, order=True):\n...     x: float\n...     y: float\n\n>>> Point(1, 2) == Point(1, 2)\nTrue\n\n>>> Point(1, 2) < Point(3, 4)\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> class Point(msgspec.Struct, eq=False):\n...     x: float\n...     y: float\n\n\n>>> p = Point(1, 2)\n\n>>> p == Point(1, 2)\nFalse\n\n>>> p == p  # identity comparison only\nTrue\n```\n\n----------------------------------------\n\nTITLE: Strict vs Lax Mode Decoding Example\nDESCRIPTION: Illustrates the difference between strict and lax decoding modes when handling type mismatches.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/usage.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.decode(b'[1, 2, \"3\"]', type=list[int])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `int`, got `str` - at `$[2]`\n\n>>> msgspec.json.decode(b'[1, 2, \"3\"]', type=list[int], strict=False)\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Combining Struct-level and Field-level Renaming\nDESCRIPTION: Demonstrates how field-level renaming takes precedence over struct-level renaming when both are used together.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Example(msgspec.Struct, rename=\"camel\"):\n...     field_x: int\n...     field_y: int = msgspec.field(name=\"y\")  # set explicitly\n\n>>> msgspec.json.encode(Example(1, 2))\nb'{\"fieldX\":1,\"y\":2}'\n```\n\n----------------------------------------\n\nTITLE: Applying Datetime Timezone Constraints in Python with msgspec\nDESCRIPTION: Shows how to apply timezone constraints to datetime objects using msgspec.Meta. It includes examples of requiring timezone-aware and timezone-naive datetimes.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from datetime import datetime\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(\n...     b'\"2022-04-02T18:18:10\"',\n...     type=Annotated[datetime, msgspec.Meta(tz=True)]  # require timezone aware\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `datetime` with a timezone component\n\n>>> msgspec.json.decode(\n...     b'\"2022-04-02T18:18:10-06:00\"',\n...     type=Annotated[datetime, msgspec.Meta(tz=False)]  # require timezone naive\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `datetime` with no timezone component\n```\n\n----------------------------------------\n\nTITLE: Applying Sequence Length Constraints in Python with msgspec\nDESCRIPTION: Shows how to apply length constraints to sequence types (like lists) using msgspec.Meta. The example demonstrates an error case when the list exceeds the specified maximum length.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(\n...     b'[1, 2, 3, 4]',\n...     type=Annotated[list[int], msgspec.Meta(max_length=3)]\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `array` of length <= 3\n```\n\n----------------------------------------\n\nTITLE: Using EdgeDB query_json Method and msgspec.Raw for JSON Composition\nDESCRIPTION: Shows how to use EdgeDB's query_json method to get results directly as JSON strings, and compose them with additional metadata using msgspec.Raw.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> edgedb_json = client.query_single_json(\n...     \"\"\"\n...     SELECT Movie {\n...         title,\n...         actors: {\n...             name\n...         }\n...     }\n...     FILTER .title = 'Dune'\n...     LIMIT 1\n...     \"\"\"\n... )\n\n>>> edgedb_json\n'{\"title\" : \"Dune\", \"actors\" : [{\"name\" : \"Timothe Chalamet\"},{\"name\" : \"Zendaya\"}]}'\n\n>>> import datetime\n\n>>> msg = {\n...     \"timestamp\": datetime.datetime.now(datetime.timezone.utc),\n...     \"server_version\": \"3.2\",\n...     \"query_result\": msgspec.Raw(edgedb_json),\n... }\n\n>>> json = msgspec.json.encode(msg)\n\n>>> print(msgspec.json.format(json.decode()))  # pretty-print the JSON\n{\n  \"timestamp\": \"2023-08-15T14:37:12.733731Z\",\n  \"server_version\": \"3.2\",\n  \"query_result\": {\n    \"title\": \"Dune\",\n    \"actors\": [\n      {\n        \"name\": \"Timothe Chalamet\"\n      },\n      {\n        \"name\": \"Zendaya\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Dictionary Key Constraint\nDESCRIPTION: Example showing JSON constraint support for dictionary keys.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/changelog.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom msgspec import Struct\n\nclass Config(Struct):\n    data: dict[int, str]  # Dictionary with integer keys\n```\n\n----------------------------------------\n\nTITLE: Applying Bytes Length Constraints in Python with msgspec\nDESCRIPTION: Demonstrates how to apply length constraints to bytes objects using msgspec.Meta. The example shows an error case when the bytes object is shorter than the specified minimum length.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/constraints.rst#2025-04-18_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> from typing import Annotated\n\n>>> msgspec.json.decode(\n...     b'\"ZXhhbXBsZQ==\"',\n...     type=Annotated[bytes, msgspec.Meta(min_length=10)]\n... )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nmsgspec.ValidationError: Expected `bytes` of length >= 10\n```\n\n----------------------------------------\n\nTITLE: Running EdgeQL Query to Insert Data\nDESCRIPTION: Executes an EdgeQL query from a file to insert example data into the database.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ edgedb query -f insert_data.edgeql\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON to Python Object with msgspec\nDESCRIPTION: Demonstrates how to deserialize JSON data back into a Python Example object using msgspec.json.decode with type annotation.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmsgspec.json.decode(msg, type=Example)\nExample(my_first_field=\"some string\", my_second_field=2)\n```\n\n----------------------------------------\n\nTITLE: Mapping Complex Numbers to Native Types in msgspec\nDESCRIPTION: Implements enc_hook and dec_hook to serialize complex numbers by converting them to/from tuples. This approach uses only native types in the serialized message and requires typed decoding for roundtripping.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/extending.rst#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport msgspec\nfrom typing import Any, Type\n\ndef enc_hook(obj: Any) -> Any:\n    if isinstance(obj, complex):\n        # convert the complex to a tuple of real, imag\n        return (obj.real, obj.imag)\n    else:\n        # Raise a NotImplementedError for other types\n        raise NotImplementedError(f\"Objects of type {type(obj)} are not supported\")\n\n\ndef dec_hook(type: Type, obj: Any) -> Any:\n    # `type` here is the value of the custom type annotation being decoded.\n    if type is complex:\n        # Convert ``obj`` (which should be a ``tuple``) to a complex\n        real, imag = obj\n        return complex(real, imag)\n    else:\n        # Raise a NotImplementedError for other types\n        raise NotImplementedError(f\"Objects of type {type} are not supported\")\n\n\n# Define a message that contains a complex type\nclass MyMessage(msgspec.Struct):\n    field_1: str\n    field_2: complex\n\n# Create an encoder and a decoder using the custom callbacks.\n# Note that typed deserialization is required for successful\n# roundtripping here, so we pass `MyMessage` to `Decoder`.\nenc = msgspec.json.Encoder(enc_hook=enc_hook)\ndec = msgspec.json.Decoder(MyMessage, dec_hook=dec_hook)\n\n# An example message\nmsg = MyMessage(\"some string\", complex(1, 2))\n\n# Encode and decode the message to show that things work\nbuf = enc.encode(msg)\nmsg2 = dec.decode(buf)\nassert msg == msg2  # True\n```\n\n----------------------------------------\n\nTITLE: Defining Array-Like Struct in Python with msgspec for Optimized Encoding/Decoding\nDESCRIPTION: Shows how to define a Struct with array_like=True option for more efficient encoding and decoding, removing field names from the encoded message.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> class Example(msgspec.Struct, array_like=True):\n...     my_first_field: str\n```\n\n----------------------------------------\n\nTITLE: Introspecting Struct Types in Python using msgspec\nDESCRIPTION: Demonstrates how to use msgspec.inspect.type_info with compound types like msgspec.Struct, showing the detailed structure of the resulting StructType.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/inspect.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> class User(msgspec.Struct):\n...     name: str\n...     groups: list[str] = []\n...     email: str | None = None\n\n>>> msgspec.inspect.type_info(User)\nStructType(\n    cls=User,\n    fields=(\n        Field(\n            name='name',\n            encode_name='name',\n            type=StrType(min_length=None, max_length=None, pattern=None),\n            required=True,\n            default=UNSET,\n            default_factory=UNSET\n        ),\n        Field(\n            name='groups',\n            encode_name='groups',\n            type=ListType(\n                item_type=StrType(min_length=None, max_length=None, pattern=None),\n                min_length=None,\n                max_length=None\n            ),\n            required=False,\n            default=[],\n            default_factory=UNSET\n        ),\n        Field(\n            name='email',\n            encode_name='email',\n            type=UnionType(\n                types=(\n                    StrType(min_length=None, max_length=None, pattern=None),\n                    NoneType()\n                )\n            ),\n            required=False,\n            default=None,\n            default_factory=UNSET\n        )\n    ),\n    tag_field=None,\n    tag=None,\n    array_like=False,\n    forbid_unknown_fields=False\n)\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Integers in JSON\nDESCRIPTION: Demonstrates encoding and decoding of integers in JSON format. Includes an example of non-strict decoding where a string representation of a number is coerced to an integer.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/supported-types.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> msgspec.json.encode(123)\nb\"123\"\n\n>>> msgspec.json.decode(b\"123\", type=int)\n123\n\n>>> msgspec.json.decode(b'\"123\"', type=int, strict=False)\n123\n\n>>> msgspec.json.decode(b'123.0', type=int, strict=False)\n123\n```\n\n----------------------------------------\n\nTITLE: Accessing Example Class Fields in Python\nDESCRIPTION: Shows how to instantiate an Example class with string and integer fields.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nx = Example(\"some string\", 2)\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Invalid Configuration\nDESCRIPTION: Shows how to handle and validate an invalid pyproject.toml file, demonstrating the error messages produced when validation fails.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/pyproject-toml.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pyproject\n\nwith open(\"pyproject.toml\", \"rb\") as f:\n    invalid = f.read()\n\npyproject.decode(invalid)\n```\n\n----------------------------------------\n\nTITLE: Default Dictionary-based Encoding of Structs\nDESCRIPTION: Shows the default behavior of encoding Struct objects as dictionaries with both keys and values in the message.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> import msgspec\n\n>>> class Point(msgspec.Struct):\n...     x: int\n...     y: int\n\n>>> msgspec.json.encode(Point(1, 2))\nb'{\"x\":1,\"y\":2}'\n```\n\n----------------------------------------\n\nTITLE: Encoding Python Object to JSON with msgspec\nDESCRIPTION: Demonstrates how to serialize an Example object to JSON format using msgspec.json.encode.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmsg = msgspec.json.encode(x)\n```\n\n----------------------------------------\n\nTITLE: Using ClassVar with msgspec.Struct in Python\nDESCRIPTION: Demonstrates how to define class variables that are not considered fields in msgspec.Struct classes using ClassVar. Shows a simple example of creating an instance where only regular fields are counted.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> Example.a_class_variable\n2\n\n>>> Example(1)  # only `x` is counted as a field\nExample(x=1)\n```\n\n----------------------------------------\n\nTITLE: Default Value Detection Logic in msgspec\nDESCRIPTION: Shows the implementation of the matches_default function that determines whether a value matches the default for a field, used for the omit_defaults functionality.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> def matches_default(value: Any, default: Any) -> bool:\n...     \"\"\"Whether a value matches the default for a field\"\"\"\n...     if value is default:\n...         return True\n...     if type(value) != type(default):\n...         return False\n...     if type(value) in (list, set, dict) and (len(value) == len(default) == 0):\n...         return True\n...     return False\n```\n\n----------------------------------------\n\nTITLE: Generated JSON Schema Output\nDESCRIPTION: The resulting JSON Schema generated from the Python code above. Shows the complete schema structure including definitions for Dimensions and Product types with their constraints and defaults.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/jsonschema.rst#2025-04-18_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"array\",\n  \"items\": {\"$ref\": \"#/$defs/Product\"},\n  \"$defs\": {\n    \"Dimensions\": {\n      \"title\": \"Dimensions\",\n      \"description\": \"Dimensions for a product, all measurements in centimeters\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"length\": {\"type\": \"number\", \"exclusiveMinimum\": 0},\n        \"width\": {\"type\": \"number\", \"exclusiveMinimum\": 0},\n        \"height\": {\"type\": \"number\", \"exclusiveMinimum\": 0}\n      },\n      \"required\": [\"length\", \"width\", \"height\"]\n    },\n    \"Product\": {\n      \"title\": \"Product\",\n      \"description\": \"A product in a catalog\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\"type\": \"integer\"},\n        \"name\": {\"type\": \"string\"},\n        \"price\": {\"type\": \"number\", \"exclusiveMinimum\": 0},\n        \"tags\": {\n          \"type\": \"array\",\n          \"items\": {\"type\": \"string\"},\n          \"default\": []\n        },\n        \"dimensions\": {\n          \"anyOf\": [{\"type\": \"null\"}, {\"$ref\": \"#/$defs/Dimensions\"}],\n          \"default\": null\n        }\n      },\n      \"required\": [\"id\", \"name\", \"price\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Unknown Field Handling in msgspec\nDESCRIPTION: Shows how msgspec skips unknown fields by default when decoding into Struct types, which allows for schema evolution but can lead to unnoticed typos.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/structs.rst#2025-04-18_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> class Example(msgspec.Struct):\n...     field_one: int\n...     field_two: bool = False\n\n>>> msgspec.json.decode(\n...     b'{\"field_one\": 1, \"field_twoo\": true}',  # oops, a typo\n...     type=Example\n... )\nExample(field_one=1, field_two=False)\n```\n\n----------------------------------------\n\nTITLE: Extending msgspec to Support Custom EdgeDB Types\nDESCRIPTION: Creates an encoding hook to support EdgeDB's DateDuration and RelativeDuration types, which aren't natively supported by msgspec.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> def enc_hook(obj):\n...     if isinstance(obj, (edgedb.DateDuration, edgedb.RelativeDuration)):\n...         # The str representation of these types are ISO8601 durations,\n...         return str(obj)\n...     # Raise a NotImplementedError for unsupported types\n...     raise NotImplementedError\n\n>>> duration = client.query_single('SELECT <cal::date_duration>\"1 year 2 days\"')\n\n>>> duration\n<edgedb.DateDuration \"P1Y2D\">\n\n>>> msgspec.json.encode(duration, enc_hook=enc_hook)\nb'\"P1Y2D\"'\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with pip\nDESCRIPTION: Basic installation of msgspec using pip package manager. Requires Python >= 3.8 with no additional dependencies.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install msgspec\n```\n\n----------------------------------------\n\nTITLE: Example Field Rename Configuration\nDESCRIPTION: Example demonstrating field renaming using the name keyword in msgspec.field.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/changelog.rst#2025-04-18_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom msgspec import Struct, field\n\nclass MyStruct(Struct):\n    my_field: str = field(name=\"myField\")\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with conda\nDESCRIPTION: Basic installation of msgspec using conda package manager from the conda-forge channel. Requires Python >= 3.8.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nconda install msgspec -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Example Configuration Using typing.Final\nDESCRIPTION: Example showing support for typing.Final annotations to indicate immutable object fields in struct types.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/changelog.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Final\n\nclass MyStruct(msgspec.Struct):\n    immutable_field: Final[str]\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with YAML support using pip\nDESCRIPTION: Installation of msgspec with PyYAML dependency using pip. Required for YAML protocol support on all platforms.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npip install \"msgspec[yaml]\"\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec development version from GitHub\nDESCRIPTION: Installation of the latest development version of msgspec directly from the GitHub repository using pip.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npip install git+https://github.com/jcrist/msgspec.git\n```\n\n----------------------------------------\n\nTITLE: Defining Schema Classes with msgspec.Struct for Benchmark\nDESCRIPTION: Code defining the schema used in the benchmark, including an enum for permissions and structs for File and Directory objects. This schema is used to demonstrate msgspec's validation capabilities compared to other libraries.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/benchmarks.rst#2025-04-18_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport enum\nimport datetime\nimport msgspec\n\nclass Permissions(enum.Enum):\n    READ = \"READ\"\n    WRITE = \"WRITE\"\n    READ_WRITE = \"READ_WRITE\"\n\n\nclass File(msgspec.Struct, kw_only=True, tag=\"file\"):\n    name: str\n    created_by: str\n    created_at: datetime.datetime\n    updated_by: str | None = None\n    updated_at: datetime.datetime | None = None\n    nbytes: int\n    permissions: Permissions\n\n\nclass Directory(msgspec.Struct, kw_only=True, tag=\"directory\"):\n    name: str\n    created_by: str\n    created_at: datetime.datetime\n    updated_by: str | None = None\n    updated_at: datetime.datetime | None = None\n    contents: list[File | Directory]\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with TOML support using conda\nDESCRIPTION: Installation of msgspec with TOML dependencies using conda from the conda-forge channel.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nconda install msgspec-toml -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Encoding Messages with msgspec JSON Serialization\nDESCRIPTION: Demonstrates how to create a User instance and encode it to JSON format using msgspec.json.encode(). Shows object instantiation and conversion to JSON bytes.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> alice = User(\"alice\", groups={\"admin\", \"engineering\"})\n\n>>> alice\nUser(name='alice', groups={\"admin\", \"engineering\"}, email=None)\n\n>>> msg = msgspec.json.encode(alice)\n\n>>> msg\nb'{\"name\":\"alice\",\"groups\":[\"admin\",\"engineering\"],\"email\":null}'\n```\n\n----------------------------------------\n\nTITLE: Benchmark Data Arrays Definition - JSON and MessagePack Performance\nDESCRIPTION: Defines arrays containing benchmark results for various serialization libraries comparing encode/decode times and memory usage. Each array represents a different benchmark category: validation, JSON serialization, and MessagePack serialization.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/benchmarks.rst#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nvar results_json = [\n    {\"label\": \"msgspec structs\", \"encode\": 0.00014051752349996606, \"decode\": 0.00036725287499939443},\n    {\"label\": \"msgspec\", \"encode\": 0.00018274705249996258, \"decode\": 0.00048175174399875685},\n    {\"label\": \"json\", \"encode\": 0.0012280583099982323, \"decode\": 0.0009195450700008223},\n    {\"label\": \"orjson\", \"encode\": 0.00017935967999983403, \"decode\": 0.0004634268540012272},\n    {\"label\": \"ujson\", \"encode\": 0.0006279176680000091, \"decode\": 0.0008554406740004197},\n    {\"label\": \"rapidjson\", \"encode\": 0.000513588076000815, \"decode\": 0.0011320363100003306},\n    {\"label\": \"simdjson\", \"encode\": 0.00123421613499886, \"decode\": 0.0007710835699999734}\n];\n\nvar results_msgpack = [\n    {\"label\": \"msgspec structs\", \"encode\": 0.00011157811949942698, \"decode\": 0.000347989668000082},\n    {\"label\": \"msgspec\", \"encode\": 0.00012483930500002316, \"decode\": 0.000487175850001222},\n    {\"label\": \"msgpack\", \"encode\": 0.00040346372400017574, \"decode\": 0.0007988804240012541},\n    {\"label\": \"ormsgpack\", \"encode\": 0.00016052370499983226, \"decode\": 0.0007458347079991654}\n];\n```\n\n----------------------------------------\n\nTITLE: Starting Key-Value Server\nDESCRIPTION: Command line example showing how to start the TCP key-value server that listens on localhost port 8888\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/asyncio-kv.rst#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ python kv.py\nServing on tcp://127.0.0.1:8888...\nConnection opened\nConnection closed\n```\n\n----------------------------------------\n\nTITLE: Plot Building Function Calls\nDESCRIPTION: Series of function calls to buildPlot() and buildMemPlot() to create visualizations for the benchmark data. Creates separate plots for validation benchmarks, memory usage, JSON serialization, and MessagePack serialization.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/benchmarks.rst#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nbuildPlot('#bench-validate', results_valid, \"Benchmark - JSON Serialization & Validation\");\nbuildMemPlot('#bench-validate-memory', results_valid, \"Benchmark - Serialization & Validation\");\nbuildPlot('#bench-json', results_json, \"Benchmark - JSON Serialization\");\nbuildPlot('#bench-msgpack', results_msgpack, \"Benchmark - MessagePack Serialization\");\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results for JSON Libraries Processing conda-forge Metadata\nDESCRIPTION: Command line output showing execution times for different JSON libraries when processing conda-forge repository data. The results show msgspec is the fastest at 25.73ms, followed by simdjson, orjson, ujson, and json.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/conda-repodata.rst#2025-04-18_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ python query_repodata.py\njson: 139.14 ms\nujson: 124.91 ms\norjson: 91.69 ms\nsimdjson: 66.40 ms\nmsgspec: 25.73 ms\n```\n\n----------------------------------------\n\nTITLE: Invalid pyproject.toml Configuration Example\nDESCRIPTION: Example of an invalid pyproject.toml file where build-system.requires is incorrectly specified as a string instead of an array of strings.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/pyproject-toml.rst#2025-04-18_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = \"hatchling\"\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"a super great library\"\nauthors = [\n    {name = \"alice shmalice\", email = \"alice@company.com\"}\n]\n```\n\n----------------------------------------\n\nTITLE: Converting EdgeDB Results to msgspec Structs\nDESCRIPTION: Defines msgspec Struct types matching the database schema and demonstrates converting EdgeDB query results to these struct instances.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> class Person(msgspec.Struct):\n...     name: str\n\n>>> class Movie(msgspec.Struct):\n...     title: str\n...     actors: list[Person]\n\n>>> msgspec.convert(dune, Movie, from_attributes=True)\nMovie(title='Dune', actors=[Person(name='Timothe Chalamet'), Person(name='Zendaya')])\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with TOML support using pip\nDESCRIPTION: Installation of msgspec with TOML dependencies using pip. Installs tomli and tomli_w for Python < 3.11, or just tomli_w for Python >= 3.11.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install \"msgspec[toml]\"\n```\n\n----------------------------------------\n\nTITLE: Installing msgspec with YAML support using conda\nDESCRIPTION: Installation of msgspec with YAML dependencies using conda from the conda-forge channel.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/install.rst#2025-04-18_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nconda install msgspec-yaml -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Initializing EdgeDB Project with CLI\nDESCRIPTION: Sets up a new EdgeDB project instance using the EdgeDB CLI with a non-interactive mode.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/examples/edgedb.rst#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ edgedb project init --server-instance edgedb-msgspec-example --non-interactive\n```\n\n----------------------------------------\n\nTITLE: Viewing Encoded JSON Output\nDESCRIPTION: Shows the byte string representation of the encoded JSON data, demonstrating how msgspec formats the output.\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/perf-tips.rst#2025-04-18_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmsg\nb'[\"some string\",2]'\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Links and References\nDESCRIPTION: Reference links used in the documentation for mypy and pyright tools\nSOURCE: https://github.com/jcrist/msgspec/blob/main/docs/source/why.rst#2025-04-18_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _mypy: https://mypy.readthedocs.io\n.. _pyright: https://github.com/microsoft/pyright\n```"
  }
]