[
  {
    "owner": "tokio-rs",
    "repo": "tracing",
    "content": "TITLE: Instrumenting Library Code with Tracing\nDESCRIPTION: This example demonstrates how to instrument a Rust library with tracing. It shows the use of spans, events at different log levels, the #[tracing::instrument] attribute, and capturing local variables as fields.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{error::Error, io};\nuse tracing::{debug, error, info, span, warn, Level};\n\n// the `#[tracing::instrument]` attribute creates and enters a span\n// every time the instrumented function is called. The span is named after\n// the function or method. Parameters passed to the function are recorded as fields.\n#[tracing::instrument]\npub fn shave(yak: usize) -> Result<(), Box<dyn Error + 'static>> {\n    // this creates an event at the DEBUG level with two fields:\n    // - `excitement`, with the key \"excitement\" and the value \"yay!\"\n    // - `message`, with the key \"message\" and the value \"hello! I'm gonna shave a yak.\"\n    //\n    // unlike other fields, `message`'s shorthand initialization is just the string itself.\n    debug!(excitement = \"yay!\", \"hello! I'm gonna shave a yak.\");\n    if yak == 3 {\n        warn!(\"could not locate yak!\");\n        // note that this is intended to demonstrate `tracing`'s features, not idiomatic\n        // error handling! in a library or application, you should consider returning\n        // a dedicated `YakError`. libraries like snafu or thiserror make this easy.\n        return Err(io::Error::new(io::ErrorKind::Other, \"shaving yak failed!\").into());\n    } else {\n        debug!(\"yak shaved successfully\");\n    }\n    Ok(())\n}\n\npub fn shave_all(yaks: usize) -> usize {\n    // Constructs a new span named \"shaving_yaks\" at the TRACE level,\n    // and a field whose key is \"yaks\". This is equivalent to writing:\n    //\n    // let span = span!(Level::TRACE, \"shaving_yaks\", yaks = yaks);\n    //\n    // local variables (`yaks`) can be used as field values\n    // without an assignment, similar to struct initializers.\n    let span = span!(Level::TRACE, \"shaving_yaks\", yaks);\n    let _enter = span.enter();\n\n    info!(\"shaving yaks\");\n\n    let mut yaks_shaved = 0;\n    for yak in 1..=yaks {\n        let res = shave(yak);\n        debug!(yak, shaved = res.is_ok());\n\n        if let Err(ref error) = res {\n            // Like spans, events can also use the field initialization shorthand.\n            // In this instance, `yak` is the field being initialized.\n            error!(yak, error = error.as_ref(), \"failed to shave yak!\");\n        } else {\n            yaks_shaved += 1;\n        }\n        debug!(yaks_shaved);\n    }\n\n    yaks_shaved\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Tracing Subscriber in Rust Application\nDESCRIPTION: Demonstrates setting up a global FmtSubscriber for tracing with basic configuration and usage. Shows how to set logging levels and create basic trace events.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{info, Level};\nuse tracing_subscriber::FmtSubscriber;\n\nfn main() {\n    // a builder for `FmtSubscriber`.\n    let subscriber = FmtSubscriber::builder()\n        // all spans/events with a level higher than TRACE (e.g, debug, info, warn, etc.)\n        // will be written to stdout.\n        .with_max_level(Level::TRACE)\n        // completes the builder.\n        .finish();\n\n    tracing::subscriber::set_global_default(subscriber)\n        .expect(\"setting default subscriber failed\");\n\n    let number_of_yaks = 3;\n    // this creates a new event, outside of any spans.\n    info!(number_of_yaks, \"preparing to shave yaks\");\n\n    let number_shaved = yak_shave::shave_all(number_of_yaks);\n    info!(\n        all_yaks_shaved = number_shaved == number_of_yaks,\n        \"yak shaving completed.\"\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Tracing Setup with Global Collector\nDESCRIPTION: This example demonstrates how to set up a global tracing collector using tracing-subscriber's fmt module and create basic info events. The collector is installed globally and will capture events from all threads.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::info;\nuse tracing_subscriber;\n\nfn main() {\n    // install global collector configured based on RUST_LOG env var.\n    tracing_subscriber::fmt::init();\n\n    let number_of_yaks = 3;\n    // this creates a new event, outside of any spans.\n    info!(number_of_yaks, \"preparing to shave yaks\");\n\n    let number_shaved = yak_shave::shave_all(number_of_yaks);\n    info!(\n        all_yaks_shaved = number_shaved == number_of_yaks,\n        \"yak shaving completed.\"\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Library Instrumentation with Tracing in Rust\nDESCRIPTION: Demonstrates how to instrument a library using tracing macros and attributes. Shows span creation, event logging, and error handling with structured fields.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{error::Error, io};\nuse tracing::{debug, error, info, span, warn, Level};\n\n#[tracing::instrument]\npub fn shave(yak: usize) -> Result<(), Box<dyn Error + 'static>> {\n    debug!(excitement = \"yay!\", \"hello! I'm gonna shave a yak.\");\n    if yak == 3 {\n        warn!(\"could not locate yak!\");\n        return Err(io::Error::new(io::ErrorKind::Other, \"shaving yak failed!\").into());\n    } else {\n        debug!(\"yak shaved successfully\");\n    }\n    Ok(())\n}\n\npub fn shave_all(yaks: usize) -> usize {\n    let span = span!(Level::TRACE, \"shaving_yaks\", yaks);\n    let _enter = span.enter();\n\n    info!(\"shaving yaks\");\n\n    let mut yaks_shaved = 0;\n    for yak in 1..=yaks {\n        let res = shave(yak);\n        debug!(yak, shaved = res.is_ok());\n\n        if let Err(ref error) = res {\n            error!(yak, error = error.as_ref(), \"failed to shave yak!\");\n        } else {\n            yaks_shaved += 1;\n        }\n        debug!(yaks_shaved);\n    }\n\n    yaks_shaved\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Code Instrumentation with Tracing\nDESCRIPTION: Shows proper instrumentation of async code using Future::instrument and the #[instrument] attribute. Includes example of instrumenting an async network operation.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{info, instrument};\nuse tokio::{io::AsyncWriteExt, net::TcpStream};\nuse std::io;\n\n#[instrument]\nasync fn write(stream: &mut TcpStream) -> io::Result<usize> {\n    let result = stream.write(b\"hello world\\n\").await;\n    info!(\"wrote to stream; success={:?}\", result.is_ok());\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Instrumenting Asynchronous Code with #[instrument] Attribute\nDESCRIPTION: This example demonstrates how to use the #[instrument] attribute to trace asynchronous functions. This is the preferred method for instrumenting async functions as it correctly handles the lifetime of spans in async contexts.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{info, instrument};\nuse tokio::{io::AsyncWriteExt, net::TcpStream};\nuse std::io;\n\n#[instrument]\nasync fn write(stream: &mut TcpStream) -> io::Result<usize> {\n    let result = stream.write(b\"hello world\\n\").await;\n    info!(\"wrote to stream; success={:?}\", result.is_ok());\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Instrumenting Futures with the instrument Combinator\nDESCRIPTION: This snippet shows how to properly instrument futures using the Future::instrument combinator. This approach ensures that spans are correctly managed across async/await points in the future's execution.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::Instrument;\n\nlet my_future = async {\n    // ...\n};\n\nmy_future\n    .instrument(tracing::info_span!(\"my_future\"))\n    .await\n```\n\n----------------------------------------\n\nTITLE: Using the #[instrument] attribute with Rust functions\nDESCRIPTION: Example showing how to use the #[instrument] attribute to automatically trace a function. This creates a span that logs entry and exit of the function along with any parameters.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-attributes/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_attributes::instrument;\n\n#[instrument]\npub fn my_function(my_arg: usize) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using the #[instrument] Attribute for Automatic Span Creation in Rust\nDESCRIPTION: Shows how to use the #[instrument] attribute macro to automatically create a span for a function, reducing boilerplate. The span is named after the function and includes the function argument as a field.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{instrument};\n\n#[instrument]\npub fn my_function(my_arg: usize) {\n    // This event will be recorded inside a span named `my_function` with the\n    // field `my_arg`.\n    tracing::info!(\"inside my_function!\");\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Local Tracing Collector with Custom Configuration\nDESCRIPTION: This example shows how to create a local tracing collector with custom configuration (setting the maximum trace level) and use it within a specific context rather than setting it globally.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{info, Level};\nuse tracing_subscriber;\n\nfn main() {\n    let collector = tracing_subscriber::fmt()\n        // filter spans/events with level TRACE or higher.\n        .with_max_level(Level::TRACE)\n        // build but do not install the subscriber.\n        .finish();\n\n    tracing::collect::with_default(collector, || {\n        info!(\"This will be logged to stdout\");\n    });\n    info!(\"This will _not_ be logged to stdout\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Tracing-Flame Layer in Rust\nDESCRIPTION: Example code showing how to set up a global tracing subscriber with both formatting and flame layers. The flame layer writes to a file that can later be used to generate flamegraphs.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-flame/README.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_flame::FlameLayer;\nuse tracing_subscriber::{prelude::*, fmt};\n\nfn setup_global_subscriber() -> impl Drop {\n    let fmt_layer = fmt::Layer::default();\n\n    let (flame_layer, _guard) = FlameLayer::with_file(\"./tracing.folded\").unwrap();\n\n    tracing_subscriber::registry()\n        .with(fmt_layer)\n        .with(flame_layer)\n        .init();\n    _guard\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up ErrorSubscriber with Tracing Subscriber in Rust\nDESCRIPTION: Shows how to configure the ErrorSubscriber by adding it to the tracing subscriber stack. This setup is required to enable SpanTrace capture within the application.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-error/README.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_error::ErrorSubscriber;\nuse tracing_subscriber::prelude::*;\n\nfn main() {\n    let subscriber = tracing_subscriber::Registry::default()\n        // any number of other subscriber layers may be added before or\n        // after the `ErrorSubscriber`...\n        .with(ErrorSubscriber::default());\n\n    // set the subscriber as the default for the application\n    tracing::subscriber::set_global_default(subscriber);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Rolling File Appender in Rust\nDESCRIPTION: This code demonstrates how to create an hourly rotating file appender using tracing-appender. It writes logs to a specified directory with a given prefix.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-appender/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main(){\n    let file_appender = tracing_appender::rolling::hourly(\"/some/directory\", \"prefix.log\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Writer for Non-Blocking Tracing in Rust\nDESCRIPTION: This snippet shows how to create a custom writer implementing std::io::Write and use it with tracing-appender's non-blocking writer. It also demonstrates how to initialize a tracing subscriber with this writer.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-appender/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::Error;\n\nstruct TestWriter;\n\nimpl std::io::Write for TestWriter {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let buf_len = buf.len();\n    \n        println!(\"{:?}\", buf);\n        Ok(buf_len)\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        Ok(())\n    }\n}\n\nfn main() {\n    let (non_blocking, _guard) = tracing_appender::non_blocking(TestWriter);\n    tracing_subscriber::fmt().with_writer(non_blocking).init();\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Non-Blocking Writer with Rolling File Appender in Rust\nDESCRIPTION: This code shows how to create a non-blocking rolling file appender and use it to initialize a tracing subscriber. It combines the rolling file appender with the non-blocking writer functionality.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-appender/README.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let file_appender = tracing_appender::rolling::hourly(\"/some/directory\", \"prefix.log\");\n    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);\n   tracing_subscriber::fmt()\n       .with_writer(non_blocking)\n       .init();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Error Type with SpanTrace in Rust\nDESCRIPTION: Demonstrates how to create a custom error type that captures the current tracing span context using SpanTrace. The error includes methods for constructing a new error and implementations of the Display and Error traits.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-error/README.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{fmt, error::Error};\nuse tracing_error::SpanTrace;\n\n#[derive(Debug)]\npub struct MyError {\n    context: SpanTrace,\n    // ...\n}\n\nimpl fmt::Display for MyError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // ... format other parts of the error ...\n\n        self.context.fmt(f)?;\n\n        // ... format other error context information, cause chain, etc ...\n        # Ok(())\n    }\n}\n\nimpl Error for MyError {}\n\nimpl MyError {\n    pub fn new() -> Self {\n        Self {\n            context: SpanTrace::capture(),\n            // ... other error information ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using InstrumentResult Trait for Error Handling in Rust\nDESCRIPTION: Shows how to use the InstrumentResult trait's in_current_span() method to automatically wrap errors with SpanTrace context. This is a convenient way to capture the current span context with minimal code changes.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-error/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_error::prelude::*;\n\nstd::fs::read_to_string(\"myfile.txt\").in_current_span()?;\n```\n\n----------------------------------------\n\nTITLE: Creating and Entering a Span in Rust\nDESCRIPTION: Demonstrates how to construct a new span named \"my span\" using the span! macro, enter it using in_scope, and perform operations within its context. The span is automatically closed when dropped.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{span, Level};\n\n// Construct a new span named \"my span\".\nlet mut span = span!(Level::INFO, \"my span\");\nspan.in_scope(|| {\n    // Any trace events in this closure or code called by it will occur within\n    // the span.\n});\n// Dropping the span will close it, indicating that it has ended.\n```\n\n----------------------------------------\n\nTITLE: Creating an Event in Rust using tracing\nDESCRIPTION: Illustrates how to create an instantaneous event using the event! macro from the tracing crate. Events represent points in time and cannot be entered like spans.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{event, Level};\n\nevent!(Level::INFO, \"something has happened!\");\n```\n\n----------------------------------------\n\nTITLE: Complex Tracing Mock Span and Event Testing\nDESCRIPTION: Advanced example showing how to test multiple tracing operations including span creation, entry/exit, and events with multiple fields.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-mock/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::collect::with_default;\nuse tracing_mock::{collector, expect};\n\n#[tracing::instrument]\nfn yak_shaving(number_of_yaks: u32) {\n    tracing::info!(number_of_yaks, \"preparing to shave yaks\");\n\n    let number_shaved = number_of_yaks; // shave_all\n    tracing::info!(\n        all_yaks_shaved = number_shaved == number_of_yaks,\n        \"yak shaving completed.\"\n    );\n}\n\nlet yak_count: u32 = 3;\nlet span = expect::span().named(\"yak_shaving\");\n\nlet (collector, handle) = collector::mock()\n    .new_span(\n        span.clone()\n            .with_fields(expect::field(\"number_of_yaks\").with_value(&yak_count).only()),\n    )\n    .enter(span.clone())\n    .event(\n        expect::event().with_fields(\n            expect::field(\"number_of_yaks\")\n                .with_value(&yak_count)\n                .and(expect::msg(\"preparing to shave yaks\"))\n                .only(),\n        ),\n    )\n    .event(\n        expect::event().with_fields(\n            expect::field(\"all_yaks_shaved\")\n                .with_value(&true)\n                .and(expect::msg(\"yak shaving completed.\"))\n                .only(),\n        ),\n    )\n    .exit(span.clone())\n    .only()\n    .run_with_handle();\n\nwith_default(collector, || {\n    yak_shaving(yak_count);\n});\n\nhandle.assert_finished();\n```\n\n----------------------------------------\n\nTITLE: Instrument Attribute Usage in Rust\nDESCRIPTION: Example of using the #[instrument] attribute on async functions, supporting arbitrary expressions as fields and providing warning for unrecognized input\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[instrument(err)]\nasync fn my_function() -> Result<(), Error> {\n    // Function body\n}\n```\n\n----------------------------------------\n\nTITLE: Level Filter Implementation in Rust\nDESCRIPTION: Example showing the LevelFilter functionality for controlling trace filtering at compile and runtime\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nLevelFilter::current() // Returns highest level any subscriber will enable\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Subscriber for Tracing\nDESCRIPTION: Example implementation of a Subscriber that serializes tracing data to JSON format using serde\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-serde/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct JsonSubscriber {\n    next_id: AtomicUsize, // you need to assign span IDs, so you need a counter\n}\n\nimpl Subscriber for JsonSubscriber {\n\n    fn new_span(&self, attrs: &Attributes) -> Id {\n        let id = self.next_id.fetch_add(1, Ordering::Relaxed);\n        let id = Id::from_u64(id as u64);\n        let json = json!({\n        \"new_span\": {\n            \"attributes\": attrs.as_serde(),\n            \"id\": id.as_serde(),\n        }});\n        println!(\"{}\", json);\n        id\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Non-Blocking Writer with stdout in Rust\nDESCRIPTION: This example demonstrates how to create a non-blocking writer using stdout and initialize a tracing subscriber with it.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-appender/README.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    let (non_blocking, _guard) = tracing_appender::non_blocking(std::io::stdout());\n    tracing_subscriber::fmt()\n        .with_writer(non_blocking)\n        .init();\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Flamegraph Using Inferno CLI\nDESCRIPTION: Console commands demonstrating how to use inferno-flamegraph to generate SVG visualizations from the folded stack trace file.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-flame/README.md#2025-04-16_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n# flamegraph\ncat tracing.folded | inferno-flamegraph > tracing-flamegraph.svg\n\n# flamechart\ncat tracing.folded | inferno-flamegraph --flamechart > tracing-flamechart.svg\n```\n\n----------------------------------------\n\nTITLE: Printing Errors with Specialized SpanTrace Handling in Rust\nDESCRIPTION: Demonstrates how to extract and print SpanTrace information from errors using the ExtractSpanTrace trait. This approach allows for specialized handling of SpanTrace objects when displaying errors.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-error/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error::Error;\nuse tracing_error::ExtractSpanTrace as _;\n\nfn print_extracted_spantraces(error: &(dyn Error + 'static)) {\n    let mut error = Some(error);\n    let mut ind = 0;\n\n    eprintln!(\"Error:\");\n\n    while let Some(err) = error {\n        if let Some(spantrace) = err.span_trace() {\n            eprintln!(\"found a spantrace:\\n{}\", spantrace);\n        } else {\n            eprintln!(\"{:>4}: {}\", ind, err);\n        }\n\n        error = err.source();\n        ind += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Error Chains with Implicit SpanTrace Display in Rust\nDESCRIPTION: Shows how to print the entire error chain including SpanTrace information without special handling. This works because TracedError implements Display to show the SpanTrace content.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-error/README.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse std::error::Error;\n\nfn print_naive_spantraces(error: &(dyn Error + 'static)) {\n    let mut error = Some(error);\n    let mut ind = 0;\n\n    eprintln!(\"Error:\");\n\n    while let Some(err) = error {\n        eprintln!(\"{:>4}: {}\", ind, err);\n        error = err.source();\n        ind += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Tracing Mock Event Testing\nDESCRIPTION: Simple example demonstrating how to test that a tracing event contains an expected message using tracing-mock.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-mock/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::collect::with_default;\nuse tracing_mock::{collector, expect};\n\nfn yak_shaving() {\n    tracing::info!(\"preparing to shave yaks\");\n}\n\nlet (collector, handle) = collector::mock()\n    .event(expect::event().with_fields(expect::msg(\"preparing to shave yaks\")))\n    .only()\n    .run_with_handle();\n\nwith_default(collector, || {\n    yak_shaving();\n});\n\nhandle.assert_finished();\n```\n\n----------------------------------------\n\nTITLE: Local Tracing Subscriber Override in Rust\nDESCRIPTION: Shows how to locally override the default subscriber within a specific context using with_default(). This allows for scoped trace collection.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::{info, Level};\nuse tracing_subscriber::FmtSubscriber;\n\nfn main() {\n    let subscriber = tracing_subscriber::FmtSubscriber::builder()\n        // all spans/events with a level higher than TRACE (e.g, debug, info, warn, etc.)\n        // will be written to stdout.\n        .with_max_level(Level::TRACE)\n        // builds the subscriber.\n        .finish();\n\n    tracing::subscriber::with_default(subscriber, || {\n        info!(\"This will be logged to stdout\");\n    });\n    info!(\"This will _not_ be logged to stdout\");\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Tracing Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows how to add tracing and tracing-subscriber dependencies to a Rust project's Cargo.toml file. These dependencies are required to use the tracing framework in an application.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n----------------------------------------\n\nTITLE: Library Tracing Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows the minimal dependency required for a library that uses tracing. Libraries should only depend on the tracing crate itself and not set global collectors.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/README.md#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntracing = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Implementing LevelFilter::current() in Rust\nDESCRIPTION: Added LevelFilter type and LevelFilter::current() method in version 0.1.12 for returning the highest level that any subscriber will enable.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl LevelFilter {\n    pub fn current() -> Self {\n        // Implementation details not provided in the changelog\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Subscriber::max_level_hint Trait Method in Rust\nDESCRIPTION: Added an optional trait method Subscriber::max_level_hint in version 0.1.12 for setting the value returned by LevelFilter::current().\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Subscriber {\n    fn max_level_hint(&self) -> Option<LevelFilter> {\n        None\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Option<Level> to LevelFilter in Rust\nDESCRIPTION: Added a conversion from Option<Level> to LevelFilter in version 0.1.16 to resolve a regression.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl From<Option<Level>> for LevelFilter {\n    fn from(level: Option<Level>) -> Self {\n        // Implementation details not provided in the changelog\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy for Level and LevelFilter in Rust\nDESCRIPTION: Added Copy trait implementations for Level and LevelFilter types in version 0.1.17.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl Copy for Level {}\nimpl Copy for LevelFilter {}\n```\n\n----------------------------------------\n\nTITLE: Converting between span::Id and NonZeroU64 in Rust\nDESCRIPTION: Added functions to convert between span::Id and NonZeroU64 in version 0.1.11.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nimpl span::Id {\n    pub fn from_non_zero_u64(id: NonZeroU64) -> Self {\n        // Implementation details not provided in the changelog\n    }\n\n    pub fn into_non_zero_u64(self) -> NonZeroU64 {\n        // Implementation details not provided in the changelog\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default for Dispatch in Rust\nDESCRIPTION: Added a Default implementation for the Dispatch type in version 0.1.8.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl Default for Dispatch {\n    fn default() -> Self {\n        // Implementation details not provided in the changelog\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Display and FromStr for Level in Rust\nDESCRIPTION: Added std::fmt::Display and std::str::FromStr implementations for the Level type in version 0.1.3.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/CHANGELOG.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl std::fmt::Display for Level {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        // Implementation details not provided in the changelog\n    }\n}\n\nimpl std::str::FromStr for Level {\n    type Err = ParseLevelError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        // Implementation details not provided in the changelog\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Wrapping Example in Rust\nDESCRIPTION: Example showing Wrapping and NonZero number implementations for field::Value trait mentioned in version 0.1.13\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfield::Value implementations for `Wrapping` and `NonZero*` numbers\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Timeout Usage in Rust Documentation Test\nDESCRIPTION: This code snippet shows how to use the `timeout` function from Tokio in a documentation test. It demonstrates wrapping a future with a Timeout set to expire in 10 milliseconds.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// // import the `timeout` function, usually this is done\n/// // with `use tokio::prelude::*`\n/// use tokio::prelude::FutureExt;\n/// use futures::Stream;\n/// use futures::sync::mpsc;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = mpsc::unbounded();\n/// # tx.unbounded_send(()).unwrap();\n/// # drop(tx);\n///\n/// let process = rx.for_each(|item| {\n///     // do something with `item`\n/// # drop(item);\n/// # Ok(())\n/// });\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// process.timeout(Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\n----------------------------------------\n\nTITLE: Using Timeout::new in Rust Documentation Test\nDESCRIPTION: This code snippet demonstrates how to use the `Timeout::new` function in a documentation test. It shows wrapping a future with a Timeout set to expire in 10 milliseconds using the explicit constructor.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// use tokio::timer::Timeout;\n/// use futures::Future;\n/// use futures::sync::oneshot;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// Timeout::new(rx, Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\n----------------------------------------\n\nTITLE: Building Tracing Documentation with Nightly Features\nDESCRIPTION: This bash command demonstrates how to build Tracing's documentation using nightly-only RustDoc features. It enables `doc(cfg)` and other features by passing the `--cfg docsrs` flag to RustDoc.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nRUSTDOCFLAGS=\"--cfg docsrs\" cargo +nightly doc --no-deps\n```\n\n----------------------------------------\n\nTITLE: Example Commit Message Format in Tokio Project\nDESCRIPTION: A sample commit message demonstrating the proper format for Tokio project commits, including a concise subject line, detailed body with proper wrapping, and references to related issues.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_3\n\nLANGUAGE: txt\nCODE:\n```\nsubcrate: explain the commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message can be several paragraphs, and\nplease do proper word-wrap and keep columns shorter than about\n72 characters or so. That way, `git log` will show things\nnicely even when it is indented.\n\nFixes: #1337\nRefs: #453, #154\n```\n\n----------------------------------------\n\nTITLE: Verifying Crate Readiness for Publishing in Tracing Project\nDESCRIPTION: Command to verify that a crate is ready for publishing by performing a dry run. This helps ensure all dependencies are properly configured before actual publication.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbin/publish --dry-run <CRATE NAME> <CRATE VERSION>\n```\n\n----------------------------------------\n\nTITLE: Publishing a Tracing Crate to crates.io\nDESCRIPTION: Command to release a crate to crates.io after all preparations have been completed. This command also creates a Git tag with the changelog entry for the release.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/CONTRIBUTING.md#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbin/publish <NAME OF CRATE> <VERSION>\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for Tracing Mock Tests in Cargo.toml\nDESCRIPTION: Example Cargo.toml configuration showing how to set up dependencies for using tracing-mock in test code, including git dependencies and crates.io patches.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-mock/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nlib-under-test = \"1.0\" # depends on `tracing`\n\n[dev-dependencies]\ntracing-mock = { git = \"https://github.com/tokio-rs/tracing\", branch = \"v0.1.x\", version = \"0.1\" }\ntracing = { git = \"https://github.com/tokio-rs/tracing\", branch = \"v0.1.x\", version = \"0.1\" }\n\n[patch.crates-io]\ntracing = { git = \"https://github.com/tokio-rs/tracing\", branch = \"v0.1.x\" }\ntracing-core = { git = \"https://github.com/tokio-rs/tracing\", branch = \"v0.1.x\" }\n```\n\n----------------------------------------\n\nTITLE: Installing Tracing-Serde Dependencies with Cargo\nDESCRIPTION: Cargo.toml configuration for adding tracing and tracing-serde dependencies to a Rust project\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-serde/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntracing = \"0.1\"\ntracing-serde = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Importing Tracing-Serde Functionality\nDESCRIPTION: Rust code showing how to import the AsSerde trait from tracing-serde\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-serde/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing_serde::AsSerde;\n```\n\n----------------------------------------\n\nTITLE: Installing tracing-attributes with Cargo\nDESCRIPTION: How to add tracing-attributes as a dependency in your Cargo.toml file.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-attributes/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntracing-attributes = \"0.1.11\"\n```\n\n----------------------------------------\n\nTITLE: Tracing Library Version History in Markdown\nDESCRIPTION: Complete changelog entries documenting the evolution of the tracing library, including bug fixes, feature additions, and breaking changes across multiple versions from 0.1.0 to 0.2.4.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-futures/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# 0.2.4 (April 21, 2020)\n\n### Fixed\n\n- docs.rs build failures (#618)\n- Spelling in documentation skins -> sinks (#643)\n\n# 0.2.3 (Feb 26, 2020)\n\n### Added\n\n- `WithDispatch::inner` and `WithDispatch::inner_mut` methods to allow borrowing\n  the wrapped type (#589)\n- `WithDispatch::with_dispatch` method, to propagate the subscriber to another\n  type (#589)\n- `inner_pin_ref` and `inner_pin_mut` methods to `Instrumented` and\n  `WithDispatch` to project to the inner future when pinned (#590)\n\n# 0.2.2 (Feb 14, 2020)\n\n### Added\n\n- Support for `futures` 0.3 `Stream`s and `Sink`s (#544)\n\n### Fixed\n\n- Compilation errors when using the `futures-03` feature (#576)\n\nThanks to @obergner and @najamelan for their contributions to this release!\n\n# 0.2.1 (Jan 15, 2020)\n\n### Added\n\n- API documentation now shows which features are required by feature-flagged items (#523)\n- `no_std` support (#498)\n\n# 0.2.0 (Dec 3, 2019)\n\n### Changed\n\n- **Breaking Change**: the default `Future` implementation comes from the `std-future` feature.\n  Compatibility with futures v0.1 is available via the `futures-01` feature.\n\n# 0.1.1 (Oct 25, 2019)\n\n### Added\n\n- `Instrumented::inner` and `inner_mut` methods that expose access to the\n  instrumented future (#386)\n\n# 0.1.0 (Oct 8, 2019)\n\n- Initial release\n```\n\n----------------------------------------\n\nTITLE: Configuring tracing-core Dependency in Cargo.toml for no_std\nDESCRIPTION: Shows how to configure the tracing-core dependency in a Cargo.toml file for no_std environments, disabling the default 'std' feature.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-core/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntracing-core = { version = \"0.1.17\", default-features = false }\n```\n\n----------------------------------------\n\nTITLE: Adding tracing-appender dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to add the tracing-appender crate as a dependency in a Rust project's Cargo.toml file.\nSOURCE: https://github.com/tokio-rs/tracing/blob/master/tracing-appender/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\ntracing-appender = \"0.2\"\n```"
  }
]