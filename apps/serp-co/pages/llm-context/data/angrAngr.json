[
  {
    "owner": "angr",
    "repo": "angr",
    "content": "TITLE: Automatic Exploit Generation using angr - Python\nDESCRIPTION: Implements a simple Automatic Exploit Generation (AEG) workflow with angr to track global symbolic data and automatically generate exploits for CTF binaries. This script is intended to guide users through the core workflow of AEG using angr, tracking symbolic data across global variables. Dependencies include angr and a supported Python version. Inputs are vulnerable binaries and the output is a generated exploit or proof-of-concept input.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n# Script author: Nick Stephens (github: @NickStephens)\n# Concepts presented: automatic exploit generation, global symbolic data tracking\n```\n\n----------------------------------------\n\nTITLE: Guided Symbolic Exploration with CFG using angr - Python\nDESCRIPTION: Showcases the use of angr for symbolic exploration guided by Control Flow Graph (CFG) analysis, designed to automatically find paths leading to exploit conditions like memcpy-based buffer overflows in CTF binaries. It leverages angr's static analysis features to guide concolic execution for valid input generation and vulnerability detection. Key parameters include target binaries with stack overflows and command-line arguments. Outputs include valid input sets leading to exploitation. Requires angr and Python 3.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n# Script author: nsr (nsr@tasteless.eu)\n# Script runtime: ~15 seconds per binary\n# Concepts presented: symbolic exploration guided by static analysis, using the CFG\n```\n\n----------------------------------------\n\nTITLE: Using Symbolic Execution with angr to Extract a Flag\nDESCRIPTION: A basic example demonstrating how to use angr to extract a flag from a CTF challenge binary. It creates a project, hooks a specific memory address to print the flag, and then executes the binary.\nSOURCE: https://github.com/angr/angr/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport angr\n\nproject = angr.Project(\"angr-doc/examples/defcamp_r100/r100\", auto_load_libs=False)\n\n@project.hook(0x400844)\ndef print_flag(state):\n    print(\"FLAG SHOULD BE:\", state.posix.dumps(0))\n    project.terminate_execution()\n\nproject.execute()\n```\n\n----------------------------------------\n\nTITLE: Solving a Crackme with angr's Exploration Feature\nDESCRIPTION: This example demonstrates how to use the explore() method to find a state that meets a specific condition - in this case finding the correct password in a crackme challenge that produces a 'Congrats' message.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/pathgroups.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a')\n>>> simgr = proj.factory.simgr()\n>>> simgr.explore(find=lambda s: b\"Congrats\" in s.posix.dumps(1))\n<SimulationManager with 1 active, 1 found>\n>>> s = simgr.found[0]\n>>> print(s.posix.dumps(1))\nEnter password: Congrats!\n\n>>> flag = s.posix.dumps(0)\n>>> print(flag)\ng00dJ0B!\n```\n\n----------------------------------------\n\nTITLE: Performing Symbolic Execution with angr in Python\nDESCRIPTION: A Python script using the angr framework to perform symbolic execution on the previously defined C functions. It finds valid inputs that lead to the execution of the helloWorld function.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/symbolic.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport angr, claripy\n# Load the binary\nproject = angr.Project('./3func', auto_load_libs=False)\n\n# Define the address of the firstCall function\nfirstCall_addr = project.loader.main_object.get_symbol(\"firstCall\")\n\n# Define the address of the helloWorld function\nhelloWorld_addr = project.loader.main_object.get_symbol(\"helloWorld\")\n# Create a symbolic variable for the firstCall arg\ninput_arg = claripy.BVS('input_arg', 32)\n\n# Create a blank state at the address of the firstCall function\ninit_state = project.factory.blank_state(addr=firstCall_addr.rebased_addr)\n\n# Assuming the calling convention passes the argument in a register\n# (e.g., x86 uses edi for the argument)\ninit_state.regs.edi = input_arg\n\n# Create a simulation manager\nsimgr = project.factory.simulation_manager(init_state)\n\n# Explore the binary, looking for the address of helloWorld\nsimgr.explore(find=helloWorld_addr.rebased_addr)\n\n# Check if we found a state that reached the target\nif simgr.found:\n    input_value = simgr.found[0].solver.eval(input_arg)\n    print(f\"Value of input_arg that reaches HelloWorld: {input_value}\")\n\t# Get the constraints for reaching the helloWorld function\n\tconstraints = simgr.found[0].solver.constraints\n\t# Create a solver with the constraints\n\tsolver = claripy.Solver()\n\tsolver.add(constraints)\n\tmin_val = solver.min(input_arg)\n\tmax_val = solver.max(input_arg)\n\tprint(f\"Function arg: min = {min_val}, max = {max_val}\")\nelse:\n    print(\"Did not find a state that reaches HelloWorld.\")\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints and Solving for Values\nDESCRIPTION: Shows how to add constraints to a state and use the solver to find concrete values that satisfy those constraints.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> state.solver.add(x > y)\n>>> state.solver.add(y > 2)\n>>> state.solver.add(10 > x)\n>>> state.solver.eval(x)\n4\n```\n\n----------------------------------------\n\nTITLE: FlareOn 2015 Challenge Solution with angr\nDESCRIPTION: This example demonstrates using angr for Windows binary analysis. It shows how to represent desired encoded output as constraints for the SAT solver to determine the correct input for a network traffic decryption challenge.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nScript author: Adrian Tang (github: @tangabc)\nScript runtime: 2 mins 10 secs\nConcepts presented: Windows support\n```\n\n----------------------------------------\n\nTITLE: Reversing little_engine Challenge with angr\nDESCRIPTION: This code snippet presents a simple reversing example using angr. It demonstrates stdin constraining and concrete optimization with Unicorn Engine. The challenge involves finding input that satisfies specific conditions in a binary.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nScript author: Michael Reeves (github: @mastermjr)\nScript runtime: 3 min 26 seconds (206 seconds)\nConcepts presented:\nstdin constraining, concrete optimization with Unicorn\n```\n\n----------------------------------------\n\nTITLE: Evaluating Symbolic Input Constraints in angr (Python)\nDESCRIPTION: Demonstrates how to retrieve symbolic data read from standard input and evaluate constraints for different execution paths. It uses `state.posix.stdin.load` to get the symbolic input buffer and `state.solver.eval` to find concrete byte values for the input that satisfy the constraints leading to `state1` (backdoor password) and `state2` (any other password).\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> input_data = state1.posix.stdin.load(0, state1.posix.stdin.size)\n\n>>> state1.solver.eval(input_data, cast_to=bytes)\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00\\x00\\x00'\n\n>>> state2.solver.eval(input_data, cast_to=bytes)\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x00\\x80N\\x00\\x00 \\x00\\x00\\x00\\x00'\n```\n\n----------------------------------------\n\nTITLE: Using Claripy Solvers with Constraints\nDESCRIPTION: Demonstrates creating a solver, adding constraints on symbolic variables, and evaluating expressions to get concrete values that satisfy the constraints.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/claripy.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# create the solver and an expression\n>>> s = claripy.Solver()\n>>> x = claripy.BVS('x', 8)\n\n# now let's add a constraint on x\n>>> s.add(claripy.ULT(x, 5))\n\n>>> assert sorted(s.eval(x, 10)) == [0, 1, 2, 3, 4]\n>>> assert s.max(x) == 4\n>>> assert s.min(x) == 0\n\n# we can also get the values of complex expressions\n>>> y = claripy.BVV(65, 8)\n>>> z = claripy.If(x == 1, x, y)\n>>> assert sorted(s.eval(z, 10)) == [1, 65]\n\n# and, of course, we can add constraints on complex expressions\n>>> s.add(z % 5 != 0)\n>>> assert s.eval(z, 10) == (1,)\n>>> assert s.eval(x, 10) == (1,) # interestingly enough, since z can't be y, x can only be 1!\n```\n\n----------------------------------------\n\nTITLE: Creating Bitvectors in angr\nDESCRIPTION: This snippet demonstrates how to create bitvectors with concrete values of different sizes and how to perform arithmetic operations with them.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr, monkeyhex\n>>> proj = angr.Project('/bin/true')\n>>> state = proj.factory.entry_state()\n\n# 64-bit bitvectors with concrete values 1 and 100\n>>> one = claripy.BVV(1, 64)\n>>> one\n <BV64 0x1>\n>>> one_hundred =claripy.BVV(100, 64)\n>>> one_hundred\n <BV64 0x64>\n\n# create a 27-bit bitvector with concrete value 9\n>>> weird_nine = claripy.BVV(9, 27)\n>>> weird_nine\n<BV27 0x9>\n```\n\n----------------------------------------\n\nTITLE: Guided Symbolic Tracing for 0ctf trace Challenge\nDESCRIPTION: This example demonstrates guided symbolic tracing in angr. It solves a challenge where only the execution trace is known by directing angr through the correct branches based on the trace data, allowing it to discover the flag.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nScript author: WGH (wgh@bushwhackers.ru)\nScript runtime: 1 min 50 secs (CPython 2.7.10), 1 min 12 secs (PyPy 4.0.1)\nConcepts presented: guided symbolic tracing\n```\n\n----------------------------------------\n\nTITLE: Defining C Functions for angr Analysis\nDESCRIPTION: Two C functions: helloWorld prints a message, and firstCall conditionally calls helloWorld based on a numeric input. These functions will be analyzed using angr for symbolic execution.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/symbolic.rst#2025-04-23_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid helloWorld() {\n    printf(\"Hello, World!\\n\");\n}\n\n\nvoid firstCall(uint32_t num) {\n    if (num > 50 && num <100)\n        HelloWorld();\n}\n```\n\n----------------------------------------\n\nTITLE: Importing angr and Creating a Project\nDESCRIPTION: Shows how to import the angr framework and load a binary into a project. A project is the control base in angr from which analyses and simulations are dispatched.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n>>> proj = angr.Project('/bin/true')\n```\n\n----------------------------------------\n\nTITLE: Automated Reverse Engineering for DEFCON Quals 2017\nDESCRIPTION: This snippet references angr usage for automated reverse engineering in the DEFCON Quals 2017 Crackme2000 challenge category. It demonstrates automated analysis capabilities for solving reversing challenges.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nScript author: Shellphish\nScript runtime: varies, but on the order of seconds\nConcepts presented: automated reverse engineering\n```\n\n----------------------------------------\n\nTITLE: Generating and Inspecting a Fast CFG with angr (Python)\nDESCRIPTION: This snippet illustrates loading a binary (`/bin/true`) into an angr project, specifically disabling the auto-loading of shared libraries (`auto_load_libs=False`), which is often preferred for static analysis. It then generates a Fast Control Flow Graph (CFG) using `proj.analyses.CFGFast()`. Finally, it demonstrates basic interaction with the CFG result, accessing the underlying networkx DiGraph (`cfg.graph`), checking the total number of nodes, retrieving the CFGNode corresponding to the program's entry point, and finding the number of its successors. Requires the angr library.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Originally, when we loaded this binary it also loaded all its dependencies into the same virtual address  space\n# This is undesirable for most analysis.\n>>> proj = angr.Project('/bin/true', auto_load_libs=False)\n>>> cfg = proj.analyses.CFGFast()\n<CFGFast Analysis Result at 0x2d85130>\n\n# cfg.graph is a networkx DiGraph full of CFGNode instances\n# You should go look up the networkx APIs to learn how to use this!\n>>> cfg.graph\n<networkx.classes.digraph.DiGraph at 0x2da43a0>\n>>> len(cfg.graph.nodes())\n951\n\n# To get the CFGNode for a given address, use cfg.get_any_node\n>>> entry_node = cfg.get_any_node(proj.entry)\n>>> len(list(cfg.graph.successors(entry_node)))\n2\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Symbolic Variables\nDESCRIPTION: Demonstrates how to create symbolic bitvector variables and perform arithmetic operations with them, resulting in AST (Abstract Syntax Tree) expressions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Create a bitvector symbol named \"x\" of length 64 bits\n>>> x = claripy.BVS(\"x\", 64)\n>>> x\n<BV64 x_9_64>\n>>> y = claripy.BVS(\"y\", 64)\n>>> y\n<BV64 y_10_64>\n\n>>> x + one\n<BV64 x_9_64 + 0x1>\n\n>>> (x + one) / 2\n<BV64 (x_9_64 + 0x1) / 0x2>\n\n>>> x - y\n<BV64 x_9_64 - y_10_64>\n```\n\n----------------------------------------\n\nTITLE: Finding Input for a Given Output\nDESCRIPTION: Demonstrates how to solve for an input that produces a specific output after a series of operations.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# get a fresh state without constraints\n>>> state = proj.factory.entry_state()\n>>> input = claripy.BVS('input', 64)\n>>> operation = (((input + 4) * 3) >> 1) + input\n>>> output = 200\n>>> state.solver.add(operation == output)\n>>> state.solver.eval(input)\n0x3333333333333381\n```\n\n----------------------------------------\n\nTITLE: Using Simulation Managers for Execution\nDESCRIPTION: Demonstrates creating and using a simulation manager to execute code. The simulation manager is the primary interface in angr for performing execution with states and manages collections of states in different \"stashes\".\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> simgr = proj.factory.simulation_manager(state)\n<SimulationManager with 1 active>\n>>> simgr.active\n[<SimState @ 0x401670>]\n\n>>> simgr.step()\n```\n\n----------------------------------------\n\nTITLE: Setting Breakpoints in angr\nDESCRIPTION: Demonstrates how to set breakpoints in angr, including before and after memory writes, with custom callback functions or interactive debugging.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/simulation.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n>>> b = angr.Project('examples/fauxware/fauxware')\n\n# get our state\n>>> s = b.factory.entry_state()\n\n# add a breakpoint. This breakpoint will drop into ipdb right before a memory write happens.\n>>> s.inspect.b('mem_write')\n\n# on the other hand, we can have a breakpoint trigger right *after* a memory write happens.\n# we can also have a callback function run instead of opening ipdb.\n>>> def debug_func(state):\n...     print(\"State %s is about to do a memory write!\")\n\n>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func)\n\n# or, you can have it drop you in an embedded IPython!\n>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=angr.BP_IPYTHON)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple C Function for Symbolic Execution\nDESCRIPTION: A C function that returns different strings based on a numeric input. This serves as an example to illustrate how symbolic execution explores multiple execution paths.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/symbolic.rst#2025-04-23_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nconst char* check_value(int x) {\n    if (x > 10) {\n        return \"Greater\";\n    } else {\n        return \"Lesser or Equal\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Working with Claripy ASTs in Python\nDESCRIPTION: Examples of creating different types of ASTs (bitvectors, booleans) and performing operations on them like getting size, reversing values, and checking depth.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/claripy.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import claripy\n\n>>> bv = claripy.BVV(0x41424344, 32)\n\n# Size - you can get the size of an AST with .size()\n>>> assert bv.size() == 32\n\n# Reversing - .reversed is the reversed version of the BVV\n>>> assert bv.reversed is claripy.BVV(0x44434241, 32)\n>>> assert bv.reversed.reversed is bv\n\n# Depth - you can get the depth of the AST\n>>> print(bv.depth)\n>>> assert bv.depth == 1\n>>> x = claripy.BVS('x', 32)\n>>> assert (x+bv).depth == 2\n>>> assert ((x+bv)/10).depth == 3\n```\n\n----------------------------------------\n\nTITLE: Solving CSAW Wyvern Reversing Challenge with angr\nDESCRIPTION: This snippet shows a solution for a CSAW CTF 2015 Quals reversing challenge. It demonstrates stdin constraining and concrete optimization with Unicorn Engine to solve the challenge with minimal user input.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nScript author: Audrey Dutcher (github: @rhelmot)\nScript runtime: 15 mins\nConcepts presented: stdin constraining, concrete optimization with Unicorn\n```\n\n----------------------------------------\n\nTITLE: Creating and Working with SimState\nDESCRIPTION: Demonstrates creating a SimState object which represents a simulated program state, and accessing registers and memory. SimState contains all \"live data\" that can be changed during execution.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> state = proj.factory.entry_state()\n<SimState @ 0x401670>\n\n>>> state.regs.rip        # get the current instruction pointer\n<BV64 0x401670>\n>>> state.regs.rax\n<BV64 0x1c>\n>>> state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int\n<BV32 0x8949ed31>\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations with Bitvectors\nDESCRIPTION: Shows how to perform arithmetic operations on bitvectors, including addition, subtraction, and dealing with different bit lengths through extension methods.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> one + one_hundred\n<BV64 0x65>\n\n# You can provide normal Python integers and they will be coerced to the\nappropriate type: >>> one_hundred + 0x100 <BV64 0x164>\n\n# The semantics of normal wrapping arithmetic apply\n>>> one_hundred - one*200\n<BV64 0xffffffffffffff9c>\n\n>>> weird_nine.zero_extend(64 - 27)\n<BV64 0x9>\n>>> one + weird_nine.zero_extend(64 - 27)\n<BV64 0xa>\n```\n\n----------------------------------------\n\nTITLE: Variable Scope Resolution using angr - Python\nDESCRIPTION: This snippet illustrates resolving variables in nested or shadowed scopes using angr and checking their values at specific execution points. It uses the simulation manager to reach code locations related to variable redefinitions and demonstrates access to values scoped to their most recent definition. Requires angr and a loaded project with debug symbols; inputs are address offsets and stash movement operations.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/debug_var.rst#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Find the addr before executing printf(\"%d\\n\", a) (line 12)\n# with the same method to find addr\n>>> addr = 0x4011e0\n# Explore until find state\n>>> simgr.move(from_stash='found', to_stash='active')\n<SimulationManager with 1 active>\n>>> simgr.explore(find = addr)\n<SimulationManager with 1 found>\n>>> state = simgr.found[0]\n# Resolve 'a' in state before execute line 10\n>>> state.dvars['a'].mem\n<int (32 bits) <BV32 0x18> at 0x7fffffffffeff34>\n```\n\n----------------------------------------\n\nTITLE: Storing and Loading Memory in angr (Python)\nDESCRIPTION: Demonstrates storing a 128-bit value to memory and reading a 48-bit value using angr's state.memory API. Depends on the angr and claripy frameworks for symbolic execution. Key parameters include the memory address, the value to store, and the number of bytes to load, with default big-endian order; results are claripy BV expressions. Input: address, value, size; Output: loaded value.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> s.memory.store(0x4000, claripy.BVV(0x0123456789abcdef0123456789abcdef, 128))\n>>> s.memory.load(0x4004, 6) # load-size is in bytes\n<BV48 0x89abcdef0123>\n```\n\n----------------------------------------\n\nTITLE: Accessing Registers and Memory in angr SimState (Python)\nDESCRIPTION: Demonstrates basic operations on an angr SimState object. It shows how to initialize a state from a project, copy register values (rsp to rbp), store register values to memory (rdx to 0x1000), dereference a register containing an address, and perform arithmetic involving registers and memory.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr, claripy\n>>> proj = angr.Project('/bin/true')\n>>> state = proj.factory.entry_state()\n\n# copy rsp to rbp\n>>> state.regs.rbp = state.regs.rsp\n\n# store rdx to memory at 0x1000\n>>> state.mem[0x1000].uint64_t = state.regs.rdx\n\n# dereference rbp\n>>> state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved\n\n# add rax, qword ptr [rsp + 8]\n>>> state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved\n```\n\n----------------------------------------\n\nTITLE: Binary Analysis Implementation in Python\nDESCRIPTION: Core function that performs binary analysis using angr. Generates CFG and extracts decompiled function data with specific configuration options.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef analyze_binary(binary_path):\n    \"\"\"\n    Run the binary through CFG generation and extract the decompilation from the Decompiler analysis.\n    The intention of this analysis function is to use as little angr interfaces as possible since they may\n    change over time. If they change, this script will need updating.\n    \"\"\"\n    project = angr.Project(binary_path, auto_load_libs=False)\n    cfg = project.analyses.CFGFast(normalize=True)\n    decompilation = {}\n\n    function: angr.knowledge_plugins.functions.function.Function\n    for function in cfg.functions.values():\n        function.normalize()\n\n        # Wrapping in a try/except because the decompiler sometimes fails\n        try:\n            decomp = project.analyses.Decompiler(\n                func=function,\n                cfg=cfg,\n                # setting show_casts to false because of non-determinism\n                options=[\n                    (\n                        PARAM_TO_OPTION[\"structurer_cls\"],\n                        \"Phoenix\",\n                    ),\n                    (\n                        PARAM_TO_OPTION[\"show_casts\"],\n                        False,\n                    ),\n                ],\n            )\n        except Exception as e:\n            print(e)\n\n        func_key = f\"{function.addr}:{function.name}\"\n\n        if decomp.codegen:\n            decompilation[func_key] = decomp.codegen.text\n        else:\n            decompilation[func_key] = None\n\n    return decompilation\n```\n\n----------------------------------------\n\nTITLE: Stepping Through Symbolic Execution in angr (Python)\nDESCRIPTION: Illustrates basic symbolic execution by stepping through a program (`fauxware`) state by state using `state.step()`. The loop continues until a branch occurs, resulting in two successor states (`succ.successors`). This demonstrates how angr handles conditional branches by exploring both paths.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> proj = angr.Project('examples/fauxware/fauxware')\n>>> state = proj.factory.entry_state(stdin=angr.SimFile)  # ignore that argument for now - we're disabling a more complicated default setup for the sake of education\n>>> while True:\n...     succ = state.step()\n...     if len(succ.successors) == 2:\n...         break\n...     state = succ.successors[0]\n\n>>> state1, state2 = succ.successors\n>>> state1\n<SimState @ 0x400629>\n>>> state2\n<SimState @ 0x400699\n```\n\n----------------------------------------\n\nTITLE: Resolving Variables and State Exploration using angr - Python\nDESCRIPTION: This Python snippet provides an example of angr's state exploration and variable resolution capabilities. It shows how to search for source line addresses, run a simulation manager to reach breakpoints, and access variable values and pointers (including dereferencing). Required dependencies are angr and a binary loaded with debug info. It demonstrates important methods such as 'addr_to_line', 'factory.simgr()', 'explore', and accessing 'state.dvars'.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/debug_var.rst#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Get a state before executing printf(%d\\n\", *b) (line 7)\n# the addr to line 7 is 0x401193 you can search for it with\n>>> project.loader.main_object.addr_to_line\n{...}\n>>> addr = 0x401193\n# Create an simulation manager and run to that addr\n>>> simgr = project.factory.simgr()\n>>> simgr.explore(find = addr)\n<SimulationManager with 1 found>\n>>> state = simgr.found[0]\n# Resolve 'a' in state\n>>> state.dvars['a'].mem\n<int (32 bits) <BV32 0xa> at 0x7fffffffffeff30>\n# Dereference pointer b\n>>> state.dvars['b'].deref.mem\n<int (32 bits) <BV32 0xa> at 0x7fffffffffeff30>\n# It works as expected when resolving the value of b gives the address of a\n>>> state.dvars['b'].mem\n<reg64_t <BV64 0x7fffffffffeff30> at 0x7fffffffffeff38>\n```\n\n----------------------------------------\n\nTITLE: Accessing States in Stashes with angr\nDESCRIPTION: This code demonstrates different ways to access states within stashes, including iterating through stashes, accessing the first state with 'one_' prefix, and using the mulpyplexed version with 'mp_' prefix.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/pathgroups.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> for s in simgr.deadended + simgr.authenticated:\n...     print(hex(s.addr))\n0x1000030\n0x1000078\n0x1000078\n\n>>> simgr.one_deadended\n<SimState @ 0x1000030>\n>>> simgr.mp_authenticated\nMP([<SimState @ 0x1000078>, <SimState @ 0x1000078>])\n>>> simgr.mp_authenticated.posix.dumps(0)\nMP(['\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00',\n     '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x80\\x80\\x80\\x80@\\x80@\\x00'])\n```\n\n----------------------------------------\n\nTITLE: Running Simulation to Branch and Termination in angr\nDESCRIPTION: This code shows how to step execution until a symbolic branch is encountered, and then run until all states terminate. It demonstrates how states are automatically categorized into stashes like 'deadended'.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/pathgroups.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Step until the first symbolic branch\n>>> while len(simgr.active) == 1:\n...    simgr.step()\n\n>>> simgr\n<SimulationManager with 2 active>\n>>> simgr.active\n[<SimState @ 0x400692>, <SimState @ 0x400699>]\n\n# Step until everything terminates\n>>> simgr.run()\n>>> simgr\n<SimulationManager with 3 deadended>\n```\n\n----------------------------------------\n\nTITLE: Loading a Binary in angr\nDESCRIPTION: Create an angr Project object by loading a binary file, with the option to disable automatic library loading for improved performance.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nproj = angr.Project(\"/path/to/binary\", auto_load_libs=False) # auto_load_libs False for improved performance\n```\n\n----------------------------------------\n\nTITLE: Extracting Metadata from Loaded Objects in angr\nDESCRIPTION: This code demonstrates how to interact with loaded binary objects to extract metadata such as entry points, address ranges, and information about segments and sections. It also shows how to access PLT (Procedure Linkage Table) stubs for symbols.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> obj = proj.loader.main_object\n\n# The entry point of the object\n>>> obj.entry\n0x400580\n\n>>> obj.min_addr, obj.max_addr\n(0x400000, 0x60105f)\n\n# Retrieve this ELF's segments and sections\n>>> obj.segments\n<Regions: [<ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0>,\n          <ELFSegment memsize=0x238, filesize=0x228, vaddr=0x600e28, flags=0x6, offset=0xe28>]>\n>>> obj.sections\n<Regions: [<Unnamed | offset 0x0, vaddr 0x0, size 0x0>,\n          <.interp | offset 0x238, vaddr 0x400238, size 0x1c>,\n          <.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20>,\n           ...etc\n\n# You can get an individual segment or section by an address it contains:\n>>> obj.find_segment_containing(obj.entry)\n<ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0>\n>>> obj.find_section_containing(obj.entry)\n<.text | offset 0x580, vaddr 0x400580, size 0x338>\n\n# Get the address of the PLT stub for a symbol\n>>> addr = obj.plt['strcmp']\n>>> addr\n0x400550\n>>> obj.reverse_plt[addr]\n'strcmp'\n\n# Show the prelinked base of the object and the location it was actually mapped into memory by CLE\n>>> obj.linked_base\n0x400000\n>>> obj.mapped_base\n0x400000\n```\n\n----------------------------------------\n\nTITLE: Setting Conditional Breakpoints in Angr in Python\nDESCRIPTION: Examples of setting conditional breakpoints in Angr based on memory addresses. This demonstrates how to break before specific memory writes or after specific instructions when certain conditions are met.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/simulation.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# This will break before a memory write if 0x1000 is a possible value of its target expression\n>>> s.inspect.b('mem_write', mem_write_address=0x1000)\n\n# This will break before a memory write if 0x1000 is the *only* value of its target expression\n>>> s.inspect.b('mem_write', mem_write_address=0x1000, mem_write_address_unique=True)\n\n# This will break after instruction 0x8000, but only 0x1000 is a possible value of the last expression that was read from memory\n>>> s.inspect.b('instruction', when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000)\n```\n\n----------------------------------------\n\nTITLE: Managing Stashes in angr SimulationManager\nDESCRIPTION: This snippet demonstrates how to move states between stashes based on filtering conditions. It shows how to create custom stashes and filter states based on their output content.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/pathgroups.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: b'Welcome' in s.posix.dumps(1))\n>>> simgr\n<SimulationManager with 2 authenticated, 1 deadended>\n```\n\n----------------------------------------\n\nTITLE: Initializing and Stepping a Simulation Manager in angr\nDESCRIPTION: This snippet demonstrates how to create a simulation manager in angr, load a binary, and step execution forward one basic block at a time. It shows the basic state management capabilities.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/pathgroups.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n>>> proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False)\n>>> state = proj.factory.entry_state()\n>>> simgr = proj.factory.simgr(state)\n>>> simgr.active\n[<SimState @ 0x400580>]\n\n>>> simgr.step()\n>>> simgr.active\n[<SimState @ 0x400540>]\n```\n\n----------------------------------------\n\nTITLE: Creating a Simulation Manager in angr\nDESCRIPTION: Initialize a simulation manager object to manage and explore program states during analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsimgr = proj.factory.simulation_manager(state)\n```\n\n----------------------------------------\n\nTITLE: Accessing Function Information\nDESCRIPTION: Demonstrates how to access and work with the Function Manager to analyze function properties, such as block addresses, string references, and control flow.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/cfg.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nentry_func = cfg.kb.functions[p.entry]\n```\n\n----------------------------------------\n\nTITLE: CGC Challenge Vulnerability Analysis with angr\nDESCRIPTION: This snippet demonstrates using angr to identify vulnerabilities in DARPA's Cyber Grand Challenge binaries. It shows how to explore a binary to find a stack buffer overflow vulnerability in a simple challenge.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nScript author: Antonio Bianchi, Jacopo Corbetta\nConcepts presented: exploration to vulnerability\n```\n\n----------------------------------------\n\nTITLE: Parsing Types in Python using angr\nDESCRIPTION: Demonstrates how to use angr's type parsing functionality to create SimType objects from C type strings. It shows parsing basic types, structs, and typedefs.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/structured_data.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr, monkeyhex\n\n>>> angr.types.parse_type('int')\nint\n\n>>> angr.types.parse_type('char **')\nchar**\n\n>>> angr.types.parse_type('struct aa {int x; long y;}')\nstruct aa\n\n>>> angr.types.parse_type('struct aa {int x; long y;}').fields\nOrderedDict([('x', int), ('y', long)])\n```\n\n----------------------------------------\n\nTITLE: Handling Self-Modifying Code in TUMCTF zwiebel Challenge\nDESCRIPTION: This example demonstrates using angr to solve a self-unpacking reversing challenge. It shows how to enable Unicorn support and self-modification capabilities, using concrete execution for unpacking code to improve performance.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nScript author: Fish\nScript runtime: 2 hours 31 minutes with pypy and Unicorn - expect much longer with CPython only\nConcepts presented: self-modifying code support, concrete optimization with Unicorn\n```\n\n----------------------------------------\n\nTITLE: Setting Exploration Technique in angr\nDESCRIPTION: Apply a specific exploration strategy, such as Depth-First Search (DFS), to the simulation manager.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsimgr.use_technique(angr.exploration_techniques.DFS())\n```\n\n----------------------------------------\n\nTITLE: Working with CFG Nodes\nDESCRIPTION: Shows how to access and analyze CFG nodes, including retrieving entry points, examining node contexts, and analyzing predecessors and successors of nodes.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/cfg.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# this grabs *any* node at a given location:\nentry_node = cfg.model.get_any_node(p.entry)\n\n# on the other hand, this grabs all of the nodes\nprint(\"There were %d contexts for the entry block\" % len(cfg.model.get_all_nodes(p.entry)))\n\n# we can also look up predecessors and successors\nprint(\"Predecessors of the entry point:\", entry_node.predecessors)\nprint(\"Successors of the entry point:\", entry_node.successors)\nprint(\"Successors (and type of jump) of the entry point:\", [ jumpkind + \" to \" + str(node.addr) for node,jumpkind in cfg.model.get_successors_and_jumpkind(entry_node) ])\n```\n\n----------------------------------------\n\nTITLE: Finding strcpy Vulnerabilities with angr\nDESCRIPTION: This example shows how to use angr to discover vulnerabilities in binaries. It finds a path from the main entry point to a strcpy operation where the source buffer is controlled by user input, demonstrating exploration to find exploitable conditions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nScript author: Kyle Ossinger (github: @k0ss)\nConcepts presented: exploration to vulnerability, programmatic find condition\n```\n\n----------------------------------------\n\nTITLE: Initializing State with Symbolic Argument and Unicorn Engine in angr\nDESCRIPTION: Create an initial state with a symbolic argument, enabling the Unicorn engine for faster execution and disabling lazy solving.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nsym_arg = angr.claripy.BVS(\"sym_arg\", flag_size * 8)\nargv = [proj.filename]\nargv.append(sym_arg)\ninitial_state = proj.factory.full_init_state(args=argv, add_options=angr.options.unicorn, remove_options={angr.options.LAZY_SOLVES})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom SimProcedure for Symbol Hooking\nDESCRIPTION: Shows how to implement a custom SimProcedure to replace the rand() function with one that returns values from a predefined sequence. The implementation maintains state across calls using state.globals.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/simprocedures.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass NotVeryRand(SimProcedure):\n    def run(self, return_values=None):\n        rand_idx = self.state.globals.get('rand_idx', 0) % len(return_values)\n        out = return_values[rand_idx]\n        self.state.globals['rand_idx'] = rand_idx + 1\n        return out\n\nproject.hook_symbol('rand', NotVeryRand(return_values=[413, 612, 1025, 1111]))\n```\n\n----------------------------------------\n\nTITLE: Exploring States with Find and Avoid Conditions in angr\nDESCRIPTION: Use the explore method to symbolically execute until finding states that satisfy specified conditions, while avoiding others.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\navoid_addr = [0x400c06, 0x400bc7]\nfind_addr = 0x400c10d\nsimgr.explore(find=find_addr, avoid=avoid_addr)\n```\n\n----------------------------------------\n\nTITLE: Importing angr and claripy in Python\nDESCRIPTION: Import the main angr framework and the claripy solver engine for use in binary analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport angr #the main framework\nimport claripy #the solver engine\n```\n\n----------------------------------------\n\nTITLE: Configuring State Options in angr (Python)\nDESCRIPTION: Demonstrates setting and modifying state-level options in angr to control execution engine behavior. Uses Python set operations on SimState.options, and shows adding/removing options at state creation with add_options/remove_options. Dependencies: angr. Inputs: option names (from angr.options), Output: SimState with modified configuration.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Example: enable lazy solves, an option that causes state satisfiability to be checked as infrequently as possible.\n# This change to the settings will be propagated to all successor states created from this state after this line.\n>>> s.options.add(angr.options.LAZY_SOLVES)\n\n# Create a new state with lazy solves enabled\n>>> s = proj.factory.entry_state(add_options={angr.options.LAZY_SOLVES})\n\n# Create a new state without simplification options enabled\n>>> s = proj.factory.entry_state(remove_options=angr.options.simplification)\n```\n\n----------------------------------------\n\nTITLE: Loading a Binary and Examining the Loader in angr\nDESCRIPTION: This snippet demonstrates how to import angr, load a binary, and access the loader object to examine basic information about the loaded binary. The loader represents the entire memory space of loaded binary objects.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr, monkeyhex\n>>> proj = angr.Project('examples/fauxware/fauxware')\n>>> proj.loader\n<Loaded fauxware, maps [0x400000:0x5008000]>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic SimProcedure in Python for angr\nDESCRIPTION: A simple example that demonstrates how to create a SimProcedure to replace the main function. The procedure prints the arguments and returns 0, effectively replacing the actual main function's behavior.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/simprocedures.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from angr import Project, SimProcedure\n>>> project = Project('examples/fauxware/fauxware')\n\n>>> class BugFree(SimProcedure):\n...    def run(self, argc, argv):\n...        print('Program running with argc=%s and argv=%s' % (argc, argv))\n...        return 0\n\n# this assumes we have symbols for the binary\n>>> project.hook_symbol('main', BugFree())\n\n# Run a quick execution!\n>>> simgr = project.factory.simulation_manager()\n>>> simgr.run()  # step until no more active states\nProgram running with argc=<SAO <BV64 0x0>> and argv=<SAO <BV64 0x7fffffffffeffa0>>\n<SimulationManager with 1 deadended>\n```\n\n----------------------------------------\n\nTITLE: Exploring with STDOUT Condition in angr\nDESCRIPTION: Symbolically execute until a specific string appears in the program's STDOUT.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsimgr.explore(find=lambda s: \"correct\" in s.posix.dumps(1))\n```\n\n----------------------------------------\n\nTITLE: Loading Memory with Endianness Control in angr (Python)\nDESCRIPTION: Shows how to specify endianness when loading from memory in angr using archinfo.Endness. The snippet requires the angr and archinfo packages, and clarifies how to load data as little-endian via the 'endness' keyword argument. Inputs: memory address, size, and endianness; Output: loaded BV value in the specified byte order.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import archinfo\n>>> s.memory.load(0x4000, 4, endness=archinfo.Endness.LE)\n<BV32 0x67452301>\n```\n\n----------------------------------------\n\nTITLE: Interacting with PyVEX through angr\nDESCRIPTION: Shows how to use the PyVEX library through angr to analyze binary code, access VEX representations, and manipulate IR components. Demonstrates loading a binary, translating basic blocks, and inspecting various IR elements.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/ir.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n\n# load the program binary\n>>> proj = angr.Project(\"/bin/true\")\n\n# translate the starting basic block\n>>> irsb = proj.factory.block(proj.entry).vex\n# and then pretty-print it\n>>> irsb.pp()\n\n# translate and pretty-print a basic block starting at an address\n>>> irsb = proj.factory.block(0x401340).vex\n>>> irsb.pp()\n\n# this is the IR Expression of the jump target of the unconditional exit at the end of the basic block\n>>> print(irsb.next)\n\n# this is the type of the unconditional exit (e.g., a call, ret, syscall, etc)\n>>> print(irsb.jumpkind)\n\n# you can also pretty-print it\n>>> irsb.next.pp()\n\n# iterate through each statement and print all the statements\n>>> for stmt in irsb.statements:\n...     stmt.pp()\n\n# pretty-print the IR expression representing the data, and the *type* of that IR expression written by every store statement\n>>> import pyvex\n>>> for stmt in irsb.statements:\n...     if isinstance(stmt, pyvex.IRStmt.Store):\n...         print(\"Data:\",)\n...         stmt.data.pp()\n...         print(\"\")\n...         print(\"Type:\",)\n...         print(stmt.data.result_type)\n...         print(\"\")\n\n# pretty-print the condition and jump target of every conditional exit from the basic block\n>>> for stmt in irsb.statements:\n...     if isinstance(stmt, pyvex.IRStmt.Exit):\n...         print(\"Condition:\",)\n...         stmt.guard.pp()\n...         print(\"\")\n...         print(\"Target:\",)\n...         stmt.dst.pp()\n...         print(\"\")\n\n# these are the types of every temp in the IRSB\n>>> print(irsb.tyenv.types)\n\n# here is one way to get the type of temp 0\n>>> print(irsb.tyenv.types[0])\n```\n\n----------------------------------------\n\nTITLE: Parsing C Definitions in Python with angr\nDESCRIPTION: Shows how to parse C definitions and declarations using angr, returning dictionaries of variable/function declarations or newly defined types. It also demonstrates registering struct definitions for future use.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/structured_data.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> angr.types.parse_defns(\"int x; typedef struct llist { char* str; struct llist *next; } list_node; list_node *y;\")\n{'x': int, 'y': struct llist*}\n\n>>> defs = angr.types.parse_types(\"int x; typedef struct llist { char* str; struct llist *next; } list_node; list_node *y;\")\n>>> defs\n{'struct llist': struct llist, 'list_node': struct llist}\n\n>>> angr.types.parse_file(\"int x; typedef struct llist { char* str; struct llist *next; } list_node; list_node *y;\")\n({'x': int, 'y': struct llist*},\n {'struct llist': struct llist, 'list_node': struct llist})\n\n>>> defs['list_node'].fields\nOrderedDict([('str', char*), ('next', struct llist*)])\n\n>>> defs['list_node'].fields['next'].pts_to.fields\nOrderedDict([('str', char*), ('next', struct llist*)])\n\n>>> angr.types.parse_type(\"int (int y, double z)\")\n(int, double) -> int\n\n>>> angr.types.register_types(angr.types.parse_type('struct abcd { int x; int y; }'))\n>>> angr.types.register_types(angr.types.parse_types('typedef long time_t;'))\n>>> angr.types.parse_defns('struct abcd a; time_t b;')\n{'a': struct abcd, 'b': long}\n```\n\n----------------------------------------\n\nTITLE: Copying and Merging SimStates in angr (Python)\nDESCRIPTION: Shows how to duplicate and merge symbolic states in angr for path exploration. Demonstrates creation of blank states, memory assignment on copies, and merging states with .merge(), which yields a merged state, a symbolic merge indicator, and a flag. Dependencies: angr. Inputs: state objects, memory assignments; Output: new/copy/merged state instances.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> proj = angr.Project('/bin/true')\n>>> s = proj.factory.blank_state()\n>>> s1 = s.copy()\n>>> s2 = s.copy()\n\n>>> s1.mem[0x1000].uint32_t = 0x41414141\n>>> s2.mem[0x1000].uint32_t = 0x42424242\n```\n\nLANGUAGE: python\nCODE:\n```\n# merge will return a tuple. the first element is the merged state\n# the second element is a symbolic variable describing a state flag\n# the third element is a boolean describing whether any merging was done\n>>> (s_merged, m, anything_merged) = s1.merge(s2)\n\n# this is now an expression that can resolve to \"AAAA\" *or* \"BBBB\"\n>>> aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t\n```\n\n----------------------------------------\n\nTITLE: Manual Exploration with Custom Step Function in angr\nDESCRIPTION: Implement a custom step function to manually control the exploration process, including stash management.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsimgr.step(step_func=step_func, until=lambda lsm: len(sm.found) > 0)\n\ndef step_func(lsm):\n    lsm.stash(filter_func=lambda state: state.addr == 0x400c06, from_stash='active', to_stash='avoid')\n    lsm.stash(filter_func=lambda state: state.addr == 0x400bc7, from_stash='active', to_stash='avoid')\n    lsm.stash(filter_func=lambda state: state.addr == 0x400c10, from_stash='active', to_stash='found')\n    return lsm\n```\n\n----------------------------------------\n\nTITLE: Solving SecurityFest 2016 'fairlight' Challenge with angr\nDESCRIPTION: Script to solve the 'fairlight' challenge from SecurityFest 2016 using angr. The script runs in about 20 seconds and solves the challenge without reversing any checks.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/more-examples.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# Script content not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Hooking Addresses and Defining Custom SimProcedures in angr (Python)\nDESCRIPTION: This snippet demonstrates several ways of hooking addresses in angr to override binary code execution with Python functions (SimProcedures). It first shows how to use a built-in 'ReturnUnconstrained' SimProcedure, then manages hooks using methods like is_hooked, hooked_by, and unhook. Additionally, it showcases the use of function decorators to hook addresses with custom Python logic and optionally control the instruction stepping via the 'length' keyword. The code requires angr and is meant to be used in the context of a loaded angr Project.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # this is a CLASS\n>>> proj.hook(0x10000, stub_func())  # hook with an instance of the class\n\n>>> proj.is_hooked(0x10000)            # these functions should be pretty self-explanitory\nTrue\n>>> proj.hooked_by(0x10000)\n<ReturnUnconstrained>\n>>> proj.unhook(0x10000)\n\n>>> @proj.hook(0x20000, length=5)\n... def my_hook(state):\n...     state.regs.rax = 1\n\n>>> proj.is_hooked(0x20000)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Solving DEFCON Quals 2016 'baby-re' Challenge with angr\nDESCRIPTION: Script to solve the 'baby-re' challenge from DEFCON Quals 2016 using angr. The script runs in about 10 seconds.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/more-examples.rst#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Script content not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Solving Floating-Point Constraints with Claripy in Python\nDESCRIPTION: This snippet demonstrates adding constraints involving a symbolic floating-point variable `b` to a Claripy solver associated with a `state` object. It then evaluates `b` to find one possible floating-point value that satisfies the constraints `b + 2 < 0` and `b + 2 > -1`.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> state.solver.add(b + 2 < 0)\n>>> state.solver.add(b + 2 > -1)\n>>> state.solver.eval(b)\n-2.4999999999999996\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Objects with claripy in angr\nDESCRIPTION: Generate a symbolic bitvector object to represent unknown input in the analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsym_arg_size = 15 #Length in Bytes because we will multiply with 8 later\nsym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)\n```\n\n----------------------------------------\n\nTITLE: Working with Floating Point Numbers\nDESCRIPTION: Shows how to create and manipulate symbolic floating point values using z3's IEEE754 floating point support.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# fresh state\n>>> state = proj.factory.entry_state()\n>>> a = claripy.FPV(3.2, claripy.fp.FSORT_DOUBLE)\n>>> a\n<FP64 FPV(3.2, DOUBLE)>\n\n>>> b = claripy.FPS('b', claripy.fp.FSORT_DOUBLE)\n>>> b\n<FP64 FPS('FP_b_0_64', DOUBLE)>\n\n>>> a + b\n<FP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))>\n\n>>> a + 4.4\n<FP64 FPV(7.6000000000000005, DOUBLE)>\n\n>>> b + 2 < 0\n<Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))>\n```\n\n----------------------------------------\n\nTITLE: Creating a SimProcedure with Continuations in Python\nDESCRIPTION: An example of a SimProcedure that uses continuations to run multiple initializers in sequence. This shows how to maintain state between calls and implement complex control flow in SimProcedures.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/simprocedures.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass LinuxLoader(angr.SimProcedure):\n    NO_RET = True\n    IS_FUNCTION = True\n    local_vars = ('initializers',)\n\n    def run(self):\n        self.initializers = self.project.loader.initializers\n        self.run_initializer()\n\n    def run_initializer(self):\n        if len(self.initializers) == 0:\n            self.project._simos.set_entry_register_values(self.state)\n            self.jump(self.project.entry)\n        else:\n            addr = self.initializers[0]\n            self.initializers = self.initializers[1:]\n            self.call(addr, (self.state.posix.argc, self.state.posix.argv, self.state.posix.environ), 'run_initializer')\n```\n\n----------------------------------------\n\nTITLE: Using Angr's Identifier Analysis to Recognize Library Functions\nDESCRIPTION: This snippet demonstrates how to use Angr's Identifier analysis to recognize common library functions in a binary. It first creates a Project instance using a test binary, then runs the Identifier analysis to detect library functions. The results are printed as address-function name pairs.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/identifier.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n\n# get all the matches\n>>> p = angr.Project(\"../binaries/tests/i386/identifiable\")\n# note analysis is executed via the Identifier call\n>>> idfer = p.analyses.Identifier()\n>>> for funcInfo in idfer.func_info:\n...     print(hex(funcInfo.addr), funcInfo.name)\n\n0x8048e60 memcmp\n0x8048ef0 memcpy\n0x8048f60 memmove\n0x8049030 memset\n0x8049320 fdprintf\n0x8049a70 sprintf\n0x8049f40 strcasecmp\n0x804a0f0 strcmp\n0x804a190 strcpy\n0x804a260 strlen\n0x804a3d0 strncmp\n0x804a620 strtol\n0x804aa00 strtol\n0x80485b0 free\n0x804aab0 free\n0x804aad0 free\n0x8048660 malloc\n0x80485b0 free\n```\n\n----------------------------------------\n\nTITLE: Bit-Pattern Preserving Float/Bitvector Conversions with Claripy in Python\nDESCRIPTION: This snippet illustrates how to convert between floating-point and bitvector representations while preserving the underlying bit-pattern using Claripy. It shows converting a concrete float (`a`) and a symbolic float (`b`) to their bitvector representations using `raw_to_bv()`. It also shows converting a concrete bitvector (0) and a symbolic bitvector ('x') to their floating-point representations using `raw_to_fp()`. These conversions are analogous to casting pointers in C.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> a.raw_to_bv()\n<BV64 0x400999999999999a>\n>>> b.raw_to_bv()\n<BV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))>\n\n>>> claripy.BVV(0, 64).raw_to_fp()\n<FP64 FPV(0.0, DOUBLE)>\n>>> claripy.BVS('x', 64).raw_to_fp()\n<FP64 fpToFP(x_1_64, DOUBLE)>\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints to Symbolic Objects in angr\nDESCRIPTION: Restrict the range of possible values for a symbolic object to represent typical character ranges.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfor byte in sym_arg.chop(8):\n    initial_state.add_constraints(byte >= '\\x20') # ' '\n    initial_state.add_constraints(byte <= '\\x7e') # '~'\n```\n\n----------------------------------------\n\nTITLE: Installing angr via pip in Bash\nDESCRIPTION: This command installs angr from PyPI using pip. It's the easiest and recommended way to install angr.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/installing.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install angr\n```\n\n----------------------------------------\n\nTITLE: Working with Basic Blocks\nDESCRIPTION: Shows how to extract and analyze a basic block of code from a specific address. The example demonstrates pretty-printing the disassembly, counting instructions, and accessing different representations of the code block.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> block = proj.factory.block(proj.entry) # lift a block of code from the program's entry point\n<Block for 0x401670, 42 bytes>\n\n>>> block.pp()                          # pretty-print a disassembly to stdout\n0x401670:       xor     ebp, ebp\n0x401672:       mov     r9, rdx\n0x401675:       pop     rsi\n0x401676:       mov     rdx, rsp\n0x401679:       and     rsp, 0xfffffffffffffff0\n0x40167d:       push    rax\n0x40167e:       push    rsp\n0x40167f:       lea     r8, [rip + 0x2e2a]\n0x401686:       lea     rcx, [rip + 0x2db3]\n0x40168d:       lea     rdi, [rip - 0xd4]\n0x401694:       call    qword ptr [rip + 0x205866]\n\n>>> block.instructions                  # how many instructions are there?\n0xb\n>>> block.instruction_addrs             # what are the addresses of the instructions?\n[0x401670, 0x401672, 0x401675, 0x401676, 0x401679, 0x40167d, 0x40167e, 0x40167f, 0x401686, 0x40168d, 0x401694]\n```\n\n----------------------------------------\n\nTITLE: Storing Values in Registers and Memory\nDESCRIPTION: Demonstrates storing bitvectors and Python integers into registers and memory. Shows the memory interface for specifying addresses and data types.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> state.regs.rsi = claripy.BVV(3, 64)\n>>> state.regs.rsi\n<BV64 0x3>\n\n>>> state.mem[0x1000].long = 4\n>>> state.mem[0x1000].long.resolved\n<BV64 0x4>\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Load Options with angr.Project (Python)\nDESCRIPTION: This snippet demonstrates initializing an angr Project by specifying per-binary and per-library options using the 'main_opts' and 'lib_opts' dictionaries. It shows how to explicitly force the project to use specific backends and architectures for main and library objects, offering fine-tuned control over the binary loading process. Required dependencies include angr and relevant libraries (such as CLE and PyELFTools) and the code expects valid binary file paths and backend identifiers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})\n<Project examples/fauxware/fauxware>\n```\n\n----------------------------------------\n\nTITLE: Creating State with Symbolic Argument in angr\nDESCRIPTION: Initialize a program state with a symbolic argument, useful for analyzing programs with command-line inputs.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nargv = [proj.filename]\nargv.append(sym_arg)\nstate = proj.factory.entry_state(args=argv)\n```\n\n----------------------------------------\n\nTITLE: Tracking Memory Reads with Angr Breakpoints in Python\nDESCRIPTION: Example of setting up a breakpoint to track memory reads in Angr. This code defines a callback function that prints the memory expression being read and its address, then attaches this function to a memory read breakpoint.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/simulation.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> def track_reads(state):\n...     print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address)\n...\n>>> s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads)\n```\n\n----------------------------------------\n\nTITLE: Working with the Loader\nDESCRIPTION: Shows how to access and query the CLE loader which handles binary loading in angr. This example demonstrates examining shared libraries, address ranges, and querying binary properties.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> proj.loader\n<Loaded true, maps [0x400000:0x5004000]>\n\n>>> proj.loader.shared_objects # may look a little different for you!\n{'ld-linux-x86-64.so.2': <ELF Object ld-2.24.so, maps [0x2000000:0x2227167]>,\n 'libc.so.6': <ELF Object libc-2.24.so, maps [0x1000000:0x13c699f]>}\n\n>>> proj.loader.min_addr\n0x400000\n>>> proj.loader.max_addr\n0x5004000\n\n>>> proj.loader.main_object  # we've loaded several binaries into this project. Here's the main one!\n<ELF Object true, maps [0x400000:0x60721f]>\n\n>>> proj.loader.main_object.execstack  # sample query: does this binary have an executable stack?\nFalse\n>>> proj.loader.main_object.pic  # sample query: is this binary position-independent?\nTrue\n```\n\n----------------------------------------\n\nTITLE: Using Custom Function Conditions for Angr Breakpoints in Python\nDESCRIPTION: Example of using a custom function as a condition for breakpoints in Angr. This code defines a complex condition that checks the value of a register and the execution history before triggering a breakpoint.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/simulation.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and\n# that the basic block starting at 0x8004 was executed sometime in this path's history\n>>> def cond(state):\n...     return state.eval(state.regs.rax, cast_to=str) == 'AAAA' and 0x8004 in state.inspect.backtrace\n\n>>> s.inspect.b('mem_write', condition=cond)\n```\n\n----------------------------------------\n\nTITLE: File System Interaction in ASIS CTF license Challenge\nDESCRIPTION: This example shows how to interact with the filesystem in angr. Instead of hooking file read operations, it demonstrates passing in a filesystem with the correct license file to solve a crackme challenge.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nScript author: Fish Wang (github: @ltfish)\nScript runtime: 3.6 sec\nConcepts presented: using the filesystem, manual symbolic summary execution\n```\n\n----------------------------------------\n\nTITLE: Calling Functions using FFI in angr\nDESCRIPTION: Demonstrate how to call a function at a specific address using angr's foreign function interface.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nf = proj.factory.callable(address)\nf(10)\nx=claripy.BVS('x', 64)\nf(x) #TODO: Find out how to make that result readable\n```\n\n----------------------------------------\n\nTITLE: Exploring Loaded Objects in angr's CLE Loader\nDESCRIPTION: This snippet shows how to examine the different objects loaded by CLE, including the main binary, shared libraries, and special objects like the TLS, externs, and kernel objects. It demonstrates how to access specific objects and their properties.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# All loaded objects\n>>> proj.loader.all_objects\n[<ELF Object fauxware, maps [0x400000:0x60105f]>,\n <ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]>,\n <ELF Object ld-2.23.so, maps [0x2000000:0x2227167]>,\n <ELFTLSObject Object cle##tls, maps [0x3000000:0x3015010]>,\n <ExternObject Object cle##externs, maps [0x4000000:0x4008000]>,\n <KernelObject Object cle##kernel, maps [0x5000000:0x5008000]>]\n\n# This is the \"main\" object, the one that you directly specified when loading the project\n>>> proj.loader.main_object\n<ELF Object fauxware, maps [0x400000:0x60105f]>\n\n# This is a dictionary mapping from shared object name to object\n>>> proj.loader.shared_objects\n{ 'fauxware': <ELF Object fauxware, maps [0x400000:0x60105f]>,\n  'libc.so.6': <ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]>,\n  'ld-linux-x86-64.so.2': <ELF Object ld-2.23.so, maps [0x2000000:0x2227167]> }\n\n# Here's all the objects that were loaded from ELF files\n# If this were a windows program we'd use all_pe_objects!\n>>> proj.loader.all_elf_objects\n[<ELF Object fauxware, maps [0x400000:0x60105f]>,\n <ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]>,\n <ELF Object ld-2.23.so, maps [0x2000000:0x2227167]>]\n\n# Here's the \"externs object\", which we use to provide addresses for unresolved imports and angr internals\n>>> proj.loader.extern_object\n<ExternObject Object cle##externs, maps [0x4000000:0x4008000]>\n\n# This object is used to provide addresses for emulated syscalls\n>>> proj.loader.kernel_object\n<KernelObject Object cle##kernel, maps [0x5000000:0x5008000]>\n\n# Finally, you can to get a reference to an object given an address in it\n>>> proj.loader.find_object_containing(0x400000)\n<ELF Object fauxware, maps [0x400000:0x60105f]>\n```\n\n----------------------------------------\n\nTITLE: Working with Symbols in angr's CLE Loader\nDESCRIPTION: This snippet demonstrates how to find and work with symbols in loaded binaries. It shows how to access different address representations of a symbol, distinguish between import and export symbols, and understand symbol resolution.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> strcmp = proj.loader.find_symbol('strcmp')\n>>> strcmp\n<Symbol \"strcmp\" in libc.so.6 at 0x1089cd0>\n\n>>> strcmp.name\n'strcmp'\n\n>>> strcmp.owner\n<ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]>\n\n>>> strcmp.rebased_addr\n0x1089cd0\n>>> strcmp.linked_addr\n0x89cd0\n>>> strcmp.relative_addr\n0x89cd0\n\n>>> strcmp.is_export\nTrue\n>>> strcmp.is_import\nFalse\n\n# On Loader, the method is find_symbol because it performs a search operation to find the symbol.\n# On an individual object, the method is get_symbol because there can only be one symbol with a given name.\n>>> main_strcmp = proj.loader.main_object.get_symbol('strcmp')\n>>> main_strcmp\n<Symbol \"strcmp\" in fauxware (import)>\n>>> main_strcmp.is_export\nFalse\n>>> main_strcmp.is_import\nTrue\n>>> main_strcmp.resolvedby\n<Symbol \"strcmp\" in libc.so.6 at 0x1089cd0>\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Python Mixin Pattern\nDESCRIPTION: Demonstrates a basic mixin pattern implementation with Base class and two mixins (StringsMixin and ArraysMixin) to handle different data types while maintaining the same interface.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/mixins.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Base:\n    def add_one(self, v):\n        return v + 1\n\nclass StringsMixin(Base):\n    def add_one(self, v):\n        coerce = type(v) is str\n        if coerce:\n            v = int(v)\n        result = super().add_one(v)\n        if coerce:\n            result = str(result)\n        return result\n\nclass ArraysMixin(Base):\n    def add_one(self, v):\n        if type(v) is list:\n            return [super().add_one(v_x) for v_x in v]\n        else:\n            return super().add_one(v)\n\nclass FinalClass(ArraysMixin, StringsMixin, Base):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic State Plugin in Python with angr\nDESCRIPTION: This snippet demonstrates how to create a simple state plugin by subclassing SimStatePlugin and implementing the required copy method. It also shows how to register the plugin with a state and access it across state copies.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n>>> class MyFirstPlugin(angr.SimStatePlugin):\n...     def __init__(self, foo):\n...         super(MyFirstPlugin, self).__init__()\n...         self.foo = foo\n...\n...     @angr.SimStatePlugin.memo\n...     def copy(self, memo):\n...         return MyFirstPlugin(self.foo)\n\n>>> state = angr.SimState(arch='AMD64')\n>>> state.register_plugin('my_plugin', MyFirstPlugin('bar'))\n>>> assert state.my_plugin.foo == 'bar'\n\n>>> state2 = state.copy()\n>>> state.my_plugin.foo = 'baz'\n>>> state3 = state.copy()\n>>> assert state2.my_plugin.foo == 'bar'\n>>> assert state3.my_plugin.foo == 'baz'\n```\n\n----------------------------------------\n\nTITLE: Accessing State after Function Call in angr\nDESCRIPTION: Retrieve the state after a function call, useful when the function modifies memory or registers instead of returning a value directly.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> f.result_state\n<SimState @ 0x1000550>\n```\n\n----------------------------------------\n\nTITLE: Analyzing AST Structure in angr\nDESCRIPTION: Shows how to examine the structure of an Abstract Syntax Tree (AST) by accessing its operation (.op) and arguments (.args) to understand the tree's composition.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> tree = (x + 1) / (y + 2)\n>>> tree\n<BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)>\n>>> tree.op\n'__floordiv__'\n>>> tree.args\n(<BV64 x_9_64 + 0x1>, <BV64 y_10_64 + 0x2>)\n>>> tree.args[0].op\n'__add__'\n>>> tree.args[0].args\n(<BV64 x_9_64>, <BV64 0x1>)\n>>> tree.args[0].args[1].op\n'BVV'\n>>> tree.args[0].args[1].args\n(1, 64)\n```\n\n----------------------------------------\n\nTITLE: Accessing Basic Block Information in angr\nDESCRIPTION: Retrieve and print information about a basic block, including its Capstone disassembly and VEX intermediate representation.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nblock = proj.factory.block(address)\nblock.capstone.pp() # Capstone object has pretty print and other data about the disassembly\nblock.vex.pp()      # Print vex representation\n```\n\n----------------------------------------\n\nTITLE: Defining UberEngine with Multiple Mixins\nDESCRIPTION: Shows the composition of angr's UberEngine class using multiple mixins to provide different execution capabilities and instrumentation features.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/mixins.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass UberEngine(SimEngineFailure,\n   SimEngineSyscall,\n   HooksMixin,\n   SimEngineUnicorn,\n   SuperFastpathMixin,\n   TrackActionsMixin,\n   SimInspectMixin,\n   HeavyResilienceMixin,\n   SootMixin,\n   HeavyVEXMixin\n):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing init_state Method for Plugin Initialization in angr\nDESCRIPTION: This snippet demonstrates how to override the init_state method to perform initialization that requires interaction with other plugins or complex state operations, such as mapping memory regions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> def init_state(self):\n...     if self.region is None:\n...        self.region = self.state.memory.map_region(SOMEWHERE, 0x1000, 7)\n```\n\n----------------------------------------\n\nTITLE: Writing to Memory in angr State\nDESCRIPTION: Demonstrate how to write a concrete value to a specific memory address in an angr state.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\naaaa = claripy.BVV(0x41414141, 32) # 32 = Bits\nstate.memory.store(0x6021f2, aaaa)\n```\n\n----------------------------------------\n\nTITLE: Accessing Typed Data from Memory in angr\nDESCRIPTION: Illustrates how to access typed data from memory using angr's state.mem interface. It shows how to read different types of data, including structs, pointers, and strings, as well as resolving and concretizing values.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/structured_data.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> p = angr.Project('examples/fauxware/fauxware')\n>>> s = p.factory.entry_state()\n>>> s.mem[0x601048]\n<<untyped> <unresolvable> at 0x601048>\n\n>>> s.mem[0x601048].long\n<long (64 bits) <BV64 0x4008d0> at 0x601048>\n\n>>> s.mem[0x601048].long.resolved\n<BV64 0x4008d0>\n\n>>> s.mem[0x601048].long.concrete\n0x4008d0\n\n>>> s.mem[0x601048].struct.abcd\n<struct abcd {\n  .x = <BV32 0x4008d0>,\n  .y = <BV32 0x0>\n} at 0x601048>\n\n>>> s.mem[0x601048].struct.abcd.x\n<int (32 bits) <BV32 0x4008d0> at 0x601048>\n\n>>> s.mem[0x601048].struct.abcd.y\n<int (32 bits) <BV32 0x0> at 0x60104c>\n\n>>> s.mem[0x601048].deref\n<<untyped> <unresolvable> at 0x4008d0>\n\n>>> s.mem[0x601048].deref.string\n<string_t <BV64 0x534f534e45414b59> at 0x4008d0>\n\n>>> s.mem[0x601048].deref.string.resolved\n<BV64 0x534f534e45414b59>\n\n>>> s.mem[0x601048].deref.string.concrete\nb'SOSNEAKY'\n\n>>> s.mem[p.entry].struct.abcd\n<struct abcd {\n  .x = <BV32 0x8949ed31>,\n  .y = <BV32 0x89485ed1>\n} at 0x400580>\n```\n\n----------------------------------------\n\nTITLE: Initializing Symbion with ConcreteTarget\nDESCRIPTION: Example showing how to set up a ConcreteTarget, create an angr Project, configure entry state options, and enable Symbion technique.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/symbion.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Instantiating the ConcreteTarget\navatar_gdb = AvatarGDBConcreteTarget(avatar2.archs.x86.X86_64,\n                                        GDB_SERVER_IP, GDB_SERVER_PORT)\n\n# Creating the Project\np = angr.Project(binary_x64, concrete_target=avatar_gdb,\n                                use_sim_procedures=True)\n\n# Getting an entry_state\nentry_state = p.factory.entry_state()\n\n# Forget about these options as for now, will explain later.\nentry_state.options.add(angr.options.SYMBION_SYNC_CLE)\nentry_state.options.add(angr.options.SYMBION_KEEP_STUBS_ON_SYNC)\n\n# Use Symbion!\nsimgr.use_technique(angr.exploration_techniques.Symbion(find=[0x85b853])\n```\n\n----------------------------------------\n\nTITLE: Compiling Binary with Debug Information using GCC - Bash\nDESCRIPTION: This snippet demonstrates how to compile a C source file with DWARF debug information using GCC, which is necessary for angr's debug variable resolution features. The '-g' flag enables inclusion of debug data, and '-o' sets the output filename. The resulting binary should be used as input for angr analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/debug_var.rst#2025-04-23_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngcc -g -o debug_var debug_var.c\n```\n\n----------------------------------------\n\nTITLE: Enabling Unicorn Engine in angr\nDESCRIPTION: This snippet demonstrates how to enable the Unicorn Engine for concrete execution in angr by adding a predefined set of options to a state. These options enable additional functionalities and defaults for efficient concrete execution.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nunicorn = { UNICORN, UNICORN_SYM_REGS_SUPPORT, INITIALIZE_ZERO_REGISTERS, UNICORN_HANDLE_TRANSMIT_SYSCALL }\n```\n\n----------------------------------------\n\nTITLE: Reading Pointer to Pointer from Frame in angr\nDESCRIPTION: Example of how to read a pointer to a pointer from the stack frame in an angr state.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\npoi1 = new_state.solver.eval(new_state.regs.rbp)-0x10\npoi1 = new_state.mem[poi1].long.concrete\npoi1 += 0x8\nptr1 = new_state.mem[poi1].long.concrete\n```\n\n----------------------------------------\n\nTITLE: Accessing CFG Graph Properties\nDESCRIPTION: Demonstrates how to access basic properties of the CFG graph including nodes and edges count, using NetworkX APIs that are available through the CFG model.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/cfg.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(\"This is the graph:\", cfg.model.graph)\nprint(\"It has %d nodes and %d edges\" % (len(cfg.model.graph.nodes()), len(cfg.model.graph.edges())))\n```\n\n----------------------------------------\n\nTITLE: Checking Satisfiability and Handling Contradictions\nDESCRIPTION: Shows how to check if constraints are satisfiable and what happens when contradictions are introduced.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> state.solver.add(input < 2**32)\n>>> state.satisfiable()\nFalse\n```\n\n----------------------------------------\n\nTITLE: ARM Assembly to VEX IR Conversion Example\nDESCRIPTION: Demonstrates how an ARM instruction 'subs R2, R2, #8' is converted into VEX IR, showing the translation of register operations and program counter updates.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/ir.rst#2025-04-23_snippet_0\n\nLANGUAGE: asm\nCODE:\n```\nsubs R2, R2, #8\n```\n\nLANGUAGE: text\nCODE:\n```\nt0 = GET:I32(16)\nt1 = 0x8:I32\nt3 = Sub32(t0,t1)\nPUT(16) = t3\nPUT(68) = 0x59FC8:I32\n```\n\n----------------------------------------\n\nTITLE: Evaluating Complex Expressions\nDESCRIPTION: Demonstrates how to evaluate more complex expressions involving multiple symbolic variables.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# fresh state\n>>> state = proj.factory.entry_state()\n>>> state.solver.add(x - y >= 4)\n>>> state.solver.add(y > 0)\n>>> state.solver.eval(x)\n5\n>>> state.solver.eval(y)\n1\n>>> state.solver.eval(x + y)\n6\n```\n\n----------------------------------------\n\nTITLE: Reading Array from Memory in angr\nDESCRIPTION: Demonstrate two equivalent methods to read an array of integers from memory in an angr state.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nkey = []\nfor i in range(38):\n    key.append(extractkey.mem[0x602140 + i*4].int.concrete)\n\n# Alternatively, the below expression is equivalent\nkey = extractkey.mem[0x602140].int.array(38).concrete\n```\n\n----------------------------------------\n\nTITLE: Configuring Stdio Streams via POSIX Plugin in Python (angr)\nDESCRIPTION: Shows how to explicitly set the standard input (`stdin`), standard output (`stdout`), and standard error (`stderr`) streams for an angr state. This is done by registering the `posix` plugin (`angr.state_plugins.posix.SimSystemPosix`) and providing `SimFile` objects for each stream during instantiation. Asserts confirm that the state's posix plugin references the correct `simfile` objects.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> state.register_plugin('posix', angr.state_plugins.posix.SimSystemPosix(stdin=simfile, stdout=simfile, stderr=simfile))\n>>> assert state.posix.stdin is simfile\n>>> assert state.posix.stdout is simfile\n>>> assert state.posix.stderr is simfile\n```\n\n----------------------------------------\n\nTITLE: Initializing CFG Analysis in angr\nDESCRIPTION: Shows how to create both static (CFGFast) and dynamic (CFGEmulated) control-flow graphs using angr. The example loads a binary without auto-loading libraries and generates both types of CFGs.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/cfg.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport angr\n# load your project\np = angr.Project('/bin/true', load_options={'auto_load_libs': False})\n\n# Generate a static CFG\ncfg = p.analyses.CFGFast()\n\n# generate a dynamic CFG\ncfg = p.analyses.CFGEmulated(keep_state=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Concrete File in angr\nDESCRIPTION: Demonstrates how to create a SimFile with concrete content 'hello world!\\n' and perform basic read operations.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport angr\nsimfile = angr.SimFile('myconcretefile', content='hello world!\\n')\nproj = angr.Project('/bin/true')\nstate = proj.factory.blank_state()\nsimfile.set_state(state)\ndata, actual_size, new_pos = simfile.read(0, 5)\n```\n\n----------------------------------------\n\nTITLE: Working with Symbolic Boolean Expressions\nDESCRIPTION: Demonstrates how to create symbolic boolean expressions through comparisons and check their truthiness using solver.is_true() and solver.is_false().\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> x == 1\n<Bool x_9_64 == 0x1>\n>>> x == one\n<Bool x_9_64 == 0x1>\n>>> x > 2\n<Bool x_9_64 > 0x2>\n>>> x + y == one_hundred + 5\n<Bool (x_9_64 + y_10_64) == 0x69>\n>>> one_hundred > 5\n<Bool True>\n>>> one_hundred > -5\n<Bool False>\n\n>>> yes = one == 1\n>>> no = one == 2\n>>> maybe = x == y\n>>> state.solver.is_true(yes)\nTrue\n>>> state.solver.is_false(yes)\nFalse\n>>> state.solver.is_true(no)\nFalse\n>>> state.solver.is_false(no)\nTrue\n>>> state.solver.is_true(maybe)\nFalse\n>>> state.solver.is_false(maybe)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Setting Breakpoint on Memory Operations in angr\nDESCRIPTION: Set up a breakpoint to trigger a debug function after every memory read operation in angr.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nnew_state.inspect.b('mem_read', when=angr.BP_AFTER, action=debug_funcRead)\ndef debug_funcRead(state):\n    print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address\n```\n\n----------------------------------------\n\nTITLE: Creating an Entry State in angr\nDESCRIPTION: Generate a SimState object representing the initial state of the program at its entry point.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstate = proj.factory.entry_state()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom SimProcedure Hooks in angr\nDESCRIPTION: Define and apply a custom SimProcedure to hook a specific address in the binary, replacing its functionality during analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass fixpid(angr.SimProcedure):\n    def run(self):\n            return 0x30\n\nproj.hook(0x4008cd, fixpid())\n```\n\n----------------------------------------\n\nTITLE: Retrieving Call Stack from State in angr\nDESCRIPTION: Access the call stack of a state to understand the execution path and identify where the analysis might be stuck.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nstate = simgr.active[0]\nprint state.callstack\n```\n\n----------------------------------------\n\nTITLE: Implementing HeavyVEXMixin Class\nDESCRIPTION: Demonstrates the composition of HeavyVEXMixin class which provides fully instrumented symbolic execution on a SimState through multiple inheritance.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/mixins.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEXMixin, VEXLifter):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating Constrained Symbolic File in angr\nDESCRIPTION: Illustrates creating a file with constrained symbolic content where each byte is limited to printable ASCII range (0x20-0x7e).\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nbytes_list = [claripy.BVS('byte_%d' % i, 8) for i in range(32)]\nbytes_ast = claripy.Concat(*bytes_list)\nmystate = proj.factory.entry_state(stdin=angr.SimFile('/dev/stdin', content=bytes_ast))\nfor byte in bytes_list:\n    mystate.solver.add(byte >= 0x20)\n    mystate.solver.add(byte <= 0x7e)\n```\n\n----------------------------------------\n\nTITLE: Concatenating Bitvectors in Claripy\nDESCRIPTION: Demonstrates how to concatenate multiple bitvectors into a single bitvector. The result combines all the bits, with the first argument being the most significant bits.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nx.concat(y, ...)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Blank State for Low-Level Memory Access (Python)\nDESCRIPTION: Shows how to create a blank angr SimState using `proj.factory.blank_state()`. This type of state has minimal initialization and is often used as a starting point for manual setup or when using the low-level memory interface (`state.memory.load()` and `state.memory.store()`) for raw data manipulation, as described in the preceding text.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/states.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> s = proj.factory.blank_state()\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging for Unicorn in angr (Python)\nDESCRIPTION: This snippet shows how to enable debug logging for the Unicorn engine integration in angr. It sets the logging level to DEBUG for both the Unicorn engine and its state plugin.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlogging.getLogger('angr.engines.unicorn_engine').setLevel('DEBUG'); logging.getLogger('angr.state_plugins.unicorn_engine').setLevel('DEBUG')\n```\n\n----------------------------------------\n\nTITLE: Initializing BackwardSlice Analysis in angr\nDESCRIPTION: Example showing how to create a BackwardSlice analysis by first generating required CFG, CDG, and DDG graphs, then targeting a specific exit function. Requires angr project initialization and configuration of analysis parameters.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/backward_slice.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport angr\n# Load the project\nb = angr.Project(\"examples/fauxware/fauxware\", load_options={\"auto_load_libs\": False})\n\n# Generate a CFG first. In order to generate data dependence graph afterwards, you'll have to:\n# - keep all input states by specifying keep_state=True.\n# - store memory, register and temporary values accesses by adding the angr.options.refs option set.\n# Feel free to provide more parameters (for example, context_sensitivity_level) for CFG\n# recovery based on your needs.\ncfg = b.analyses.CFGEmulated(keep_state=True,\n                             state_add_options=angr.sim_options.refs,\n                             context_sensitivity_level=2)\n\n# Generate the control dependence graph\ncdg = b.analyses.CDG(cfg)\n\n# Build the data dependence graph. It might take a while. Be patient!\nddg = b.analyses.DDG(cfg)\n\n# See where we wanna go... let's go to the exit() call, which is modeled as a\n# SimProcedure.\ntarget_func = cfg.kb.functions.function(name=\"exit\")\n# We need the CFGNode instance\ntarget_node = cfg.model.get_any_node(target_func.addr)\n\n# Let's get a BackwardSlice out of them!\n# `targets` is a list of objects, where each one is either a CodeLocation\n# object, or a tuple of CFGNode instance and a statement ID. Setting statement\n# ID to -1 means the very beginning of that CFGNode. A SimProcedure does not\n# have any statement, so you should always specify -1 for it.\nbs = b.analyses.BackwardSlice(cfg, cdg=cdg, ddg=ddg, targets=[ (target_node, -1) ])\n\n# Here is our awesome program slice!\nprint(bs)\n```\n\n----------------------------------------\n\nTITLE: Creating Mixed Content File in angr\nDESCRIPTION: Demonstrates creating a file with both symbolic and concrete content without EOF.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nvariable = claripy.BVS('myvar', 10*8)\nsimfile = angr.SimFile('mymixedfile', content=variable.concat(claripy.BVV('\\n')), has_end=False)\nsimfile.set_state(state)\n```\n\n----------------------------------------\n\nTITLE: Chopping a Bitvector into Chunks in Claripy\nDESCRIPTION: Shows how to split a bitvector into a list of smaller bitvectors of equal size. This is useful for operations that need to process parts of a value separately.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nval.chop(n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Combining Boolean Conditions in Claripy\nDESCRIPTION: Demonstrates how to create boolean conditions by comparing ASTs and combining them using logical operators like And and Or.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/claripy.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> r = bv == x\n>>> assert isinstance(r, claripy.ast.Bool)\n\n>>> p = bv == bv\n>>> assert isinstance(p, claripy.ast.Bool)\n>>> assert p.is_true()\n\n>>> q = claripy.And(claripy.Or(bv == x, bv * 2 == x, bv * 3 == x), x == 0)\n>>> assert isinstance(p, claripy.ast.Bool)\n```\n\n----------------------------------------\n\nTITLE: Hooking and Symbolic Exploration in angr - Python\nDESCRIPTION: Demonstrates the use of angr for program state space exploration on custom targets, specifically to discover inputs that crash GRUB's password prompt. The Python script requires angr and may use angr's function hooking features to override unusual or non-standard target behaviors, enabling advanced exploration techniques to categorize and prune program state. Expected inputs are target binaries and the outputs are crash-triggering inputs. This script is reliant on the angr framework and Python 3.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n# Script author: Audrey Dutcher (github: @rhelmot)\n# Concepts presented: unusual target (custom function hooking required), use of exploration techniques to categorize and prune the program's state space\n```\n\n----------------------------------------\n\nTITLE: Accessing Basic Project Properties\nDESCRIPTION: Demonstrates how to access basic properties of an angr project, including CPU architecture information, entry point address, and filename. The monkeyhex module is used to format numerical results in hexadecimal.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import monkeyhex # this will format numerical results in hexadecimal\n>>> proj.arch\n<Arch AMD64 (LE)>\n>>> proj.entry\n0x401670\n>>> proj.filename\n'/bin/true'\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Size File in angr\nDESCRIPTION: Shows how to create a file with a symbolic size constrained between 10 and 20 bytes.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsymsize = claripy.BVS('mysize', 64)\nstate.solver.add(symsize >= 10)\nstate.solver.add(symsize < 20)\nsimfile = angr.SimFile('mysymsizefile', size=symsize)\nsimfile.set_state(state)\n```\n\n----------------------------------------\n\nTITLE: Adding Solver Replacements in angr\nDESCRIPTION: Shows how to use the Replacement Solver API to add AST replacements that are applied at solve-time, which can greatly reduce runtime by replacing symbolic data with concrete values.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/speed.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nstate.se._solver.add_replacement(old, new)\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic File in angr\nDESCRIPTION: Shows how to create a SimFile with symbolic content and a defined size of 0x20 bytes.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsimfile = angr.SimFile('mysymbolicfile', size=0x20)\nsimfile.set_state(state)\ndata, actual_size, new_pos = simfile.read(0, 0x30)\n```\n\n----------------------------------------\n\nTITLE: Working with Bitvectors\nDESCRIPTION: Shows how to convert between Python integers and bitvectors (the representation angr uses for CPU data). Bitvectors properly model CPU semantics like wrapping on overflow.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> bv = claripy.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234\n<BV32 0x1234>                               # BVV stands for bitvector value\n>>> state.solver.eval(bv)                # convert to Python int\n0x1234\n```\n\n----------------------------------------\n\nTITLE: Accessing Alternative Block Representations\nDESCRIPTION: Shows how to access different representations of a code block, including Capstone disassembly and VEX IRSB (Intermediate Representation Super-Block).\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> block.capstone                       # capstone disassembly\n<CapstoneBlock for 0x401670>\n>>> block.vex                            # VEX IRSB (that's a Python internal address, not a program address)\n<pyvex.block.IRSB at 0x7706330>\n```\n\n----------------------------------------\n\nTITLE: Mounting Host Filesystem in angr Simulation (Python)\nDESCRIPTION: Demonstrates mounting a directory from the host filesystem ('./guest_chroot') into the simulated environment's filesystem root ('/') using `angr.SimHostFilesystem`. This allows the simulated program to interact with files from the specified host directory lazily.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> state.fs.mount('/', angr.SimHostFilesystem('./guest_chroot'))\n```\n\n----------------------------------------\n\nTITLE: Hooking libc Functions in angr\nDESCRIPTION: Use pre-defined hooks for libc functions, which is particularly useful for analyzing statically compiled binaries.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nproj = angr.Project('/path/to/binary', use_sim_procedures=True)\nproj.hook(addr, angr.SIM_PROCEDURES['libc']['atoi']())\n```\n\n----------------------------------------\n\nTITLE: Accessing Symbolic Variables\nDESCRIPTION: Shows how registers can contain symbolic variables (bitvectors with names instead of concrete values), which are the foundation of symbolic execution in angr.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> state.regs.rdi\n<BV64 reg_48_11_64{UNINITIALIZED}>\n```\n\n----------------------------------------\n\nTITLE: Automatic ROP Chain Generation and Patching with angr - Python\nDESCRIPTION: Illustrates automated ROP chain generation using angr and angrop, including binary modification to bypass input checks discovered via symbolic execution. The script instruments binaries by removing validation checks, generates ROP chains, and creates required payloads to pass remaining constraints. This workflow depends on angr, angrop, and Python. Inputs are challenge binaries and the outputs are functional ROP chains suitable for exploitation.\nSOURCE: https://github.com/angr/angr/blob/master/docs/examples.rst#2025-04-23_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# Script author: Yan Shoshitaishvili (github @zardus) and Nilo Redini\n# Script runtime: 2 minutes\n# Concepts presented: automatic ROP chain generation, binary modification, reasoning over constraints, reasoning over action history\n```\n\n----------------------------------------\n\nTITLE: Registering a Default Plugin in angr\nDESCRIPTION: This snippet shows how to register a plugin as a default so it will be automatically instantiated when accessed from a state without explicit registration.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nMyPlugin.register_default('my_plugin')\n```\n\n----------------------------------------\n\nTITLE: Initializing angr Project and Loading DWARF Debug Info - Python\nDESCRIPTION: This snippet shows how to initialize an angr project for a given binary file with debug info loading enabled via the 'load_debug_info' parameter. It also demonstrates invoking 'load_from_dwarf()' to prepare the debug variable resolution feature. Dependencies include angr and a binary containing DWARF debug information. 'project' is the angr project instance.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/debug_var.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> import angr\n>>> project = angr.Project('./examples/debug_var/simple_var', load_debug_info = True)\n>>> project.kb.dvars.load_from_dwarf()\n```\n\n----------------------------------------\n\nTITLE: Setting Stdin During angr State Creation (Python)\nDESCRIPTION: Provides a shortcut method for configuring the standard input (`stdin`) stream when creating an initial angr state using `proj.factory.entry_state()`. By passing a `SimFile` object (or compatible type) to the `stdin` keyword argument, the state's POSIX environment is initialized with the specified input stream. An assert verifies that `state.posix.stdin` points to the provided `simfile`.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> state = proj.factory.entry_state(stdin=simfile)\n>>> assert state.posix.stdin is simfile\n```\n\n----------------------------------------\n\nTITLE: Stepping Simulation until Lambda Condition in angr\nDESCRIPTION: Execute the simulation step by step until a specified lambda expression evaluates to True.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsimgr.step(until=lambda sm: sm.active[0].addr >= first_jmp)\n```\n\n----------------------------------------\n\nTITLE: Reversing Endianness of a Bitvector in Claripy\nDESCRIPTION: Demonstrates how to reverse the byte order of a bitvector. This is useful for converting between different endianness representations.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nx.reversed\n```\n\n----------------------------------------\n\nTITLE: Working with CLE Memory in Python 3\nDESCRIPTION: Example code showing how to produce a C-pointer to a given address in memory using angr's CLE loader and the cffi library. This demonstrates accessing memory backers directly in the new API style.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-8.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cffi, cle\nffi = cffi.FFI()\nld = cle.Loader('/bin/true')\n\naddr = ld.main_object.entry\ntry:\n    backer_start, backer = next(ld.memory.backers(addr))\nexcept StopIteration:\n    raise Exception(\"not mapped\")\n\nif backer_start > addr:\n    raise Exception(\"not mapped\")\n\ncbacker = ffi.from_buffer(backer)\naddr_pointer = cbacker + (addr - backer_start)\n```\n\n----------------------------------------\n\nTITLE: Sample C Program for Debug Variable Demonstration - C\nDESCRIPTION: This C code snippet defines a main function and global/static variables to serve as analysis targets for debug variable resolution via angr. It highlights variable shadowing, pointer usage, and prints variable values to facilitate precise demonstration of debug information recovery. No external dependencies are required other than C standard library for 'printf'.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/debug_var.rst#2025-04-23_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#include<stdio.h>\n\nint global_var = 100;\nint main(void){\n   int a = 10;\n   int* b = &a;\n   printf(\"%d\\n\", *b);\n   {\n      int a = 24;\n      *b = *b + a;\n      int c[] = {5, 6, 7, 8};\n      printf(\"%d\\n\", a);\n   }\n   return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Unsigned Less Than (ULT) Comparison in Claripy\nDESCRIPTION: Demonstrates an unsigned less than comparison between bitvectors. This treats the values as unsigned integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nx.ULT(y)\n```\n\n----------------------------------------\n\nTITLE: Value-Preserving Float/Bitvector Conversions with Claripy in Python\nDESCRIPTION: This snippet demonstrates value-preserving conversions between floating-point and bitvector types using Claripy, similar to type casting in C. It converts a concrete floating-point value `a` (3.2) to a 12-bit bitvector using `val_to_bv(12)`, resulting in truncation (value 3). It then converts this resulting bitvector back to a single-precision float using `val_to_fp(claripy.fp.FSORT_FLOAT)`, yielding 3.0. These methods require specifying the target size or sort.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/solver.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> a\n<FP64 FPV(3.2, DOUBLE)>\n>>> a.val_to_bv(12)\n<BV12 0x3>\n>>> a.val_to_bv(12).val_to_fp(claripy.fp.FSORT_FLOAT)\n<FP32 FPV(3.0, FLOAT)>\n```\n\n----------------------------------------\n\nTITLE: Logical NOT Operation with Claripy\nDESCRIPTION: Shows how to negate a boolean expression. This is equivalent to using the inequality operator in simple cases.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclaripy.Not(x == y)\n```\n\n----------------------------------------\n\nTITLE: Checking if a Value is Symbolic in Claripy\nDESCRIPTION: Demonstrates how to determine if an AST contains any symbolic components. This helps distinguish between concrete and symbolic values in analysis.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nval.symbolic\n```\n\n----------------------------------------\n\nTITLE: Running an Analysis on a Project in angr\nDESCRIPTION: Shows how to instantiate a project and run a previously defined analysis on it. The example demonstrates accessing the analysis results.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/analysis_writing.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> proj = angr.Project(\"/bin/true\")\n>>> mock = proj.analyses.MockAnalysis('this is my option')\n>>> assert mock.option == 'this is my option'\n```\n\n----------------------------------------\n\nTITLE: Discovering Built-in Analyses in angr (Python)\nDESCRIPTION: This snippet shows how to list the available analysis modules within an angr Project object (`proj`). By accessing `proj.analyses.` (and potentially using tab completion in interactive environments like IPython, as suggested by the comment), users can discover the various analyses angr provides, such as CFG, DFG, BackwardSlice, etc. Assumes `proj` is a pre-existing, loaded angr Project object.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> proj.analyses.            # Press TAB here in ipython to get an autocomplete-listing of everything:\n proj.analyses.BackwardSlice        proj.analyses.CongruencyCheck      proj.analyses.reload_analyses\n proj.analyses.BinaryOptimizer      proj.analyses.DDG                  proj.analyses.StaticHooker\n proj.analyses.BinDiff              proj.analyses.DFG                  proj.analyses.VariableRecovery\n proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast\n proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting\n proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG\n proj.analyses.CFGEmulated          proj.analyses.LoopFinder           proj.analyses.VSA_DDG\n proj.analyses.CFGFast              proj.analyses.Reassembler\n```\n\n----------------------------------------\n\nTITLE: Solving HackCon 2016 'angry-reverser' Challenge with angr\nDESCRIPTION: Script to solve the 'angry-reverser' challenge from HackCon 2016 using angr. The script takes about 31 minutes to run.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/more-examples.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Script content not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Inspecting and Modifying SimPackets Content in Python (angr)\nDESCRIPTION: Shows the internal structure of `SimPackets`. Data is stored as a list of (packet data, packet size) tuples in the `.content` attribute. The example first prints the initial content, then performs a read operation (packet 0, size 1 byte, `short_reads=False`), and prints the content again, showing how a new packet entry might be added or modified.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> print(simfile.content)\n[(<BV160 packet_0_mypackets>, <BV64 packetsize_0_mypackets>)]\n\n>>> simfile.read(0, 1, short_reads=False)\n>>> print(simfile.content)\n[(<BV160 packet_0_mypackets>, <BV64 packetsize_0_mypackets>), (<BV8 packet_1_mypackets>, <BV64 0x1>)]\n```\n\n----------------------------------------\n\nTITLE: Getting Symbolic Variable Names in Claripy\nDESCRIPTION: Shows how to retrieve the set of names of all symbolic variables used in an AST. This helps track which input variables affect a particular expression.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nval.variables\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Resilience in Analysis Classes\nDESCRIPTION: Shows how to use the _resilience context manager to handle exceptions gracefully during analysis. This example demonstrates analyzing functions while handling potential errors to ensure partial results are still available.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/analysis_writing.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> class ComplexFunctionAnalysis(angr.Analysis):\n...     def __init__(self):\n...         self._cfg = self.project.analyses.CFG()\n...         self.results = { }\n...         for addr, func in self._cfg.function_manager.functions.items():\n...             with self._resilience():\n...                 if addr % 2 == 0:\n...                     raise ValueError(\"can't handle functions at even addresses\")\n...                 else:\n...                     self.results[addr] = \"GOOD\"\n```\n\n----------------------------------------\n\nTITLE: Working with Streams in angr\nDESCRIPTION: Demonstrates working with SimPackets for handling stream-based I/O like stdin, stdout, and network connections.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsimfile = angr.SimPackets('mypackets')\nsimfile.set_state(state)\n```\n\n----------------------------------------\n\nTITLE: Accessing Project Properties in an Analysis Class\nDESCRIPTION: Demonstrates how to access the project object from within an analysis class using self.project. This example creates a ProjectSummary analysis that reports basic information about the binary.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/analysis_writing.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> class ProjectSummary(angr.Analysis):\n...     def __init__(self):\n...         self.result = 'This project is a %s binary with an entry point at %#x.' % (self.project.arch.name, self.project.entry)\n\n>>> angr.AnalysesHub.register_default('ProjectSummary', ProjectSummary)\n>>> proj = angr.Project(\"/bin/true\")\n\n>>> summary = proj.analyses.ProjectSummary()\n>>> print(summary.result)\nThis project is a AMD64 binary with an entry point at 0x401410.\n```\n\n----------------------------------------\n\nTITLE: Bit Extraction from Bitvectors in Claripy\nDESCRIPTION: Shows how to extract specific bits from a bitvector using Python slice notation. Bits are zero-indexed from the right (least significant bit).\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nx[7:0]\n```\n\n----------------------------------------\n\nTITLE: Logical OR Operation with Claripy\nDESCRIPTION: Demonstrates creating a logical OR constraint between boolean expressions. This is used when at least one of multiple constraints must be satisfied.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclaripy.Or(x == y, y < 10)\n```\n\n----------------------------------------\n\nTITLE: Implementing a User Hook in angr\nDESCRIPTION: Demonstrates how to create a simple user hook at a specific address with a defined length. The hook sets the RAX register to 1 and execution continues 5 bytes after the hooked address.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/simprocedures.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@project.hook(0x1234, length=5)\ndef set_rax(state):\n    state.regs.rax = 1\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Analysis Class in angr\nDESCRIPTION: Demonstrates how to create a simple analysis class by extending angr.Analysis and registering it with the AnalysesHub. This example creates a MockAnalysis that stores a provided option.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/analysis_writing.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import angr\n\n>>> class MockAnalysis(angr.Analysis):\n...     def __init__(self, option):\n...         self.option = option\n\n>>> angr.AnalysesHub.register_default('MockAnalysis', MockAnalysis) # register the class with angr's global analysis list\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Logging in Angr\nDESCRIPTION: Example showing how to enable debug logging for Angr using Python's standard logging module. Demonstrates setting the log level to DEBUG for all Angr components.\nSOURCE: https://github.com/angr/angr/blob/master/docs/faq.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nlogging.getLogger('angr').setLevel('DEBUG')\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Logic with Manual If-Then-Else Construction in angr\nDESCRIPTION: This snippet shows how to implement the merge method for a state plugin by manually constructing an if-then-else tree to combine values from multiple plugin instances based on merge conditions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor other_plugin, condition in zip(others, merge_conditions[1:]): # chop off self's condition\n    self.myvar = claripy.If(condition, other_plugin.myvar, self.myvar)\n```\n\n----------------------------------------\n\nTITLE: Unsigned Greater Than (UGT) Comparison in Claripy\nDESCRIPTION: Demonstrates an unsigned greater than comparison between bitvectors. This treats the values as unsigned integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx.UGT(y)\n```\n\n----------------------------------------\n\nTITLE: Solving Google CTF 'Unbreakable Enterprise Product Activation' Challenge with angr\nDESCRIPTION: Two scripts to solve the 'Unbreakable Enterprise Product Activation' challenge from Google CTF using angr. The scripts run in 4.5 and 6.7 seconds respectively.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/more-examples.rst#2025-04-23_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Script content not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expressions with solver.eval\nDESCRIPTION: Basic solver method to get a single solution to an expression.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval(expression)\n```\n\n----------------------------------------\n\nTITLE: Handling Division by Zero in Z3 with Python\nDESCRIPTION: This code demonstrates an issue with Z3 solver where division by zero produces unexpected results. The example shows how Z3 handles constraints where a variable is divided by zero, resulting in the maximum 32-bit value (4294967295) instead of raising an error.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/gotchas.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> z = z3.Solver()\n>>> a = z3.BitVec('a', 32)\n>>> b = z3.BitVec('b', 32)\n>>> c = z3.BitVec('c', 32)\n>>> z.add(a/b == c)\n>>> z.add(b == 0)\n>>> z.check()\n>>> print(z.model().eval(b), z.model().eval(a/b))\n0 4294967295\n```\n\n----------------------------------------\n\nTITLE: Using LShR Operation in Claripy for Logical Right Shift\nDESCRIPTION: Demonstrates how to perform a logical right shift on a bitvector. Unlike the default arithmetic shift, this operation shifts in zeros from the left regardless of the sign bit.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx.LShR(10)\n```\n\n----------------------------------------\n\nTITLE: Signed Less Than or Equal (SLE) Comparison in Claripy\nDESCRIPTION: Shows how to perform a signed less than or equal comparison between two bitvectors. This treats the values as signed (two's complement) integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nx.SLE(y)\n```\n\n----------------------------------------\n\nTITLE: Solving EKOPARTY CTF 'Fuckzing reverse' Challenge with angr\nDESCRIPTION: Script to solve the 'Fuckzing reverse' challenge from EKOPARTY CTF using angr. The script runs in about 29 seconds and checks a team name against a series of constraints.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/more-examples.rst#2025-04-23_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Script content not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Getting Exact Number of Solutions with solver.eval_exact\nDESCRIPTION: Solver method that returns exactly n solutions, throwing an error if fewer or more are possible.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval_exact(expression, n)\n```\n\n----------------------------------------\n\nTITLE: Dropping Stashes in angr Simulation Manager\nDESCRIPTION: Remove a specific stash from the Simulation Manager to free up memory.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nsimgr.drop(stash=\"avoid\")\n```\n\n----------------------------------------\n\nTITLE: Reading from SimPackets with Short Reads in Python (angr)\nDESCRIPTION: Demonstrates reading data from a `SimPackets` object (`simfile`). The `read` method is called with a starting position (packet number 0), a size (20 bytes), and `short_reads=True`. This allows the read operation to return fewer bytes than requested if the symbolic packet size permits. Asserts verify the length of the returned data (in bits) and the possible concrete values for the actual size read.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> data, actual_size, new_pos = simfile.read(0, 20, short_reads=True)\n>>> assert len(data) == 20*8\n>>> assert set(state.solver.eval_upto(actual_size, 30)) == set(range(21))\n```\n\n----------------------------------------\n\nTITLE: Signed Less Than (SLT) Comparison in Claripy\nDESCRIPTION: Demonstrates a signed less than comparison between bitvectors. This treats the values as signed (two's complement) integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nx.SLT(y)\n```\n\n----------------------------------------\n\nTITLE: Migrating SimuVEX Class References in Python\nDESCRIPTION: Mapping of old SimuVEX class imports to their new locations in Angr 7.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Old imports\nsimuvex.SimState       -> angr.SimState\nsimuvex.SimProcedure   -> angr.SimProcedure\nsimuvex.SimEngine      -> angr.SimEngine\nsimuvex.SimCC          -> angr.SimCC\n```\n\n----------------------------------------\n\nTITLE: Sign Extension of Bitvectors in Claripy\nDESCRIPTION: Shows how to extend a bitvector by padding it with sign bits on the left. This preserves the signed value of the original bitvector.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nx.sign_extend(n)\n```\n\n----------------------------------------\n\nTITLE: Unsigned Less Than or Equal (ULE) Comparison in Claripy\nDESCRIPTION: Shows how to perform an unsigned less than or equal comparison between two bitvectors. This treats the values as unsigned integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nx.ULE(y)\n```\n\n----------------------------------------\n\nTITLE: Working with Relocations in angr's CLE Loader\nDESCRIPTION: This code shows how to examine relocations in loaded objects. Relocations define how import symbols are linked to their corresponding exports, including where addresses should be written in memory and in what format.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/loading.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Relocations don't have a good pretty-printing, so those addresses are Python-internal, unrelated to our program\n>>> proj.loader.shared_objects['libc.so.6'].imports\n{'__libc_enable_secure': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce780>,\n '__tls_get_addr': <cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018358>,\n '_dl_argv': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2e48>,\n '_dl_find_dso_for_object': <cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018588>,\n '_dl_starting_up': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2550>,\n '_rtld_global': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce4e0>,\n '_rtld_global_ro': <cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fcea20>}\n```\n\n----------------------------------------\n\nTITLE: Zero Extension of Bitvectors in Claripy\nDESCRIPTION: Demonstrates extending a bitvector by padding it with zero bits on the left. This preserves the unsigned value of the original bitvector.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nx.zero_extend(n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Minimum Address in Angr Objects\nDESCRIPTION: Demonstrates the API change from using get_min_addr() method to directly accessing the min_addr property on angr objects.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nanything.get_min_addr()\n```\n\n----------------------------------------\n\nTITLE: Rotating Bits Right with RotateRight in Claripy\nDESCRIPTION: Demonstrates rotation of bits to the right. Bits that would be shifted off the right end are placed at the left end.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx.RotateRight(8)\n```\n\n----------------------------------------\n\nTITLE: Unsigned Greater Than or Equal (UGE) Comparison in Claripy\nDESCRIPTION: Shows how to perform an unsigned greater than or equal comparison between two bitvectors. This treats the values as unsigned integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nx.UGE(y)\n```\n\n----------------------------------------\n\nTITLE: Inserting and Retrieving SimFile in angr Filesystem (Python)\nDESCRIPTION: Illustrates adding a `SimFile` object (`simfile`) to the angr state's simulated filesystem (`state.fs`) at the path '/tmp/myfile' using the `insert` method. It then verifies the insertion by retrieving the same file using the `get` method and asserting object identity.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/file_system.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> state.fs.insert('/tmp/myfile', simfile)\n>>> assert state.fs.get('/tmp/myfile') is simfile\n```\n\n----------------------------------------\n\nTITLE: Creating Test Cases for Bug Reports in angr\nDESCRIPTION: Example of how to structure a test case for reporting bugs in angr. The test should reproduce the issue and include an assertion of the expected behavior to verify when the bug is fixed.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/developing.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_some_broken_feature():\n    p = angr.Project(\"some_binary\")\n    result = p.analyses.SomethingThatDoesNotWork()\n    assert result == \"what it should *actually* be if it worked\"\n\nif __name__ == '__main__':\n    test_some_broken_feature()\n```\n\n----------------------------------------\n\nTITLE: Accessing Symbol Addresses in Angr\nDESCRIPTION: Shows the API change from using addr property to linked_addr property when working with symbol objects.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsymbol.addr\n```\n\n----------------------------------------\n\nTITLE: Moving Stashes in angr Simulation Manager\nDESCRIPTION: Transfer states between stashes in the Simulation Manager.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsimgr.stash(from_stash=\"found\", to_stash=\"active\")\n```\n\n----------------------------------------\n\nTITLE: Signed Greater Than (SGT) Comparison in Claripy\nDESCRIPTION: Demonstrates a signed greater than comparison between bitvectors. This treats the values as signed (two's complement) integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nx.SGT(y)\n```\n\n----------------------------------------\n\nTITLE: Signed Greater Than or Equal (SGE) Comparison in Claripy\nDESCRIPTION: Shows how to perform a signed greater than or equal comparison between two bitvectors. This treats the values as signed (two's complement) integers.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nx.SGE(y)\n```\n\n----------------------------------------\n\nTITLE: Alternative Function Documentation Style for angr\nDESCRIPTION: Shows a simpler documentation style for functions in angr, which is preferred for cases where a textual description is more readable than formal parameter documentation.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/developing.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef read_bytes(self, addr, n):\n   \"\"\"\n   Read `n` bytes at address `addr` in memory and return an array of bytes.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Getting Multiple Solutions with solver.eval_upto\nDESCRIPTION: Solver method that returns up to n solutions for an expression.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval_upto(expression, n)\n```\n\n----------------------------------------\n\nTITLE: Using Explorer Technique in SimulationManager\nDESCRIPTION: This code snippet shows the implementation of SimulationManager.explore() method, which is a wrapper around run() that uses the Explorer exploration technique to find paths to target addresses while avoiding others.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnum_find += len(self._stashes[find_stash]) if find_stash in self._stashes else 0\ntech = self.use_technique(Explorer(find, avoid, find_stash, avoid_stash, cfg, num_find))\n\ntry:\n    self.run(stash=stash, n=n, **kwargs)\nfinally:\n    self.remove_technique(tech)\n\nreturn self\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression (If-Then-Else) in Claripy\nDESCRIPTION: Demonstrates how to create a conditional expression that evaluates to one of two values based on a condition. This example shows how to select the maximum of two values.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclaripy.If(x > y, x, y)\n```\n\n----------------------------------------\n\nTITLE: Setting Breakpoint at Specific Memory Address in angr\nDESCRIPTION: Configure a breakpoint to trigger a debug function after a write operation to a specific memory address in angr.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nnew_state.inspect.b('mem_write', mem_write_address=0x6021f1, when=angr.BP_AFTER, action=debug_funcWrite)\n```\n\n----------------------------------------\n\nTITLE: Pulling angr Docker image using Bash\nDESCRIPTION: This command pulls the official angr Docker image from Docker Hub. The image includes angr and its dependencies.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/installing.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull angr/angr\n```\n\n----------------------------------------\n\nTITLE: Using extra_constraints in Solver Methods\nDESCRIPTION: Demonstrates passing additional constraints to solver methods without adding them to the state.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval(expression, extra_constraints=(constraint1, constraint2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Sub-Plugin Merge Logic in angr Hierarchical Plugins\nDESCRIPTION: This snippet demonstrates how to properly merge hierarchical plugins by unwrapping and forwarding merge operations to sub-plugins, maintaining the correct structure of merge conditions and common ancestor.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> def merge(self, others, merge_conditions, common_ancestor=None):\n...     # ... merge self\n...     self.plugin_b.merge([o.plugin_b for o in others], merge_conditions,\n...         common_ancestor=None if common_ancestor is None else common_ancestor.plugin_b)\n```\n\n----------------------------------------\n\nTITLE: Rotating Bits Left with RotateLeft in Claripy\nDESCRIPTION: Shows how to rotate the bits of a bitvector to the left by a specified number of positions. Bits that would be shifted off the left end are placed at the right end.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx.RotateLeft(8)\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Solution with solver.max\nDESCRIPTION: Solver method that returns the maximum possible solution to an expression.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsolver.max(expression)\n```\n\n----------------------------------------\n\nTITLE: Running angr Docker container using Bash\nDESCRIPTION: This command runs the angr Docker container interactively, providing a shell with angr installed and ready to use.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/installing.rst#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it angr/angr\n```\n\n----------------------------------------\n\nTITLE: Logical AND Operation with Claripy\nDESCRIPTION: Shows how to create a logical AND constraint between two boolean expressions. This is useful for combining multiple constraints that must all be satisfied.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclaripy.And(x == y, x > 0)\n```\n\n----------------------------------------\n\nTITLE: Trimming State History in angr\nDESCRIPTION: Demonstrates how to reduce memory usage by trimming a state's history and freeing all data related to old steps, which is useful when analyzing programs with very long paths.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/speed.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstate.history.trim()\n```\n\n----------------------------------------\n\nTITLE: Getting Bitvector Length in Claripy\nDESCRIPTION: Shows how to retrieve the width (in bits) of a bitvector. This is useful for operations that need to know the size of the value they're working with.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/ops.rst#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nval.length\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Solution with solver.min\nDESCRIPTION: Solver method that returns the minimum possible solution to an expression.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nsolver.min(expression)\n```\n\n----------------------------------------\n\nTITLE: Defining RST Table of Contents for angr Documentation\nDESCRIPTION: RST directive that creates a table of contents tree with maximum depth of 1, including key documentation sections for angr's core concepts.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   toplevel\n   loading\n   solver\n   states\n   pathgroups\n   simulation\n   analyses\n   symbolic\n   be_creative\n```\n\n----------------------------------------\n\nTITLE: Evaluating Symbolic Arguments in angr\nDESCRIPTION: Retrieve a concrete string value for a symbolic argument that leads to a specific state.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfound = simgr.found[0] # A state that reached the find condition from explore\nfound.solver.eval(sym_arg, cast_to=bytes) # Return a concrete string value for the sym arg to reach this state\n```\n\n----------------------------------------\n\nTITLE: Installing angr-targets Package\nDESCRIPTION: Commands to clone and install the angr-targets repository which provides the ConcreteTarget implementation needed for Symbion.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/symbion.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/angr/angr-targets.git\ncd angr-targets\npip install .\n```\n\n----------------------------------------\n\nTITLE: Implementing set_state Method for State Access in angr Plugin\nDESCRIPTION: This snippet shows how to override the set_state method in a state plugin to access the state object and perform initialization that requires state context, such as creating symbolic variables.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> def set_state(self, state):\n...     super(SimStatePlugin, self).set_state(state)\n...     self.symbolic_word = claripy.BVS('my_variable', self.state.arch.bits)\n```\n\n----------------------------------------\n\nTITLE: Getting Exactly One Solution with solver.eval_one\nDESCRIPTION: Solver method that returns a single solution but throws an error if multiple solutions are possible.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval_one(expression)\n```\n\n----------------------------------------\n\nTITLE: Installing Test Runners with Pip\nDESCRIPTION: These commands install nose2 and pytest using pip. Either of these tools can be used to run the Angr tests.\nSOURCE: https://github.com/angr/angr/blob/master/tests/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npip install nose2\n```\n\nLANGUAGE: sh\nCODE:\n```\npip install pytest\n```\n\n----------------------------------------\n\nTITLE: Setting Up SIGINT Handler for Debugging in Python\nDESCRIPTION: Implement a signal handler to drop into an IPython shell when Ctrl+C is pressed, allowing for interactive debugging of long-running scripts.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport signal\ndef killmyself():\n    os.system('kill %d' % os.getpid())\ndef sigint_handler(signum, frame):\n    print 'Stopping Execution for Debug. If you want to kill the program issue: killmyself()'\n    if not \"IPython\" in sys.modules:\n        import IPython\n        IPython.embed()\n\nsignal.signal(signal.SIGINT, sigint_handler)\n```\n\n----------------------------------------\n\nTITLE: Auto-dropping Stashes during Exploration in angr\nDESCRIPTION: Automatically drop certain stashes during exploration to manage memory usage in large searches.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsimgr.explore(find=find_addr, avoid=avoid_addr, step_func=lambda lsm: lsm.drop(stash='avoid'))\n```\n\n----------------------------------------\n\nTITLE: Backend Function Pattern - Python\nDESCRIPTION: Demonstrates the naming convention for public and private backend functions. Public functions handle Claripy AST objects while private functions (prefixed with underscore) handle backend-specific objects.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/claripy.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef func():    # public function - handles AST objects\n    pass\n\ndef _func():   # private function - handles backend-specific objects\n    pass\n```\n\n----------------------------------------\n\nTITLE: Getting Minimum Required Solutions with solver.eval_atleast\nDESCRIPTION: Solver method that returns n solutions, throwing an error if fewer than n are possible.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsolver.eval_atleast(expression, n)\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nose2\nDESCRIPTION: This command runs the Angr tests using nose2. It should be executed from the root of the repository.\nSOURCE: https://github.com/angr/angr/blob/master/tests/README.md#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnose2 -s tests\n```\n\n----------------------------------------\n\nTITLE: Unicorn Emulation Finish Log (Log Output)\nDESCRIPTION: This log entry shows the completion of a Unicorn emulation session, including the ending address and the number of steps executed.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nINFO    | 2017-02-25 08:19:48,037 | angr.state_plugins.unicorn | finished emulation at 0x7000080 after 3 steps: STOP_STOPPOINT\n```\n\n----------------------------------------\n\nTITLE: Using claripy.ite_cases Utility for Merge Operations in angr\nDESCRIPTION: This snippet demonstrates how to use the claripy.ite_cases utility function to simplify the implementation of merging plugin data based on merge conditions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/state_plugins.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nself.myvar = claripy.ite_cases(zip(merge_conditions[1:], [o.myvar for o in others]), self.myvar)\n```\n\n----------------------------------------\n\nTITLE: Backend Convert Method Pattern - Python\nDESCRIPTION: Example pattern for the required convert() and _convert() methods that all backends must implement. These methods handle translation between Claripy ASTs and backend-specific formats.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/claripy.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef convert(self, ast_obj):\n    # Handle conversion of Claripy AST objects\n    pass\n\ndef _convert(self, non_ast_obj):\n    # Handle conversion of non-AST objects\n    pass\n```\n\n----------------------------------------\n\nTITLE: Migrating SimuVEX Module References in Python\nDESCRIPTION: Mapping of old SimuVEX module imports to their new locations in Angr 7.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Old imports\nsimuvex.s_cc                    -> angr.calling_conventions\nsimuvex.s_state                 -> angr.sim_state\nsimuvex.s_procedure             -> angr.sim_procedure\nsimuvex.plugins                 -> angr.state_plugins\nsimuvex.engines                 -> angr.engines\nsimuvex.concretization_strategies -> angr.concretization_strategies\n```\n\n----------------------------------------\n\nTITLE: Inspecting Simulation State Immutability in angr (Python)\nDESCRIPTION: This snippet demonstrates accessing the active state in an angr SimulationManager (`simgr`) and inspecting register values (`rip`) after a simulation step. It highlights that the original state (`state`) remains unchanged, illustrating the immutability principle of SimState objects in angr. Assumes `simgr` and `state` are pre-existing angr objects from a previous simulation.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> simgr.active\n[<SimState @ 0x1020300>]\n>>> simgr.active[0].regs.rip                 # new and exciting!\n<BV64 0x1020300>\n>>> state.regs.rip                           # still the same!\n<BV64 0x401670>\n```\n\n----------------------------------------\n\nTITLE: Referencing angr's ExplorationTechnique Class for Path Explosion Mitigation\nDESCRIPTION: This code reference points to the ExplorationTechnique class in angr, which serves as a base for implementing custom techniques to control path explosion in symbolic execution. The reference is formatted as a Python documentation cross-reference.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/helpwanted.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n:py:class:`~angr.exploration_techniques.ExplorationTechnique`\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Pytest\nDESCRIPTION: This command runs the Angr tests using pytest. It can be executed from the root of the repository.\nSOURCE: https://github.com/angr/angr/blob/master/tests/README.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npytest\n```\n\n----------------------------------------\n\nTITLE: Migrating Path References in Python\nDESCRIPTION: Mapping of old Path object references to their new State-based equivalents in Angr 7.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Old path references      -> New state references\npath                    -> state\npath.state              -> state\npath.history            -> state.history\npath.callstack          -> state.callstack\npath.trace              -> state.history.descriptions\npath.addr_trace         -> state.history.bbl_addrs\npath.jumpkinds          -> state.history.jumpkinds\npath.guards             -> state.history.jump_guards\npath.targets            -> state.history.jump_targets\npath.actions            -> state.history.actions\npath.events             -> state.history.events\npath.recent_actions     -> state.history.recent_actions\npath.reachable          -> state.history.reachable()\n```\n\n----------------------------------------\n\nTITLE: Installing build dependencies on Ubuntu using Bash\nDESCRIPTION: This command installs the necessary build dependencies (python development headers, make, and a C compiler) on Ubuntu systems for setting up an angr development environment manually.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/installing.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install python3-dev build-essential\n```\n\n----------------------------------------\n\nTITLE: Illustrating Context Sensitivity with Nested Function Calls - C\nDESCRIPTION: This C code snippet demonstrates multiple call chains with functions invoking each other and outputting messages. Used as an illustrative example in angr documentation, it shows how context sensitivity affects the representation of function call and return paths in a CFG. Inputs and outputs include string literals and function calls; key functions are 'error', 'alpha', 'beta', and 'main', with dependencies on standard I/O (e.g., 'puts'). There are no external library requirements beyond standard C I/O, and the snippet assumes sequential calling without conditional logic.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/cfg.rst#2025-04-23_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nvoid error(char *error)\n{\n    puts(error);\n}\n\nvoid alpha()\n{\n    puts(\"alpha\");\n    error(\"alpha!\");\n}\n\nvoid beta()\n{\n    puts(\"beta\");\n    error(\"beta!\");\n}\n\nvoid main()\n{\n    alpha();\n    beta();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Snapshot Diff Generation\nDESCRIPTION: Shell command to generate and display decompilation snapshot differences locally.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./corpus_tests/scripts/snapshot_diff.sh \\\n  -H snapshot-diff-cli-utility \\\n  -t $(gh auth token)\n```\n\n----------------------------------------\n\nTITLE: Casting Results to String in Solver Methods\nDESCRIPTION: Shows how to cast evaluation results to string representations using the cast_to parameter.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nstate.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)\n```\n\n----------------------------------------\n\nTITLE: Cloning Binaries Repository for Angr Tests\nDESCRIPTION: This command clones the binaries repository required for running Angr tests. It should be executed in the same folder where Angr was cloned.\nSOURCE: https://github.com/angr/angr/blob/master/tests/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/angr/binaries\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging for Simulation Manager in angr\nDESCRIPTION: Set up logging to get debug output from the Simulation Manager during execution.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/cheatsheet.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nlogging.getLogger('angr.sim_manager').setLevel(logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Unicorn Emulation Start Log (Log Output)\nDESCRIPTION: This log output shows the start of Unicorn emulation in angr. It indicates the starting address and the maximum number of steps allowed in Unicorn mode.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nINFO    | 2017-02-25 08:19:48,012 | angr.state_plugins.unicorn | started emulation at 0x4012f9 (1000000 steps)\n```\n\n----------------------------------------\n\nTITLE: Configuring SYMBION_SYNC_CLE Option\nDESCRIPTION: Example of enabling the SYMBION_SYNC_CLE option to synchronize memory mapping between angr and the concrete process.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/symbion.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nentry_state.options.add(angr.options.SYMBION_SYNC_CLE)\nsimgr = project.factory.simgr(state)\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions Event for PR Testing\nDESCRIPTION: JSON configuration file defining parameters for triggering a workflow run against a pull request. Specifies corpus path and pull request branch details.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"inputs\": {\n    \"corpus_github_path\": \"stable/\"\n    \"nightly\": false\n  },\n  \"pull_request\": {\n    \"head\": {\n      \"ref\": \"snapshot-diff-cli-utility\"\n    },\n    \"base\": {\n      \"ref\": \"master\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Loader References in Python\nDESCRIPTION: Mapping of old CLE loader references to their new equivalents in Angr 7.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/migration-7.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Old loader references           -> New loader references\nloader.whats_at()                -> loader.describe_addr\nloader.addr_belongs_to_object()  -> loader.find_object_containing()\nloader.find_symbol_name()        -> loader.find_symbol().name\nloader.find_module_name()        -> loader.find_object_containing().provides\nloader.find_symbol_got_entry()   -> loader.find_relevant_relocations()\nloader.main_bin                  -> loader.main_object\n```\n\n----------------------------------------\n\nTITLE: Unicorn Empty Page Fetch Warning (Log Output)\nDESCRIPTION: This warning log shows an attempt to fetch an empty memory page during Unicorn emulation, which can lead to execution bouncing out of Unicorn mode.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nWARNING | 2017-02-25 08:19:48,082 | angr.state_plugins.unicorn | fetching empty page [0x0, 0xfff]\nINFO    | 2017-02-25 08:19:48,103 | angr.state_plugins.unicorn | finished emulation at 0x401777 after 1 steps: STOP_EXECNONE\n```\n\n----------------------------------------\n\nTITLE: Configuring SYMBION_KEEP_STUBS_ON_SYNC Option\nDESCRIPTION: Example of enabling the SYMBION_KEEP_STUBS_ON_SYNC option to control SimProcedure hooking behavior for external functions.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/symbion.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nentry_state.options.add(angr.options.SYMBION_KEEP_STUBS_ON_SYNC)\nsimgr = project.factory.simgr(state)\n```\n\n----------------------------------------\n\nTITLE: Pytest Integration for Snapshot Testing\nDESCRIPTION: Implementation of pytest fixtures and test functions for comparing decompilation snapshots using pytest-insta framework.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef test_decompilation(binary, snapshot):\n    \"\"\"\n    In order to accommodate insta's need to have snapshots stored in a single\n    file directly in the local `./snapshots/` directory, but also allow a\n    reasonable comparison with the snapshots repo using github's pull request\n    comparison, we pull down each snapshot from deeper within the snapshot\n    repo's directory structure, but place it with a flat name (path delimiters\n    replaced) in the `./snapshots/`, tweaking it to work with the standard\n    way `pytest-insta` works (see `pytest_insta_snapshot_name()` above).\n\n    Note that the snapshot should already be downloaded (by the workflow or\n    manually) and placed in the snapshots directory. The name should be\n    'corpus__decompilation__<binary-subpath-/-escaped>.json.txt__0.txt'. For\n    example, the binary 'binaries/my/path/binary.exe' should be named\n    'corpus__decompilation__my_path_binary.exe.json.txt__0.txt' in the\n    local `./snapshots/` directory.\n\n    This needs to stay in sync with the code that downloads the snapshots\n    in `corpus_test.yml`.\n    \"\"\"\n    decompilation = analyze_binary(binary)\n    if not decompilation:\n        # Message already emitted.\n        return False\n\n    # Adds newlines after each newline literal '\\\\n'.\n    diffable_decompilation = create_diffable_decompilation(decompilation)\n\n    # This replaces path delimiters with underscores and appends \".json.txt\".\n    snapshot_name = pytest_insta_snapshot_name(binary)\n\n    print(f'Loading snapshot \"{snapshot_name}\".')\n    assert snapshot(snapshot_name) == diffable_decompilation\n```\n\n----------------------------------------\n\nTITLE: IPython Configuration for Better Performance\nDESCRIPTION: A workaround for slow tab completion in IPython when working with angr. This code can be placed in IPython profile's startup directory to disable jedi-based completion for better performance.\nSOURCE: https://github.com/angr/angr/blob/master/docs/core-concepts/toplevel.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Drop this file in IPython profile's startup directory to avoid running it every time.\nimport IPython\npy = IPython.get_ipython()\npy.Completer.use_jedi = False\n```\n\n----------------------------------------\n\nTITLE: Unicorn Cooldown Logs (Log Output)\nDESCRIPTION: These log entries demonstrate the cooldown mechanism in angr's Unicorn integration, which prevents frequent transitions between angr and Unicorn execution modes.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nINFO    | 2017-02-25 08:19:48,120 | angr.engines.unicorn_engine | not enough runs since last unicorn (100)\nINFO    | 2017-02-25 08:19:48,125 | angr.engines.unicorn_engine | not enough runs since last unicorn (99)\n```\n\n----------------------------------------\n\nTITLE: Environment Configuration Variables\nDESCRIPTION: Shell environment variables used to configure the GitHub integration for corpus and snapshot repositories.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# points to the github repo that contains the corpus for testing\nCORPUS_GITHUB_OWNER=\"project-purcellville\"\nCORPUS_GITHUB_REPO=\"direct-file-store-0000\"\nCORPUS_GITHUB_PATH=\"cgc-binaries\" # or a subset via \"cgc-binaries/linux-build/challenges\"\n\n# points to the github repo that contains the snapshots of the decompilation output\nSNAPSHOT_GITHUB_OWNER=\"project-purcellville\"\nSNAPSHOT_GITHUB_REPO=\"snapshots-0000\"\nSNAPSHOTS_PAT=<YOUR-PERSONAL-ACCESS-TOKEN-FOR-SNAPSHOTS-REPO>  # As a secret.\n```\n\n----------------------------------------\n\nTITLE: Fetching Repository Tree Structure by SHA with GitHub API in Shell\nDESCRIPTION: This shell code snippet utilizes curl to fetch the recursive file tree of a repository for a specific directory SHA using the GitHub REST API endpoint. It requires the same authentication details and headers as previous queries, and needs the SHA (TREE_SHA) obtained from a prior metadata request. The response is a JSON object detailing the directory's file hierarchy, which is useful for automating mass retrieval of files in workflows. Dependencies are identical: curl, a GitHub token, and correct endpoint and SHA.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncurl -L \\\n  -H \"Accept: application/vnd.github+json\" \\\n  -H \"Authorization: Bearer <YOUR-TOKEN>\" \\\n  -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n  https://api.github.com/repos/OWNER/REPO/git/trees/TREE_SHA\n```\n\n----------------------------------------\n\nTITLE: Unicorn Memory Mapping Logs (Log Output)\nDESCRIPTION: These log entries show how angr maps memory for Unicorn emulation. It includes the memory ranges, permissions, and whether the memory contains symbolic data.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/pipeline.rst#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nINFO    | 2017-02-25 08:19:48,014 | angr.state_plugins.unicorn | mmap [0x401000, 0x401fff], 5 (symbolic)\nINFO    | 2017-02-25 08:19:48,016 | angr.state_plugins.unicorn | mmap [0x7fffffffffe0000, 0x7fffffffffeffff], 3 (symbolic)\nINFO    | 2017-02-25 08:19:48,019 | angr.state_plugins.unicorn | mmap [0x6010000, 0x601ffff], 3\nINFO    | 2017-02-25 08:19:48,022 | angr.state_plugins.unicorn | mmap [0x602000, 0x602fff], 3 (symbolic)\nINFO    | 2017-02-25 08:19:48,023 | angr.state_plugins.unicorn | mmap [0x400000, 0x400fff], 5\nINFO    | 2017-02-25 08:19:48,025 | angr.state_plugins.unicorn | mmap [0x7000000, 0x7000fff], 5\n```\n\n----------------------------------------\n\nTITLE: Creating a Table of Contents for Advanced Angr Topics in reStructuredText\nDESCRIPTION: This code creates a table of contents using reStructuredText syntax to organize documentation on advanced angr topics. It uses the toctree directive with maxdepth set to 1 to list various documentation pages without showing their subsections.\nSOURCE: https://github.com/angr/angr/blob/master/docs/advanced-topics/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   gotchas\n   pipeline\n   mixins\n   speed\n   file_system\n   ir\n   structured_data\n   claripy\n   concretization_strategies\n   java_support\n   symbion\n   debug_var\n```\n\n----------------------------------------\n\nTITLE: Executing Local GitHub Actions Workflow\nDESCRIPTION: Shell command to run the corpus test workflow locally using act tool. Sets up authentication tokens and event configuration.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsudo $(which act) \\\n  -W .github/workflows/corpus_test.yml \\\n  --eventpath pr.event \\\n  -s GITHUB_TOKEN=\"$(gh auth token)\" \\\n  -s SNAPSHOTS_PAT=\"$(gh auth token)\" \\\n  workflow_call\n```\n\n----------------------------------------\n\nTITLE: Example of Function Documentation Using Sphinx RST Format\nDESCRIPTION: Demonstrates how to document functions in angr using Sphinx-compatible ReStructured Text format. Includes parameter descriptions, return values, and type information with proper formatting.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/developing.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef prune(self, filter_func=None, from_stash=None, to_stash=None):\n    \"\"\"\n    Prune unsatisfiable paths from a stash.\n\n    :param filter_func: Only prune paths that match this filter.\n    :param from_stash:  Prune paths from this stash. (default: 'active')\n    :param to_stash:    Put pruned paths in this stash. (default: 'pruned')\n    :returns:           The resulting PathGroup.\n    :rtype:             PathGroup\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Requesting Repository Directory Metadata with GitHub API in Shell\nDESCRIPTION: This shell snippet demonstrates how to use curl with authentication and custom headers to query the metadata (including SHA and details) about a specific directory in a GitHub repository via the GitHub REST API. Required dependencies are curl and a valid GitHub token (GITHUB_TOKEN or personal access token). The primary parameters are the API endpoint, repository owner, repo name, and directory path as well as the reference branch. The output is JSON metadata for the requested path, which includes the SHA necessary for subsequent tree queries.\nSOURCE: https://github.com/angr/angr/blob/master/corpus_tests/README.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncurl -L \\\n  -H \"Accept: application/vnd.github+json\" \\\n  -H \"Authorization: Bearer <YOUR-TOKEN>\" \\\n  -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n  https://api.github.com/repos/OWNER/REPO/content/PATH?ref=main\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for angr Extension Documentation in reStructuredText\nDESCRIPTION: This snippet creates a table of contents using reStructuredText syntax. It defines a toctree directive with a maximum depth of 1 and lists several documentation pages related to extending angr.\nSOURCE: https://github.com/angr/angr/blob/master/docs/extending-angr/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   simprocedures\n   state_plugins\n   environment\n   analysis_writing\n```\n\n----------------------------------------\n\nTITLE: Citing angr in Academic Work using BibTeX\nDESCRIPTION: BibTeX entries for citing the key papers related to angr's development in academic work. Includes citations for the state-of-the-art offensive techniques, Driller for augmenting fuzzing, and Firmalice for detecting authentication bypass vulnerabilities.\nSOURCE: https://github.com/angr/angr/blob/master/docs/quickstart.rst#2025-04-23_snippet_0\n\nLANGUAGE: bibtex\nCODE:\n```\n@article{shoshitaishvili2016state,\n  title={SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis},\n  author={Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Audrey and Grosen, Jessie and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},\n  booktitle={IEEE Symposium on Security and Privacy},\n  year={2016}\n}\n\n@article{stephens2016driller,\n  title={Driller: Augmenting Fuzzing Through Selective Symbolic Execution},\n  author={Stephens, Nick and Grosen, Jessie and Salls, Christopher and Dutcher, Audrey and Wang, Ruoyu and Corbetta, Jacopo and Shoshitaishvili, Yan and Kruegel, Christopher and Vigna, Giovanni},\n  booktitle={NDSS},\n  year={2016}\n}\n\n@article{shoshitaishvili2015firmalice,\n  title={Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware},\n  author={Shoshitaishvili, Yan and Wang, Ruoyu and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},\n  booktitle={NDSS},\n  year={2015}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sphinx Table of Contents in RST\nDESCRIPTION: Creates a table of contents tree using Sphinx toctree directive, setting maximum depth to 1 and listing documentation sections under the Appendix heading.\nSOURCE: https://github.com/angr/angr/blob/master/docs/appendix/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   cheatsheet\n   ops\n   options\n   more-examples\n   changelog\n   migration-9.1\n   migration-8\n   migration-7\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation Toctree for Angr\nDESCRIPTION: ReStructuredText configuration for the documentation table of contents, setting up navigation for getting started guides with a maximum depth of 1 level.\nSOURCE: https://github.com/angr/angr/blob/master/docs/getting-started/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   installing\n   developing\n   helpwanted\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents for angr Analysis Documentation in reStructuredText\nDESCRIPTION: A reStructuredText directive that creates a table of contents pointing to documentation for angr's built-in analysis capabilities, with a maximum depth of 1 level. The links point to documentation for CFG analysis, backward slicing, identifier analysis, and the decompiler.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 1\n\n   cfg\n   backward_slice\n   identifier\n   decompiler\n```\n\n----------------------------------------\n\nTITLE: Creating CFG-only BackwardSlice in angr\nDESCRIPTION: Simplified example showing how to create a BackwardSlice using only CFG without data dependence graph, useful when DDG generation is difficult or unnecessary.\nSOURCE: https://github.com/angr/angr/blob/master/docs/analyses/backward_slice.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbs = b.analyses.BackwardSlice(cfg, control_flow_slice=True)\nBackwardSlice (to [(<CFGNode exit (0x10000a0) [0]>, -1)])\n```"
  }
]