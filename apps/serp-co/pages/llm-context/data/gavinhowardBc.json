[
  {
    "owner": "gavinhoward",
    "repo": "bc",
    "content": "TITLE: Function Definition\nDESCRIPTION: Defines the syntax for function definitions in bc, including parameter lists, auto variables, statements, and return values.  It outlines the standard structure using 'define', the function name 'I', parameter list, auto variables, statements, and a return expression. It also mentions non-portable extensions related to brace placement and return statement variations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in bc\nDESCRIPTION: This snippet demonstrates how to define a function in bc. It shows the general structure, including parameter declaration, automatic variable declaration, a sequence of statements, and a return statement. Array parameters can be defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Shell aliases for number conversion using bc\nDESCRIPTION: Demonstrates how to create shell aliases that invoke bc with the -e option to set ibase and obase, effectively creating number conversion tools. The examples show aliases for converting from decimal to octal (d2o) and hexadecimal to binary (h2b).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Functions in BC\nDESCRIPTION: This snippet demonstrates the use of several built-in functions in BC, including `sqrt`, `length`, `abs`, and `scale`. It shows how these functions can be used to perform mathematical operations, determine string lengths, find absolute values, and set the scale of arithmetic operations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\ni += 4\ni\n\nsqrt(i *= 4)\ni\nlength(i /= 2)\ni\n\ni = 4\nscale(i /= 2)\ni\n\ni = -1\n\nabs(i--)\nabs(--i)\nabs(++i)\nabs(i++)\n\ni = -i\n```\n\n----------------------------------------\n\nTITLE: Subtracting BclNumber objects in C\nDESCRIPTION: Subtracts BclNumber 'b' from 'a' and returns the result. The scale of the result is the maximum of the scales of 'a' and 'b'.  'a' and 'b' are consumed after the operation unless the `_keep` variant is used. The function can return errors such as invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_sub(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Array Access and Increment/Decrement in BC\nDESCRIPTION: This snippet demonstrates array access and the use of increment/decrement operators within array indices. It showcases how the order of operations affects the evaluation of array elements and the subsequent modification of the variable `i`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\ni = 0\n\na[i++] += ++i\ni--\ni--\ni\na[i]\n\na[i]++\na[i]--\n++a[i]\n--a[i]\n```\n\n----------------------------------------\n\nTITLE: Increment and Decrement Operators in BC\nDESCRIPTION: This snippet demonstrates the use of increment (++) and decrement (--) operators in BC, both as prefix and postfix operators. The code shows how these operators modify the value of the variable `i` and how the order of operations affects the result.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ni++\ni--\n++i\n--i\n\n(i++)\n(i--)\n(++i)\n(--i)\n```\n\n----------------------------------------\n\nTITLE: Initializing and processing array (a1) in BC\nDESCRIPTION: This function, `a1`, initializes the provided array `a[]` from index 0 to `len-1` with values corresponding to their index. After initialization, it calls function `a2` to square each array element and finally calls `printarray` to display the array elements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine a1(*a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = i\n\t}\n\n\ta2(a[], len)\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Global Stacks Example Function\nDESCRIPTION: This bc(1) code snippet demonstrates the use of the `-g` or `--global-stacks` option, which turns `ibase`, `obase`, `scale`, and `seed` into stacks. This allows functions to modify these global variables without affecting other functions.  The example shows how the `output` function can be simplified using global stacks.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n obase=b\n x\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplying BclNumber objects in C\nDESCRIPTION: Multiplies two BclNumber objects, 'a' and 'b', and returns the result. The scale of the result is determined by the scales of 'a' and 'b' along with the current context's scale. 'a' and 'b' are consumed after the operation unless the `_keep` variant is used. Potential errors include invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_mul(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Square Root Calculation with bc\nDESCRIPTION: This snippet demonstrates how to calculate the square root of numbers using the `sqrt()` function in the `bc` calculator. It showcases a range of inputs, including integers, floating-point numbers, and very small values. The `scale` variable controls the number of digits after the decimal point.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/sqrt.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nscale = 20\nsqrt(0)\nsqrt(1)\nsqrt(1.00000000000)\nsqrt(2)\nsqrt(4)\nsqrt(9)\nsqrt(16)\nsqrt(25)\nsqrt(121)\nsqrt(48765)\nsqrt(9287356207356)\nsqrt(0.189274385967238956872354)\nsqrt(12389467137496823.134567829387456283946)\nsqrt(.0000000000000000000000000000123)\nsqrt(1)\nscale = 0;\nsqrt(1407)\nsqrt(79101)\nscale = 6; sqrt(88.1247699921300025847737099094480986051698668662822009535526240)\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND example\nDESCRIPTION: Demonstrates the bitwise AND operation between two numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\nband(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Function Definition Syntax in bc\nDESCRIPTION: Defines the general syntax for function definitions in bc, including parameter lists, auto variables, statements, and return values.  It shows the structure and components of a user-defined function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition in bc\nDESCRIPTION: Defines the general syntax for function definitions in the bc calculator language.  It outlines the structure including the 'define' keyword, parameter list, auto variable declarations, statements, and the return statement. The syntax allows for array parameters and array references, with specific rules on using asterisks for array references.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functions in bc\nDESCRIPTION: This code shows the standard syntax for defining a function in bc. Parameters and auto variables can be declared as arrays using I[]. Parameters can also be declared as array references using *I[].\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean AND Operator\nDESCRIPTION: This snippet showcases the boolean AND operator '&&' which returns true (typically 1) if and only if both operands are true (non-zero). Otherwise, it returns false (typically 0). Integer literals are treated as boolean values where non-zero is true and zero is false.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_1\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n4 && 5\n4 && 0\n0 && 5\n4 && 5 && 7\n4 && 0 && 7\n0 && 5 && 7\n4 && 5 && 0\n0 && 0 && 7\n4 && 0 && 0\n0 && 5 && 0\n```\n\n----------------------------------------\n\nTITLE: Multiplication with Scale\nDESCRIPTION: This snippet sets the scale to 10 and then performs a multiplication operation between two large decimal numbers.  'scale' defines the number of digits after the decimal point. The result will be displayed with 10 decimal places.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nscale=10;123981239.981273987 * 12983791827398.29836472638\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR example\nDESCRIPTION: Demonstrates the bitwise OR operation between two numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\nbor(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Defining a function with global stacks in bc\nDESCRIPTION: This code snippet demonstrates how to define a function `output(x, b)` that prints `x` in base `b` when the `-g` or `--global-stacks` option is used.  It showcases how the `obase` is set without affecting other functions. The example shows the difference using auto variable, vs letting the global stack manage the original obase.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    obase=b\n    x\n}\n```\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    auto c\n    c=obase\n    obase=b\n    x\n    obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Printing an array in BC\nDESCRIPTION: This function, `printarray`, iterates through the provided array `a[]` from index 0 to `len-1` and prints the value of each element. It takes an array `a[]` and its length `len` as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine printarray(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: BC Array Assignment and Access with Float Index\nDESCRIPTION: This snippet shows assignment and potential implicit printing of array elements in BC.  First, a[5] is assigned the value 2. Next, a[5.789] is accessed which demonstrates BC's handling of floating point array indices. BC truncates the floating point index, effectively accessing a[5] again.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arrays.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\na[5] = 2\na[5.789]\n```\n\n----------------------------------------\n\nTITLE: Array Reference Definition in bc\nDESCRIPTION: Shows how array references are declared in bc function parameters.  When an array parameter is declared as `*I[]`, modifications made to the array within the function will reflect on the original array passed in. This demonstrates pass-by-reference behavior for arrays in bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Division with Variables and Scale\nDESCRIPTION: This snippet defines a scale, assigns decimal numbers to variables 'a' and 'b', divides 'a' by 'b', and assigns the result to 'c'.  Finally, it prints the value of 'c' to the standard output. The 'scale' is set to 100, so the division will have 100 digits after the decimal point.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\nscale=100;a=739534985.895347284957;b=238746782364.2374623784; c = a / b; c\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (64-bit) example\nDESCRIPTION: Demonstrates the bitwise NOT operation on a 64-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_8\n\nLANGUAGE: N/A\nCODE:\n```\nbnot64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Assigning and Printing String Variables in bc\nDESCRIPTION: This snippet assigns a string to two variables, `v` and `u`, and then prints the values of both variables, followed by a newline.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\nv = u = \"test assign\\n\"\nprint v, u\n```\n\n----------------------------------------\n\nTITLE: Calculating Absolute Values with abs() in bc\nDESCRIPTION: This snippet demonstrates the `abs()` function in `bc` to calculate absolute values. It showcases usage with integers, floating-point numbers (positive and negative). The bc language is an arbitrary precision calculator language.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/abs.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nabs(0)\nabs(1)\nabs(.289365)\nabs(289.82937658)\nabs(-19)\nabs(-.2098180)\nabs(-198289.1098376)\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling the 'stuff' Function in BC\nDESCRIPTION: This code defines a function named 'stuff' that takes one argument 'x' and prints the string \"x: \" followed by the value of 'x' and a newline character. Then, it calls the 'stuff' function with various numerical arguments (integer and floating-point).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/void.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void stuff(x) {\n\tprint \"x: \", x, \"\\n\"\n}\n\nstuff(0)\nstuff(1)\nstuff(2.2839)\nstuff(-9.9289389)\n```\n\n----------------------------------------\n\nTITLE: While Loop in BC\nDESCRIPTION: This snippet demonstrates the use of a while loop in BC. It shows how to repeatedly execute a block of code as long as a specified condition is true. The example shows how the condition is evaluated and how the loop continues until the condition becomes false.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_7\n\nLANGUAGE: BC\nCODE:\n```\ni = 3\n\nwhile (i -= 2) print \"i: \", i += 1, \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo Operation (16-bit)\nDESCRIPTION: Performs a bitwise modulo operation on a 16-bit integer. The function `bmod16` calculates the modulo of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_97\n\nLANGUAGE: C\nCODE:\n```\nbmod16(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation\nDESCRIPTION: Demonstrates the bitwise OR operation (bor) on integers. The function takes two arguments: the two integers to be ORed. It performs a bitwise OR operation, where each bit in the result is 1 if either of the corresponding bits in the input integers is 1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_173\n\nLANGUAGE: N/A\nCODE:\n```\nbor(869320618226679840, 15779715921992018698)\nbor(11784620717065408517, 14976544843797949497)\n```\n\n----------------------------------------\n\nTITLE: Example function definition with global stacks in bc\nDESCRIPTION: This code snippet demonstrates how to define a function named output(x, b) that prints x in base b using the -g or --global-stacks option. The example showcases the use of bc(1)'s arbitrary precision calculator with global stacks enabled.  When the -g flag is used, functions can assign to ibase, obase, scale, and seed without affecting other functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    obase=b\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: BC Exponential Function Calculation\nDESCRIPTION: This snippet demonstrates how to calculate the exponential value using the 'e()' function in BC. It showcases various positive, negative, and fractional input values to illustrate the function's behavior and output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/exponent.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ne(0)\ne(0.5)\ne(1)\ne(1.5)\ne(1.74)\ne(2)\ne(3.2345)\ne(5.283957)\ne(13.23857)\ne(100)\ne(283.238957)\ne(-0.5)\ne(-1)\ne(-1.5)\ne(-1.74)\ne(-2)\ne(-3.2345)\ne(-5.283957)\ne(-13.23857)\ne(-100)\ne(-283.238957)\ne(142.749502399)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left Operation\nDESCRIPTION: Demonstrates the bitwise rotate left operation (brol) on integers of different sizes (8, 16, 32, and 64 bits). The function takes two arguments: the integer to be rotated and the number of bits to rotate. It shifts the bits of the first argument to the left by the specified number of bits, with the bits that fall off the left end being re-inserted on the right end. Each function (brol8, brol16, brol32, brol64) is specific to the size of the integer being operated on.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_169\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(6960136430480362150, 11351650405755785491)\nbrol8(166, 11351650405755785491)\nbrol8(6960136430480362150, 19)\nbrol8(166, 19)\nbrol16(6960136430480362150, 11351650405755785491)\nbrol16(35494, 11351650405755785491)\nbrol16(6960136430480362150, 4371)\nbrol16(35494, 4371)\nbrol32(6960136430480362150, 11351650405755785491)\nbrol32(118065830, 11351650405755785491)\nbrol32(6960136430480362150, 2172522771)\nbrol32(118065830, 2172522771)\nbrol64(6960136430480362150, 11351650405755785491)\nbrol8(869320618226679840, 15779715921992018698)\nbrol8(32, 15779715921992018698)\nbrol8(869320618226679840, 10)\nbrol8(32, 10)\nbrol16(869320618226679840, 15779715921992018698)\nbrol16(32, 15779715921992018698)\nbrol16(869320618226679840, 60170)\nbrol16(32, 60170)\nbrol32(869320618226679840, 15779715921992018698)\nbrol32(357761056, 15779715921992018698)\nbrol32(869320618226679840, 3404262154)\nbrol32(357761056, 3404262154)\nbrol64(869320618226679840, 15779715921992018698)\nbrol8(11784620717065408517, 14976544843797949497)\nbrol8(5, 14976544843797949497)\nbrol8(11784620717065408517, 57)\nbrol8(5, 57)\nbrol16(11784620717065408517, 14976544843797949497)\nbrol16(36869, 14976544843797949497)\nbrol16(11784620717065408517, 60473)\nbrol16(36869, 60473)\nbrol32(11784620717065408517, 14976544843797949497)\nbrol32(3311702021, 14976544843797949497)\nbrol32(11784620717065408517, 2974346297)\nbrol32(3311702021, 2974346297)\nbrol64(11784620717065408517, 14976544843797949497)\n```\n\n----------------------------------------\n\nTITLE: Using the length() Function in bc\nDESCRIPTION: This snippet demonstrates using the built-in `length()` function in bc to determine the length of a string literal and a string variable.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nlength(\"ouch\")\nlength(v)\n```\n\n----------------------------------------\n\nTITLE: Defining a function without -g (global-stacks) option\nDESCRIPTION: This snippet illustrates how to define the `output(x, b)` function without using the `-g` or `--global-stacks` option. It demonstrates the manual saving and restoring of the `obase` global variable to avoid unintended side effects on other functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    auto c\n    c=obase\n    obase=b\n    x\n    obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: BC Array Element Addition with Computed Index\nDESCRIPTION: This snippet demonstrates addition of array elements where the indices are computed using arithmetic expressions. It adds a[2-1] to itself, using 2-1 to access the array element at index 1. BC evaluates the expression inside the brackets before accessing the array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arrays.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\na[2-1]+a[2-1]\n```\n\n----------------------------------------\n\nTITLE: Complex Nested Conditionals and Loops C\nDESCRIPTION: This code snippet demonstrates a complex nesting of 'if' statements and 'for' loops. An outer 'if' statement controls the execution of an outer 'for' loop, which contains another 'if' statement that then controls an inner 'for' loop. This inner loop contains a final 'if' condition and executes '4' if all conditions are true.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/stdin2.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nif (6 < 7) for (j = 0; j < 3; ++j) if (5 < 6) for (i = 0; i < 3; ++i) if (4 < 5) 4\n```\n\n----------------------------------------\n\nTITLE: Setting Scale in BC\nDESCRIPTION: This snippet demonstrates how to set the scale in BC using the `scale()` function. The scale determines the number of digits after the decimal point for arithmetic operations. Different values are used as arguments to the function, showing various ways the scale can be set.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scale.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nscale(0)\nscale(1)\nscale(12)\nscale(123)\nscale(1234)\nscale(12345)\nscale(123456)\nscale(1234567)\nscale(12345678)\nscale(123456789)\nscale(1234567890)\nscale(1.0)\nscale(12.0)\nscale(123.0)\nscale(1234.0)\nscale(12345.0)\nscale(123456.0)\nscale(1234567.0)\nscale(12345678.0)\nscale(123456789.0)\nscale(1234567890.0)\nscale(.1)\nscale(.12)\nscale(.123)\nscale(.1234)\nscale(.12345)\nscale(.123456)\nscale(.1234567)\nscale(.12345678)\nscale(.123456789)\nscale(.1234567890)\nscale(.01)\nscale(.012)\nscale(.0123)\nscale(.01234)\nscale(.012345)\nscale(.0123456)\nscale(.01234567)\nscale(.012345678)\nscale(.0123456789)\nscale(.01234567890)\nscale(.0000000001)\nscale(.00000000012)\nscale(.000000000123)\nscale(.0000000001234)\nscale(.00000000012345)\nscale(.000000000123456)\nscale(.0000000001234567)\nscale(.00000000012345678)\nscale(.000000000123456789)\nscale(.0000000001234567890)\nscale(289.29837)\nscale(2893.00000)\nscale(289.0)\nscale(1802973.0000000238)\nscale(.000000000000000093182394080000000000)\nscale(0.00000000000000000000)\n```\n\n----------------------------------------\n\nTITLE: Setting Scale and Dividing Numbers in BC\nDESCRIPTION: This snippet demonstrates setting the `scale` variable to control the precision of calculations in `bc`. It then performs division operations using the `divmod` function, which computes both the quotient and remainder and stores it in an array. Finally, it prints the quotient, which is the first element of the array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divmod.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nscale = 20\nv = divmod(0, 1, v[]); v[0]; v\nv = divmod(0, 321566, v[]); v[0]; v\nv = divmod(0, 0.3984567238456, v[]); v[0]; v\nv = divmod(1, 1, v[]); v[0]; v\nv = divmod(1, 1287469297356, v[]); v[0]; v\nv = divmod(1, 0.2395672438567234, v[]); v[0]; v\nv = divmod(1, 237586239856.0293596728392360, v[]); v[0]; v\nv = divmod(1249687284356, 3027949207835207, v[]); v[0]; v\nv = divmod(378617298617396719, 35748521, v[]); v[0]; v\nv = divmod(9348576237845624358, 0.9857829375461, v[]); v[0]; v\nv = divmod(35768293846193284, 2374568947.045762839567823, v[]); v[0]; v\nv = divmod(-78987234567812345, 876542837618936, v[]); v[0]; v\nv = divmod(-356789237555535468, 0.3375273860984786903, v[]); v[0]; v\nv = divmod(-5203475364850390, 435742903748307.70869378534043296404530458, v[]); v[0]; v\nv = divmod(-0.37861723347576903, 7385770896, v[]); v[0]; v\nv = divmod(-0.399454682043962, 0.34824389304, v[]); v[0]; v\nv = divmod(-0.6920414523873204, 356489645223.76076045304879030, v[]); v[0]; v\nv = divmod(-35872917389671.7573280963748, 73924708, v[]); v[0]; v\nv = divmod(-78375896314.4836709876983, 0.78356798637817, v[]); v[0]; v\nv = divmod(-2374123896417.143789621437581, 347821469423789.1473856783960, v[]); v[0]; v\nv = divmod(-896729350238549726, -34976289345762, v[]); v[0]; v\nv = divmod(-2374568293458762348596, -0.8792370647234987679, v[]); v[0]; v\nv = divmod(-237584692306721845726038, -21783910782374529637.978102738746189024761, v[]); v[0]; v\nv = divmod(-0.23457980123576298375682, -1375486293874612, v[]); v[0]; v\nv = divmod(-0.173897061862478951264, -0.8179327486017634987516298745, v[]); v[0]; v\nv = divmod(-0.9186739823576829347586, -0.235678293458756239846, v[]); v[0]; v\nv = divmod(-0.9375896183746982374568, -13784962873546.0928729395476283745, v[]); v[0]; v\nv = divmod(-2930754618923467.12323745862937465, -734869238465, v[]); v[0]; v\nv = divmod(-23745861923467.874675129834675, -0.23542357869124756, v[]); v[0]; v\nv = divmod(-3878923750692883.7238596702834756902, -7384192674957215364986723.9738461923487621983, v[]); v[0]; v\nv = divmod(1, 0.00000000000000000000000000000000000000000002346728372937352457354204563027, v[]); v[0]; v\n```\n\n----------------------------------------\n\nTITLE: Void Function Definition\nDESCRIPTION: Defines the syntax for void functions in bc. These functions do not return a value and are intended for use as standalone expressions.  It outlines the structure for a void function, specifying 'define void', function name 'I', parameter list, auto variables, statements, and a return statement (or omission thereof).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Square Root with Keep in BclNumber (bcl_sqrt_keep)\nDESCRIPTION: This function calculates the square root of BclNumber *a* and returns the result. The scale of the result is equal to the scale of the current context. *a* cannot be negative. Possible errors can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_sqrt_keep(BclNumber* _a_**)\n```\n\n----------------------------------------\n\nTITLE: While Loop with Compound Condition\nDESCRIPTION: This snippet demonstrates a while loop with a compound condition using '&&' (AND). The loop continues as long as 'q' is not equal to 0 AND 'x' is equal to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_9\n\nLANGUAGE: bc\nCODE:\n```\nwhile (q!=0 && x==0) { ++q; }\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Decimal Value\nDESCRIPTION: Illustrates bitwise right shift operations on the decimal number 1.1, with shift amounts ranging from 0 to 19. This demonstrates how the '>>' operator functions with decimal values in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\n1.1 >> 0\n```\n\n----------------------------------------\n\nTITLE: Shell Aliases for Number Conversion\nDESCRIPTION: These shell aliases provide examples of how to use `bc` for number conversion when the global stack option (`-g`) is used. The aliases demonstrate how to set `ibase` and `obase` to convert between different number bases, such as decimal to octal and hexadecimal to binary.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Addition of Large Numbers\nDESCRIPTION: This snippet adds two very large numbers (including decimal portions).  It doesn't specify a 'scale', so the default scale will be used. The default scale is usually 0, therefore, the fractional part will be truncated.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\n34895734986539489834759837489573498573.398475984759837485734987598345 + 9823749832749872384234872934.28347982374987239847982374\n```\n\n----------------------------------------\n\nTITLE: GCD Calculation in bc\nDESCRIPTION: This snippet shows how to calculate the Greatest Common Divisor (GCD) using bc.  The GCD function is called with two integer arguments.  The output of bc will be the GCD of the two numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_gcd.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ngcd(285, 35)\n```\n\nLANGUAGE: bc\nCODE:\n```\ngcd(1, 6)\n```\n\nLANGUAGE: bc\nCODE:\n```\ngcd(5, 1)\n```\n\nLANGUAGE: bc\nCODE:\n```\ngcd(8, 12)\n```\n\nLANGUAGE: bc\nCODE:\n```\ngcd(40, 4096)\n```\n\n----------------------------------------\n\nTITLE: Natural Logarithm Calculation (BC Math Library)\nDESCRIPTION: This code snippet illustrates the series used in the bc math library to calculate ln(x). It utilizes the series a + a^3/3 + a^5/5 + ... (where a = (x - 1)/(x + 1)) for small x and the relation ln(x^2) = 2 * ln(x) to reduce x.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/algorithms.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\na + a^3/3 + a^5/5 + ...\n\n```\n\nLANGUAGE: text\nCODE:\n```\nln(x^2) = 2 * ln(x)\n\n```\n\n----------------------------------------\n\nTITLE: Built-in Functions in BC\nDESCRIPTION: Shows how to use the built-in functions `length`, `sqrt`, and `scale`.  scale is first used to set a variable and later used as function that sets the scale.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_7\n\nLANGUAGE: BC\nCODE:\n```\nlength(2381)\nsqrt(9)\nscale(238.1)\nx=2\nx[0]=3\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression in bc\nDESCRIPTION: This snippet shows an arithmetic expression involving multiplication, subtraction, and potentially large numbers in bc. The expression calculates a value by performing these operations sequentially.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n4.1*1.-13^ - 74 - 1284597623841*1.-13^ - 757\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation\nDESCRIPTION: Performs a bitwise XOR operation between two 64-bit integers. The function `bxor` takes two numerical arguments and returns the result of the XOR operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_77\n\nLANGUAGE: C\nCODE:\n```\nbxor(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Left Shift Operation\nDESCRIPTION: Demonstrates the bitwise left shift operation (bshl) with a 32-bit integer argument and a shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_143\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(2815553780, 26)\n```\n\n----------------------------------------\n\nTITLE: Reading Standard Input\nDESCRIPTION: Reads a line from standard input and executes it. This allows macros to request input from users.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_15\n\nLANGUAGE: dc\nCODE:\n```\n?\n```\n\n----------------------------------------\n\nTITLE: Looping and Conditional Execution in C\nDESCRIPTION: This C code snippet demonstrates a 'for' loop iterating 'A' times, with nested 'if' and 'else' statements that determine which code block is executed based on boolean conditions. The loop prints \"n\", then executes different code blocks based on nested if statements.  Finally, it prints the value of the iterator 'i'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc3.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfor (i = 0; i < A; ++i)\n{print \"n\"\nif(1)if(1){3\n}\nif(0)if(1){3\n}\nelse 4\nif(0){if(1){3\n}}\nelse 5\n{i}\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Example\nDESCRIPTION: Demonstrates the bitwise AND operation (`band`) between two 64-bit integers.  The operation performs a logical AND on each corresponding pair of bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_102\n\nLANGUAGE: N/A\nCODE:\n```\nband(15629579542790190053, 11001744205379253724)\n```\n\n----------------------------------------\n\nTITLE: Compound Assignment Operators in BC\nDESCRIPTION: This snippet demonstrates the use of compound assignment operators in BC, such as `+=`, `-=`, `*=`, and `/=`. These operators combine an arithmetic operation with an assignment, providing a shorthand way to modify a variable's value. The snippet also demonstrates the use of negative numbers in assignment.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\ni += 1\ni\ni -= -4\ni\ni *= 5\ni\ni /= 12.5\ni\n\ni = 0\n\n(i += 1)\n(i -= -4)\n(i *= 5)\n(i /= 12.5)\n```\n\n----------------------------------------\n\nTITLE: Alternative function definition without global stacks in bc\nDESCRIPTION: This code snippet shows how to define the same output(x, b) function, printing x in base b, but without using the -g or --global-stacks option.  It illustrates manually saving and restoring the obase variable to avoid unintended side effects on other functions. The auto keyword declares a local variable c to store the original value of obase.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    auto c\n    c=obase\n    obase=b\n    x\n    obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Void Function Definition in bc\nDESCRIPTION: Defines the syntax for defining a void function in bc. Void functions cannot return values and are invoked as standalone expressions. The return statement can be omitted or can take the form `return` or `return ()`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: If-Else Statements in BC\nDESCRIPTION: This snippet demonstrates the use of if-else statements in BC. It shows how to evaluate a conditional expression and execute different blocks of code based on whether the condition is true or false. In BC, any non-zero value is considered true, and zero is considered false.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_6\n\nLANGUAGE: BC\nCODE:\n```\ni = 1\n\nif (i -= 1) print \"true\\n\"\nelse print \"false\\n\"\n\nif (i += 1) print \"true\\n\"\nelse print \"false\\n\"\n```\n\n----------------------------------------\n\nTITLE: Defining Functions in BC\nDESCRIPTION: This snippet demonstrates how to define functions in BC using the `define` keyword. Each function is defined with its name and a block of code to be executed. The functions `w`, `x`, `y`, `z`, and `v` are defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine w() { auto z; return 1; }\ndefine x() {\n\t\"x\"\n\treturn (1)\n}\ndefine y() {\n\t\"y\"\n\treturn (2)\n}\ndefine z() {\n\t\"z\"\n\treturn (3)\n}\n\ndefine v() { return }\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse Operation\nDESCRIPTION: Demonstrates the bitwise reverse operation (brev) on integers of different sizes (8, 16, 32, and 64 bits). This operation reverses the order of the bits in the input integer. Each function (brev8, brev16, brev32, brev64) is specific to the size of the integer being operated on.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_168\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(6960136430480362150)\nbrev8(166)\nbrev16(6960136430480362150)\nbrev16(35494)\nbrev32(6960136430480362150)\nbrev32(118065830)\nbrev64(6960136430480362150)\nbrev8(869320618226679840)\nbrev8(32)\nbrev16(869320618226679840)\nbrev16(32)\nbrev32(869320618226679840)\nbrev32(357761056)\nbrev64(869320618226679840)\nbrev8(11784620717065408517)\nbrev8(5)\nbrev16(11784620717065408517)\nbrev16(36869)\nbrev32(11784620717065408517)\nbrev32(3311702021)\nbrev64(11784620717065408517)\n```\n\n----------------------------------------\n\nTITLE: Defining a bc function\nDESCRIPTION: This code snippet shows the general structure for defining functions in bc, including parameter lists, auto variables, statements, and return values. The 'I' represents an identifier for variable or array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Calling BC Function 'y'\nDESCRIPTION: These are examples of calling the 'y' function with different sets of input parameters. Each call will execute the function 'y' as defined above, using the given arguments to compute and return a value. These calls demonstrate how to use a defined function within 'bc'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/functions.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ny(1, 4)\ny(2, 4)\ny(3, 4)\ny(4, 3)\ny(3, 2)\n```\n\n----------------------------------------\n\nTITLE: Calling Functions in BC\nDESCRIPTION: This snippet calls previously defined functions `v` and `w`. Calling a function executes the code block defined within it. These calls illustrate the basic function invocation in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\nv()\n\nw()\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation\nDESCRIPTION: Demonstrates the bitwise AND operation (band) on integers. The function takes two arguments: the two integers to be ANDed. It performs a bitwise AND operation, where each bit in the result is 1 only if the corresponding bits in both input integers are 1. \nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_172\n\nLANGUAGE: N/A\nCODE:\n```\nband(869320618226679840, 15779715921992018698)\nband(11784620717065408517, 14976544843797949497)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (32-bit)\nDESCRIPTION: Rotates the bits of a 32-bit number to the left by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_130\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Displaying Limits\nDESCRIPTION: This snippet demonstrates the 'limits' command in bc, which displays various limits of the bc implementation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\nlimits\n```\n\n----------------------------------------\n\nTITLE: Function Definition with Global Stacks\nDESCRIPTION: This code snippet demonstrates how to define a function `output(x, b)` that prints `x` in base `b` using the `-g` or `--global-stacks` option. This option enables the use of global stacks for `ibase`, `obase`, and `scale`, making it easier to write functions that modify these variables without affecting other functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    obase=b\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (16-bit)\nDESCRIPTION: Reverses the bits of a 16-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_125\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Floating Point Number\nDESCRIPTION: Performs a bitwise right shift operation on a floating-point number.  The floating-point number is shifted by an integer value, which represents the number of bits to shift. This operation effectively divides the number by 2 raised to the power of the shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n0.0000001 >> 8\n```\n\n----------------------------------------\n\nTITLE: BC Program Logic and Conditional Printing\nDESCRIPTION: This BC code initializes variables, calls `prnt` and `prnt2` functions conditionally based on `i` and `maxobase()`, and prints specific strings when the conditions are not met. The loop continues modifying the value of `i` and deciding to use functions or print strings based on `maxobase()`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/print2.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\na = 999999999999999999999999999999999999\nb = a + 1\nc = b + 1\n\ni = 100\ni = prnt(i)\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 084 044 021 047 096 073 015 052 088 014 072 097 047 021 094 051 083\\e\\n 000\\n\"\n\tprint \" 084 044 021 047 096 073 015 052 088 014 072 097 047 021 094 051 083\\e\\n 001\\n\"\n\tprint \" 084 044 021 047 096 073 015 052 088 014 072 097 047 021 094 051 083\\e\\n 002\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 001 012 066 220 495 792 924 792 495 220 066 012 000\\n\"\n\tprint \" 001 012 066 220 495 792 924 792 495 220 066 012 001\\n\"\n\tprint \" 001 012 066 220 495 792 924 792 495 220 066 012 002\\n\"\n\tprint \" 999 999 999 999 999 999 999 999 999 999 999 999\\n\"\n\tprint \" 001 000 000 000 000 000 000 000 000 000 000 000 000\\n\"\n\tprint \" 001 000 000 000 000 000 000 000 000 000 000 000 001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 0989 0065 0781 0494 0209 0923 0209 0494 0781 0065 0989 0000\\n\"\n\tprint \" 0989 0065 0781 0494 0209 0923 0209 0494 0781 0065 0989 0001\\n\"\n\tprint \" 0989 0065 0781 0494 0209 0923 0209 0494 0781 0065 0989 0002\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 0001 0009 0036 0084 0126 0126 0084 0036 0009 0000\\n\"\n\tprint \" 0001 0009 0036 0084 0126 0126 0084 0036 0009 0001\\n\"\n\tprint \" 0001 0009 0036 0084 0126 0126 0084 0036 0009 0002\\n\"\n\tprint \" 9999 9999 9999 9999 9999 9999 9999 9999 9999\\n\"\n\tprint \" 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000\\n\"\n\tprint \" 0001 0000 0000 0000 0000 0000 0000 0000 0000 0001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 09992 00035 09917 00125 09875 00083 09965 00008 09999\\n\"\n\tprint \" 09992 00035 09917 00125 09875 00083 09965 00008 10000\\n\"\n\tprint \" 09992 00035 09917 00125 09875 00083 09965 00009 00000\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 00010 00070 00210 00350 00350 00210 00070 00009\\n\"\n\tprint \" 00010 00070 00210 00350 00350 00210 00070 00010\\n\"\n\tprint \" 00010 00070 00210 00350 00350 00210 00070 00011\\n\"\n\tprint \" 00009 99999 99999 99999 99999 99999 99999 99999\\n\"\n\tprint \" 00010 00000 00000 00000 00000 00000 00000 00000\\n\"\n\tprint \" 00010 00000 00000 00000 00000 00000 00000 00001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 000009 099931 000209 099651 000349 099791 000069 099990\\n\"\n\tprint \" 000009 099931 000209 099651 000349 099791 000069 099991\\n\"\n\tprint \" 000009 099931 000209 099651 000349 099791 000069 099992\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 000001 000006 000015 000020 000015 000006 000000\\n\"\n\tprint \" 000001 000006 000015 000020 000015 000006 000001\\n\"\n\tprint \" 000001 000006 000015 000020 000015 000006 000002\\n\"\n\tprint \" 999999 999999 999999 999999 999999 999999\\n\"\n\tprint \" 000001 000000 000000 000000 000000 000000 000000\\n\"\n\tprint \" 000001 000000 000000 000000 000000 000000 000001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 0999995 0000014 0999981 0000014 0999995 0000000\\n\"\n\tprint \" 0999995 0000014 0999981 0000014 0999995 0000001\\n\"\n\tprint \" 0999995 0000014 0999981 0000014 0999995 0000002\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 0000010 0000050 0000100 0000100 0000050 0000009\\n\"\n\tprint \" 0000010 0000050 0000100 0000100 0000050 0000010\\n\"\n\tprint \" 0000010 0000050 0000100 0000100 0000050 0000011\\n\"\n\tprint \" 0000009 9999999 9999999 9999999 9999999 9999999\\n\"\n\tprint \" 0000010 0000000 0000000 0000000 0000000 0000000\\n\"\n\tprint \" 0000010 0000000 0000000 0000000 0000000 0000001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 00000009 09999951 00000099 09999901 00000049 09999990\\n\"\n\tprint \" 00000009 09999951 00000099 09999901 00000049 09999991\\n\"\n\tprint \" 00000009 09999951 00000099 09999901 00000049 09999992\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 00010000 00040000 00060000 00040000 00009999\\n\"\n\tprint \" 00010000 00040000 00060000 00040000 00010000\\n\"\n\tprint \" 00010000 00040000 00060000 00040000 00010001\\n\"\n\tprint \" 00009999 99999999 99999999 99999999 99999999\\n\"\n\tprint \" 00010000 00000000 00000000 00000000 00000000\\n\"\n\tprint \" 00010000 00000000 00000000 00000000 00000001\\n\"\n}\n\nif (i + 1 <= maxobase()) {\n\ti = prnt2(i)\n}\nelse {\n\tprint \" 000009999 099960001 000059999 099960001 000009999\\n\"\n\tprint \" 000009999 099960001 000059999 099960001 000010000\\n\"\n\tprint \" 000009999 099960001 000059999 099960001 000010001\\n\"\n\tprint \"\\n\"\n\ti *= 10\n}\n\nif (i <= maxobase()) {\n\ti = prnt(i)\n}\nelse {\n\tprint \" 000000001 000000004 000000006 000000004 000000000\\n\"\n\tprint \" 000000001 000000004 000000006 000000004 000000001\\n\"\n\tprint \" 000000001 000000004 000000006 000000004 000000002\\n\"\n\tprint \" 999999999 999999999 999999999 999999999\\n\"\n\tprint \" 000000001 000000000 000000000 000000000 000000000\\n\"\n\tprint \" 000000001 000000000 000000000 000000000 000000001\\n\"\n}\n```\n\n----------------------------------------\n\nTITLE: bc(1) Shell Aliases for Number Conversion\nDESCRIPTION: Example shell aliases that use bc(1) to perform number base conversions. These aliases demonstrate how to set the `ibase` (input base) and `obase` (output base) using the `-e` (expression) option to create simple conversion tools.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right Operation (32-bit)\nDESCRIPTION: Performs a bitwise rotate right operation on a 32-bit integer. The function `bror32` rotates the bits to the right by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_94\n\nLANGUAGE: C\nCODE:\n```\nbror32(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (32-bit) Example\nDESCRIPTION: Demonstrates the bitwise reverse operation (`brev32`) on a 32-bit integer. The operation reverses the order of the bits in the input value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_113\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(3708754108241877138)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift With Incremental Decimal Places\nDESCRIPTION: Demonstrates bitwise right shift operations on the numbers 1.001, 1.0001, 1.00001, 1.000001, 1.0000001, 1.00000001, 1.000000001 and 1.0000000001. The number of bits shifted ranges from 0 to 19 in each case.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\n1.001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.0001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.00001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.0000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.00000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.000000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n1.0000000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Function Call Examples in BC\nDESCRIPTION: Demonstrates calling the user-defined function `x` with different arguments and combining it with arithmetic operations and array accesses. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nx ( 7 )\nx + x( 8 )\nx - x[0]\n```\n\n----------------------------------------\n\nTITLE: Shell Aliases for Number Conversion - Bash/bc\nDESCRIPTION: This snippet provides examples of shell aliases that use `bc` to convert numbers between different bases.  The `d2o` alias converts decimal to octal, and the `h2b` alias converts hexadecimal to binary. These aliases use `-e` to execute `bc` commands. Dependencies include `bash` shell and `bc` command.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation\nDESCRIPTION: Demonstrates the bitwise AND operation (band) with two 64-bit integer arguments.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_140\n\nLANGUAGE: N/A\nCODE:\n```\nband(16527427662727213300, 6651564814332221722)\n```\n\n----------------------------------------\n\nTITLE: Calculating Digits or String Length in dc\nDESCRIPTION: Pops a value off the stack. If it's a number, calculates and pushes the number of significant decimal digits. Pushes 1 if the argument is 0 with no decimal places. If it's a string, pushes the number of characters.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_19\n\nLANGUAGE: dc\nCODE:\n```\nZ\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Larger Integer\nDESCRIPTION: Illustrates bitwise right shift operations with the integer 10, with shift amounts varying from 0 to 19. This shows the effect of different shift amounts on a larger integer value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\n10 >> 0\n```\n\n----------------------------------------\n\nTITLE: Setting Precision and Initial Calculation in BC\nDESCRIPTION: This snippet initializes the scale (precision) to 25, calculates 'p' as 4 times the value of a(1), and then sets the scale to 20 for subsequent calculations using the function 's'. The 'a' function is assumed to be defined elsewhere in the BC environment. The variable 'p' is used in later calculations with the 's' function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/sine.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nscale = 25\np = 4 * a(1)\nscale = 20\n```\n\n----------------------------------------\n\nTITLE: Array operations with BC\nDESCRIPTION: This code segment initializes 'len' to 16 and then calls a series of functions (a1, a3, a5, a7) on arrays a[], b[], a253[], a254[], a255[], and a256[], followed by calls to printarray to display the array content. It also initializes a large number of array elements to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\nlen = 16\n\na1(a[], len)\nprintarray(a[], len)\na3(a[], len)\nprintarray(a[], len)\na5(a[], len)\nprintarray(a[], len)\na7(a[], len)\nprintarray(a[], len)\n\na1(b[], len)\nprintarray(b[], len)\na3(b[], len)\nprintarray(b[], len)\na5(b[], len)\nprintarray(b[], len)\na7(b[], len)\nprintarray(b[], len)\n\na1[0] = 0\na2[0] = 0\na3[0] = 0\na4[0] = 0\na5[0] = 0\na6[0] = 0\na7[0] = 0\na8[0] = 0\na9[0] = 0\na10[0] = 0\na11[0] = 0\na12[0] = 0\na13[0] = 0\na14[0] = 0\na15[0] = 0\na16[0] = 0\na17[0] = 0\na18[0] = 0\na19[0] = 0\na20[0] = 0\na21[0] = 0\na22[0] = 0\na23[0] = 0\na24[0] = 0\na25[0] = 0\na26[0] = 0\na27[0] = 0\na28[0] = 0\na29[0] = 0\na30[0] = 0\na31[0] = 0\na32[0] = 0\na33[0] = 0\na34[0] = 0\na35[0] = 0\na36[0] = 0\na37[0] = 0\na38[0] = 0\na39[0] = 0\na40[0] = 0\na41[0] = 0\na42[0] = 0\na43[0] = 0\na44[0] = 0\na45[0] = 0\na46[0] = 0\na47[0] = 0\na48[0] = 0\na49[0] = 0\na50[0] = 0\na51[0] = 0\na52[0] = 0\na53[0] = 0\na54[0] = 0\na55[0] = 0\na56[0] = 0\na57[0] = 0\na58[0] = 0\na59[0] = 0\na60[0] = 0\na61[0] = 0\na62[0] = 0\na63[0] = 0\na64[0] = 0\na65[0] = 0\na66[0] = 0\na67[0] = 0\na68[0] = 0\na69[0] = 0\na70[0] = 0\na71[0] = 0\na72[0] = 0\na73[0] = 0\na74[0] = 0\na75[0] = 0\na76[0] = 0\na77[0] = 0\na78[0] = 0\na79[0] = 0\na80[0] = 0\na81[0] = 0\na82[0] = 0\na83[0] = 0\na84[0] = 0\na85[0] = 0\na86[0] = 0\na87[0] = 0\na88[0] = 0\na89[0] = 0\na90[0] = 0\na91[0] = 0\na92[0] = 0\na93[0] = 0\na94[0] = 0\na95[0] = 0\na96[0] = 0\na97[0] = 0\na98[0] = 0\na99[0] = 0\na100[0] = 0\na101[0] = 0\na102[0] = 0\na103[0] = 0\na104[0] = 0\na105[0] = 0\na106[0] = 0\na107[0] = 0\na108[0] = 0\na109[0] = 0\na110[0] = 0\na111[0] = 0\na112[0] = 0\na113[0] = 0\na114[0] = 0\na115[0] = 0\na116[0] = 0\na117[0] = 0\na118[0] = 0\na119[0] = 0\na120[0] = 0\na121[0] = 0\na122[0] = 0\na123[0] = 0\na124[0] = 0\na125[0] = 0\na126[0] = 0\na127[0] = 0\na128[0] = 0\na129[0] = 0\na130[0] = 0\na131[0] = 0\na132[0] = 0\na133[0] = 0\na134[0] = 0\na135[0] = 0\na136[0] = 0\na137[0] = 0\na138[0] = 0\na139[0] = 0\na140[0] = 0\na141[0] = 0\na142[0] = 0\na143[0] = 0\na144[0] = 0\na145[0] = 0\na146[0] = 0\na147[0] = 0\na148[0] = 0\na149[0] = 0\na150[0] = 0\na151[0] = 0\na152[0] = 0\na153[0] = 0\na154[0] = 0\na155[0] = 0\na156[0] = 0\na157[0] = 0\na158[0] = 0\na159[0] = 0\na160[0] = 0\na161[0] = 0\na162[0] = 0\na163[0] = 0\na164[0] = 0\na165[0] = 0\na166[0] = 0\na167[0] = 0\na168[0] = 0\na169[0] = 0\na170[0] = 0\na171[0] = 0\na172[0] = 0\na173[0] = 0\na174[0] = 0\na175[0] = 0\na176[0] = 0\na177[0] = 0\na178[0] = 0\na179[0] = 0\na180[0] = 0\na181[0] = 0\na182[0] = 0\na183[0] = 0\na184[0] = 0\na185[0] = 0\na186[0] = 0\na187[0] = 0\na188[0] = 0\na189[0] = 0\na190[0] = 0\na191[0] = 0\na192[0] = 0\na193[0] = 0\na194[0] = 0\na195[0] = 0\na196[0] = 0\na197[0] = 0\na198[0] = 0\na199[0] = 0\na200[0] = 0\na201[0] = 0\na202[0] = 0\na203[0] = 0\na204[0] = 0\na205[0] = 0\na206[0] = 0\na207[0] = 0\na208[0] = 0\na209[0] = 0\na210[0] = 0\na211[0] = 0\na212[0] = 0\na213[0] = 0\na214[0] = 0\na215[0] = 0\na216[0] = 0\na217[0] = 0\na218[0] = 0\na219[0] = 0\na220[0] = 0\na221[0] = 0\na222[0] = 0\na223[0] = 0\na224[0] = 0\na225[0] = 0\na226[0] = 0\na227[0] = 0\na228[0] = 0\na229[0] = 0\na230[0] = 0\na231[0] = 0\na232[0] = 0\na233[0] = 0\na234[0] = 0\na235[0] = 0\na236[0] = 0\na237[0] = 0\na238[0] = 0\na239[0] = 0\na240[0] = 0\na241[0] = 0\na242[0] = 0\na243[0] = 0\na244[0] = 0\na245[0] = 0\na246[0] = 0\na247[0] = 0\na248[0] = 0\na249[0] = 0\na250[0] = 0\na251[0] = 0\na252[0] = 0\na253[0] = 0\na254[0] = 0\na255[0] = 0\na256[0] = 0\n\na1(a253[], len)\nprintarray(a253[], len)\na3(a253[], len)\nprintarray(a253[], len)\na5(a253[], len)\nprintarray(a253[], len)\na7(a253[], len)\nprintarray(a253[], len)\n\na1(a254[], len)\nprintarray(a254[], len)\na3(a254[], len)\nprintarray(a254[], len)\na5(a254[], len)\nprintarray(a254[], len)\na7(a254[], len)\nprintarray(a254[], len)\n\na1(a255[], len)\nprintarray(a255[], len)\na3(a255[], len)\nprintarray(a255[], len)\na5(a255[], len)\nprintarray(a255[], len)\na7(a255[], len)\nprintarray(a255[], len)\n\na1(a256[], len)\nprintarray(a256[], len)\na3(a256[], len)\nprintarray(a256[], len)\na5(a256[], len)\nprintarray(a256[], len)\na7(a256[], len)\nprintarray(a256[], len)\n```\n\n----------------------------------------\n\nTITLE: While Loop with Conditional Continue\nDESCRIPTION: This snippet shows a while loop in bc that increments 'q' and uses 'continue' to skip the rest of the loop if 'q' is equal to 0. It is important to note that q is not initialized prior to comparison. After the while loop, the 'last' command is executed, likely to exit another enclosing loop construct if present.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nwhile (q==0) { ++q; continue; }\nlast\n```\n\n----------------------------------------\n\nTITLE: Complex Boolean Expression\nDESCRIPTION: This snippet contains a complex boolean expression involving multiple relational operators, AND, and OR.  It is designed to test the precedence and associativity of these operators within the boolean logic evaluation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_7\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n1 <= 0 && 1 <= 2 || 1 >= 0 && 1 == 2\n1 <= 0 && 1 <= 2 || 1 >= 0 && 1 != 2\n1 >= 0 && 1 <= 2 || 1 >= 0 && 1 == 2\n```\n\n----------------------------------------\n\nTITLE: Conditional Statement\nDESCRIPTION: This snippet shows an if-else statement in bc, assigning different values to the variable 'x' based on the value of 'q'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\nif (q!=0) { x=3; } else { x=4; }\n```\n\n----------------------------------------\n\nTITLE: BC Array Assignment with Integer Index\nDESCRIPTION: This snippet demonstrates how to assign integer values to array elements using integer indices in BC. The array is denoted by 'a', and the index is specified within square brackets. This sets the value of a[0] to 1 and a[1] (from 2-1) to 2.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arrays.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\na[0] = 1\na[2-1] = 2\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right Operation\nDESCRIPTION: Demonstrates the bitwise rotate right operation (bror) on integers of different sizes (8, 16, 32, and 64 bits). The function takes two arguments: the integer to be rotated and the number of bits to rotate. It shifts the bits of the first argument to the right by the specified number of bits, with the bits that fall off the right end being re-inserted on the left end. Each function (bror8, bror16, bror32, bror64) is specific to the size of the integer being operated on.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_170\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(6960136430480362150, 11351650405755785491)\nbror8(166, 11351650405755785491)\nbror8(6960136430480362150, 19)\nbror8(166, 19)\nbror16(6960136430480362150, 11351650405755785491)\nbror16(35494, 11351650405755785491)\nbror16(6960136430480362150, 4371)\nbror16(35494, 4371)\nbror32(6960136430480362150, 11351650405755785491)\nbror32(118065830, 11351650405755785491)\nbror32(6960136430480362150, 2172522771)\nbror32(118065830, 2172522771)\nbror64(6960136430480362150, 11351650405755785491)\nbror8(869320618226679840, 15779715921992018698)\nbror8(32, 15779715921992018698)\nbror8(869320618226679840, 10)\nbror8(32, 10)\nbror16(869320618226679840, 15779715921992018698)\nbror16(32, 15779715921992018698)\nbror16(869320618226679840, 60170)\nbror16(32, 60170)\nbror32(869320618226679840, 15779715921992018698)\nbror32(357761056, 15779715921992018698)\nbror32(869320618226679840, 3404262154)\nbror32(357761056, 3404262154)\nbror64(869320618226679840, 15779715921992018698)\nbror8(11784620717065408517, 14976544843797949497)\nbror8(5, 14976544843797949497)\nbror8(11784620717065408517, 57)\nbror8(5, 57)\nbror16(11784620717065408517, 14976544843797949497)\nbror16(36869, 14976544843797949497)\nbror16(11784620717065408517, 60473)\nbror16(36869, 60473)\nbror32(11784620717065408517, 14976544843797949497)\nbror32(3311702021, 14976544843797949497)\nbror32(11784620717065408517, 2974346297)\nbror32(3311702021, 2974346297)\nbror64(11784620717065408517, 14976544843797949497)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (32-bit) example\nDESCRIPTION: Demonstrates the bitwise reverse operation on a 32-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_11\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Defining a Void Function in bc\nDESCRIPTION: This snippet shows how to define a void function in bc. Void functions are standalone expressions that can be used, except in a print statement. They can omit the return statement or use `return` or `return ()`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Output Base Conversion in bc\nDESCRIPTION: This snippet sets the output base to 9 using the `obase` variable in bc. Subsequent calculations will be displayed in base 9.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nobase = 9\n```\n\n----------------------------------------\n\nTITLE: Dot Variable Assignment and Access in BC\nDESCRIPTION: Shows how to use and access the dot (.) variable. The dot variable holds the last result. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_12\n\nLANGUAGE: BC\nCODE:\n```\n. = 150\n.\n```\n\n----------------------------------------\n\nTITLE: For Loop in BC\nDESCRIPTION: This snippet demonstrates the use of a for loop in BC. It shows how to initialize a loop variable, specify a condition for continuing the loop, and update the loop variable after each iteration. The example shows how to use multiple variables in the initialization and update expressions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_8\n\nLANGUAGE: BC\nCODE:\n```\na = 5\n\nfor (i = 5; i-= 1; --a) print \"i: \", i, \"; a: \", a, \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (8-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate right operation (bror8) on an 8-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_157\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(244, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(16527427662727213300, 26)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(244, 26)\n```\n\n----------------------------------------\n\nTITLE: Testing length() with Numeric Values in BC\nDESCRIPTION: This snippet tests the `length()` function in BC with a wide range of numeric inputs, including integers and decimal numbers with varying precision. It aims to verify the function's correct behavior across different numeric formats.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/length.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nlength(0)\nlength(0.0000)\nlength(0.00000000)\nlength(0.00000000000)\nlength(1)\nlength(12)\nlength(123)\nlength(1234)\nlength(12345)\nlength(123456)\nlength(1234567)\nlength(12345678)\nlength(123456789)\nlength(1234567890)\nlength(1.0)\nlength(12.0)\nlength(123.0)\nlength(1234.0)\nlength(12345.0)\nlength(123456.0)\nlength(1234567.0)\nlength(12345678.0)\nlength(123456789.0)\nlength(1234567890.0)\nlength(.1)\nlength(.12)\nlength(.123)\nlength(.1234)\nlength(.12345)\nlength(.123456)\nlength(.1234567)\nlength(.12345678)\nlength(.123456789)\nlength(.1234567890)\nlength(.01)\nlength(.012)\nlength(.0123)\nlength(.01234)\nlength(.012345)\nlength(.0123456)\nlength(.01234567)\nlength(.012345678)\nlength(.0123456789)\nlength(.01234567890)\nlength(.001)\nlength(.0012)\nlength(.00123)\nlength(.001234)\nlength(.0012345)\nlength(.00123456)\nlength(.001234567)\nlength(.0012345678)\nlength(.00123456789)\nlength(.001234567890)\nlength(.0001)\nlength(.00012)\nlength(.000123)\nlength(.0001234)\nlength(.00012345)\nlength(.000123456)\nlength(.0001234567)\nlength(.00012345678)\nlength(.000123456789)\nlength(.0001234567890)\nlength(.00001)\nlength(.000012)\nlength(.0000123)\nlength(.00001234)\nlength(.000012345)\nlength(.0000123456)\nlength(.00001234567)\nlength(.000012345678)\nlength(.0000123456789)\nlength(.00001234567890)\nlength(.000001)\nlength(.0000012)\nlength(.00000123)\nlength(.000001234)\nlength(.0000012345)\nlength(.00000123456)\nlength(.000001234567)\nlength(.0000012345678)\nlength(.00000123456789)\nlength(.000001234567890)\nlength(.0000001)\nlength(.00000012)\nlength(.000000123)\nlength(.0000001234)\nlength(.00000012345)\nlength(.000000123456)\nlength(.0000001234567)\nlength(.00000012345678)\nlength(.000000123456789)\nlength(.0000001234567890)\nlength(.00000001)\nlength(.000000012)\nlength(.0000000123)\nlength(.00000001234)\nlength(.000000012345)\nlength(.0000000123456)\nlength(.00000001234567)\nlength(.000000012345678)\nlength(.0000000123456789)\nlength(.00000001234567890)\nlength(.000000001)\nlength(.0000000012)\nlength(.00000000123)\nlength(.000000001234)\nlength(.0000000012345)\nlength(.00000000123456)\nlength(.000000001234567)\nlength(.0000000012345678)\nlength(.00000000123456789)\nlength(.000000001234567890)\nlength(.0000000001)\nlength(.00000000012)\nlength(.000000000123)\nlength(.0000000001234)\nlength(.00000000012345)\nlength(.000000000123456)\nlength(.0000000001234567)\nlength(.00000000012345678)\nlength(.000000000123456789)\nlength(.0000000001234567890)\nlength(289.29837)\nlength(2893.00000)\nlength(289.0)\nlength(1802973.0000000238)\n```\n\n----------------------------------------\n\nTITLE: Array Reference Declaration\nDESCRIPTION: Illustrates the syntax for declaring array references in bc function parameter lists. Changes made to the array within the function will affect the original array passed in by the caller. The example shows how to define an array reference parameter using '*I[]'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Bitwise Left Shift Example\nDESCRIPTION: Demonstrates the bitwise left shift operation (`bshl`) on a 32-bit integer. The operation shifts the bits of the first argument to the left by the number of positions specified by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_105\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(4239963109, 28)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (32-bit) Operation\nDESCRIPTION: This code rotates the bits to the left in a 32-bit number utilizing the 'brol32' function. The first argument is the 32-bit value to be rotated, the second is the amount of rotation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_55\n\nLANGUAGE: Text\nCODE:\n```\nbrol32(433984901, 363382439)\n```\n\n----------------------------------------\n\nTITLE: Defining a1 function: Initializing and squaring array (bc)\nDESCRIPTION: The `a1` function initializes an array `a[]` with values from 0 to `len-1`.  It then calls the `a2` function to square each element of the array, and finally prints the array using the `printarray` function. It receives an array pointer and the length of the array as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine a1(*a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = i\n\t}\n\n\ta2(a[], len)\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BC Function 'y'\nDESCRIPTION: This snippet defines the 'y' function in the 'bc' language. It takes two arguments, 'y' and 'x', and calculates a value based on two calls to the 'x' function with different argument orders. The result is the sum of 'x(y, x)' and 'x(x, y)'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/functions.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine y(y, x) {\n\treturn x(y, x) + x(x, y)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (32-bit) example\nDESCRIPTION: Demonstrates the bitwise NOT operation on a 32-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_7\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left Operation (8-bit)\nDESCRIPTION: Performs a bitwise rotate left operation on an 8-bit integer. The function `brol8` rotates the bits to the left by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_88\n\nLANGUAGE: C\nCODE:\n```\nbrol8(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Right Shifting BclNumber objects in C\nDESCRIPTION: Shifts 'a' right (moves the radix left) by 'b' places (in decimal) and returns the result. 'b' must be an integer. 'a' and 'b' are consumed unless the `_keep` variant is used. Errors can include invalid number, invalid context, non-integer shift value, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_rshift(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Decimal Value 2\nDESCRIPTION: Shows bitwise right shift operations on the decimal number 10.1.  The shift amounts range from 0 to 19. Demonstrates how decimal values interact with bitwise shifting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_9\n\nLANGUAGE: bc\nCODE:\n```\n10.1 >> 0\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (32-bit) Operation\nDESCRIPTION: This snippet rotates a 32-bit integer to the right using 'bror32'. The second parameter specifies how many bit positions to shift.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_67\n\nLANGUAGE: Text\nCODE:\n```\nbror32(2384001591844672901, 363382439)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (64-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate right operation on a 64-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_20\n\nLANGUAGE: N/A\nCODE:\n```\nbror64(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (8-bit) Operation\nDESCRIPTION: This snippet rotates the bits to the left in an 8-bit value with 'brol8'. The rotation is performed based on the number of bits specified as the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_46\n\nLANGUAGE: Text\nCODE:\n```\nbrol8(2384001591844672901, 167)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (32-bit) Operation\nDESCRIPTION: This code performs bitwise rotate right on a 32-bit number using 'bror32'. The bits are shifted to the right by the amount specified in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_66\n\nLANGUAGE: Text\nCODE:\n```\nbror32(433984901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Function Call in BC\nDESCRIPTION: This snippet calls the previously defined function 'a' with the argument 10. This will execute the code within the function 'a', resulting in the output 'a(10)' followed by a newline character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/line_by_line2.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\na(10)\n```\n\n----------------------------------------\n\nTITLE: Determine Length of Number or String in DC\nDESCRIPTION: This snippet explains the 'Z' command, which calculates and pushes the number of significant decimal digits for a number, or the number of characters for a string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_13\n\nLANGUAGE: dc\nCODE:\n```\nZ\n```\n\n----------------------------------------\n\nTITLE: Output using Print Statement in BC\nDESCRIPTION: This snippet demonstrates how to use the `print` statement in BC to output values and strings to the console. It shows printing multiple values separated by commas and printing a newline character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_7\n\nLANGUAGE: BC\nCODE:\n```\nprint 1,2,3\nprint \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Exponentiation with Floating-Point Exponents in BC\nDESCRIPTION: These are BC examples demonstrating exponentiation with floating-point exponents. The examples cover positive, negative, and zero values for the base and exponents, showcasing BC's handling of floating-point arithmetic with arbitrary precision.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/power.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\n0 ^ 0.0\n0 ^ 1.00\n0 ^ 1894.000\n1 ^ 0.0000\n39746823 ^ 0.00000\n0.238672983047682 ^ 0.000000\n18394762374689237468.97354862973846 ^ 0.0000000\n1 ^ 1.00000000\n2 ^ 1.000000000\n18927361346 ^ 1.0000000000\n0.23523785962738592635777 ^ 1.00000000000\n328956734869213746.89782398457234 ^ 1.000000000000\n8937 ^ 98.0000000000000\n0.124876812394 ^ 2396.00000000000000\n93762.2836 ^ 13.000000000000000\n1 ^ -1.0000000000000000\n2 ^ -1.00000000000000000\n10 ^ -1.000000000000000000\n683734768 ^ -1.0000000000000000000\n38579623756.897937568235 ^ -1.00000000000000000000\n1 ^ -32467.000000000000000000000\n2 ^ -53.0000000000000000000000\n23897 ^ -213.00000000000000000000000\n-1 ^ 1.000000000000000000000000\n-1 ^ 2.0000000000000000000000000\n-2 ^ 1.00000000000000000000000000\n-2 ^ 2.000000000000000000000000000\n-237 ^ 294.0000000000000000000000000000\n-3746 ^ 28.00000000000000000000000000000\n-0.3548 ^ 35.000000000000000000000000000000\n-4267.234 ^ 37.0000000000000000000000000000000\n-326.3246 ^ 78.00000000000000000000000000000000\n-1 ^ -1.000000000000000000000000000000000\n-1 ^ -2.0000000000000000000000000000000000\n-2 ^ -1.00000000000000000000000000000000000\n-2 ^ -2.000000000000000000000000000000000000\n-237 ^ -293.0000000000000000000000000000000000000\n-784 ^ -23.00000000000000000000000000000000000000\n-86 ^ -7.000000000000000000000000000000000000000\n-0.23424398 ^ -781.0000000000000000000000000000000000000000\n-178.234786 ^ -879.00000000000000000000000000000000000000000\n-1274.346 ^ -768.000000000000000000000000000000000000000000\n-0.2959371298 ^ 227.0000000000000000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Return Value in bc\nDESCRIPTION: This example defines a function `t()` that returns a string. The returned string is then assigned to the variable `v` and printed to the console.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine t() {\n\treturn \"return test\\n\"\n}\n\nv = t()\nprint v\n```\n\n----------------------------------------\n\nTITLE: Compound Assignment Operator in BC\nDESCRIPTION: Demonstrates the use of a compound assignment operator (+=) to modify the value of a scalar variable. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_6\n\nLANGUAGE: BC\nCODE:\n```\nx += 9\nx\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Print Strings in bc\nDESCRIPTION: This snippet defines a function `v(v)` that takes a string as input and prints it followed by a newline character.  It then calls the function with two different string arguments: \"stuff\" and the value of the variable `v`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine v(v) {\n\tprint v, \"\\n\"\n}\n\nv(\"stuff\")\nv(v)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (16-bit)\nDESCRIPTION: Rotates the bits of a 16-bit number to the left by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_129\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: BC Function Calls with Numeric Arguments\nDESCRIPTION: This snippet shows a series of calls to the BC function 's' with various numerical arguments, including positive and negative integers, decimals, and calculations involving the variable 'p'. These calls demonstrate how to use the 's' function with a range of inputs.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/sine.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ns(0)\ns(0.5)\ns(1)\ns(2)\ns(3)\ns(-0.5)\ns(-1)\ns(-2)\ns(-3)\ns(p / 7)\ns(-p / 7)\ns(p / 4)\ns(-p / 4)\ns(p / 3)\ns(-p / 3)\ns(p / 2)\ns(-p / 2)\ns(3 * p / 4)\ns(3 * -p / 4)\ns(p)\ns(-p)\ns(3 * p / 2)\ns(3 * -p / 2)\ns(7 * p / 4)\ns(7 * -p / 4)\ns(13 * p / 4)\ns(13 * -p / 4)\ns(2 * p)\ns(2 * -p)\ns(131231)\ns(-131231)\ns(69.1967507777)\ns(10828)\ns(-16248506.847013148)\ns(2050281000)\ns(8224939)\ns(11334231.1154662464)\ns(-4109411249.2986954846)\ns(-2395915402.13984)\ns(-2795874313)\ns(-2262647256)\ns(3323158182.1239222084)\ns(99901384)\ns(-4202726050.2780080957)\ns(2870000621.3228830588)\ns(-4230239450.981045150)\ns(-1517506941.2678857223)\ns(4004582176)\ns(-4193724543.1108508063)\ns(-3432511261)\ns(1804484812)\ns(3229084127)\ns(-3565317246.583937244)\ns(3503281621)\ns(-3469146313.1766891244)\ns(-2257308049.307721068)\ns(-3978441809)\ns(3431564304.3752537)\ns(1249644440.2464914559)\ns(2395558891.1188487974)\ns(-2607820706.4079280116)\ns(1208310007)\ns(-3758597557.863203175)\ns(1186920672)\ns(-3988103872)\ns(-4280635328.4194857577)\ns(1051748072)\ns(-1884006279)\ns(-1046568719.2698663389)\ns(2482991410)\ns(-2106101268.1154045959)\ns(3530359346.77217900)\ns(-3373362543)\ns(2601598062)\ns(2576349783.2446436039)\ns(2987020862)\ns(-12033356.2057140648)\ns(-3721760707)\ns(2842387705.4145759704)\ns(3515832681.1808393297)\ns(-3658522034.16149)\ns(3963658030.2860423992)\ns(2977802215.597946655)\ns(-4271392570.4091498761)\ns(2378692585)\ns(-3545193743.629374782)\ns(-1762458738)\ns(-1174277828.4264040126)\ns(-1724994857)\ns(2802750230.1783499408)\ns(-3068133550)\ns(3324811474.621822235)\ns(2873024984)\ns(-3509056632.3888206298)\ns(1772903162.647192879)\ns(2836543102)\ns(4117858580.186)\ns(2988632386.4063754522)\ns(-4256784971.1770067447)\ns(2280820447)\ns(-2865200306)\ns(-3329592486)\ns(519126268)\ns(-2452430452)\ns(-2693220186.62104082)\ns(-3796811992.14485798)\ns(3619792326)\ns(2697791049.3038381550)\ns(3751267834.2808166557)\ns(-3761719074)\ns(-3824087631)\ns(2119301150)\ns(1398148974)\ns(-3386564819.1351816969)\ns(-3171483098)\ns(3688944941.3273318162)\ns(3060521119)\ns(-3527110404)\ns(3699631193)\ns(3872838898)\ns(3880350192)\n```\n\n----------------------------------------\n\nTITLE: Define prnt Function in BC\nDESCRIPTION: This BC function, `prnt(i)`, takes an integer `i` as input, sets the output base (`obase`) to `i - 1` and then to `i`, prints 'a', 'b', and 'c' in these bases. Finally it returns the original input `i`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/print2.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine prnt(i) {\n\n\tobase = i - 1\n\ta\n\tb\n\tc\n\n\tobase = i\n\ta\n\tb\n\tc\n\n\treturn i\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (16-bit) example\nDESCRIPTION: Demonstrates the bitwise NOT operation on a 16-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_6\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left Operation (16-bit)\nDESCRIPTION: Performs a bitwise rotate left operation on a 16-bit integer. The function `brol16` rotates the bits to the left by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_89\n\nLANGUAGE: C\nCODE:\n```\nbrol16(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Determine Scale of Number or String in DC\nDESCRIPTION: This snippet explains the 'X' command, which pushes the scale of a number onto the stack, or 0 if the value is a string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_14\n\nLANGUAGE: dc\nCODE:\n```\nX\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (64-bit)\nDESCRIPTION: Rotates the bits of a 64-bit number to the left by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_131\n\nLANGUAGE: N/A\nCODE:\n```\nbrol64(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (16-bit) Operation\nDESCRIPTION: This snippet executes the bitwise NOT operation on a 16-bit value using the 'bnot16' function. It effectively flips all the bits in the provided 16-bit unsigned integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_33\n\nLANGUAGE: Text\nCODE:\n```\nbnot16(5509)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (16-bit) Operation\nDESCRIPTION: This snippet rotates bits to the right in a 16-bit value using the 'bror16' function. The amount of rotation is determined by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_61\n\nLANGUAGE: Text\nCODE:\n```\nbror16(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: BclContext Struct Definition\nDESCRIPTION: Defines the `BclContext` structure, which encapsulates the context for arbitrary precision arithmetic within the bcl library. The structure itself is opaque and only a pointer to it is used.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstruct BclCtxt;\n```\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct BclCtxt* BclContext;\n```\n\n----------------------------------------\n\nTITLE: Check if Value is a Number in DC\nDESCRIPTION: This snippet explains the 'u' command, which pushes 1 onto the stack if the popped value is a number, and 0 if it is a string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_15\n\nLANGUAGE: dc\nCODE:\n```\nu\n```\n\n----------------------------------------\n\nTITLE: Adding BclNumber objects in C\nDESCRIPTION: Adds two BclNumber objects, 'a' and 'b', and returns the result. The scale of the result is the maximum of the scales of 'a' and 'b'. 'a' and 'b' are consumed (freed) after the operation unless the `_keep` variant is used.  The function can return various errors, including invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_add(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Functions in .bcrc for bc\nDESCRIPTION: This `.bcrc` file contains custom functions for use with the bc calculator. It defines functions for time conversions, random number generation, and printing formatted output, extending the functionality of the basic calculator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine void print_time_unit(t){\n\tif(t<10)print \"0\"\n\tif(t<1&&t)print \"0\"\n\tprint t,\":\"\n}\ndefine void sec2time(t){\n\tauto s,m,h,d,r\n\tr=scale\n\tscale=0\n\tt=abs(t)\n\ts=t%60\n\tt-=s\n\tm=t/60%60\n\tt-=m\n\th=t/3600%24\n\tt-=h\n\td=t/86400\n\tif(d)print_time_unit(d)\n\tif(h)print_time_unit(h)\n\tprint_time_unit(m)\n\tif(s<10)print \"0\"\n\tif(s<1&&s)print \"0\"\n\ts\n\tscale=r\n}\ndefine minutes(secs){\n\treturn secs/60;\n}\ndefine hours(secs){\n\treturn secs/3600;\n}\ndefine days(secs){\n\treturn secs/3600/24;\n}\ndefine years(secs){\n\treturn secs/3600/24/365.25;\n}\ndefine fbrand(b,p){\n\tauto l,s,t\n\tb=abs(b)$\n\tif(b<2)b=2\n\ts=scale\n\tt=b^abs(p)$\n\tl=ceil(l2(t),0)\n\tif(l>scale)scale=l\n\tt=irand(t)/t\n\tscale=s\n\treturn t\n}\ndefine ifbrand(i,b,p){return irand(abs(i)$)+fbrand(b,p)}\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise AND Operation\nDESCRIPTION: This code snippet demonstrates the bitwise AND operation with two 64-bit integer inputs. The function 'band' is used to perform the AND operation between the two provided numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_25\n\nLANGUAGE: Text\nCODE:\n```\nband(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Modular Exponentiation in BclNumber (bcl_modexp)\nDESCRIPTION: This function computes modular exponentiation: (*a* ^ *b*) mod *c*. *a* is the base, *b* is the exponent, and *c* is the modulus. The scale of the result is the scale of the current context. *a*, *b*, and *c* must be integers, *c* must not be 0, and *b* must not be negative. *a*, *b*, and *c* are consumed by the function. Possible errors can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_modexp(BclNumber* _a_**, BclNumber* _b_**, BclNumber* _c_**)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (8-bit) Operation\nDESCRIPTION: This snippet rotates an 8-bit integer's bits to the right using 'bror8'. The rotation is based on the bit positions dictated by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_59\n\nLANGUAGE: Text\nCODE:\n```\nbror8(2384001591844672901, 167)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (16-bit) Operation\nDESCRIPTION: This code performs the bitwise modulo operation on a 16-bit value using 'bmod16'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_73\n\nLANGUAGE: Text\nCODE:\n```\nbmod16(5509)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation (64-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 64-bit integer. The function `bnot64` inverts the bits of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_83\n\nLANGUAGE: C\nCODE:\n```\nbnot64(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (64-bit) Operation\nDESCRIPTION: Demonstrates the bitwise NOT operation (bnot64) on a 64-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_148\n\nLANGUAGE: N/A\nCODE:\n```\nbnot64(16527427662727213300)\n```\n\n----------------------------------------\n\nTITLE: Testing Array with Constant Values\nDESCRIPTION: This section tests the behavior of an array by initializing all its elements to the value '1'. It may be used for validation purposes, boundary conditions, or performance tests. The output here displays a sequence of all ones, confirming correct initialization and potentially consistent access patterns.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand_results.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n```\n\n----------------------------------------\n\nTITLE: Division with Scale in BC\nDESCRIPTION: Demonstrates the usage of 'scale' variable in BC calculator to control the precision of decimal division. Includes setting 'scale' and performing division to see the effect. Requires understanding of the 'scale' variable in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divide.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nscale = 0\n15 / 4\n17 / 4\n2389473 / 5\n346728934 / 23958\n-47589634875689345 / 37869235\n-6324758963 / 237854962\n2 / -3\n16 / 5\n14 / 5\n123647238946 / -12467\n-2 / -3\n-13 / -7\n-15 / -7\n-12784956 / -32746\n-3191280681 / 641165986\nscale = 0; -899510228 / -2448300078.40314\nscale = 0; -7424863 / -207.2609738667\nscale = 0; 3769798918 / 0.6\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (8-bit) Operation\nDESCRIPTION: This code rotates the bits to the left in an 8-bit value with 'brol8'. The first argument is the value to rotate, the second is the number of bit positions to rotate by.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_47\n\nLANGUAGE: Text\nCODE:\n```\nbrol8(133, 167)\n```\n\n----------------------------------------\n\nTITLE: Conditional For Loop C\nDESCRIPTION: This snippet demonstrates a for loop with a conditional 'if' statement inside. The loop iterates three times, and in each iteration, it checks if 2 is less than 3. If the condition is true, it executes the statement '1'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/stdin2.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfor (i = 0; i < 3; ++i) if (2 < 3) 1\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (16-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 16-bit number, inverting all the bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_121\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Unspecified Code Snippet 1\nDESCRIPTION: This snippet contains a series of seemingly random characters and expressions including array access and string constants. It is hard to determine the purpose without additional context or language specification.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/01.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\nu\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\nu\na\ns\nc = l[ ca]\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\na\na\ns\nc = l[ ca]\na\ns\nc = l[ ca]\na(s691027461l[ ba])\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\nu\na\ns\nc = l[ ca]\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na*e\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\na\na\ns\nc = l[ ca]\na\na\nsa\ne\ncss\nc = c[ ca]\na\na\nsa\ne\ncs\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\n cs\nc = l[ ca]\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\na\na\ns\nc = l[ ca]\na\na\nsa\ne\ncss\nc = l[ ca]\na\na\nsa\ne\ncs\na\nb\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\n\nscal[ ca]\na\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\nu\na\ns\nc = l[ ca]\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\nc\n\na\ns(scal[ ba])\nscal[ ca]\na\na\ns\nc = l[ ca]\na\na\nsa\ne\ncss\nc = l[ ca]\na\na\nsa\ne\ncs\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscs\nc = l[ ca]\na\na\nsa\ne\ncs\nc\n\na(s691027461l[ ba])\nscal[ ca]\na\na\ne\ncs\nc\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Less Than)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is less than the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_7\n\nLANGUAGE: dc\nCODE:\n```\n<_r_\n```\n\n----------------------------------------\n\nTITLE: BC Quit Statement Example\nDESCRIPTION: This example demonstrates the behavior of the `quit` statement in this implementation of bc(1), which differs from other implementations. It shows that statements before the `quit` statement on the same line are executed before exiting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Sequence Calculation with bc\nDESCRIPTION: This snippet calculates the Fibonacci sequence for numbers from 0 to 30 using the `fib()` function.  It's intended to be run with the `bc` command-line calculator after the `fib()` function is defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/fib.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nfib(0)\nfib(1)\nfib(2)\nfib(3)\nfib(4)\nfib(5)\nfib(6)\nfib(7)\nfib(8)\nfib(9)\nfib(10)\nfib(11)\nfib(12)\nfib(13)\nfib(14)\nfib(15)\nfib(16)\nfib(17)\nfib(18)\nfib(19)\nfib(20)\nfib(21)\nfib(22)\nfib(23)\nfib(24)\nfib(25)\nfib(26)\nfib(27)\nfib(28)\nfib(29)\nfib(30)\n```\n\n----------------------------------------\n\nTITLE: Function Definition with Global Stacks - bc\nDESCRIPTION: This snippet demonstrates how to define a function `output(x, b)` that prints the value of `x` in base `b` using the `-g` or `--global-stacks` option.  It utilizes the global stacks feature to avoid the need for explicitly saving and restoring the `obase` variable. Dependencies include the `bc` command itself.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n obase=b\n x\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Equality Comparisons\nDESCRIPTION: This snippet shows comparisons for equality and inequality of a variable with itself.  It uses the equality (==) and inequality (!=) operators. The variable 'v' is initialized to 18237.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/comp.txt#_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\nv = 18237\nv == v\nv != v\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Equality in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on an equality comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_7\n\nLANGUAGE: dc\nCODE:\n```\n=r\n```\n\nLANGUAGE: dc\nCODE:\n```\n=rers\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (16-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate left operation on a 16-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_14\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling the 'void' Function in BC\nDESCRIPTION: This code attempts to define a function named 'void' that takes one argument 'x' and returns 'x'. It then calls the 'void' function with various numerical arguments (integer and floating-point). It's important to note that 'void' might be a reserved or built-in keyword, and using it as a function name could lead to unexpected behaviour.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/void.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine void(x) {\n\treturn x\n}\n\nvoid(0)\nvoid(1)\nvoid(2.9823)\nvoid(-3.5982)\n```\n\n----------------------------------------\n\nTITLE: Combined Conditional and Loop Statements\nDESCRIPTION: This snippet illustrates how conditional statements (`if/else`) can be combined with loop structures (`while`).  These examples showcase different variations of nesting `if` statements inside `while` loops and vice versa, including using `break` to exit loops.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_5\n\nLANGUAGE: BC\nCODE:\n```\nif (x == 1) while (x > 0) { x ; x -= 1 } else 0\nx = 1\nif (x == 0) while (x > 0) { x ; x -= 1 } else 0\n\nif(x == 1) {\n\t11\n\twhile(x == 1) {\n\t\t21\n\t\twhile(x == 1) {\n\t\t\t31\n\t\t\tbreak\n\t\t\t32\n\t\t}\n\t\t22\n\t\tbreak\n\t\t23\n\t}\n\t12\n}\n99\n```\n\n----------------------------------------\n\nTITLE: Defining a function with -g (global-stacks) option\nDESCRIPTION: This snippet demonstrates how the `-g` or `--global-stacks` option affects function definitions by pushing copies of `ibase`, `obase`, and `scale` onto a stack for each function call. It illustrates how to define a function `output(x, b)` that prints `x` in base `b` using the `obase` global without affecting other functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    obase=b\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Less Than)\nDESCRIPTION: Pops two numbers. If the first is less than the second, the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_7\n\nLANGUAGE: dc\nCODE:\n```\n<r\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (64-bit) Operation\nDESCRIPTION: This code snippet tests the bitwise NOT operation (complement) on a 64-bit number with 'bnot64'. It inverts all the bits of the input number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_36\n\nLANGUAGE: Text\nCODE:\n```\nbnot64(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (8-bit)\nDESCRIPTION: Performs a bitwise NOT operation on an 8-bit number, inverting all the bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_120\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Defining Bash Aliases for bc Configuration\nDESCRIPTION: These bash aliases simplify the process of configuring the bc project with different compiler flags and debugging options. They set up configurations for debugging, compiling with all warnings, disabling assertions, and unsetting environment variables specific to bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nalias bcdebug='CPPFLAGS=\"-DBC_DEBUG_CODE=1\" CFLAGS=\"-Weverything -Wno-padded \\\n    -Wno-switch-enum -Wno-format-nonliteral -Wno-cast-align \\\n    -Wno-unreachable-code-return -Wno-missing-noreturn \\\n    -Wno-disabled-macro-expansion -Wno-unreachable-code -Wall -Wextra \\\n    -pedantic -std=c99\" ./configure.sh'\nalias bcconfig='CFLAGS=\"-Weverything -Wno-padded -Wno-switch-enum \\\n    -Wno-format-nonliteral -Wno-cast-align -Wno-unreachable-code-return \\\n    -Wno-missing-noreturn -Wno-disabled-macro-expansion -Wno-unreachable-code \\\n    -Wall -Wextra -pedantic -std=c99\" ./configure.sh'\nalias bcnoassert='CPPFLAGS=\"-DNDEBUG\" CFLAGS=\"-Weverything -Wno-padded \\\n    -Wno-switch-enum -Wno-format-nonliteral -Wno-cast-align \\\n    -Wno-unreachable-code-return -Wno-missing-noreturn \\\n    -Wno-disabled-macro-expansion -Wno-unreachable-code -Wall -Wextra \\\n    -pedantic -std=c99\" ./configure.sh'\nalias bcdebugnoassert='CPPFLAGS=\"-DNDEBUG -DBC_DEBUG_CODE=1\" \\\n    CFLAGS=\"-Weverything -Wno-padded -Wno-switch-enum -Wno-format-nonliteral \\\n    -Wno-cast-align -Wno-unreachable-code-return -Wno-missing-noreturn \\\n    -Wno-disabled-macro-expansion -Wno-unreachable-code -Wall -Wextra \\\n    -pedantic -std=c99\" ./configure.sh'\nalias bcunset='unset BC_LINE_LENGTH && unset BC_ENV_ARGS'\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!>r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not greater than the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_5\n\nLANGUAGE: dc\nCODE:\n```\n!>r\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!>r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not greater than the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_6\n\nLANGUAGE: dc\nCODE:\n```\n!>r es\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Left Shift Operation\nDESCRIPTION: This code snippet performs a bitwise left shift operation using the 'bshl' function. It takes a 32-bit integer and shifts it to the left by a specified number of bits (7 in this case).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_28\n\nLANGUAGE: Text\nCODE:\n```\nbshl(433984901, 7)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (64-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 64-bit number, inverting all the bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_123\n\nLANGUAGE: N/A\nCODE:\n```\nbnot64(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Define array initialization function in BC\nDESCRIPTION: This BC script defines a function `a1` that takes an array `a[]` and its length `len` as input. The function initializes each element of the array with its index, then calls the `a2` function to square each element, and finally calls the `printarray` function to output the modified array. This function is dependent on the `a2` and `printarray` functions being defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/38.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\ndefine a1(*a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = i\n\t}\n\n\ta2(a[], len)\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: While Loop in BC\nDESCRIPTION: This snippet demonstrates the use of a `while` loop in BC. It includes an example of a `break` statement used to exit the loop prematurely when `x` equals -5. The loop continues as long as `x` is less than or equal to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nx = -10\nwhile (x <= 0) {\n\tx\n\tif (x == -5) break;\n\tx += 1\n}\n```\n\n----------------------------------------\n\nTITLE: Permutation and Combination Calculations\nDESCRIPTION: This snippet demonstrates examples of permutation and combination calculations using 'perm' and 'comb' functions. The functions likely compute the number of permutations and combinations respectively, given two integer inputs representing the total number of items and the number of items to choose.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_perm.txt#_snippet_0\n\nLANGUAGE: None\nCODE:\n```\nperm(10, 2)\ncomb(10, 2)\nperm(6, 2)\ncomb(6, 2)\nperm(12, 10)\ncomb(12, 10)\nperm(24, 15)\ncomb(24, 15)\n```\n\n----------------------------------------\n\nTITLE: Halting BC Execution\nDESCRIPTION: This snippet demonstrates the `halt` command in `bc`. The `halt` command causes the `bc` program to terminate immediately.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/atan.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nhalt\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Parameters in BC\nDESCRIPTION: This snippet demonstrates defining a function `t` in BC that accepts two parameters, `x` and `y`. The function prints the values of these parameters. It further shows how to call the function with post-increment operators to observe the order of evaluation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_9\n\nLANGUAGE: BC\nCODE:\n```\ndefine void t(x, y) {\n\tprint \"x: \", x, \"; y: \", y, \"\\n\"\n}\n\nt(i++, i++)\ni\n\nt(++i, ++i)\ni\n```\n\n----------------------------------------\n\nTITLE: Variable Assignments and Array Access in BC\nDESCRIPTION: Assigns values to scalar variable `x` and array element `x[0]`. The snippet then attempts to access these variables. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\nx=2\nx[0]=3\nx\nx[0]\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Equal)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not equal to the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_13\n\nLANGUAGE: dc\nCODE:\n```\n!=_r_\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse Operation (64-bit)\nDESCRIPTION: Performs a bitwise reverse operation on a 64-bit integer. The function `brev64` reverses the order of bits in the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_87\n\nLANGUAGE: C\nCODE:\n```\nbrev64(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (64-bit) example\nDESCRIPTION: Demonstrates the bitwise reverse operation on a 64-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_12\n\nLANGUAGE: N/A\nCODE:\n```\nbrev64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Macro Execution in dc(1)\nDESCRIPTION: This snippet describes the 'x' command in dc(1) that executes a string as a macro. The command pops a value off the stack. If the value is a number, it's pushed back onto the stack. If the value is a string, it's executed as a macro.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Running Tests with AddressSanitizer\nDESCRIPTION: These commands run the test suite under AddressSanitizer to detect memory-related errors. The `CFLAGS` variable is set to include the `-fsanitize` flag with the appropriate sanitizer name. `-gO3` enables debugging and optimization level 3.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nCFLAGS=\"-fsanitize=<sanitizer> ./configure -gO3 -m\nmake -j<cores>\nmake -j<cores> test\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (>r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is greater than the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n>r\n```\n\n----------------------------------------\n\nTITLE: Defining a function in bc\nDESCRIPTION: This code snippet defines a function named 'i' that takes one argument 'x'. It includes an incomplete 'if' statement which appears to contain an incomplete condition. More context is needed for a full understanding.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/08.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine i(x) {\nc673\nif(267)}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (8-bit) Example\nDESCRIPTION: Demonstrates the bitwise rotate right operation (`bror8`) on an 8-bit integer. The operation rotates the bits of the first argument to the right by the number of positions specified by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_110\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(3708754108241877138, 16558750771054102751)\n```\n\n----------------------------------------\n\nTITLE: Initializing and processing array (a7) in BC\nDESCRIPTION: This function, `a7`, initializes the provided array `a__[]` from index 0 to `len-1` with values corresponding to their index. After initialization, it calls function `a6` to square each array element and finally calls `printarray` to display the array elements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\ndefine a7(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta6(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Exiting Macros in DC\nDESCRIPTION: This snippet explains the 'q' command, which exits the execution of the current macro and its parent macro, or exits dc if there are no macros.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_10\n\nLANGUAGE: dc\nCODE:\n```\nq\n```\n\n----------------------------------------\n\nTITLE: BC Modulo with Decimal and Scale\nDESCRIPTION: This snippet demonstrates how the 'scale' variable interacts with modulo operations involving decimal numbers. Setting 'scale' to 0 truncates the decimal part before performing the modulo, which may result in unexpected outputs if the intention is to preserve decimal precision.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/modulus.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\n1 % 0.2395672438567234\n```\n\n----------------------------------------\n\nTITLE: Relational and AND Operators\nDESCRIPTION: This snippet combines relational operators (<, >, >=, ==, !=) with the boolean AND operator '&&'. The relational operators evaluate to either true (1) or false (0), and then the AND operator combines these results. This showcases precedence and the conversion of relational results to boolean values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_3\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n3 < 4 && 7\n3 && 4 >= 4\n3 > 4 && 7\n3 && 4 >= 5\n3 < 4 && 0\n0 && 4 >= 4\n3 > 4 && 0\n0 && 4 >= 5\n3 > 4 && 0\n0 && 4 < 4\n3 >= 4 && 0\n0 && 4 >= 5\n3 < 4 && 7\n3 && 4 >= 4\n3 > 4 && 7 > 4\n3 >= 2 && 4 >= 5\n3 < 4 && 0 > -1\n4 < 3 && 4 >= 4\n3 > 4 && 3 == 3\n3 != 3 && 4 >= 5\n3 > 4 && 0 > 1\n0 >= 0 && 4 < 4\n3 >= 4 && 0 >= 1\n0 <= -1 && 4 >= 5\n```\n\n----------------------------------------\n\nTITLE: Data Point Representation\nDESCRIPTION: This snippet showcases the general structure of a data point used for testing, represented as 'r(x, y)'. 'x' and 'y' are numerical values that can be positive, negative, or decimal. These points likely serve as input to a function or system being tested, validating its behavior across a range of values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_r.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nr(0, 0)\nr(0, 1)\nr(0, 100)\nr(1, 0)\nr(1, 3)\nr(1.4, 0)\nr(1.5, 0)\nr(34.45, 2)\nr(64.1223, 4)\nr(283.1983893, 6)\nr(283.1983895, 6)\nr(283.1983899, 6)\nr(99.999999999, 5)\nr(-1, 0)\nr(-1, 3)\nr(-1.4, 0)\nr(-1.5, 0)\nr(-34.45, 2)\nr(-64.1223, 4)\nr(-283.1983893, 6)\nr(-283.1983895, 6)\nr(-283.1983899, 6)\nr(-99.999999999, 5)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Equal Else)\nDESCRIPTION: Pops two numbers. If the first is equal to the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_12\n\nLANGUAGE: dc\nCODE:\n```\n=res\n```\n\n----------------------------------------\n\nTITLE: Generating Makefile with out-of-source build\nDESCRIPTION: This snippet demonstrates how to perform an out-of-source build. It calls `configure.sh` from a separate build directory, generating the `Makefile` there. Subsequently, `make` is invoked in the build directory.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n../bc/configure.sh\nmake\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Less Than Else)\nDESCRIPTION: Pops two numbers. If the first is not less than the second (greater than or equal to), the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_10\n\nLANGUAGE: dc\nCODE:\n```\n!<res\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Equal) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not equal to the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_14\n\nLANGUAGE: dc\nCODE:\n```\n!=_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (64-bit) Operation\nDESCRIPTION: This snippet reverses the bit order in a 64-bit value using 'brev64'. It swaps the positions of all bits within the 64-bit input number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_43\n\nLANGUAGE: Text\nCODE:\n```\nbrev64(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Left Shift Operation\nDESCRIPTION: Performs a bitwise left shift operation on a 32-bit number. The number is shifted left by a specified number of bits (27 in this case), effectively multiplying it by 2 raised to the power of the shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_118\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(2455887482, 27)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift Operation\nDESCRIPTION: Performs a bitwise right shift operation on a 32-bit number. The number is shifted right by a specified number of bits (27 in this case), effectively dividing it by 2 raised to the power of the shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_119\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(2455887482, 27)\n```\n\n----------------------------------------\n\nTITLE: Declaring an array reference in bc\nDESCRIPTION: This code snippet demonstrates how to declare an array parameter as a reference in a bc function definition. Any changes made to the array within the function will be reflected in the original array passed as an argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Read and Execute Input in DC\nDESCRIPTION: This snippet describes the '?' command, which reads a line from stdin and executes it as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_9\n\nLANGUAGE: dc\nCODE:\n```\n?\n```\n\n----------------------------------------\n\nTITLE: Configuring bc library build\nDESCRIPTION: Configures the build to create the math library. This disables history and locales, and enables functionality for both bc and dc, but does not build the executables.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -a\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --library\n```\n\n----------------------------------------\n\nTITLE: Function Definition\nDESCRIPTION: This snippet defines a function 'a' that takes an argument 'x', prints the function name and the argument, and then exits the program. The function showcases simple output and termination.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line1.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndefine a (x) {\n\tprint \"a(\", x, \")\\n\"\n\tquit\n}\n```\n\n----------------------------------------\n\nTITLE: Division with Scale\nDESCRIPTION: This snippet sets the scale to 100 and performs a division operation. 'scale' is set to a high value to ensure high precision. This operation divides a larger decimal number by another large decimal number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nscale=100;759634576394.3946587934658364895 / 9834759834895386.36459364958346\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation\nDESCRIPTION: Performs a bitwise OR operation between two 64-bit numbers. The operation combines bits from both inputs such that the resultant bit is 1 if either of the corresponding bits in operands is 1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_116\n\nLANGUAGE: N/A\nCODE:\n```\nbor(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Changing Scale to Zero and Dividing Numbers in BC\nDESCRIPTION: This snippet sets the `scale` variable to 0, meaning results will be truncated to integers, and then performs similar division operations using the `divmod` function.  The quotient is extracted and printed. This highlights the effect of the scale on the result of the division.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divmod.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nscale = 0\nv = divmod(0, 1, v[]); v[0]; v\nv = divmod(0, 321566, v[]); v[0]; v\nv = divmod(0, 0.3984567238456, v[]); v[0]; v\nv = divmod(1, 1, v[]); v[0]; v\nv = divmod(1, 1287469297356, v[]); v[0]; v\nv = divmod(1, 0.2395672438567234, v[]); v[0]; v\nv = divmod(1, 237586239856.0293596728392360, v[]); v[0]; v\nv = divmod(1249687284356, 3027949207835207, v[]); v[0]; v\nv = divmod(378617298617396719, 35748521, v[]); v[0]; v\nv = divmod(9348576237845624358, 0.9857829375461, v[]); v[0]; v\nv = divmod(35768293846193284, 2374568947.045762839567823, v[]); v[0]; v\nv = divmod(-78987234567812345, 876542837618936, v[]); v[0]; v\nv = divmod(-356789237555535468, 0.3375273860984786903, v[]); v[0]; v\nv = divmod(-5203475364850390, 435742903748307.70869378534043296404530458, v[]); v[0]; v\nv = divmod(-0.37861723347576903, 7385770896, v[]); v[0]; v\nv = divmod(-0.399454682043962, 0.34824389304, v[]); v[0]; v\nv = divmod(-0.6920414523873204, 356489645223.76076045304879030, v[]); v[0]; v\nv = divmod(-35872917389671.7573280963748, 73924708, v[]); v[0]; v\nv = divmod(-78375896314.4836709876983, 0.78356798637817, v[]); v[0]; v\nv = divmod(-2374123896417.143789621437581, 347821469423789.1473856783960, v[]); v[0]; v\nv = divmod(-896729350238549726, -34976289345762, v[]); v[0]; v\nv = divmod(-2374568293458762348596, -0.8792370647234987679, v[]); v[0]; v\nv = divmod(-237584692306721845726038, -21783910782374529637.978102738746189024761, v[]); v[0]; v\nv = divmod(-0.23457980123576298375682, -1375486293874612, v[]); v[0]; v\nv = divmod(-0.173897061862478951264, -0.8179327486017634987516298745, v[]); v[0]; v\nv = divmod(-0.9186739823576829347586, -0.235678293458756239846, v[]); v[0]; v\nv = divmod(-0.9375896183746982374568, -13784962873546.0928729395476283745, v[]); v[0]; v\nv = divmod(-2930754618923467.12323745862937465, -734869238465, v[]); v[0]; v\nv = divmod(-23745861923467.874675129834675, -0.23542357869124756, v[]); v[0]; v\nv = divmod(-3878923750692883.7238596702834756902, -7384192674957215364986723.9738461923487621983, v[]); v[0]; v\nv = divmod(1, 0.00000000000000000000000000000000000000000002346728372937352457354204563027, v[]); v[0]; v\n```\n\n----------------------------------------\n\nTITLE: Standard Build and Install - Shell\nDESCRIPTION: These commands demonstrate the standard build and installation process using `make`. It assumes the configuration step has already been performed using `configure.sh`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_20\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --prefix=/usr\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo Operation\nDESCRIPTION: Demonstrates the bitwise modulo operation (bmod) on integers of different sizes (8, 16, 32, and 64 bits).  It computes the modulo (remainder) of the input integer. The exact behavior depends on how the `bmod` function is defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_171\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(6960136430480362150)\nbmod8(166)\nbmod16(6960136430480362150)\nbmod16(35494)\nbmod32(6960136430480362150)\nbmod32(118065830)\nbmod64(6960136430480362150)\nbmod8(869320618226679840)\nbmod8(32)\nbmod16(869320618226679840)\nbmod16(32)\nbmod32(869320618226679840)\nbmod32(357761056)\nbmod64(869320618226679840)\nbmod8(11784620717065408517)\nbmod8(5)\nbmod16(11784620717065408517)\nbmod16(36869)\nbmod32(11784620717065408517)\nbmod32(3311702021)\nbmod64(11784620717065408517)\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Comparisons\nDESCRIPTION: This snippet demonstrates the comparison of floating-point numbers using equality (==), greater than (>), and less than (<) operators. It includes comparisons of numbers that are very close to each other and numbers with slightly different precision.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/comp.txt#_snippet_3\n\nLANGUAGE: N/A\nCODE:\n```\n1000000000.000000001 == 999999999.000000001\n1000000000.000000001 > 999999999.000000001\n1000000000.000000001 < 999999999.000000001\n1000000000.000000001 == 1000000000.000000001\n1000000000.000000001 > 1000000000.000000001\n1000000000.000000001 < 1000000000.000000001\n1000000000.000000001 == 1000000000.00000000100000000\n1000000000.000000001 > 1000000000.00000000100000000\n1000000000.000000001 < 1000000000.00000000100000000\n1000000000.000000001 == 1000000000.000000001000000001\n1000000000.000000001 > 1000000000.000000001000000001\n1000000000.000000001 < 1000000000.000000001000000001\n999999999.000000001 == 1000000000.000000001\n999999999.000000001 > 1000000000.000000001\n999999999.000000001 < 1000000000.000000001\n1000000000.00000000100000000 == 1000000000.000000001\n1000000000.00000000100000000 > 1000000000.000000001\n1000000000.00000000100000000 < 1000000000.000000001\n1000000000.000000001000000001 == 1000000000.000000001\n1000000000.000000001000000001 > 1000000000.000000001\n1000000000.000000001000000001 < 1000000000.000000001\n```\n\n----------------------------------------\n\nTITLE: Configuring bc/dc to Disable Problematic Tests\nDESCRIPTION: These commands configure the build process to disable tests known to be problematic, potentially causing `SIGKILL` or `SIGSEGV`.  The `-P` flag and `--disable-problematic-tests` option are equivalent.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_33\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh -P\n```\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh --disable-problematic-tests\n```\n\n----------------------------------------\n\nTITLE: Simple For Loop with Conditional in C\nDESCRIPTION: This snippet shows a 'for' loop that iterates three times. Inside the loop, there is an 'if' statement that checks if 2 is less than 3. If the condition is true, the value 1 is returned (although the return value is unused in this context).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc7.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfor (i = 0; i < 3; ++i) if (2 < 3) 1\n```\n\n----------------------------------------\n\nTITLE: Example Conditional Execution with '>r' in dc(1)\nDESCRIPTION: This code snippet shows an example of conditional execution using the '>r' command. It pushes 0 and 1 onto the stack, and then compares them. Since 0 is not greater than 1, the contents of register 'a' will NOT be executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_19\n\nLANGUAGE: dc\nCODE:\n```\n0 1>a\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (8-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate left operation (brol8) on an 8-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_153\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(244, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(16527427662727213300, 26)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(244, 26)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Right Operation\nDESCRIPTION: Demonstrates the bitwise shift right operation (bshr) on integers. The function takes two arguments: the integer to be shifted and the number of bits to shift. It shifts the bits of the first argument to the right by the specified number of bits. The behavior of filling vacated positions depends on the implementation (logical or arithmetic shift). The operation is performed on different integer sizes.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_166\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(118065830, 19)\nbshr(2172522771, 6)\nbshr(357761056, 10)\nbshr(3404262154, 0)\nbshr(3311702021, 25)\nbshr(2974346297, 5)\n```\n\n----------------------------------------\n\nTITLE: LCM Calculation in bc\nDESCRIPTION: This snippet shows how to calculate the Least Common Multiple (LCM) using bc. The LCM function is called with two integer arguments. The output will be the LCM of the provided numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_gcd.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nlcm(40, 4096)\n```\n\nLANGUAGE: bc\nCODE:\n```\nlcm(555, 55)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Greater Than)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not greater than the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_5\n\nLANGUAGE: dc\nCODE:\n```\n!>_r_\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise OR Operation\nDESCRIPTION: This code snippet showcases the bitwise OR operation between two 64-bit integer inputs. The 'bor' function is utilized for performing the bitwise OR operation on the provided input values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_26\n\nLANGUAGE: Text\nCODE:\n```\nbor(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left Operation (64-bit)\nDESCRIPTION: Performs a bitwise rotate left operation on a 64-bit integer. The function `brol64` rotates the bits to the left by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_91\n\nLANGUAGE: C\nCODE:\n```\nbrol64(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Conditional Statements (if/else) in BC\nDESCRIPTION: This snippet showcases various conditional statements using `if` and `else` in BC. It demonstrates comparison operators like `==`, `<=`, `>=`, `!=`, `<`, and `>` used within the conditional expressions. It also shows nested `if/else` structures.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\nif (x() == y()) { 1 }\n1\nif (x() <= y()) { 2 }\nif (y() >= x()) { 3 }\nif (x() != y()) { 4 }\nif (x() < y()) { 5 }\nif (y() > x()) { 6 }\n\nif (x() == z()) { 11 }\n11\nif (x() <= z()) { 12 }\nif (z() >= x()) { 13 }\nif (x() != z()) { 14 }\nif (x() < z()) { 15 }\nif (z() > x()) { 16 }\n\nif (x == -4) x\nelse x - 4\n\nx = 1\n\nif (x == 1) 1 else 2\nif (x == 0) 1 else 2\n\nif (x == 1) 1 else if (x == 0) 2 else 3\nif (x == 0) 1 else if (x == 1) 2 else 3\nif (x == -1) 1 else if (x == 0) 2 else 3\n\nif (x == 1) if (x != 0) 1 else 2 else 3\nif (x == 1) if (x == 0) 1 else 2 else 3\nif (x != 1) if (x == 0) 1 else 2 else 3\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (32-bit) Operation\nDESCRIPTION: This snippet demonstrates rotating bits to the right in a 32-bit number using 'bror32'. The bits are rotated by the amount specified in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_68\n\nLANGUAGE: Text\nCODE:\n```\nbror32(433984901, 363382439)\n```\n\n----------------------------------------\n\nTITLE: For Loop with Initialization and No Condition\nDESCRIPTION: This snippet shows a for loop with initialization but no condition or increment expression.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_15\n\nLANGUAGE: bc\nCODE:\n```\nfor (x=0;;) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Equal)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is equal to the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_11\n\nLANGUAGE: dc\nCODE:\n```\n=_r_\n```\n\n----------------------------------------\n\nTITLE: Function 'a' with Numerical Arguments\nDESCRIPTION: This snippet demonstrates calls to a function 'a' with various numerical inputs, including positive, negative, integer, and floating-point values.  It is likely testing the function's behavior across different numerical ranges. No specific language is indicated.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arctangent.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\na(.267)\na(1)\na(.267)\na(1)\na(.267)\na(1)\na(0)\na(.5)\na(0.577350269189625764509148780501)\na(1.5)\na(1.7320508075688772935274463415)\na(2)\na(3)\na(1000)\na(-.5)\na(-0.577350269189625764509148780501)\na(-1.5)\na(-1.7320508075688772935274463415)\na(-2)\na(-3)\na(-1000)\na(-3249917614.2821897119)\na(-694706362.1974670468)\na(-816494969)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (32-bit)\nDESCRIPTION: Reverses the bits of a 32-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_126\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (64-bit)\nDESCRIPTION: Rotates the bits of a 64-bit number to the right by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_135\n\nLANGUAGE: N/A\nCODE:\n```\nbror64(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: bc Quit Statement Example\nDESCRIPTION: Illustrates the difference in behavior of the `quit` statement between different bc implementations. This bc implementation executes completed statements before quitting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: Scale Adjustment\nDESCRIPTION: This snippet shows the assignment of different integer values to a variable named 'scale'. It suggests that 'scale' likely influences the behavior or output of the function 'a' when called. No specific language is indicated.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arctangent.txt#_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\nscale = 64\nscale = 100\nscale = 20\nscale = 22\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop\nDESCRIPTION: This code snippet demonstrates an infinite loop using the 'while (1)' construct. The loop continues to execute indefinitely unless a 'break' or 'return' statement is encountered within the loop's body.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/18.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nwhile (1) {\n\n\n\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right Operation (8-bit)\nDESCRIPTION: Performs a bitwise rotate right operation on an 8-bit integer. The function `bror8` rotates the bits to the right by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_92\n\nLANGUAGE: C\nCODE:\n```\nbror8(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Evaluating f(x) in bc\nDESCRIPTION: This snippet shows how to evaluate a function 'f' with different integer arguments using bc. The function 'f' is assumed to be defined elsewhere within the bc script or environment. This example demonstrates calling the function f with arguments 0 through 5.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_fac.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nf(0)\nf(1)\nf(2)\nf(3)\nf(4)\nf(5)\n```\n\n----------------------------------------\n\nTITLE: Define array squaring function in BC\nDESCRIPTION: This BC script defines a function `a2` that takes an array `a[]` and its length `len` as input. The function iterates through the array, squares each element, and then calls the `printarray` function to output the modified array.  It depends on the `printarray` function being defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/38.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine a2(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = a[i] * a[i]\n\t}\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right Operation (64-bit)\nDESCRIPTION: Performs a bitwise rotate right operation on a 64-bit integer. The function `bror64` rotates the bits to the right by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_95\n\nLANGUAGE: C\nCODE:\n```\nbror64(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (32-bit) Operation\nDESCRIPTION: This code rotates the bits to the left in a 32-bit value with 'brol32'. The number of positions to rotate by is indicated by the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_52\n\nLANGUAGE: Text\nCODE:\n```\nbrol32(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: While Loop with Compound Condition (OR)\nDESCRIPTION: This snippet demonstrates a while loop with a compound condition using '||' (OR). The loop continues as long as 'q' is not equal to 0 OR 'x' is equal to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_10\n\nLANGUAGE: bc\nCODE:\n```\nwhile (q!=0 || x==0) { ++q; }\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic in bc\nDESCRIPTION: This snippet performs a simple addition operation using the bc calculator language. It demonstrates the most basic functionality of the bc interpreter: evaluating arithmetic expressions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line2.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n1+1\n```\n\n----------------------------------------\n\nTITLE: Dividing BclNumber objects, keeping originals in C\nDESCRIPTION: Divides BclNumber 'a' by 'b' and returns the result. The scale of the result is the scale of the current context.  'b' cannot be zero. Unlike `bcl_div`, 'a' and 'b' are not consumed. Possible errors include invalid number, invalid context, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_div_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (=r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is equal to the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_12\n\nLANGUAGE: dc\nCODE:\n```\n=r es\n```\n\n----------------------------------------\n\nTITLE: Defining a3 function: Initialize, square, and print (bc)\nDESCRIPTION: The `a3` function initializes an array `a__[]` with values from 0 to `len-1`, then squares each element using function `a4`, and finally prints the resulting array using the function `printarray`. The function takes an array pointer `*a__[]` and the length of the array as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine a3(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta4(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Push Leading Zero Setting Status in DC\nDESCRIPTION: This snippet explains the 'gz' command, which pushes 0 onto the stack if the leading zero setting has not been enabled, and non-zero otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_24\n\nLANGUAGE: dc\nCODE:\n```\ngz\n```\n\n----------------------------------------\n\nTITLE: Setting Scale in BC\nDESCRIPTION: This snippet demonstrates setting the `scale` variable in `bc`. The `scale` variable controls the number of digits after the decimal point in calculations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/atan.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nscale = 1\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Left Operation\nDESCRIPTION: Demonstrates the bitwise shift left operation (bshl) on integers. The function takes two arguments: the integer to be shifted and the number of bits to shift. It shifts the bits of the first argument to the left by the specified number of bits, filling the vacated positions with zeros. The operation is performed on different integer sizes.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_165\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(118065830, 19)\nbshl(2172522771, 6)\nbshl(357761056, 10)\nbshl(3404262154, 0)\nbshl(3311702021, 25)\nbshl(2974346297, 5)\n```\n\n----------------------------------------\n\nTITLE: Global Stacks Alternative Function\nDESCRIPTION: This bc(1) code snippet shows an alternative implementation of the `output` function *without* using the `-g` or `--global-stacks` option. This requires saving and restoring the original `obase` value to avoid affecting other functions, making the code more complex.  It illustrates the benefit of global stacks for simplified function writing.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n auto c\n c=obase\n obase=b\n x\n obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Bit Modification (64-bit) Operation\nDESCRIPTION: Performs a bit modification operation on a 64-bit representation of the input value. This function likely modifies the bit value based on an internal algorithm. `bmod64` operates on a 64-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_24\n\nLANGUAGE: N/A\nCODE:\n```\nbmod64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: test2.bc Execution Command\nDESCRIPTION: This command executes the test2.bc script using bc, measures the time taken, and discards the output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_10\n\nLANGUAGE: Shell Script\nCODE:\n```\ntime -p [bc] ../test2.bc > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation\nDESCRIPTION: Performs a bitwise OR operation on two large integer values. This operation compares the bits of the two input numbers, and if either of the bits is 1, the corresponding result bit is set to 1; if both are 0, the result bit is 0.  It returns the bitwise OR of the two operands.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\nbor(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse Operation (16-bit)\nDESCRIPTION: Performs a bitwise reverse operation on a 16-bit integer. The function `brev16` reverses the order of bits in the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_85\n\nLANGUAGE: C\nCODE:\n```\nbrev16(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: While Loop with Negation\nDESCRIPTION: This snippet demonstrates a while loop with a negated condition.  The loop continues as long as 'q' is equal to 0, as the negation operator '!' is applied to 'q'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_11\n\nLANGUAGE: bc\nCODE:\n```\nwhile (!q) { ++q; }\n```\n\n----------------------------------------\n\nTITLE: Division with Modulus in BclNumber (bcl_divmod)\nDESCRIPTION: This function divides BclNumber *a* by *b*, placing the quotient in the location pointed to by *c*, and the modulus in the location pointed to by *d*. *b* cannot be 0, and *a* and *b* are consumed. *c* and *d* cannot point to the same location, or to the space occupied by *a* or *b*. Returns BCL_ERROR_NONE on success; otherwise, an error code.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nBclError bcl_divmod(BclNumber* _a_**, BclNumber* _b_**, BclNumber* _c_**, BclNumber* _d_**)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift Operation\nDESCRIPTION: Performs a bitwise right shift operation. The function `bshr` takes an integer and shifts it right by the specified number of bits. The result depends on the integer size.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_79\n\nLANGUAGE: C\nCODE:\n```\nbshr(754174378, 4)\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation\nDESCRIPTION: Demonstrates the bitwise OR operation (bor) with two 64-bit integer arguments.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_141\n\nLANGUAGE: N/A\nCODE:\n```\nbor(16527427662727213300, 6651564814332221722)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (16-bit) Operation\nDESCRIPTION: This code performs a bitwise rotate right on a 16-bit integer using 'bror16'. The second argument defines the number of bits to rotate.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_62\n\nLANGUAGE: Text\nCODE:\n```\nbror16(5509, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Function Call h with Array Arguments in BC\nDESCRIPTION: This snippet calls the function `h(x[], y[])`. The expected behavior is that `h` will call `g(x[], y[])` and return the difference between the first elements of arrays `x[]` and `y[]` (x[0] - y[0] = 5 - 4).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\nh(x[], y[])\n```\n\n----------------------------------------\n\nTITLE: Order of evaluation in bc: Function arguments\nDESCRIPTION: This example demonstrates the left-to-right evaluation order in bc, specifically how increment operators interact with function arguments. The first argument passed to **x()** is **0**, and the second argument is **1**, while **i** is equal to **2** before the function starts executing.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\nx(i++, i++)\n```\n\n----------------------------------------\n\nTITLE: Calculating Power of BclNumber objects in C\nDESCRIPTION: Calculates 'a' to the power of 'b' to the scale of the current context and returns the result.  'b' must be an integer and can be negative; if negative, 'a' must not be zero. 'a' must be smaller than BC_OVERFLOW_MAX. 'a' and 'b' are consumed unless the `_keep` variant is used. Errors may include invalid number, context, non-integer exponent, overflow, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_pow(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: ASCII Array Assignment and Conversion in BC\nDESCRIPTION: This BC code snippet demonstrates assigning ASCII values to an array 'a[]' and then converting the array into a string using the asciify() function. The resulting string is stored in the variable 'x'. The script also prints the converted string along with the literal ' Sup!'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/asciify_array.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\na[0] = 72\na[1] = 101\na[2] = 108\na[3] = 108\na[4] = 111\na[5] = 44\na[6] = 32\na[7] = 87\na[8] = 111\na[9] = 114\na[10] = 108\na[11] = 100\na[12] = 33\nasciify(a[])\nx = asciify(a[])\nx\nprint x, \" Sup!\\n\"\n```\n\n----------------------------------------\n\nTITLE: DC Script Snippet 5\nDESCRIPTION: Another DC script snippet with stack operations, register assignments and 'zsdc' at the end. Seems to be part of a larger series of scripts performing similar tasks with slight variations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n*sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsdc\n0sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsW\n```\n\n----------------------------------------\n\nTITLE: bc for loop with conditional logic\nDESCRIPTION: This bc script demonstrates a for loop that iterates 'A' times. Inside the loop, several nested 'if' statements are used to conditionally execute different code blocks. The script prints 'n' and assigns numerical values based on the outcomes of these conditional checks. Requires the variable 'A' to be defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/misc3.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < A; ++i)\n{\nprint \"n\"\nif(1)if(1){3\n}\nif(0)if(1){3\n}\nelse 4\nif(0){if(1){3\n}}\nelse 5\n{i}\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (8-bit)\nDESCRIPTION: Rotates the bits of an 8-bit number to the right by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_132\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (32-bit) Operation\nDESCRIPTION: This snippet performs a bitwise rotate left operation on a 32-bit value using the 'brol32' function. It rotates the bits by the amount specified in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_53\n\nLANGUAGE: Text\nCODE:\n```\nbrol32(433984901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (16-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate right operation on a 16-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_18\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Left Operation\nDESCRIPTION: Performs a bitwise shift left operation on an integer value. The `bshl` function shifts the bits of the first argument (an integer) to the left by the number of positions specified by the second argument.  It returns the shifted value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_3\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(2366588185, 0)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(347743040, 25)\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Right (32-bit) Operation\nDESCRIPTION: Performs a bit rotation right operation on a 32-bit representation of the input. This rotates the bits of the input value to the right by a specified number of positions, wrapping the shifted bits around to the other end. `bror32` specifically handles 32-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_19\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(2366588185, 347743040)\n```\n\n----------------------------------------\n\nTITLE: BC Script Execution\nDESCRIPTION: This snippet shows a sequence of BC commands that are likely executed in the BC environment. These commands include calls to the `i` and `o` functions and setting/accessing `ibase` and `obase` variables, potentially for number base conversion operations, along with some potentially erroneous code.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/19.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\ni(11)\nibase\n_(12)\nobase\nr(15)\nsMale\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (8-bit) Operation\nDESCRIPTION: Demonstrates the bitwise NOT operation (bnot8) on an 8-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_145\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(244)\n```\n\n----------------------------------------\n\nTITLE: Boolean AND with NOT Operators\nDESCRIPTION: This snippet combines the boolean AND operator '&&' with the NOT operator '!'.  It demonstrates how the negation of integer literals affects the outcome of the AND operation. Remember that non-zero values are considered 'true' unless negated.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_2\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n!4 && 5\n!4 && 0\n!0 && 5\n4 && !5\n4 && !0\n0 && !5\n!4 && 5 && 7\n!4 && 0 && 7\n!0 && 5 && 7\n!4 && 5 && 0\n!0 && 0 && 7\n!4 && 0 && 0\n!0 && 5 && 0\n4 && !5 && 7\n4 && !0 && 7\n0 && !5 && 7\n4 && !5 && 0\n0 && !0 && 7\n4 && !0 && 0\n0 && !5 && 0\n4 && 5 && !7\n4 && 0 && !7\n0 && 5 && !7\n4 && 5 && !0\n0 && 0 && !7\n4 && 0 && !0\n0 && 5 && !0\n!4 && !5 && 7\n!4 && !0 && 7\n!0 && !5 && 7\n!4 && !5 && 0\n!0 && !0 && 7\n!4 && !0 && 0\n!0 && !5 && 0\n!4 && 5 && !7\n!4 && 0 && !7\n!0 && 5 && !7\n!4 && 5 && !0\n!0 && 0 && !7\n!4 && 0 && !0\n!0 && 5 && !0\n4 && !5 && !7\n4 && !0 && !7\n0 && !5 && !7\n4 && !5 && !0\n0 && !0 && !7\n4 && !0 && !0\n0 && !5 && !0\n!4 && !5 && !7\n!4 && !0 && !7\n!0 && !5 && !7\n!4 && !5 && !0\n!0 && !0 && !7\n!4 && !0 && !0\n!0 && !5 && !0\n```\n\n----------------------------------------\n\nTITLE: Bitwise MOD (8-bit) Operation\nDESCRIPTION: Demonstrates the bitwise MOD operation (bmod8) on an 8-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_161\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(5205211806348135630)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(206)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (8-bit) Example\nDESCRIPTION: Demonstrates the bitwise NOT operation (`bnot8`) on an 8-bit integer (represented here as a 64-bit integer).  The operation inverts each bit of the input value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_107\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(15629579542790190053)\n```\n\n----------------------------------------\n\nTITLE: Define Input Base Function in BC\nDESCRIPTION: This snippet defines a function `i(x)` in BC. The function sets the input base to a given value `x` and then executes `i(11)`, `ibase`, `o(12)` and `ase`. The purpose of this function appears to be setting the input base.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/19.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine i(x) {\n\ni(11)\nibase\no(12)`ase\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Integer Ten Plus Decimal\nDESCRIPTION: Demonstrates bitwise right shift operations on the numbers 10.01, 10.001, 10.0001, 10.00001, 10.000001, 10.0000001, 10.00000001 and 10.000000001. The number of bits shifted ranges from 0 to 19 in each case.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_10\n\nLANGUAGE: bc\nCODE:\n```\n10.01 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.0001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.00001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.0000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.00000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n10.000000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation\nDESCRIPTION: Demonstrates the bitwise NOT operation (bnot) on integers of different sizes (8, 16, 32, and 64 bits). This operation flips each bit of the input integer. Each function (bnot8, bnot16, bnot32, bnot64) is specific to the size of the integer being operated on.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_167\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(6960136430480362150)\nbnot8(166)\nbnot16(6960136430480362150)\nbnot16(35494)\nbnot32(6960136430480362150)\nbnot32(118065830)\nbnot64(6960136430480362150)\nbnot8(869320618226679840)\nbnot8(32)\nbnot16(869320618226679840)\nbnot16(32)\nbnot32(869320618226679840)\nbnot32(357761056)\nbnot64(869320618226679840)\nbnot8(11784620717065408517)\nbnot8(5)\nbnot16(11784620717065408517)\nbnot16(36869)\nbnot32(11784620717065408517)\nbnot32(3311702021)\nbnot64(11784620717065408517)\n```\n\n----------------------------------------\n\nTITLE: Define array printing function in BC\nDESCRIPTION: This BC script defines a function `printarray` that takes an array `a[]` and its length `len` as input. The function iterates through the array and prints each element m[i]. It is a basic implementation for visualizing array contents within BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/38.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine printarray(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\tm[i]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Output\nDESCRIPTION: This snippet shows how to print a string and a variable's value in bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nprint \"i: \", i\n```\n\n----------------------------------------\n\nTITLE: String Assignment\nDESCRIPTION: This snippet assigns the string \"stuff\" to the variable `v`.  While bc supports variables, it doesn't natively support string types in the way other languages do.  This will be interpreted as an arithmetic expression.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_27\n\nLANGUAGE: bc\nCODE:\n```\nv = \"stuff\"\n```\n\n----------------------------------------\n\nTITLE: ASCII Array to String Conversion and Output in BC\nDESCRIPTION: This BC code initializes an array `a` with ASCII values, converts it into a string using a custom `asciify` function (assumed to be defined elsewhere or built-in), assigns the result to variable `x`, and prints `x` along with the string \" Sup!\\n\". This snippet requires a defined or built-in `asciify` function that can handle an array of numbers as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/asciify_array.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\na[0] = 72\na[1] = 101\na[2] = 108\na[3] = 108\na[4] = 111\na[5] = 44\na[6] = 32\na[7] = 87\na[8] = 111\na[9] = 114\na[10] = 108\na[11] = 100\na[12] = 33\nasciify(a[])\nx = asciify(a[])\nx\nprint x, \" Sup!\\n\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (16-bit)\nDESCRIPTION: Performs a modulo operation based on the size of a 16 bit number. The inputs are truncated to 16 bits before being used as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_137\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Relational and OR Operators\nDESCRIPTION: This snippet combines relational operators (<, >, >=, ==, !=) with the boolean OR operator '||'. It demonstrates the order of operations, where relational comparisons are performed first, and the results are then combined using the OR operator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_6\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n3 < 4 || 7\n3 || 4 >= 4\n3 > 4 || 7\n3 || 4 >= 5\n3 < 4 || 0\n0 || 4 >= 4\n3 > 4 || 0\n0 || 4 >= 5\n3 > 4 || 0\n0 || 4 < 4\n3 >= 4 || 0\n0 || 4 >= 5\n3 < 4 || 7\n3 || 4 >= 4\n3 > 4 || 7 > 4\n3 >= 2 || 4 >= 5\n3 < 4 || 0 > -1\n4 < 3 || 4 >= 4\n3 > 4 || 3 == 3\n3 != 3 || 4 >= 5\n3 > 4 || 0 > 1\n0 >= 0 || 4 < 4\n3 >= 4 || 0 >= 1\n0 <= -1 || 4 >= 5\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (8-bit) Operation\nDESCRIPTION: This snippet performs a bitwise NOT operation on an 8-bit value using the 'bnot8' function. It inverts all bits of the input, treating it as an 8-bit unsigned integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_31\n\nLANGUAGE: Text\nCODE:\n```\nbnot8(133)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bc Macros\nDESCRIPTION: This snippet defines and uses macros in bc. The macro `M` appears to involve string manipulation and conditional execution based on the result of a comparison. The `pR` macro likely prints a string to standard output. There are potentially issues with the encoding of characters within the string literals.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/23.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n[[Done\\n]pR]SM[lip1-si0li`LeM]sL10silLx\n```\n\n----------------------------------------\n\nTITLE: Testing unsigned byte values with ubytes()\nDESCRIPTION: These test values are designed to evaluate the behavior of the `ubytes()` function with various integer inputs. The tests include zero, small positive numbers, boundary values for different byte sizes (e.g., 255, 65535, 4294967295, 18446744073709551615), and values exceeding these boundaries to confirm proper handling of overflow or truncation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_bytes.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\nubytes(0)\nubytes(1)\nubytes(2)\nubytes(254)\nubytes(255)\nubytes(256)\nubytes(65535)\nubytes(65536)\nubytes(131072)\nubytes(4294967295)\nubytes(4294967296)\nubytes(18446744073709551615)\nubytes(18446744073709551616)\n```\n\n----------------------------------------\n\nTITLE: Configuring bc/dc with Coverage\nDESCRIPTION: These commands configure the build process to enable test coverage reporting. The `-c` flag and `--coverage` option are equivalent, requiring both `bc` and `dc` to be built.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_32\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh -c\n```\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh --coverage\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (32-bit) Operation\nDESCRIPTION: This code computes a bitwise modulo on a 32-bit number utilizing 'bmod32'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_74\n\nLANGUAGE: Text\nCODE:\n```\nbmod32(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Nested if statement in C-like syntax\nDESCRIPTION: This snippet shows a nested 'if' statement. The outer 'if' checks if 1 is less than 3. If true, it proceeds to the inner 'if', which checks if 2 is less than 3. If both conditions are true, the value 1 is returned.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/stdin1.txt#_snippet_0\n\nLANGUAGE: C-like\nCODE:\n```\nif (1 < 3)\n\tif (2 < 3) 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in bc\nDESCRIPTION: This snippet defines a function named 'a' in the bc language. The function takes one argument, 'x', and prints a string that includes the function name and the value of the argument followed by a newline character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line2.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine a (x) {\n\tprint \"a(\", x, \")\\n\"\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and processing array (a3) in BC\nDESCRIPTION: This function, `a3`, initializes the provided array `a__[]` from index 0 to `len-1` with values corresponding to their index. After initialization, it calls function `a4` to square each array element and finally calls `printarray` to display the array elements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine a3(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta4(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Right Shift with Keep in BclNumber (bcl_rshift_keep)\nDESCRIPTION: This function shifts a BclNumber *a* to the right by *b* places, effectively moving the radix to the left. The shift is performed in decimal. *b* must be an integer, and *a* and *b* can be the same number. Possible errors are encoded in the return value, and can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_rshift_keep(BclNumber* _a_**, BclNumber* _b_**)\n```\n\n----------------------------------------\n\nTITLE: BC Array Element Addition\nDESCRIPTION: This snippet shows how to add two array elements together in BC. It adds the value of a[0] to itself, demonstrating a basic arithmetic operation using array elements. The result of the addition is implicitly printed by BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/arrays.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\na[0]+a[0]\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Integer Plus Decimal\nDESCRIPTION: Shows bitwise right shift operations on the number 1.01. The right-hand side of the operation varies from 0 to 19. This demonstrates the behavior of the bitwise operator with a simple floating-point value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\n1.01 >> 0\n```\n\n----------------------------------------\n\nTITLE: Decimal Division BC\nDESCRIPTION: Illustrates decimal division within BC calculator. It includes examples with decimal numbers, both positive and negative. No dependencies, directly runnable in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divide.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\n0 / 0.3984567238456\n1 / 0.2395672438567234\n1 / 237586239856.0293596728392360\n9348576237845624358 / 0.9857829375461\n35768293846193284 / 2374568947.045762839567823\n-356789237555535468 / 0.3375273860984786903\n-5203475364850390 / 435742903748307.70869378534043296404530458\n-0.37861723347576903 / 7385770896\n-0.399454682043962 / 0.34824389304\n-0.6920414523873204 / 356489645223.76076045304879030\n-35872917389671.7573280963748 / 73924708\n-78375896314.4836709876983 / 0.78356798637817\n-2374123896417.143789621437581 / 347821469423789.1473856783960\n-2374568293458762348596 / -0.8792370647234987679\n-237584692306721845726038 / -21783910782374529637.978102738746189024761\n-0.23457980123576298375682 / -1375486293874612\n-0.173897061862478951264 / -0.8179327486017634987516298745\n-0.9186739823576829347586 / -0.235678293458756239846\n-0.9375896183746982374568 / -13784962873546.0928729395476283745\n-2930754618923467.12323745862937465 / -734869238465\n-23745861923467.874675129834675 / -0.23542357869124756\n-3878923750692883.7238596702834756902 / -7384192674957215364986723.9738461923487621983\n1 / 0.00000000000000000000000000000000000000000002346728372937352457354204563027\n```\n\n----------------------------------------\n\nTITLE: Calling a Function in bc\nDESCRIPTION: This snippet calls the function 'a' that was defined previously, passing the value 10 as an argument. This triggers the function to print the string 'a(10)\\n' to the standard output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line2.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\na(10)\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (32-bit) Operation\nDESCRIPTION: This code showcases the bit reversal of a 32-bit value using 'brev32'. It reverses the order of bits in the given 32-bit unsigned integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_42\n\nLANGUAGE: Text\nCODE:\n```\nbrev32(433984901)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Very Small Floating Point Number\nDESCRIPTION: Illustrates the usage of the right shift operator (>>) on the number 0.0000000001 with varying shift amounts (0 to 19).  The result depends on how BC handles floating point numbers in bitwise operations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\n0.0000000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Convert Number to ASCII Character in DC\nDESCRIPTION: This snippet explains the 'a' command, which converts a number on the stack to its ASCII character representation, or extracts the first character from a string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Reinitializing bc Script with Loop\nDESCRIPTION: This bc script snippet re-initializes the 'i' and 'x' variables and defines a macro 'x' that simulates a loop. It sets up 'i' and 'x' to 0 and then defines a macro 'x' which duplicates the value on the top of the stack, loads 'i', duplicates the value on the stack, loads 'i' again, increments it by 1, stores it back into 'i', compares it with 10, and executes 'x' again if 'i' is less than 10.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/25.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nsi[lid:rli1;rd:rli1;rpRli1+sili10>x]dsxx0sx0si\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (16-bit) Operation\nDESCRIPTION: Performs a bitwise NOT operation on a 16-bit representation of the input. This flips each bit: 0 becomes 1, and 1 becomes 0. The function `bnot16` operates specifically on a 16-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_6\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(17689)\n```\n\n----------------------------------------\n\nTITLE: For Loop with Initialization and Empty Increment\nDESCRIPTION: This snippet shows a for loop with initialization and a condition.  The third expression is empty.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_14\n\nLANGUAGE: bc\nCODE:\n```\nfor (x=0; x<0;) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Function Calls and Variable Scoping in BC\nDESCRIPTION: This snippet demonstrates how to call user-defined functions and pass arguments to them in BC. It highlights the interaction between local variables within functions and global variables outside of functions. The examples show how variable values change after function calls, and how arguments passed by value are affected by operations inside the function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_5\n\nLANGUAGE: BC\nCODE:\n```\na = 4\n\nx(a)\ni\n\nx(a *= 5)\na\ni\n\na = 4\n\ny(a)\ni\n\ny(a -= 2)\na\ni\n\na = 4\n\nz(a)\ni\n\nz(a /= 0.5)\na\ni\n```\n\n----------------------------------------\n\nTITLE: Initializing and processing array (a5) in BC\nDESCRIPTION: This function, `a5`, initializes the provided array `a__[]` from index 0 to `len-1` with values corresponding to their index. After initialization, it calls function `a2` to square each array element and finally calls `printarray` to display the array elements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ndefine a5(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta2(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Execution Stack Depth in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the ',' command in dc(1) that pushes the depth of the execution stack onto the stack.  The sequence ',Q' will exit the dc(1) program. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_18\n\nLANGUAGE: dc\nCODE:\n```\n,\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift Example\nDESCRIPTION: Demonstrates the bitwise right shift operation (`bshr`) on a 32-bit integer. The operation shifts the bits of the first argument to the right by the number of positions specified by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_106\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(4239963109, 28)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Less Than)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not less than the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_9\n\nLANGUAGE: dc\nCODE:\n```\n!<_r_\n```\n\n----------------------------------------\n\nTITLE: Large Number Multiplication\nDESCRIPTION: Demonstrates multiplication with very large numbers and large decimal numbers, perhaps used to test the precision limits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_4\n\nLANGUAGE: NA\nCODE:\n```\n37164201 * 2931559660\n679468076118972457796560530571.46287161642138401685 * 93762.2836\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (32-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 32-bit number, inverting all the bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_122\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (16-bit) Operation\nDESCRIPTION: This snippet applies a bitwise rotate right on a 16-bit value using the 'bror16' function. The rotation occurs according to the amount given by the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_63\n\nLANGUAGE: Text\nCODE:\n```\nbror16(2384001591844672901, 50855)\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation\nDESCRIPTION: Demonstrates the bitwise XOR operation (bxor) with two 64-bit integer arguments.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_142\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(16527427662727213300, 6651564814332221722)\n```\n\n----------------------------------------\n\nTITLE: Shell Aliases for Number Conversion\nDESCRIPTION: These shell alias examples demonstrate how to use bc(1) as a number converter by setting `ibase` and `obase` using the `-e` or `--expression` option.  These aliases can be used to convert between decimal, octal, and binary number systems. The aliases provide a convenient way to perform number base conversions without writing complex bc(1) scripts.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Array Iteration and Function Calls in BC\nDESCRIPTION: This snippet iterates through the array `a[]` from index 0 to `l`, printing each element.  It calls functions `z(a[])` and `x(a[])` to manipulate the array, then calls `z(a[])` again. Finally, it accesses the global variable `l` and initializes elements of arrays `x` and `y`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i <= l; ++i) {\n\ta[i]\n}\n\nz(a[])\nx(a[])\nz(a[])\nl\n\nx[0] = 5\ny[0] = 4\n```\n\n----------------------------------------\n\nTITLE: Configuring GNU predefined build\nDESCRIPTION: Configures the build for bc and dc to be compatible with the GNU versions. This sets up a release build with GNU compatibility.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -pGNU\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --predefined-build-type=GNU\n```\n\n----------------------------------------\n\nTITLE: Mathematical operations and r2d function calls\nDESCRIPTION: This snippet demonstrates a series of calculations involving the variable 'p' and the function 'r2d'. 'p' is initialized by calling the function 'pi(100)'. The 'r2d' function is then called with various arguments derived from 'p' using multiplication and division.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_r2d.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\np=pi(100)\nr2d(p)\nr2d(2 * p)\nr2d(p / 2)\nr2d(p / 4)\nr2d(p / 3)\nr2d(p / 5)\nr2d(p / 6)\nr2d(p / 10)\nr2d(-p)\nr2d(2 * -p)\nr2d(-p / 2)\nr2d(-p / 4)\nr2d(-p / 3)\nr2d(-p / 5)\nr2d(-p / 6)\nr2d(-p / 10)\n```\n\n----------------------------------------\n\nTITLE: Updating Coverage Output with rig\nDESCRIPTION: This command updates the test coverage output after performing manual executions that may not have been covered by automated tests. It requires that the coverage analysis has been initialized before.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nrig coverage_output\n```\n\n----------------------------------------\n\nTITLE: Defining a4 function: Squaring array elements and printing (bc)\nDESCRIPTION: The `a4` function squares each element of an input array `a__[]` and then prints the array using the `printarray` function. It takes the array and its length `len` as parameters, iterating and performing the squaring operation within a loop.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine a4(a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = a__[i] * a__[i]\n\t}\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a5 function: Initialize with indices, square, and print (bc)\nDESCRIPTION: The `a5` function initializes an array `a__[]` with the index values (0 to len-1), squares each element of the array using the `a2` function, and then prints the resulting array by calling the `printarray` function.  It uses the `a2` squaring function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ndefine a5(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta2(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing bc Script with Loop\nDESCRIPTION: This bc script snippet initializes the 'i' and 'x' variables and defines a macro 'x' that simulates a loop.  It sets up 'i' and 'x' to 0 and then defines a macro 'x' which duplicates the value on the top of the stack, loads 'i', duplicates the value on the stack, loads 'i' again, increments it by 1, stores it back into 'i', compares it with 10, and executes 'x' again if 'i' is less than 10.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/25.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n0si[lid:rli1;rd:rli1;rpRli1+sili10>x]dsxx0sx0si\n```\n\n----------------------------------------\n\nTITLE: Getting Array Length in dc\nDESCRIPTION: Pushes the length of array *r* onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_27\n\nLANGUAGE: dc\nCODE:\n```\nYr\n```\n\n----------------------------------------\n\nTITLE: BC Script with Loop and Quit\nDESCRIPTION: This BC script defines a simple for loop that iterates from 0 to 2. The loop body is empty, represented by `i;`. After the loop completes, the `quit` command is executed to terminate the BC interpreter. The initial '3' may relate to precision setting or some prior context not fully defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_loop_quit1.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n3\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (64-bit)\nDESCRIPTION: Performs a modulo operation based on the size of a 64 bit number. The inputs are truncated to 64 bits before being used as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_139\n\nLANGUAGE: N/A\nCODE:\n```\nbmod64(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Greater Than)\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is greater than the second, the contents of register *r* are executed. An error occurs if either value is not a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n>_r_\n```\n\n----------------------------------------\n\nTITLE: Boolean NOT Operator\nDESCRIPTION: This snippet demonstrates the use of the boolean NOT operator '!' with integer literals. The '!' operator negates the truthiness of the operand; non-zero values are treated as true, and zero is treated as false. Thus, '!0' evaluates to true (represented as 1 in many languages) and '!4' evaluates to false (represented as 0).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_0\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n!0\n!1\n!(-129)\n```\n\n----------------------------------------\n\nTITLE: Addition and Variable Assignment in bc\nDESCRIPTION: This snippet adds 483 to 37 and assigns the result to 'R'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\n037 483+pR\n```\n\n----------------------------------------\n\nTITLE: Simple Numerical Comparisons\nDESCRIPTION: This snippet provides basic examples of numerical comparisons involving positive and negative integers using less than (<) and greater than (>) operators.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/comp.txt#_snippet_2\n\nLANGUAGE: N/A\nCODE:\n```\n4 < 0\n-4 < 0\n4 > 0\n-4 > 0\n5 > 4\n-5 > 4\n5 > -4\n-5 > -4\n5 < 4\n-5 < 4\n5 < -4\n-5 < -4\n```\n\n----------------------------------------\n\nTITLE: BC Modulo and Scale in Combination\nDESCRIPTION: This snippet combines the setting of the 'scale' variable with modulo operations that involve very large numbers and decimals. Each line consists of setting scale = 0, followed by performing the modulo. Due to scale being 0, any fractional component is truncated before performing the modulo calculation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/modulus.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nscale = 0; -899510228 % -2448300078.40314\nscale = 0; -7424863 % -207.2609738667\nscale = 0; 3769798918 % 0.6\n```\n\n----------------------------------------\n\nTITLE: Calculating Modulus of BclNumber objects, keeping originals in C\nDESCRIPTION: Calculates the modulus of 'a' divided by 'b' and returns the result. Division is performed to the scale of the current context.  'b' cannot be zero. Unlike `bcl_mod`, 'a' and 'b' are not consumed. Errors can include invalid number, invalid context, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_mod_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: AddressSanitizer Fuzzing Commands\nDESCRIPTION: These commands build ASan-enabled versions of `bc` and `dc`, and then run them on corpus files generated by AFL++ to check for memory errors. The commands can be run in parallel. A timeout is set to avoid infinite loops during execution.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/fuzz_prep.sh -a\n./scripts/afl.py --asan bc1\n./scripts/afl.py --asan bc2\n./scripts/afl.py --asan bc3\n./scripts/afl.py --asan dc\n```\n\n----------------------------------------\n\nTITLE: For Loop Examples in BC\nDESCRIPTION: This snippet demonstrates different variations of `for` loops in BC, including an infinite loop with a `break` statement and loops with increment/decrement operations.  It shows usage of the `continue` statement.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_6\n\nLANGUAGE: BC\nCODE:\n```\nfor (;;) { 123 ; break; }\nfor (i = 0;; ++i) { i ; if (i == 2) break; else i; }\nfor (i = 0;;!++i) { i ; if (i == 2) break; else i; }\nfor (i = 0;; ++i) { i ; if (i != 2) i else break }\n\nwhile (i > 0) if (i == 1) break else i--\nwhile (i < 3) if (i != 2) i++ else break\n\nfor(i=1; i<=3; i++) { i; if(i==2) continue; print i,i,\"\\n\" }\n```\n\n----------------------------------------\n\nTITLE: Multiplying BclNumber objects, keeping originals in C\nDESCRIPTION: Multiplies two BclNumber objects, 'a' and 'b', and returns the result. The scale of the result is determined by the scales of 'a' and 'b' along with the current context's scale. Unlike `bcl_mul`, 'a' and 'b' are not consumed after the operation. Potential errors include invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_mul_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Adding BclNumber objects, keeping originals in C\nDESCRIPTION: Adds two BclNumber objects, 'a' and 'b', and returns the result. The scale of the result is the maximum of the scales of 'a' and 'b'. Unlike `bcl_add`, 'a' and 'b' are not consumed (freed) after the operation. The function can return various errors, including invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_add_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Running the Test Suite\nDESCRIPTION: This command executes the test suite for bc and dc. It assumes that bc and/or dc have already been built. The command will return an error code if the test suite fails and will print information about the failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nrig test\n```\n\n----------------------------------------\n\nTITLE: Loading tmuxp configuration for fuzzing\nDESCRIPTION: This command loads a tmuxp configuration file, which sets up multiple AFL++ instances for fuzzing.  The `bc_afl.yaml` file contains the configuration details for running AFL++ on bc and dc. It assumes that `tmuxp` is installed and configured.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\ntmuxp load tests/fuzzing/bc_afl.yaml\n```\n\n----------------------------------------\n\nTITLE: Exponentiation with Integers in BC\nDESCRIPTION: These examples demonstrate exponentiation in BC using integer bases and exponents. They cover positive, negative, and zero exponents, as well as positive and negative bases. BC is used for arbitrary precision arithmetic.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/power.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n0 ^ 0\n0 ^ 1\n0 ^ 1894\n1 ^ 0\n39746823 ^ 0\n1 ^ 1\n2 ^ 1\n18927361346 ^ 1\n8937 ^ 98\n1 ^ -1\n2 ^ -1\n10 ^ -1\n683734768 ^ -1\n1 ^ -32467\n2 ^ -53\n23897 ^ -213\n-1 ^ 1\n-1 ^ 2\n-2 ^ 1\n-2 ^ 2\n-237 ^ 294\n-3746 ^ 28\n-1 ^ -1\n-1 ^ -2\n-2 ^ -1\n-2 ^ -2\n-237 ^ -293\n-784 ^ -23\n-86 ^ -7\n```\n\n----------------------------------------\n\nTITLE: Creating shell aliases for number conversion using bc\nDESCRIPTION: These shell aliases demonstrate how to use `bc` to create number converters.  `d2o` converts from decimal (base 10) to octal (base 8), and `h2b` converts from hexadecimal (base 16) to binary (base 2). The aliases use the `-e` option to set the `ibase` and `obase` variables for the conversion.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Left Shifting BclNumber objects, keeping originals in C\nDESCRIPTION: Shifts 'a' left (moves the radix right) by 'b' places (in decimal) and returns the result. 'b' must be an integer. Unlike `bcl_lshift`, 'a' and 'b' are not consumed. Errors can include invalid number, invalid context, non-integer shift value, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_lshift_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: bc(1) Function Definition with -g Option\nDESCRIPTION: Demonstrates function definition using the `-g` (global stacks) option in bc(1).  This simplifies function definitions by automatically saving and restoring the values of `ibase`, `obase`, and `scale` on function calls, eliminating the need for manual saving and restoring of these global variables. The first definition shows usage of global stacks, the second manual saving and restoring.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    obase=b\n    x\n}\n```\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    auto c\n    c=obase\n    obase=b\n    x\n    obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Left Shifting BclNumber objects in C\nDESCRIPTION: Shifts 'a' left (moves the radix right) by 'b' places (in decimal) and returns the result. 'b' must be an integer. 'a' and 'b' are consumed unless the `_keep` variant is used.  Errors can include invalid number, invalid context, non-integer shift value, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_lshift(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Building and Running Tests After Configuration\nDESCRIPTION: These commands first build the `bc` and `dc` calculators using `make`, then execute the test suite.  This assumes `configure.sh` has already been run to set up the build environment.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_31\n\nLANGUAGE: shell\nCODE:\n```\nmake\n```\n\nLANGUAGE: shell\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Example in dc\nDESCRIPTION: This example shows how conditional execution can be achieved in dc using the '>a' command. The code '0 1>a' will execute the contents of register 'a' because 0 is not greater than 1. Conversely, '1 0>a' will not execute register 'a'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/A.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\n0 1>a\n```\n\nLANGUAGE: dc\nCODE:\n```\n1 0>a\n```\n\n----------------------------------------\n\nTITLE: Bitwise Left Shift Operation\nDESCRIPTION: Performs a bitwise left shift operation. The function `bshl` takes an integer and shifts it left by the specified number of bits. The result depends on the integer size.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_78\n\nLANGUAGE: C\nCODE:\n```\nbshl(754174378, 4)\n```\n\n----------------------------------------\n\nTITLE: Multiplication with Scale Setting\nDESCRIPTION: These examples demonstrate the use of 'scale' to control the number of decimal places in the output of the multiplication. This affects the precision of the result.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_6\n\nLANGUAGE: NA\nCODE:\n```\nscale = 0; 237854962 * -26\nscale = 20; -989840367 * -604515309.000000000000000000000000000934882580147931989975995184020932681975029644558793192923907\nscale = 20; 623151276.1106104320046667401793737969130124845763706302869482103753909 * -605483272.00000000000000000000000000000000000000000000000000000000000000000001214399683339235971324443660465351061300645722062237312361947\nscale = 20; -4036255151 * -107387984.0000000000000000000000000000000000000211170318819607129506079448130618538050115777171523510326383\nscale = 19; 207225741.422284845290215111137445727462936392828872808516127361319675 * -1915632919.00000000000000000001200266819789205382734342543620744656564870683107249138254072\nscale = 4; -3700694776.00000000000000000000000001187600351487950366746489017325409746844911432455524847144387 * 3138176186.1604970875815488831816899415825759179598942878342303599901133\nscale = 4; 2471252773 * -2993804686\nscale = 5; -4136888605.1006664686088985948377077150956015758460597074849621165317181 * -356481995.883644326721780591302331282263396633424696084971708651216219\nscale = 10; -1226031704.000000000000000000000000000001604564576253363548680043729535457438899040946479243020383986 * -1255956056\nscale = 19; 1916023355.00000000000000000000000000000000000590795041191824027930567027047057471024023798017409006012644 * -3373891612\nscale = 22; 579072526.647812809110145427578413082391478903947155934872093047795435 * -2359518757\nscale = 16; 3426351583 * -1097923200.1397570019820419234583136053292187927164488359163611530503423\nscale = 29; 2500140133 * 2519408882.136359515749313850856768153433872015185470839039102302348122\nscale = 26; -2643644458 * -1308250843\nscale = 1; -1657954173 * 3046852834.163701388468236163905483103301582741070980569231164917728216\nscale = 19; -2350345163 * 1973064755\n```\n\n----------------------------------------\n\nTITLE: String to ASCII Character\nDESCRIPTION: Pops a value from the stack. If it is a number, it is truncated, its absolute value is taken, and the result mod 256 is calculated to produce an ASCII character string. If it is a string, the first character of the string is converted to a one-character string and pushed to the stack. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Integer Division BC\nDESCRIPTION: Demonstrates integer division in BC calculator.  It shows the operation of dividing two integers and the result. No dependencies, directly executable in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divide.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n0 / 1\n0 / 321566\n1 / 1\n1 / 1287469297356\n378617298617396719 / 35748521\n-78987234567812345 / 876542837618936\n2 / -3\n89237423 / -237856923854\n123647238946 / -12467\n-2 / -3\n-13 / -7\n-15 / -7\n-12784956 / -32746\n-127849612 / -23712347682193\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (8-bit) Operation\nDESCRIPTION: This snippet demonstrates a bitwise rotate left operation using 'brol8'. It rotates the bits of the first 64-bit argument (treated as 8-bit) to the left by the number of positions specified by the second 64-bit argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_44\n\nLANGUAGE: Text\nCODE:\n```\nbrol8(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Addition and Variable Assignment in bc\nDESCRIPTION: This snippet demonstrates basic addition and assignment. It adds 1 to 'p' and assigns the result to 'R'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\n1 1+pR\n```\n\n----------------------------------------\n\nTITLE: Comments in BC\nDESCRIPTION: Demonstrates the use of multiline comments enclosed in /* and */ symbols. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_15\n\nLANGUAGE: BC\nCODE:\n```\n2 + /*\n*/3\n```\n\n----------------------------------------\n\nTITLE: Evaluating BC Math Expressions\nDESCRIPTION: This snippet shows the execution of multiple 'c' function calls within the bc calculator environment. It sets the scale for decimal precision and evaluates the function 'c' with both constant numeric values and values derived from variable 'p'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/cosine.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nscale = 25\np = 4 * a(1)\nscale = 20\nc(0)\nc(0.5)\nc(1)\nc(2)\nc(3)\nc(-0.5)\nc(-1)\nc(-2)\nc(-3)\nc(p / 7)\nc(-p / 7)\nc(p / 4)\nc(-p / 4)\nc(p / 3)\nc(-p / 3)\nc(p / 2)\nc(-p / 2)\nc(3 * p / 4)\nc(3 * -p / 4)\nc(p)\nc(-p)\nc(3 * p / 2)\nc(3 * -p / 2)\nc(7 * p / 4)\nc(7 * -p / 4)\nc(13 * p / 4)\nc(13 * -p / 4)\nc(2 * p)\nc(2 * -p)\nc(131231)\nc(-131231)\nc(859799894.3562378245)\nc(859799894.3562378245)\nc(4307371)\nc(3522556.3323810191)\nc(44961070)\nc(6918619.1574479809)\nc(190836996.2180244164)\nc(34934)\nc(2483599)\nc(13720376)\n```\n\n----------------------------------------\n\nTITLE: Exponentiation with Decimals in BC\nDESCRIPTION: These examples show exponentiation in BC using decimal bases and exponents, highlighting BC's arbitrary precision. They test cases involving decimal bases raised to integer exponents and integer bases raised to decimal exponents.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/power.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\n0.238672983047682 ^ 0\n0.23523785962738592635777 ^ 1\n0.124876812394 ^ 2396\n38579623756.897937568235 ^ -1\n-0.3548 ^ 35\n-4267.234 ^ 37\n-326.3246 ^ 78\n-0.23424398 ^ -781\n-178.234786 ^ -879\n-1274.346 ^ -768\n18394762374689237468.97354862973846 ^ 0\n328956734869213746.89782398457234 ^ 1\n93762.2836 ^ 13\n-0.2959371298 ^ 227\n```\n\n----------------------------------------\n\nTITLE: Nested Conditional Statement in C-like language\nDESCRIPTION: This code snippet demonstrates a nested conditional statement.  The outer `if` checks if 1 is less than 3. If true, the inner `if` checks if 2 is less than 3. If both conditions are true, the code evaluates to 1.  This example relies on implicit return.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc6.txt#_snippet_0\n\nLANGUAGE: C-like\nCODE:\n```\nif (1 < 3)\n\tif (2 < 3) 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Function in bc\nDESCRIPTION: This snippet shows the general syntax for defining a function in bc.  It includes the function name (I), parameter list, auto variables, statements within the function, and a return statement. Any I in the parameter list or auto list may be replaced with I[] to make a parameter or auto var an array, and any I in the parameter list may be replaced with *I[] to make a parameter an array reference.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '>' in dc(1)\nDESCRIPTION: This snippet explains the '>' command in dc(1) that conditionally executes a register based on a greater-than comparison. The command pops two numbers from the stack. If the first number is greater than the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n>r\n```\n\n----------------------------------------\n\nTITLE: Defining Functions in BC\nDESCRIPTION: This snippet demonstrates the definition of three functions in BC: `x`, `y`, and `z`. Each function takes a single argument `x` and performs some arithmetic operation involving `x` and a global variable `i`. The `return` statement specifies the function's return value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/assignments.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine x(x) {\n\treturn (i++ + x)\n}\ndefine y(x) {\n\treturn (++i + x)\n}\ndefine z(x) {\n\treturn (i *= 2) + x\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Conditional For Loops C\nDESCRIPTION: This snippet contains nested 'for' loops and nested 'if' statements.  The outer 'for' loop iterates based on variable 'j', while the inner loop iterates based on 'i'. Both loops contain 'if' statements with simple less than comparisons. If both conditions are met, '3' is executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/stdin2.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nfor (j = 0; j < 3; ++j) if (5 < 6) for (i = 0; i < 3; ++i) if (4 < 5) 3\n```\n\n----------------------------------------\n\nTITLE: bcl Number Preservation Example\nDESCRIPTION: This code demonstrates how to preserve numbers using `bcl_dup()` before passing them as arguments to `bcl_add`, `bcl_mul`, and `bcl_div`. This ensures that the original numbers are not freed after the operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nn = bcl_add(bcl_mul(bcl_dup(a), bc_dup(b)), bcl_div(bcl_dup(c), bcl_dup(d)));\n```\n\n----------------------------------------\n\nTITLE: Defining a7 function: Initialize, square with a6, and print (bc)\nDESCRIPTION: The `a7` function initializes an array `a__[]` with index values (0 to len-1), squares each element of the array by calling `a6` function, and finally prints the resulting array by calling `printarray` function. It initializes the array with sequential integers and then squares each element using the a6 function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\ndefine a7(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = i\n\t}\n\n\ta6(a__[], len)\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!=' in dc(1)\nDESCRIPTION: This snippet explains the '!=' command in dc(1) that conditionally executes a register based on an inequality comparison. The command pops two numbers from the stack. If the first number is not equal to the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_13\n\nLANGUAGE: dc\nCODE:\n```\n!=r\n```\n\n----------------------------------------\n\nTITLE: Building only bc on POSIX\nDESCRIPTION: These commands configure and build only the `bc` executable on a POSIX-compatible system. The `--disable-dc` option prevents the `dc` executable from being built.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-dc\nmake\n```\n\n----------------------------------------\n\nTITLE: Squaring array elements and printing (a6) in BC\nDESCRIPTION: This function, `a6`, iterates through the provided array `a__[]` from index 0 to `len-1` and squares each element. It then calls `printarray` to print the array's elements after squaring.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\ndefine a6(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = a__[i] * a__[i]\n\t}\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (32-bit) Operation\nDESCRIPTION: Demonstrates the bitwise reverse operation (brev32) on a 32-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_151\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(2815553780)\n```\n\n----------------------------------------\n\nTITLE: Program Exit\nDESCRIPTION: This snippet exits the program. It terminates the execution of the script.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line1.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nquit\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (64-bit)\nDESCRIPTION: Reverses the bits of a 64-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_127\n\nLANGUAGE: N/A\nCODE:\n```\nbrev64(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Checking for String Type in dc\nDESCRIPTION: Pops a value off the stack. If it's a string, pushes 1. Otherwise (if it's a number), pushes 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_22\n\nLANGUAGE: dc\nCODE:\n```\nt\n```\n\n----------------------------------------\n\nTITLE: Modular Exponentiation with Keep in BclNumber (bcl_modexp_keep)\nDESCRIPTION: This function computes modular exponentiation: (*a* ^ *b*) mod *c*. *a* is the base, *b* is the exponent, and *c* is the modulus. The scale of the result is the scale of the current context. *a*, *b*, and *c* must be integers, *c* must not be 0, and *b* must not be negative. Possible errors can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_modexp_keep(BclNumber* _a_**, BclNumber* _b_**, BclNumber* _c_**)\n```\n\n----------------------------------------\n\nTITLE: Large Number Addition and Variable Assignment in bc\nDESCRIPTION: This snippet shows the addition of two large numbers in bc, and assigns the result to 'R'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\n999 999+pR\n```\n\n----------------------------------------\n\nTITLE: Line Continuation in BC\nDESCRIPTION: Shows how to use the backslash character (\\) for line continuation. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_10\n\nLANGUAGE: BC\nCODE:\n```\n2 + \\\n3\n```\n\n----------------------------------------\n\nTITLE: if statement with print\nDESCRIPTION: This snippet demonstrates an if statement that prints to standard output when the condition is true. If the condition (1) is true, it executes the print statement, printing \"true\\n\".\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\nif (1) {\n\tprint \"true\\n\"\n}\n```\n\n----------------------------------------\n\nTITLE: Regular Expression for Identifiers in bc(1)\nDESCRIPTION: This snippet represents the regular expression used to define valid identifiers in bc(1). Identifiers start with a lowercase letter, followed by lowercase letters, digits, or underscores. Identifiers with more than one character are considered a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_2\n\nLANGUAGE: regex\nCODE:\n```\n[a-z][a-z0-9_]*\n```\n\n----------------------------------------\n\nTITLE: Exiting Macro Execution in dc\nDESCRIPTION: During macro execution, exits the execution of that macro and the execution of the macro that executed it. If no macros or only one is executing, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_16\n\nLANGUAGE: dc\nCODE:\n```\nq\n```\n\n----------------------------------------\n\nTITLE: SED script for BC output compatibility\nDESCRIPTION: This `sed` script removes an incompatibility with GNU `bc` where GNU prints a backslash+newline+digit combo at the end of `BC_LINE_LENGTH` when only one more character is to be printed. It edits numbers that end with just one digit on a line by itself to put it on the same line as others.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_6\n\nLANGUAGE: sed\nCODE:\n```\nThe `sed` script edits numbers that end with just one digit on a line by itself\nto put it on the same line as others.\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Greater Than) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not greater than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_6\n\nLANGUAGE: dc\nCODE:\n```\n!>_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Less Than) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is not less than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_10\n\nLANGUAGE: dc\nCODE:\n```\n!<_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Setting seed without affecting parent functions in bc\nDESCRIPTION: This bc(1) code snippet shows how to re-assign seed to itself within a function. By doing so, the function uses the same seed as its parent without affecting the sequence of pseudo-random numbers seen by the parent. This is useful when the function does not want to alter the global seed state.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nseed = seed\n```\n\n----------------------------------------\n\nTITLE: While Loop Condition\nDESCRIPTION: This snippet shows a while loop that continues execution as long as the variable 'i' is equal to 0.  It's a fundamental control flow structure in many programming languages.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/06.txt#_snippet_0\n\nLANGUAGE: C-like\nCODE:\n```\nwhile (i == 0) {\n```\n\n----------------------------------------\n\nTITLE: Popping Macro Executions in dc\nDESCRIPTION: Pops a non-negative value from the stack indicating the number of macro executions to pop. If the number to pop exceeds the number of executing macros, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_17\n\nLANGUAGE: dc\nCODE:\n```\nQ\n```\n\n----------------------------------------\n\nTITLE: Array Initialization and Function Call in BC\nDESCRIPTION: This BC script snippet first initializes a variable `len` to 16.  It then attempts to call function `a1` with what appears to be an uninitialized or invalid array expression and value. It's likely to result in an error as written since array declaration and indexing aren't correctly structured.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/38.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nlen = 16\na1((b[]) + ++ase^= , len)\n```\n\n----------------------------------------\n\nTITLE: Alternative Function Definition without Global Stacks\nDESCRIPTION: This code snippet shows the alternative way to define the `output(x, b)` function if the `-g` or `--global-stacks` option is not used. It demonstrates the need to save and restore the original value of `obase` to prevent unintended side effects.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n    auto c\n    c=obase\n    obase=b\n    x\n    obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating bc syntax error and scale issue\nDESCRIPTION: This snippet demonstrates the bug where a syntax error as the first input to bc causes the scale to be incorrectly set (or reset) when using the -l flag.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/project/issue10.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ bc -l\n>>> 2+; # or any other syntax error it seems\n\nParse error: bad expression\n    <stdin>:1\n\n>>> l(1000)\n6\n>>> scale\n0\n```\n\n----------------------------------------\n\nTITLE: For Loop with Initialization and Increment\nDESCRIPTION: This snippet shows a for loop with initialization and increment. The loop has no termination condition.  The loop initializes x to 0, and increments x for each iteration, incrementing y as well.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_13\n\nLANGUAGE: bc\nCODE:\n```\nfor (x=0;; ++x) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Multiplication by Zero with Scale\nDESCRIPTION: Demonstrates multiplication of a number by zero while setting the scale. The result should always be zero, regardless of the scale setting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_7\n\nLANGUAGE: NA\nCODE:\n```\nscale = 23; -847296455 * 0\nscale = 32; -340132470 * 0\nscale = 30; 0 * -898777681\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse Operation (8-bit)\nDESCRIPTION: Performs a bitwise reverse operation on an 8-bit integer. The function `brev8` reverses the order of bits in the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_84\n\nLANGUAGE: C\nCODE:\n```\nbrev8(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Small Decimal Multiplication\nDESCRIPTION: Multiplication of two very small decimal numbers.  This could be testing underflow conditions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_5\n\nLANGUAGE: NA\nCODE:\n```\n.000000000000000000000000001 * .0000000000000000000000001\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (64-bit) Example\nDESCRIPTION: Demonstrates the bitwise reverse operation (`brev64`) on a 64-bit integer. The operation reverses the order of the bits in the input value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_114\n\nLANGUAGE: N/A\nCODE:\n```\nbrev64(3708754108241877138)\n```\n\n----------------------------------------\n\nTITLE: Boolean OR Operator\nDESCRIPTION: This snippet demonstrates the boolean OR operator '||'. The OR operator returns true (1) if at least one of its operands is true (non-zero). It returns false (0) only if both operands are false (zero).  Integer literals are used as boolean values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_4\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n4 || 5\n4 || 0\n0 || 5\n4 || 5 || 7\n4 || 0 || 7\n0 || 5 || 7\n4 || 5 || 0\n0 || 0 || 7\n4 || 0 || 0\n0 || 5 || 0\n```\n\n----------------------------------------\n\nTITLE: Repeating Integer Division BC\nDESCRIPTION: Shows repeated examples of integer division using BC. This provides a more extensive overview of simple division operations in the language. No dependencies, executable in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divide.txt#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\n1 / 0.2395672438567234\n```\n\n----------------------------------------\n\nTITLE: Addition and Variable Assignment with Scale in bc\nDESCRIPTION: This snippet adds 9 to the variable 'i' and assigns the result to 'R'. The scale is set to 2 before the addition.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\n2 9+iR\n```\n\n----------------------------------------\n\nTITLE: Sine and Cosine Calculation (BC Math Library)\nDESCRIPTION: This code snippet illustrates the series used in the bc math library to calculate sine and cosine functions. It uses the series x - x^3/3! + x^5/5! - x^7/7! + ... for sin(x) and the relation cos(x) = sin(x + pi/2) to calculate cos(x).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/algorithms.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nx - x^3/3! + x^5/5! - x^7/7! + ...\n\n```\n\nLANGUAGE: text\nCODE:\n```\ncos(x) = sin(x + pi/2)\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '>', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '>r e s' command in dc(1) that conditionally executes one of two registers based on a greater-than comparison. The command pops two numbers from the stack. If the first number is greater than the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n>r es\n```\n\n----------------------------------------\n\nTITLE: Get Length of Array in DC\nDESCRIPTION: This snippet explains the 'Yr' command, which pushes the length of the array 'r' onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_21\n\nLANGUAGE: dc\nCODE:\n```\nYr\n```\n\n----------------------------------------\n\nTITLE: Brand Class Comparison\nDESCRIPTION: This snippet demonstrates comparison operations for an instance of the `brand` class.  It checks if the instance `b` is less than 2 and greater than or equal to 0. Assumes `brand` class is defined elsewhere.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_rand.txt#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nb = brand()\nb < 2\nb >= 0\n```\n\n----------------------------------------\n\nTITLE: Define prnt2 Function in BC\nDESCRIPTION: This BC function, `prnt2(i)`, takes an integer `i` as input, sets the output base (`obase`) to `i + 1`, prints 'a', 'b', and 'c' in that base, and then prints a newline character. Finally it returns the input `i` multiplied by 10.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/print2.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine prnt2(i) {\n\n\tobase = i + 1\n\ta\n\tb\n\tc\n\n\tprint \"\\n\"\n\n\treturn i * 10\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Branch Instruction\nDESCRIPTION: This assembly-like snippet uses `sM` and appears to involve a conditional jump based on the value of `lip`. If `lip` is equal to 0, represented as `lip=000`, then it may skip to address `0;0` or execute a different code path. Dependencies are unclear without knowledge of the architecture.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/11.txt#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\n[R]sM[lip=000]s0;0\n```\n\n----------------------------------------\n\nTITLE: Arctangent Calculation (BC Math Library)\nDESCRIPTION: This code snippet illustrates the series used in the bc math library to calculate atan(x). It uses the series x - x^3/3 + x^5/5 - x^7/7 + ... for small x and the relation atan(x) = atan(c) + atan((x - c)/(1 + x * c)) to reduce x to a small value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/algorithms.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nx - x^3/3 + x^5/5 - x^7/7 + ...\n\n```\n\nLANGUAGE: text\nCODE:\n```\natan(x) = atan(c) + atan((x - c)/(1 + x * c))\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Parsing Logic in bc/dc (C-like)\nDESCRIPTION: This code snippet demonstrates how function pointers are used to select the correct lex and parse functions for either `bc` or `dc` based on a condition (`BC_IS_BC`). This approach avoids `if`/`else` chains and improves code maintainability.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nif (BC_IS_BC) {\n\tbc_parse_parse(vm.parse);\n}\nelse {\n\tdc_parse_parse(vm.parse);\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Arithmetic Expression in BC\nDESCRIPTION: This snippet demonstrates a complex arithmetic expression in BC. It utilizes operators such as addition, subtraction, multiplication, and division. This expression might involve variables or constants.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n0si[lid:rli1+sili10>x]dsxxli1-si[li;rpRli1-sili0!>x]dsxxli1+si[li;rpRli1+sili10>x]dsxx0sx0si\n```\n\n----------------------------------------\n\nTITLE: Assigning a Value and Performing Addition with 'void' in BC\nDESCRIPTION: This code attempts to assign the value 0.198389 to the identifier 'void', potentially overwriting any previously defined function named 'void'. It then attempts to add 10 to the current value of 'void'. This highlights BC's dynamic typing and allows variables to be redefined easily.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/void.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nvoid = .198389\nvoid + 10\n```\n\n----------------------------------------\n\nTITLE: Variable Naming Convention in POSIX Shell Scripts\nDESCRIPTION: This code shows the variable naming convention used in POSIX shell scripts to avoid naming conflicts. Variables within functions are prefixed with `_<function_name>_`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\n_<function_name>_<var_name>\n```\n\n----------------------------------------\n\nTITLE: Defining a function using -g (global-stacks) option in bc\nDESCRIPTION: Shows how to define a function output(x, b) that prints x in base b using the -g option to enable global stacks for ibase, obase and scale. The example contrasts the simplified function definition possible with -g to the more complex method that manages obase manually.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n obase=b\n x\n}\n```\n\nLANGUAGE: bc\nCODE:\n```\ndefine void output(x, b) {\n auto c\n c=obase\n obase=b\n x\n obase=c\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Floating Point Random Number Generation\nDESCRIPTION: This snippet tests `ifrand` along with the `scale` function and a magnitude check. It generates a random scaled float, then checks its scaled value against the max range and finally ensures it is less than 128.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_rand.txt#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfi = ifrand(123, 28)\nscale(fi) == 28\nfi < 128\n```\n\n----------------------------------------\n\nTITLE: bc Macro with Control Characters\nDESCRIPTION: This snippet contains a `bc` macro definition `M` with embedded control characters. It defines a macro and uses `pR` for printing, however the included special characters like nulls and unknown encodings make it difficult to assess the exact program logic.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/23.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\n[[D}ne!]pR|sM[l\\u0000\\u0001\\u0000\\u0000s\\u0000\\u0000L10sil\n```\n\n----------------------------------------\n\nTITLE: Extended Register Regex (C)\nDESCRIPTION: Defines the regex pattern used to parse extended register names when the `-x` option is enabled. It specifies that register names must start with a lowercase letter, followed by zero or more lowercase letters, numbers, or underscores.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/gen/dc_help.txt#_snippet_0\n\nLANGUAGE: regex\nCODE:\n```\n[a-z][a-z0-9_]*\n```\n\n----------------------------------------\n\nTITLE: Conditional `irand` Calls in C\nDESCRIPTION: This snippet demonstrates a conditional execution block based on the output of `maxrand()`. If `maxrand()` returns a value greater than or equal to 2^64 - 1, a loop iterates from 1 to 37, calling `irand` with 10 raised to the power of the current iteration value (i).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand_limits.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nif (maxrand() >= 2^64 - 1) {\n\n\tfor (i = 1; i <= 37; ++i)\n\t{\n\t\tirand(10^i)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Extended Register Mode in dc\nDESCRIPTION: Pushes 1 onto the stack if extended register mode is on, 0 otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_29\n\nLANGUAGE: dc\nCODE:\n```\ngx\n```\n\n----------------------------------------\n\nTITLE: Defining Function z for Array Iteration in BC\nDESCRIPTION: This function `z(a[])` iterates through the array `a` from index 0 to `l-1`, where `l` is a global variable representing the length of the array. It accesses each element `a[i]` within the loop. Requires the global variable `l` to be defined with the array's length.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine z(a[]) {\n\tfor (i = 0; i < l; ++i) {\n\t\ta[i]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation\nDESCRIPTION: Performs a bitwise AND operation between two 64-bit numbers. The operation combines bits from both inputs such that the resultant bit is only 1 if corresponding bits in both operands are 1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_115\n\nLANGUAGE: N/A\nCODE:\n```\nband(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Disabling history support\nDESCRIPTION: Configures the build to disable history support. It's recommended to disable history if facing portability issues.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -H\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-history\n```\n\n----------------------------------------\n\nTITLE: Array Indexing in BC\nDESCRIPTION: Demonstrates accessing array elements using different indexing methods.  The `(1-1)` example is the same as `0`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_9\n\nLANGUAGE: BC\nCODE:\n```\nx[(1 - 1)]\n```\n\n----------------------------------------\n\nTITLE: Integer Comparisons\nDESCRIPTION: This snippet demonstrates comparisons between different integer values using less than (<) and greater than (>) operators.  It includes comparisons between very large positive and negative numbers, and smaller values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/comp.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\n-999999999 < -1\n-999999999 > -1\n-1000000000 < -1\n-1000000000 > -1\n-1 < -999999999\n-1 > -999999999\n-1 < -1000000000\n-1 > -1000000000\n-99999 < -1\n-99999 > -1\n-100000 < -1\n-100000 > -1\n-1 < -99999\n-1 > -99999\n-1 < -100000\n-1 > -100000\n-999999999 < -1000000000\n-999999999 > -1000000000\n-1000000000 < -999999999\n-1000000000 > -999999999\n-99999 < -100000\n-99999 > -100000\n-100000 < -99999\n-100000 > -99999\n999999999 < 1\n999999999 > 1\n1000000000 < 1\n1000000000 > 1\n1 < 999999999\n1 > 999999999\n1 < 1000000000\n1 > 1000000000\n99999 < 1\n99999 > 1\n100000 < 1\n100000 > 1\n1 < 99999\n1 > 99999\n1 < 100000\n1 > 100000\n999999999 < 1000000000\n999999999 > 1000000000\n1000000000 < 999999999\n1000000000 > 999999999\n99999 < 100000\n99999 > 100000\n100000 < 99999\n100000 > 99999\n-999999999 < 1\n-999999999 > 1\n-1000000000 < 1\n-1000000000 > 1\n-1 < 999999999\n-1 > 999999999\n-1 < 1000000000\n-1 > 1000000000\n-99999 < 1\n-99999 > 1\n-100000 < 1\n-100000 > 1\n-1 < 99999\n-1 > 99999\n-1 < 100000\n-1 > 100000\n-999999999 < 1000000000\n-999999999 > 1000000000\n-1000000000 < 999999999\n-1000000000 > 999999999\n-99999 < 100000\n-99999 > 100000\n-100000 < 99999\n-100000 > 99999\n999999999 < -1\n999999999 > -1\n1000000000 < -1\n1000000000 > -1\n1 < -999999999\n1 > -999999999\n1 < -1000000000\n1 > -1000000000\n99999 < -1\n99999 > -1\n100000 < -1\n100000 > -1\n1 < -99999\n1 > -99999\n1 < -100000\n1 > -100000\n999999999 < -1000000000\n999999999 > -1000000000\n1000000000 < -999999999\n1000000000 > -999999999\n99999 < -100000\n99999 > -100000\n100000 < -99999\n100000 > -99999\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (<r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is less than the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_7\n\nLANGUAGE: dc\nCODE:\n```\n<r\n```\n\n----------------------------------------\n\nTITLE: Defining Function x for Array Modification in BC\nDESCRIPTION: This function `x(a[])` tests variable scope and array modification. It declares a local variable `a` within the function, then iterates through the array `a[]` (passed as argument). Each element `a[a]` is set to its negative value. It calls function `z(a[])` afterward.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine x(a[]) {\n\n\t# Test for separate vars and arrays.\n\tauto a\n\n\tfor (a = 0; a < l; ++a) {\n\t\ta[a] = -a\n\t}\n\n\tz(a[])\n}\n```\n\n----------------------------------------\n\nTITLE: Function Call with Array Argument in C\nDESCRIPTION: This snippet consists of a function call to 'asciify' with 'a[]' as an argument. This indicates that 'asciify' likely takes an array as input and processes it, potentially converting its elements into ASCII characters.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/36.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nasciify(a[])\n```\n\n----------------------------------------\n\nTITLE: Order of evaluation in bc: Assignment example\nDESCRIPTION: This example demonstrates the left-to-right evaluation order in bc, specifically how increment operators interact with array assignments. The first (or 0th) element of **a** is set to **1**, and **i** is equal to **2** at the end of the expression.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\na[i++] = i++\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Left (64-bit) Operation\nDESCRIPTION: Performs a bit rotation left operation on a 64-bit representation of the input. This rotates the bits of the input value to the left by a specified number of positions, wrapping the shifted bits around to the other end. `brol64` specifically handles 64-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_16\n\nLANGUAGE: N/A\nCODE:\n```\nbrol64(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Printing Zero in BC\nDESCRIPTION: This snippet demonstrates printing the number 0 to standard output using the 'p' operator in BC.  The 'p' operator prints the result of the preceding expression.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\n0\np\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Right (16-bit) Operation\nDESCRIPTION: Performs a bit rotation right operation on a 16-bit representation of the input. This rotates the bits of the input value to the right by a specified number of positions, wrapping the shifted bits around to the other end. `bror16` specifically handles 16-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_18\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(17689, 9024)\n```\n\n----------------------------------------\n\nTITLE: Scale and Radix Formula in bc (C-like)\nDESCRIPTION: This formula shows the relationship between the `scale` (number of decimal places), `BC_BASE_DIGS` (number of decimal digits in a limb), and the `rdx` (radix point location) fields in the `BcNum` struct. It ensures that the decimal point is always between limbs.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nscale + (BC_BASE_DIGS - 1) / BC_BASE_DIGS == rdx >> 1\n```\n\n----------------------------------------\n\nTITLE: Initialize unsigned integer to zero\nDESCRIPTION: Initializes an unsigned integer to the value of 0. The specific language is not evident from the code snippet but is likely to be C, C++, Java, or Go based on the syntax.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/lib12.txt#_snippet_0\n\nLANGUAGE: Unknown\nCODE:\n```\nuint(0)\n```\n\n----------------------------------------\n\nTITLE: bc Script with Loop and Quit\nDESCRIPTION: This bc script demonstrates a simple for loop that iterates three times and then exits the bc interpreter using the quit command. No dependencies are required. The script's output is the side effect of looping (no variables are manipulated or printed) and then the interpreter quitting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_loop_quit2.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n3\nfor (i = 0; i < 3; ++i) i; \\\nquit\n```\n\n----------------------------------------\n\nTITLE: Square Root Calculation in BclNumber (bcl_sqrt)\nDESCRIPTION: This function calculates the square root of BclNumber *a*. The scale of the result is equal to the scale of the current context. *a* cannot be negative and is consumed by the function. Possible errors can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_sqrt(BclNumber* _a_**)\n```\n\n----------------------------------------\n\nTITLE: DC Script with Variable Assignment and Conditional\nDESCRIPTION: This DC script initializes variable 'Nx', performs stack manipulation, variable assignments related to 'Wx', 'li', 'Px' and 'Gx'. Then the `zsW` instruction is used.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/10.txt#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]zWx[li]zsGd[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsW#! /Wx[li]zs^x[Nx]0s_[]zsWx[li]zs^x[lili100>Nx]0sm[]zs]0sm[]zsdc\n```\n\n----------------------------------------\n\nTITLE: Nested if statement\nDESCRIPTION: Illustrates a nested if statement within a block. The outer block isn't strictly necessary, but shows how code can be grouped. Both if conditions evaluate to true (1), so the inner if statement is reached. However, nothing is done within the if block.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\n{\n\tif (1) if (1)\n}\n```\n\n----------------------------------------\n\nTITLE: Addition Test Script\nDESCRIPTION: This shell script is used to benchmark the addition operation in bc. It takes the bc executable, the script name (add.bc), and some parameters as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_0\n\nLANGUAGE: Shell Script\nCODE:\n```\ntests/script.sh bc add.bc 1 0 1 1 [bc]\n```\n\n----------------------------------------\n\nTITLE: BC Modulo Operations with Integers\nDESCRIPTION: This snippet demonstrates modulo operations using integer values in BC. It covers positive, negative, and large integer inputs. The modulo operator (%) calculates the remainder of the division of the left operand by the right operand.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/modulus.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n1 % 1\n2 % 1\n16 % 4\n15 % 4\n17 % 4\n2389473 % 5\n39240687239 % 1\n346728934 % 23958\n3496723859067234 % 298375462837546928347623059375486\n-1 % 1\n-2 % 1\n-47589634875689345 % 37869235\n-1274852934765 % 2387628935486273546\n-6324758963 % 237854962\n1 % -1\n2 % -1\n2 % -2\n2 % -3\n16 % 5\n15 % 5\n14 % 5\n89237423 % -237856923854\n123647238946 % -12467\n-1 % -1\n-2 % -1\n-2 % -2\n-2 % -3\n-13 % -7\n-14 % -7\n-15 % -7\n-12784956 % -32746\n-127849612 % -23712347682193\n```\n\n----------------------------------------\n\nTITLE: Comparison Operator\nDESCRIPTION: This snippet demonstrates a comparison operator in bc. It is a boolean expression checking if x is less than or equal to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\nx<=0\n```\n\n----------------------------------------\n\nTITLE: Calculating Power of BclNumber objects, keeping originals in C\nDESCRIPTION: Calculates 'a' to the power of 'b' to the scale of the current context and returns the result.  'b' must be an integer and can be negative; if negative, 'a' must not be zero. 'a' must be smaller than BC_OVERFLOW_MAX. Unlike `bcl_pow`, 'a' and 'b' are not consumed. Errors may include invalid number, context, non-integer exponent, overflow, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_pow_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (8-bit) Example\nDESCRIPTION: Demonstrates the bitwise rotate left operation (`brol8`) on an 8-bit integer. The operation rotates the bits of the first argument to the left by the number of positions specified by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_109\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(3708754108241877138, 16558750771054102751)\n```\n\n----------------------------------------\n\nTITLE: Calculating Modulus of BclNumber objects in C\nDESCRIPTION: Calculates the modulus of 'a' divided by 'b' and returns the result. Division is performed to the scale of the current context.  'b' cannot be zero. 'a' and 'b' are consumed unless the `_keep` variant is used. Errors can include invalid number, invalid context, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_mod(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Stack Manipulation using pR in bc\nDESCRIPTION: This snippet demonstrates the use of 'pR' in bc, which seems to push values onto and potentially pop values from the stack, effectively manipulating the stack's content. The repeated 'pR' commands indicate multiple stack operations. There are no explicit dependencies or prerequisites.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/misc1.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\npR\npR\npR\npR\npR\npR\npR\npR\npR\npR\npR\npR\npR\npR\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation\nDESCRIPTION: Performs a bitwise XOR (exclusive OR) operation between two 64-bit numbers. The operation combines bits from both inputs such that the resultant bit is 1 if corresponding bits are different.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_117\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Define scale function in BC\nDESCRIPTION: Defines a function `r(x)` in bc that sets the scale to the value of `x` and returns the new scale value.  The scale determines the number of digits after the decimal point for calculations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/globals.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine r(x) {\n\tscale=x\n\treturn scale\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Function m for Array Division in BC\nDESCRIPTION: This function `m(*x[], *y[])` calculates the division of the first element of `x[]` by the first element of `y[]`. It returns `x[0] / y[0]`. The `*` before the array names may indicate pass-by-reference, which could be a typo as BC typically uses pass-by-value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine m(*x[], *y[]) {\n\treturn x[0] / y[0]\n}\n```\n\n----------------------------------------\n\nTITLE: Decimal Multiplication\nDESCRIPTION: Multiplication of decimal numbers, demonstrating the tool's ability to handle fractional values. It includes different magnitudes and numbers of decimal places.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_2\n\nLANGUAGE: NA\nCODE:\n```\n328962735862.2973546835638947635 * 1728465791348762356\n38745962374538.387427384672934867234 * 0.1932476528394672837568923754\n9878894576289457634856.2738627161689017387608947567654 * 37842939768237596237854203.29874372139852739126739621793162\n```\n\n----------------------------------------\n\nTITLE: String to ASCII\nDESCRIPTION: Pops a value. If it's a number, it's truncated, its absolute value is taken, and the result mod 256 is calculated. If the result is 0, an empty string is pushed; otherwise, a one-character string is pushed using the result as an ASCII character. If it's a string, a new string is made using the first character of the original string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Function Definition in BC\nDESCRIPTION: Defines a function `x` that takes one argument and returns it. Also defines function `y` and `z` which take no arguments and return nothing or an empty value, respectively.  These snippets demonstrates function definition syntax in BC. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine x(x) {\n\treturn(x)\n}\ndefine y() {\n\treturn;\n}\ndefine z() {\n\treturn ();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with UndefinedBehaviorSanitizer\nDESCRIPTION: These commands run the test suite under UndefinedBehaviorSanitizer (UBSan), which requires zero optimization. The `CFLAGS` variable is set to include the `-fsanitize=undefined` flag, and optimization is set to `-gO0`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\nCFLAGS=\"-fsanitize=undefined\" ./configure -gO0 -m\nmake -j<cores>\nmake -j<cores> test\n```\n\n----------------------------------------\n\nTITLE: Rerunning Coverage Generation\nDESCRIPTION: These commands ensure that a fresh coverage analysis is performed by first cleaning the build and then rebuilding with the coverage flags set. This prevents errors that can occur if the coverage data is not properly reset.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nmake clean\nmake -j<cores>\nmake coverage\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation\nDESCRIPTION: Demonstrates the bitwise XOR operation (bxor) on integers. The function takes two arguments: the two integers to be XORed. It performs a bitwise XOR operation, where each bit in the result is 1 if the corresponding bits in the input integers are different.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_174\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(869320618226679840, 15779715921992018698)\nbxor(11784620717065408517, 14976544843797949497)\n```\n\n----------------------------------------\n\nTITLE: Simple if-else statement in bc\nDESCRIPTION: This snippet illustrates a basic if-else structure in bc. If the condition (1) is true, the empty block {} is executed; otherwise, the value 4 is returned. Because 1 is always true in bc's boolean context, the 'else' statement will not be run. Note that in bc an assignment is needed to store and subsequently use the result of an else statement.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nif (1) {}\nelse 4\n```\n\n----------------------------------------\n\nTITLE: Unidentified Instruction Pattern\nDESCRIPTION: This snippet appears to represent a sequence of instructions or data definitions possibly associated with a stack-based virtual machine or compiler intermediate representation. The 'bpR' suffix suggests a reference to base pointer or register. Deciphering the exact meaning requires more context about the 'bc' project's architecture and instruction set.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/26.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\n0bpR\n1bp0\n.23bpR\n138963.9873645bpR\n_19bpR\n_.1298[li;i;rpRli1+sili10>x]dsxx0sx0si\n```\n\n----------------------------------------\n\nTITLE: Addition of Very Large Integers\nDESCRIPTION: This snippet attempts to add two extremely large integers.  It is intended to demonstrate bc's ability to handle very long numbers. No scale is defined, as these are integers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ns7298367203972395108367910823465293084561329084561390845613409516734503870691837451 + 785621394067928346918023476190834672198467134908618723249671349062187346898241093486139046139084613490817356023871869102746182749061872609129847\n```\n\n----------------------------------------\n\nTITLE: Calling function 'a' in BC\nDESCRIPTION: This snippet shows calling a user-defined function named `a` with a floating-point argument (.267) and an integer argument (1) in `bc`. It depends on function 'a' being defined elsewhere in the script or loaded from an external file.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/atan.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\na(.267)\na(1)\n```\n\n----------------------------------------\n\nTITLE: Quit Statement Example\nDESCRIPTION: This example demonstrates the behavior of the `quit` statement in this bc(1) implementation, highlighting the difference in behavior compared to other bc(1) implementations. Unlike some implementations, this bc(1) executes completed and executable statements before exiting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: Define output base function in BC\nDESCRIPTION: Defines a function `o(x)` in bc that sets the output base to the value of `x` and returns the new output base value. It allows the user to dynamically change the output base, influencing how results are displayed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/globals.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine o(x) {\n\tobase=x\n\treturn obase\n}\n```\n\n----------------------------------------\n\nTITLE: Addition with Variables\nDESCRIPTION: This snippet assigns two decimal numbers to variables 'a' and 'b', then adds them together.  'scale' is not defined, so the default 'scale' will be applied. The result of the addition is printed to the standard output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\na=123123123.987239874; b=123123123.239479823748; a+b\n```\n\n----------------------------------------\n\nTITLE: Defining a bc void function\nDESCRIPTION: This code snippet demonstrates how to define void functions in bc. Void functions do not return a value and can only be used as standalone expressions. The 'I' represents an identifier for variable or array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation\nDESCRIPTION: Performs a bitwise AND operation on two large integer values. This operation compares the bits of the two input numbers, and if both bits are 1, the corresponding result bit is set to 1; otherwise, it is set to 0.  It returns the bitwise AND of the two operands.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\nband(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Hundred Plus Decimal\nDESCRIPTION: Demonstrates bitwise right shift operations on the numbers 100.01, 100.001, 100.0001, 100.00001, 100.000001, 100.0000001, 100.00000001 and 100.000000001. The number of bits shifted ranges from 0 to 19 in each case.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_13\n\nLANGUAGE: bc\nCODE:\n```\n100.01 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.0001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.00001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.0000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.00000001 >> 0\n```\n\nLANGUAGE: bc\nCODE:\n```\n100.000000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Data Point Pattern\nDESCRIPTION: This snippet represents a generalized pattern for the data entries.  It consists of two fields, value1 and value2, separated by the string \"^pR\". The fields can be numerical values or labels. This format can be used for data storage or representation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/power.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nvalue1 ^pR value2\n```\n\n----------------------------------------\n\nTITLE: Testing signed byte values with sbytes()\nDESCRIPTION: These test values are designed to evaluate the behavior of the `sbytes()` function with various integer inputs. The tests include zero, small positive and negative numbers, boundary values for different byte sizes (e.g., -128, 127, -32768, 32767, -2147483648, 2147483647, -9223372036854775808, 9223372036854775807), and values exceeding these boundaries to confirm proper handling of overflow or truncation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_bytes.txt#_snippet_1\n\nLANGUAGE: N/A\nCODE:\n```\nsbytes(0)\nsbytes(1)\nsbytes(-1)\nsbytes(2)\nsbytes(127)\nsbytes(128)\nsbytes(-127)\nsbytes(-128)\nsbytes(-129)\nsbytes(254)\nsbytes(255)\nsbytes(256)\nsbytes(32767)\nsbytes(32768)\nsbytes(-32767)\nsbytes(-32768)\nsbytes(65535)\nsbytes(65536)\nsbytes(131072)\nsbytes(2147483647)\nsbytes(2147483648)\nsbytes(2147483649)\nsbytes(-2147483647)\nsbytes(-2147483648)\nsbytes(-2147483649)\nsbytes(4294967295)\nsbytes(4294967296)\nsbytes(9223372036854775807)\nsbytes(9223372036854775808)\nsbytes(9223372036854775809)\nsbytes(-9223372036854775807)\nsbytes(-9223372036854775808)\nsbytes(-9223372036854775809)\n```\n\n----------------------------------------\n\nTITLE: Multiple Macro Exit\nDESCRIPTION: Pops a value from the stack, which must be non-negative. This value determines the number of macro executions to pop off the execution stack. If the number of levels to pop is greater than the number of executing macros, dc exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_17\n\nLANGUAGE: dc\nCODE:\n```\nQ\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (64-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate left operation (brol64) on a 64-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_156\n\nLANGUAGE: N/A\nCODE:\n```\nbrol64(16527427662727213300, 6651564814332221722)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (32-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate left operation (brol32) on a 32-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_155\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(2815553780, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(16527427662727213300, 113400090)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(2815553780, 113400090)\n```\n\n----------------------------------------\n\nTITLE: Bit Reversal (32-bit) Operation\nDESCRIPTION: Performs a bit reversal operation on a 32-bit representation of the input. This reverses the order of the bits in the 32-bit value.  The function `brev32` specifically operates on 32-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_11\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev32(2366588185)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (16-bit) Operation\nDESCRIPTION: Demonstrates the bitwise reverse operation (brev16) on a 16-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_150\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(61684)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Function Test Generation\nDESCRIPTION: This snippet describes how to generate tests for bc's bitwise functions using the `bitfuncgen.c` executable. The output to stdout is the test and the standard error is the expected result.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nscripts/bitfuncgen > tests/bc/bitfuncs.txt 2> tests/bc/bitfuncs_results.txt\n```\n\n----------------------------------------\n\nTITLE: Execute String as Macro in DC\nDESCRIPTION: This snippet demonstrates the 'x' command, which executes a string on the stack as a macro, or pushes a number back onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Subtracting BclNumber objects, keeping originals in C\nDESCRIPTION: Subtracts BclNumber 'b' from 'a' and returns the result. The scale of the result is the maximum of the scales of 'a' and 'b'. Unlike `bcl_sub`, 'a' and 'b' are not consumed after the operation. The function can return errors such as invalid number, invalid context, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_sub_keep(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Squaring array elements in BC\nDESCRIPTION: This function, `a2`, iterates through the provided array `a[]` from index 0 to `len-1` and squares each element. After squaring the elements, it calls `printarray` function with the length parameter set to `len` to print the array elements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine a2(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = a[i] * a[i]\n\t}\n\n\tprintarray(len, len)\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Not Less Than in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on a not-less-than comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_6\n\nLANGUAGE: dc\nCODE:\n```\n!<r\n```\n\nLANGUAGE: dc\nCODE:\n```\n!<rers\n```\n\n----------------------------------------\n\nTITLE: Multiplication with Zero\nDESCRIPTION: Demonstrates multiplication of various numbers (integer and decimal) with zero, which always results in zero. This is likely a basic test case to confirm the expected behavior.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_0\n\nLANGUAGE: NA\nCODE:\n```\n0 * 0\n0.000 * 0\n1 * 0\n0 * 1\n0 * 2498752389672835476\n873246913745129084576134 * 0\n```\n\n----------------------------------------\n\nTITLE: Function Definition Syntax\nDESCRIPTION: Illustrates the general syntax for defining functions in bc(1), including parameter lists, auto variables, statements, and return expressions. This snippet shows the basic structure of a function definition.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn(E)\n}\n```\n\n----------------------------------------\n\nTITLE: BC quit statement example\nDESCRIPTION: This code snippet demonstrates the behavior of the `quit` statement in this implementation of bc, which differs from other implementations. This version executes completed and executable statements before quitting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: String Creation and Pushing onto Stack in dc(1)\nDESCRIPTION: This snippet describes how to create a string in dc(1) using square brackets and push it onto the stack. Backslashes are used to escape special characters like unbalanced brackets or other backslashes. The brackets in the string need to be balanced otherwise, they can be escaped.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n\\[characters\\]\n```\n\n----------------------------------------\n\nTITLE: Defining Function g for Array Difference in BC\nDESCRIPTION: This function `g(x[], y[])` calculates the difference between the first elements of arrays `x[]` and `y[]`. It returns `x[0] - y[0]`. No specific dependencies or prerequisites beyond array existence.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine g(x[], y[]) {\n\treturn x[0] - y[0]\n}\n```\n\n----------------------------------------\n\nTITLE: Basic While Loop in Bash\nDESCRIPTION: This snippet demonstrates a simple while loop in bash. The loop continues as long as the condition 'i == 0' is true. It's crucial to have a mechanism within the loop to eventually change the value of 'i' to avoid an infinite loop.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/06.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwhile (i == 0) {\n\n```\n\n----------------------------------------\n\nTITLE: Optimizing for SSE4 Architectures - Shell\nDESCRIPTION: This command adds compiler flags to optimize the build for SSE4 architectures, potentially increasing performance. It combines the CFLAGS variable with the configuration and optimization steps.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_24\n\nLANGUAGE: Shell\nCODE:\n```\nCFLAGS=\"-march=native -msse4\" ./configure.sh -O3\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: DC Script Snippet 4\nDESCRIPTION: DC script involving stack manipulation, storing values in registers Nx, li and Gx. It uses 'zsdc' at the end, which could indicate the end of a macro or a sequence of operations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n*sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsdc\n0sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]x]zsxx\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (8-bit) Operation\nDESCRIPTION: This code demonstrates the bitwise NOT operation applied to an 8-bit value using the 'bnot8' function. It inverts all the bits of the provided 64-bit number, effectively treating it as an 8-bit value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_30\n\nLANGUAGE: Text\nCODE:\n```\nbnot8(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Define Print Array Function BC\nDESCRIPTION: Defines a function `printarray` that iterates through an array `a` of length `len` and attempts to access an undefined variable `m` at index `i` within the loop.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/37.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\ndefine printarray(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\tm[i]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Seed and Base Testing\nDESCRIPTION: This code snippet conditionally tests the random number generator based on the value of `maxrand()`. If `maxrand()` is greater than or equal to 2^64 - 1, it sets the seed and base values and then generates 64 random numbers. Otherwise, it uses a different set of hardcoded values for testing.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nprint \"Testing implementation...\\n\"\n\nif (maxrand() >= 2^64 - 1) {\n\n\tseed = 54.86785590782347282592869373784717814475564948862907968939359536927733440\\\n\t          901359008180088183692646452982444316148757934570312500000\n\n\tibase = G\n\tobase = G\n\n\tfor (i = 0; i < 64; ++i) {\n\t\trand()\n\t}\n\n\tseed = 0.2890120\n\n\trand()\n\n\t7B47F409\n\tBA1D3330\n\t83D2F293\n\tBFA4784B\n\tCBED606E\n\tBFC6A3AD\n\t812FFF6D\n\tE61F305A\n\tF9384B90\n\t32DB86FE\n\t1DC035F9\n\tED786826\n\t3822441D\n\t2BA113D7\n\t1C5B818B\n\tA233956A\n\t84DA65E3\n\tCED67292\n\tB2C0FE06\n\t91817130\n\n\t55FE8917\n\t47E92091\n\t486AF299\n\tB1E882BB\n\tC261E845\n\t1A9B90F6\n\t7964E884\n\t5F36D7A4\n\t1EE2052D\n\t8519F5D5\n\t293D4E4F\n\t6D8F99FC\n\tC3421509\n\tA06CD7C6\n\tE43064D3\n\tE20F9BF0\n\t401B50B7\n\t8EF1FF3E\n\tE357E2B2\n\tA4AEEE37\n\n\t2AD4426A\n\t9D11BE94\n\t7290C556\n\t6E6F3787\n\t050C2EE3\n\t4FD73703\n\tC6FF478B\n\t4B1CA1E1\n\t1654EA91\n\tCD08B2F2\n\tF7FF3DA8\n\t78B1B8DA\n\tA100602C\n\t9588585F\n\tDA028873\n\t66B4F376\n\t0E6B4B9A\n\t48167094\n\t0D58CDA0\n\t8F7238BE\n\n\tF79983F3\n\t07E5D324\n\tAD78DF52\n\t1532BA74\n\t1E4899E2\n\t6C75DF64\n\t171DDC36\n\tF2D8D74A\n\t24E6D907\n\t4780FD32\n\t9ADF408C\n\tA25544CF\n\tEFC6A738\n\t1AA23A54\n\tC5A13EBB\n\tF739EDC9\n\tC3A015FA\n\t3D5E1511\n\tAFC4D7FB\n\t3F413B5E\n\n\t4660CB73\n\t88FC773F\n\tD6BED59C\n\t63B3B54A\n\tD67D3DDE\n\t23394F8B\n\t13384B44\n\tDD8B3ABC\n\tFF59A21E\n\t3BB16D7E\n\t6E01CB68\n\tEC34790E\n\tB26C42AD\n\tD723C830\n\tDFD10FCA\n\t7E362AA1\n\t826FF323\n\tCB8F63B5\n\t9B3227E5\n\t9A61E339\n\n\t40BDACF\n}\nelse {\n\n\tibase = G\n\tobase = G\n\n\t86B1DA1D72062B68\n\t1304AA46C9853D39\n\tA3670E9E0DD50358\n\tF9090E529A7DAE00\n\tC85B9FD837996F2C\n\t606121F8E3919196\n\t7CE1C7FF478354BA\n\tCBC4AC70E541310E\n\t74BE71999EC37F2C\n\tB81F9C99A934F1A7\n\t120E9901A900C97F\n\t0F983BAD4B19F493\n\t5934619363660D96\n\tD5A7FE2717A2014E\n\t6E437241C9E6676E\n\t6A75C9DD6329CD29\n\t2D9E477683673437\n\t51FB0CF3D4405437\n\t217BB90392D08B20\n\t47C528A018B07A82\n\n\t1B4E474C418C835E\n\tBDB2BDA74A119ED6\n\tC6DB79D0B9E43493\n\tC3CF4834E94A41D1\n\tAB8312FC7877C7DC\n\t094B108133E8B5EC\n\t37CA97AC830113BD\n\tEF02D7347F9192BF\n\t959517DD9896C53A\n\t7A80EB7629EFE9F9\n\tAE53C23F2B1CF57C\n\tCA605CD189F6D5CD\n\t921C2704886A9622\n\tB68C9FBF826AF7AA\n\t73F8C733124772C3\n\t6B57F7E459EFBCDF\n\t9DE7696DDB6B8E18\n\t02CA67560DC26877\n\tA24E353080777DEC\n\t4D600156763FD65C\n\n\t5CDF9C7E26DD2C38\n\t6A32443BBBB16774\n\t3D8415FFECFB8B7F\n\t3090ED9C475635A3\n\t6DBF241361C3E652\n\t2CA9EF5A2AD971FC\n\t44FBE937A1CF0FFC\n\tDB17CF0577CB7853\n\tAA3747D98D31B24C\n\t5D9A104C5D7F43F7\n\tBAE65E3E293B2C7B\n\t16A396F0DB4EF984\n\t6DD2BACDC4445A05\n\t7B7A13D1858E5CA8\n\tF73722BCAA52447C\n\t31A2C7BBE77CBA00\n\t7FC8AF9003BA1ACE\n\t5703F11DD3F235EF\n\tFA1952267EF836C7\n\tBBFA558C9E2D51E2\n\n\t3A29661D8145AF36\n\t608DEA6358DABD7C\n\t9E34E9E53431B447\n\t325A05E35EA524EB\n\t63A87CCF0C80ABB1\n\t8EA183287A46F292\n\tE2AA5F119CBF2A08\n\t2F3BEB0DE8B730C8\n\t4B8006A928CF8F5B\n\t57B8BA85069C201C\n\t3422D962DDF59474\n\tFD744940BA7366A1\n\t23D24B06B5DA4F6F\n\tAA187C608319D1DC\n\tDC60CA6FEA738B8A\n\tC9FC61DF96A769FE\n\t82E2457708658A20\n\t2BECEC9B3E7D93EC\n\t1340DAEC04588952\n\tF533446AD5C50B1D\n\n\t31FD1C7F434A62CE\n\tD16DAEDD1F281A39\n\t6B5D9648931D7057\n\t62FEE3392DBB06D5\n\t0358BC87B00DF25A\n\tF3C882D22946175D\n\t65BA8F11B4516EFE\n\t2DA5A96E626DA4FE\n\tDCC669F4CD6121F0\n\t7A47FAC054319CA2\n\t9661CFEE277284C8\n\t01E483A14F4EB23A\n\tADDC115507390607\n\t5AB47C343BD3B0BD\n\t4882FB3A3957B11F\n\t615B7C9C3626DD44\n\tF79CF49562969219\n\t88C32C194EA78D27\n\tDA8AFFE1353FF352\n\tA7A3C331A64CB146\n\n\tA1F53517A7BE0CAA\n\n\tibase = A\n\n\tseed = 54.0950779151573258314404657465246373249101452529430389404296875000\n\n\tibase = G\n\n\tfor (i = 0; i < 64; ++i) {\n\t\trand()\n\t}\n\n\tseed = 0.2890120\n\n\trand()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Memory Manipulation with Conditional Branching\nDESCRIPTION: This assembly-like snippet seems to involve moving data into memory locations based on a condition. It starts with a memory address `[00000]aa` and then appears to involve conditional branching `li>0eM`. The `sM` instruction might be related to memory storage. No dependencies are specified but further context would be required to understand the exact instruction set.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/11.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n[[00000]aa]sM[lip1-si0li>0eM]s010sil0x\n```\n\n----------------------------------------\n\nTITLE: if-else with false condition and empty else\nDESCRIPTION: Shows an if-else statement with a false condition (0) and an empty 'else' block. If the condition is false, the empty 'else' block is executed. If the condition is true, 7 is evaluated. Note that in bc an assignment is needed to store and subsequently use the result of an if statement.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nif (0) 7\nelse {}\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (64-bit) Operation\nDESCRIPTION: This code segment rotates bits to the right in a 64-bit value using 'bror64'. The rotation occurs by the amount designated by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_69\n\nLANGUAGE: Text\nCODE:\n```\nbror64(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (8-bit) Operation\nDESCRIPTION: Demonstrates the bitwise reverse operation (brev8) on an 8-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_149\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(244)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '<', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '<r es' command in dc(1) that conditionally executes one of two registers based on a less-than comparison. The command pops two numbers from the stack. If the first number is less than the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_8\n\nLANGUAGE: dc\nCODE:\n```\n<r es\n```\n\n----------------------------------------\n\nTITLE: Usage Example of Base and Scale functions in BC\nDESCRIPTION: Demonstrates the usage of `i(x)`, `o(x)`, and `r(x)` functions defined previously.  It sets the input base to 11, output base to 12, and scale to 15 and then prints the values of `ibase`, `obase`, and `scale` to verify.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/globals.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\ni(11)\nibase\no(12)\nobase\nr(15)\nscale\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (16-bit) Operation\nDESCRIPTION: This code segment rotates bits to the left in a 16-bit value utilizing 'brol16'. It shifts the bits by the amount specified in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_48\n\nLANGUAGE: Text\nCODE:\n```\nbrol16(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Modulo Operations with Integers in bc\nDESCRIPTION: This snippet demonstrates basic modulo operations using integer operands in bc.  It calculates the remainder when the first operand is divided by the second.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/modulus.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n1 % 1\n2 % 1\n16 % 4\n17 % 4\n3496723859067234 % 298375462837546928347623059375486\n-1 % 1\n-2 % 1\n-1274852934765 % 2387628935486273546\n1 % -1\n2 % -1\n2 % -3\n16 % 5\n89237423 % -237856923854\n-1 % -1\n-2 % -1\n-2 % -2\n-2 % -3\n-13 % -7\n-14 % -7\n-15 % -7\n-127849612 % -23712347682193\n```\n\n----------------------------------------\n\nTITLE: Function Definition and Call in BC\nDESCRIPTION: This snippet defines a function 'a' in BC that takes an argument 'x', prints a message including the argument's value, and then quits the program. It then calls this function with the argument 10.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/line_by_line1.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine a (x) {\n\tprint \"a(\", x, \")\\n\"\n\tquit\n}\n\na(10)\n```\n\n----------------------------------------\n\nTITLE: Example Conditional Execution with '>r' in dc(1)\nDESCRIPTION: This code snippet shows an example of conditional execution using the '>r' command. It pushes 1 and 0 onto the stack, and then compares them. Since 1 is greater than 0, the contents of register 'a' will be executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_20\n\nLANGUAGE: dc\nCODE:\n```\n1 0>a\n```\n\n----------------------------------------\n\nTITLE: Setting EXECSUFFIX for bc installation\nDESCRIPTION: This command sets the `EXECSUFFIX` environment variable to modify the installation path of the `bc` and `dc` executables. It allows appending a custom string to the names of the installed binaries.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nEXECSUFFIX=<some_suffix> ./configure.sh\n```\n\n----------------------------------------\n\nTITLE: Seed Preservation in Functions - bc\nDESCRIPTION: This bc code snippet shows how to use seed = seed instruction inside of a function when -g or --global-stacks options are in use. This makes sure that the seed is not changed in the parent functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nseed = seed\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (32-bit) Operation\nDESCRIPTION: This code segment applies a bitwise rotate left on a 32-bit number using 'brol32'. The first parameter's bits are rotated left by the amount given in the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_54\n\nLANGUAGE: Text\nCODE:\n```\nbrol32(2384001591844672901, 363382439)\n```\n\n----------------------------------------\n\nTITLE: Defining BC Function 'x'\nDESCRIPTION: This snippet defines the 'x' function in the 'bc' language. It takes two arguments, 'x' and 'y', and returns the result of the expression 'x - y + 5'. This function performs a simple subtraction and addition operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/functions.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine x(x, y) {\n\treturn x - y + 5\n}\n```\n\n----------------------------------------\n\nTITLE: Define input base function in BC\nDESCRIPTION: Defines a function `i(x)` in bc that sets the input base to the value of `x` and returns the new input base value. It allows the user to dynamically change the input base during calculations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/globals.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine i(x) {\n\tibase=x\n\treturn ibase\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Hundred\nDESCRIPTION: Illustrates bitwise right shift operations with the integer 100. The bit shifts range from 0 to 19. It is worth noting that bitwise operators are often used to perform efficient multiplication and division.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_11\n\nLANGUAGE: bc\nCODE:\n```\n100 >> 0\n```\n\n----------------------------------------\n\nTITLE: Duplicate BclNumber (bcl_dup)\nDESCRIPTION: This function creates a new BclNumber that is a copy of BclNumber *s* and returns the new BclNumber. Possible errors can be queried using bcl_err(BclNumber).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_34\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_dup(BclNumber* _s_**)\n```\n\n----------------------------------------\n\nTITLE: Function Definition (Multiple on one line)\nDESCRIPTION: This defines functions 'a' and 'b' each returning a constant value, 5 and 6 respectively. This illustrates how to define multiple functions on a single line.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine a() { return (5); };define b() { return (6); }\n```\n\n----------------------------------------\n\nTITLE: Subtraction of Large Numbers\nDESCRIPTION: This snippet performs a subtraction operation between two large decimal numbers.  No 'scale' is defined, therefore, the default scale will be used, and any fractional component will be truncated.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/vars.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\n20347023.23498723984 - 28934723874.234720384\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (8-bit) Operation\nDESCRIPTION: This code segment rotates the bits to the right in an 8-bit value with 'bror8'. The first argument's bits are shifted right by the amount specified by the second.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_58\n\nLANGUAGE: Text\nCODE:\n```\nbror8(133, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!=', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '!=r es' command in dc(1) that conditionally executes one of two registers based on an inequality comparison. The command pops two numbers from the stack. If the first number is not equal to the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_14\n\nLANGUAGE: dc\nCODE:\n```\n!=r es\n```\n\n----------------------------------------\n\nTITLE: DC Script Snippet 2\nDESCRIPTION: Similar to the previous snippet, this DC script uses stack operations and variable assignments to registers Nx, li, and Gx. It appears to define a sequence of actions to be performed on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsW\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (8-bit) Operation\nDESCRIPTION: This snippet performs bit reversal for an 8-bit value using 'brev8'. It reverses the order of bits within the input number, treated as an 8-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_37\n\nLANGUAGE: Text\nCODE:\n```\nbrev8(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Equal Else)\nDESCRIPTION: Pops two numbers. If the first is not equal to the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_14\n\nLANGUAGE: dc\nCODE:\n```\n!=res\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (32-bit) Operation\nDESCRIPTION: Performs a bitwise NOT operation on a 32-bit representation of the input. This flips each bit: 0 becomes 1, and 1 becomes 0. The function `bnot32` operates specifically on a 32-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_7\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(2366588185)\n```\n\n----------------------------------------\n\nTITLE: Declaring an Array Reference in bc\nDESCRIPTION: This shows the syntax for declaring an array reference in a function's parameter list.  Any changes to the array within the function will be reflected in the original array passed in. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Greater Than Else)\nDESCRIPTION: Pops two numbers. If the first is greater than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n>res\n```\n\n----------------------------------------\n\nTITLE: Running the Default Test Suite with Make\nDESCRIPTION: This command executes the default test suite for both `bc` and `dc` calculators. It assumes that the `make` utility is available in the system.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_27\n\nLANGUAGE: makefile\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Bit Reversal (16-bit) Operation\nDESCRIPTION: Performs a bit reversal operation on a 16-bit representation of the input. This reverses the order of the bits in the 16-bit value.  The function `brev16` specifically operates on 16-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_10\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(17689)\n```\n\n----------------------------------------\n\nTITLE: Reading Input in dc(1)\nDESCRIPTION: This snippet explains the '?' command in dc(1) that reads a line from standard input and executes it. It is typically used within macros to request input from the user.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_15\n\nLANGUAGE: dc\nCODE:\n```\n?\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (8-bit) Operation\nDESCRIPTION: This code rotates the bits of an 8-bit value to the left using 'brol8'. The first argument is rotated by the number of bits specified by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_45\n\nLANGUAGE: Text\nCODE:\n```\nbrol8(133, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Declaring Array References in bc\nDESCRIPTION: This code shows how to declare an array reference as a function parameter in bc. Changes made to the array within the function will be reflected in the original array passed as an argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (16-bit) Operation\nDESCRIPTION: This code rotates the bits to the left in a 16-bit number utilizing 'brol16'. The rotation occurs by the bit count indicated in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_49\n\nLANGUAGE: Text\nCODE:\n```\nbrol16(5509, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Modulo Operations with Scale Set to 0 in bc\nDESCRIPTION: This snippet demonstrates modulo operations in bc after setting the scale to 0.  The `scale` variable affects the number of digits after the decimal point in calculations. It shows how it interacts with the modulo operator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/modulus.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nscale = 0\n1 % 1\n2 % 1\n```\n\n----------------------------------------\n\nTITLE: Sourcing Shell Script Functions\nDESCRIPTION: This shell snippet demonstrates how to source a common functions file into another POSIX shell script. This allows the script to access and utilize functions defined in the sourced file.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n. \"$scriptdir/functions.sh\"\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (16-bit) Operation\nDESCRIPTION: This snippet reverses the bit order in a 16-bit value with 'brev16'. It effectively swaps the positions of bits within the 16-bit input number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_39\n\nLANGUAGE: Text\nCODE:\n```\nbrev16(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Conditional and Variable Assignment in bc\nDESCRIPTION: This snippet checks if 1 is equal to 0, and if it is, assigns the result to the variable 'R' using 'Ip'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\n1 0IpR\n```\n\n----------------------------------------\n\nTITLE: Defining a Void Function in bc\nDESCRIPTION: This shows the structure for defining a void function in bc, a non-portable extension. Void functions can only be used as standalone expressions, where such an expression would be printed alone, except in a print statement.  They can only use the first two return statements listed above. They can also omit the return statement entirely.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/HN.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (32-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate left operation on a 32-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_15\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Defining Void Functions in bc\nDESCRIPTION: This code snippet illustrates the syntax for defining a void function in bc. Void functions do not return a value and are a non-portable extension. They can only be used as standalone expressions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Set BclNumber to Zero (bcl_zero)\nDESCRIPTION: This function sets the value of the BclNumber *n* to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nvoid bcl_zero(BclNumber* _n_**)\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Right (64-bit) Operation\nDESCRIPTION: Performs a bit rotation right operation on a 64-bit representation of the input. This rotates the bits of the input value to the right by a specified number of positions, wrapping the shifted bits around to the other end. `bror64` specifically handles 64-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_20\n\nLANGUAGE: N/A\nCODE:\n```\nbror64(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Redundant BC Function Calls\nDESCRIPTION: This snippet duplicates a significant portion of the previous function calls to 's'. This redundancy suggests it may be for testing purposes or to ensure consistency, but it doesn't introduce new functionality.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/sine.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\ns(-4109411249.2986954846)\ns(-2395915402.13984)\ns(-2795874313)\ns(-2262647256)\ns(3323158182.1239222084)\ns(99901384)\ns(-4202726050.2780080957)\ns(2870000621.3228830588)\ns(-4230239450.981045150)\ns(-1517506941.2678857223)\ns(4004582176)\ns(-4193724543.1108508063)\ns(-3432511261)\ns(1804484812)\ns(3229084127)\ns(-3565317246.583937244)\ns(3503281621)\ns(-3469146313.1766891244)\ns(-2257308049.307721068)\ns(-3978441809)\ns(3431564304.3752537)\ns(1249644440.2464914559)\ns(2395558891.1188487974)\ns(-2607820706.4079280116)\ns(1208310007)\ns(-3758597557.863203175)\ns(1186920672)\ns(-3988103872)\ns(-4280635328.4194857577)\ns(1051748072)\ns(-1884006279)\ns(-1046568719.2698663389)\ns(2482991410)\ns(-2106101268.1154045959)\ns(3530359346.77217900)\ns(-3373362543)\ns(2601598062)\ns(2576349783.2446436039)\ns(2987020862)\ns(-12033356.2057140648)\ns(-3721760707)\ns(2842387705.4145759704)\ns(3515832681.1808393297)\ns(-3658522034.16149)\ns(3963658030.2860423992)\ns(2977802215.597946655)\ns(-4271392570.4091498761)\ns(2378692585)\ns(-3545193743.629374782)\ns(-1762458738)\ns(-1174277828.4264040126)\ns(-1724994857)\ns(2802750230.1783499408)\ns(-3068133550)\ns(3324811474.621822235)\ns(2873024984)\ns(-3509056632.3888206298)\ns(1772903162.647192879)\ns(2836543102)\ns(4117858580.186)\ns(2988632386.4063754522)\ns(-4256784971.1770067447)\ns(2280820447)\ns(-2865200306)\ns(-3329592486)\ns(519126268)\ns(-2452430452)\ns(-2693220186.62104082)\ns(-3796811992.14485798)\ns(3619792326)\ns(2697791049.3038381550)\ns(3751267834.2808166557)\ns(-3761719074)\ns(-3824087631)\ns(2119301150)\ns(1398148974)\ns(-3386564819.1351816969)\ns(-3171483098)\ns(3688944941.3273318162)\ns(3060521119)\ns(-3527110404)\ns(3699631193)\ns(3872838898)\ns(3880350192)\n```\n\n----------------------------------------\n\nTITLE: Set BclNumber to One (bcl_one)\nDESCRIPTION: This function sets the value of the BclNumber *n* to 1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\nvoid bcl_one(BclNumber* _n_**)\n```\n\n----------------------------------------\n\nTITLE: Incrementing Special Variables in BC\nDESCRIPTION: Demonstrates how to increment and decrement the special variables `ibase`, `obase`, and `last`. `last` stores the last printed value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_11\n\nLANGUAGE: BC\nCODE:\n```\n++ibase\n--ibase\n++obase\n--obase\n++last\n--last\nlast\nlast = 100\nlast\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Equal)\nDESCRIPTION: Pops two numbers. If the first is equal to the second, the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_11\n\nLANGUAGE: dc\nCODE:\n```\n=r\n```\n\n----------------------------------------\n\nTITLE: Shell aliases for number conversion using bc\nDESCRIPTION: These are example shell aliases that demonstrate how to use bc(1) for number conversion. The d2o alias converts decimal to octal, while the h2b alias converts hexadecimal to binary. This can be used as a substitute for functions that set ibase and obase globally when using the -g option.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Incrementing Scale Variable in BC\nDESCRIPTION: Demonstrates incrementing and decrementing the scale variable, which determines the precision of decimal calculations. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_13\n\nLANGUAGE: BC\nCODE:\n```\n++scale\n--scale\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise XOR Operation\nDESCRIPTION: This code snippet demonstrates the bitwise XOR operation with two 64-bit integer inputs. The function 'bxor' is used to calculate the exclusive OR of the two provided numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_27\n\nLANGUAGE: Text\nCODE:\n```\nbxor(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!>' in dc(1)\nDESCRIPTION: This snippet explains the '!>' command in dc(1) that conditionally executes a register based on a 'not greater than' (less than or equal to) comparison. The command pops two numbers from the stack. If the first number is not greater than the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_5\n\nLANGUAGE: dc\nCODE:\n```\n!>r\n```\n\n----------------------------------------\n\nTITLE: Integer Length Calculation Examples\nDESCRIPTION: These examples demonstrate the use of a function or macro named 'l10' to calculate the length (number of digits) of integers. The examples cover positive numbers, negative numbers, and zero.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/lib10.txt#_snippet_0\n\nLANGUAGE: N/A\nCODE:\n```\nl10(0)\nl10(99)\nl10(100)\nl10(-100)\n```\n\n----------------------------------------\n\nTITLE: Array Reference Declaration\nDESCRIPTION: Shows how to declare an array reference in a function parameter list in bc(1). Array references allow functions to modify the original array passed as an argument. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (16-bit) Operation\nDESCRIPTION: This code segment rotates a 16-bit value to the left using 'brol16'. The number of bit positions to rotate is given by the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_50\n\nLANGUAGE: Text\nCODE:\n```\nbrol16(2384001591844672901, 50855)\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression with Line Breaks in bc\nDESCRIPTION: This snippet demonstrates an arithmetic expression in bc with manual line breaks for readability. The \\ characters allow the expression to span multiple lines without changing its value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\n4.1*1.\\\n-1\\\n3^ - 74 - 1284597623841*1.\\\n-1\\\n3^ - 757\n```\n\n----------------------------------------\n\nTITLE: Link with bcl Library\nDESCRIPTION: This describes the necessary linking flags to use the bcl library. It also indicates that pthread is required on POSIX systems.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nLink with *-lbcl*, and on POSIX systems, *-lpthread* is also required.\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment and Addition in bc\nDESCRIPTION: This snippet demonstrates variable assignment and addition in bc. The expression `zp198202389.289374p1+pR` assigns a value to the variable 'p' and adds 1 to it. The result is then assigned to the variable 'R'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nzp198202389.289374p1+pR\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (32-bit) Operation\nDESCRIPTION: This code rotates the bits to the right in a 32-bit number via 'bror32'. The number of bit positions to rotate is determined by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_65\n\nLANGUAGE: Text\nCODE:\n```\nbror32(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (8-bit) Operation\nDESCRIPTION: This code rotates the bits to the right in an 8-bit value using 'bror8'. The amount of rotation is defined by the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_57\n\nLANGUAGE: Text\nCODE:\n```\nbror8(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Read and Execute Input\nDESCRIPTION: Reads a line from stdin and executes it as a dc command.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_15\n\nLANGUAGE: dc\nCODE:\n```\n?\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (8-bit) Operation\nDESCRIPTION: This code demonstrates bit reversal for an 8-bit value, utilizing the function 'brev8'. It reverses the bit order of the specified 8-bit unsigned integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_38\n\nLANGUAGE: Text\nCODE:\n```\nbrev8(133)\n```\n\n----------------------------------------\n\nTITLE: Increment and Compound Statements in BC\nDESCRIPTION: This snippet demonstrates post and pre increment operations, in addition to compound statements using curly braces in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_8\n\nLANGUAGE: BC\nCODE:\n```\nifz = 1\nifz\n++ifz\nifz++\nifz\n\n{\n\t4\n\t5\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Array References in bc\nDESCRIPTION: This snippet shows how to declare an array reference in the parameter list of a bc function.  Changes to the array within the function will be reflected in the original array passed in.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/A.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Less Than)\nDESCRIPTION: Pops two numbers. If the first is not less than the second (greater than or equal to), the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_9\n\nLANGUAGE: dc\nCODE:\n```\n!<r\n```\n\n----------------------------------------\n\nTITLE: Simple Addition in BC\nDESCRIPTION: This snippet demonstrates simple addition using the '+' operator in BC.  It adds 2 to a variable that is not explicitly defined, so its initial value is assumed to be 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\n1 2+p\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Right Shift Operation\nDESCRIPTION: This snippet performs a bitwise right shift operation using the 'bshr' function. It shifts a 32-bit integer to the right by a given number of bits (7 in this instance).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_29\n\nLANGUAGE: Text\nCODE:\n```\nbshr(433984901, 7)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!=r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not equal to the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_14\n\nLANGUAGE: dc\nCODE:\n```\n!=r es\n```\n\n----------------------------------------\n\nTITLE: Array Length and Function Call BC\nDESCRIPTION: Initializes the variable `len` to 16 and then attempts to call the function `a1` with `b[] ++ase^= , len`. The array passed appears to be malformed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/37.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nlen = 16\na1(b[] ++ase^= , len)\n```\n\n----------------------------------------\n\nTITLE: BclError Enum Definition\nDESCRIPTION: This code snippet declares the `BclError` enum type. It's used for error handling throughout the bcl library.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ntypedef enum BclError BclError;\n```\n\n----------------------------------------\n\nTITLE: Execution Stack Depth\nDESCRIPTION: Pushes the depth of the execution stack onto the stack. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_18\n\nLANGUAGE: dc\nCODE:\n```\n,\n```\n\n----------------------------------------\n\nTITLE: timeconst.bc Patch\nDESCRIPTION: This patch modifies the timeconst.bc script to execute the timeconst function in a loop from 0 to 50000 instead of reading input and halting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n--- ../timeconst.bc\t2018-09-28 11:32:22.808669000 -0600\n+++ ../timeconst.bc\t2019-06-07 07:26:36.359913078 -0600\n@@ -110,8 +110,10 @@\n \n \t\tprint \"#endif /* KERNEL_TIMECONST_H */\\n\"\n \t}\n-t\thalt\n }\n \n-hz = read();\n-timeconst(hz)\n+for (i = 0; i <= 50000; ++i) {\n+\ttimeconst(i)\n+}\n+\nhalt\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (<r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is less than the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_8\n\nLANGUAGE: dc\nCODE:\n```\n<r es\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Greater Than in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on a greater-than comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n>r\n```\n\nLANGUAGE: dc\nCODE:\n```\n>rers\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift Operation\nDESCRIPTION: Demonstrates the bitwise right shift operation (bshr) with a 32-bit integer argument and a shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_144\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(2815553780, 26)\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Operation\nDESCRIPTION: Performs a bitwise XOR (exclusive OR) operation on two large integer values. The XOR operation compares the bits of two numbers and sets the corresponding bit in the result to 1 if and only if exactly one of the corresponding bits in the operands is 1.  It returns the bitwise XOR of the two operands.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_2\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Defining a2 function: Squaring array elements in bc\nDESCRIPTION: The `a2` function takes an array `a[]` and its length `len` as input. It squares each element of the array and then calls the `printarray` function to display the modified array. It iterates through the array using a for loop and multiplies each element by itself.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\ndefine a2(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {(x)#086$\n7.715E\nasciify(x)#\n2893.M9\n\n7.7150-1#93.19\nasciify(x)#d(1) {\nx = asciify(x)#086$\n7.7150-1893.19\nasciify(x)\n\t\ta[i] = a[i] * a[i]\n\t}\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Hexadecimal Output for Randomness\nDESCRIPTION: This section contains a series of hexadecimal strings, which may represent the output of a random number generator. They are likely being gathered as test data for later analysis or use in other parts of the system. The sequence shows a wide variety of bytes which suggests they might have good entropy.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand_results.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n86B1DA1D72062B68\n1304AA46C9853D39\nA3670E9E0DD50358\nF9090E529A7DAE00\nC85B9FD837996F2C\n606121F8E3919196\n7CE1C7FF478354BA\nCBC4AC70E541310E\n74BE71999EC37F2C\nB81F9C99A934F1A7\n120E9901A900C97F\nF983BAD4B19F493\n5934619363660D96\nD5A7FE2717A2014E\n6E437241C9E6676E\n6A75C9DD6329CD29\n2D9E477683673437\n51FB0CF3D4405437\n217BB90392D08B20\n47C528A018B07A82\n1B4E474C418C835E\nBDB2BDA74A119ED6\nC6DB79D0B9E43493\nC3CF4834E94A41D1\nAB8312FC7877C7DC\n94B108133E8B5EC\n37CA97AC830113BD\nEF02D7347F9192BF\n959517DD9896C53A\n7A80EB7629EFE9F9\nAE53C23F2B1CF57C\nCA605CD189F6D5CD\n921C2704886A9622\nB68C9FBF826AF7AA\n73F8C733124772C3\n6B57F7E459EFBCDF\n9DE7696DDB6B8E18\n2CA67560DC26877\nA24E353080777DEC\n4D600156763FD65C\n5CDF9C7E26DD2C38\n6A32443BBBB16774\n3D8415FFECFB8B7F\n3090ED9C475635A3\n6DBF241361C3E652\n2CA9EF5A2AD971FC\n44FBE937A1CF0FFC\nDB17CF0577CB7853\nAA3747D98D31B24C\n5D9A104C5D7F43F7\nBAE65E3E293B2C7B\n16A396F0DB4EF984\n6DD2BACDC4445A05\n7B7A13D1858E5CA8\nF73722BCAA52447C\n31A2C7BBE77CBA00\n7FC8AF9003BA1ACE\n5703F11DD3F235EF\nFA1952267EF836C7\nBBFA558C9E2D51E2\n3A29661D8145AF36\n608DEA6358DABD7C\n9E34E9E53431B447\n325A05E35EA524EB\n63A87CCF0C80ABB1\n8EA183287A46F292\nE2AA5F119CBF2A08\n2F3BEB0DE8B730C8\n4B8006A928CF8F5B\n57B8BA85069C201C\n3422D962DDF59474\nFD744940BA7366A1\n23D24B06B5DA4F6F\nAA187C608319D1DC\nDC60CA6FEA738B8A\nC9FC61DF96A769FE\n82E2457708658A20\n2BECEC9B3E7D93EC\n1340DAEC04588952\nF533446AD5C50B1D\nD16DAEDD1F281A39\n6B5D9648931D7057\n62FEE3392DBB06D5\n358BC87B00DF25A\nF3C882D22946175D\n65BA8F11B4516EFE\n2DA5A96E626DA4FE\nDCC669F4CD6121F0\n7A47FAC054319CA2\n9661CFEE277284C8\n1E483A14F4EB23A\nADDC115507390607\n5AB47C343BD3B0BD\n4882FB3A3957B11F\n615B7C9C3626DD44\nF79CF49562969219\n88C32C194EA78D27\nDA8AFFE1353FF352\nA7A3C331A64CB146\nA1F53517A7BE0CAA\n7B47F409\nBA1D3330\n83D2F293\nBFA4784B\nCBED606E\nBFC6A3AD\n812FFF6D\nE61F305A\nF9384B90\n32DB86FE\n1DC035F9\nED786826\n3822441D\n2BA113D7\n1C5B818B\nA233956A\n84DA65E3\nCED67292\nB2C0FE06\n91817130\n55FE8917\n47E92091\n486AF299\nB1E882BB\nC261E845\n1A9B90F6\n7964E884\n5F36D7A4\n1EE2052D\n8519F5D5\n293D4E4F\n6D8F99FC\nC3421509\nA06CD7C6\nE43064D3\nE20F9BF0\n401B50B7\n8EF1FF3E\nE357E2B2\nA4AEEE37\n2AD4426A\n9D11BE94\n7290C556\n6E6F3787\n50C2EE3\n4FD73703\nC6FF478B\n4B1CA1E1\n1654EA91\nCD08B2F2\nF7FF3DA8\n78B1B8DA\nA100602C\n9588585F\nDA028873\n66B4F376\nE6B4B9A\n48167094\nD58CDA0\n8F7238BE\nF79983F3\n7E5D324\nAD78DF52\n1532BA74\n1E4899E2\n6C75DF64\n171DDC36\nF2D8D74A\n24E6D907\n4780FD32\n9ADF408C\nA25544CF\nEFC6A738\n1AA23A54\nC5A13EBB\nF739EDC9\nC3A015FA\n3D5E1511\nAFC4D7FB\n3F413B5E\n4660CB73\n88FC773F\nD6BED59C\n63B3B54A\nD67D3DDE\n23394F8B\n13384B44\nDD8B3ABC\nFF59A21E\n3BB16D7E\n6E01CB68\nEC34790E\nB26C42AD\nD723C830\nDFD10FCA\n7E362AA1\n826FF323\nCB8F63B5\n9B3227E5\n9A61E339\n40BDACF\n```\n\n----------------------------------------\n\nTITLE: Multiplication Test Script\nDESCRIPTION: This shell script is used to benchmark the multiplication operation in bc. It takes the bc executable, the script name (multiply.bc), and some parameters as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_2\n\nLANGUAGE: Shell Script\nCODE:\n```\ntests/script.sh bc multiply.bc 1 0 1 1 [bc]\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Less Than) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is less than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_8\n\nLANGUAGE: dc\nCODE:\n```\n<_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (32-bit) Operation\nDESCRIPTION: This code segment performs the bitwise NOT operation on a 32-bit value utilizing the 'bnot32' function. It computes the complement by inverting each bit of the 64-bit number, treating it as a 32-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_34\n\nLANGUAGE: Text\nCODE:\n```\nbnot32(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Shell aliases for base conversion\nDESCRIPTION: These shell aliases provide examples of how to use bc(1) as a number converter for different bases. `d2o` converts from decimal to octal, and `h2b` converts from hexadecimal to binary using the `-e` option to set `ibase` and `obase`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nalias d2o=\"bc -e ibase=A -e obase=8\"\nalias h2b=\"bc -e ibase=G -e obase=2\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR Example\nDESCRIPTION: Demonstrates the bitwise XOR operation (`bxor`) between two 64-bit integers.  The operation performs a logical XOR on each corresponding pair of bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_104\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(15629579542790190053, 11001744205379253724)\n```\n\n----------------------------------------\n\nTITLE: Printing Strings in bc\nDESCRIPTION: This snippet demonstrates how to print strings and newlines in bc using the `print` statement. It shows how to include a newline character in the output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nprint \"string\"\nprint \"newline\\n\"\n```\n\n----------------------------------------\n\nTITLE: Creating a String in DC\nDESCRIPTION: This snippet shows how to create a string in dc using brackets. It describes how to handle special characters like brackets and backslashes within the string.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[characters]\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Right (8-bit) Operation\nDESCRIPTION: Performs a bit rotation right operation on an 8-bit representation of the input. This rotates the bits of the input value to the right by a specified number of positions, wrapping the shifted bits around to the other end. `bror8` specifically handles 8-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_17\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(25, 64)\n```\n\n----------------------------------------\n\nTITLE: BclRandInt Type Definition\nDESCRIPTION: Defines `BclRandInt` as an unsigned long. This type represents the integer type returned by the pseudo-random number generator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\ntypedef unsigned long BclRandInt;\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Operation\nDESCRIPTION: Performs a bitwise OR operation between two 64-bit integers. The function `bor` takes two numerical arguments and returns the result of the OR operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_101\n\nLANGUAGE: C\nCODE:\n```\nbor(2453880646200884732, 16136849305783275860)\n```\n\n----------------------------------------\n\nTITLE: Bitwise AND Operation\nDESCRIPTION: Performs a bitwise AND operation between two 64-bit integers. The function `band` takes two numerical arguments and returns the result of the AND operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_100\n\nLANGUAGE: C\nCODE:\n```\nband(2453880646200884732, 16136849305783275860)\n```\n\n----------------------------------------\n\nTITLE: Bitwise OR Example\nDESCRIPTION: Demonstrates the bitwise OR operation (`bor`) between two 64-bit integers. The operation performs a logical OR on each corresponding pair of bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_103\n\nLANGUAGE: N/A\nCODE:\n```\nbor(15629579542790190053, 11001744205379253724)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!<r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not less than the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_9\n\nLANGUAGE: dc\nCODE:\n```\n!<r\n```\n\n----------------------------------------\n\nTITLE: DC Script Snippet 3\nDESCRIPTION: A DC script that includes conditional logic using '>Nx'. It stores values in registers, performs comparisons, and potentially uses recursion (indicated by 'x'). It involves operations with registers like 'li', 'Nx' and uses square brackets for defining macros or strings to be executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0s_[]zsWx[li]zs^x[lili100>Nx]0sm[]zsWx[liNx]zsxx[li;rlilix]\nx[liN]zsWx[liNx]zsxx[li;rlilix]\nx[liNzsxx\n```\n\n----------------------------------------\n\nTITLE: Bessel Function Calculation (BC Math Library)\nDESCRIPTION: This code snippet illustrates the series used in the bc math library to calculate the bessel function. It utilizes the given complex series and the relation j(-n,x) = (-1)^n * j(n,x) to handle negative x values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/algorithms.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nx^n/(2^n * n!) * (1 - x^2 * 2 * 1! * (n + 1)) + x^4/(2^4 * 2! * (n + 1) * (n + 2)) - ...\n\n```\n\nLANGUAGE: text\nCODE:\n```\nj(-n,x) = (-1)^n * j(n,x)\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Not Greater Than in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on a not-greater-than comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n!>r\n```\n\nLANGUAGE: dc\nCODE:\n```\n!>rers\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (64-bit) Operation\nDESCRIPTION: This code snippet executes a bitwise rotate left on a 64-bit value utilizing 'brol64'. The bits are rotated by the bit count specified in the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_56\n\nLANGUAGE: Text\nCODE:\n```\nbrol64(2384001591844672901, 14826715856253798055)\n```\n\n----------------------------------------\n\nTITLE: Bit Modification (32-bit) Operation\nDESCRIPTION: Performs a bit modification operation on a 32-bit representation of the input value. This function likely modifies the bit value based on an internal algorithm. `bmod32` operates on a 32-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_23\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(2366588185)\n```\n\n----------------------------------------\n\nTITLE: Function Call\nDESCRIPTION: This snippet calls the function 'a' with the argument 10. It triggers the execution of the defined function and passes the specified value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line1.txt#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\na(10)\n```\n\n----------------------------------------\n\nTITLE: Floating Point Random Number Generation\nDESCRIPTION: This snippet tests the `frand` function and `scale` function.  It verifies that `frand(10)` generates a floating-point number that, when scaled, equals 10. Requires `frand` and `scale` functions to be defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_rand.txt#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nf = frand(10)\nscale(f) == 10\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Build - Shell\nDESCRIPTION: These commands enable debug builds, which disables optimization and includes debugging information. This is helpful for identifying and fixing bugs.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_25\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -g\n./configure.sh --debug\n```\n\n----------------------------------------\n\nTITLE: Popping Macro Executions in dc(1)\nDESCRIPTION: This snippet explains the 'Q' command in dc(1) that pops a specified number of macro executions from the stack. The value popped from the stack specifies how many executions to pop. If the number of levels to pop is greater than the number of executing macros, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_17\n\nLANGUAGE: dc\nCODE:\n```\nQ\n```\n\n----------------------------------------\n\nTITLE: Integer Multiplication\nDESCRIPTION: Simple integer multiplication examples covering different magnitudes. These serve as basic tests for the multiplication function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_1\n\nLANGUAGE: NA\nCODE:\n```\n1 * 472638590273489273456\n12374861230476103672835496 * 1\n1 * 1\n2 * 1\n1 * 2\n2 * 2\n3 * 14\n17 * 8\n1892467513846753 * 1872439821374591038746\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left Operation (32-bit)\nDESCRIPTION: Performs a bitwise rotate left operation on a 32-bit integer. The function `brol32` rotates the bits to the left by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_90\n\nLANGUAGE: C\nCODE:\n```\nbrol32(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: BC Modulo with Scale Variable\nDESCRIPTION: This snippet sets the `scale` variable to 0, affecting the precision of subsequent calculations. It then demonstrates modulo operations with integers, similar to the previous snippet, but now under the context of a defined scale. Setting `scale` to 0 effectively truncates any decimal part in the division, impacting the remainder.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/modulus.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\nscale = 0\n1 % 1\n2 % 1\n16 % 4\n15 % 4\n17 % 4\n2389473 % 5\n39240687239 % 1\n346728934 % 23958\n3496723859067234 % 298375462837546928347623059375486\n-1 % 1\n-2 % 1\n-47589634875689345 % 37869235\n-1274852934765 % 2387628935486273546\n-6324758963 % 237854962\n1 % -1\n2 % -1\n2 % -2\n2 % -3\n16 % 5\n15 % 5\n14 % 5\n89237423 % -237856923854\n123647238946 % -12467\n-1 % -1\n-2 % -1\n-2 % -2\n-2 % -3\n-13 % -7\n-14 % -7\n-15 % -7\n-12784956 % -32746\n-127849612 % -23712347682193\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (8-bit) Operation\nDESCRIPTION: This snippet applies a bitwise modulo operation on an 8-bit value using 'bmod8'. It computes the modulo of the given number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_70\n\nLANGUAGE: Text\nCODE:\n```\nbmod8(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Push Extended Register Mode Status in DC\nDESCRIPTION: This snippet explains the 'gx' command, which pushes 1 onto the stack if extended register mode is on, and 0 otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_23\n\nLANGUAGE: dc\nCODE:\n```\ngx\n```\n\n----------------------------------------\n\nTITLE: Stack Depth for Exiting in dc\nDESCRIPTION: Pushes the depth of the execution stack onto the stack, facilitating dc(1) exiting with the Q command. The sequence ,Q will exit dc(1).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_18\n\nLANGUAGE: dc\nCODE:\n```\n,\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (16-bit) Example\nDESCRIPTION: Demonstrates the bitwise reverse operation (`brev16`) on a 16-bit integer. The operation reverses the order of the bits in the input value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_112\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(3708754108241877138)\n```\n\n----------------------------------------\n\nTITLE: Calling Functions with no return value\nDESCRIPTION: Illustrates the use of defined functions `y` and `z` which may or may not return values. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_14\n\nLANGUAGE: BC\nCODE:\n```\ny()\nz()\n```\n\n----------------------------------------\n\nTITLE: Simple Addition in BC\nDESCRIPTION: This snippet performs a basic addition operation in BC. It evaluates the expression 1+1 and prints the result to standard output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/line_by_line2.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n1+1\n```\n\n----------------------------------------\n\nTITLE: Repeating Byte Sequence\nDESCRIPTION: This sequence consists of repeating byte patterns '01 00 00 00...'. It could represent a binary data structure or part of a file format.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/print2.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00\n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0\\\n0 00 00\n```\n\n----------------------------------------\n\nTITLE: Checking for Number Type in dc\nDESCRIPTION: Pops a value off the stack. If it's a number, pushes 1. Otherwise (if it's a string), pushes 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_21\n\nLANGUAGE: dc\nCODE:\n```\nu\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Inequality in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on an inequality comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_8\n\nLANGUAGE: dc\nCODE:\n```\n!=r\n```\n\nLANGUAGE: dc\nCODE:\n```\n!=rers\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (16-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate right operation (bror16) on a 16-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_158\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(61684, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(16527427662727213300, 22810)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(61684, 22810)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (64-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate right operation (bror64) on a 64-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_160\n\nLANGUAGE: N/A\nCODE:\n```\nbror64(16527427662727213300, 6651564814332221722)\n```\n\n----------------------------------------\n\nTITLE: Retrieve Value from Array\nDESCRIPTION: Pops a value and uses it as an index into array *r*. The selected value is pushed onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_26\n\nLANGUAGE: dc\nCODE:\n```\n;r\n```\n\n----------------------------------------\n\nTITLE: Push Scale of Number or 0 for String\nDESCRIPTION: Pops a value. If it is a number, pushes its scale onto the stack. If it is a string, pushes 0 onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_20\n\nLANGUAGE: dc\nCODE:\n```\nX\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (16-bit) Operation\nDESCRIPTION: This snippet showcases the bitwise modulo operation applied to a 16-bit value with 'bmod16'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_72\n\nLANGUAGE: Text\nCODE:\n```\nbmod16(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operations in BC\nDESCRIPTION: Performs various arithmetic operations using scalar variables and array elements. Includes multiplication and exponentiation. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\n321 * x\n2 ^ x[0]\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (32-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate right operation on a 32-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_19\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (8-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate right operation on an 8-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_17\n\nLANGUAGE: N/A\nCODE:\n```\nbror8(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Floating Point Arithmetic and Variable Assignment in bc\nDESCRIPTION: This snippet demonstrates floating-point arithmetic and variable assignment in bc. It assigns a long floating point number to variable 'v' and then assigns v to R. It also showcases the precision handling by bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\n.0000000ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd/ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddfddddddddddddddddddddddddddddddddddddddddddddddddddddddcdddddddddddd96723895687456283846vpR\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (8-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate left operation on an 8-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_13\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Greater Than)\nDESCRIPTION: Pops two numbers. If the first is not greater than the second (less than or equal to), the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_5\n\nLANGUAGE: dc\nCODE:\n```\n!>r\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Left (16-bit) Operation\nDESCRIPTION: This snippet rotates the bits to the left in a 16-bit integer using the 'brol16' function. It rotates based on the bit position given by the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_51\n\nLANGUAGE: Text\nCODE:\n```\nbrol16(5509, 50855)\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Left (8-bit) Operation\nDESCRIPTION: Performs a bit rotation left operation on an 8-bit representation of the input. This rotates the bits of the input value to the left by a specified number of positions, wrapping the shifted bits around to the other end. `brol8` specifically handles 8-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_13\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(25, 64)\n```\n\n----------------------------------------\n\nTITLE: if-else with false condition\nDESCRIPTION: This snippet showcases an if-else statement where the condition is false (0).  Consequently, the code within the 'else' block (returning the value 5) is executed. Like the previous example, in bc an assignment is needed to store and subsequently use the result of an else statement.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nif (0) {}\nelse 5\n```\n\n----------------------------------------\n\nTITLE: Nested Loops and Conditionals in C\nDESCRIPTION: This example includes a 'for' loop with variable 'j' that iterates three times. Within this outer loop, there is an 'if' statement checking if 5 is less than 6. If it is, another nested 'for' loop with variable 'i' iterates three times. Inside this inner loop, an 'if' statement checks if 4 is less than 5, returning the value 3 if both the conditions are met.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc7.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nfor (j = 0; j < 3; ++j) if (5 < 6) for (i = 0; i < 3; ++i) if (4 < 5) 3\n```\n\n----------------------------------------\n\nTITLE: Getting configure.sh options\nDESCRIPTION: This snippet shows how to retrieve a list of available options, including environment variables, that can be used with the `configure.sh` script. The `-h` or `--help` flags can be used to display the available options.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n./configure.sh -h\n./configure.sh --help\n```\n\n----------------------------------------\n\nTITLE: Store Value in Array in DC\nDESCRIPTION: This snippet explains the ':r' command, which stores a value in array 'r' indexed by another value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_19\n\nLANGUAGE: dc\nCODE:\n```\n:r\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '<' in dc(1)\nDESCRIPTION: This snippet explains the '<' command in dc(1) that conditionally executes a register based on a less-than comparison. The command pops two numbers from the stack. If the first number is less than the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_7\n\nLANGUAGE: dc\nCODE:\n```\n<r\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (16-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate left operation (brol16) on a 16-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_154\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(61684, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(16527427662727213300, 22810)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(61684, 22810)\n```\n\n----------------------------------------\n\nTITLE: Very Large Number Assignment in bc\nDESCRIPTION: This snippet assigns a very large number to the variable 'v' and then assigns the value of 'v' to 'R'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\n237467456283846vpR\n```\n\n----------------------------------------\n\nTITLE: Getting Scale in dc\nDESCRIPTION: Pops a value off the stack. If it's a number, pushes its scale. If it's a string, pushes 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_20\n\nLANGUAGE: dc\nCODE:\n```\nX\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation (32-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 32-bit integer. The function `bnot32` inverts the bits of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_82\n\nLANGUAGE: C\nCODE:\n```\nbnot32(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Getting Leading Zero Setting in dc\nDESCRIPTION: Pushes 0 onto the stack if the leading zero setting has not been enabled, non-zero otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_30\n\nLANGUAGE: dc\nCODE:\n```\ngz\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation (8-bit)\nDESCRIPTION: Performs a bitwise NOT operation on an 8-bit integer. The function `bnot8` inverts the bits of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_80\n\nLANGUAGE: C\nCODE:\n```\nbnot8(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Push Line Length in DC\nDESCRIPTION: This snippet explains the 'gl' command, which pushes the line length set by DC_LINE_LENGTH onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_22\n\nLANGUAGE: dc\nCODE:\n```\ngl\n```\n\n----------------------------------------\n\nTITLE: Storing Array Value in dc\nDESCRIPTION: Pops two values. The second value is stored in the array *r*, indexed by the first value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_25\n\nLANGUAGE: dc\nCODE:\n```\n:r\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (16-bit)\nDESCRIPTION: Rotates the bits of a 16-bit number to the right by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_133\n\nLANGUAGE: N/A\nCODE:\n```\nbror16(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Store Value in Array\nDESCRIPTION: Pops two values. The second value is stored in array *r*, indexed by the first value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_25\n\nLANGUAGE: dc\nCODE:\n```\n:r\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo Operation (8-bit)\nDESCRIPTION: Performs a bitwise modulo operation on an 8-bit integer. The function `bmod8` calculates the modulo of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_96\n\nLANGUAGE: C\nCODE:\n```\nbmod8(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo Operation (32-bit)\nDESCRIPTION: Performs a bitwise modulo operation on a 32-bit integer. The function `bmod32` calculates the modulo of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_98\n\nLANGUAGE: C\nCODE:\n```\nbmod32(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo Operation (64-bit)\nDESCRIPTION: Performs a bitwise modulo operation on a 64-bit integer. The function `bmod64` calculates the modulo of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_99\n\nLANGUAGE: C\nCODE:\n```\nbmod64(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Left example\nDESCRIPTION: Demonstrates the bitwise shift left operation with a 32-bit number and a shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_3\n\nLANGUAGE: N/A\nCODE:\n```\nbshl(2366588185, 0)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Integer\nDESCRIPTION: Performs a bitwise right shift operation on an integer (1).  This operation is repeated with different shift amounts (0 to 19).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\n1 >> 0\n```\n\n----------------------------------------\n\nTITLE: Increment and Decrement Operators in BC\nDESCRIPTION: Demonstrates the use of increment (++) and decrement (--) operators on a scalar variable. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_5\n\nLANGUAGE: BC\nCODE:\n```\nx++\n--x\n```\n\n----------------------------------------\n\nTITLE: Reading Input in dc\nDESCRIPTION: Reads a line from stdin and executes it, allowing macros to request input from users.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_15\n\nLANGUAGE: dc\nCODE:\n```\n?\n```\n\n----------------------------------------\n\nTITLE: Pushing Depth of Execution Stack onto Stack in DC\nDESCRIPTION: This snippet explains the ',' command, which pushes the depth of the execution stack onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_12\n\nLANGUAGE: dc\nCODE:\n```\n,\n```\n\n----------------------------------------\n\nTITLE: Creating a String in dc\nDESCRIPTION: Creates a string from the characters within the brackets and pushes it onto the stack. Brackets and backslashes need to be properly escaped.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[characters]\n```\n\n----------------------------------------\n\nTITLE: Building bc on POSIX systems\nDESCRIPTION: This snippet demonstrates the general steps for configuring, building, and installing `bc` on a POSIX-compliant system. It involves running the `configure.sh` script with optional build options, followed by `make` to build the binaries, and `make install` to install them to the system.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n[ENVIRONMENT_VARIABLE=<value>...] ./configure.sh [build_options...]\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!<' in dc(1)\nDESCRIPTION: This snippet explains the '!<' command in dc(1) that conditionally executes a register based on a 'not less than' (greater than or equal to) comparison. The command pops two numbers from the stack. If the first number is not less than the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_9\n\nLANGUAGE: dc\nCODE:\n```\n!<r\n```\n\n----------------------------------------\n\nTITLE: Exit Macro Execution\nDESCRIPTION: Exits the execution of the current macro and the macro that called it. If there are no more macros to exit, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_16\n\nLANGUAGE: dc\nCODE:\n```\nq\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment\nDESCRIPTION: This snippet demonstrates a simple variable assignment in bc, setting the variable 'aa' to 0.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\naa = 0\n```\n\n----------------------------------------\n\nTITLE: Defining functions a and b\nDESCRIPTION: This code defines two functions, 'a' and 'b', that return the integer values 5 and 6 respectively. The language is unspecified and could be interpreted as a simplified scripting or mathematical notation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc8.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\ndefine a(){\n\treturn 5\n}define b(){\n\treturn 6\n}\n```\n\n----------------------------------------\n\nTITLE: Function Evaluation with pi(100)\nDESCRIPTION: This snippet demonstrates the evaluation of a function 't' with various integer and fractional inputs. 'p' is first assigned the value of pi(100), and then function 't' is called with values derived from 'p'. The goal likely is to test or explore behavior of function t at several points.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_tan.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\np=pi(100)\nt(0)\nt(1)\nt(-1)\nt(2)\nt(-2)\nt(3)\nt(-3)\nt(p)\nt(-p)\nt(p/2)\nt(-p/2)\nt(p/3)\nt(-p/3)\nt(p/4)\nt(-p/4)\nt(p/5)\nt(-p/5)\nt(p/6)\nt(-p/6)\nt(p/7)\nt(-p/7)\nt(p/8)\nt(-p/8)\nt(p/9)\nt(-p/9)\nt(p/10)\nt(-p/10)\nt(p/15)\nt(-p/15)\n```\n\n----------------------------------------\n\nTITLE: Squaring array elements and printing (a4) in BC\nDESCRIPTION: This function, `a4`, iterates through the provided array `a__[]` from index 0 to `len-1` and squares each element. It then calls `printarray` to print the array's elements after squaring.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/11.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\ndefine a4(a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = a__[i] * a__[i]\n\t}\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (16-bit) Operation\nDESCRIPTION: Demonstrates the bitwise NOT operation (bnot16) on a 16-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_146\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot16(61684)\n```\n\n----------------------------------------\n\nTITLE: Bitwise XOR example\nDESCRIPTION: Demonstrates the bitwise XOR operation between two numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_2\n\nLANGUAGE: N/A\nCODE:\n```\nbxor(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Push Extended Register Mode\nDESCRIPTION: Pushes 1 onto the stack if extended register mode is on, 0 otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_29\n\nLANGUAGE: dc\nCODE:\n```\ngx\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (16-bit) example\nDESCRIPTION: Demonstrates the bitwise reverse operation on a 16-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_10\n\nLANGUAGE: N/A\nCODE:\n```\nbrev16(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (8-bit) example\nDESCRIPTION: Demonstrates the bitwise NOT operation on an 8-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_5\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Maximum Output Base\nDESCRIPTION: This snippet displays the maximum output base allowed by the bc implementation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_25\n\nLANGUAGE: bc\nCODE:\n```\nmaxobase()\n```\n\n----------------------------------------\n\nTITLE: Identifier Regex Pattern\nDESCRIPTION: This snippet describes the regular expression used to validate identifiers in bc(1). Identifiers must begin with a lowercase letter and can be followed by any number of lowercase letters, digits, or underscores.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EN.1.md#_snippet_3\n\nLANGUAGE: regex\nCODE:\n```\n[a-z][a-z0-9_]*\n```\n\n----------------------------------------\n\nTITLE: Dividing BclNumber objects in C\nDESCRIPTION: Divides BclNumber 'a' by 'b' and returns the result. The scale of the result is the scale of the current context.  'b' cannot be zero. 'a' and 'b' are consumed unless the `_keep` variant is used. Possible errors include invalid number, invalid context, division by zero, or allocation failure.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\nBclNumber bcl_div(BclNumber *a, BclNumber *b)\n```\n\n----------------------------------------\n\nTITLE: Setting Karatsuba length\nDESCRIPTION: Configures the Karatsuba length for multiplication. Must be an integer greater than or equal to 16 to prevent stack overflow.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -k32\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --karatsuba-len 32\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (8-bit) Operation\nDESCRIPTION: This code rotates the bits to the right for an 8-bit value using 'bror8'. The bit count for the rotation is specified as the second argument.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_60\n\nLANGUAGE: Text\nCODE:\n```\nbror8(133, 167)\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Level - Shell\nDESCRIPTION: These commands set the optimization level for the compiler during the build process.  A higher optimization level can significantly improve the performance of `bc`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_23\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -O3\n./configure.sh --opt 3\n```\n\n----------------------------------------\n\nTITLE: BC Loop with Scale and Calculation\nDESCRIPTION: This BC script iterates through numbers from 0 to 100. In each iteration, it sets the `scale` variable and then calculates `4 * a(1)`. The `a(1)` part relies on a function 'a' defined elsewhere, and the result of this calculation is implicitly printed to standard output due to BC's default behavior.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/pi.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nfor (i = 0; i <= 100; ++i) {\n\tscale = i\n\t4 * a(1)\n}\n```\n\n----------------------------------------\n\nTITLE: Addition and Variable Assignment in bc\nDESCRIPTION: This snippet shows simple addition and variable assignment in bc. It adds 1 to 1 and assigns the result to the variable 'R', then prints the result. The variable 'k' is used to set the scale before the operations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\n0 1 1+kpR\n```\n\n----------------------------------------\n\nTITLE: Exponentiation Calculation (BC Math Library)\nDESCRIPTION: This code snippet illustrates the series used in the bc math library to calculate e^x. It employs the series 1 + x + x^2/2! + x^3/3! + ... and uses the relation e^x = (e^(x/2))^2 to reduce x for better convergence.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/algorithms.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1 + x + x^2/2! + x^3/3! + ...\n\n```\n\nLANGUAGE: text\nCODE:\n```\ne^x = (e^(x/2))^2\n\n```\n\n----------------------------------------\n\nTITLE: Printing Escape Sequences in bc\nDESCRIPTION: This example shows how to print escape sequences in bc, specifically backslash e and backslash d followed by a newline character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/strings.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\nprint \"\\\\e\\n\"\nprint \"\\d\\n\"\n```\n\n----------------------------------------\n\nTITLE: Incrementing and Printing in BC\nDESCRIPTION: This code snippet increments a number by 1 and prints the result.  The pattern suggests a loop structure where a number is incremented and then printed using the 'p' operator, continuing up to 200.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\n1+p\n2+p\n3+p\n4+p\n5+p\n6+p\n7+p\n8+p\n9+p\n10+p\n11+p\n12+p\n13+p\n14+p\n15+p\n16+p\n17+p\n18+p\n19+p\n20+p\n21+p\n22+p\n23+p\n24+p\n25+p\n26+p\n27+p\n28+p\n29+p\n30+p\n31+p\n32+p\n33+p\n34+p\n35+p\n36+p\n37+p\n38+p\n39+p\n40+p\n41+p\n42+p\n43+p\n44+p\n45+p\n46+p\n47+p\n48+p\n49+p\n50+p\n51+p\n52+p\n53+p\n54+p\n55+p\n56+p\n57+p\n58+p\n59+p\n60+p\n61+p\n62+p\n63+p\n64+p\n65+p\n66+p\n67+p\n68+p\n69+p\n70+p\n71+p\n72+p\n73+p\n74+p\n75+p\n76+p\n77+p\n78+p\n79+p\n80+p\n81+p\n82+p\n83+p\n84+p\n85+p\n86+p\n87+p\n88+p\n89+p\n90+p\n91+p\n92+p\n93+p\n94+p\n95+p\n96+p\n97+p\n98+p\n99+p\n100+p\n101+p\n102+p\n103+p\n104+p\n105+p\n106+p\n107+p\n108+p\n109+p\n110+p\n111+p\n112+p\n113+p\n114+p\n115+p\n116+p\n117+p\n118+p\n119+p\n120+p\n121+p\n122+p\n123+p\n124+p\n125+p\n126+p\n127+p\n128+p\n129+p\n130+p\n131+p\n132+p\n133+p\n134+p\n135+p\n136+p\n137+p\n138+p\n139+p\n140+p\n141+p\n142+p\n143+p\n144+p\n145+p\n146+p\n147+p\n148+p\n149+p\n150+p\n151+p\n152+p\n153+p\n154+p\n155+p\n156+p\n157+p\n158+p\n159+p\n160+p\n161+p\n162+p\n163+p\n164+p\n165+p\n166+p\n167+p\n168+p\n169+p\n170+p\n171+p\n172+p\n173+p\n174+p\n175+p\n176+p\n177+p\n178+p\n179+p\n180+p\n181+p\n182+p\n183+p\n184+p\n185+p\n186+p\n187+p\n188+p\n189+p\n190+p\n191+p\n192+p\n193+p\n194+p\n195+p\n196+p\n197+p\n198+p\n199+p\n200+p\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!>', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '!>r es' command in dc(1) that conditionally executes one of two registers based on a 'not greater than' (less than or equal to) comparison. The command pops two numbers from the stack. If the first number is not greater than the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_6\n\nLANGUAGE: dc\nCODE:\n```\n!>r es\n```\n\n----------------------------------------\n\nTITLE: Retrieve Value from Array in DC\nDESCRIPTION: This snippet explains the ';r' command, which retrieves a value from array 'r' using an index.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_20\n\nLANGUAGE: dc\nCODE:\n```\n;r\n```\n\n----------------------------------------\n\nTITLE: Floating Point Number\nDESCRIPTION: This snippet shows a floating point number in bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_19\n\nLANGUAGE: bc\nCODE:\n```\n3e2981\n```\n\n----------------------------------------\n\nTITLE: Push Stack Depth\nDESCRIPTION: Pushes the current depth of the stack onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_23\n\nLANGUAGE: dc\nCODE:\n```\nz\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration in BC\nDESCRIPTION: This snippet declares a variable named 'foo' within square brackets. This syntax might be specific to BC or a preprocessor being used. The exact behavior depends on the BC implementation or preprocessor configuration.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\n[foo]\n```\n\n----------------------------------------\n\nTITLE: bcl Math Operation Example\nDESCRIPTION: This code snippet shows how to perform a mathematical operation using `bcl_add`, `bcl_mul`, and `bcl_div`. The arguments are consumed regardless of errors.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nn = bcl_add(bcl_mul(a, b), bcl_div(c, d));\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (8-bit)\nDESCRIPTION: Rotates the bits of an 8-bit number to the left by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_128\n\nLANGUAGE: N/A\nCODE:\n```\nbrol8(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Calling functions a and b\nDESCRIPTION: This code calls the previously defined functions 'a' and 'b'. The expected output would be the returned values of these functions, although the execution context is unclear.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc8.txt#_snippet_1\n\nLANGUAGE: unknown\nCODE:\n```\na()\nb()\n```\n\n----------------------------------------\n\nTITLE: Get Stack Depth of Register in DC\nDESCRIPTION: This snippet explains the 'yr' command, which pushes the current stack depth of register 'r' onto the main stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_18\n\nLANGUAGE: dc\nCODE:\n```\nyr\n```\n\n----------------------------------------\n\nTITLE: Boolean OR with NOT Operators\nDESCRIPTION: This snippet combines the boolean OR operator '||' with the NOT operator '!'. The expressions demonstrate how negating an integer literal (treating it as a boolean) affects the outcome of the OR operation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/boolean.txt#_snippet_5\n\nLANGUAGE: Boolean Expression\nCODE:\n```\n!4 || 5\n!4 || 0\n!0 || 5\n4 || !5\n4 || !0\n0 || !5\n!4 || 5 || 7\n!4 || 0 || 7\n!0 || 5 || 7\n!4 || 5 || 0\n!0 || 0 || 7\n!4 || 0 || 0\n!0 || 5 || 0\n4 || !5 || 7\n4 || !0 || 7\n0 || !5 || 7\n4 || !5 || 0\n0 || !0 || 7\n4 || !0 || 0\n0 || !5 || 0\n4 || 5 || !7\n4 || 0 || !7\n0 || 5 || !7\n4 || 5 || !0\n0 || 0 || !7\n4 || 0 || !0\n0 || 5 || !0\n!4 || !5 || 7\n!4 || !0 || 7\n!0 || !5 || 7\n!4 || !5 || 0\n!0 || !0 || 7\n!4 || !0 || 0\n!0 || !5 || 0\n!4 || 5 || !7\n!4 || 0 || !7\n!0 || 5 || !7\n!4 || 5 || !0\n!0 || 0 || !7\n!4 || 0 || !0\n!0 || 5 || !0\n4 || !5 || !7\n4 || !0 || !7\n0 || !5 || !7\n4 || !5 || !0\n0 || !0 || !7\n4 || !0 || !0\n0 || !5 || !0\n!4 || !5 || !7\n!4 || !0 || !7\n!0 || !5 || !7\n!4 || !5 || !0\n!0 || !0 || !7\n!4 || !0 || !0\n!0 || !5 || !0\n```\n\n----------------------------------------\n\nTITLE: PRNG Example Numbers\nDESCRIPTION: Illustrates the decimal representation of powers of 2 in base 10. Shows how the number of decimal places increases with each halving.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_24\n\nLANGUAGE: text\nCODE:\n```\n0.5\n0.25\n0.125\n0.0625\n0.03125\n0.015625\n...\n```\n\n----------------------------------------\n\nTITLE: Large Integer Number Examples\nDESCRIPTION: This snippet provides examples of very large integer numbers, exceeding the typical range of standard integer data types. These numbers are represented as plain text strings of digits. No specific dependencies or prerequisites are required.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/decimal_results.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n135482346782356\n1023468723275435238491972521917846\n434347243243170586739207351703827039802735270902738927392073903793796\n43434724324317058673920735170382703980273527090273892739207390379379\\\n60379637893607893607893670530278200795207952702873892786172916728961\\\n783907893607418973587857386079679267926737520730925372983782793652793\n-31378682943772818461924738352952347258\n-8239456287456735894950672387239865203756982376208346745096273452730\\\n96287563846592384526349872634895763257893467523987578690283762897568\\\n459072348758071071087813501875908127359018715023841710239872301387278\n```\n\n----------------------------------------\n\nTITLE: Check if Value is a String in DC\nDESCRIPTION: This snippet explains the 't' command, which pushes 1 onto the stack if the popped value is a string, and 0 if it is a number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_16\n\nLANGUAGE: dc\nCODE:\n```\nt\n```\n\n----------------------------------------\n\nTITLE: Testing bc Only with Make\nDESCRIPTION: This command executes the test suite specifically for the `bc` calculator.  It utilizes the `make` utility to target the `test_bc` target.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_28\n\nLANGUAGE: makefile\nCODE:\n```\nmake test_bc\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (32-bit)\nDESCRIPTION: Rotates the bits of a 32-bit number to the right by a certain number of positions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_134\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(1832899002788601466, 3707273195320999771)\n```\n\n----------------------------------------\n\nTITLE: Out-of-source build example on POSIX\nDESCRIPTION: These commands demonstrate how to perform an out-of-source build of `bc` on a POSIX-compatible system. The configuration script is executed from the build directory, pointing to the source directory.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n../bc/configure.sh\nmake\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (16-bit) Operation\nDESCRIPTION: This code snippet utilizes 'brev16' to reverse the bit order of a 16-bit value. The bits within the provided 16-bit unsigned integer are reversed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_40\n\nLANGUAGE: Text\nCODE:\n```\nbrev16(5509)\n```\n\n----------------------------------------\n\nTITLE: Initializing array elements to zero (bc)\nDESCRIPTION: This section initializes a large number of array elements (from a1[0] to a52[0]) to 0. This likely serves to ensure a clean state before further array operations. Note that some array indices are missing, and there is an incomplete array assignment (a10[ ] = 0).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_9\n\nLANGUAGE: bc\nCODE:\n```\na1[0] = 0\na2[0] = 0\na3[0] = 0\na4[0] = 0\na5[0] = 0\na6[0] = 0\na7[0] = 0\na8[0] = 0\na9[0] = 0\na10[ ] = 0\na11[0] = 0\na12[0]\na13[0] = 0\na14[0] = 0\na15[0] = 0\na16[0]\na17[0] = 0\na18[0] = 0\na19[0] = 0\na20[0]\na21[0] = 0\na22[0] = 0\na23[0] = 0\na24[0]\na25[0] = 0\na26[0] = 0\na27[0] = 0\na28[0] = 0\na29[0] = 0\na30[0] = 0\na31[0] = 0\na32[0] = 0\na33[0] = 0\na34[0] = 0\na35[0] = 0\na36[0] = 0\na37[0] = 0\na38[0] = 0\na39[0] = 0\na40[0] = 0\na41[0] = 0\na42[0] = 0\na43[0] = 0\na44[0] = 0\na45[0] = 0\na46[0] = 0\na47[0] = 0\na48[0] = 0\na49[0] = 0\na50[0] = 0\na51[0] = 0\na52[0] = 50] = 0\n```\n\n----------------------------------------\n\nTITLE: Defining function g(x) in bc\nDESCRIPTION: Defines a function named `g` in the `bc` language. This function takes one argument, `x`, prints its value, and then returns the same value. The `print` statement outputs the value of `x`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/25.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine void g(x) {\n\tprint x\n\treturn x\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Macro Execution in dc(1)\nDESCRIPTION: This snippet demonstrates conditional macro execution in dc(1). It compares two numbers on the stack and executes the contents of register 'a' if the first value is greater than the second. For example, '0 1>a' executes register 'a', while '1 0>a' does not.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/N.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\n0 1>a\n```\n\nLANGUAGE: dc\nCODE:\n```\n1 0>a\n```\n\n----------------------------------------\n\nTITLE: Macro Execution Example in dc\nDESCRIPTION: This example demonstrates how a string can be executed as a macro in dc. The string '[1pR]' is pushed onto the stack and then executed, resulting in the number 1 being printed with a newline and then popped from the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/A.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[1pR]\n```\n\n----------------------------------------\n\nTITLE: Maximum Scale\nDESCRIPTION: This snippet displays the maximum scale (number of digits after the decimal point) allowed by the bc implementation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_26\n\nLANGUAGE: bc\nCODE:\n```\nmaxscale()\n```\n\n----------------------------------------\n\nTITLE: Handling Numerical Strings with Embedded Newlines and 'pR' Suffix\nDESCRIPTION: This snippet demonstrates the presence of numerical strings that include newline characters embedded within them, as well as the 'pR' suffix. These examples are designed to test a parser's resilience and correctness when encountering such atypical formatting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/decimal.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n2893.982.28937pRpR\n198273\\\n.192837pR\n1892.238907\\\n.3982739pRpR\n```\n\n----------------------------------------\n\nTITLE: Disabling Binary Stripping - Shell\nDESCRIPTION: These commands disable the stripping of binaries during the build process, which preserves debugging symbols in the final executables.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_26\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -T\n./configure.sh --disable-strip\n```\n\n----------------------------------------\n\nTITLE: Get Current Stack Depth in DC\nDESCRIPTION: This snippet explains the 'z' command, which pushes the current depth of the stack onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_17\n\nLANGUAGE: dc\nCODE:\n```\nz\n```\n\n----------------------------------------\n\nTITLE: Floating Point Number in bc\nDESCRIPTION: This snippet represents a floating-point number in bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/04.txt#_snippet_9\n\nLANGUAGE: bc\nCODE:\n```\n.0\n```\n\n----------------------------------------\n\nTITLE: Array Comparison After Reseeding\nDESCRIPTION: This code snippet reseeds the random number generator with the initial seed `s` and compares the generated random numbers with the previously stored values in array `a`. It also recalculates the sum and populates array `b` by comparing the results of `irand()` function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nprint \"Testing array...\\n\"\n\nibase = A\n\nseed = s\n\nsum = 0\n\nfor (i = 0; i < 100; ++i) {\n\ta[i] == rand()\n\tsum += a[i]\n\tb[i] == irand(sum)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Define Output Base Function in BC\nDESCRIPTION: This snippet defines a function `o(x)` in BC. It appears to be for setting the output base. The function takes an integer `x` as input, assigns it to the variable `obage` prefixed by a newline character. It then returns the `obage` variable. The newline character might be a transcription error.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/19.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine o(x) {\n\nbase=x\n\treturn obage\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Rotate Right (16-bit) Operation\nDESCRIPTION: This code rotates the bits to the right in a 16-bit integer using 'bror16'. The amount of the rotation is specified by the second parameter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_64\n\nLANGUAGE: Text\nCODE:\n```\nbror16(5509, 50855)\n```\n\n----------------------------------------\n\nTITLE: Testing length() with Arrays in BC\nDESCRIPTION: This snippet tests the `length()` function when applied to array references in BC. It sets values to specific indices in an array `a` and then uses `length(a[])` to get the length of the array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/length.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\na[0] = 0\na[5] = 0\nlength(a[])\n```\n\n----------------------------------------\n\nTITLE: Number to ASCII Character Conversion in dc\nDESCRIPTION: Pops a value; if a number, truncates and takes the absolute value, then calculates the result mod 256. Pushes an empty string if the result is 0, otherwise pushes a one-character string from the ASCII character. If the value is a string, pushes a one-character string using the first character or an empty string if the original string is empty.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Exiting Macro Execution in dc(1)\nDESCRIPTION: This snippet explains the 'q' command in dc(1) that exits the current macro execution. If the command is executed inside of nested macros, it also exits execution of the outer macro. If there are no macros running, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_16\n\nLANGUAGE: dc\nCODE:\n```\nq\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Right Operation\nDESCRIPTION: Performs a bitwise shift right operation on an integer value. The `bshr` function shifts the bits of the first argument (an integer) to the right by the number of positions specified by the second argument.  It returns the shifted value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_4\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(2366588185, 0)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(347743040, 25)\n```\n\n----------------------------------------\n\nTITLE: Division with Modulus and Keep in BclNumber (bcl_divmod_keep)\nDESCRIPTION: This function divides BclNumber *a* by *b*, placing the quotient in the location pointed to by *c*, and the modulus in the location pointed to by *d*. *b* cannot be 0. *c* and *d* cannot point to the same location, or to the space occupied by *a* or *b*. Returns BCL_ERROR_NONE on success; otherwise, an error code.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nBclError bcl_divmod_keep(BclNumber* _a_**, BclNumber* _b_**, BclNumber* _c_**, BclNumber* _d_**)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for bc\nDESCRIPTION: These environment variables configure the behavior of the bc calculator. `BC_ENV_ARGS` specifies that the `.bcrc` file should be loaded on startup, and `BC_LINE_LENGTH` sets the output line length.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nexport BC_ENV_ARGS=\"-l $HOME/.bcrc\"\nexport BC_LINE_LENGTH=\"74\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT Operation (16-bit)\nDESCRIPTION: Performs a bitwise NOT operation on a 16-bit integer. The function `bnot16` inverts the bits of the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_81\n\nLANGUAGE: C\nCODE:\n```\nbnot16(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Calculate Number of Digits or String Length\nDESCRIPTION: Pops a value. If it is a number, calculates and pushes the number of significant decimal digits. If it is a string, pushes the string length.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_19\n\nLANGUAGE: dc\nCODE:\n```\nZ\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (32-bit) Operation\nDESCRIPTION: This code snippet implements the bitwise NOT operation for a 32-bit value using the 'bnot32' function. The function complements each bit of the given 32-bit unsigned integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_35\n\nLANGUAGE: Text\nCODE:\n```\nbnot32(433984901)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (8-bit) Example\nDESCRIPTION: Demonstrates the bitwise reverse operation (`brev8`) on an 8-bit integer. The operation reverses the order of the bits in the input value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_108\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(3708754108241877138)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (8-bit)\nDESCRIPTION: Reverses the bits of an 8-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_124\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Right example\nDESCRIPTION: Demonstrates the bitwise shift right operation with a 32-bit number and a shift amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_4\n\nLANGUAGE: N/A\nCODE:\n```\nbshr(2366588185, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining a6 function: Squaring array elements with pointer (bc)\nDESCRIPTION: The `a6` function takes an array pointer `*a__[]` and its length `len` as input. It iterates through the array, squares each element, and then prints the modified array using the `printarray` function. This function uses a pointer for array access.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\ndefine a6(*a__[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta__[i] = a__[i] * a__[i]\n\t}\n\n\tprintarray(a__[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring bc/dc Without Generated Tests\nDESCRIPTION: These commands configure the build process to disable the generation of tests that rely on a GNU-compatible `bc` and `dc` calculators. The `-G` flag and `--disable-generated-tests` option are equivalent.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh -G\n```\n\nLANGUAGE: shell\nCODE:\n```\n./configure.sh --disable-generated-tests\n```\n\n----------------------------------------\n\nTITLE: Exit Multiple Macro Executions\nDESCRIPTION: Pops a non-negative value from the stack, which determines how many macro executions to pop off the execution stack. If the number of levels to pop is greater than the number of executing macros, dc(1) exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_17\n\nLANGUAGE: dc\nCODE:\n```\nQ\n```\n\n----------------------------------------\n\nTITLE: Bit Modification (8-bit) Operation\nDESCRIPTION: Performs a bit modification operation on an 8-bit representation of the input value. This function likely modifies the bit value based on an internal algorithm. `bmod8` operates on an 8-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_21\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(25)\n```\n\n----------------------------------------\n\nTITLE: Function Definition (Multiple)\nDESCRIPTION: This snippet defines a function 'x' with an argument 'e' multiple times, each with a different implementation.  The last definition will override any previous definitions of 'x(e)'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\ndefine x(e) { return 0; }\ndefine x(e) { return 4*(e+e); }\ndefine x(e) { return (e+e)*4; }\n```\n\n----------------------------------------\n\nTITLE: Subtraction Test Script\nDESCRIPTION: This shell script is used to benchmark the subtraction operation in bc. It takes the bc executable, the script name (subtract.bc), and some parameters as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_1\n\nLANGUAGE: Shell Script\nCODE:\n```\ntests/script.sh bc subtract.bc 1 0 1 1 [bc]\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (32-bit) Operation\nDESCRIPTION: This code demonstrates the bitwise modulo operation on a 32-bit value through the 'bmod32' function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_75\n\nLANGUAGE: Text\nCODE:\n```\nbmod32(433984901)\n```\n\n----------------------------------------\n\nTITLE: Compare Two BclNumbers (bcl_cmp)\nDESCRIPTION: This function compares two BclNumber variables, *a* and *b*, returning 0 if they are equal, <0 if *a* < *b*, and >0 if *a* > *b*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_32\n\nLANGUAGE: C\nCODE:\n```\nssize_t bcl_cmp(BclNumber* _a_**, BclNumber* _b_**)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (64-bit) Operation\nDESCRIPTION: Demonstrates the bitwise reverse operation (brev64) on a 64-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_152\n\nLANGUAGE: N/A\nCODE:\n```\nbrev64(16527427662727213300)\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (32-bit) Operation\nDESCRIPTION: Demonstrates the bitwise NOT operation (bnot32) on a 32-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_147\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(16527427662727213300)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot32(2815553780)\n```\n\n----------------------------------------\n\nTITLE: Building bcl library with MSBuild on Windows\nDESCRIPTION: This command builds the `bcl` library using MSBuild on Windows. It requires Visual Studio with MSBuild and specifies the configuration (Debug, ReleaseMD, or ReleaseMT). The output library is located in the `vs/lib` directory.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmsbuild -property:Configuration=<config> vs/bcl.sln\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse (8-bit) example\nDESCRIPTION: Demonstrates the bitwise reverse operation on an 8-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_9\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: if-else with empty else block\nDESCRIPTION: Demonstrates an if-else statement where the 'else' block is empty. If the condition (1) is true, the expression 6 is evaluated (but not necessarily assigned). Because 1 is always true, the empty else block is ignored. Note that in bc an assignment is needed to store and subsequently use the result of an if statement.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc5.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nif (1) 6\nelse {}\n```\n\n----------------------------------------\n\nTITLE: If Condition with For Loop C\nDESCRIPTION: This snippet showcases an 'if' statement that encloses a 'for' loop, which in turn contains another 'if' statement. The code first checks if 3 is less than 4. If true, it executes the inner for loop, which iterates three times and checks if 4 is less than 5 in each iteration, executing '2' if that is also true.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/stdin2.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nif (3 < 4) for (i = 0; i < 3; ++i) if (4 < 5) 2\n```\n\n----------------------------------------\n\nTITLE: Defining and Using bc Macros with Conditional\nDESCRIPTION: This snippet is very similar to the first one, but it includes a slightly different string literal within the `M` macro, using `!` for a possible comparison. It defines a macro `M` and uses `pR` for printing. The conditional comparison likely affects the program's execution flow. The `Done!` string is printed if the comparison passes.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/23.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\n[[Done!]pR]sMYip1-si0li!<LeM]sL10silLx\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right (32-bit) Operation\nDESCRIPTION: Demonstrates the bitwise rotate right operation (bror32) on a 32-bit integer with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_159\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(16527427662727213300, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(2815553780, 6651564814332221722)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(16527427662727213300, 113400090)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbror32(2815553780, 113400090)\n```\n\n----------------------------------------\n\nTITLE: Output Base Assignment\nDESCRIPTION: This snippet demonstrates assigning 0 to the output base (obase) in bc. It's likely to revert to the default obase (10).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_21\n\nLANGUAGE: bc\nCODE:\n```\nobase = 0\n```\n\n----------------------------------------\n\nTITLE: Generating Test Coverage with rig\nDESCRIPTION: These commands are used to generate test coverage information for the project, requiring `gcc`, `gcov`, and `gcovr`. It involves configuring the compiler with specific flags for debugging, optimization, and coverage, then running `rig coverage` to collect the data.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nrig --compiler=gcc -Ddebug=1 -Doptimization=3 -Dcoverage=1\nrig coverage\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Small Floating Point Number\nDESCRIPTION: Performs a bitwise right shift operation on a small floating-point number. The right operand determines the number of bits to shift. These are common operations in languages which support direct memory and bit manipulation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\n0.00000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Macro Execution Example in dc(1)\nDESCRIPTION: This example demonstrates how a string can be executed as a macro within dc(1). The string '[1pR]' is pushed onto the stack and then executed. This results in the number 1 being printed followed by a newline, and then popped from the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/N.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[1pR]\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Number List\nDESCRIPTION: This snippet shows a series of floating-point numbers. The numbers vary in magnitude, ranging from 10,000,000,000.0000000001 to 0.00000000100000000000001. These are likely used for testing floating-point precision or as input to a calculation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift_results.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n10000000000.0000000001\n1000000000.0000000001\n100000000.00000000001\n10000000.000000000001\n1000000.0000000000001\n100000.00000000000001\n10000.000000000000001\n1000.0000000000000001\n100.00000000000000001\n10.000000000000000001\n1.0000000000000000001\n.10000000000000000001\n.010000000000000000001\n.0010000000000000000001\n.00010000000000000000001\n.000010000000000000000001\n.0000010000000000000000001\n.00000010000000000000000001\n.000000010000000000000000001\n.00000000100000000000000000001\n```\n\n----------------------------------------\n\nTITLE: Regex for bc(1) Identifiers\nDESCRIPTION: Defines the regular expression for valid identifiers in bc(1). Identifiers must start with a lowercase letter, followed by any number of lowercase letters, digits, or underscores. The length is limited by BC_NAME_MAX-1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_2\n\nLANGUAGE: regex\nCODE:\n```\n[a-z][a-z0-9_]*\n```\n\n----------------------------------------\n\nTITLE: Conditional with For Loop and Conditional in C\nDESCRIPTION: This snippet demonstrates an 'if' statement that checks if 3 is less than 4. If true, it executes a 'for' loop which iterates three times. Inside the loop, another 'if' statement checks if 4 is less than 5. If that condition is also true, the value 2 is returned (and also unused).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc7.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nif (3 < 4) for (i = 0; i < 3; ++i) if (4 < 5) 2\n```\n\n----------------------------------------\n\nTITLE: BIPR Script Snippet\nDESCRIPTION: A BIPR (likely related to bc or dc) script for formatting numbers. It uses 'p' for printing and 'R' for some kind of formatting or conversion. The script defines a series of formatting rules, probably for decimal numbers.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_5\n\nLANGUAGE: BIPR\nCODE:\n```\n00?00pR0.0pR\n.0000p0000000000000;0000000000.0pR\n.0000p00.000000;00000500000.0pR\n.0000p0000000000?00pR0.0pR\n.0000p0000000000000;0000000000.0pR\n.0000p00.000000;00000500000.0pR\n.0000p00000000000000000000000000000000000000000d000.0pR\n.0000p0000000000000000000000R\n.0000p02730pR\n00000pR0.0pR\n.0000p0000000000000000000000R\n.0000p00pR\n```\n\n----------------------------------------\n\nTITLE: Mixed Number Examples\nDESCRIPTION: This snippet presents a mixture of integer and floating-point number examples with different formats and precisions. These can be used for testing the validity of numerical input and output routines.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/decimal_results.txt#_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\n2893729837\n29837.29837048\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (32-bit)\nDESCRIPTION: Performs a modulo operation based on the size of a 32 bit number. The inputs are truncated to 32 bits before being used as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_138\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: Printing in BC\nDESCRIPTION: This snippet demonstrates printing without any preceding operation.  The 'p' operator will likely print the value of the last variable used or 0 if no variable has been used yet.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/stdin.txt#_snippet_5\n\nLANGUAGE: BC\nCODE:\n```\np\n```\n\n----------------------------------------\n\nTITLE: Running AFL++ crash analysis script\nDESCRIPTION: This command executes a Python script to analyze crashes reported by AFL++. The script checks whether the reported crash is valid and, if so, copies the crashing test case to a file for further investigation. The `<dir>` argument specifies the directory where the AFL++ output is located.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/afl.py <dir>\n```\n\n----------------------------------------\n\nTITLE: Include bcl Header\nDESCRIPTION: This code snippet demonstrates how to include the bcl library header file in a C program. This inclusion is necessary to access the library's functions and data structures.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <bcl.h>\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (8-bit) Operation\nDESCRIPTION: This code demonstrates computing the bitwise modulo for an 8-bit value using the function 'bmod8'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_71\n\nLANGUAGE: Text\nCODE:\n```\nbmod8(133)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Floating Point Number 2\nDESCRIPTION: Demonstrates bitwise right shift operations on the floating-point number 0.000000001, with right operands ranging from 0 to 19. This operation shifts the binary representation of the number to the right by the specified number of bits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\n0.000000001 >> 0\n```\n\n----------------------------------------\n\nTITLE: Copy BclNumber (bcl_copy)\nDESCRIPTION: This function copies the value of BclNumber *s* into BclNumber *d*. It returns BCL_ERROR_NONE on success; otherwise, it returns an error code.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_33\n\nLANGUAGE: C\nCODE:\n```\nBclError bcl_copy(BclNumber* _d_**, BclNumber* _s_**)\n```\n\n----------------------------------------\n\nTITLE: Configuring bc only build\nDESCRIPTION: Configures the build to build only bc and not dc. Using these options when bc is also disabled will result in an error.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -b\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --bc-only\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -D\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-dc\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operation\nDESCRIPTION: This snippet performs a simple addition operation (5 + 5). The result may be displayed, stored in a variable, or used in a subsequent calculation, depending on the language's implicit behavior. There are no explicit dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/read_errors.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\n5+5;\n```\n\n----------------------------------------\n\nTITLE: Void Function Definition\nDESCRIPTION: Demonstrates how to define a void function in bc(1). Void functions don't return a value and are typically used for performing actions or side effects. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EH.1.md#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Reverse Operation (32-bit)\nDESCRIPTION: Performs a bitwise reverse operation on a 32-bit integer. The function `brev32` reverses the order of bits in the input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_86\n\nLANGUAGE: C\nCODE:\n```\nbrev32(9338170161174399402)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (8-bit)\nDESCRIPTION: Performs a modulo operation based on the size of an 8 bit number. The inputs are truncated to 8 bits before being used as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_136\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(1832899002788601466)\n```\n\n----------------------------------------\n\nTITLE: For Loop with Increment\nDESCRIPTION: This snippet shows a for loop in bc that increments 'x' as long as 'x' is less than 0, and increments 'y' in each iteration.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_12\n\nLANGUAGE: bc\nCODE:\n```\nfor (; x<0; ++x) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Define Array Initialize and Square Function BC\nDESCRIPTION: Defines a function `a1` that takes an array `a` and its length `len`. It initializes the array elements with their index values and then calls function `a2` and `printarray`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/37.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\ndefine a1(*a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = i\n\t}\n\n\ta2(a[], len)\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise MOD (32-bit) Operation\nDESCRIPTION: Demonstrates the bitwise MOD operation (bmod32) on a 32-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_163\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(5205211806348135630)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(973917390)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (32-bit) example\nDESCRIPTION: Demonstrates the bitwise modulo operation on a 32-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_23\n\nLANGUAGE: N/A\nCODE:\n```\nbmod32(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Parallel for Coverage\nDESCRIPTION: These commands allow for parallel execution of tests to speed up the testing process. It then aggregates the coverage results correctly.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nmake -j<cores>\nmake -j<cores> test\nmake coverage_output\n```\n\n----------------------------------------\n\nTITLE: Quit BC Interpreter\nDESCRIPTION: This snippet uses the 'quit' command to exit the BC interpreter. This command terminates the execution of the BC script and returns control to the operating system.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/line_by_line2.txt#_snippet_3\n\nLANGUAGE: BC\nCODE:\n```\nquit\n```\n\n----------------------------------------\n\nTITLE: Void Function Definition Syntax in bc\nDESCRIPTION: Defines the syntax for void function definitions in bc. These functions, identified by the `void` keyword after `define`, are intended for standalone expressions and have specific restrictions on their return statements.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ndefine void I(I,...,I){\n\tauto I,...,I\n\tS;...;S\n\treturn\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop with No Initialization, Condition, or Increment\nDESCRIPTION: This snippet demonstrates an infinite for loop with empty initialization, condition, and increment expressions. Equivalent to while(true).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_18\n\nLANGUAGE: bc\nCODE:\n```\nfor (;;) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (8-bit) example\nDESCRIPTION: Demonstrates the bitwise modulo operation on an 8-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_21\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Bitwise MOD (64-bit) Operation\nDESCRIPTION: Demonstrates the bitwise MOD operation (bmod64) on a 64-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_164\n\nLANGUAGE: N/A\nCODE:\n```\nbmod64(5205211806348135630)\n```\n\n----------------------------------------\n\nTITLE: Array manipulation and printing (bc)\nDESCRIPTION: This code snippet sets the length `len` to 16 and then calls the functions `a1`, `a3`, `a5`, and `a7` with array `a[]` and `b[]` and prints the arrays after each function call. This demonstrates the usage of these array manipulation functions.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_8\n\nLANGUAGE: bc\nCODE:\n```\nlen = 16\n\na1(a[], len)\nprintarray(a[], len)\na3(a[], len)\nprintarray(a[], len)\na5(a[], len)\nprintarray(a[], len)\na7(a[], len)\nprintarray(a[], len)\n\na1(b[], len)\nprintarray(b[], len)\na3(b[], len)\nprintarray(b[], len)\na5(b[], len)\nprintarray(b[], len)\na7(b[], len)\nprintarray(b[], len)\n```\n\n----------------------------------------\n\nTITLE: Testing Bit Reversal (32-bit) Operation\nDESCRIPTION: This code segment reverses the bit order in a 32-bit value with 'brev32'. This function swaps the positions of the bits in a given 32-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_41\n\nLANGUAGE: Text\nCODE:\n```\nbrev32(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Valgrind\nDESCRIPTION: These commands run the test suite under Valgrind to detect memory errors and leaks. Valgrind integration is built into the test suite.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_13\n\nLANGUAGE: Shell\nCODE:\n```\n./configure -gO3 -v\nmake -j<cores>\nmake -j<cores> test\n```\n\n----------------------------------------\n\nTITLE: Integer Number Examples\nDESCRIPTION: This snippet showcases examples of integer numbers, including positive, negative, and zero values. The numbers are represented as plain text. No specific dependencies or prerequisites are required.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/decimal_results.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n0\n0\n0\n0\n2\n1\n11\n123\n7505\n-1\n-203\n-57\n-18586\n```\n\n----------------------------------------\n\nTITLE: Array Reference Declaration in bc\nDESCRIPTION: Illustrates the syntax for declaring array references in bc function parameter lists using the `*I[]` notation. Changes to these array references within the function will be reflected in the original array passed to the function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/EHN.1.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n*I[]\n```\n\n----------------------------------------\n\nTITLE: Push Line Length\nDESCRIPTION: Pushes the line length set by DC_LINE_LENGTH onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_28\n\nLANGUAGE: dc\nCODE:\n```\ngl\n```\n\n----------------------------------------\n\nTITLE: bc quit Statement Example\nDESCRIPTION: Illustrates the behavior of the `quit` statement in bc, showing that the current implementation executes completed statements before exiting, unlike other implementations.  This example demonstrates the difference in output between this implementation and others.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/H.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!<r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not less than the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_10\n\nLANGUAGE: dc\nCODE:\n```\n!<r es\n```\n\n----------------------------------------\n\nTITLE: Exiting Multiple Macro Executions in DC\nDESCRIPTION: This snippet explains the 'Q' command, which pops a value from the stack and uses it as the number of macro executions to pop off the execution stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_11\n\nLANGUAGE: dc\nCODE:\n```\nQ\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '=', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '=r es' command in dc(1) that conditionally executes one of two registers based on an equality comparison. The command pops two numbers from the stack. If the first number is equal to the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_12\n\nLANGUAGE: dc\nCODE:\n```\n=r es\n```\n\n----------------------------------------\n\nTITLE: Line Comment Syntax in bc(1)\nDESCRIPTION: This snippet shows the syntax for line comments in bc(1). Line comments start with '#' and continue until the end of the line. This type of comment is considered a non-portable extension to the bc(1) standard.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_4\n\nLANGUAGE: bc\nCODE:\n```\n# ...\n```\n\n----------------------------------------\n\nTITLE: Disabling Manpage Installation - Shell\nDESCRIPTION: These commands disable the installation of manpages during the installation process. This can be useful if manpages are not desired or if there are issues with their installation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_21\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -M\n./configure.sh --disable-man-pages\n```\n\n----------------------------------------\n\nTITLE: Displaying Binary Data\nDESCRIPTION: This snippet represents a hexadecimal dump of binary data. Each line shows a series of byte values, likely read from a file or memory location.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/print2.txt#_snippet_2\n\nLANGUAGE: hex\nCODE:\n```\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n```\n\n----------------------------------------\n\nTITLE: Displaying bc version information\nDESCRIPTION: This snippet shows the output of the `bc -v` command, which displays the version information of the bc utility.  The specific versions shown are on FreeBSD 12.2-STABLE and 14-CURRENT.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/project/issue10.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ bc -v\nbc 4.0.1\nCopyright (c) 2018-2021 Gavin D. Howard and contributors\nReport bugs at: https://git.yzena.com/gavin/bc\n\nThis is free software with ABSOLUTELY NO WARRANTY.\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ bc -v\nbc 4.0.0\nCopyright (c) 2018-2021 Gavin D. Howard and contributors\nReport bugs at: https://git.yzena.com/gavin/bc\n\nThis is free software with ABSOLUTELY NO WARRANTY.\n```\n\n----------------------------------------\n\nTITLE: Array Handling in BC\nDESCRIPTION: This snippet defines a function `u` that attempts to access an element of an automatically declared array `a`.  This highlights the way arrays are handled by default in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc2.txt#_snippet_4\n\nLANGUAGE: BC\nCODE:\n```\ndefine u() {\n\tauto a[];\n\treturn a[0]\n}\n\nu()\n```\n\n----------------------------------------\n\nTITLE: Macro Execution\nDESCRIPTION: Pops a value off of the top of the stack. If it is a number, it is pushed back onto the stack. If it is a string, it is executed as a macro. This describes the standard behavior when executing a macro.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Complex Nested Conditional and Loops in C\nDESCRIPTION: This snippet showcases multiple levels of nesting: an outer 'if' statement, followed by a 'for' loop, another 'if' statement, and finally an inner 'for' loop and 'if' statement. If 6 is less than 7, the outer 'for' loop (with 'j') executes three times. Inside, if 5 is less than 6, the inner 'for' loop (with 'i') also executes three times. Finally, if 4 is less than 5, the value 4 is returned (and discarded).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc7.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nif (6 < 7) for (j = 0; j < 3; ++j) if (5 < 6) for (i = 0; i < 3; ++i) if (4 < 5) 4\n```\n\n----------------------------------------\n\nTITLE: BC Script Loop and Quit\nDESCRIPTION: This BC script demonstrates a basic for loop that iterates three times. The loop body is intentionally empty. After the loop completes, the `quit` command is executed, terminating the BC interpreter.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/line_loop_quit1.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n3\nfor (i = 0; i < 3; ++i) i; quit\n```\n\n----------------------------------------\n\nTITLE: test2.bc Script (While Loop)\nDESCRIPTION: This bc script contains a while loop that increments the variable i from 0 to 99999999. The script then prints the final value of i before halting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_9\n\nLANGUAGE: bc\nCODE:\n```\ni = 0\n\nwhile (i < 100000000) {\n\ti += 1\n}\n\ni\n\nhalt\n```\n\n----------------------------------------\n\nTITLE: Halting Execution\nDESCRIPTION: This snippet demonstrates the 'halt' command in bc, which stops the execution of the script.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nhalt\n```\n\n----------------------------------------\n\nTITLE: Error Handling Status Check in bc (pre-3.0.0)\nDESCRIPTION: Before version 3.0.0, bc used a manual error handling system where most functions returned a `BcStatus` indicating if an error occurred. This required explicit checks after each function call to determine if an error had occurred. This snippet illustrates the common pattern used to check for errors and return the status if an error was detected.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nif (BC_ERR(s)) return s;\n```\n\n----------------------------------------\n\nTITLE: bc Macro Definition and Execution\nDESCRIPTION: This snippet defines bc macros using string registers (sM, sL) and utilizes conditional execution (li>L). The 'aa' macro likely prints 'Done!', while the other macros involve register manipulations using 'lip' (likely printing a register's content) and conditional jumps based on register values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/11.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n#! /bin/dc\n[[Done!]aa]sM[lip1-si0li>LeM]sL10silLx\n[[Done!]pR]sM[]sL10silLx\n[R]sM[lip=`eM]sL;Lx\n```\n\n----------------------------------------\n\nTITLE: Enabling Editline history support\nDESCRIPTION: Configures the build to enable editline support for history, providing vi-like keybindings and other features. Ignored if history is disabled.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -e\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --enable-editline\n```\n\n----------------------------------------\n\nTITLE: test.bc Script (For Loop)\nDESCRIPTION: This bc script contains a for loop that iterates from 0 to 99999999, assigning the loop counter to the variable y.  The script then prints the final values of i and y before halting.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_7\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 100000000; ++i) {\n\ty = i\n}\n\ni\ny\n\nhalt\n```\n\n----------------------------------------\n\nTITLE: Integer Random Number Generation\nDESCRIPTION: This snippet tests the `irand` function. It checks that the generated random integer `i` falls within the range of 0 to `maxrand()`, inclusive. Requires `irand` and `maxrand` functions to be defined.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/lib2_rand.txt#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ni = irand(maxrand() + 1)\ni <= maxrand()\ni >= 0\n```\n\n----------------------------------------\n\nTITLE: Running Static Analysis with Clang\nDESCRIPTION: These commands run the Clang Static Analyzer using `scan-build` to detect potential issues in the code. The analysis is performed in debug mode.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_15\n\nLANGUAGE: Shell\nCODE:\n```\nmake clean\nscan-build make\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '=' in dc(1)\nDESCRIPTION: This snippet explains the '=' command in dc(1) that conditionally executes a register based on an equality comparison. The command pops two numbers from the stack. If the first number is equal to the second, the contents of register 'r' are executed. If either value is not a number, it raises an error and resets.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_11\n\nLANGUAGE: dc\nCODE:\n```\n=r\n```\n\n----------------------------------------\n\nTITLE: Array Initialization and Length Determination in BC\nDESCRIPTION: This snippet initializes array `a[]` with values from 0 to 100. `a[i]` is set to `i` for i=0 to 100. Then sets `a[104]` to 204. Afterwards, the length of the array `a[]` is calculated and stored in the global variable `l` using `length(a[])`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_6\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; i < 101; ++i) {\n\ta[i] = i\n}\n\na[104] = 204\n\nl = length(a[])\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (16-bit) example\nDESCRIPTION: Demonstrates the bitwise modulo operation on a 16-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_22\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: DC Script with Variable Assignment and Conditional\nDESCRIPTION: This DC script initializes variable 'Nx', potentially performs stack operations involving 'li', 'Gx', and 'Px', and then executes a 'dc' command. It uses stack manipulation and variable assignment, key aspects of DC programming. The script appears to be incomplete.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/10.txt#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]zsWx[li]zsGx[Nfvfff[]zsm[]zsWx[li]zsPx[Nx]0sm[]zsdc\n```\n\n----------------------------------------\n\nTITLE: Defining Function h with Array Arguments in BC\nDESCRIPTION: This function `h(uto, x[])` calls function `g(x[], y[])` to calculate the difference between arrays `x[]` and `y[]`. The `uto` parameter doesn't appear to be used. It assumes that `y[]` is defined globally or within the calling scope.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\ndefine h(uto, x[]) {\n\treturn g(x[], y[])\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Configuration Option to OFF - Shell\nDESCRIPTION: This command uses the configure.sh script to set the default value of a specified configuration option to 'off'. It is used to disable features or behaviors by default when bc or dc is installed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_19\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -S bc.banner\n./configure.sh --set-default-off=bc.banner\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Less Than Else)\nDESCRIPTION: Pops two numbers. If the first is less than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_8\n\nLANGUAGE: dc\nCODE:\n```\n<res\n```\n\n----------------------------------------\n\nTITLE: Configuring BSD predefined build\nDESCRIPTION: Configures the build for bc and dc to be compatible with the BSD versions. This sets up a release build with BSD compatibility.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -pBSD\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --predefined-build-type=BSD\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop with Math Operation in bc\nDESCRIPTION: This bc snippet appears to define an infinite loop with a complex math expression. The `ssqrtt()` function suggests a repeated square root calculation, while `p(s(...))` likely involves printing and further processing. Due to the cryptic nature, the precise result and usage are uncertain without more context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/03.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; ; )\nfor (i = 0; ;(p(s(ssqrtt()-p())))00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n```\n\n----------------------------------------\n\nTITLE: Assignment with Function Call in C\nDESCRIPTION: This snippet assigns the result of calling the function 'asciify(a[])' to the variable 'x'. The 'asciify' function, again taking array 'a' as an argument, likely returns an ASCII representation of the array which is then stored in variable 'x'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/36.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nx = asciify(a[])\n```\n\n----------------------------------------\n\nTITLE: Troff Formatting Directives\nDESCRIPTION: Sets up troff formatting options. `.nh` disables hyphenation, and `.ad l` adjusts text to the left margin.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/header_dc.txt#_snippet_1\n\nLANGUAGE: troff\nCODE:\n```\n.nh\n.ad l\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Equal) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is equal to the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_12\n\nLANGUAGE: dc\nCODE:\n```\n=_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Macro Execution in dc\nDESCRIPTION: Pops a value from the stack. If it is a string, it is executed as a macro. If it is a number, it is pushed back onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Bit Reversal (64-bit) Operation\nDESCRIPTION: Performs a bit reversal operation on a 64-bit representation of the input. This reverses the order of the bits in the 64-bit value.  The function `brev64` specifically operates on 64-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_12\n\nLANGUAGE: N/A\nCODE:\n```\nbrev64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Right Operation (16-bit)\nDESCRIPTION: Performs a bitwise rotate right operation on a 16-bit integer. The function `bror16` rotates the bits to the right by a specified amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_93\n\nLANGUAGE: C\nCODE:\n```\nbror16(9338170161174399402, 5871583126889167076)\n```\n\n----------------------------------------\n\nTITLE: Check if String\nDESCRIPTION: Pops a value. Pushes 1 onto the stack if the value is a string, otherwise pushes 0 (if it's a number). This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_22\n\nLANGUAGE: dc\nCODE:\n```\nt\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (>r es)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is greater than the second, executes register *r*. Otherwise, executes register *s*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n>r es\n```\n\n----------------------------------------\n\nTITLE: Installing All Locales - Shell\nDESCRIPTION: These commands force the installation of all available locales during the installation process, overriding the default behavior of only installing enabled locales.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_22\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -l\n./configure.sh --install-all-locales\n```\n\n----------------------------------------\n\nTITLE: Building bc and dc with default configuration on POSIX\nDESCRIPTION: These commands configure and build `bc` and `dc` on a POSIX-compatible system. It uses the `configure.sh` script to set up the build environment with optimization enabled and then compiles the source code using `make`. The executables are created in the `bin` directory.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -O3\nmake\n```\n\n----------------------------------------\n\nTITLE: Getting Register Stack Depth in dc\nDESCRIPTION: Pushes the current stack depth of the register *r* onto the main stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_24\n\nLANGUAGE: dc\nCODE:\n```\nyr\n```\n\n----------------------------------------\n\nTITLE: Execute String Macro\nDESCRIPTION: Pops a value. If it is a string, it is executed as a macro. If the popped value is a number, it is pushed back onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Building bcl library on POSIX\nDESCRIPTION: This command configures the build to create the `bcl` library. The `-a` or `--library` options ensure that only the library is built, and not the `bc` and `dc` executables.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -a\n```\n\n----------------------------------------\n\nTITLE: Input Function Call\nDESCRIPTION: This snippet invokes a function named 'read()'.  This function likely reads input from a standard input stream (e.g., keyboard).  The specific data type returned by the function depends on the language implementation. There are no explicit dependencies besides the built-in read() function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/read_errors.txt#_snippet_1\n\nLANGUAGE: unknown\nCODE:\n```\nread()\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Greater Than) with Else\nDESCRIPTION: Pops two numbers off the stack and compares them. If the first value is greater than the second, the contents of register *r* are executed; otherwise, the contents of register *s* are executed. An error occurs if either value is not a number. This command is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_4\n\nLANGUAGE: dc\nCODE:\n```\n>_r_e_s_\n```\n\n----------------------------------------\n\nTITLE: Accessing Special Variables in BC\nDESCRIPTION: Accesses the values of special variables `scale`, `ibase`, and `obase`, which control the precision and number base used in calculations. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\nscale\nibase\nobase\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Left (32-bit) Operation\nDESCRIPTION: Performs a bit rotation left operation on a 32-bit representation of the input. This rotates the bits of the input value to the left by a specified number of positions, wrapping the shifted bits around to the other end. `brol32` specifically handles 32-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_15\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol32(2366588185, 347743040)\n```\n\n----------------------------------------\n\nTITLE: timeconst.bc Execution Command\nDESCRIPTION: This command executes the timeconst.bc script using bc, measures the time taken, and discards the output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_6\n\nLANGUAGE: Shell Script\nCODE:\n```\ntime -p [bc] ../timeconst.bc > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Cross Compiling bc\nDESCRIPTION: This snippet demonstrates cross-compiling `bc` by specifying the host compiler using the `HOSTCC` environment variable. This is necessary when building for a different architecture than the host system.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nHOSTCC=\"/path/to/native/compiler\" ./configure.sh\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: irand() Function Testing\nDESCRIPTION: This snippet performs a series of tests on the `irand()` function with different inputs and seed values. It checks for boundary conditions, equality, and inequality, as well as verifies that the output of `irand()` stays within expected bounds. Several tests involve comparison against seed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nprint \"Exercising irand()...\\n\"\n\nscale = 256\n\npow = (maxrand() + 1) ^ 4\ns = 2^256 + 2^128 + (irand(pow) / pow)\nseed = s\nseed < s\n\ns = -459.125\nseed = s\nseed == -s\n\nirand(0)\nirand(1)\nseed == -s\nirand(maxrand() + 1) <= maxrand()\n\nfor (i = 0; i < 200; ++i) {\n\tirand(20) < 20\n}\n\nseed = 738\nseed != 738\n\ns = 2398@0625\nseed = s\nseed != s\n\npow = (maxrand() + 1) ^ 4\ns = 2^2560 + 2^128 + (irand(pow) / pow)\nseed = s\nseed < s\n\nb = 0\nm = maxrand() + 1\nn = m + 1\n\nfor (i = 0; !b && i < 100; ++i) {\n\tc = irand(n)\n\tb = (c != 0 && c != m)\n\tif (c >= n) print \"irand() result is too large.\\n\"\n}\n\nb\n\n```\n\n----------------------------------------\n\nTITLE: Bcl Seed Defines\nDESCRIPTION: Defines related to seeding the bcl pseudo-random number generator, defining the use of unsigned longs and the size.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#define BCL_SEED_ULONGS\n```\n\nLANGUAGE: c\nCODE:\n```\n#define BCL_SEED_SIZE\n```\n\n----------------------------------------\n\nTITLE: Loop with Assignment and Function Call in C\nDESCRIPTION: This snippet includes a for loop that iterates until 'i' is no longer less than 725. Inside the loop, 'i' is multiplied by 9, and the 'asciify' function is called with a value of 180. The result is assigned to both 'strse' and the first element of the array 'a'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/36.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfor (i*= 9; i <  725; ++i)strse=a[0] = asciify(180)\n```\n\n----------------------------------------\n\nTITLE: Looping and Printing Characters\nDESCRIPTION: This snippet iterates from 1 to 020 (octal 16) using a 'for' loop. Inside the loop, it attempts to print the character 'n' along with subsequent conditional blocks and empty print statements. The variable 'F' is used for initialization, and 'pryn' and 'tryn' are likely typos and their effects are unpredictable.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/07.txt#_snippet_0\n\nLANGUAGE: unknown\nCODE:\n```\nfor (q = F; i <=020; ++i)  #\ti\n{print \"n\"\\f\nif(6)if(6){3\n\\f}\n{pryn}\n\"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{tryn}\n{print \"\"\\f \"\"\\f}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n \"\"\\f}\n{prynn}\n{print \"\"\\f \"\"\\f}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n{print \"\"\\f \"\"\\f}\n{pryn}\n \"\"\\f}\n```\n\n----------------------------------------\n\nTITLE: Getting Stack Depth in dc\nDESCRIPTION: Pushes the current depth of the stack onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_23\n\nLANGUAGE: dc\nCODE:\n```\nz\n```\n\n----------------------------------------\n\nTITLE: Number Representation with Leading and Trailing Zeros\nDESCRIPTION: This snippet showcases various ways to represent the same number using leading and trailing zeros in both integer and decimal forms. It illustrates how precision can be affected by the placement of the decimal point and the use of zeros.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/decimal_results.txt#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\n11234567890\n1123456789.0\n112345678.90\n11234567.890\n1123456.7890\n112345.67890\n11234.567890\n1123.4567890\n112.34567890\n11.234567890\n1.1234567890\n.11234567890\n.011234567890\n.0011234567890\n.00011234567890\n.000011234567890\n.0000011234567890\n.00000011234567890\n.000000011234567890\n.0000000011234567890\n.00000000011234567890\n.000000000011234567890\n.0000000000011234567890\n```\n\n----------------------------------------\n\nTITLE: Bit Rotation Left (16-bit) Operation\nDESCRIPTION: Performs a bit rotation left operation on a 16-bit representation of the input. This rotates the bits of the input value to the left by a specified number of positions, wrapping the shifted bits around to the other end. `brol16` specifically handles 16-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_14\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(13946233938940740889, 12028823668264674112)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrol16(17689, 9024)\n```\n\n----------------------------------------\n\nTITLE: Macro Exit\nDESCRIPTION: During the execution of a macro, this command exits the current macro and the macro that executed it. If there are no macros or only one macro executing, dc exits.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_16\n\nLANGUAGE: dc\nCODE:\n```\nq\n```\n\n----------------------------------------\n\nTITLE: Configuring dc only build\nDESCRIPTION: Configures the build to build only dc and not bc. Using these options when dc is also disabled will result in an error.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -d\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --dc-only\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -B\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-bc\n```\n\n----------------------------------------\n\nTITLE: Simple bc Loop and Quit\nDESCRIPTION: This bc script demonstrates a basic for loop that iterates three times and then exits the bc interpreter using the `quit` command. The loop body is an empty statement `i;` which does nothing during each iteration. The `\\` character is used to escape the newline character after the loop, allowing it to be treated as a single command.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/line_loop_quit2.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\n3\nfor (i = 0; i < 3; ++i) i; \\\nquit\n```\n\n----------------------------------------\n\nTITLE: Maximum Input Base\nDESCRIPTION: This snippet displays the maximum input base allowed by the bc implementation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_24\n\nLANGUAGE: bc\nCODE:\n```\nmaxibase()\n```\n\n----------------------------------------\n\nTITLE: Modulo Operations with Scale and Floating-Point Numbers in bc\nDESCRIPTION: This snippet demonstrates modulo operations in bc when the scale is set to 0 and floating-point numbers are involved. Setting scale to 0 affects results of division and other operations involving decimal points. It provides examples of how these configurations affect the output of modulo calculations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/modulus.txt#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nscale = 0; -899510228 % -2448300078.40314\nscale = 0; -7424863 % -207.2609738667\nscale = 0; 3769798918 % 0.6\n```\n\n----------------------------------------\n\nTITLE: Defining Function n for Array Division (Reversed) in BC\nDESCRIPTION: This function `n(*y[], *x[])` calculates the division of the first element of `x[]` by the first element of `y[]`, similar to `m`, but with the arguments reversed. It returns `m(x[], y[])`. It calls `m` with the arguments swapped.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/13.txt#_snippet_5\n\nLANGUAGE: bc\nCODE:\n```\ndefine n(*y[], *x[]) {\n\treturn m(x[], y[])\n}\n```\n\n----------------------------------------\n\nTITLE: Preparing fuzzing environment\nDESCRIPTION: This sequence prepares the environment for fuzzing by first executing a script to configure and build `bc` with fuzzing optimizations.  Then, it loads a `tmuxp` configuration to start multiple AFL++ instances.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/fuzz_prep.sh\ntmuxp load tests/fuzzing/bc_afl.yaml\n```\n\n----------------------------------------\n\nTITLE: Extract Data Rows\nDESCRIPTION: This snippet extracts rows of data terminated by the \"/pR\" delimiter. The data format is unstructured, consisting of numerical values and special characters, which would necessitate further processing.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/divide.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n20k 0 1/pR\n0 321566/pR\n0 0.3984567238456/pR\n1 1/pR\n1 1287469297356/pR\n1 0.2395672438567234/pR\n1 237586239856.0293596728392360/pR\n1249687284356 3027949207835207/pR\n378617298617396719 35748521/pR\n9348576237845624358 0.9857829375461/pR\n35768293846193284 2374568947.045762839567823/pR\n_78987234567812345 876542837618936/pR\n_356789237555535468 0.3375273860984786903/pR\n_5203475364850390 435742903748307.70869378534043296404530458/pR\n_0.37861723347576903 7385770896/pR\n_0.399454682043962 0.34824389304/pR\n_0.6920414523873204 356489645223.76076045304879030/pR\n_35872917389671.7573280963748 73924708/pR\n_78375896314.4836709876983 0.78356798637817/pR\n_2374123896417.143789621437581 347821469423789.1473856783960/pR\n_896729350238549726 _34976289345762/pR\n_2374568293458762348596 _0.8792370647234987679/pR\n_237584692306721845726038 _21783910782374529637.978102738746189024761/pR\n_0.23457980123576298375682 _1375486293874612/pR\n_0.173897061862478951264 _0.8179327486017634987516298745/pR\n_0.9186739823576829347586 _0.235678293458756239846/pR\n_0.9375896183746982374568 _13784962873546.0928729395476283745/pR\n_2930754618923467.12323745862937465 _734869238465/pR\n_23745861923467.874675129834675 _0.23542357869124756/pR\n_3878923750692883.7238596702834756902 _7384192674957215364986723.9738461923487621983/pR\n1 0.00000000000000000000000000000000000000000002346728372937352457354204563027/pR\n239854711289345712 2891374 182 .2893 ///pR\n```\n\n----------------------------------------\n\nTITLE: Identifying the fix commit hash\nDESCRIPTION: This snippet provides the commit hash that fixes the bug. Applying this diff resolves the incorrect scale setting issue.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/project/issue10.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n299a4fd353\n```\n\n----------------------------------------\n\nTITLE: Disabling locale support (NLS)\nDESCRIPTION: Configures the build to disable locale support, using only English. NLS is automatically disabled on Windows or platforms without POSIX locale support.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_15\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -N\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-nls\n```\n\n----------------------------------------\n\nTITLE: Repeating Numerical Sequence\nDESCRIPTION: This sequence consists of repeating '1000...' strings.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/scripts/print2.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n100000000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000000\\\n00\n10000000000000000000000000000000000000000000000000000000000000000000\\\n000\n```\n\n----------------------------------------\n\nTITLE: bc Example Usage\nDESCRIPTION: This code snippet demonstrates a failing scenario in bc versions prior to 3.1.3, which would result in an error when evaluating an if statement provided via standard input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/NEWS.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\necho \"if (1 < 3) 1\" | bc\n```\n\n----------------------------------------\n\nTITLE: Setting Default Configuration Option to ON - Shell\nDESCRIPTION: This command uses the configure.sh script to set the default value of a specified configuration option to 'on'. It is used to enable features or behaviors by default when bc or dc is installed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_18\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -s bc.banner\n./configure.sh --set-default-on=bc.banner\n```\n\n----------------------------------------\n\nTITLE: Enabling Internal History support\nDESCRIPTION: Configures the build to enable internal history implementation with no dependencies. Useful when a predefined build type is used.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_14\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -i\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --enable-internal-history\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (8-bit) Example\nDESCRIPTION: Demonstrates the bitwise modulo operation (`bmod8`) on an 8-bit integer. The operation returns the remainder after dividing the input by 2^8.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_111\n\nLANGUAGE: N/A\nCODE:\n```\nbmod8(3708754108241877138)\n```\n\n----------------------------------------\n\nTITLE: Integer Declaration in C\nDESCRIPTION: This snippet represents a simple integer declaration or type casting in a C-like language. It suggests a possible attempt to cast the value 1 to an integer type. No external dependencies are required.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/lib21.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint(1)\n```\n\n----------------------------------------\n\nTITLE: Multiplication with Negative Numbers\nDESCRIPTION: Examples of multiplication involving negative numbers, showcasing correct sign handling.  Includes integer and decimal variations.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/multiply.txt#_snippet_3\n\nLANGUAGE: NA\nCODE:\n```\n-1 * 1\n-1 * 2\n1 * -1\n2 * -1\n-1 * -1\n-1 * -2\n78893457 * -34876238956\n235678324957634 * -0.2349578349672389576\n-12849567821934 * 12738462937681\n1274861293467.927843682937462 * -28935678239\n2936077239872.12937462836 * -0.012842357682435762\n2387692387566.2378569237546 * -272189345628.123875629835876\n0.012348629356782835962 * -23487692356\n0.4768349567348675934 * -0.23756834576934857638495\n0.98748395367485962735486 * -4675839462354867.376834956738456\n-321784627934586 * -235762378596\n-32578623567892356 * -0.32567384579638456\n-35768232346876 * -2348672935602387620.28375682349576237856\n-0.2356728394765234 * -238759624356978\n-0.2345768212346780 * -0.235768124697074385948943532045\n-0.370873860736785306278630 * -7835678398607.7086378076867096270\n-78365713707.7089637863786730 * -738580798679306780\n-73867038956790490258249 * -0.7379862716391723672803679\n-378621971598721837710387 * -98465373878350798.09743896037963078560\n```\n\n----------------------------------------\n\nTITLE: Bitwise Rotate Left (64-bit) example\nDESCRIPTION: Demonstrates the bitwise rotate left operation on a 64-bit number with a rotation amount.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_16\n\nLANGUAGE: N/A\nCODE:\n```\nbrol64(13946233938940740889, 12028823668264674112)\n```\n\n----------------------------------------\n\nTITLE: Bit Modification (16-bit) Operation\nDESCRIPTION: Performs a bit modification operation on a 16-bit representation of the input value. This function likely modifies the bit value based on an internal algorithm. `bmod16` operates on a 16-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_22\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(17689)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Equal)\nDESCRIPTION: Pops two numbers. If the first is not equal to the second, the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_13\n\nLANGUAGE: dc\nCODE:\n```\n!=r\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution with '!<', 'e' in dc(1) (Non-Portable)\nDESCRIPTION: This snippet explains the '!<r es' command in dc(1) that conditionally executes one of two registers based on a 'not less than' (greater than or equal to) comparison. The command pops two numbers from the stack. If the first number is not less than the second, the contents of register 'r' are executed; otherwise, the contents of register 's' are executed. If either value is not a number, it raises an error and resets. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_10\n\nLANGUAGE: dc\nCODE:\n```\n!<r es\n```\n\n----------------------------------------\n\nTITLE: Floating Point Number (Negative Exponent)\nDESCRIPTION: This snippet shows a floating point number with a negative exponent in bc.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_20\n\nLANGUAGE: bc\nCODE:\n```\n9.892108e-20\n```\n\n----------------------------------------\n\nTITLE: Defining undefined macro\nDESCRIPTION: This snippet defines an undefined macro named `a` in C++. It takes two arrays, `t[]`, as input parameters, but its body is empty, rendering its functionality undefined. This type of macro definition can be used as a compile-time flag or placeholder for future implementation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/39.txt#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ndefine a(*t[], t[]) {}\n```\n\n----------------------------------------\n\nTITLE: Macro Definition\nDESCRIPTION: This code snippet defines a simple macro named 'x(x)' that takes a single argument and returns it. This is a preprocessor directive that substitutes the macro with its definition during compilation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/18.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ndefine x(x) {\n\treturn x\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Numerical Strings with 'pR' Suffix\nDESCRIPTION: This snippet showcases various numerical string formats, including integers, decimals, and combinations of both, all ending with the 'pR' suffix. It tests how a parser handles different representations of numbers with a custom suffix.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/decimal.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n0pR\n0.0pR\n.0000pR\n000000000000000000000000.00000000000000000000000pR\n000000000000000000000000000135482346782356pR\n000000000000000000000000002pR\n1pR\n11pR\n123pR\n7505pR\n1023468723275435238491972521917846pR\n4343472432431705867392073517038270398027352709027389273920739037937960379637893607893607893670530278200795207952702873892786172916728961783907893607418973587857386079679267926737520730925372983782793652793pR\n_1pR\n_203pR\n_57pR\n_18586pR\n_31378682943772818461924738352952347258pR\n_823945628745673589495067238723986520375698237620834674509627345273096287563846592384526349872634895763257893467523987578690283762897568459072348758071071087813501875908127359018715023841710239872301387278pR\n.123521346523546pR\n0.1245923756273856pR\n_.1024678456387pR\n_0.8735863475634587pR\n4.0pR\n_6.0pR\n234237468293576.000000000000000000000000000000pR\n23987623568943567.00000000000000000005677834650000000000000pR\n23856934568940675.000000000000000435676782300000000000000456784pR\n77567648698496.000000000000000000587674750000000000458563800000000000000pR\n2348672354968723.2374823546000000000003256987394502346892435623870000000034578pR\n_2354768.000000000000000000000000000000000000pR\n_96739874567.000000000347683456pR\n_3764568345.000000000004573845000000347683460pR\n_356784356.934568495770004586495678300000000pR\n74325437345273852773827101738273127312738521733017537073520735207307570358738257390761276072160719802671980267018728630178.7082681027680521760217867841276127681270867827821768173178207830710978017738178678012767377058785378278207385237085237803278203782037237582795870pR\n_756752732785273851273728537852738257837283678965738527385272983678372867327835672967385278372637862738627836279863782673862783670.71738178361738718367186378610738617836781603760178367018603760178107735278372832783728367826738627836278378260736270367362073867097307925pR\n9812734012837410982345719208345712908357412903587192048571920458712.23957182459817249058172945781pR\n```\n\n----------------------------------------\n\nTITLE: Power Calculation Test Command\nDESCRIPTION: This command calculates 1234567890 raised to the power of 100000 using bc, measures the time taken, and discards the output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_4\n\nLANGUAGE: Shell Script\nCODE:\n```\nprintf '1234567890^100000; halt\\n' | time -p [bc] -q > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Manual Page Header\nDESCRIPTION: Defines the header section of a manual page, including the command name (DC), section (1), date (August 2024), author (Gavin D. Howard), and manual title (General Commands Manual).\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/header_dc.txt#_snippet_0\n\nLANGUAGE: troff\nCODE:\n```\n.TH \"DC\" \"1\" \"August 2024\" \"Gavin D. Howard\" \"General Commands Manual\"\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise Modulo (64-bit) Operation\nDESCRIPTION: This snippet executes a bitwise modulo operation on a 64-bit number employing the 'bmod64' function.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_76\n\nLANGUAGE: Text\nCODE:\n```\nbmod64(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Testing Bitwise NOT (16-bit) Operation\nDESCRIPTION: This code snippet shows the bitwise NOT operation being applied to a 16-bit value with 'bnot16'. The function inverts all bits of the given 64-bit number, treating it as a 16-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_32\n\nLANGUAGE: Text\nCODE:\n```\nbnot16(2384001591844672901)\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Greater Than)\nDESCRIPTION: Pops two numbers. If the first is greater than the second, the contents of register *r* are executed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n>r\n```\n\n----------------------------------------\n\nTITLE: Building bc and dc with MSBuild on Windows\nDESCRIPTION: This command builds the `bc` and `dc` executables using MSBuild on Windows. It requires Visual Studio with MSBuild and specifies the configuration (Debug or Release). The output executables are located in the `vs/bin` directory.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmsbuild -property:Configuration=<config> vs/bc.sln\n```\n\n----------------------------------------\n\nTITLE: Building bc and dc with debug configuration on POSIX\nDESCRIPTION: These commands configure and build `bc` and `dc` on a POSIX-compatible system with debugging symbols. The `-g` option enables the generation of debugging information during compilation.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -g\nmake\n```\n\n----------------------------------------\n\nTITLE: String Creation\nDESCRIPTION: Creates a string containing the specified characters and pushes it onto the stack. Brackets within the string must be balanced, and backslashes can be used to escape special characters.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/HN.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[_characters_]\n```\n\n----------------------------------------\n\nTITLE: Push Leading Zero Setting\nDESCRIPTION: Pushes 0 onto the stack if the leading zero setting has not been enabled with the -z or --leading-zeroes options, non-zero otherwise.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_30\n\nLANGUAGE: dc\nCODE:\n```\ngz\n```\n\n----------------------------------------\n\nTITLE: Disabling extra math features\nDESCRIPTION: Configures the build to disable extra operators, scientific notation, engineering notation, and the pseudo-random number generator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -E\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-extra-math\n```\n\n----------------------------------------\n\nTITLE: Bitwise MOD (16-bit) Operation\nDESCRIPTION: Demonstrates the bitwise MOD operation (bmod16) on a 16-bit integer.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_162\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(5205211806348135630)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbmod16(52430)\n```\n\n----------------------------------------\n\nTITLE: Output Base Assignment (Binary)\nDESCRIPTION: This snippet demonstrates assigning 1 to the output base (obase) in bc. Since obase must be greater than 1, this command is invalid and will likely result in an error.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_22\n\nLANGUAGE: bc\nCODE:\n```\nobase = 1\n```\n\n----------------------------------------\n\nTITLE: Obfuscated bc Calculation\nDESCRIPTION: This bc code snippet contains nested loops and mathematical operations using single-character variables and function names. The purpose of the computation is unclear due to the obfuscation, but it involves square roots, subtractions, and potentially conditional logic. The code initializes a loop counter 'i' and contains nested expressions using functions like ssqrt(), p(), and s().\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/03.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nfor (i = 0; ; )\nfor (i = 0; ;(ssqrt()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(ssssq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(sq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(t()-p(sstp(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-v(qrt(ssqrt()-p(ssqrt()-s(ssqrt()-p(ssssq(ssqrt()-p(ssq(ssqrt()-p(t()-sst()-prt()-s(ssqrt()-p(q(ssqrt()-p(ssqrt()-sst()-ssqrt()-t(ss(s()-p(srt()-s(ssqrt()-p(s(ssqrtt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(qr (itt()-p(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(t()-p(sstp(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(qr (itt()-p(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(osqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(ssqrt()-sstfor (itt()-p(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(sstss(sssq(ssqrt()-p(ssqrt()-sst()-prt()-s(ssqrt()-p(q(ssqrt()-ssqrt(qrt()-p(s()-p(srt(s(ssqrt()-p(q(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(ssqrt()-sst()-p(ssqrt()-ssq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s-t()-s(ssurt()-p(sstss(ssqrt()-p(qr (itt()-p(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(osqrt()-p(sstsq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(ssqrt()-sstfor (itt()-p(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(sstss(sssq(ssqrt()-p(ssqrt()-sst()-prt()-s(ssqrt()-p(q(ssqrt()-ssqrt(qrt()-p(s()-p(srt(s(ssqrt()-p(q(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s(ssqrt()-p(ssqrt()-sst()-p(ssqrt()-ssq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s-p(ssqrt()-sst()-p(qrt()-p(s(st()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(ssssq(ssqrt()-p(ssqrt()-sst()-p(qrt()-p(s()-p(srt()-s(ssqrt()-p(sstss(ssqrt()-p(ssssq(ssqrt()-p(ssqrt()-sst()-p(qrtrrrrr()-p(s(ssqrt()-p(ssqrt()-sst()-p(ssqrt(qrt(ssqrt()-p(ssqrt()-s(ssqrt()-p(ssssq(ssqrt()-p(ssq(ssqrt()-p(ssqrt()-sst()-prt()-s(ssqrt()-p(q(ssqrt()-p(ssqrt()-sst()-ssqrt()-t(ss(s()-p(srt()-s(ssqrt()-p(s(ssqrtt()-p()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))()%t(ss(s()-p(srt()))))))))))))))))))))))t()Cp(q(s(ssqrt()-t(ss(ssqrt()-p(srt()-s(ssqrt()-p(srt()-p(ssqrt()-sst=)-p(qrt()-p(s(t()-p(qrt()-p(s(ssqrt()-p(ssqrt()-sst()-p(ssqrt(qrt(ssqrt()-p(ssqrt()-s(ssqrt()-p(ssts*=!dd_ed0;#239\n```\n\n----------------------------------------\n\nTITLE: Testing dc Only with Make\nDESCRIPTION: This command executes the test suite specifically for the `dc` calculator. It utilizes the `make` utility to target the `test_dc` target.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_29\n\nLANGUAGE: makefile\nCODE:\n```\nmake test_dc\n```\n\n----------------------------------------\n\nTITLE: For Loop with No Initialization and Increment\nDESCRIPTION: This snippet shows a for loop with no condition or initialization, but has an increment expression.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_17\n\nLANGUAGE: bc\nCODE:\n```\nfor (;; ++x) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Function Definition in BC\nDESCRIPTION: This snippet defines a function named 'a' in BC. The function takes one argument 'x', prints a string representation of the function call with its argument, and appends a newline character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs2/line_by_line2.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine a (x) {\n\tprint \"a(\", x, \")\\n\"\n}\n```\n\n----------------------------------------\n\nTITLE: Exercising irand() Function\nDESCRIPTION: This section tests the `irand()` function, likely a custom implementation of a random integer function, by repeatedly calling it. The observed output sequence of '1' and '0' values hints at a possible bias or issues with the distribution of the random numbers. These values should be checked for equidistribution and appropriate period.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand_results.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n1\n1\n0\n0\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n```\n\n----------------------------------------\n\nTITLE: Bitwise Modulo (64-bit) example\nDESCRIPTION: Demonstrates the bitwise modulo operation on a 64-bit number.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/bitfuncs.txt#_snippet_24\n\nLANGUAGE: N/A\nCODE:\n```\nbmod64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Create String\nDESCRIPTION: Creates a string containing the specified characters and pushes it onto the stack. Brackets within the string must be balanced or escaped. Backslashes escape the following character.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n[characters]\n```\n\n----------------------------------------\n\nTITLE: Check if Number\nDESCRIPTION: Pops a value. Pushes 1 onto the stack if the value is a number, otherwise pushes 0 (if it's a string). This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_21\n\nLANGUAGE: dc\nCODE:\n```\nu\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (8-bit) Operation\nDESCRIPTION: Performs a bitwise NOT operation on an 8-bit representation of the input. This flips each bit: 0 becomes 1, and 1 becomes 0. The function `bnot8` operates specifically on an 8-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_5\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbnot8(25)\n```\n\n----------------------------------------\n\nTITLE: For Loop with No Initialization and Condition\nDESCRIPTION: This snippet shows a for loop with a condition and increment, but no initialization.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_16\n\nLANGUAGE: bc\nCODE:\n```\nfor (; x<0;) { y += 1; }\n```\n\n----------------------------------------\n\nTITLE: Bitwise NOT (64-bit) Operation\nDESCRIPTION: Performs a bitwise NOT operation on a 64-bit representation of the input. This flips each bit: 0 becomes 1, and 1 becomes 0. The function `bnot64` operates specifically on a 64-bit context.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_8\n\nLANGUAGE: N/A\nCODE:\n```\nbnot64(13946233938940740889)\n```\n\n----------------------------------------\n\nTITLE: Defining printarray function in bc\nDESCRIPTION: This function `printarray` takes an array `a[]` and its length `len` as input and iterates through the array, printing each element. It utilizes an auto variable `i` for iteration. Note there's a typo as `hen` should be `len`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/34.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\ndefine printarray(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < hen; ++i) {\n\t\ta[i]\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition with String\nDESCRIPTION: This snippet shows a function definition with a string inside. In bc, this does nothing. It defines a function `a` that takes an argument `e` and contains a string \"stuff\" that is ignored.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/posix_errors.txt#_snippet_23\n\nLANGUAGE: bc\nCODE:\n```\ndefine void a(e) { \"stuff\" }\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Expressions in BC\nDESCRIPTION: Demonstrates the use of parentheses to group expressions and enforce operator precedence. No dependencies.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/misc1.txt#_snippet_8\n\nLANGUAGE: BC\nCODE:\n```\n(x)\n(x[0])\n(scale)\n(ibase)\n(obase)\n(x ( 7 ))\n(x + x( 8 ))\n(x - x[0])\n(321 * x)\n(2 ^ x[0])\n(x++)\n(--x)\n(x += 9)\n(length(2381))\n(sqrt(9))\n(scale(238.1))\n(scale = 0)\n(x = 10)\n(x += 100)\n(x -= 10)\n(x *= 10)\n(x /= 100)\n(x ^= 10)\n(x = sqrt(x))\n(x[1 - 1])\n```\n\n----------------------------------------\n\nTITLE: Configuring bc with CC and CFLAGS\nDESCRIPTION: This snippet demonstrates how to configure the `bc` build system using custom compiler options (CC) and flags (CFLAGS). It shows how to pass optimization flags like `-O3` and target-specific flags like `-march=native` to the compiler during the configuration process.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/NEWS.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nCC=\"gcc -O3 -march=native\" ./configure.sh\n```\n\n----------------------------------------\n\nTITLE: Define Array Square Function BC\nDESCRIPTION: Defines a function `a2` that iterates through an array `a` of length `len`, squares each element, and then calls the `printarray` function to print the (modified) array.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/37.txt#_snippet_1\n\nLANGUAGE: BC\nCODE:\n```\ndefine a2(a[], len) {\n\n\tauto i\n\n\tfor (i = 0; i < len; ++i) {\n\t\ta[i] = a[i] * a[i]\n\t}\n\n\tprintarray(a[], len)\n}\n```\n\n----------------------------------------\n\nTITLE: Bit Reversal (8-bit) Operation\nDESCRIPTION: Performs a bit reversal operation on an 8-bit representation of the input. This reverses the order of the bits in the 8-bit value.  The function `brev8` specifically operates on 8-bit values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/bitfuncs.txt#_snippet_9\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(13946233938940740889)\n```\n\nLANGUAGE: N/A\nCODE:\n```\nbrev8(25)\n```\n\n----------------------------------------\n\nTITLE: Setting seed in bc\nDESCRIPTION: Example of setting seed using seed = seed, to ensure that if the function does not affect the sequence of pseudo-random numbers of its parents, but wants to use the same seed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/N.1.md#_snippet_2\n\nLANGUAGE: bc\nCODE:\n```\nseed = seed\n```\n\n----------------------------------------\n\nTITLE: Getting Line Length Setting in dc\nDESCRIPTION: Pushes the line length set by DC_LINE_LENGTH onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_28\n\nLANGUAGE: dc\nCODE:\n```\ngl\n```\n\n----------------------------------------\n\nTITLE: Exiting the bc Interpreter\nDESCRIPTION: This command terminates the bc interpreter. After this command is executed, the bc session will end.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line2.txt#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\nquit\n```\n\n----------------------------------------\n\nTITLE: Building bcl library with MSBuild\nDESCRIPTION: This snippet shows how to build the `bcl` library using MSBuild from the command line. It specifies the configuration (Debug, ReleaseMD, or ReleaseMT) as a property. This requires Visual Studio's MSBuild tools to be available in the system's PATH.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_5\n\nLANGUAGE: msbuild\nCODE:\n```\nmsbuild -property:Configuration=<config> vs/bcl.sln\n```\n\n----------------------------------------\n\nTITLE: Unidentified Arithmetic Sequence\nDESCRIPTION: This code snippet shows a sequence of arithmetic operations involving the addition of 'p' to increasing numbers. This pattern suggests the manipulation of memory addresses, stack offsets, or some other sequential data structure. The meaning of 'p' remains unclear without further information.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/26.txt#_snippet_1\n\nLANGUAGE: unknown\nCODE:\n```\n1 2+p+p\n3+p\n4+p\n5+p\n6+p\n7+p\n8+p\n9+p\n10+p\n11+p\n12+p\n13+p\n14+p\n15+p\n16+p\n17+p\n18+p\n19+p\n20+p\n21+0+p\n71+o\n72+p\n73+p\n74+p\n75+p\n22+p\n23+p\n24+p\n25+p\n26+p\n27+p\n28+p\n29+p\n30+p\n31+p\n32+p\n33+p\n34+p\n35+p\n36+p\n37+p\n38+p\n39+p\n40+1+p\n42+p\n43+p\n44+p\n45+p\n46+p\n47+p\n48+p\n49+p\n50+p\n51+p\n52+p\n53+p\n54+p\n55+p\n56+p\n57+p\n58+p\n59+p\n60+p\n61+p\n```\n\n----------------------------------------\n\nTITLE: Unspecified Code Snippet 2\nDESCRIPTION: This snippet contains a series of assignments and conditional checks, involving variables like 'i', 'se', 'ase', 's', and 'scale'. The purpose seems related to setting values to the scale variable but again more context is needed to assess the functionality.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/01.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\na\ns(scal[ ba])\ns(1)\nsd= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscalaaaaaaaaaaaaa^aaaaaaaaaaaaaaa20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=asj-=se-=as-=se-=axse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=as=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscales=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nsd= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na==se-=as+=ase-=se8=as-=se-=a(1)\ns ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=as-=ase-=se-=se4=ase-=se-=as-=e-=as=ae-=a(1)\nsc= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nsd= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase = 20\na(0)\na=i-=se-=ase-=se-=ase-=s-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=a_=as-=ase-=se-=se4=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as*=e-=as=aaaaaaaaaaaaaaaaaaaaaaa^aaaaaaaaaaaaaaa20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=axse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=as=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==sse-=ase-=s-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=as-=ase-=se-=se4=ase-=se-=as-=e-=as=ase0=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=as-=ase-=se-=as-=as0\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=aaa^aaaaaaaaaaaaaaa20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=axse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=as=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscales=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nsd= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nde ==se-=a(1)\nscale = 20\na(0)\na==se-=as-=ase-=se8=as-=se-=a(1)\ns ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=as-=ase-=se-=se4=ase-=se-=as-=e-=as=ae-=a(1)\nsc= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=se-=xse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nsd= 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase = 20\na(0)\na1i-=se-=ase-=se-=ase-=s-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=c-=a_=as-se-=se-=se4=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=asse-=as-=e-=as=aaaaaaaaaaaaaaaaaaaaaaa^aaaaaaaaaaaaaaa20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=axse!=e-=ase-=i-=se-=ase-=se-=se-=ase-=se-=as-=e-=as=ase-=se-=as-=as=i-=se-=ase-=-=se-=ascccc-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=s-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nscale = 20\na(0)\na=i-=se-=ase-=se-=ase-=i-=s-=se-=xse!=e-=as=as-=ase-=se-=se4=ase-=se-=as-=e-=as=ase-=se-=as-=ase-=se-=as-=se-=a(1)\nscscale ==se-=a(1)\nsBale = 20\na\n```\n\n----------------------------------------\n\nTITLE: DC Script Snippet 1\nDESCRIPTION: A DC script snippet involving stack operations and variable assignments using the 's' command. It seems to store values into registers like Nx, li, and Gx, and then performs some operation based on these values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/09.txt#_snippet_0\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]zsWx[li]zsGx[Nx]0sm[]zsdc\n```\n\n----------------------------------------\n\nTITLE: Large Number Division BC\nDESCRIPTION: Shows the calculation of dividing extremely large numbers within the BC calculator. The examples showcase the handling of substantial integer values. No dependencies, suitable for direct execution in BC.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/divide.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\n1249687284356 / 3027949207835207\n3496723859067234 / 298375462837546928347623059375486\n-47589634875689345 / 37869235\n-6324758963 / 237854962\n```\n\n----------------------------------------\n\nTITLE: Trailing Data and Repetition\nDESCRIPTION: This snippet illustrates a continuation of the arithmetic sequence from before, followed by more seemingly arbitrary text data. There is also noticeable repetition of certain number + 'p' patterns.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/26.txt#_snippet_2\n\nLANGUAGE: unknown\nCODE:\n```\n62+p\n63+p\n64+p\n65+p\n66+p\n67\n73+p\n74+p\n75+p\n76+p\n77+p\n78+p\n79+p\n80+p\n1+p\n82+p\n83+p\n84+p\n85+p86+p\n87+p\n88+p\n89+p\n90+p\n91+p\n92+p\n93+p\n94+p\n95+p\n96+p\n97+p\n98+p\n99+p\n100+p\n101+p\n102+p\n103+p\n104+p\n105+p\n106+p\n107+p\n108+p\n1093+p2+p\n```\n\n----------------------------------------\n\nTITLE: Enabling Readline history support\nDESCRIPTION: Configures the build to enable readline support for history, providing vi-like keybindings and other features. Ignored if history is disabled.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_13\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh -r\n```\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --enable-readline\n```\n\n----------------------------------------\n\nTITLE: DC Script with Variable Assignment and Conditional\nDESCRIPTION: This DC script initializes 'Nx', interacts with stack and variables 'li', 'Gx'. It uses 'dc' command at end and appears to be incomplete.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/10.txt#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]x[li]zsGx[Nx]0sm[]zsdc\n```\n\n----------------------------------------\n\nTITLE: DC Script with Variable Assignment and Conditional\nDESCRIPTION: This DC script initializes variable 'Nx', performs stack manipulation, variable assignments related to 'Wx', 'li', 'Px' and 'Gx'. Then a `dc` command is executed. It appears to calculate some value.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/10.txt#_snippet_3\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0sm[]zsWx[li]zsPx[Nxx]0sm[]x[li]zsGx[Nx]0sm[]zsdc\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Number Examples\nDESCRIPTION: This snippet demonstrates floating-point numbers, including positive, negative, and decimal values with varying precision. These are represented as plain text. It includes standard decimal notation and examples with multiple decimal places.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/decimal_results.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n.123521346523546\n.1245923756273856\n-.1024678456387\n-.8735863475634587\n4.0\n-6.0\n234237468293576.000000000000000000000000000000\n23987623568943567.00000000000000000005677834650000000000000\n23856934568940675.000000000000000435676782300000000000000456784\n77567648698496.00000000000000000058767475000000000045856380000000000\\\n0000\n2348672354968723.237482354600000000000325698739450234689243562387000\\\n0000034578\n-2354768.000000000000000000000000000000000000\n-96739874567.000000000347683456\n-3764568345.00000000004573845000000347683460\n-356784356.934568495770004586495678300000000\n74325437345273852773827101738273127312738521733017537073520735207307\\\n570358738257390761276072160719802671980267018728630178.7082681027680\\\n52176021786784127612768127086782782176817317820783071097801773817867\\\n8012767377058785378278207385237085237803278203782037237582795870\n-7567527327852738512737285378527382578372836789657385273852729836783\\\n72867327835672967385278372637862738627836279863782673862783670.71738\\\n17836173871836718637861073861783678160376017836701860376017810773527\\\n8372832783728367826738627836278378260736270367362073867097307925\n9812734012837410982345719208345712908357412903587192048571920458712.\\\n23957182459817249058172945781\n1891702357289370172037.90287102837\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (=r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is equal to the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_11\n\nLANGUAGE: dc\nCODE:\n```\n=r\n```\n\n----------------------------------------\n\nTITLE: Example Data Point\nDESCRIPTION: This snippet is an example of a single data point from the file. It shows a numerical value and a label separated by \"^pR\".  This structure might represent a feature value and its class label.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/power.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n1 0^pR\n```\n\n----------------------------------------\n\nTITLE: BC Program Input Data\nDESCRIPTION: These lines represent input data for a BC program, possibly invoking a function 'l' with various numerical arguments. The data includes positive, negative, and decimal values, used for testing or calculations within the program.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/log.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\nl(0)\nl(0.5)\nl(1)\nl(1.5)\nl(1.74)\nl(2)\nl(3.2345)\nl(5.283957)\nl(13.23857)\nl(100)\nl(283.238957)\nl(-0.5)\nl(-1)\nl(-1.5)\nl(-1.74)\nl(-2)\nl(-3.2345)\nl(-5.283957)\nl(-13.23857)\nl(-100)\nl(-283.238957)\nl(10430710.3325472917)\n```\n\n----------------------------------------\n\nTITLE: DC Script with Conditional Loop and Variable Assignment\nDESCRIPTION: This DC script initializes variable 'Nx', assigns value to '_@', manipulates the stack using variables 'Wx', 'li', and '^x'. The script also implements a conditional loop using `lili100>Nx`, variable assignment and execution of stored macros 'x'. It appears to implement a complex algorithm with loop.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/10.txt#_snippet_2\n\nLANGUAGE: dc\nCODE:\n```\n0sm[Nx]0s_[]zsWx[li]zs^x[lili100>Nx]0sm[]zsWx[liNx]zsxx[li;rlilix]\nx[liNx]zsxx\n```\n\n----------------------------------------\n\nTITLE: Array Initialization and Summation\nDESCRIPTION: This code snippet initializes two arrays, `a` and `b`, with random numbers generated by the `rand()` and `irand()` functions, respectively. It also calculates the sum of the elements in array `a`.  The `irand()` function uses the cumulative sum to generate its values.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/rand.txt#_snippet_0\n\nLANGUAGE: bc\nCODE:\n```\nprint \"Gathering array...\\n\"\n\ns = seed\n\nsum = 0\n\nfor (i = 0; i < 100; ++i) {\n\ta[i] = rand()\n\tsum += a[i]\n\tb[i] = irand(sum)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operation\nDESCRIPTION: This snippet performs a simple addition of 1+1. It demonstrates a basic arithmetic operation in a shell-like environment.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/line_by_line1.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n1+1\n```\n\n----------------------------------------\n\nTITLE: Division Test Script\nDESCRIPTION: This shell script is used to benchmark the division operation in bc. It takes the bc executable, the script name (divide.bc), and some parameters as input.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_3\n\nLANGUAGE: Shell Script\nCODE:\n```\ntests/script.sh bc divide.bc 1 0 1 1 [bc]\n```\n\n----------------------------------------\n\nTITLE: BclNumber Struct Definition\nDESCRIPTION: This code snippet defines the structure of `BclNumber`, which represents an arbitrary-precision number in the bcl library. It contains a single member `i` of type `size_t`.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct { size_t i; } BclNumber;\n```\n\n----------------------------------------\n\nTITLE: Setting EXECPREFIX for bc installation\nDESCRIPTION: This command sets the `EXECPREFIX` environment variable to modify the installation path of the `bc` and `dc` executables. It allows prepending a custom string to the names of the installed binaries.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nEXECPREFIX=<some_prefix> ./configure.sh\n```\n\n----------------------------------------\n\nTITLE: bc Script Stack Setup\nDESCRIPTION: This bc script snippet pushes the numbers 1 and 2 onto the stack. These values are likely intended for use in later calculations within the script.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/dc/errors/25.txt#_snippet_1\n\nLANGUAGE: bc\nCODE:\n```\n1 2\n```\n\n----------------------------------------\n\nTITLE: Basic For Loop in C\nDESCRIPTION: This code snippet demonstrates a basic 'for' loop in C-style syntax. It initializes a loop counter 'i' to 0, continues as long as the integer 29834 is considered true (non-zero), and increments 'i' after each iteration. The body of the loop simply references the variable 'i'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/errors/15.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nfor (i = 0; int32(29834); ++i) {\n\ti\n}\n```\n\n----------------------------------------\n\nTITLE: Building bc with MSBuild\nDESCRIPTION: This snippet shows how to build `bc` using MSBuild from the command line. It specifies the configuration (Debug or Release) as a property.  This requires Visual Studio's MSBuild tools to be available in the system's PATH.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/build.md#_snippet_4\n\nLANGUAGE: msbuild\nCODE:\n```\nmsbuild -property:Configuration=<config> vs/bc.sln\n```\n\n----------------------------------------\n\nTITLE: ASCII Character Conversion in dc(1)\nDESCRIPTION: This snippet explains the 'a' command in dc(1) that converts a number or string to an ASCII character string. If the value on top of the stack is a number, the truncated absolute value mod 256 determines the ASCII character. If the value on top of the stack is a string, the new string contains the first character of the original string. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/H.1.md#_snippet_1\n\nLANGUAGE: dc\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Brainfuck Arithmetic Logic\nDESCRIPTION: This Brainfuck code snippet appears to perform arithmetic operations using a loop that adds the value in one cell to another based on a conditional check.  The '>x' likely acts as a conditional jump. No external dependencies are listed.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/25.txt#_snippet_0\n\nLANGUAGE: Brainfuck\nCODE:\n```\ns0[l0d:0l01;0d:0l01;0pRl01+s0l010>x]dsxx0sx0s0\n```\n\n----------------------------------------\n\nTITLE: BC Script Termination\nDESCRIPTION: This snippet shows how to terminate a BC script using the 'quit' command.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/line_by_line1.txt#_snippet_2\n\nLANGUAGE: BC\nCODE:\n```\nquit\n```\n\n----------------------------------------\n\nTITLE: Installing bc and dc on POSIX\nDESCRIPTION: This command installs the `bc` and `dc` executables to the system. By default, they are installed in `/usr/local`. The installation location can be changed using the `PREFIX` environment variable or the `--prefix` option during configuration.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuration Variable for Karatsuba Multiplication - BC_NUM_KARATSUBA_LEN\nDESCRIPTION: Introduced the BC_NUM_KARATSUBA_LEN configuration variable to switch between Karatsuba and O(n^2) multiplication algorithms. This allows users to optimize performance based on their specific needs and hardware.  The optimal value can be determined using the karatsuba.py script and configured via 'make'.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/NEWS.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Bitwise Right Shift with Decimal Value 3\nDESCRIPTION: Demonstrates bitwise right shift operations with the decimal value 100.1.  The number of bits to shift ranges from 0 to 19. It's necessary to understand how the BC language will handle floating point numbers with bitwise operations, as this is atypical.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/bc/shift.txt#_snippet_12\n\nLANGUAGE: bc\nCODE:\n```\n100.1 >> 0\n```\n\n----------------------------------------\n\nTITLE: test.bc Execution Command\nDESCRIPTION: This command executes the test.bc script using bc, measures the time taken, and discards the output.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/benchmarks.md#_snippet_8\n\nLANGUAGE: Shell Script\nCODE:\n```\ntime -p [bc] ../test.bc > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Building only dc on POSIX\nDESCRIPTION: These commands configure and build only the `dc` executable on a POSIX-compatible system. The `--disable-bc` option prevents the `bc` executable from being built.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n./configure.sh --disable-bc\nmake\n```\n\n----------------------------------------\n\nTITLE: BclBigDig Type Definition\nDESCRIPTION: Defines `BclBigDig` as an unsigned long.  It is used for large digit representation or seeding the random number generator.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bcl.3.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\ntypedef unsigned long BclBigDig;\n```\n\n----------------------------------------\n\nTITLE: Continuing fuzzing with tmuxp\nDESCRIPTION: This command loads a tmuxp configuration file that continues a previous fuzzing session. The `bc_afl_continue.yaml` file contains the configuration details for resuming AFL++ fuzzing on bc and dc. This is used when crashes reported by AFL++ are invalid.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/development.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ntmuxp load tests/fuzzing/bc_afl_continue.yaml\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic in BC\nDESCRIPTION: This snippet shows a simple arithmetic addition operation in BC. It adds 1 and 1.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/bc_inputs1/line_by_line1.txt#_snippet_0\n\nLANGUAGE: BC\nCODE:\n```\n1+1\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution (Not Greater Than Else)\nDESCRIPTION: Pops two numbers. If the first is not greater than the second (less than or equal to), the contents of register *r* are executed; otherwise, the contents of register *s* are executed. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_6\n\nLANGUAGE: dc\nCODE:\n```\n!>res\n```\n\n----------------------------------------\n\nTITLE: Push Register Stack Depth\nDESCRIPTION: Pushes the current stack depth of the register *r* onto the main stack.  This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_24\n\nLANGUAGE: dc\nCODE:\n```\nyr\n```\n\n----------------------------------------\n\nTITLE: Push Execution Stack Depth\nDESCRIPTION: Pushes the depth of the execution stack onto the stack. This allows the script to exit dc(1) with the Q command. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_18\n\nLANGUAGE: dc\nCODE:\n```\n,\n```\n\n----------------------------------------\n\nTITLE: Block Comment Syntax in bc(1)\nDESCRIPTION: This snippet shows the syntax for block comments in bc(1). Block comments start with '/*' and end with '*/'. These comments can span multiple lines and are used to provide detailed explanations or temporarily disable code.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/bc/E.1.md#_snippet_3\n\nLANGUAGE: bc\nCODE:\n```\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution in dc (!=r)\nDESCRIPTION: Pops two values (numbers) from the stack. If the first is not equal to the second, executes register *r*.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_13\n\nLANGUAGE: dc\nCODE:\n```\n!=r\n```\n\n----------------------------------------\n\nTITLE: Conditional Execution Based on Less Than in DC\nDESCRIPTION: This snippet explains how to conditionally execute a register based on a less-than comparison between two numbers on the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EN.1.md#_snippet_5\n\nLANGUAGE: dc\nCODE:\n```\n<r\n```\n\nLANGUAGE: dc\nCODE:\n```\n<rers\n```\n\n----------------------------------------\n\nTITLE: Memory Storage Operation\nDESCRIPTION: This snippet appears to involve memory storage `sM`. The `[0000]00]` likely refers to a memory address, and `s010sil0x` might be the data being stored. Dependencies are not explicitly defined, but an understanding of the target architecture and memory addressing scheme is crucial. \nSOURCE: https://github.com/gavinhoward/bc/blob/master/tests/fuzzing/dc_inputs/11.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n[[0000]00]sM[]s010sil0x\n```\n\n----------------------------------------\n\nTITLE: Retrieving Array Value in dc\nDESCRIPTION: Pops a value from the stack and uses it as an index into array *r*. The selected value is pushed onto the stack.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EHN.1.md#_snippet_26\n\nLANGUAGE: dc\nCODE:\n```\n;r\n```\n\n----------------------------------------\n\nTITLE: Push Array Length\nDESCRIPTION: Pushes the length of the array *r* onto the stack. This is a non-portable extension.\nSOURCE: https://github.com/gavinhoward/bc/blob/master/manuals/dc/EH.1.md#_snippet_27\n\nLANGUAGE: dc\nCODE:\n```\nYr\n```"
  }
]