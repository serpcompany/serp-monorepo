[
  {
    "owner": "vueuse",
    "repo": "vueuse",
    "content": "TITLE: Importing and Using VueUse Utilities\nDESCRIPTION: This snippet demonstrates importing and using various VueUse composables. It imports `useLocalStorage`, `useMouse`, and `usePreferredDark` from the `@vueuse/core` package. The example shows how to get mouse coordinates, check for dark theme preference, and persist data using local storage. It requires the `@vueuse/core` package to be installed.  The output depends on the user's preferences and the data stored in localStorage.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/README.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport { useLocalStorage, useMouse, usePreferredDark } from '@vueuse/core'\n\nconst { x, y } = useMouse()\n\n// if user prefers dark theme\nconst isDark = usePreferredDark()\n\n// persist state in localStorage\nconst store = useLocalStorage(\n  'my-storage',\n  {\n    name: 'Apple',\n    color: 'red',\n  },\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Refresh Logic (VueUse TypeScript)\nDESCRIPTION: Provides a comprehensive example demonstrating how to implement automatic token refreshing logic using `createFetch`, interceptors (`afterFetch` or `onFetchError`), and the `execute` function to re-run failed requests after the token is updated.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nlet isRefreshing = false\nconst refreshSubscribers: Array<() => void> = []\n\nconst useMyFetch = createFetch({\n  baseUrl: 'https://my-api.com',\n  options: {\n    async beforeFetch({ options }) {\n      const myToken = await getMyToken()\n      options.headers.Authorization = `Bearer ${myToken}`\n\n      return { options }\n    },\n    afterFetch({ data, response, context, execute }) {\n      if (needRefreshToken) {\n        if (!isRefreshing) {\n          isRefreshing = true\n          refreshToken().then((newToken) => {\n            if (newToken.value) {\n              isRefreshing = false\n              setMyToken(newToken.value)\n              onRrefreshed()\n            }\n            else {\n              refreshSubscribers.length = 0\n              // handle refresh token error\n            }\n          })\n        }\n\n        return new Promise((resolve) => {\n          addRefreshSubscriber(() => {\n            execute().then((response) => {\n              resolve({ data, response })\n            })\n          })\n        })\n      }\n\n      return { data, response }\n    },\n    // or use onFetchError with updateDataOnError\n    updateDataOnError: true,\n    onFetchError({ error, data, response, context, execute }) {\n      // same as afterFetch\n      return { error, data }\n    },\n  },\n  fetchOptions: {\n    mode: 'cors',\n  },\n})\n\nasync function refreshToken() {\n  const { data, execute } = useFetch<string>('refresh-token', {\n    immediate: false,\n  })\n\n  await execute()\n  return data\n}\n\nfunction onRrefreshed() {\n  refreshSubscribers.forEach(callback => callback())\n  refreshSubscribers.length = 0\n}\n\nfunction addRefreshSubscriber(callback: () => void) {\n  refreshSubscribers.push(callback)\n}\n\nconst { isFetching, error, data } = useMyFetch('users')\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization Configuration for VueUse useStorage in TypeScript\nDESCRIPTION: Shows how to override the default serialization and deserialization methods in useStorage by providing custom read and write functions through the serializer option. This allows handling more complex or non-standard data formats. It also covers scenarios where the default value is null, which prevents automatic data type inference, requiring explicit serializer usage, e.g., built-in StorageSerializers.object. This snippet depends on the @vueuse/core package and assumes correct implementation of custom serializer methods that follow the expected API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStorage/index.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { useStorage } from '@vueuse/core'\n\nuseStorage(\n  'key',\n  {},\n  undefined,\n  {\n    serializer: {\n      read: (v: any) => v ? JSON.parse(v) : null,\n      write: (v: any) => JSON.stringify(v),\n    },\n  },\n)\n```\n\nLANGUAGE: ts\nCODE:\n```\nimport { StorageSerializers, useStorage } from '@vueuse/core'\n\nconst objectLike = useStorage('key', null, undefined, { serializer: StorageSerializers.object })\nobjectLike.value = { foo: 'bar' }\n```\n\n----------------------------------------\n\nTITLE: Initializing Firestore and Fetching Data - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to initialize Firebase and use `useFirestore` to establish reactive bindings to a Firestore collection, single document and query. It shows how to observe changes in the database and keep the local data synchronized. Key dependencies include the Firebase SDK and the `@vueuse/firebase` library. The expected output is a reactive data structure representing data from Firestore.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useFirestore/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n```js {9,12,17,22}\nimport { useFirestore } from '@vueuse/firebase/useFirestore'\nimport { initializeApp } from 'firebase/app'\nimport { collection, doc, getFirestore, limit, orderBy, query } from 'firebase/firestore'\nimport { computed, shallowRef } from 'vue'\n\nconst app = initializeApp({ projectId: 'MY PROJECT ID' })\nconst db = getFirestore(app)\n\nconst todos = useFirestore(collection(db, 'todos'))\n\n// or for doc reference\nconst user = useFirestore(doc(db, 'users', 'my-user-id'))\n\n// you can also use ref value for reactive query\nconst postsLimit = shallowRef(10)\nconst postsQuery = computed(() => query(collection(db, 'posts'), orderBy('createdAt', 'desc'), limit(postsLimit.value)))\nconst posts = useFirestore(postsQuery)\n\n// you can use the boolean value to tell a query when it is ready to run\n// when it gets falsy value, return the initial value\nconst userId = shallowRef('')\nconst userQuery = computed(() => userId.value && doc(db, 'users', userId.value))\nconst userData = useFirestore(userQuery, null)\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Fetching with useFetch (VueUse TypeScript)\nDESCRIPTION: Initializes a basic fetch request using `useFetch` with a given URL. It returns reactive properties `isFetching` (loading state), `error` (any fetch error), and `data` (the fetched response). This is the simplest way to integrate data fetching.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useFetch } from '@vueuse/core'\n\nconst { isFetching, error, data } = useFetch(url)\n```\n\n----------------------------------------\n\nTITLE: Initializing Reactive Storage Bindings with VueUse useStorage in JavaScript\nDESCRIPTION: Demonstrates importing and using the useStorage function from @vueuse/core to bind reactive refs to LocalStorage or SessionStorage values. Shows usage with various data types such as objects, booleans, numbers, and strings, including specifying SessionStorage as the storage source. This snippet highlights that setting the ref's value to null deletes the item from storage. It requires a browser environment with Web Storage API support and a Vue 3 ecosystem to support ref reactivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStorage/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useStorage } from '@vueuse/core'\n\n// bind object\nconst state = useStorage('my-store', { hello: 'hi', greeting: 'Hello' })\n\n// bind boolean\nconst flag = useStorage('my-flag', true) // returns Ref<boolean>\n\n// bind number\nconst count = useStorage('my-count', 0) // returns Ref<number>\n\n// bind string with SessionStorage\nconst id = useStorage('my-id', 'some-string-id', sessionStorage) // returns Ref<string>\n// delete data from storage\nstate.value = null\n```\n\n----------------------------------------\n\nTITLE: Setting Method and Response Type via Options (VueUse TypeScript)\nDESCRIPTION: Shows how to set the HTTP `method` using the options object passed to `useFetch`. The response type is still configured using a chainable method like `.blob()`. This is an alternative to the purely chainable approach.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Request will be sent with GET method and data will be parsed as blob\nconst { data } = useFetch(url, { method: 'GET' }, { refetch: true }).blob()\n```\n\n----------------------------------------\n\nTITLE: Using useDebouncedRefHistory with VueUse\nDESCRIPTION: This TypeScript snippet demonstrates importing and using the `useDebouncedRefHistory` composable from `@vueuse/core`. It tracks the history of a `shallowRef` named `counter`, creating snapshots only 1000ms after the `counter` value stops changing, due to the `debounce: 1000` option. The `deep: true` option enables deep watching of the ref's value. The composable returns `history`, `undo`, and `redo` functions for managing the ref's history states.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDebouncedRefHistory/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useDebouncedRefHistory } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst counter = shallowRef(0)\nconst { history, undo, redo } = useDebouncedRefHistory(counter, { deep: true, debounce: 1000 })\n```\n\n----------------------------------------\n\nTITLE: Using useVModel in Script Setup with Vue\nDESCRIPTION: Example showing how to use the useVModel composable in a Vue component using the <script setup> syntax with TypeScript. It demonstrates defining props and emits, then creating a two-way binding for 'modelValue'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVModel/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script lang=\"ts\" setup>\nimport { useVModel } from '@vueuse/core'\n\nconst props = defineProps<{\n  modelValue: string\n}>()\nconst emit = defineEmits(['update:modelValue'])\n\nconst data = useVModel(props, 'modelValue', emit)\n</script>\n```\n\n----------------------------------------\n\nTITLE: Destructuring v-model Props with toRefs in a Vue Component\nDESCRIPTION: Illustrates a practical application of `toRefs` within a Vue 3 component's `setup` function. It combines `useVModel` (to handle `v-model` props) with `toRefs` to destructure the reactive props object into individual refs. This allows direct use of these refs in the template (`v-model=\"a\"`), simplifying binding while ensuring updates are correctly emitted back to the parent component. Requires `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/toRefs/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n<script lang=\"ts\">\nimport { toRefs, useVModel } from '@vueuse/core'\n\nexport default {\n  setup(props) {\n    // Assumes 'data' prop exists and is used with v-model in parent\n    // e.g., <MyComponent v-model:data=\"myData\" />\n    const refs = toRefs(useVModel(props, 'data'))\n\n    console.log(refs.a.value) // Accesses props.data.a reactively\n    refs.a.value = 'new value' // Updates props.data.a and emits 'update:data'\n\n    // Spread the refs into the return object for template access\n    return { ...refs }\n  }\n}\n</script>\n```\n\nLANGUAGE: HTML\nCODE:\n```\n<template>\n  <div>\n    <input v-model=\"a\" type=\"text\">\n    <input v-model=\"b\" type=\"text\">\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useWebSocket with basic URL\nDESCRIPTION: This code snippet demonstrates the basic initialization of the `useWebSocket` composable with a WebSocket URL. It imports the `useWebSocket` function from `@vueuse/core` and initializes it with a WebSocket endpoint. The composable returns reactive properties such as `status`, `data`, `send`, `open`, and `close` to manage the WebSocket connection.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useWebSocket } from '@vueuse/core'\n\nconst { status, data, send, open, close } = useWebSocket('ws://websocketurl')\n```\n\n----------------------------------------\n\nTITLE: Using useClipboard in Vue with Composition API\nDESCRIPTION: This snippet demonstrates how to integrate the useClipboard function within a Vue 3 component using the Composition API and script setup syntax. It shows how to bind clipboard copy actions and display current clipboard text, with support check for browser capabilities.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useClipboard/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useClipboard } from '@vueuse/core'\n\nconst source = ref('Hello')\nconst { text, copy, copied, isSupported } = useClipboard({ source })\n</script>\n\n<template>\n  <div v-if=\"isSupported\">\n    <button @click=\"copy(source)\">\n      <!-- by default, `copied` will be reset in 1.5s -->\n      <span v-if=\"!copied\">Copy</span>\n      <span v-else>Copied!</span>\n    </button>\n    <p>Current copied: <code>{{ text || 'none' }}</code></p>\n  </div>\n  <p v-else>\n    Your browser does not support Clipboard API\n  </p>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using UseImage Component with VueUse in Vue\nDESCRIPTION: This snippet illustrates usage of the <UseImage> component provided by VueUse within a Vue single-file component's template. By supplying the src prop, image loading is handled reactively, and named slots allow for custom display of loading and error states. The snippet requires the VueUse library and a Vue environment capable of resolving the <UseImage> component. The component expects a valid src URL string and provides slots for 'loading' and 'error' to customize user feedback.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useImage/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseImage src=\"https://place.dog/300/200\">\n    <template #loading>\n      Loading..\n    </template>\n\n    <template #error>\n      Failed\n    </template>\n  </UseImage>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Opening File Dialog Using VueUse in TypeScript\nDESCRIPTION: Imports and uses the useFileDialog composable from the @vueuse/core library to open a file selection dialog. It supports filtering accepted file types via the 'accept' option and optionally allows selecting directories with the 'directory' flag. The snippet shows how to subscribe to file selection changes with onChange and handle cancellation via onCancel. Dependencies include the VueUse library and a compatible Vue 3 project environment. Inputs include event callbacks for file changes and cancellations, and the outputs are reactive file lists and control functions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFileDialog/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useFileDialog } from '@vueuse/core'\n\nconst { files, open, reset, onCancel, onChange } = useFileDialog({\n  accept: 'image/*', // Set to accept only image files\n  directory: true, // Select directories instead of files if set true\n})\n\nonChange((files) => {\n  /** do something with files */\n})\n\nonCancel(() => {\n  /** do something on cancel */\n})\n```\n\n----------------------------------------\n\nTITLE: Using useElementBounding with Template Ref - Vue\nDESCRIPTION: This snippet demonstrates the basic usage of the `useElementBounding` composable. It initializes a template ref, `el`, to target a `div` element and utilizes `useElementBounding(el)` to retrieve reactive bounding box properties like `x`, `y`, `top`, `right`, `bottom`, `left`, `width`, and `height`. The template includes a `div` element with the ref attribute bound to `el`.  Dependencies include `@vueuse/core` and Vue.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementBounding/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport { useElementBounding } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nexport default {\n  setup() {\n    const el = useTemplateRef('el')\n    const { x, y, top, right, bottom, left, width, height }\n        = useElementBounding(el)\n\n    return {\n      el,\n      /* ... */\n    }\n  },\n}\n</script>\n\n<template>\n  <div ref=\"el\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using tryOnBeforeUnmount in Vue.js\nDESCRIPTION: This example demonstrates how to import and use the tryOnBeforeUnmount utility function from the VueUse core package. The function accepts a callback that will be executed before the component is unmounted if used within a component lifecycle.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/tryOnBeforeUnmount/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { tryOnBeforeUnmount } from '@vueuse/core'\n\ntryOnBeforeUnmount(() => {\n\n})\n```\n\n----------------------------------------\n\nTITLE: Using Event Filters (Throttle/Debounce) in VueUse (TypeScript)\nDESCRIPTION: Demonstrates how to use `throttleFilter` with `useLocalStorage` to limit update frequency to once per second and `debounceFilter` with `useMouse` to delay updates until 100ms after mouse movement stops. Imports necessary functions from `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/config.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { debounceFilter, throttleFilter, useLocalStorage, useMouse } from '@vueuse/core'\n\n// changes will write to localStorage with a throttled 1s\nconst storage = useLocalStorage('my-key', { foo: 'bar' }, { eventFilter: throttleFilter(1000) })\n\n// mouse position will be updated after mouse idle for 100ms\nconst { x, y } = useMouse({ eventFilter: debounceFilter(100) })\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Shared Composable in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use `createSharedComposable` from `@vueuse/core` to wrap the `useMouse` composable. The resulting `useSharedMouse` function can then be called in multiple components (CompA.vue, CompB.vue), ensuring they share the same mouse position state (`x`, `y`) and that the underlying event listeners for `useMouse` are only registered once.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createSharedComposable/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSharedComposable, useMouse } from '@vueuse/core'\n\nconst useSharedMouse = createSharedComposable(useMouse)\n\n// CompA.vue\nconst { x, y } = useSharedMouse()\n\n// CompB.vue - will reuse the previous state and no new event listeners will be registered\nconst { x, y } = useSharedMouse()\n```\n\n----------------------------------------\n\nTITLE: Using useRafFn VueUse Hook in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `useRafFn` hook from VueUse. It imports the hook and `shallowRef`, initializes a reactive counter, and uses `useRafFn` to increment the counter and log its value on each animation frame. The snippet also shows how to destructure the `pause` and `resume` control functions returned by the hook.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRafFn/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useRafFn } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst count = shallowRef(0)\n\nconst { pause, resume } = useRafFn(() => {\n  count.value++\n  console.log(count.value)\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Document Title Reactively Using VueUse in JavaScript\nDESCRIPTION: This snippet shows how to initialize the document title immediately by passing an initial string argument to useTitle. The title is set to 'New Title' upon invocation without requiring further reactive updates. This pattern provides a quick way to establish the document title during setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTitle/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst title = useTitle('New Title')\n```\n\n----------------------------------------\n\nTITLE: Sharing Firestore References with createGlobalState - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates sharing Firestore references across different instances of your application using the `createGlobalState` function from the `@vueuse/core` package. This enables you to share the same reactive Firestore data across multiple components. It relies on the core package and the Firestore integration within VueUse. The expected output is a globally accessible reactive Firestore binding.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useFirestore/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n```js\n// store.js\nimport { createGlobalState } from '@vueuse/core'\nimport { useFirestore } from '@vueuse/firebase/useFirestore'\n\nexport const useTodos = createGlobalState(\n  () => useFirestore(collection(db, 'todos')),\n)\n```\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n```js\n// app.js\nimport { useTodos } from './store'\n\nexport default {\n  setup() {\n    const todos = useTodos()\n    return { todos }\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing File Drop Zone with useDropZone in Vue 3 Script Setup\nDESCRIPTION: This snippet demonstrates how to use the `useDropZone` composable in a Vue 3 component with `<script setup>`. It imports the composable, creates a ref to link to the drop zone element, defines an `onDrop` handler for processing files, and configures `useDropZone` with options like `dataTypes` (e.g., 'image/jpeg'), `multiple`, and `preventDefaultForUnhandled`. It also shows how to use the returned `isOverDropZone` ref and links the drop zone element in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDropZone/index.md#_snippet_0\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useDropZone } from '@vueuse/core'\n\nconst dropZoneRef = ref<HTMLDivElement>()\n\nfunction onDrop(files: File[] | null) {\n  // called when files are dropped on zone\n}\n\nconst { isOverDropZone } = useDropZone(dropZoneRef, {\n  onDrop,\n  // specify the types of data to be received.\n  dataTypes: ['image/jpeg'],\n  // control multi-file drop\n  multiple: true,\n  // whether to prevent default behavior for unhandled events\n  preventDefaultForUnhandled: false,\n})\n</script>\n\n<template>\n  <div ref=\"dropZoneRef\">\n    Drop files here\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using usePreferredDark Function in JavaScript\nDESCRIPTION: Example showing how to import and use the usePreferredDark function. This creates a reactive reference that tracks whether the user prefers a dark color scheme.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredDark/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { usePreferredDark } from '@vueuse/core'\n\nconst isDark = usePreferredDark()\n```\n\n----------------------------------------\n\nTITLE: Initializing useVirtualList for Basic List in TypeScript\nDESCRIPTION: This snippet demonstrates the basic initialization of useVirtualList for rendering a large list efficiently. It imports the composable from '@vueuse/core', creates a list of 99,999 items, and sets the item height to 22 pixels to ensure proper DOM height calculations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { list, containerProps, wrapperProps } = useVirtualList(\n  Array.from(Array.from({ length: 99999 }).keys()),\n  {\n    // Keep `itemHeight` in sync with the item's row.\n    itemHeight: 22,\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using useIntersectionObserver in Vue 3 with TypeScript\nDESCRIPTION: Demonstrates how to utilize the useIntersectionObserver composition API from '@vueuse/core' within a Vue 3 component. It observes a target element's intersection status and updates a reactive variable accordingly. Dependencies include '@vueuse/core' and 'vue'. The snippet highlights setting up refs, importing the hook, and handling intersection updates via a callback function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useIntersectionObserver/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useIntersectionObserver } from '@vueuse/core'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst targetIsVisible = shallowRef(false)\n\nconst { stop } = useIntersectionObserver(\n  target,\n  ([entry], observerElement) => {\n    targetIsVisible.value = entry?.isIntersecting || false\n  },\n)\n</script>\n\n<template>\n  <div ref=\"target\">\n    <h1>Hello world</h1>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using tryOnScopeDispose in Vue.js\nDESCRIPTION: This snippet demonstrates the usage of `tryOnScopeDispose` to register a cleanup function. The `tryOnScopeDispose` function ensures that `onScopeDispose` is called only when inside a valid effect scope. This is useful for managing resources or side effects within a component's lifecycle. The provided anonymous function is the cleanup function that will be executed when the scope is disposed. There are no specific input parameters for `tryOnScopeDispose`, but it expects a function as an argument to execute when the scope is disposed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/tryOnScopeDispose/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { tryOnScopeDispose } from '@vueuse/core'\n\ntryOnScopeDispose(() => {\n\n})\n```\n\n----------------------------------------\n\nTITLE: useAxios execute function returns result\nDESCRIPTION: The execute function resolves with a result of the network request as shown in this snippet.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\n\nconst { execute } = useAxios()\nconst result = await execute(url)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useBreakpoints with Tailwind Preset in JavaScript\nDESCRIPTION: Demonstrates how to use the useBreakpoints composable with Tailwind CSS breakpoints. Shows different methods for checking viewport sizes including greaterOrEqual, greater, smallerOrEqual, and smaller.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBreakpoints/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { breakpointsTailwind, useBreakpoints } from '@vueuse/core'\n\nconst breakpoints = useBreakpoints(breakpointsTailwind)\n\nconst smAndLarger = breakpoints.greaterOrEqual('sm') // sm and larger\nconst largerThanSm = breakpoints.greater('sm') // only larger than sm\nconst lgAndSmaller = breakpoints.smallerOrEqual('lg') // lg and smaller\nconst smallerThanLg = breakpoints.smaller('lg') // only smaller than lg\n```\n\n----------------------------------------\n\nTITLE: Using VueUse functions in a Nuxt application\nDESCRIPTION: Example of using VueUse's useMouse function in a Nuxt component with auto-importing, displaying mouse coordinates in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_6\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nconst { x, y } = useMouse()\n</script>\n\n<template>\n  <div>pos: {{ x }}, {{ y }}</div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Configuring Textarea Autosize for 'rows' Attribute in VueUse\nDESCRIPTION: Illustrates how to configure `useTextareaAutosize` to correctly handle the HTML `rows` attribute. By passing `{ styleProp: 'minHeight' }` as an option, the composable sets the `min-height` style instead of `height`, ensuring the textarea respects the initial row count while still auto-resizing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextareaAutosize/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nconst { textarea, input } = useTextareaAutosize({ styleProp: 'minHeight' })\n</script>\n\n<template>\n  <textarea\n    ref=\"textarea\"\n    v-model=\"input\"\n    class=\"resize-none\"\n    placeholder=\"What's on your mind?\"\n    rows=\"3\"\n  />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useElementVisibility Composable in Vue Script Setup\nDESCRIPTION: Example showing how to track element visibility using the useElementVisibility composable in a Vue component with script setup. It tracks a div element referenced with useTemplateRef and provides a reactive boolean indicating visibility status.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementVisibility/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useElementVisibility } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst targetIsVisible = useElementVisibility(target)\n</script>\n\n<template>\n  <div ref=\"target\">\n    <h1>Hello world</h1>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useRouteQuery with value transformation for 'page' parameter\nDESCRIPTION: This example demonstrates transforming the 'page' query parameter using a transform function (Number), allowing the reactive value to be automatically parsed as a number. It shows how to handle parameter conversions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteQuery/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst page = useRouteQuery('page', '1', { transform: Number })\n```\n\n----------------------------------------\n\nTITLE: Focus Trap in VueUse\nDESCRIPTION: Creates a focus trap mechanism to confine keyboard navigation to a specific component, improving accessibility.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Implements an accessibility focus trap within Vue components, restricting keyboard focus for modal dialogs or menus. */\n```\n\n----------------------------------------\n\nTITLE: Tracking Focus State with useFocus in VueUse (TypeScript)\nDESCRIPTION: Imports useFocus from @vueuse/core and demonstrates how to monitor and react to the focus state of a DOM element using the focused ref. The shallowRef holds the target element, and a watcher logs when the element gains or loses focus. Requires VueUse and a Vue 3 compatible environment. Input: any focusable DOM node reference. Output: reactive focus state. Limitations include dependency on a ref and proper DOM mounting.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFocus/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useFocus } from '@vueuse/core'\n\nconst target = shallowRef()\nconst { focused } = useFocus(target)\n\nwatch(focused, (focused) => {\n  if (focused)\n    console.log('input element has been focused')\n  else console.log('input element has lost focus')\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Persistent Global State with useStorage (JS)\nDESCRIPTION: Illustrates how to combine `createGlobalState` with `useStorage` from VueUse to create global state that automatically persists its value in `localStorage`. The factory function simply returns the result of calling `useStorage` with a storage key and initial value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createGlobalState/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createGlobalState, useStorage } from '@vueuse/core'\n\nexport const useGlobalState = createGlobalState(\n  () => useStorage('vueuse-local-storage', 'initialValue'),\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Focus with useFocus Option (TypeScript)\nDESCRIPTION: Shows how to set the focused state of a DOM element to true on mount by providing the initialValue option to useFocus. This triggers an immediate focus event on the referenced element. Dependencies are @vueuse/core and a Vue 3 setup. Input: a DOM ref, options object. Output: the focused ref is true initially. Ensure the referenced element exists when the hook runs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFocus/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useFocus } from '@vueuse/core'\n\nconst target = shallowRef()\nconst { focused } = useFocus(target, { initialValue: true })\n```\n\n----------------------------------------\n\nTITLE: Using the v-element-size Directive in Vue/TypeScript\nDESCRIPTION: Shows how to use the `v-element-size` directive provided by `@vueuse/components`. The directive is applied to an HTML element (e.g., `<textarea>`) and calls the provided function (`onResize`) whenever the element's size changes, passing the new width and height. The example also demonstrates passing initial size hints and ResizeObserver options (`box: 'content-box'`) to the directive.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementSize/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vElementSize } from '@vueuse/components'\nfunction onResize({ width, height }: { width: number, height: number }) {\n  console.log(width, height)\n}\n</script>\n\n<template>\n  <textarea v-element-size=\"onResize\" />\n  <!-- with options -->\n  <textarea v-element-size=\"[onResize, { width: 100, height: 100 }, { box: 'content-box' }]\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using whenever Function for Shortcut Detection in TypeScript\nDESCRIPTION: Demonstrates utilizing the whenever helper to execute code when a specific key combination, such as shift and space, is pressed. Simplifies the event handling for key presses. Requires '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys, whenever } from '@vueuse/core'\n\nconst keys = useMagicKeys()\n\nwhenever(keys.shift_space, () => {\n  console.log('Shift+Space have been pressed')\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useMagicKeys for Monitoring Specific Keys in JavaScript\nDESCRIPTION: Demonstrates initializing useMagicKeys and setting up watchers to detect when specific keys (space, shift, a) are pressed, with real-time response via watch and watchEffect. Dependencies include @vueuse/core and Vue's reactive utilities. Inputs are key states; outputs are console logs indicating key presses.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useMagicKeys } from '@vueuse/core'\n\nconst { shift, space, a } = useMagicKeys()\n\nwatch(space, (v) => {\n  if (v)\n    console.log('space has been pressed')\n})\n\nwatchEffect(() => {\n  if (shift.value && a.value)\n    console.log('Shift + A have been pressed')\n})\n```\n\n----------------------------------------\n\nTITLE: Using v-on-click-outside directive\nDESCRIPTION: This Vue snippet demonstrates using the `v-on-click-outside` directive. The directive, likely imported from `@vueuse/components`, closes a modal when a click occurs outside of it.  It shows the usage with a boolean reactive value `modal` and a function `closeModal`.  Dependencies include `@vueuse/components` and `vue`'s `shallowRef`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onClickOutside/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vOnClickOutside } from '@vueuse/components'\nimport { shallowRef } from 'vue'\n\nconst modal = shallowRef(false)\nfunction closeModal() {\n  modal.value = false\n}\n</script>\n\n<template>\n  <button @click=\"modal = true\">\n    Open Modal\n  </button>\n  <div v-if=\"modal\" v-on-click-outside=\"closeModal\">\n    Hello World\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useClipboardItems in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates initializing and using the `useClipboardItems` composable function from the `@vueuse/core` library. It sets up a `source` ref containing a `ClipboardItem` with a `text/plain` MIME type. The snippet then calls `useClipboardItems` to get the `content`, `copy`, `copied`, and `isSupported` properties. It relies on the `@vueuse/core` library and the Clipboard API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useClipboardItems/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useClipboardItems } from '@vueuse/core'\n\nconst mime = 'text/plain'\nconst source = ref([\n  new ClipboardItem({\n    [mime]: new Blob(['plain text'], { type: mime }),\n  })\n])\n\nconst { content, copy, copied, isSupported } = useClipboardItems({ source })\n```\n\n----------------------------------------\n\nTITLE: Draggable element setup with useTemplateRef (Vue)\nDESCRIPTION: This code snippet demonstrates the basic usage of `useDraggable` with `useTemplateRef` in a Vue component. It imports the necessary functions from `@vueuse/core` and `vue`, creates a template ref for the draggable element, and uses `useDraggable` to manage the element's position. The `style` computed property is used to apply the element's position using CSS.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDraggable/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useDraggable } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\n\n// `style` will be a helper computed for `left: ?px; top: ?px;`\nconst { x, y, style } = useDraggable(el, {\n  initialValue: { x: 40, y: 40 },\n})\n</script>\n\n<template>\n  <div ref=\"el\" :style=\"style\" style=\"position: fixed\">\n    Drag me! I am at {{ x }}, {{ y }}\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using whenever with Computed Getter Function in TypeScript\nDESCRIPTION: Demonstrates using whenever with a getter function that returns a boolean computed expression, triggering the callback when the expression becomes truthy. In this example, it logs when the counter reaches 7. The getter is reevaluated for each change, depending on reactive dependencies.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/whenever/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nwhenever(\n  () => counter.value === 7,\n  () => console.log('counter is 7 now!'),\n)\n```\n\n----------------------------------------\n\nTITLE: Using v-scroll-lock directive in Vue components\nDESCRIPTION: Shows how to use the scroll lock functionality as a directive (v-scroll-lock) to control element scrolling. The directive takes a reactive boolean value that determines if scrolling is locked or not.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScrollLock/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vScrollLock } from '@vueuse/components'\nconst data = ref([1, 2, 3, 4, 5, 6])\nconst isLocked = ref(false)\nconst toggleLock = useToggle(isLocked)\n</script>\n\n<template>\n  <div v-scroll-lock=\"isLocked\">\n    <div v-for=\"item in data\" :key=\"item\">\n      {{ item }}\n    </div>\n  </div>\n  <button @click=\"toggleLock()\">\n    Toggle lock state\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: useWebSocket with autoReconnect enabled\nDESCRIPTION: This snippet demonstrates how to enable automatic reconnection with the `autoReconnect` option. When set to `true`, the WebSocket client will automatically attempt to reconnect upon encountering errors.  Dependencies include `@vueuse/core`. It allows for a simplified reconnection setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { status, data, close } = useWebSocket('ws://websocketurl', {\n  autoReconnect: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Tracking Mouse Position with useMouse in TypeScript\nDESCRIPTION: Demonstrates the basic usage of the `useMouse` composable from `@vueuse/core` to reactively track the mouse's `x` and `y` coordinates, along with the `sourceType` (e.g., 'mouse', 'touch').\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouse/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@vueuse/core'\n\nconst { x, y, sourceType } = useMouse()\n```\n\n----------------------------------------\n\nTITLE: useResizeObserver Composable Usage in Vue\nDESCRIPTION: Demonstrates how to use the `useResizeObserver` composable to observe changes in an element's dimensions. It imports the composable and `useTemplateRef` from Vue and updates a reactive variable with the width and height of the observed element. Requires Vue 3.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useResizeObserver/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useResizeObserver } from '@vueuse/core'\nimport { ref, useTemplateRef } from 'vue'\n\nconst el = useTemplateRef('el')\nconst text = ref('')\n\nuseResizeObserver(el, (entries) => {\n  const entry = entries[0]\n  const { width, height } = entry.contentRect\n  text.value = `width: ${width}, height: ${height}`\n})\n</script>\n\n<template>\n  <div ref=\"el\">\n    {{ text }}\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Core VueUse Utilities in TypeScript\nDESCRIPTION: This snippet demonstrates how to import multiple composable functions from the VueUse core library in a TypeScript-based Vue 3 project. It shows the usage of 'useMouse' for retrieving cursor coordinates, 'usePreferredDark' for detecting the user's dark mode preference, and 'useLocalStorage' to persist an object in browser localStorage. Dependencies: '@vueuse/core' (npm package), Vue 3, and TypeScript support. Key parameters include the localStorage key and default object; expected outputs are reactive values for mouse position, theme preference, and the stored state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useLocalStorage, useMouse, usePreferredDark } from '@vueuse/core'\n\nconst { x, y } = useMouse()\n\n// if user prefers dark theme\nconst isDark = usePreferredDark()\n\n// persist state in localStorage\nconst store = useLocalStorage(\n  'my-storage',\n  {\n    name: 'Apple',\n    color: 'red',\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Refetching on URL Ref Change (VueUse TypeScript)\nDESCRIPTION: Configures `useFetch` to automatically trigger a new request whenever the provided URL, which is a Vue `ref`, changes its value. The `refetch: true` option must be set to enable this reactive refetching behavior.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = ref('https://my-api.com/user/1')\n\nconst { data } = useFetch(url, { refetch: true })\n\nurl.value = 'https://my-api.com/user/2' // Will trigger another request\n```\n\n----------------------------------------\n\nTITLE: Joining Array of Multiple Refs with useArrayJoin in VueUse (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use the useArrayJoin function from @vueuse/core to join the values of multiple Vue refs in a reactive array. By placing several refs into a list and passing it to useArrayJoin, changes to any ref are automatically reflected in the joined result. Dependencies include Vue (with the ref API) and @vueuse/core; inputs are an array of refs, and the output is a computed ref string. The result is updated whenever any ref value changes, making it ideal for reactive data displays.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayJoin/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayJoin } from '@vueuse/core'\n\nconst item1 = ref('foo')\nconst item2 = ref(0)\nconst item3 = ref({ prop: 'val' })\nconst list = [item1, item2, item3]\nconst result = useArrayJoin(list)\n// result.value: foo,0,[object Object]\nitem1.value = 'bar'\n// result.value: bar,0,[object Object]\n```\n\n----------------------------------------\n\nTITLE: Requesting Device Permissions - JavaScript\nDESCRIPTION: Uses the `ensurePermissions` method returned by `useDevicesList` to prompt the user for media device access permissions. The `permissionGranted` reactive ref indicates whether permissions were successfully obtained after the prompt. This is typically needed before `enumerateDevices` can return full device information.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicesList/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst {\n  ensurePermissions,\n  permissionGranted,\n} = useDevicesList()\n\nawait ensurePermissions()\nconsole.log(permissionsGranted.value)\n```\n\n----------------------------------------\n\nTITLE: Initializing Geolocation API Reactively with VueUse in JavaScript\nDESCRIPTION: Imports the useGeolocation hook from the @vueuse/core library and destructures the reactive properties including coordinates, timestamp of location update, error message, and control functions to pause or resume tracking. It depends on the browser's Geolocation API and may require user permission to access location data. The snippet demonstrates how to access location data reactively in a JavaScript context and control updates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGeolocation/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useGeolocation } from '@vueuse/core'\n\nconst { coords, locatedAt, error, resume, pause } = useGeolocation()\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive List with useVirtualList in TypeScript\nDESCRIPTION: This snippet showcases how to create a reactive, toggleable list that filters items to show either even or odd numbers using Vue's composition API with useToggle and computed. The virtual list updates dynamically based on the filter state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst [isEven, toggle] = useToggle()\nconst allItems = Array.from(Array.from({ length: 99999 }).keys())\nconst filteredList = computed(() => allItems.filter(i => isEven.value ? i % 2 === 0 : i % 2 === 1))\n\nconst { list, containerProps, wrapperProps } = useVirtualList(\n  filteredList,\n  {\n    itemHeight: 22,\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Intercepting Fetch Before Sending (VueUse TypeScript)\nDESCRIPTION: Uses the `beforeFetch` option to intercept the request before it is sent. This async hook allows modifying the `url` or `options` (e.g., adding headers) or canceling the request via `cancel()` based on custom logic.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useFetch(url, {\n  async beforeFetch({ url, options, cancel }) {\n    const myToken = await getMyToken()\n\n    if (!myToken)\n      cancel()\n\n    options.headers = {\n      ...options.headers,\n      Authorization: `Bearer ${myToken}`,\n    }\n\n    return {\n      options,\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using useTitle with a ref argument in VueUse\nDESCRIPTION: Demonstrates passing a ref into useTitle to synchronize document.title with reactive data, avoiding explicit watchers.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useDark, useTitle } from '@vueuse/core'\nimport { computed } from 'vue'\n// ---cut---\nconst isDark = useDark()\nconst title = computed(() => isDark.value ? 'üåô Good evening!' : '‚òÄÔ∏è Good morning!')\n\nuseTitle(title)\n```\n\n----------------------------------------\n\nTITLE: Sortable List Utility in VueUse\nDESCRIPTION: Provides drag-and-drop sortable list functionality, allowing users to reorder items interactively within Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Drag-and-drop sortable list utility to enable reordering of items in Vue components. */\n```\n\n----------------------------------------\n\nTITLE: Using useScrollLock with a template ref in Vue\nDESCRIPTION: Demonstrates how to use the useScrollLock hook with a template ref to control the scrolling behavior of a specific element. Returns a reactive boolean that can be toggled to lock or unlock scrolling.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScrollLock/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useScrollLock } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst isLocked = useScrollLock(el)\n\nisLocked.value = true // lock\nisLocked.value = false // unlock\n</script>\n\n<template>\n  <div ref=\"el\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Intercepting Fetch Error and Modifying Data (VueUse TypeScript)\nDESCRIPTION: Employs the `onFetchError` option, typically used with `updateDataOnError: true`, to intercept errors and potentially modify the error object or provide default data to the `data` ref. Useful for handling specific API error structures or providing fallbacks.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useFetch(url, {\n  updateDataOnError: true,\n  onFetchError(ctx) {\n    // ctx.data can be null when 5xx response\n    if (ctx.data === null)\n      ctx.data = { title: 'Hunter x Hunter' } // Modifies the response data\n\n    ctx.error = new Error('Custom Error') // Modifies the error\n    return ctx\n  },\n})\n\nconsole.log(data.value) // { title: 'Hunter x Hunter' }\n```\n\n----------------------------------------\n\nTITLE: Using useUrlSearchParams in Hash Mode (JavaScript)\nDESCRIPTION: This snippet illustrates how to use `useUrlSearchParams` with hash mode.  This is suitable for applications where the routing uses the hash fragment of the URL.  It initializes `useUrlSearchParams` by passing 'hash' as the mode. Setting parameters via the returned object updates the URL, which then changes the hash portion. Dependencies: VueUse library, and a Vue application configured for hash-based routing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUrlSearchParams/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useUrlSearchParams } from '@vueuse/core'\n\nconst params = useUrlSearchParams('hash')\n\nparams.foo = 'bar'\nparams.vueuse = 'awesome'\n// url updated to `#/your/route?foo=bar&vueuse=awesome`\n```\n\n----------------------------------------\n\nTITLE: Displaying reactive time ago with UseTimeAgo component in Vue template\nDESCRIPTION: Shows how to use the built-in `UseTimeAgo` component within a Vue template. Pass the target time via the `:time` prop and access the reactive formatted string through the scoped slot prop `timeAgo`. Suitable for component-based rendering in Vue applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimeAgo/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseTimeAgo v-slot=\"{ timeAgo }\" :time=\"new Date(2021, 0, 1)\">\n    Time Ago: {{ timeAgo }}\n  </UseTimeAgo>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Vue Component Implementation with Custom Breakpoints\nDESCRIPTION: Shows how to implement useBreakpoints in a Vue component with custom breakpoints for mobile, tablet, laptop, and desktop. Demonstrates using the active() method to get the current breakpoint and the between() method to check for specific range.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBreakpoints/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useBreakpoints } from '@vueuse/core'\n\nconst breakpoints = useBreakpoints({\n  mobile: 0, // optional\n  tablet: 640,\n  laptop: 1024,\n  desktop: 1280,\n})\n\n// Can be 'mobile' or 'tablet' or 'laptop' or 'desktop'\nconst activeBreakpoint = breakpoints.active()\n\n// true or false\nconst laptop = breakpoints.between('laptop', 'desktop')\n</script>\n\n<template>\n  <div :class=\"activeBreakpoint\">\n    ...\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: useTimeout with Controls - JavaScript\nDESCRIPTION: Demonstrates using `useTimeout` with the `controls: true` option, which returns an object with `ready`, `start`, and `stop` methods for managing the timeout. This allows for programmatic control over the timeout. Requires importing `useTimeout` from `@vueuse/core`. `ready` is a `Ref<boolean>`, `start` is a function to start the timeout, and `stop` is a function to stop the timeout.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useTimeout/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useTimeout } from '@vueuse/core'\n\nconst { ready, start, stop } = useTimeout(1000, { controls: true })\n```\n\n----------------------------------------\n\nTITLE: Using the UseElementSize Component in Vue Template\nDESCRIPTION: Illustrates how to use the `<UseElementSize>` renderless component from VueUse. This component wraps the target element(s) and exposes their reactive `width` and `height` through its default scoped slot. This approach avoids explicit ref handling in the script section for simple cases.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementSize/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseElementSize v-slot=\"{ width, height }\">\n    Width: {{ width }} Height: {{ height }}\n  </UseElementSize>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Checking Source Ref Equality in TypeScript\nDESCRIPTION: This snippet demonstrates the behavior of `useFavicon` when a source ref is passed. It shows that the returned ref is identical to the source ref. It initializes a `shallowRef` as the source and then assigns that source ref to the `useFavicon` composable. The code logs whether the returned ref and the source ref are equal, which should be true.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFavicon/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst source = shallowRef('icon.png')\nconst icon = useFavicon(source)\n\nconsole.log(icon === source) // true\n```\n\n----------------------------------------\n\nTITLE: Configuring fallback support for useClipboard with legacy option\nDESCRIPTION: This snippet explains how to enable fallback copying via execCommand when the Clipboard API isn't supported in the browser, by setting the 'legacy' option to true. It allows copying text with broader browser compatibility.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useClipboard/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useClipboard } from '@vueuse/core'\n\nconst source = ref('Text to copy')\nconst { copy, copied, isSupported } = useClipboard({ source, legacy: true })\n</script>\n\n<template>\n  <button @click=\"copy()\">\n    {{ copied ? 'Copied' : 'Copy' }}\n  </button>\n  <p v-if=\"!isSupported\">Clipboard API not supported; fallback enabled.</p>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useBroadcastChannel to Post Message in JavaScript\nDESCRIPTION: This snippet demonstrates how to initialize the useBroadcastChannel hook, create a channel with a specified name, post a message using the returned `post` function, and optionally close the channel using the `close` function. It also shows accessing state like `isSupported`, `isClosed`, etc.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBroadcastChannel/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useBroadcastChannel } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst {\n  isSupported,\n  channel,\n  post,\n  close,\n  error,\n  isClosed,\n} = useBroadcastChannel({ name: 'vueuse-demo-channel' })\n\nconst message = shallowRef('')\n\nmessage.value = 'Hello, VueUse World!'\n\n// Post the message to the broadcast channel:\npost(message.value)\n\n// Option to close the channel if you wish:\nclose()\n```\n\n----------------------------------------\n\nTITLE: Component usage of UseElementBounding - Vue\nDESCRIPTION: This snippet demonstrates the component usage of UseElementBounding. It makes use of a `UseElementBounding` component, and provides a scoped slot to access width and height of the element. This is a practical example of how to obtain the dimensions of a DOM element within a Vue component, using the Vueuse library for ease of use. The output displays the current width and height.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementBounding/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseElementBounding v-slot=\"{ width, height }\">\n    Width: {{ width }} Height: {{ height }}\n  </UseElementBounding>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating Fetch Utility with Event Hooks using createEventHook (TypeScript)\nDESCRIPTION: This snippet defines a reusable function `useMyFetch` that performs an asynchronous fetch operation. It utilizes `createEventHook` from `@vueuse/core` to create separate event hooks for successful results and errors. The function returns an object containing `on` methods for attaching listeners to these hooks, decoupling the fetch logic from event handling.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createEventHook/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createEventHook } from '@vueuse/core'\n\nexport function useMyFetch(url) {\n  const fetchResult = createEventHook<Response>()\n  const fetchError = createEventHook<any>()\n\n  fetch(url)\n    .then(result => fetchResult.trigger(result))\n    .catch(error => fetchError.trigger(error.message))\n\n  return {\n    onResult: fetchResult.on,\n    onError: fetchError.on,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Aborting Fetch Request with Timeout (VueUse TypeScript)\nDESCRIPTION: Automatically aborts the fetch request if it does not complete within the specified `timeout` duration (in milliseconds). This is a convenient way to prevent requests from hanging indefinitely.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useFetch(url, { timeout: 100 })\n```\n\n----------------------------------------\n\nTITLE: Initializing useColorMode Basic Usage JavaScript\nDESCRIPTION: Demonstrates the basic import and initialization of the `useColorMode` composable from `@vueuse/core` without any configuration options. It returns a reactive reference `mode` that defaults to matching the user's browser preference.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useColorMode/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useColorMode } from '@vueuse/core'\n\nconst mode = useColorMode() // Ref<'dark' | 'light'>\n```\n\n----------------------------------------\n\nTITLE: Using useActiveElement in JavaScript\nDESCRIPTION: This snippet demonstrates how to use the `useActiveElement` composable in JavaScript. It initializes the composable and sets up a watcher to react to changes in the active element. It logs the new active element to the console whenever the focus changes.\n\nDependencies: Requires the '@vueuse/core' library.\n\nParameters: None directly, but it uses the `activeElement` reactive object returned by `useActiveElement()`.\n\nOutput: Console logs the element that currently has focus.\n\nLimitations: Relies on DOM interaction, behavior might be affected by how the DOM is changed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useActiveElement/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useActiveElement } from '@vueuse/core'\n\nconst activeElement = useActiveElement()\n\nwatch(activeElement, (el) => {\n  console.log('focus changed to', el)\n})\n```\n\n----------------------------------------\n\nTITLE: Using VueUse useSwipe with useTemplateRef - Vue\nDESCRIPTION: This snippet demonstrates how to integrate the `useSwipe` composable within a Vue 3 `<script setup>` component. It utilizes `useTemplateRef` to get a reactive reference to a DOM element defined by a `ref` attribute in the template, then passes this reference to `useSwipe` to enable swipe detection. The reactive `isSwiping` and `direction` properties are destructured from the composable's return value for use in the component's logic or template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSwipe/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef('el')\nconst { isSwiping, direction } = useSwipe(el)\n</script>\n\n<template>\n  <div ref=\"el\">\n    Swipe here\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useIntervalFn Timer Control in Vue.js\nDESCRIPTION: Demonstrates how to import and use the useIntervalFn utility from VueUse to create a controllable interval timer. The function returns control methods (pause, resume) and a reactive state variable (isActive) to manage the interval.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useIntervalFn/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useIntervalFn } from '@vueuse/core'\n\nconst { pause, resume, isActive } = useIntervalFn(() => {\n  /* your function */\n}, 1000)\n```\n\n----------------------------------------\n\nTITLE: Applying Default Value to VueUse ref in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to use the refDefault function from VueUse to assign a default value to a reactive reference (ref). It uses useStorage to create a reactive reference bound to local storage and then creates a derived state that defaults to a specified fallback value when the original reference is undefined. The snippet requires the @vueuse/core library and Vue's reactive system. Inputs include the reactive reference 'raw' and the fallback default 'default'. Outputs include a reactive 'state' that mirrors 'raw' but falls back when 'raw' is undefined. It is useful for safely handling reactive data that may be temporarily undefined without breaking reactivity or causing runtime errors.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refDefault/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { refDefault, useStorage } from '@vueuse/core'\n\nconst raw = useStorage('key')\nconst state = refDefault(raw, 'default')\n\nraw.value = 'hello'\nconsole.log(state.value) // hello\n\nraw.value = undefined\nconsole.log(state.value) // default\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFilter with reactive array\nDESCRIPTION: Example showing how to use useArrayFilter with a reactive array. The filter keeps only even numbers, and the result updates reactively when the source array is modified, such as when elements are removed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFilter/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayFilter } from '@vueuse/core'\n\nconst list = ref([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nconst result = useArrayFilter(list, i => i % 2 === 0)\n// result.value: [0, 2, 4, 6, 8]\nlist.value.shift()\n// result.value: [2, 4, 6, 8]\n```\n\n----------------------------------------\n\nTITLE: Reactively Using useMediaQuery in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `useMediaQuery` composable. It initializes two reactive variables, `isLargeScreen` and `isPreferredDark`, which are bound to the results of media queries.  It requires the VueUse library. It returns a reactive boolean representing whether the media query matches the current environment. The `min-width: 1024px` query checks if the screen width is at least 1024px, and the `prefers-color-scheme: dark` checks for dark mode preference.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMediaQuery/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useMediaQuery } from '@vueuse/core'\n\nconst isLargeScreen = useMediaQuery('(min-width: 1024px)')\nconst isPreferredDark = useMediaQuery('(prefers-color-scheme: dark)')\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple History Points with commit()\nDESCRIPTION: Demonstrates how to manually create multiple history points in the same tick using the commit() function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst r = shallowRef(0)\nconst { history, commit } = useRefHistory(r)\n\nr.value = 1\ncommit()\n\nr.value = 2\ncommit()\n\nconsole.log(history.value)\n/* [\n  { snapshot: 2 },\n  { snapshot: 1 },\n  { snapshot: 0 },\n] */\n```\n\n----------------------------------------\n\nTITLE: Subscribing to RxJS Streams using from(), fromEvent() and operators\nDESCRIPTION: This TypeScript snippet demonstrates how to use `from()`, `fromEvent()`, and RxJS operators within a Vue component. It initializes a `count` reactive variable using `shallowRef` and then utilizes RxJS operators like `interval`, `mapTo`, `takeUntil`, `withLatestFrom`, and `map` to create a data stream. The stream emits values to `count` using `toObserver` and `useSubscription`, which updates its value based on the stream's output and user interactions. The snippet uses `fromEvent` to create an observable from button clicks to complete the timer stream.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/from/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { from, fromEvent, toObserver, useSubscription } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { map, mapTo, takeUntil, withLatestFrom } from 'rxjs/operators'\nimport { shallowRef } from 'vue'\n\nconst count = shallowRef(0)\nconst button = shallowRef<HTMLButtonElement | null>(null)\n\nuseSubscription(\n  interval(1000)\n    .pipe(\n      mapTo(1),\n      takeUntil(fromEvent(button, 'click')),\n      withLatestFrom(from(count, {\n        immediate: true,\n        deep: false,\n      })),\n      map(([curr, total]) => curr + total),\n    )\n    .subscribe(toObserver(count)), // same as ).subscribe(val => (count.value = val))\n)\n```\n\n----------------------------------------\n\nTITLE: Using usePrevious with shallowRef in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `usePrevious` utility from `@vueuse/core` to track the previous value of a `shallowRef` from `vue`. It initializes a `shallowRef`, tracks it with `usePrevious`, and shows how the `previous` ref updates to hold the value before the `counter` changes. Requires the `@vueuse/core` and `vue` libraries.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePrevious/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { usePrevious } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst counter = shallowRef('Hello')\nconst previous = usePrevious(counter)\n\nconsole.log(previous.value) // undefined\n\ncounter.value = 'World'\n\nconsole.log(previous.value) // Hello\n```\n\n----------------------------------------\n\nTITLE: Passing Data to a Reusable Template via Slots (Vue)\nDESCRIPTION: Illustrates how to pass data from ReuseTemplate to DefineTemplate using Vue's slot syntax. DefineTemplate uses v-slot to receive named properties, and each ReuseTemplate instance binds differing sets of props or objects using v-bind. Prerequisites: Vue 3, @vueuse/core. Inputs: Props like 'data', 'msg' provided to ReuseTemplate. Outputs: Rendered elements with slot-scoped data. Limitations: Developers should be careful with property naming and object shapes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate()\n</script>\n\n<template>\n  <DefineTemplate v-slot=\"{ data, msg, anything }\">\n    <div>{{ data }} passed from usage</div>\n  </DefineTemplate>\n\n  <ReuseTemplate :data=\"data\" msg=\"The first usage\" />\n  <ReuseTemplate :data=\"anotherData\" msg=\"The second usage\" />\n  <ReuseTemplate v-bind=\"{ data: something, msg: 'The third' }\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useElementSize Composable in Vue\nDESCRIPTION: Demonstrates the basic usage of the `useElementSize` composable function from `@vueuse/core`. It uses `useTemplateRef` to get a reactive reference to a DOM element (`<div>` in this case) and passes it to `useElementSize` to obtain reactive `width` and `height` variables, which are then displayed in the template. Requires importing `useElementSize` and `useTemplateRef`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementSize/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport { useElementSize } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nexport default {\n  setup() {\n    const el = useTemplateRef('el')\n    const { width, height } = useElementSize(el)\n\n    return {\n      el,\n      width,\n      height,\n    }\n  }\n}\n</script>\n\n<template>\n  <div ref=\"el\">\n    Height: {{ height }}\n    Width: {{ width }}\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Vue Template for Horizontal Virtual List Display\nDESCRIPTION: This Vue template shows how to render a horizontally scrolling virtual list, binding container and wrapper properties to ensure proper scrolling behavior, and styling each item with a fixed width.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_5\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <div v-bind=\"containerProps\" style=\"height: 300px\">\n    <div v-bind=\"wrapperProps\">\n      <div v-for=\"item in list\" :key=\"item.index\" style=\"width: 200px\">\n        Row: {{ item.data }}\n      </div>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Debouncing and Handling Return Values\nDESCRIPTION: This snippet demonstrates how to handle the return value of a debounced function using promises. It imports `useDebounceFn`. The `debouncedRequest` function is debounced to return 'response' after a delay of 1000ms. The example shows using `.then()` to handle the resolved value, and using `async/await` as an alternative approach.  This allows developers to retrieve data from the debounced function when it resolves.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDebounceFn/index.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { useDebounceFn } from '@vueuse/core'\n\nconst debouncedRequest = useDebounceFn(() => 'response', 1000)\n\ndebouncedRequest().then((value) => {\n  console.log(value) // 'response'\n})\n\n// or use async/await\nasync function doRequest() {\n  const value = await debouncedRequest()\n  console.log(value) // 'response'\n}\n```\n\n----------------------------------------\n\nTITLE: OnClickOutside directive with configuration\nDESCRIPTION: This Vue snippet extends the directive usage by allowing configuration via an array. The handler function closes a modal, and an additional object specifies the `ignore` option with an element reference. This demonstrates a more advanced use case involving the `ignore` option, similar to the component-based usage, with the component-based alternative.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onClickOutside/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { vOnClickOutside } from '@vueuse/components'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst modal = shallowRef(false)\n\nconst ignoreElRef = useTemplateRef<HTMLElement>('ignoreEl')\n\nconst onClickOutsideHandler = [\n  (ev) => {\n    console.log(ev)\n    modal.value = false\n  },\n  { ignore: [ignoreElRef] },\n]\n</script>\n\n<template>\n  <button @click=\"modal = true\">\n    Open Modal\n  </button>\n\n  <div ref=\"ignoreElRef\">\n    click outside ignore element\n  </div>\n\n  <div v-if=\"modal\" v-on-click-outside=\"onClickOutsideHandler\">\n    Hello World\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Configuring useCookies with Options\nDESCRIPTION: Illustrates how to initialize `useCookies` with optional parameters in TypeScript. It shows specifying dependent cookie names for reactivity and configuring options like `doNotParse` and `autoUpdateDependencies`. The returned object includes methods for cookie manipulation (`get`, `getAll`, `set`, `remove`) and change listening (`addChangeListener`, `removeChangeListener`).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useCookies/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst { get, getAll, set, remove, addChangeListener, removeChangeListener } = useCookies(['cookie-name'], { doNotParse: false, autoUpdateDependencies: false })\n```\n\n----------------------------------------\n\nTITLE: Ensuring SSR Safety with useEventListener (TypeScript)\nDESCRIPTION: Demonstrates how to safely use `useEventListener` with DOM-specific targets like `document` or `window` in applications using Server-Side Rendering (SSR). Wrapping the `useEventListener` call within the `onMounted` hook ensures it only executes on the client-side where DOM APIs are available, preventing potential errors during server rendering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventListener/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// onMounted will only be called in the client side, so it guarantees the DOM APIs are available.\nonMounted(() => {\n  useEventListener(document, 'keydown', (e) => {\n    console.log(e.key)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Equivalent whenever and watch Usage in TypeScript\nDESCRIPTION: Shows the equivalence between using whenever and Vue's watch function to respond when a reactive boolean 'ready' becomes true. This snippet helps clarify that whenever is a specialized shorthand for a watch with a truthy check. Dependencies include Vue's watch API. Inputs include a reactive boolean and a callback, with the output being triggered callback execution.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/whenever/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// this\nwhenever(ready, () => console.log(state))\n\n// is equivalent to:\nwatch(ready, (isReady) => {\n  if (isReady)\n    console.log(state)\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing useBase64 hook in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import and initialize the `useBase64` hook from the `@vueuse/core` library in a Vue 3 application. It shows the required imports and how to pass a reactive reference (a `shallowRef` containing a string in this case) to the hook to get a reactive base64 representation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBase64/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useBase64 } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst text = shallowRef('')\n\nconst { base64 } = useBase64(text)\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Variables in Composables\nDESCRIPTION: This snippet illustrates how to use `configurableWindow` to provide flexibility when working with global variables like `window`. This is useful for multi-window environments, testing mocks, and SSR. The example uses `useActiveElement` to demonstrate how to make the `window` object configurable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ConfigurableWindow } from '../_configurable'\nimport { defaultWindow } from '../_configurable'\nimport { useEventListener } from '../useEventListener'\n\nexport function useActiveElement<T extends HTMLElement>(\n  options: ConfigurableWindow = {},\n) {\n  const {\n    // defaultWindow = isClient ? window : undefined\n    window = defaultWindow,\n  } = options\n\n  let el: T\n\n  // skip when in Node.js environment (SSR)\n  if (window) {\n    useEventListener(window, 'blur', () => {\n      el = window?.document.activeElement\n    }, true)\n  }\n\n  /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking and Committing Ref State History in VueUse (TypeScript)\nDESCRIPTION: Demonstrates the initialization and basic usage of useManualRefHistory to track the history of a shallowRef number in a Vue.js application. Requires @vueuse/core and vue as dependencies. Functions commit, undo, and redo are provided for manual snapshotting and history navigation; 'history' stores past state objects, each with a snapshot and timestamp. Parameters: 'counter' is the reactive ref; commit() pushes a new snapshot. Input: mutation of counter.value. Output: updated history array with state changes and timestamps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst counter = shallowRef(0)\nconst { history, commit, undo, redo } = useManualRefHistory(counter)\n\ncounter.value += 1\ncommit()\n\nconsole.log(history.value)\n/* [\n  { snapshot: 1, timestamp: 1601912898062 },\n  { snapshot: 0, timestamp: 1601912898061 }\n] */\n```\n\n----------------------------------------\n\nTITLE: Import useWindowSize from VueUse (JavaScript)\nDESCRIPTION: Imports the `useWindowSize` composable from the `@vueuse/core` package. This composable provides reactive references to the window's width and height.  It returns an object with `width` and `height` properties, which are reactive refs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWindowSize/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useWindowSize } from '@vueuse/core'\n\nconst { width, height } = useWindowSize()\n```\n\n----------------------------------------\n\nTITLE: Using vElementVisibility as a Vue Directive\nDESCRIPTION: Example demonstrating how to use the element visibility functionality as a Vue directive. It shows both basic usage and advanced configuration with options like scrollTarget. The directive runs a callback function whenever visibility changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementVisibility/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vElementVisibility } from '@vueuse/components'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst isVisible = shallowRef(false)\n\nfunction onElementVisibility(state) {\n  isVisible.value = state\n}\n</script>\n\n<template>\n  <div v-element-visibility=\"onElementVisibility\">\n    {{ isVisible ? 'inside' : 'outside' }}\n  </div>\n\n  <!-- with options -->\n  <div ref=\"target\">\n    <div v-element-visibility=\"[onElementVisibility, { scrollTarget: target }]\">\n      {{ isVisible ? 'inside' : 'outside' }}\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing and using useOnline in JavaScript\nDESCRIPTION: This snippet demonstrates how to import the `useOnline` composable from `@vueuse/core` and use it to get the reactive online state.  The `online` variable will hold a reactive boolean value indicating whether the user is online.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOnline/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useOnline } from '@vueuse/core'\n\nconst online = useOnline()\n```\n\n----------------------------------------\n\nTITLE: Using useNavigatorLanguage Composable in Vue with TypeScript\nDESCRIPTION: This snippet demonstrates how to use the useNavigatorLanguage composable from the @vueuse/core package inside a Vue 3 component written in TypeScript. It shows how to import the necessary dependencies, initialize the composable within the setup function, and reactively watch for changes in the browser's language setting. The language property is exposed for use in the component's template or other logic. Dependencies include Vue 3 and @vueuse/core. Expected input: none; output: a reactive language property reflecting navigator.language. This implementation assumes the environment supports the Navigator API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNavigatorLanguage/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useNavigatorLanguage } from '@vueuse/core'\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  setup() {\n    const { language } = useNavigatorLanguage()\n\n    watch(language, () => {\n      // Listen to the value changing\n    })\n\n    return {\n      language,\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Intercepting Fetch After Receiving Response (VueUse TypeScript)\nDESCRIPTION: Utilizes the `afterFetch` option to intercept the response context (`ctx`) after the request completes successfully but before the reactive `data` property is updated. This hook allows modifying the response data or performing side effects.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useFetch(url, {\n  afterFetch(ctx) {\n    if (ctx.data.title === 'HxH')\n      ctx.data.title = 'Hunter x Hunter' // Modifies the response data\n\n    return ctx\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: useAxios with execute function, no immediate\nDESCRIPTION: When no URL is passed initially to `useAxios`, the default value for immediate is set to false. The `execute` function can then be used to trigger the request.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\n\nconst { execute } = useAxios()\nexecute(url)\n```\n\n----------------------------------------\n\nTITLE: Using onChanged Callback to Handle Dark Mode Changes\nDESCRIPTION: Provides an example of passing an onChanged callback to useDark, allowing full control over DOM updates, API calls, or other side effects whenever dark mode toggles. This facilitates custom reactions to user preference changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDark/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst isDark = useDark({\n  onChanged(dark: boolean) {\n    // update the dom, call the API or something\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using usePointer in JavaScript to Access Pointer Data\nDESCRIPTION: This snippet demonstrates the basic usage of the `usePointer` composable in JavaScript. It imports the `usePointer` function from the `@vueuse/core` library and uses it to track the pointer's x and y coordinates, pressure, and pointer type. The resulting `x`, `y`, `pressure`, and `pointerType` variables are reactive and will update whenever the pointer's state changes. No specific dependencies are required other than the `@vueuse/core` library and a running JavaScript environment. The output includes reactive properties representing the current pointer state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointer/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { usePointer } from '@vueuse/core'\n\nconst { x, y, pressure, pointerType } = usePointer()\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Reconnection Parameters with useEventSource in JavaScript\nDESCRIPTION: Demonstrates advanced autoReconnect options by specifying number of retries, delay between attempts (in milliseconds), and a callback function onFailed that triggers when all reconnection attempts fail. This snippet enables fine-tuned control over reconnection behavior and error handling strategies while managing SSE connections.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventSource/index.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst { status, data, close } = useEventSource('https://event-source-url', [], {\n  autoReconnect: {\n    retries: 3,\n    delay: 1000,\n    onFailed() {\n      alert('Failed to connect EventSource after 3 retries')\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using useMemoize for Asynchronous Function Caching in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `useMemoize` to cache results from an asynchronous function (e.g., an Axios GET request). Subsequent calls with the same arguments retrieve cached data or promises. It also shows the `load`, `delete`, and `clear` methods provided by the memoized function for cache management. Requires `@vueuse/core` and an HTTP client like `axios`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMemoize/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMemoize } from '@vueuse/core'\n\nconst getUser = useMemoize(\n  async (userId: number): Promise<UserData> =>\n    axios.get(`users/${userId}`).then(({ data }) => data),\n)\n\nconst user1 = await getUser(1) // Request users/1\nconst user2 = await getUser(2) // Request users/2\n// ...\nconst user1 = await getUser(1) // Retrieve from cache\n\n// ...\nconst user1 = await getUser.load(1) // Request users/1\n\n// ...\ngetUser.delete(1) // Delete cache from user 1\ngetUser.clear() // Clear full cache\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useEventListener (JavaScript)\nDESCRIPTION: Demonstrates the fundamental usage of `useEventListener` to attach a 'visibilitychange' event listener to the global `document` object. The listener automatically cleans up when the component unmounts. Requires importing `useEventListener` from '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventListener/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useEventListener } from '@vueuse/core'\n\nuseEventListener(document, 'visibilitychange', (evt) => {\n  console.log(evt)\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Web Notification Events (TypeScript)\nDESCRIPTION: This snippet illustrates how to handle events triggered by a web notification, such as click, show, error, and close. It utilizes the `onClick`, `onShow`, `onError`, and `onClose` functions provided by `useWebNotification`. Each function takes a callback that receives an event object containing information about the respective event. These events allow developers to handle interactions and lifecycle changes for web notifications, enabling user interaction, handling potential errors, and monitoring notification state. It relies on the `@vueuse/core` library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebNotification/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nonClick((evt: Event) => {\n  // Do something with the notification on:click event...\n})\n\nonShow((evt: Event) => {\n  // Do something with the notification on:show event...\n})\n\nonError((evt: Event) => {\n  // Do something with the notification on:error event...\n})\n\nonClose((evt: Event) => {\n  // Do something with the notification on:close event...\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useDark with VueUse\nDESCRIPTION: Demonstrates how to import useDark and useToggle from VueUse, create a reactive dark mode state, and toggle its value. This pattern provides a simple way to manage dark mode in Vue.js components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDark/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useDark, useToggle } from '@vueuse/core'\n\nconst isDark = useDark()\nconst toggleDark = useToggle(isDark)\n```\n\n----------------------------------------\n\nTITLE: Integrating useMousePressed with the UseMousePressed Component in Vue\nDESCRIPTION: This snippet displays useMousePressed usage via the <UseMousePressed> Vue component, utilizing a scoped slot to expose the pressed value to the template. It enables declarative UI patterns for reactive mouse or touch press detection within a template. Requires Vue and a registered UseMousePressed component, outputting the pressed state as a slot prop.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMousePressed/index.md#_snippet_3\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseMousePressed v-slot=\"{ pressed }\">\n    Is Pressed: {{ pressed }}\n  </UseMousePressed>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Ignoring Repeated Key Events with onKeyStroke\nDESCRIPTION: Demonstrates how to prevent multiple triggers when a key is held down by using the 'dedupe' option set to true. Suitable for scenarios where only the initial key press should activate the handler. Depends on @vueuse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { onKeyStroke } from '@vueuse/core'\n\n// use `autoRepeat` option\nonKeyStroke('A', (e) => {\n  console.log('Key A pressed')\n}, { dedupe: true })\n```\n\n----------------------------------------\n\nTITLE: useAxios with Axios Instance and Config\nDESCRIPTION: This example extends the previous one by adding a configuration object to the useAxios call, specifically setting the HTTP method to 'POST'. It combines the reusability of an Axios instance with request-specific configurations. `data` and `isFinished` provide the response data and completion status respectively.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\nimport axios from 'axios'\n\nconst instance = axios.create({\n  baseURL: '/api',\n})\n\nconst { data, isFinished } = useAxios('/posts', { method: 'POST' }, instance)\n```\n\n----------------------------------------\n\nTITLE: Handling v-if Conditional Rendering with useFocusTrap (Vue/TypeScript)\nDESCRIPTION: Explains how to properly activate `useFocusTrap` on elements rendered conditionally with `v-if` by waiting for the DOM update cycle using `nextTick`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { nextTick, useTemplateRef } from 'vue'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { ref } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst { activate, deactivate } = useFocusTrap(target, { immediate: true })\n\nconst show = ref(false)\n\nasync function reveal() {\n  show.value = true\n\n  await nextTick()\n  activate()\n}\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div>\n    <div v-if=\"show\" ref=\"target\">\n      ...\n    </div>\n\n    <button @click=\"reveal\">\n      Reveal and Focus\n    </button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating Pre-configured useFetch Instance (VueUse TypeScript)\nDESCRIPTION: Uses `createFetch` to generate a custom `useFetch` function with predefined options, such as a base URL and common interceptors (like adding authentication headers). This creates reusable fetch instances for specific API endpoints.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst useMyFetch = createFetch({\n  baseUrl: 'https://my-api.com',\n  options: {\n    async beforeFetch({ options }) {\n      const myToken = await getMyToken()\n      options.headers.Authorization = `Bearer ${myToken}`\n\n      return { options }\n    },\n  },\n  fetchOptions: {\n    mode: 'cors',\n  },\n})\n\nconst { isFetching, error, data } = useMyFetch('users')\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFind with a Reactive Array in VueUse (JavaScript)\nDESCRIPTION: Illustrates how `useArrayFind` works with a `reactive` array. Initially, no positive value exists, so the result is `undefined`. When a positive value (1) is pushed into the reactive array, `useArrayFind` automatically re-evaluates, and the `positive` ref updates to the newly found value (1).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFind/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { useArrayFind } from '@vueuse/core'\n\nconst list = reactive([-1, -2])\nconst positive = useArrayFind(list, val => val > 0)\n// positive.value: undefined\nlist.push(1)\n// positive.value: 1\n```\n\n----------------------------------------\n\nTITLE: Debouncing Function with useDebounceFn\nDESCRIPTION: This snippet demonstrates basic usage of `useDebounceFn` to debounce a function. It imports the `useDebounceFn` and `useEventListener` functions from `@vueuse/core`. It then creates a debounced function `debouncedFn` that executes an anonymous function after a delay of 1000 milliseconds. Finally, it uses `useEventListener` to attach the debounced function to the `resize` event of the window.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDebounceFn/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useDebounceFn, useEventListener } from '@vueuse/core'\n\nconst debouncedFn = useDebounceFn(() => {\n  // do something\n}, 1000)\n\nuseEventListener(window, 'resize', debouncedFn)\n```\n\n----------------------------------------\n\nTITLE: Using OnClickOutside Renderless Component from @vueuse/components in Vue (vue)\nDESCRIPTION: Illustrates usage of the OnClickOutside renderless component from @vueuse/components, which automatically handles element binding internally. The example defines a close function triggered on the component's 'trigger' event and wraps content inside the <OnClickOutside> component. This simplifies attaching outside click detection without manual ref handling.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/components.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { OnClickOutside } from '@vueuse/components'\n\nfunction close() {\n  /* ... */\n}\n</script>\n\n<template>\n  <OnClickOutside @trigger=\"close\">\n    <div>\n      Click Outside of Me\n    </div>\n  </OnClickOutside>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Firebase Auth in Vue with TypeScript\nDESCRIPTION: This Vue and TypeScript snippet demonstrates integrating Firebase authentication using the VueUse useAuth composable. It initializes the Firebase app, sets up authentication with getAuth, and creates reactive isAuthenticated and user states. The signIn method uses GoogleAuthProvider and signInWithPopup; the template displays the user or a sign-in button based on authentication status. Required dependencies: @vueuse/firebase, firebase/app, firebase/auth, and Vue 3 composition API. Configuration input is required for Firebase initialization, and outputs include real-time authentication state and user information.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useAuth/index.md#_snippet_0\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useAuth } from '@vueuse/firebase/useAuth'\nimport { initializeApp } from 'firebase/app'\nimport { getAuth, GoogleAuthProvider, signInWithPopup } from 'firebase/auth'\n\nconst app = initializeApp({ /* config */ })\nconst auth = getAuth(app)\nconst { isAuthenticated, user } = useAuth(auth)\n\nconst signIn = () => signInWithPopup(auth, new GoogleAuthProvider())\n</script>\n\n<template>\n  <pre v-if=\"isAuthenticated\">{{ user }}</pre>\n  <div v-else>\n    <button @click=\"signIn\">\n      Sign In with Google\n    </button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Battery API Reactively with VueUse Composable in JavaScript\nDESCRIPTION: Demonstrates how to import the useBattery composable from @vueuse/core to obtain real-time reactive information about device charging status, charging time, discharging time, and battery level. Requires @vueuse/core as a dependency. Key properties such as charging, chargingTime, dischargingTime, and level are destructured from the composable result. Inputs are internal device battery properties; outputs are reactive variables representing those states. This pattern is suitable for pure JavaScript or composition API-based Vue applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBattery/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useBattery } from '@vueuse/core'\n\nconst { charging, chargingTime, dischargingTime, level } = useBattery()\n```\n\n----------------------------------------\n\nTITLE: Using structuredClone with useRefHistory\nDESCRIPTION: Demonstrates how to use a custom clone function like structuredClone to handle more complex objects when tracking history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRefHistory } from '@vueuse/core'\n\nconst refHistory = useRefHistory(target, { clone: structuredClone })\n```\n\n----------------------------------------\n\nTITLE: onClickOutside with controls option\nDESCRIPTION: This TypeScript snippet showcases the usage of `onClickOutside` with the `controls` option. This allows the user to manually control the handler's triggering and cancellation. It returns `cancel` and `trigger` functions. Dependencies are `@vueuse/core`. The `cancel` function stops the handler, and `trigger` manually calls the handler.  This example demonstrates canceling the handler and potentially re-triggering it based on a `pointermove` event.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onClickOutside/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst { cancel, trigger } = onClickOutside(\n  modalRef,\n  (event) => {\n    modal.value = false\n  },\n  { controls: true },\n)\n\nuseEventListener('pointermove', (e) => {\n  cancel()\n  // or\n  trigger(e)\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useSpeechSynthesis in TypeScript\nDESCRIPTION: Demonstrates how to import and use the useSpeechSynthesis composable from VueUse, showing the available returned properties and methods including playback controls and status information.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSpeechSynthesis/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useSpeechSynthesis } from '@vueuse/core'\n\nconst {\n  isSupported,\n  isPlaying,\n  status,\n  voiceInfo,\n  utterance,\n  error,\n  stop,\n\n  toggle,\n  speak,\n} = useSpeechSynthesis()\n```\n\n----------------------------------------\n\nTITLE: Throttling Ref Value with refThrottled - JavaScript\nDESCRIPTION: This snippet demonstrates how to throttle a ref value using the `refThrottled` function from `@vueuse/core`. It initializes a shallow ref called `input` and then creates a throttled ref `throttled` that updates no more frequently than every 1000ms. Requires `vue` and `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refThrottled/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { refThrottled } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst input = shallowRef('')\nconst throttled = refThrottled(input, 1000)\n```\n\n----------------------------------------\n\nTITLE: Tracking Evaluation State of Async Computed with computedAsync in Vue (JavaScript)\nDESCRIPTION: Illustrates how to pass an evaluation state ref to computedAsync so that you can track whether the asynchronous computation is currently running. This enables UI components to react to the loading state of your async operation. Dependencies: @vueuse/core, vue. Parameters: evaluating (ref), async function, initial state, evaluating ref. Input: async operation trigger. Output: computed async value and evaluation state indicator.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedAsync/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { computedAsync } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst evaluating = shallowRef(false)\n\nconst userInfo = computedAsync(\n  async () => { /* your logic */ },\n  null,\n  evaluating,\n)\n```\n\n----------------------------------------\n\nTITLE: Attaching vMouseInElement Directive with Event Handler in Vue Using TypeScript\nDESCRIPTION: This example illustrates applying the vMouseInElement directive from @vueuse/components to an HTML element to reactively monitor comprehensive mouse information. It defines a TypeScript interface describing the event payload containing various mouse metrics (coordinates, source type, element dimensions, and outside status), and a handler function that logs these values. The directive usage in the template supports optional configuration options such as handling outside mouse events, providing flexible mouse input control tied to DOM elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouseInElement/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\\nimport { vMouseInElement } from '@vueuse/components'\\nimport { UseMouseSourceType } from '@vueuse/core'\\n\\ninterface MouseInElementType {\\n  x: number\\n  y: number\\n  sourceType: UseMouseSourceType\\n  elementX: number\\n  elementY: number\\n  elementPositionX: number\\n  elementPositionY: number\\n  elementHeight: number\\n  elementWidth: number\\n  isOutside: boolean\\n}\\n\\nconst options = {\\n  handleOutside: true\\n}\\nfunction onMouseInElement({ x, y, sourceType, elementX, elementY, elementPositionX, elementPositionY, elementHeight, elementWidth, isOutside }: MouseInElementType) {\\n  console.log(x, y, sourceType, elementX, elementY, elementPositionX, elementPositionY, elementHeight, elementWidth, isOutside)\\n}\\n</script>\\n\\n<template>\\n  <textarea v-mouse-in-element=\"onMouseInElement\" />\\n  <!-- with options -->\\n  <textarea v-mouse-in-element=\"[onMouseInElement, options]\" />\\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useParallax in a Vue 3 Composition API component\nDESCRIPTION: This snippet shows how to import and set up the useParallax hook from VueUse within a Vue 3 <script setup> block. It demonstrates creating a ref for the container element and extracting the tilt, roll, and source reactive data to be used in the template for a parallax effect.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useParallax/index.md#_snippet_0\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup>\nimport { useParallax } from '@vueuse/core'\n\nconst container = ref(null)\nconst { tilt, roll, source } = useParallax(container)\n</script>\n```\n\n----------------------------------------\n\nTITLE: onLongPress Function Usage in Vue\nDESCRIPTION: This snippet demonstrates how to use the `onLongPress` function from `@vueuse/core` to detect long press events on a button element. It utilizes `useTemplateRef` to reference the button and updates a reactive variable when the long press is detected. Modifiers are used to prevent default behavior.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onLongPress/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { onLongPress } from '@vueuse/core'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst htmlRefHook = useTemplateRef<HTMLElement>('htmlRefHook')\nconst longPressedHook = shallowRef(false)\n\nfunction onLongPressCallbackHook(e: PointerEvent) {\n  longPressedHook.value = true\n}\nfunction resetHook() {\n  longPressedHook.value = false\n}\n\nonLongPress(\n  htmlRefHook,\n  onLongPressCallbackHook,\n  {\n    modifiers: {\n      prevent: true\n    }\n  }\n)\n</script>\n\n<template>\n  <p>Long Pressed: {{ longPressedHook }}</p>\n\n  <button ref=\"htmlRefHook\" class=\"ml-2 button small\">\n    Press long\n  </button>\n\n  <button class=\"ml-2 button small\" @click=\"resetHook\">\n    Reset\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useShare with basic options - JavaScript\nDESCRIPTION: Demonstrates importing and using the `useShare` composable to trigger the Web Share API with static title, text, and URL options. It destructures the `share` function and `isSupported` flag from the hook. The `share` method is called within a function, emphasizing the need for a user gesture.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useShare/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useShare } from '@vueuse/core'\n\nconst { share, isSupported } = useShare()\n\nfunction startShare() {\n  share({\n    title: 'Hello',\n    text: 'Hello my friend!',\n    url: location.href,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: useWebSocket with advanced autoReconnect configuration\nDESCRIPTION: This code illustrates the configuration of more advanced options for the `autoReconnect` feature.  It allows specifying the number of retries, the delay between reconnection attempts, and a callback function to execute when the connection fails after multiple retries. Dependencies include `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst { status, data, close } = useWebSocket('ws://websocketurl', {\n  autoReconnect: {\n    retries: 3,\n    delay: 1000,\n    onFailed() {\n      alert('Failed to connect WebSocket after 3 retries')\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useElementHover with Vue Template Ref\nDESCRIPTION: This snippet demonstrates how to use the useElementHover function with a template ref to track a button's hover state. It imports the necessary functions from VueUse and Vue, creates a template ref, and uses it to monitor hover status.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementHover/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useElementHover } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst myHoverableElement = useTemplateRef<HTMLButtonElement>('myHoverableElement')\nconst isHovered = useElementHover(myHoverableElement)\n</script>\n\n<template>\n  <button ref=\"myHoverableElement\">\n    {{ isHovered }}\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing SSE Connection with useEventSource in JavaScript\nDESCRIPTION: Demonstrates the basic initialization of an EventSource connection using the useEventSource composable from @vueuse/core. It opens a persistent connection to a provided URL and returns reactive status, data, error, and close function. No additional options or named events are specified in this usage example.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventSource/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useEventSource } from '@vueuse/core'\n\nconst { status, data, error, close } = useEventSource('https://event-source-url')\n```\n\n----------------------------------------\n\nTITLE: Using useArrayDifference with reactive arrays for relative complement\nDESCRIPTION: A basic example demonstrating how to use useArrayDifference to compute the difference between two reactive arrays. The result updates reactively when the source arrays change, returning elements from the first array that are not in the second.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayDifference/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayDifference } from '@vueuse/core'\n\nconst list1 = ref([0, 1, 2, 3, 4, 5])\nconst list2 = ref([4, 5, 6])\nconst result = useArrayDifference(list1, list2)\n// result.value: [0, 1, 2, 3]\nlist2.value = [0, 1, 2]\n// result.value: [3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Clamping Reactive Source Value with VueUse Math in TypeScript\nDESCRIPTION: This snippet explains how to clamp a reactive source number ref between static minimum and maximum values using useClamp, ensuring the clamped computed ref updates whenever the source ref changes. Dependencies include Vue's shallowRef and useClamp from @vueuse/math. The input is a reactive ref number initialized at 0, clamped between 0 and 10, with the output being a computed ref that reacts to number changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useClamp/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useClamp } from '@vueuse/math'\n\nconst number = shallowRef(0)\nconst clamped = useClamp(number, 0, 10)\n```\n\n----------------------------------------\n\nTITLE: Using useMediaQuery with SSR in JavaScript\nDESCRIPTION: This snippet shows how to use `useMediaQuery` in a Server-Side Rendering (SSR) context.  It addresses potential hydration mismatches by specifying an `ssrWidth` option. The `ssrWidth` option defines the screen width that should be used on the server side before hydration.  It requires the VueUse library and `@vueuse/core`. In this case, the `isLarge` variable will be `false` because the screen is treated as being 768px wide before hydration.  On the client side, the value is updated based on the actual screen size. The `onMounted` lifecycle hook demonstrates client-side reactivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMediaQuery/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { breakpointsTailwind, useMediaQuery } from '@vueuse/core'\n\nconst isLarge = useMediaQuery(\n  '(min-width: 1024px)',\n  { ssrWidth: 768 } // Will enable SSR mode and render like if the screen was 768px wide\n)\n\nconsole.log(isLarge.value) // always false because ssrWidth of 768px is smaller than 1024px\nonMounted(() => {\n  console.log(isLarge.value) // false if screen is smaller than 1024px, true if larger than 1024px\n})\n```\n\n----------------------------------------\n\nTITLE: Component Usage of useObjectUrl - Vue\nDESCRIPTION: This snippet shows how to use the `UseObjectUrl` component, which is an alternative to the composable function.  It takes an `object` prop (in this case `file`) and provides the URL through a slot. This simplifies the setup compared to the composable. Requires Vue 3 and @vueuse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useObjectUrl/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseObjectUrl v-slot=\"url\" :object=\"file\">\n    <a :href=\"url\">Open file</a>\n  </UseObjectUrl>\n</template>\n\n```\n\n----------------------------------------\n\nTITLE: Implementing 'onStartTyping' in Vue Component\nDESCRIPTION: This code snippet showcases how to use the 'onStartTyping' composable from '@vueuse/core' within a Vue 3 component setup function to detect when a user begins typing and automatically focus an input element. Dependencies include Vue and '@vueuse/core'. Key parameters include the callback function triggered on typing start, which checks if the input is active and focuses it if not. It demonstrates practical input focus management based on user activity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onStartTyping/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onStartTyping } from '@vueuse/core'\n\nexport default {\n  setup() {\n    const input = ref(null)\n\n    onStartTyping(() => {\n      if (!input.value.active)\n        input.value.focus()\n    })\n\n    return {\n      input,\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Instance Option Combination (VueUse TypeScript)\nDESCRIPTION: Explains the `combination` option in `createFetch`, which determines how options defined in the `createFetch` instance merge with options provided when calling the instance (`useMyFetch('url', options)`). The example shows `overwrite` mode.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst useMyFetch = createFetch({\n  baseUrl: 'https://my-api.com',\n  combination: 'overwrite',\n  options: {\n    // beforeFetch in pre-configured instance will only run when the newly spawned instance do not pass beforeFetch\n    async beforeFetch({ options }) {\n      const myToken = await getMyToken()\n      options.headers.Authorization = `Bearer ${myToken}`\n\n      return { options }\n    },\n  },\n})\n\n// use useMyFetch beforeFetch\nconst { isFetching, error, data } = useMyFetch('users')\n\n// use custom beforeFetch\nconst { isFetching, error, data } = useMyFetch('users', {\n  async beforeFetch({ url, options, cancel }) {\n    const myToken = await getMyToken()\n\n    if (!myToken)\n      cancel()\n\n    options.headers = {\n      ...options.headers,\n      Authorization: `Bearer ${myToken}`,\n    }\n\n    return {\n      options,\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring useElementVisibility with rootMargin Option\nDESCRIPTION: Example demonstrating how to use the rootMargin option with useElementVisibility to trigger visibility detection before an element is fully visible in the viewport. This allows for preloading or preparing content before it's fully in view.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementVisibility/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst targetIsVisible = useElementVisibility(target, {\n  rootMargin: '0px 0px 100px 0px',\n})\n```\n\n----------------------------------------\n\nTITLE: Using watchPausable to Control Vue Watchers in TypeScript\nDESCRIPTION: This example demonstrates how to use the watchPausable function from VueUse to watch a source ref with the ability to pause and resume the watcher. It includes importing necessary functions, creating a reactive reference, setting up the watcher, and demonstrating the pause/resume functionality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchPausable/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchPausable } from '@vueuse/core'\nimport { nextTick, shallowRef } from 'vue'\n\nconst source = shallowRef('foo')\n\nconst { stop, pause, resume } = watchPausable(\n  source,\n  v => console.log(`Changed to ${v}!`),\n)\n\nsource.value = 'bar'\nawait nextTick() // Changed to bar!\n\npause()\n\nsource.value = 'foobar'\nawait nextTick() // (nothing happend)\n\nresume()\n\nsource.value = 'hello'\nawait nextTick() // Changed to hello!\n```\n\n----------------------------------------\n\nTITLE: Basic usage of useSubject with RxJS Subject in Vue\nDESCRIPTION: Demonstrates how to bind an RxJS Subject to a ref using useSubject. This creates a reactive reference that stays synchronized with the Subject's emissions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useSubject/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useSubject } from '@vueuse/rxjs'\nimport { Subject } from 'rxjs'\n\nconst subject = new Subject()\n\n// setup()\nconst subjectRef = useSubject(subject)\n```\n\n----------------------------------------\n\nTITLE: Using useKeyModifier to Track Modifier State in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import and initialize the useKeyModifier hook to monitor the state of the 'CapsLock' key. It shows the basic usage, accessing the reactive state to check if the key is active.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useKeyModifier/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useKeyModifier } from '@vueuse/core'\n\nconst capsLockState = useKeyModifier('CapsLock')\n\nconsole.log(capsLockState.value)\n```\n\n----------------------------------------\n\nTITLE: Disable default drag behavior with preventDefault (TS)\nDESCRIPTION: This code snippet shows how to disable the default drag-and-drop behavior of certain elements (e.g., images) using the `preventDefault` option in `useDraggable`.  Setting `preventDefault` to `true` allows the user to fully control the dragging behavior without browser interference.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDraggable/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { x, y, style } = useDraggable(el, {\n  preventDefault: true,\n  // with `preventDefault: true`\n  // you can disable the native behavior (e.g., for img)\n  // and control the drag-and-drop, preventing the browser interference.\n})\n```\n\n----------------------------------------\n\nTITLE: Using the v-infinite-scroll Directive in Vue Templates\nDESCRIPTION: Illustrates using the `v-infinite-scroll` directive from `@vueuse/components` directly within a Vue template for a simpler infinite scroll implementation. The directive takes the `onLoadMore` function as its primary value. Optional configuration, including `distance` and the crucial `canLoadMore` function, can be passed as an array alongside the handler.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useInfiniteScroll/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vInfiniteScroll } from '@vueuse/components'\nimport { ref } from 'vue'\n\nconst data = ref([1, 2, 3, 4, 5, 6])\n\nfunction onLoadMore() {\n  const length = data.value.length + 1\n  data.value.push(...Array.from({ length: 5 }, (_, i) => length + i))\n}\nfunction canLoadMore() {\n  // inidicate when there is no more content to load so onLoadMore stops triggering\n  // if (noMoreContent) return false\n  return true // for demo purposes\n}\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div v-infinite-scroll=\"onLoadMore\">\n    <div v-for=\"item in data\" :key=\"item\">\n      {{ item }}\n    </div>\n  </div>\n\n  <!-- with options -->\n  <div v-infinite-scroll=\"[onLoadMore, { distance: 10, canLoadMore }]\">\n    <div v-for=\"item in data\" :key=\"item\">\n      {{ item }}\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Vue Component for Displaying Reactive Virtual List\nDESCRIPTION: This Vue template demonstrates how to display a toggleable list of even or odd items using the useVirtualList composable within a component. It includes buttons to toggle filtering and binds virtual list properties to DOM elements for efficient rendering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_3\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <p>Showing {{ isEven ? 'even' : 'odd' }} items</p>\n  <button @click=\"toggle\">\n    Toggle Even/Odd\n  </button>\n  <div v-bind=\"containerProps\" style=\"height: 300px\">\n    <div v-bind=\"wrapperProps\">\n      <div v-for=\"item in list\" :key=\"item.index\" style=\"height: 22px\">\n        Row: {{ item.data }}\n      </div>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Handling Named Events with useEventSource in TypeScript\nDESCRIPTION: Shows how to specify named server-sent events to listen for by passing an array of event names as the second parameter to useEventSource. This approach allows subscribing to specific custom events (e.g., 'notice', 'update') emitted by the server, enhancing event granularity and control. The snippet is written in TypeScript and uses type assertions for the event names array.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventSource/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useEventSource } from '@vueuse/core'\n\nconst { event, data } = useEventSource('https://event-source-url', ['notice', 'update'] as const)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Disabling Key Handling in TypeScript\nDESCRIPTION: Demonstrates how to avoid trigger of key events when the user focuses on input or textarea elements by combining 'useActiveElement' and 'logicAnd'. It ensures the shortcuts do not activate inside form controls.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useActiveElement, useMagicKeys, whenever } from '@vueuse/core'\nimport { logicAnd } from '@vueuse/math'\n\nconst activeElement = useActiveElement()\nconst notUsingInput = computed(() =>\n  activeElement.value?.tagName !== 'INPUT'\n  && activeElement.value?.tagName !== 'TEXTAREA')\n\nconst { tab } = useMagicKeys()\n\nwhenever(logicAnd(tab, notUsingInput), () => {\n  console.log('Tab has been pressed outside of inputs!')\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useScroll with Vue\nDESCRIPTION: Demonstrates how to implement useScroll in a Vue component to track scroll position and state of an element. Returns reactive properties including coordinates, scrolling state, arrival state, and directions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScroll/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useScroll } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst { x, y, isScrolling, arrivedState, directions } = useScroll(el)\n</script>\n\n<template>\n  <div ref=\"el\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useDateFormat with Localization\nDESCRIPTION: Shows how to format dates with localization by providing the 'locales' option to useDateFormat. This example formats the current date with day of week in US English format.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDateFormat/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useDateFormat, useNow } from '@vueuse/core'\n\nconst formatted = useDateFormat(useNow(), 'YYYY-MM-DD (ddd)', { locales: 'en-US' })\n</script>\n\n<template>\n  <div>{{ formatted }}</div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Textarea Autosize with VueUse\nDESCRIPTION: Demonstrates the basic setup for `useTextareaAutosize` in a Vue 3 component using script setup. It initializes the composable, obtains refs for the textarea element and its input model, and binds them in the template. The `resize-none` class prevents manual resizing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextareaAutosize/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nconst { textarea, input } = useTextareaAutosize()\n</script>\n\n<template>\n  <textarea\n    ref=\"textarea\"\n    v-model=\"input\"\n    class=\"resize-none\"\n    placeholder=\"What's on your mind?\"\n  />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useThrottledRefHistory in VueUse with TypeScript\nDESCRIPTION: This snippet shows how to use the useThrottledRefHistory composable from the '@vueuse/core' package alongside Vue's shallowRef to manage the history of a reactive state variable in a Vue application. The example demonstrates tracking a numeric counter and initializing undo/redo handlers, with a throttling option set to 1000 milliseconds to limit how frequently state snapshots are captured. Dependencies include Vue 3 and VueUse; key parameters include the reactive reference and options object ({ deep: true, throttle: 1000 }). Input is a reactive ref; output provides access to history tracking and undo/redo methods; this is optimal for use cases where excessive snapshotting should be avoided. The function assumes Vue reactivity and will not work with plain JavaScript variables.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useThrottledRefHistory/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useThrottledRefHistory } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst counter = shallowRef(0)\nconst { history, undo, redo } = useThrottledRefHistory(counter, { deep: true, throttle: 1000 })\n```\n\n----------------------------------------\n\nTITLE: Joining with Reactive Separator using useArrayJoin in VueUse (JavaScript)\nDESCRIPTION: This example shows how to use a reactive separator in conjunction with useArrayJoin. By making both the input array and the separator reactive, any change to the separator or the array immediately updates the joined string. This is especially useful when the delimiter needs to be dynamic (e.g., user-toggled). Dependencies are Vue's ref API and @vueuse/core; key parameters are a ref array and a ref separator; the output is a reactive computed string.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayJoin/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayJoin } from '@vueuse/core'\n\nconst list = ref(['string', 0, { prop: 'val' }])\nconst separator = ref()\nconst result = useArrayJoin(list, separator)\n// result.value: string,0,[object Object]\nseparator.value = ''\n// result.value: string0[object Object]\nseparator.value = '--'\n// result.value: string--0--[object Object]\n```\n\n----------------------------------------\n\nTITLE: Using useCycleList to Navigate Through a List in TypeScript\nDESCRIPTION: Example demonstrates initializing useCycleList with an array of strings and using its methods to navigate through the list. The code shows how to access the current state, move to the previous item (which cycles to the end of the list), and jump to a specific position in the list.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCycleList/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useCycleList } from '@vueuse/core'\n\nconst { state, next, prev, go } = useCycleList([\n  'Dog',\n  'Cat',\n  'Lizard',\n  'Shark',\n  'Whale',\n  'Dolphin',\n  'Octopus',\n  'Seal',\n])\n\nconsole.log(state.value) // 'Dog'\n\nprev()\n\nconsole.log(state.value) // 'Seal'\n\ngo(3)\n\nconsole.log(state.value) // 'Shark'\n```\n\n----------------------------------------\n\nTITLE: useWebSocket specifying sub-protocols\nDESCRIPTION: This code snippet shows how to specify the WebSocket sub-protocols to use during the connection.  The `protocols` option accepts an array of strings representing the desired sub-protocols. Dependencies include `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useWebSocket } from '@vueuse/core'\n\nconst { status, data, send, open, close } = useWebSocket('ws://websocketurl', {\n  protocols: ['soap'], // ['soap', 'wamp']\n})\n```\n\n----------------------------------------\n\nTITLE: Basic usage of useIdle function in VueUse with JavaScript\nDESCRIPTION: This snippet demonstrates importing the useIdle function from VueUse, initializing it with a 5-minute timeout, and logging whether the user is idle. It provides a fundamental method to monitor user activity status within a Vue component or script.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useIdle/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useIdle } from '@vueuse/core'\n\nconst { idle, lastActive } = useIdle(5 * 60 * 1000) // 5 min\n\nconsole.log(idle.value) // true or false\n```\n\n----------------------------------------\n\nTITLE: Handling Default Value Merging in VueUse useStorage with TypeScript\nDESCRIPTION: Illustrates the default behavior and options for merging default values with existing stored values when using useStorage. By default, stored values override defaults, potentially leading to missing keys. This snippet shows setting storage directly and retrieving the ref value that may be undefined for missing keys. It then demonstrates enabling a shallow merge via the mergeDefaults boolean option and custom merge through a user-provided function, allowing deep merge strategies. This requires TypeScript support and assumes a utility function like deepMerge is defined for custom merging.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStorage/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nlocalStorage.setItem('my-store', '{\"hello\": \"hello\"}')\n\nconst state = useStorage('my-store', { hello: 'hi', greeting: 'hello' }, localStorage)\n\nconsole.log(state.value.greeting) // undefined, since the value is not presented in storage\n```\n\nLANGUAGE: ts\nCODE:\n```\nlocalStorage.setItem('my-store', '{\"hello\": \"nihao\"}')\n\nconst state = useStorage(\n  'my-store',\n  { hello: 'hi', greeting: 'hello' },\n  localStorage,\n  { mergeDefaults: true } // <--\n)\n\nconsole.log(state.value.hello) // 'nihao', from storage\nconsole.log(state.value.greeting) // 'hello', from merged default value\n```\n\nLANGUAGE: ts\nCODE:\n```\nconst state = useStorage(\n  'my-store',\n  { hello: 'hi', greeting: 'hello' },\n  localStorage,\n  { mergeDefaults: (storageValue, defaults) => deepMerge(defaults, storageValue) } // <--\n)\n```\n\n----------------------------------------\n\nTITLE: Handling Gamepad Connect/Disconnect Events\nDESCRIPTION: This TypeScript snippet shows how to handle gamepad connect and disconnect events using `onConnected` and `onDisconnected` from `useGamepad`.  It imports `useGamepad`.  It logs messages to the console when a gamepad connects or disconnects. Requires VueUse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGamepad/index.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst { gamepads, onConnected, onDisconnected } = useGamepad()\n\nonConnected((index) => {\n  console.log(`${gamepads.value[index].id} connected`)\n})\n\nonDisconnected((index) => {\n  console.log(`${index} disconnected`)\n})\n```\n\n----------------------------------------\n\nTITLE: Caching a Vue Ref with a Custom Comparator using VueUse (TypeScript)\nDESCRIPTION: This TypeScript example demonstrates how to cache a Vue ref object using the useCached utility from the @vueuse/core library. It imports shallowRef from Vue to create a reactive reference, and then applies useCached to ensure the cached value only updates when a custom comparator function, which compares the value property of the ref, returns false. Dependencies include @vueuse/core and vue. The source ref is updated with new objects, but the cached value changes only when the value property differs, allowing for efficient reactive data handling. The snippet expects a Data interface, a source ref, and a comparator function as inputs, and outputs a cached ref object reflecting changes according to the custom comparator logic.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCached/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCached } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\ninterface Data {\n  value: number\n  extra: number\n}\n\nconst source = shallowRef<Data>({ value: 42, extra: 0 })\nconst cached = useCached(source, (a, b) => a.value === b.value)\n\nsource.value = {\n  value: 42,\n  extra: 1,\n}\n\nconsole.log(cached.value) // { value: 42, extra: 0 }\n\nsource.value = {\n  value: 43,\n  extra: 1,\n}\n\nconsole.log(cached.value) // { value: 43, extra: 1 }\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useCookies in a Vue Component\nDESCRIPTION: Demonstrates the common usage pattern for `useCookies` within a Vue 3 component's `setup` function. It imports `useCookies`, initializes it (optionally tracking specific cookies like 'locale'), and uses the returned methods (`get`, `getAll`, `set`) to interact with cookies in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useCookies/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport { useCookies } from '@vueuse/integrations/useCookies'\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  setup() {\n    const cookies = useCookies(['locale'])\n    return {\n      cookies,\n    }\n  },\n})\n</script>\n\n<template>\n  <div>\n    <strong>locale</strong>: {{ cookies.get('locale') }}\n    <hr>\n    <pre>{{ cookies.getAll() }}</pre>\n    <button @click=\"cookies.set('locale', 'ru-RU')\">\n      Russian\n    </button>\n    <button @click=\"cookies.set('locale', 'en-US')\">\n      English\n    </button>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Implementing OnClickOutside Component\nDESCRIPTION: This Vue snippet demonstrates using a component named `OnClickOutside` (presumably a custom component from the `vueuse` library).  The `@trigger` event is used to trigger a `count++` action.  The `:options` prop allows configuration, such as ignoring specific elements. No other dependencies are directly present within this snippet.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onClickOutside/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <OnClickOutside :options=\"{ ignore: [/* ... */] }\" @trigger=\"count++\">\n    <div>\n      Click Outside of Me\n    </div>\n  </OnClickOutside>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Customizing Cache Keys with useMemoize getKey Option in TypeScript\nDESCRIPTION: Shows how to customize the cache key generation by providing a `getKey` function in the `useMemoize` options. This allows control over which arguments contribute to the cache key, enabling scenarios like ignoring certain parameters (e.g., request headers) for caching purposes. Requires `@vueuse/core` and `axios` (or similar).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMemoize/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst getUser = useMemoize(\n  async (userId: number, headers: AxiosRequestHeaders): Promise<UserData> =>\n    axios.get(`users/${userId}`, { headers }).then(({ data }) => data),\n  {\n    // Use only userId to get/set cache and ignore headers\n    getKey: (userId, headers) => userId,\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Device Orientation Sensor with VueUse in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to import and invoke the useDeviceOrientation composable from the @vueuse/core library to obtain reactive state variables representing the device's physical orientation. The snippet exposes isAbsolute (boolean) indicating if the orientation data is absolute, and alpha, beta, gamma (numbers) representing degrees of rotation around the z, x, and y axes respectively. This requires a modern browser with support for the DeviceOrientationEvent and the @vueuse/core package installed. The reactive state can be used to respond to changes in device orientation within JavaScript-based Vue applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDeviceOrientation/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useDeviceOrientation } from '@vueuse/core'\n\nconst {\n  isAbsolute,\n  alpha,\n  beta,\n  gamma,\n} = useDeviceOrientation()\n```\n\n----------------------------------------\n\nTITLE: Importing useDeviceMotion in JavaScript\nDESCRIPTION: This JavaScript snippet imports the `useDeviceMotion` function from the `@vueuse/core` library. It provides access to device motion data such as acceleration, acceleration including gravity, rotation rate, and interval.  The code assumes the VueUse library is installed.  It does not take any parameters as it initializes and returns reactive values.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDeviceMotion/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useDeviceMotion } from '@vueuse/core'\n\nconst {\n  acceleration,\n  accelerationIncludingGravity,\n  rotationRate,\n  interval,\n} = useDeviceMotion()\n```\n\n----------------------------------------\n\nTITLE: Configuring useSortable with custom options and selectors\nDESCRIPTION: Example showing how to configure useSortable with custom selectors and options. Demonstrates using the handle class for drag handles and accessing the option method to get/set Sortable options.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useSortable/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useSortable } from '@vueuse/integrations/useSortable'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst list = shallowRef([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\n\nconst animation = 200\n\nconst { option } = useSortable(el, list, {\n  handle: '.handle',\n  // or option set\n  // animation\n})\n\n// You can use the option method to set and get the option of Sortable\noption('animation', animation)\n// option('animation') // 200\n</script>\n\n<template>\n  <div ref=\"el\">\n    <div v-for=\"item in list\" :key=\"item.id\">\n      <span>{{ item.name }}</span>\n      <span class=\"handle\">*</span>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Listening for a Single Key Using onKeyStroke in VueUse\nDESCRIPTION: Demonstrates how to set up a basic keyboard listener for a specific key ('ArrowDown') using onKeyStroke. It prevents the default action when the key is pressed. Dependencies include @vueuse/core. It requires importing onKeyStroke and attaching it within a Vue component setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { onKeyStroke } from '@vueuse/core'\n\nonKeyStroke('ArrowDown', (e) => {\n  e.preventDefault()\n})\n```\n\n----------------------------------------\n\nTITLE: Using useRouteQuery to access 'search' query parameter\nDESCRIPTION: This code imports the useRouteQuery hook from VueUse, retrieves the 'search' query parameter reactively, and demonstrates how to access its value. It shows basic retrieval of the query parameter from the current route.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteQuery/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useRouteQuery } from '@vueuse/router'\n\nconst search = useRouteQuery('search')\n```\n\n----------------------------------------\n\nTITLE: Creating Async Computed State with computedAsync in Vue (JavaScript)\nDESCRIPTION: Demonstrates the basic setup for creating an asynchronous computed property in a Vue application using computedAsync from @vueuse/core and shallowRef from vue. The mockLookUp async function is called whenever the reactive name reference changes, and the result is populated into userInfo. Dependencies: @vueuse/core, vue. Parameters: name (ref), initial state (null), the function to resolve user info. Input: reactive reference. Output: resolved async value or the initial state. Limitations: async dependencies accessed after the initial stack are not tracked for reactivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedAsync/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { computedAsync } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst name = shallowRef('jack')\n\nconst userInfo = computedAsync(\n  async () => {\n    return await mockLookUp(name.value)\n  },\n  null // initial state\n)\n```\n\n----------------------------------------\n\nTITLE: Using useToggle in Vue.js Templates with Caution\nDESCRIPTION: This snippet offers a word of caution when using the toggle function within Vue.js templates and event handlers. Specifically, it highlights the risk of inadvertently passing the event object to the toggle function, which can lead to unexpected behavior if not handled carefully. It shows how to trigger the toggle function with and without arguments within the template's @click event handler, showcasing the necessity of empty parentheses when calling the toggle function to prevent event object interference.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useToggle/index.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<!-- caution: $event will be pass in -->\n<button @click=\"toggleDark\" />\n<!-- recommended to do this -->\n<button @click=\"toggleDark()\" />\n```\n\n----------------------------------------\n\nTITLE: Watching DOM Mutations with useMutationObserver in Vue (TypeScript)\nDESCRIPTION: This snippet sets up a Vue component that uses useMutationObserver from @vueuse/core to monitor attribute changes on a DOM element identified via a template ref. It imports useMutationObserver, useTemplateRef, and Vue's ref API, and attaches an observer that appends the changed attribute's name to a reactive messages array. Dependencies include @vueuse/core and vue. The observer is configured with the attributes: true option, focusing on attribute mutations. Inputs are the observed element and a callback handling MutationRecord arrays; outputs are updates to the messages ref. Only the first mutation is processed per callback execution.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMutationObserver/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMutationObserver } from '@vueuse/core'\nimport { ref, useTemplateRef } from 'vue'\n\nexport default {\n  setup() {\n    const el = useTemplateRef('el')\n    const messages = ref([])\n\n    useMutationObserver(el, (mutations) => {\n      if (mutations[0])\n        messages.value.push(mutations[0].attributeName)\n    }, {\n      attributes: true,\n    })\n\n    return {\n      el,\n      messages,\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using Undo Functionality with useRefHistory\nDESCRIPTION: Demonstrates how to use the undo function to reset the ref value to the previous history point.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.log(counter.value) // 1\nundo()\nconsole.log(counter.value) // 0\n```\n\n----------------------------------------\n\nTITLE: Using useQRCode with static text\nDESCRIPTION: Example of using useQRCode to generate a QR code from a static text string. The function returns a ref containing a data URL representing the QR code.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useQRCode/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useQRCode } from '@vueuse/integrations/useQRCode'\n\n// `qrcode` will be a ref of data URL\nconst qrcode = useQRCode('text-to-encode')\n```\n\n----------------------------------------\n\nTITLE: Configuring useScroll with Offset Options\nDESCRIPTION: Shows how to configure useScroll with offset options to adjust when the arrivedState is triggered. The offset values determine the distance from edges when arrival state is considered true.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScroll/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst { x, y, isScrolling, arrivedState, directions } = useScroll(el, {\n  offset: { top: 30, bottom: 30, right: 30, left: 30 },\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Countdown Timer with useCountdown in Vue\nDESCRIPTION: Demonstrates the basic setup of the `useCountdown` composable. It imports the function, initializes a countdown with a fixed duration (e.g., 5 seconds), and destructures reactive properties (`remaining`) and control methods (`start`, `stop`, `pause`, `resume`). Optional `onComplete` and `onTick` callbacks can be provided for handling timer events.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCountdown/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useCountdown } from '@vueuse/core'\n\nconst countdownSeconds = 5\nconst { remaining, start, stop, pause, resume } = useCountdown(countdownSeconds, {\n  onComplete() {\n\n  },\n  onTick() {\n\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Draggable component with persistent storage (Vue)\nDESCRIPTION: This code snippet illustrates how to enable persistent storage of the draggable element's position using the `storage-key` and `storage-type` props of the `UseDraggable` component. The `storage-key` specifies the key under which the position will be stored, and `storage-type` determines the type of storage to use (e.g., 'session' for session storage).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDraggable/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseDraggable storage-key=\"vueuse-draggable\" storage-type=\"session\">\n    Refresh the page and I am still in the same position!\n  </UseDraggable>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useToggle Utility in Vue.js\nDESCRIPTION: This snippet demonstrates the basic usage of the `useToggle` function from the `@vueuse/core` library in a Vue.js context. It initializes a boolean variable and a toggle function. The `useToggle` function manages the state of a boolean value and provides a method to switch its value. This setup is used to manage a simple boolean switch.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useToggle/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useToggle } from '@vueuse/core'\n\nconst [value, toggle] = useToggle()\n```\n\n----------------------------------------\n\nTITLE: Initializing useCounter with Options in VueUse (JavaScript)\nDESCRIPTION: Imports `useCounter` and initializes it with an initial value of 1 and configuration options specifying a minimum value of 0 and a maximum value of 16. The returned reactive state (`count`) and control functions (`inc`, `dec`, `set`, `reset`) are destructured for use.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useCounter/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useCounter } from '@vueuse/core'\n\nconst { count, inc, dec, set, reset } = useCounter(1, { min: 0, max: 16 })\n```\n\n----------------------------------------\n\nTITLE: Using reactivePick with a Predicate Function in TypeScript\nDESCRIPTION: Illustrates how to use `reactivePick` with a predicate function to filter properties based on their key and value. In this example, properties are picked if their key is not 'bar' and their value is not `true`. It also shows the reactive nature of the result when the source object changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactivePick/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactivePick } from '@vueuse/core'\n\nconst source = reactive({\n  foo: 'foo',\n  bar: 'bar',\n  baz: 'baz',\n  qux: true,\n})\nconst state = reactivePick(source, (value, key) => key !== 'bar' && value !== true)\n// { foo: string, baz: string }\nsource.qux = false\n// { foo: string, baz: string, qux: boolean }\n```\n\n----------------------------------------\n\nTITLE: Omitting Fields from a Reactive Object Using VueUse (TypeScript)\nDESCRIPTION: Demonstrates how to use the 'reactiveOmit' function from @vueuse/core to create a new reactive object with specified keys omitted from the original. Requires the VueUse library and a reactive object (from Vue's reactive API). Accepts the base object and one or more property keys to omit. Returns a new reactive object containing fields not explicitly omitted. The input object must be reactive, and omitted fields must be correctly identified by string key.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactiveOmit/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reactiveOmit } from '@vueuse/core'\n\nconst obj = reactive({\n  x: 0,\n  y: 0,\n  elementX: 0,\n  elementY: 0,\n})\n\nconst picked = reactiveOmit(obj, 'x', 'elementX') // { y: number, elementY: number }\n```\n\n----------------------------------------\n\nTITLE: Using useBrowserLocation in JavaScript\nDESCRIPTION: Basic implementation of the useBrowserLocation function from VueUse to reactively access the browser location object.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBrowserLocation/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useBrowserLocation } from '@vueuse/core'\n\nconst location = useBrowserLocation()\n```\n\n----------------------------------------\n\nTITLE: Using useUrlSearchParams for history mode in JavaScript\nDESCRIPTION: This code snippet demonstrates the basic usage of the `useUrlSearchParams` composable.  It initializes the composable to operate in 'history' mode (which is the default if no mode is given).  It accesses and modifies URL parameters reactively.  The example then logs the value of a specific parameter to the console. Dependencies include the VueUse library, and it requires that your application is set up to use Vue and the Vue Router or similar routing mechanisms.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUrlSearchParams/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useUrlSearchParams } from '@vueuse/core'\n\nconst params = useUrlSearchParams('history')\n\nconsole.log(params.foo) // 'bar'\n\nparams.foo = 'bar'\nparams.vueuse = 'awesome'\n// url updated to `?foo=bar&vueuse=awesome`\n```\n\n----------------------------------------\n\nTITLE: Using useToggle with a Ref in Vue.js\nDESCRIPTION: This snippet shows how `useToggle` can be used with a ref, such as the `useDark` composable.  When provided a ref, `useToggle` returns a toggle function that modifies the ref's value. This demonstrates an application to dynamically toggle the state of a boolean value which could represent, for instance, dark mode or a visibility setting. It emphasizes the ability to override the target value in the toggle function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useToggle/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { useDark, useToggle } from '@vueuse/core'\n\nconst isDark = useDark()\nconst toggleDark = useToggle(isDark)\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Multiple Target Refs with syncRefs in TypeScript\nDESCRIPTION: This example shows how to synchronize a single source ref with multiple target refs simultaneously by passing an array of refs as the second argument to `syncRefs`. All refs in the target array will be kept in sync with the source ref.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRefs/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { syncRefs } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst source = shallowRef('hello')\nconst target1 = shallowRef('target1')\nconst target2 = shallowRef('target2')\n\nconst stop = syncRefs(source, [target1, target2])\n\nconsole.log(target1.value) // hello\nconsole.log(target2.value) // hello\n\nsource.value = 'foo'\n\nconsole.log(target1.value) // foo\nconsole.log(target2.value) // foo\n```\n\n----------------------------------------\n\nTITLE: Configuring Flush Timing with useRefHistory\nDESCRIPTION: Shows how to modify the flush timing for when history points are recorded, using the flush option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst refHistory = useRefHistory(target, {\n  flush: 'sync', // options 'pre' (default), 'post' and 'sync'\n})\n```\n\n----------------------------------------\n\nTITLE: Using extendRef with Reactive Extra Attributes in TypeScript\nDESCRIPTION: Shows how to extend a Ref with another Ref as an extra attribute. This example demonstrates how reactivity is maintained, with changes to the extended property reflecting in the original ref and vice versa.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/extendRef/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst myRef = shallowRef('content')\nconst extraRef = shallowRef('extra')\n\nconst extended = extendRef(myRef, { extra: extraRef })\n\nextended.value === 'content'\nextended.extra === 'extra'\n\nextended.extra = 'new data' // will trigger update\nextraRef.value === 'new data'\n```\n\n----------------------------------------\n\nTITLE: Using useAsyncQueue with Sequential Promises - TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use `useAsyncQueue` from `@vueuse/core`. It defines two asynchronous functions (`p1` and `p2`) that return Promises. `p2` is designed to accept the result of `p1`. These functions are passed to `useAsyncQueue` as an array, and the example shows how to access the `activeIndex` (the index of the currently running task) and the final `result` of the sequence.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useAsyncQueue/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useAsyncQueue } from '@vueuse/core'\n\nfunction p1() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1000)\n    }, 10)\n  })\n}\n\nfunction p2(result: number) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(1000 + result)\n    }, 20)\n  })\n}\n\nconst { activeIndex, result } = useAsyncQueue([p1, p2])\n\nconsole.log(activeIndex.value) // current pending task index\n\nconsole.log(result) // the tasks result\n```\n\n----------------------------------------\n\nTITLE: Displaying User Media Stream in Video Element - TypeScript\nDESCRIPTION: This TypeScript snippet shows how to display the user media stream obtained from `useUserMedia` on a video element. It uses `watchEffect` to reactively update the `srcObject` property of the video element with the stream's value.  This allows the video element to display the user's camera feed. Requires an existing HTML video element with id \"video\" and the `stream` value from the `useUserMedia` function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUserMedia/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst video = document.getElementById('video')\n\nwatchEffect(() => {\n  // preview on a video element\n  video.srcObject = stream.value\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Object URL with useObjectUrl - Vue\nDESCRIPTION: This code snippet demonstrates how to use the `useObjectUrl` composable from `@vueuse/core` to create a reactive URL for a file. It uses `shallowRef` to hold the file object and updates the URL when the file changes.  The URL is automatically revoked when the component is unmounted or the file changes, preventing memory leaks. Requires Vue 3 and @vueuse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useObjectUrl/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useObjectUrl } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst file = shallowRef()\nconst url = useObjectUrl(file)\n\nfunction onFileChange(event) {\n  file.value = event.target.files[0]\n}\n</script>\n\n<template>\n  <input type=\"file\" @change=\"onFileChange\">\n\n  <a :href=\"url\">Open file</a>\n</template>\n\n```\n\n----------------------------------------\n\nTITLE: Installing @vueuse/electron with npm\nDESCRIPTION: Command to install the @vueuse/electron package and its peer dependency electron using npm. Both packages are required for the functionality to work properly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/electron electron\n```\n\n----------------------------------------\n\nTITLE: Using useArrayDifference with custom equality function for object arrays\nDESCRIPTION: An example showing how to use useArrayDifference with arrays of objects by providing a custom comparison function. The function compares objects based on their id property to determine equality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayDifference/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayDifference } from '@vueuse/core'\n\nconst list1 = ref([{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }])\nconst list2 = ref([{ id: 4 }, { id: 5 }, { id: 6 }])\n\nconst result = useArrayDifference(list1, list2, (value, othVal) => value.id === othVal.id)\n// result.value: [{ id: 1 }, { id: 2 }, { id: 3 }]\n```\n\n----------------------------------------\n\nTITLE: Using onCancel with computedAsync for Cancelable Fetch Request in Vue (JavaScript)\nDESCRIPTION: Shows how to utilize the onCancel mechanism in computedAsync to abort a fetch request if the dependencies are updated before the previous request resolves. Uses AbortController to cancel the in-flight request and provides fallback output in case of fetch errors. Dependencies: @vueuse/core, vue, fetch API. Parameters: onCancel callback, packageName ref, abort controller, fetch URL. Input: reactive package name. Output: number of downloads or fallback value. Limitations: only works in environments supporting fetch and AbortController.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedAsync/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst packageName = shallowRef('@vueuse/core')\n\nconst downloads = computedAsync(async (onCancel) => {\n  const abortController = new AbortController()\n\n  onCancel(() => abortController.abort())\n\n  return await fetch(\n    `https://api.npmjs.org/downloads/point/last-week/${packageName.value}`,\n    { signal: abortController.signal },\n  )\n    .then(response => response.ok ? response.json() : { downloads: '\\u2014' })\n    .then(result => result.downloads)\n}, 0)\n```\n\n----------------------------------------\n\nTITLE: useAxios Usage with Axios Instance\nDESCRIPTION: This snippet shows how to use useAxios with a pre-configured Axios instance.  An Axios instance allows for setting up common configurations like baseURL, headers, etc. and re-using it across multiple requests. `data` will contain the response data and `isFinished` indicates request completion.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\nimport axios from 'axios'\n\nconst instance = axios.create({\n  baseURL: '/api',\n})\n\nconst { data, isFinished } = useAxios('/posts', instance)\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Omission with Predicate Using VueUse (TypeScript)\nDESCRIPTION: Shows how to conditionally omit fields from a reactive object based on a predicate function using 'reactiveOmit' from @vueuse/core. Dependency: VueUse library and Vue's reactivity system. The predicate function receives both the field value and key; only fields for which the predicate returns false are retained in the result. Useful for dynamic, value-dependent omission logic on reactive objects.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactiveOmit/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reactiveOmit } from '@vueuse/core'\n\nconst obj = reactive({\n  bar: 'bar',\n  baz: 'should be omit',\n  foo: 'foo2',\n  qux: true,\n})\n\nconst picked = reactiveOmit(obj, (value, key) => key === 'baz' || value === true)\n// { bar: string, foo: string }\n```\n\n----------------------------------------\n\nTITLE: Using useVirtualList within a Custom Vue Component\nDESCRIPTION: This snippet demonstrates how to implement the useVirtualList within a Vue component, passing the list and options as props. The default scoped slot provides access to the current item's index and data, enabling custom rendering of each list item.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_6\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseVirtualList :list=\"list\" :options=\"options\" height=\"300px\">\n    <template #default=\"props\">\n      <!-- you can get current item of list here -->\n      <div style=\"height: 22px\">\n        Row {{ props.index }} {{ props.data }}\n      </div>\n    </template>\n  </UseVirtualList>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useBrowserLocation as a Vue Component\nDESCRIPTION: Example of using the UseBrowserLocation component with Vue's slot API to access the browser location reactively in a template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBrowserLocation/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<UseBrowserLocation v-slot=\"{ location }\">\n  Browser Location: {{ location }}\n</UseBrowserLocation>\n```\n\n----------------------------------------\n\nTITLE: Using Dirty Mode with useSorted for In-Place Array Sorting (TypeScript)\nDESCRIPTION: This snippet illustrates how to enable dirty mode in useSorted, which directly modifies the source array to keep it sorted reactively. It shows the reactive source array wrapped with Vue's ref and demonstrates the sorting operation with the 'dirty' option set to true. The output confirms the in-place modification behavior. Dependencies include Vue's ref and '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSorted/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst source = ref([10, 3, 5, 7, 2, 1, 8, 6, 9, 4])\nconst sorted = useSorted(source, (a, b) => a - b, {\n  dirty: true,\n})\nconsole.log(source)// output: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n```\n\n----------------------------------------\n\nTITLE: Custom ID assignment in useStyleTag for style element in VueUse\nDESCRIPTION: This snippet illustrates how to specify a custom 'id' for the style element injected by useStyleTag, allowing precise control over the style tag's identifier in the DOM. It requires providing a second argument with an 'id' property. The style is injected into <head> with the specified ID. The approach is useful for preventing conflicts or targeting specific style tags.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStyleTag/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useStyleTag } from '@vueuse/core'\n\nuseStyleTag('.foo { margin-top: 32px; }', { id: 'custom-id' })\n\n// Injected into <head>\n// <style id=\"custom-id\">\n//   .foo {\n//     margin-top: 32px;\n//   }\n// </style>\n\n```\n\n----------------------------------------\n\nTITLE: Using toRefs with Refs and Reactive Objects/Arrays in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `@vueuse/core`'s `toRefs` function. It shows how to destructure both refs containing objects/arrays (`ref`) and standard reactive objects/arrays (`reactive`) into individual refs, preserving reactivity. Requires importing `toRefs` from `@vueuse/core` and `reactive`, `ref` from `vue`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/toRefs/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { toRefs } from '@vueuse/core'\nimport { reactive, ref } from 'vue'\n\nconst objRef = ref({ a: 'a', b: 0 })\nconst arrRef = ref(['a', 0])\n\nconst { a, b } = toRefs(objRef)\n// const [a, b] = toRefs(arrRef) // Original example has duplicate 'a', 'b' declaration. Corrected for clarity.\nconst [arrA, arrB] = toRefs(arrRef)\n\nconst obj = reactive({ a: 'a', b: 0 })\nconst arr = reactive(['a', 0])\n\nconst { a: objA, b: objB } = toRefs(obj) // Renamed to avoid conflict\nconst [arrC, arrD] = toRefs(arr) // Renamed to avoid conflict\n```\n\n----------------------------------------\n\nTITLE: Basic useAxios Usage with URL\nDESCRIPTION: This example demonstrates the most basic usage of the useAxios composable with a URL. It fetches data from the specified endpoint and provides reactive properties like `data` (containing the response data) and `isFinished` (indicating whether the request has completed).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\n\nconst { data, isFinished } = useAxios('/api/posts')\n```\n\n----------------------------------------\n\nTITLE: Consuming Counter Store Actions in Vue Component\nDESCRIPTION: Shows how to access and use actions from the injected counter store in a button component, specifically using the increment function on button click.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<!-- ButtonComponent.vue -->\n<script setup lang=\"ts\">\nimport { useCounterStore } from './useCounterStore'\n\n// use non-null assertion operator to ignore the case that store is not provided.\nconst { increment } = useCounterStore()!\n</script>\n\n<template>\n  <button @click=\"increment\">\n    +\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Debouncing with Rejection Handling\nDESCRIPTION: This snippet demonstrates how to handle promise rejections when a debounced function is canceled.  By default, a debounced promise will *not* reject if it is canceled; you must specify `rejectOnCancel: true`.  It shows how to set `rejectOnCancel: true` and then use `.catch()` to handle a rejection if the debounced function is canceled before completion. Calling `debouncedRequest()` again will cancel the previous execution.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDebounceFn/index.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { useDebounceFn } from '@vueuse/core'\n\nconst debouncedRequest = useDebounceFn(() => 'response', 1000, { rejectOnCancel: true })\n\ndebouncedRequest()\n  .then((value) => {\n    // do something\n  })\n  .catch(() => {\n    // do something when canceled\n  })\n\n// calling it again will cancel the previous request and gets rejected\nsetTimeout(debouncedRequest, 500)\n```\n\n----------------------------------------\n\nTITLE: Using useOffsetPagination Function in TypeScript\nDESCRIPTION: Example of importing and initializing the useOffsetPagination function with callback for data fetching. Returns reactive pagination controls such as page navigation and state indicators.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOffsetPagination/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useOffsetPagination } from '@vueuse/core'\n\nfunction fetchData({ currentPage, currentPageSize }: { currentPage: number, currentPageSize: number }) {\n  fetch(currentPage, currentPageSize).then((responseData) => {\n    data.value = responseData\n  })\n}\n\nconst {\n  currentPage,\n  currentPageSize,\n  pageCount,\n  isFirstPage,\n  isLastPage,\n  prev,\n  next,\n} = useOffsetPagination({\n  total: database.value.length,\n  page: 1,\n  pageSize: 10,\n  onPageChange: fetchData,\n  onPageSizeChange: fetchData,\n})\n```\n\n----------------------------------------\n\nTITLE: Consuming and Transforming Injected Array with computedInject (TypeScript)\nDESCRIPTION: This snippet demonstrates using the computedInject utility from @vueuse/core to inject a reactive array and transform it within a computed context. Dependencies include @vueuse/core for computedInject and a defined injection key exported from another module. The function transforms the injected array by prepending a new element, supporting derived state based on injected sources. It expects a valid injection key and an initial provided array; the output is a computed ref with custom mapping. Applies only within Vue setup or composition API context.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedInject/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { computedInject } from '@vueuse/core'\n\nimport { ArrayKey } from './provider'\n\nconst computedArray = computedInject(ArrayKey, (source) => {\n  const arr = [...source.value]\n  arr.unshift({ key: 0, value: 'all' })\n  return arr\n})\n```\n\n----------------------------------------\n\nTITLE: Using watchImmediate for Immediate Watching - TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to use the `watchImmediate` function from the `@vueuse/core` library. It takes a reactive value (in this case, a ref named `obj`) and a callback function as arguments.  The callback will be immediately executed upon the initial watch setup, and then every time the `obj` value changes. The example uses `console.log` inside the callback to display the updated value. Requires `@vueuse/core` library to be installed as a dependency.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchImmediate/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { watchImmediate } from '@vueuse/core'\n\nconst obj = ref('vue-use')\n\n// changing the value from some external store/composables\nobj.value = 'VueUse'\n\nwatchImmediate(obj, (updated) => {\n  console.log(updated) // Console.log will be logged twice\n})\n```\n\n----------------------------------------\n\nTITLE: Debouncing ref with refDebounced in VueUse\nDESCRIPTION: This code snippet demonstrates how to use `refDebounced` from `@vueuse/core` to debounce the value of a shallow ref. The `debounced` ref will update its value only after a specified delay (1000ms in this example) of inactivity on the original `input` ref. It shows how initial values are preserved and updated after the debounce period. The `sleep` function is assumed to be available for testing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refDebounced/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { refDebounced } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst input = shallowRef('foo')\nconst debounced = refDebounced(input, 1000)\n\ninput.value = 'bar'\nconsole.log(debounced.value) // 'foo'\n\nawait sleep(1100)\n\nconsole.log(debounced.value) // 'bar'\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Reactive Interval Counter in JavaScript\nDESCRIPTION: Demonstrates the basic usage of `useInterval` from `@vueuse/core` in JavaScript. It initializes a reactive `counter` variable by calling `useInterval` with the desired interval duration (200ms). The counter automatically increments every 200 milliseconds.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useInterval/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useInterval } from '@vueuse/core'\n\n// count will increase every 200ms\nconst counter = useInterval(200)\n```\n\n----------------------------------------\n\nTITLE: Using useWindowScroll to Track and Set Scroll Positions in VueUse (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import the useWindowScroll function from VueUse, initialize reactive x and y scroll position references, read the current scroll position, and update the vertical scroll to a specific value. It relies on Vue's reactivity system and the VueUse library to manage window scroll state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWindowScroll/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useWindowScroll } from '@vueuse/core'\n\nconst { x, y } = useWindowScroll()\nconsole.log(x.value) // read current x scroll value\ny.value = 100 // scroll y to 100\n```\n\n----------------------------------------\n\nTITLE: Implementing Deep Watching with watchDeep in VueUse/TypeScript\nDESCRIPTION: Demonstrates using `watchDeep` from `@vueuse/core` to monitor changes within a nested reactive object (`ref`). The callback logs the updated object whenever any nested property changes. The example modifies a deeply nested property within the `onMounted` lifecycle hook to trigger the watcher.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchDeep/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchDeep } from '@vueuse/core'\n\nconst nestedObject = ref({ foo: { bar: { deep: 5 } } })\n\nwatchDeep(nestedObject, (updated) => {\n  console.log(updated)\n})\n\nonMounted(() => {\n  nestedObject.value.foo.bar.deep = 10\n})\n```\n\n----------------------------------------\n\nTITLE: Targeting Specific Element with useFullscreen Hook (TypeScript)\nDESCRIPTION: Initializes the `useFullscreen` hook to target a specific element referenced by a Vue template ref named 'el'. It provides reactive state (`isFullscreen`) and control methods (`enter`, `exit`, `toggle`) for that element. Note that fullscreen support can vary across browsers and element types, particularly on mobile platforms like iOS Safari which may only support video elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFullscreen/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst el = useTemplateRef<HTMLElement>('el')\n\nconst { isFullscreen, enter, exit, toggle } = useFullscreen(el)\n```\n\n----------------------------------------\n\nTITLE: Component-based useFullscreen Usage (Vue)\nDESCRIPTION: Illustrates using a renderless component (`UseFullscreen`) to manage fullscreen state. The component utilizes a scoped slot (`v-slot=\"{ toggle }\"`) to expose the `toggle` function to its children, enabling a button click to trigger fullscreen on the enclosed video element. This pattern simplifies template integration of the fullscreen logic.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFullscreen/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseFullscreen v-slot=\"{ toggle }\">\n    <video />\n    <button @click=\"toggle\">\n      Go Fullscreen\n    </button>\n  </UseFullscreen>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing useCounter in VueUse with TypeScript\nDESCRIPTION: This snippet demonstrates how to import the useCounter composable from the @vueuse/core package and initialize its reactive state in TypeScript. It exposes functions for incrementing (inc), decrementing (dec), setting a value (set), and resetting the counter (reset) along with the count variable itself. Dependencies include the @vueuse/core library and a TypeScript environment; all returned methods are intended for use within Vue 3 Composition API components and expect numerical input where relevant.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/_template/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCounter } from '@vueuse/core'\n\nconst { count, inc, dec, set, reset } = useCounter()\n```\n\n----------------------------------------\n\nTITLE: Integrations with Axios in VueUse\nDESCRIPTION: Provides utilities for managing Axios HTTP requests, including automatic retries, cancelation, and reactive request states.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility functions for integrating Axios with Vue's reactivity system, supporting HTTP request management. */\n```\n\n----------------------------------------\n\nTITLE: Listening for Electron IPC Events with useIpcRendererOn in TypeScript\nDESCRIPTION: Demonstrates how to import and use the `useIpcRendererOn` composable to subscribe to a specific Electron IPC channel ('custom-event'). The provided listener function will be executed when an event is received on that channel. The composable automatically manages the lifecycle, removing the listener when the component using it is unmounted. Requires the `@vueuse/electron` dependency and appropriate Electron context (like `nodeIntegration` enabled if `ipcRenderer` is not explicitly provided).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useIpcRendererOn/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useIpcRendererOn } from '@vueuse/electron'\n\n// enable nodeIntegration if you don't provide ipcRenderer explicitly\n// @see: https://www.electronjs.org/docs/api/webview-tag#nodeintegration\n// remove listener automatically on unmounted\nuseIpcRendererOn('custom-event', (event, ...args) => {\n  console.log(args)\n})\n```\n\n----------------------------------------\n\nTITLE: Importing and Using tryOnUnmounted in Vue (JavaScript)\nDESCRIPTION: This example demonstrates how to import the `tryOnUnmounted` function from `@vueuse/core` and use it to register a callback function that will be safely executed when the component unmounts. The callback is only invoked if `tryOnUnmounted` is called within a component's setup function or lifecycle hook context.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/tryOnUnmounted/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { tryOnUnmounted } from '@vueuse/core'\n\ntryOnUnmounted(() => {\n\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useDateFormat with Vue\nDESCRIPTION: Demonstrates the basic implementation of useDateFormat with the useNow function to display the current time formatted as YYYY-MM-DD HH:mm:ss.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDateFormat/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useDateFormat, useNow } from '@vueuse/core'\n\nconst formatted = useDateFormat(useNow(), 'YYYY-MM-DD HH:mm:ss')\n</script>\n\n<template>\n  <div>{{ formatted }}</div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using destructuring with VueUse's useMouse in TypeScript\nDESCRIPTION: Demonstrates destructuring of refs returned by the useMouse composable for simplified access to mouse coordinates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@vueuse/core'\n\n// \"x\" and \"y\" are refs\nconst { x, y } = useMouse()\n\nconsole.log(x.value)\n\nconst mouse = useMouse()\n\nconsole.log(mouse.x.value)\n```\n\n----------------------------------------\n\nTITLE: Using watchTriggerable for manual watch triggering (TypeScript)\nDESCRIPTION: This example demonstrates how to use `watchTriggerable` to manually trigger a watch callback. It imports `watchTriggerable` from `@vueuse/core` and `nextTick` and `shallowRef` from `vue`. The `trigger` function allows immediate execution of the callback, bypassing the usual dependency tracking.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchTriggerable/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchTriggerable } from '@vueuse/core'\nimport { nextTick, shallowRef } from 'vue'\n\nconst source = shallowRef(0)\n\nconst { trigger, ignoreUpdates } = watchTriggerable(\n  source,\n  v => console.log(`Changed to ${v}!`),\n)\n\nsource.value = 'bar'\nawait nextTick() // logs: Changed to bar!\n\n// Execution of WatchCallback via `trigger` does not require waiting\ntrigger() // logs: Changed to bar!\n```\n\n----------------------------------------\n\nTITLE: Using VueUse whenever for Watching Async State in JavaScript\nDESCRIPTION: Demonstrates importing useAsyncState and whenever from @vueuse/core to fetch JSON asynchronously and watch the readiness of the state. When the state is ready, a callback logs the fetched data. Dependencies include VueUse core. Inputs are a promise-based fetch operation and the ready state. Output is a console log of the state once ready.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/whenever/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useAsyncState, whenever } from '@vueuse/core'\n\nconst { state, isReady } = useAsyncState(\n  fetch('https://jsonplaceholder.typicode.com/todos/1').then(t => t.json()),\n  {},\n)\n\nwhenever(isReady, () => console.log(state))\n```\n\n----------------------------------------\n\nTITLE: Using usePrecision to set number precision in VueUse\nDESCRIPTION: This code snippet demonstrates how to use the `usePrecision` composable from `@vueuse/math` to set the precision of a reactive number. It showcases basic rounding, ceiling, and flooring functionalities. The composable takes a reactive number, the desired precision, and an optional configuration object as input.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/usePrecision/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { usePrecision } from '@vueuse/math'\n\nconst value = ref(3.1415)\nconst result = usePrecision(value, 2) // 3.14\n\nconst ceilResult = usePrecision(value, 2, {\n  math: 'ceil'\n}) // 3.15\n\nconst floorResult = usePrecision(value, 3, {\n  math: 'floor'\n}) // 3.141\n```\n\n----------------------------------------\n\nTITLE: Displaying Media Stream in a Video Element (TypeScript)\nDESCRIPTION: Uses `watchEffect` from Vue to reactively update the `srcObject` property of an HTML video element whenever the `stream` ref obtained from `useDisplayMedia` changes. This effectively displays the captured screen or window content in the video player. Assumes an HTML element with id 'video' exists.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDisplayMedia/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst video = document.getElementById('video')\n\nwatchEffect(() => {\n  // preview on a video element\n  video.srcObject = stream.value\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Media Controls with useMediaControls in Vue\nDESCRIPTION: This snippet demonstrates the basic usage of `useMediaControls` from `@vueuse/core` to control an HTML video element. It initializes reactive refs for `playing`, `currentTime`, `duration`, and `volume` linked to the video element referenced by `useTemplateRef`. The `onMounted` hook is used to set initial volume and playback time. The template shows how to bind these reactive variables to UI elements like a play/pause button and a time display.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMediaControls/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useMediaControls } from '@vueuse/core'\nimport { onMounted, useTemplateRef } from 'vue'\n\nconst video = useTemplateRef('video')\nconst { playing, currentTime, duration, volume } = useMediaControls(video, {\n  src: 'video.mp4',\n})\n\n// Change initial media properties\nonMounted(() => {\n  volume.value = 0.5\n  currentTime.value = 60\n})\n</script>\n\n<template>\n  <video ref=\"video\" />\n  <button @click=\"playing = !playing\">\n    Play / Pause\n  </button>\n  <span>{{ currentTime }} / {{ duration }}</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Wrapping useNetwork result in Vue reactive object in JavaScript\nDESCRIPTION: This snippet shows how to integrate the useNetwork composable with Vue's reactive system by importing reactive from 'vue' and wrapping the useNetwork return object. This allows direct property access without .value, supporting reactive data binding more intuitively. The example logs the reactive network's isOnline property. Prerequisites include Vue 3 and @vueuse/core installed together to enable reactive composition API usage.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNetwork/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { reactive } from 'vue'\n\nconst network = reactive(useNetwork())\n\nconsole.log(network.isOnline)\n```\n\n----------------------------------------\n\nTITLE: Using UseOffsetPagination Component in Vue Template\nDESCRIPTION: Example of using the UseOffsetPagination component in a Vue template with slot props for pagination controls and data display. Demonstrates event handling with page-change and page-size-change events.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOffsetPagination/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseOffsetPagination\n    v-slot=\"{\n      currentPage,\n      currentPageSize,\n      next,\n      prev,\n      pageCount,\n      isFirstPage,\n      isLastPage,\n    }\"\n    :total=\"database.length\"\n    @page-change=\"fetchData\"\n    @page-size-change=\"fetchData\"\n  >\n    <div class=\"gap-x-4 gap-y-2 grid-cols-2 inline-grid items-center\">\n      <div opacity=\"50\">\n        total:\n      </div>\n      <div>{{ database.length }}</div>\n      <div opacity=\"50\">\n        pageCount:\n      </div>\n      <div>{{ pageCount }}</div>\n      <div opacity=\"50\">\n        currentPageSize:\n      </div>\n      <div>{{ currentPageSize }}</div>\n      <div opacity=\"50\">\n        currentPage:\n      </div>\n      <div>{{ currentPage }}</div>\n      <div opacity=\"50\">\n        isFirstPage:\n      </div>\n      <div>{{ isFirstPage }}</div>\n      <div opacity=\"50\">\n        isLastPage:\n      </div>\n      <div>{{ isLastPage }}</div>\n    </div>\n    <div>\n      <button :disabled=\"isFirstPage\" @click=\"prev\">\n        prev\n      </button>\n      <button :disabled=\"isLastPage\" @click=\"next\">\n        next\n      </button>\n    </div>\n  </UseOffsetPagination>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using the 'set' utility function in TypeScript with Vue refs\nDESCRIPTION: Demonstrates how to use the 'set' utility function from VueUse to update the value of a ref object without directly accessing its 'value' property. This simplifies the syntax from 'ref.value = x' to 'set(ref, x)'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/set/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { set } from '@vueuse/core'\n\nconst a = ref(0)\n\nset(a, 1)\n\nconsole.log(a.value) // 1\n```\n\n----------------------------------------\n\nTITLE: Initializing Reactive Document Title Using VueUse in JavaScript\nDESCRIPTION: This snippet demonstrates importing the useTitle composable from '@vueuse/core' and creating a reactive reference to the document title. It shows how to access and update the title reactively via the returned ref. This pattern requires a browser environment as SSR is unsupported.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTitle/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useTitle } from '@vueuse/core'\n\nconst title = useTitle()\nconsole.log(title.value) // print current title\ntitle.value = 'Hello' // change current title\n```\n\n----------------------------------------\n\nTITLE: Reactive JSON Stringify Implementation in TypeScript\nDESCRIPTION: Shows how to create a reactive version of JSON.stringify using reactify. The example demonstrates reactifying a built-in JavaScript function to automatically update string output when the input object changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactify/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactify } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst stringify = reactify(JSON.stringify)\n\nconst obj = shallowRef(42)\nconst dumped = stringify(obj)\n\nconsole.log(dumped.value) // '42'\n\nobj.value = { foo: 'bar' }\n\nconsole.log(dumped.value) // '{\"foo\":\"bar\"}'\n```\n\n----------------------------------------\n\nTITLE: Installing async-validator Dependency (Bash)\nDESCRIPTION: Installs the `async-validator` library (version 4 or higher) using npm. This library is required by the `useAsyncValidator` composable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAsyncValidator/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i async-validator@^4\n```\n\n----------------------------------------\n\nTITLE: Customizing Transition Easing with Cubic Bezier Curves in JavaScript\nDESCRIPTION: Illustrates configuring useTransition with a custom cubic bezier curve array for easing, conforming to CSS easing function syntax. This enables advanced control over transition timing beyond the provided presets. The transition option is assigned an array of four numbers representing the bezier control points. This customization requires no additional dependencies beyond Vue and '@vueuse/core'. The source ref remains reactive and numeric or array-based.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nuseTransition(source, {\\n  transition: [0.75, 0, 0.25, 1],\\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Attribute Inheritance in Reusable Templates (TypeScript)\nDESCRIPTION: Shows how to create a reusable template that opts out from inheriting DOM attributes by using the inheritAttrs: false option. Prerequisites: TypeScript, @vueuse/core. Inputs: Option object with inheritAttrs set to false. Outputs: DefineTemplate and ReuseTemplate components without attribute inheritance. Limitation: May affect how custom attributes appear in rendered output.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate({\n  inheritAttrs: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Summing Multiple Reactive Values and Constants Using @vueuse/math in TypeScript\nDESCRIPTION: This snippet illustrates using useSum to compute the sum of multiple reactive references along with constant numeric values. It imports useSum from @vueuse/math and uses Vue's ref to create reactive numbers. The function returns a Ref containing the total sum, which updates reactively as any referenced values change. Dependencies include Vue's ref and the @vueuse/math package.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useSum/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useSum } from '@vueuse/math'\n\nconst a = ref(1)\nconst b = ref(3)\n\nconst sum = useSum(a, b, 2) // Ref<6>\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Scroll with useInfiniteScroll Composable in Vue/TypeScript\nDESCRIPTION: Demonstrates how to use the `useInfiniteScroll` composable from `@vueuse/core` to implement infinite scrolling on an HTML element. It requires a template ref (`el`) for the scrollable container, a callback function (`onLoadMore`) to load more data, and optional configuration like `distance` and `canLoadMore`. The `canLoadMore` function is crucial to prevent unnecessary loading attempts when no more data is available. A `reset` function is also provided to clear the data and reset the scroll state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useInfiniteScroll/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useInfiniteScroll } from '@vueuse/core'\nimport { ref, useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst data = ref([1, 2, 3, 4, 5, 6])\n\nconst { reset } = useInfiniteScroll(\n  el,\n  () => {\n    // load more\n    data.value.push(...moreData)\n  },\n  {\n    distance: 10,\n    canLoadMore: () => {\n      // inidicate when there is no more content to load so onLoadMore stops triggering\n      // if (noMoreContent) return false\n      return true // for demo purposes\n    },\n  }\n)\n\nfunction resetList() {\n  data.value = []\n  reset()\n}\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div ref=\"el\">\n    <div v-for=\"item in data\">\n      {{ item }}\n    </div>\n  </div>\n  <button @click=\"resetList()\">\n    Reset\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Tracking Press State on a Specific Element in Vue with TypeScript\nDESCRIPTION: This snippet shows how to restrict press state tracking to a specific DOM element using useMousePressed in a Vue single-file component with TypeScript. It uses the useTemplateRef from Vue to create a ref linked to a div, and passes this ref as the target option to useMousePressed. Only pressing or touching this element updates the reactive pressed state. Dependencies include Vue and @vueuse/core. The input is a Vue ref to the element, and the output is a pressed boolean linked to that element's state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMousePressed/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLDivElement>('el')\n\nconst { pressed } = useMousePressed({ target: el })\n</script>\n\n<template>\n  <div ref=\"el\">\n    Only clicking on this element will trigger the update.\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using usePointerSwipe Composable in a Vue Component\nDESCRIPTION: Example showing how to implement swipe detection in a Vue component using the usePointerSwipe composable. The composable tracks whether a swipe is occurring and returns the direction of the swipe using the PointerEvents API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointerSwipe/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { usePointerSwipe } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef('el')\nconst { isSwiping, direction } = usePointerSwipe(el)\n</script>\n\n<template>\n  <div ref=\"el\">\n    Swipe here\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayMap with array of refs in VueUse\nDESCRIPTION: This snippet demonstrates applying useArrayMap to an array of reactive refs, transforming each ref's value by doubling it. It highlights how updates to individual refs propagate to the mapped result, maintaining reactivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayMap/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayMap } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(2)\nconst item3 = ref(4)\nconst item4 = ref(6)\nconst item5 = ref(8)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArrayMap(list, i => i * 2)\n// result.value: [0, 4, 8, 12, 16]\nitem1.value = 1\n// result.value: [2, 4, 8, 12, 16]\n```\n\n----------------------------------------\n\nTITLE: Using watchDebounced in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates the usage of the `watchDebounced` function in a Vue.js application using TypeScript. It observes a source (presumably a reactive variable) and executes a callback function after a specified debounce delay. The `debounce` and `maxWait` options control the debouncing behavior. Dependencies include the `@vueuse/core` library. The expected output is the console logging of \"changed!\" after the debouncing period if the `source` value changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchDebounced/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { watchDebounced } from '@vueuse/core'\n\nwatchDebounced(\n  source,\n  () => { console.log('changed!') },\n  { debounce: 500, maxWait: 1000 },\n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Minimum from Multiple Reactive Refs and Static Values with useMin\nDESCRIPTION: This snippet shows how to pass multiple reactive references and static values to the useMin function to compute the minimum among them. The function returns a reactive ref that automatically updates if any dependencies change, enabling dynamic UI updates based on the minimum value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useMin/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMin } from '@vueuse/math'\n\nconst a = ref(1)\nconst b = ref(3)\n\nconst min = useMin(a, b, 2) // Ref<1>\n```\n\n----------------------------------------\n\nTITLE: Configuring useVirtualList with Pattern Options in TypeScript\nDESCRIPTION: This snippet outlines how to configure useVirtualList with additional options such as itemWidth and overscan to control the size of list items and pre-rendering behavior. These parameters ensure smooth scrolling and correct layout calculations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n| State      | Type     | Description                                                                                     |\n| ---------- | -------- | ----------------------------------------------------------------------------------------------- |\n| itemHeight | `number` | ensure that the total height of the `wrapper` element is calculated correctly.\\*                |\n| itemWidth  | `number` | ensure that the total width of the `wrapper` element is calculated correctly.\\*                 |\n| overscan   | `number` | number of pre-rendered DOM nodes. Prevents whitespace between items if you scroll very quickly. |\n```\n\n----------------------------------------\n\nTITLE: Polling Data Using useTimeoutPoll in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the useTimeoutPoll composable from the @vueuse/core library to periodically execute an asynchronous fetchData function. The polling mechanism ensures that the callback fetchData is invoked at a specified interval (1000ms) but only after the previous asynchronous task completes, preventing overlap. Dependencies include Vue's ref and the useTimeoutPoll composable. Key parameters are the polling callback (fetchData) and the delay interval in milliseconds. Expected output includes reactive polling controls (isActive, pause, resume) and an incrementing count value. It is suitable for scenarios where serial polling is essential to avoid race conditions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimeoutPoll/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useTimeoutPoll } from '@vueuse/core'\n\nconst count = ref(0)\n\nasync function fetchData() {\n  await new Promise(resolve => setTimeout(resolve, 1000))\n  count.value++\n}\n\n// Only trigger after last fetch is done\nconst { isActive, pause, resume } = useTimeoutPoll(fetchData, 1000)\n```\n\n----------------------------------------\n\nTITLE: Listening for Multiple Keys with onKeyStroke\nDESCRIPTION: Shows how to listen for multiple keys ('s', 'S', 'ArrowDown') simultaneously, or all keys by passing a boolean or a callback. Suitable for capturing different key presses within a component. Depends on @vueuse/core, importing onKeyStroke.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { onKeyStroke } from '@vueuse/core'\n\nonKeyStroke(['s', 'S', 'ArrowDown'], (e) => {\n  e.preventDefault()\n})\n\n// listen to all keys\nonKeyStroke(true, (e) => {\n  e.preventDefault()\n})\n// shorthand for all keys\nonKeyStroke((e) => {\n  e.preventDefault()\n})\n```\n\n----------------------------------------\n\nTITLE: useWebSocket with heartbeat enabled\nDESCRIPTION: This snippet shows how to enable a simple heartbeat. When set to `true`, the WebSocket client will send a default 'ping' message at a default interval to keep the connection alive.  Dependencies include `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst { status, data, close } = useWebSocket('ws://websocketurl', {\n  heartbeat: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Initialize WebFrame Zoom Factor Immediately in JavaScript using useZoomFactor\nDESCRIPTION: This code shows how to set an initial zoom factor at the time of invoking useZoomFactor, establishing a starting zoom level in an Electron application. It uses JavaScript syntax and demonstrates direct initialization without reactive references.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomFactor/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useZoomFactor } from '@vueuse/electron'\\n\\nconst factor = useZoomFactor(2)\n```\n\n----------------------------------------\n\nTITLE: Common Matching Conditions with until - TypeScript\nDESCRIPTION: Provides examples of various built-in matchers available with `until`, such as `toBe`, `toMatch` (with a function), `changed`, `changedTimes`, `toBeTruthy`, and `toBeNull`. It also demonstrates how to use the `.not` modifier to negate a condition.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/until/index.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nawait until(ref).toBe(true)\nawait until(ref).toMatch(v => v > 10 && v < 100)\nawait until(ref).changed()\nawait until(ref).changedTimes(10)\nawait until(ref).toBeTruthy()\nawait until(ref).toBeNull()\n\nawait until(ref).not.toBeNull()\nawait until(ref).not.toBeTruthy()\n```\n\n----------------------------------------\n\nTITLE: Triggering File Dialog Open in Vue Template\nDESCRIPTION: Provides a Vue single-file component template snippet showing a button that triggers the file dialog's open method upon click. This snippet integrates with the useFileDialog composable's open function to initiate file selection. It assumes the composable is properly registered and available in the component's setup context. The button acts as the user interface control to open the dialog.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFileDialog/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <button type=\"button\" @click=\"open\">\n    Choose file\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Displaying dynamic QR code with HTML\nDESCRIPTION: HTML example showing how to bind the generated QR code to an image element and allow user input to dynamically change the QR code content.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useQRCode/index.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<input v-model=\"text\" type=\"text\" />\n<img :src=\"qrcode\" alt=\"QR Code\" />\n```\n\n----------------------------------------\n\nTITLE: Using useTrunc Composable in Vue.js/TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the `useTrunc` composable from `@vueuse/math`. It takes reactive number values (like `ref`s) as input and returns a reactive computed property that holds the truncated integer value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useTrunc/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useTrunc } from '@vueuse/math'\n\nconst value1 = ref(0.95)\nconst value2 = ref(-2.34)\nconst result1 = useTrunc(value1) // 0\nconst result2 = useTrunc(value2) // -2\n```\n\n----------------------------------------\n\nTITLE: Manual Cloning with useCloned in VueUse (TypeScript)\nDESCRIPTION: This snippet illustrates manual cloning enabled by the manual option in useCloned. It requires explicit synchronization via the sync method to update the clone after changing the original, allowing controlled data management.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCloned/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCloned } from '@vueuse/core'\n\nconst original = ref({ key: 'value' })\n\nconst { cloned, sync } = useCloned(original, { manual: true })\n\noriginal.value.key = 'manual'\n\nconsole.log(cloned.value.key) // 'value'\n\nsync()\n\nconsole.log(cloned.value.key)// 'manual'\n```\n\n----------------------------------------\n\nTITLE: Configuring useSpeechRecognition with default options\nDESCRIPTION: This snippet shows how to pass configuration options to useSpeechRecognition to set language, interimResults, and continuous recognition behavior. These options configure the SpeechRecognition API's parameters to tailor speech recognition to specific needs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSpeechRecognition/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nuseSpeechRecognition({\n  lang: 'en-US',\n  interimResults: true,\n  continuous: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Using Throttled Watcher in VueUse (TypeScript)\nDESCRIPTION: Demonstrates how to invoke the watchThrottled utility from @vueuse/core to observe a reactive source and throttle the callback execution. Requires VueUse installed and imported; accepts a reactive data source, a callback function, and an options object with a throttle duration (milliseconds). Useful for reducing callback frequency in high-update scenarios; outputs throttled side effects via the callback, and inputs include any observable compatible with Vue's watch API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchThrottled/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchThrottled } from '@vueuse/core'\n\nwatchThrottled(\n  source,\n  () => { console.log('changed!') },\n  { throttle: 500 },\n)\n```\n\n----------------------------------------\n\nTITLE: Using useWebWorkerFn with Local Dependencies - VueUse TypeScript\nDESCRIPTION: Shows how to pass locally defined dependencies to a function running in a Web Worker using useWebWorkerFn in a TypeScript Vue environment. The pow function is defined in the same module and injected into the worker via the localDependencies array, allowing the worker function to compute the square of a number array. Depends on @vueuse/core and requires that all local dependencies are serializable and included explicitly. Proper use is limited to stateless, pure utility functions as dependencies.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebWorkerFn/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useWebWorkerFn } from '@vueuse/core'\n\nconst pow = (a: number) => a * a\n\nconst { workerFn, workerStatus, workerTerminate } = useWebWorkerFn(\n  numbers => pow(numbers),\n  {\n    timeout: 50000,\n    localDependencies: [pow]\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Querying Mouse Position Using useMouseInElement Component Slot in Vue Template\nDESCRIPTION: This snippet demonstrates the use of a Vue component wrapper named UseMouseInElement which exposes mouse position data relative to an element through scoped slots. The template binds to elementX, elementY, and isOutside properties provided to the slot, allowing reactive usage of mouse coordinates and outside-element status directly in the template markup without imperative code.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouseInElement/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\\n  <UseMouseInElement v-slot=\"{ elementX, elementY, isOutside }\">\\n    x: {{ elementX }}\\n    y: {{ elementY }}\\n    Is Outside: {{ isOutside }}\\n  </UseMouseInElement>\\n</template>\n```\n\n----------------------------------------\n\nTITLE: Reading and updating 'search' query parameter reactively\nDESCRIPTION: This snippet shows how to access the current value of the reactive 'search' query parameter and update it, which in turn updates the URL query string via router.replace(). It demonstrates the bi-directional binding capability of useRouteQuery.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteQuery/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconsole.log(search.value)\nsearch.value = 'foobar' // router.replace({ query: { search: 'foobar' } })\n```\n\n----------------------------------------\n\nTITLE: Creating Global State with useRTDB and createGlobalState in JavaScript\nDESCRIPTION: Example showing how to use createGlobalState from the @vueuse/core package to create a reusable global state for the Firebase Realtime Database reference, making it accessible across multiple components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useRTDB/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// store.js\nimport { createGlobalState } from '@vueuse/core'\nimport { useRTDB } from '@vueuse/firebase/useRTDB'\n\nexport const useTodos = createGlobalState(\n  () => useRTDB(db.ref('todos')),\n)\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// app.js\nimport { useTodos } from './store'\n\nconst todos = useTodos()\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of reactivePick in TypeScript\nDESCRIPTION: Demonstrates the basic usage of `reactivePick` to create a new reactive object containing only the specified properties ('x', 'elementX') from the source reactive object `obj`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactivePick/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactivePick } from '@vueuse/core'\n\nconst obj = reactive({\n  x: 0,\n  y: 0,\n  elementX: 0,\n  elementY: 0,\n})\n\nconst picked = reactivePick(obj, 'x', 'elementX') // { x: number, elementX: number }\n```\n\n----------------------------------------\n\nTITLE: Draggable component usage (Vue)\nDESCRIPTION: This snippet showcases the component-based usage of `UseDraggable` (assuming it exists as a separate component within the VueUse library). The component uses a scoped slot to access the x and y coordinates of the dragged element. It also demonstrates setting the initial value of the draggable element's position.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDraggable/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseDraggable v-slot=\"{ x, y }\" :initial-value=\"{ x: 10, y: 10 }\">\n    Drag me! I am at {{ x }}, {{ y }}\n  </UseDraggable>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Programmatic reset and watch of useIdle in JavaScript\nDESCRIPTION: This snippet shows how to import additional VueUse hooks, such as useCounter, to increment a counter upon user becoming inactive. It also demonstrates using Vue's watch to trigger actions when the idle state changes, including calling reset to restart the idle timer without affecting lastActive timestamp.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useIdle/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useCounter, useIdle } from '@vueuse/core'\nimport { watch } from 'vue'\n\nconst { inc, count } = useCounter()\n\nconst { idle, lastActive, reset } = useIdle(5 * 60 * 1000) // 5 min\n\nwatch(idle, (idleValue) => {\n  if (idleValue) {\n    inc()\n    console.log(`Triggered ${count.value} times`)\n    reset() // restarts the idle timer. Does not change lastActive value\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using Lodash cloneDeep with useRefHistory\nDESCRIPTION: Shows how to integrate lodash's cloneDeep function for more robust object cloning when tracking history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRefHistory } from '@vueuse/core'\nimport { cloneDeep } from 'lodash-es'\n\nconst refHistory = useRefHistory(target, { clone: cloneDeep })\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useRTDB with Firebase Realtime Database in JavaScript\nDESCRIPTION: Example showing how to initialize Firebase and set up a reactive connection to a 'todos' reference in the Realtime Database using the useRTDB hook.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useRTDB/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useRTDB } from '@vueuse/firebase/useRTDB'\nimport { initializeApp } from 'firebase/app'\nimport { getDatabase } from 'firebase/database'\n\nconst app = initializeApp({ /* config */ })\nconst db = getDatabase(app)\n\n// in setup()\nconst todos = useRTDB(db.ref('todos'))\n```\n\n----------------------------------------\n\nTITLE: Using RxJS Subscription with useSubscription in Vue\nDESCRIPTION: This snippet demonstrates how to use the `useSubscription` composable to manage an RxJS subscription within a Vue component. It subscribes to an interval observable that increments a ref `count` value every second and logs the count to the console. The `useSubscription` function automatically handles unsubscribing from the subscription when the component unmounts, preventing memory leaks. The example uses the `interval` observable from `rxjs` and `ref` from Vue.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useSubscription/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useSubscription } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\n\nconst count = ref(0)\n\n// useSubscription call unsubscribe method before unmount the component\nuseSubscription(\n  interval(1000)\n    .subscribe(() => {\n      count.value++\n      console.log(count)\n    }),\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing System and Store Preferences JavaScript\nDESCRIPTION: Demonstrates destructuring the return value of `useColorMode` to access the `system` preference (from the browser) and the `store` preference (the user's potentially persisted override) separately. It also shows how to create a computed property `myColorMode` combining these two values.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useColorMode/index.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { useColorMode } from '@vueuse/core'\n\nconst { system, store } = useColorMode()\n\nsystem.value // 'dark' | 'light'\nstore.value // 'dark' | 'light' | 'auto'\n\nconst myColorMode = computed(() => store.value === 'auto' ? system.value : store.value)\n```\n\n----------------------------------------\n\nTITLE: Implementing Logic OR Condition in Vue.js with VueUse\nDESCRIPTION: This snippet demonstrates the usage of `logicOr` function from the VueUse library within a Vue.js context. It imports the `whenever` utility and `logicOr` from '@vueuse/math'. It defines two reactive variables, `a` and `b`, initialized as boolean refs. It then uses `whenever` with `logicOr(a, b)` to trigger a side effect (console log) when either `a` or `b` is truthy. The snippet showcases how to implement 'OR' logic with refs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/logicOr/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { whenever } from '@vueuse/core'\nimport { logicOr } from '@vueuse/math'\n\nconst a = ref(true)\nconst b = ref(false)\n\nwhenever(logicOr(a, b), () => {\n  console.log('either a or b is truthy!')\n})\n```\n\n----------------------------------------\n\nTITLE: Using useCssVar to Manage CSS Variables in Vue\nDESCRIPTION: This JavaScript snippet demonstrates the usage of the `useCssVar` composable from `@vueuse/core` in a Vue application. It shows how to bind a CSS variable (e.g., `--color`) to a reactive ref by targeting a DOM element obtained via `useTemplateRef`. The example also illustrates using a reactive `ref` for the CSS variable name itself and setting an initial value for the CSS variable if it's not already defined.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCssVar/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useTemplateRef } from 'vue'\nimport { useCssVar } from '@vueuse/core'\n\nconst el = useTemplateRef('el')\nconst color1 = useCssVar('--color', el)\n\nconst elv = useTemplateRef('elv')\nconst key = ref('--color')\nconst colorVal = useCssVar(key, elv)\n\nconst someEl = useTemplateRef('someEl')\nconst color2 = useCssVar('--color', someEl, { initialValue: '#eee' })\n```\n\n----------------------------------------\n\nTITLE: Creating and Exporting a Counter Store with TypeScript\nDESCRIPTION: Demonstrates how to create a counter store using createInjectionState. It defines state (count), getters (double), and actions (increment), and exports functions to provide and consume the store with different error handling approaches.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createInjectionState } from '@vueuse/core'\n// useCounterStore.ts\nimport { computed, shallowRef } from 'vue'\n\nconst [useProvideCounterStore, useCounterStore] = createInjectionState((initialValue: number) => {\n  // state\n  const count = shallowRef(initialValue)\n\n  // getters\n  const double = computed(() => count.value * 2)\n\n  // actions\n  function increment() {\n    count.value++\n  }\n\n  return { count, double, increment }\n})\n\nexport { useProvideCounterStore }\n// If you want to hide `useCounterStore` and wrap it in default value logic or throw error logic, please don't export `useCounterStore`\nexport { useCounterStore }\n\nexport function useCounterStoreWithDefaultValue() {\n  return useCounterStore() ?? {\n    count: shallowRef(0),\n    double: shallowRef(0),\n    increment: () => {},\n  }\n}\n\nexport function useCounterStoreOrThrow() {\n  const counterStore = useCounterStore()\n  if (counterStore == null)\n    throw new Error('Please call `useProvideCounterStore` on the appropriate parent component')\n  return counterStore\n}\n```\n\n----------------------------------------\n\nTITLE: Using whenever with Options Parameter in TypeScript\nDESCRIPTION: Shows how to pass options to whenever, such as the 'flush' option with value 'sync', controlling the timing of the watcher callback invocation. This is useful for fine-tuning behavior identical to Vue's watch options. The example watches a computed boolean and logs synchronously when true.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/whenever/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nwhenever(\n  () => counter.value === 7,\n  () => console.log('counter is 7 now!'),\n  { flush: 'sync' },\n)\n```\n\n----------------------------------------\n\nTITLE: Extending Watch Options in Vue Composables\nDESCRIPTION: This code snippet shows how to extend `WatchOptions` to include additional configurations, like `debounce`, for `watch` and `watchEffect`. This example defines a `WatchDebouncedOptions` interface that extends `WatchOptions` and includes a `debounce` property, then demonstrates its usage in a `watchDebounced` function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { WatchOptions } from 'vue'\n\n// extend the watch options\nexport interface WatchDebouncedOptions extends WatchOptions {\n  debounce?: number\n}\n\nexport function watchDebounced(\n  source: any,\n  cb: any,\n  options: WatchDebouncedOptions = {},\n): WatchStopHandle {\n  return watch(\n    source,\n    () => { /* ... */ },\n    options, // pass watch options\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useRouteParams in Vue\nDESCRIPTION: Demonstrates how to use the `useRouteParams` composable from `@vueuse/router` to access and update route parameters reactively. The composable takes the parameter name as the first argument and optionally a default value as the second argument. An options object can be provided for transformations. The returned value is a `Ref` that reflects the current value of the route parameter, and setting the `Ref` updates the route parameters.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteParams/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRouteParams } from '@vueuse/router'\n\nconst userId = useRouteParams('userId')\n\nconst userId = useRouteParams('userId', '-1') // or with a default value\n\nconst userId = useRouteParams('page', '1', { transform: Number }) // or transforming value\n\nconsole.log(userId.value) // route.params.userId\nuserId.value = '100' // router.replace({ params: { userId: '100' } })\n```\n\n----------------------------------------\n\nTITLE: useAxios with immediate option set to false\nDESCRIPTION: This example demonstrates using the `immediate` option to prevent the request from being executed immediately upon initialization. The `immediate: false` option is passed to the useAxios hook, so the request is not executed until triggered manually, such as by a button click or another event.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\nimport axios from 'axios'\n\nconst instance = axios.create({\n  baseURL: '/api',\n})\n\nconst { data, isFinished } = useAxios('/posts', { method: 'POST' }, instance, {\n  immediate: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useDevicePixelRatio Hook in Vue Setup\nDESCRIPTION: This snippet demonstrates how to import the useDevicePixelRatio hook from VueUse and use it within a Vue component setup function to obtain the current device pixel ratio reactively. It also shows how to expose pixelRatio for use in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicePixelRatio/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useDevicePixelRatio } from '@vueuse/core'\n\nexport default {\n  setup() {\n    const { pixelRatio } = useDevicePixelRatio()\n\n    return { pixelRatio }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using useTimeoutFn in Vue.js\nDESCRIPTION: This snippet demonstrates the use of the `useTimeoutFn` composable from the `@vueuse/core` library. It takes a callback function and a delay (in milliseconds) as arguments.  It returns an object with `isPending`, `start`, and `stop` properties, allowing control over the timeout.  It requires VueUse library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useTimeoutFn/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useTimeoutFn } from '@vueuse/core'\n\nconst { isPending, start, stop } = useTimeoutFn(() => {\n  /* ... */\n}, 3000)\n```\n\n----------------------------------------\n\nTITLE: Initializing reactive network status with VueUse in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use the useNetwork function from the @vueuse/core package in a JavaScript environment. It extracts reactive properties such as isOnline, offlineAt, downlink, downlinkMax, effectiveType, saveData, and type, enabling reactive monitoring of network status. The snippet logs the current online status using the reactive value isOnline.value. Dependencies include the VueUse library installed with network support.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNetwork/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useNetwork } from '@vueuse/core'\n\nconst { isOnline, offlineAt, downlink, downlinkMax, effectiveType, saveData, type } = useNetwork()\n\nconsole.log(isOnline.value)\n```\n\n----------------------------------------\n\nTITLE: Changing Element Focus via Button with useFocus in Vue SFC\nDESCRIPTION: Integrates useFocus into a Vue Single File Component, allowing button-triggered focus on an input element. When the button is clicked, the focused ref is set to true, automatically focusing the associated input. Dependencies include @vueuse/core, vue, and SFC support. Inputs: user clicks, component refs. Output: input field receives focus. Must coordinate component mounting and ref assignment.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFocus/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<script>\nimport { useFocus } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nexport default {\n  setup() {\n    const input = shallowRef()\n    const { focused } = useFocus(input)\n\n    return {\n      input,\n      focused,\n    }\n  }\n}\n</script>\n\n<template>\n  <div>\n    <button type=\"button\" @click=\"focused = true\">\n      Click me to focus input below\n    </button>\n    <input ref=\"input\" type=\"text\">\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Manually Cleaning Up useEventListener (TypeScript)\nDESCRIPTION: Illustrates that `useEventListener` returns a cleanup function. Calling this function explicitly removes the attached event listener before the component unmounts.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventListener/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEventListener } from '@vueuse/core'\n\nconst cleanup = useEventListener(document, 'keydown', (e) => {\n  console.log(e.key)\n})\n\ncleanup() // This will unregister the listener.\n```\n\n----------------------------------------\n\nTITLE: Using reactivePick to Simplify Reactive Subset Creation in Vue/TypeScript\nDESCRIPTION: Shows how `reactivePick` provides a more concise way to achieve the same result as the previous example. It directly picks the 'height' and 'width' properties from the result of `useElementBounding` into a new reactive object `size`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactivePick/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactivePick, useElementBounding } from '@vueuse/core'\n\nconst size = reactivePick(useElementBounding(), 'height', 'width')\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Nuxt module with nuxi\nDESCRIPTION: Command to add the VueUse module to a Nuxt application using the nuxi CLI tool, enabling auto-importing functionality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx nuxi@latest module add vueuse\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Event Handler for Magic Keys in TypeScript\nDESCRIPTION: Provides a way to intercept and handle specific key events by passing a custom 'onEventFired' callback in the useMagicKeys options. In this example, it prevents default save shortcut behavior if 'Ctrl+S' is pressed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys, whenever } from '@vueuse/core'\n\nconst { ctrl_s } = useMagicKeys({\n  passive: false,\n  onEventFired(e) {\n    if (e.ctrlKey && e.key === 's' && e.type === 'keydown')\n      e.preventDefault()\n  },\n})\n\nwhenever(ctrl_s, () => console.log('Ctrl+S have been pressed'))\n```\n\n----------------------------------------\n\nTITLE: Initializing usePreferredReducedTransparency with VueUse in JavaScript\nDESCRIPTION: This snippet shows how to import and initialize the usePreferredReducedTransparency function from VueUse in a JavaScript setup. It returns a reactive object that reflects whether the user prefers reduced transparency based on system settings.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredReducedTransparency/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { usePreferredReducedTransparency } from '@vueuse/core'\n\nconst preferredTransparency = usePreferredReducedTransparency()\n```\n\n----------------------------------------\n\nTITLE: Using watchWithFilter with debounceFilter in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `watchWithFilter` function from VueUse with a `debounceFilter`. It imports the necessary functions, sets up a source (implicitly `source`), defines a callback that logs a message, and configures the `eventFilter` option to use `debounceFilter(500)`, causing the callback to be delayed by 500 milliseconds after the source changes. It also mentions other filter options like `throttledFilter` or `pausableFilter`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchWithFilter/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { debounceFilter, watchWithFilter } from '@vueuse/core'\n\nwatchWithFilter(\n  source,\n  () => { console.log('changed!') }, // callback will be called in 500ms debounced manner\n  {\n    eventFilter: debounceFilter(500), // throttledFilter, pausableFilter or custom filters\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Binding Template Refs with useTemplateRefsList in Vue 3 - Vue (TypeScript)\nDESCRIPTION: This code snippet shows how to use the useTemplateRefsList composable from the @vueuse/core library within a Vue 3 Single File Component using TypeScript. It imports both useTemplateRefsList and the onUpdated lifecycle hook, sets up a refs collection for HTMLDivElement elements, and binds refs to div elements generated by a v-for loop in the template. The onUpdated function logs the current state of the refs. Required dependencies include Vue 3 and @vueuse/core. Inputs are the template refs created by the v-for loop; outputs are the collected refs. This pattern is only compatible with Vue 3.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTemplateRefsList/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useTemplateRefsList } from '@vueuse/core'\nimport { onUpdated } from 'vue'\n\nconst refs = useTemplateRefsList<HTMLDivElement>()\n\nonUpdated(() => {\n  console.log(refs)\n})\n</script>\n\n<template>\n  <div v-for=\"i of 5\" :key=\"i\" :ref=\"refs.set\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Configuring Flush Timing in VueUse Watchers (TypeScript)\nDESCRIPTION: Illustrates setting the `flush` option in `watch`-like composables, specifically `pausableWatch`. This example uses `{ flush: 'post' }` to ensure the watcher callback runs after component updates, allowing safe access to the updated DOM. Imports `pausableWatch` from `@vueuse/core` and `ref` from `vue`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/config.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pausableWatch } from '@vueuse/core'\nimport { ref } from 'vue'\n\nconst counter = ref(0)\nconst { pause, resume } = pausableWatch(\n  counter,\n  () => {\n    // Safely access updated DOM\n  },\n  { flush: 'post' },\n)\n```\n\n----------------------------------------\n\nTITLE: VueUse Web Bluetooth Sample Button\nDESCRIPTION: Provides a Vue template with a button to request a Bluetooth device. Similar to the previous button example, this allows user-initiated device connection within a Vue component.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBluetooth/index.md#_snippet_3\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <button @click=\"requestDevice()\">\n    Request Bluetooth Device\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Detecting Preferred Reduced Motion - JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to import and use the `usePreferredReducedMotion` composable from the `@vueuse/core` library. It retrieves the user's preference for reduced motion by calling the composable and assigns the result to the `preferredMotion` variable.  No parameters are required.  The output is a reactive boolean indicating if the user prefers reduced motion.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredReducedMotion/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { usePreferredReducedMotion } from '@vueuse/core'\n\nconst preferredMotion = usePreferredReducedMotion()\n```\n\n----------------------------------------\n\nTITLE: Getting Current Component Element with VueUse useCurrentElement (TypeScript)\nDESCRIPTION: Demonstrates the basic usage of `useCurrentElement` to get the root DOM element of the component where the hook is called. It returns a computed ref that updates when the component is mounted. This hook requires Vue 3 and works best with components having a single root element.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCurrentElement/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCurrentElement } from '@vueuse/core'\n\nconst el = useCurrentElement() // ComputedRef<Element>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Integration with EventBusKey\nDESCRIPTION: Shows how to use EventBusKey to bind specific event types to keys for type safety, similar to Vue's InjectionKey. This approach provides strong typing for event data passed through the bus.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventBus/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// fooKey.ts\nimport type { EventBusKey } from '@vueuse/core'\n\nexport const fooKey: EventBusKey<{ name: foo }> = Symbol('symbol-key')\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEventBus } from '@vueuse/core'\n\nimport { fooKey } from './fooKey'\n\nconst bus = useEventBus(fooKey)\n\nbus.on((e) => {\n  // `e` will be `{ name: foo }`\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Scroll Position Programmatically\nDESCRIPTION: Demonstrates how to programmatically set the scroll position by modifying the reactive x and y values returned by useScroll. Includes buttons to increment scroll position by 10px.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScroll/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useScroll } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst { x, y } = useScroll(el)\n</script>\n\n<template>\n  <div ref=\"el\" />\n  <button @click=\"x += 10\">\n    Scroll right 10px\n  </button>\n  <button @click=\"y += 10\">\n    Scroll down 10px\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using onKeyStroke as a Vue Directive\nDESCRIPTION: Describes how to attach keyboard event listeners directly within Vue templates using the v-on-key-stroke directive. Supports custom event types like 'keyup'. Requires implementing an 'onUpdate' handler in the script setup. Useful for declarative event binding in templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vOnKeyStroke } from '@vueuse/components'\n\nfunction onUpdate(e: KeyboardEvent) {\n  // impl...\n}\n</script>\n\n<template>\n  <input v-on-key-stroke:c,v=\"onUpdate\" type=\"text\">\n  <!-- with options -->\n  <input v-on-key-stroke:c,v=\"[onUpdate, { eventName: 'keyup' }]\" type=\"text\">\n</template>\n```\n\n----------------------------------------\n\nTITLE: Setting up viewport meta tag for safe areas in HTML\nDESCRIPTION: The required viewport meta tag configuration to enable full-screen rendering with safe area support. The viewport-fit=cover attribute is necessary for safe area insets to work properly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenSafeArea/index.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<meta name=\"viewport\" content=\"initial-scale=1, viewport-fit=cover\" />\n```\n\n----------------------------------------\n\nTITLE: Import and Initialize useDocumentVisibility in Vue\nDESCRIPTION: This code imports the useDocumentVisibility function from '@vueuse/core' and initializes it to create a reactive visibility state. It demonstrates programmatic usage within a setup function, suitable for integrating with Vue 3 components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDocumentVisibility/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useDocumentVisibility } from '@vueuse/core'\n\nconst visibility = useDocumentVisibility()\n```\n\n----------------------------------------\n\nTITLE: Dynamically Controlling and Resetting useCountdown Timer in Vue\nDESCRIPTION: Illustrates advanced control of the `useCountdown` timer. It uses a `shallowRef` for the initial countdown value, allowing dynamic updates. The example shows how to change the countdown value via the ref, start a new countdown with a specific duration using `start(newValue)`, reset the timer to a specific value without starting it using `reset(newValue)`, and start the timer with the current ref value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCountdown/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { shallowRef } from 'vue'\nimport { useCountdown } from '@vueuse/core'\n\nconst countdown = shallowRef(5)\nconst { start, reset } = useCountdown(countdown, {\n})\n\n// change the countdown value\ncountdown.value = 10\n\n// start a new countdown with 2 seconds\nstart(2)\n\n// reset the countdown to 4, but do not start it\nreset(4)\n\n// start the countdown with the current value of `countdown`\nstart()\n```\n\n----------------------------------------\n\nTITLE: Using useVModel in Options API with Vue\nDESCRIPTION: Example showing how to use the useVModel composable in a Vue component using the Options API. It creates a two-way binding for a 'data' prop and demonstrates both reading and updating the value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVModel/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useVModel } from '@vueuse/core'\n\nexport default {\n  setup(props, { emit }) {\n    const data = useVModel(props, 'data', emit)\n\n    console.log(data.value) // props.data\n    data.value = 'foo' // emit('update:data', 'foo')\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Display Media Stream with useDisplayMedia (TypeScript)\nDESCRIPTION: Imports the `useDisplayMedia` composable from `@vueuse/core` and destructures its returned reactive `stream` reference and the `start` function. Calling `start()` will prompt the user to select a screen or window to share, initiating the media stream.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDisplayMedia/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useDisplayMedia } from '@vueuse/core'\n\nconst { stream, start } = useDisplayMedia()\n\n// start streaming\n\nstart()\n```\n\n----------------------------------------\n\nTITLE: watchExtractedObservable with onError and onComplete in TypeScript\nDESCRIPTION: This snippet extends the previous example by adding custom error handling (`onError`) and completion handling (`onComplete`). If the watched observable errors, the `onError` callback is executed, and any error will be logged.  When the observable completes, the `onComplete` callback is triggered. Requires the `@vueuse/rxjs` library and the Vue.js core. The primary addition is the inclusion of the `onError` and `onComplete` configuration objects.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/watchExtractedObservable/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchExtractedObservable } from '@vueuse/rxjs'\nimport { computed, reactive, shallowRef } from 'vue'\nimport { AudioPlayer } from '../my/libs/AudioPlayer'\n\n// setup()\n\nconst audio = shallowRef<HTMLAudioElement>()\nconst player = computed(() => (audio.value ? new AudioPlayer(audio) : null))\nconst state = reactive({\n  progress: 0,\n})\n\nwatchExtractedObservable(player, p => p.progress$, (percentage) => {\n  state.progress = percentage * 100\n}, {\n  onError: (err: unknown) => {\n    console.error(err)\n  },\n  onComplete: () => {\n    state.progress = 100 // or 0, or whatever\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useArrayFind with Refs in VueUse (JavaScript)\nDESCRIPTION: Demonstrates importing `useArrayFind` from '@vueuse/core' and applying it to an array of `ref` objects. It finds the first element whose value satisfies the provided predicate function (val > 0) and returns a reactive reference to that value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFind/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useArrayFind } from '@vueuse/core'\n\nconst list = [ref(1), ref(-1), ref(2)]\nconst positive = useArrayFind(list, val => val > 0)\n// positive.value: 1\n```\n\n----------------------------------------\n\nTITLE: Supported Feature Detection in VueUse\nDESCRIPTION: Detects if certain features or APIs are supported in the current environment, enabling feature toggling in Vue apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Checks support for specific features or APIs in the current environment for adaptive Vue application behavior. */\n```\n\n----------------------------------------\n\nTITLE: Using UseOffsetPagination Component with Event Listeners\nDESCRIPTION: Example of the UseOffsetPagination component with event listener syntax for handling pagination events such as page-change, page-size-change, and page-count-change.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOffsetPagination/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseOffsetPagination\n    v-slot=\"{\n      currentPage,\n      currentPageSize,\n      next,\n      prev,\n      pageCount,\n      isFirstPage,\n      isLastPage,\n    }\"\n    :total=\"database.length\"\n    @page-change=\"fetchData\"\n    @page-size-change=\"fetchData\"\n    @page-count-change=\"onPageCountChange\"\n  >\n    <!-- your code -->\n  </UseOffsetPagination>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useNetwork inside a Vue component template with slot props\nDESCRIPTION: This Vue single file component snippet illustrates how to consume the useNetwork composable via a component named UseNetwork that provides reactive network properties through scoped slots. Inside the template, it uses slot props to display the current online status and network type dynamically. This pattern requires the UseNetwork component setup to internally use the useNetwork composable and expose its data, enabling declarative reactive UI updates based on network connectivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNetwork/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseNetwork v-slot=\"{ isOnline, type }\">\n    Is Online: {{ isOnline }}\n    Type: {{ type }}\n  </UseNetwork>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Manual cleanup of event listener using stop handler in TypeScript\nDESCRIPTION: Shows obtaining a stop function from useEventListener to manually remove the event listener when needed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useEventListener } from '@vueuse/core'\n// ---cut---\nconst stop = useEventListener('mousemove', () => {})\n\n// ...\n\n// unregister the event listener manually\nstop()\n```\n\n----------------------------------------\n\nTITLE: Limiting History Capacity with useRefHistory\nDESCRIPTION: Demonstrates how to set a maximum capacity for history records and how to manually clear the history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst refHistory = useRefHistory(target, {\n  capacity: 15, // limit to 15 history records\n})\n\nrefHistory.clear() // explicitly clear all the history\n```\n\n----------------------------------------\n\nTITLE: Implementing Smooth Scrolling Behavior\nDESCRIPTION: Shows how to enable smooth scrolling by setting the behavior option to 'smooth'. Also demonstrates how to make the behavior reactive using a computed property.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScroll/index.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { useScroll } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst { x, y } = useScroll(el, { behavior: 'smooth' })\n\n// Or as a `ref`:\nconst smooth = ref(false)\nconst behavior = computed(() => smooth.value ? 'smooth' : 'auto')\nconst { x, y } = useScroll(el, { behavior })\n```\n\n----------------------------------------\n\nTITLE: Initializing useVirtualList for Horizontal List in TypeScript\nDESCRIPTION: This snippet provides an example of setting up useVirtualList for horizontal scrolling by specifying itemWidth instead of itemHeight. It is suitable for lists that scroll horizontally, with each item rendered within a fixed width container.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVirtualList/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst allItems = Array.from(Array.from({ length: 99999 }).keys())\n\nconst { list, containerProps, wrapperProps } = useVirtualList(\n  allItems,\n  {\n    itemWidth: 200,\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing History Records with useRefHistory\nDESCRIPTION: Shows how history points are triggered asynchronously and how to access the history records after a ref value changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ncounter.value += 1\n\nawait nextTick()\nconsole.log(history.value)\n/* [\n  { snapshot: 1, timestamp: 1601912898062 },\n  { snapshot: 0, timestamp: 1601912898061 }\n] */\n```\n\n----------------------------------------\n\nTITLE: Monitoring Currently Pressed Keys with current Property in TypeScript\nDESCRIPTION: Uses the 'current' property to access the set of all keys pressed at the moment. Includes a condition to trigger an action only when 'a' is pressed without 'b', using 'whenever' with a reactive condition. Dependencies include '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys, whenever } from '@vueuse/core'\n\nconst { current } = useMagicKeys()\n\nconsole.log(current) // Set { 'control', 'a' }\n\nwhenever(\n  () => current.has('a') && !current.has('b'),\n  () => console.log('A is pressed but not B'),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Title Template Option for Dynamic Titles with VueUse in JavaScript\nDESCRIPTION: Demonstrates passing a second argument to useTitle to apply a title template. The template string uses a placeholder '%s' which is replaced by the reactive title value, enabling consistent branding or suffixing in the document title. Note that the 'observe' option cannot be used concurrently with 'titleTemplate'. This facilitates formatted title updates without manual string concatenation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTitle/index.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst title = useTitle('New Title', { titleTemplate: '%s | My Awesome Website' })\n```\n\n----------------------------------------\n\nTITLE: Batching Array Mutations with useRefHistory\nDESCRIPTION: Shows how to use batch() with array splice operations to ensure only one history point is generated for complex array mutations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst arr = ref([1, 2, 3])\nconst { history, batch } = useRefHistory(arr, { deep: true, flush: 'sync' })\n\nbatch(() => {\n  arr.value.splice(1, 1) // batch ensures only one history point is generated\n})\n```\n\n----------------------------------------\n\nTITLE: Getting and Setting WebFrame Zoom Factor in TypeScript using useZoomFactor\nDESCRIPTION: This snippet demonstrates how to import the useZoomFactor function, retrieve the current zoom factor, and update it reactively in a Vue component. It highlights how to interact with Electron's WebFrame API through VueUse's composable, with the assumption that Node integration is enabled if webFrame is not explicitly provided.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomFactor/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useZoomFactor } from '@vueuse/electron'\\n\\n// enable nodeIntegration if you don't provide webFrame explicitly\\n// @see: https://www.electronjs.org/docs/api/webview-tag#nodeintegration\\n// Ref result will return\\nconst factor = useZoomFactor()\\nconsole.log(factor.value) // print current zoom factor\\nfactor.value = 2 // change current zoom factor\n```\n\n----------------------------------------\n\nTITLE: Injecting Local Dependency in VueUse\nDESCRIPTION: Provides a mechanism to inject local dependencies into Vue components, enabling context-specific service provision or configuration. Depends on Vue's provide/inject API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Injects a local dependency or service into a Vue component context, utilizing Vue's provide/inject API for dependency injection within component hierarchies. */\n```\n\n----------------------------------------\n\nTITLE: Getting Reactive Element at Pointer Coordinates Using VueUse (TypeScript)\nDESCRIPTION: This snippet uses VueUse's useMouse to reactively track pointer coordinates in client space, then passes those coordinates to useElementByPoint which returns a reactive reference to the DOM element at those coordinates. It requires the '@vueuse/core' library. The inputs are reactive x and y values representing pointer coordinates, and the output is a reactive element reference updating in response to pointer movement. This supports dynamic element detection under the mouse pointer with TypeScript.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementByPoint/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useElementByPoint, useMouse } from '@vueuse/core'\n\nconst { x, y } = useMouse({ type: 'client' })\nconst { element } = useElementByPoint({ x, y })\n```\n\n----------------------------------------\n\nTITLE: Using Pausable Event Filters in VueUse (TypeScript)\nDESCRIPTION: Shows how to create a `pausableFilter` and apply it to `useDeviceMotion` via the `eventFilter` option. The filter allows pausing and resuming the motion updates programmatically using the `pause()` and `resume()` methods returned by `pausableFilter()`. Imports `pausableFilter` and `useDeviceMotion` from `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/config.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pausableFilter, useDeviceMotion } from '@vueuse/core'\n\nconst motionControl = pausableFilter()\n\nconst motion = useDeviceMotion({ eventFilter: motionControl.eventFilter })\n\nmotionControl.pause()\n// motion updates paused\n\nmotionControl.resume()\n// motion updates resumed\n```\n\n----------------------------------------\n\nTITLE: Using Callback with Previous and Current Values in whenever (TypeScript)\nDESCRIPTION: Illustrates passing a callback to whenever that receives the current and previous values along with an onInvalidate function, similar to Vue's watch callback signature. The example logs when the 'height' value increases with the difference. Requires that 'height' is a reactive or ref value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/whenever/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nwhenever(height, (current, lastHeight) => {\n  if (current > lastHeight)\n    console.log(`Increasing height by ${current - lastHeight}`)\n})\n```\n\n----------------------------------------\n\nTITLE: Using usePointer as a Vue Component with Local Element Targeting\nDESCRIPTION: This Vue component example illustrates how to target the pointer tracking to the current element. By setting `target=\"self\"`, the `usePointer` composable will calculate pointer positions relative to the element. This allows for local coordinate tracking within the element. This setup requires the `@vueuse/core` library to be installed and working within the Vue.js context.  The output will be x and y coordinates relative to the target element.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointer/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePointer v-slot=\"{ x, y }\" target=\"self\">\n    x: {{ x }} y: {{ y }}\n  </UsePointer>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Checking Ref Definition with VueUse isDefined in TypeScript\nDESCRIPTION: Demonstrates how to use the `isDefined` function from `@vueuse/core` to check if a Vue `Ref` contains a defined value (not null or undefined). This function acts as a type guard, narrowing the type of the `Ref` within the conditional block. It requires Vue and VueUse installed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/isDefined/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isDefined } from '@vueuse/core'\n\nconst example = ref(Math.random() ? 'example' : undefined) // Ref<string | undefined>\n\nif (isDefined(example))\n  example // Ref<string>\n```\n\n----------------------------------------\n\nTITLE: Increasing Values with Units in VueUse\nDESCRIPTION: Provides a utility to increase numerical values with optional units, supporting dynamic numerical adjustments in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Increases numerical values, appending specified units when applicable, facilitating dynamic UI updates in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Creating a Destructurable Object and Array with makeDestructurable in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the makeDestructurable function from the @vueuse/core library to create an entity that supports both object and array destructuring in TypeScript. It defines two constants, foo and bar, and combines them into an object that can be destructured either by property or by index. Prerequisites include installing @vueuse/core. Inputs are the source object and array; output is a combined object supporting both destructuring methods. This pattern is useful for developing utility libraries or APIs that offer flexible consumption.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/makeDestructurable/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeDestructurable } from '@vueuse/core'\n\nconst foo = { name: 'foo' }\nconst bar = 1024\n\nconst obj = makeDestructurable(\n  { foo, bar } as const,\n  [foo, bar] as const,\n)\n```\n\n----------------------------------------\n\nTITLE: Component Usage of useDark in Vue.js\nDESCRIPTION: Illustrates how to embed the useDark hook within a Vue component template, utilizing scoped slots to access reactive properties like isDark and toggleDark. This pattern supports interactive dark mode toggling in the UI.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDark/index.md#_snippet_3\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseDark v-slot=\"{ isDark, toggleDark }\">\n    <button @click=\"toggleDark()\">\n      Is Dark: {{ isDark }}\n    </button>\n  </UseDark>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using toRef Function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `toRef` function from `@vueuse/core` to convert a primitive value, an existing Vue `ref`, or a getter function into a reactive reference (`Ref` or `ComputedRef`). It shows the expected return type for each input type.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/toRef/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { toRef } from '@vueuse/core'\n\nconst foo = ref('hi')\n\nconst a = toRef(0) // Ref<number>\nconst b = toRef(foo) // Ref<string>\nconst c = toRef(() => 'hi') // ComputedRef<string>\n```\n\n----------------------------------------\n\nTITLE: Awaiting useFetch in Async Components (VueUse TypeScript)\nDESCRIPTION: Demonstrates using `useFetch` with the `await` keyword. This is suitable for use within asynchronous Vue components that are typically rendered inside a `<Suspense>` boundary. It executes the fetch and waits for completion before proceeding.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useFetch } from '@vueuse/core'\n\nconst { isFetching, error, data } = await useFetch(url)\n```\n\n----------------------------------------\n\nTITLE: Eager Computed in VueUse\nDESCRIPTION: Creates a computed property that evaluates eagerly on initialization and updates immediately when dependencies change, improving responsiveness.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Sets up an eager computed property that evaluates immediately and stays updated, improving responsiveness in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Mocking Global Dependencies for Testing in VueUse (TypeScript)\nDESCRIPTION: Shows how to provide a mock `window` object when using `useMouse` within a testing environment. This isolates the composable from the actual browser environment, enabling unit testing by passing the mock object via the `window` option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/config.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// testing\nconst mockWindow = { /* ... */ }\n\nconst { x, y } = useMouse({ window: mockWindow })\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reactive Computed Object with VueUse in TypeScript\nDESCRIPTION: This snippet demonstrates the creation of a reactive computed object using '@vueuse/core'. It shows importing the function, defining a reactive state with 'reactiveComputed', and accessing its properties reactively. Dependencies include VueUse's '@vueuse/core', and the code expects Vue 3's Composition API environment.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactiveComputed/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { reactiveComputed } from '@vueuse/core'\n\nconst state = reactiveComputed(() => {\n  return {\n    foo: 'bar',\n    bar: 'baz',\n  }\n})\n\nstate.bar // 'baz'\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Composable in VueUse\nDESCRIPTION: Defines a shared state or logic that can be reused across multiple Vue components, leveraging Composition API. Facilitates code reuse and state management within a Vue project.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Creates a shared composable that encapsulates reactive state or logic for reuse across Vue components, utilizing Vue's Composition API. Enhances modularity and DRY principles. */\n```\n\n----------------------------------------\n\nTITLE: useWebSocket with advanced heartbeat configuration\nDESCRIPTION: This code demonstrates more complex configuration for the heartbeat functionality. It allows specifying a custom message to send, the interval at which to send the message, and a timeout for the pong response. Dependencies include `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebSocket/index.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst { status, data, close } = useWebSocket('ws://websocketurl', {\n  heartbeat: {\n    message: 'ping',\n    interval: 1000,\n    pongTimeout: 1000,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Requesting and Managing Screen Wake Lock Using VueUse in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use the useWakeLock composable from VueUse. It provides reactive properties and methods to check API support (isSupported), determine if the wake lock is active (isActive), request a wake lock (request), release it (release), or force a wake lock request regardless of document visibility (forceRequest). The wake lock request is automatically queued if the document is hidden, making the API usage reactive to page visibility. Dependencies include VueUse core library and a modern browser supporting the Screen Wake Lock API. The snippet expects no inputs other than usage within a reactive Vue component context. Outputs are reactive state variables indicating lock status.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWakeLock/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useWakeLock } from '@vueuse/core'\n\nconst { isSupported, isActive, forceRequest, request, release } = useWakeLock()\n```\n\n----------------------------------------\n\nTITLE: Interacting with useColorMode Ref TypeScript\nDESCRIPTION: Shows how to read and write to the reactive `mode` reference obtained from `useColorMode`. Writing to the ref changes the color mode and persists it to local storage (by default), while reading returns the current active mode.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useColorMode/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nmode.value // 'dark' | 'light'\n\nmode.value = 'dark' // change to dark mode and persist\n\nmode.value = 'auto' // change to auto mode\n```\n\n----------------------------------------\n\nTITLE: Using the UseFocusTrap Component (Vue/TypeScript)\nDESCRIPTION: Demonstrates using the `UseFocusTrap` component, which automatically activates the focus trap when the component mounts and deactivates it when it unmounts. Options can be passed as a prop.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { UseFocusTrap } from '@vueuse/integrations/useFocusTrap/component'\nimport { shallowRef } from 'vue'\n\nconst show = shallowRef(false)\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <UseFocusTrap v-if=\"show\" :options=\"{ immediate: true }\">\n    <div class=\"modal\">\n      ...\n    </div>\n  </UseFocusTrap>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing auto-resetting reactive reference with VueUse in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the refAutoReset utility from the @vueuse/core package to create a reactive reference that automatically resets to a default value after a specified timeout in milliseconds. The key parameters are the initial default value (a string) and the reset delay (1000 ms). The ref's reactive value can be temporarily changed, and after the timeout elapses, it reverts to the initial default. Usage includes managing reactive state that self-resets without manual intervention and depends on Vue's reactivity system. It also notes that triggerRef can be used for triggering effects on deep mutations within the ref's value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refAutoReset/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { refAutoReset } from '@vueuse/core'\n\nconst message = refAutoReset('default message', 1000)\n\nfunction setMessage() {\n  // here the value will change to 'message has set' but after 1000ms, it will change to 'default message'\n  message.value = 'message has set'\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @vueuse/firebase and Firebase via npm (bash)\nDESCRIPTION: This snippet provides the npm command needed to install both the @vueuse/firebase add-on and the official firebase library as project dependencies. These packages are prerequisites for using the VueUse Firebase functions within a JavaScript or Vue 3 project. It is expected that Node.js and npm are already set up, and that Firebase version 9 or higher (modular API) is targeted.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/firebase firebase\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Refs Unidirectionally with VueUse syncRef (TypeScript)\nDESCRIPTION: Shows how to configure `syncRef` for one-way synchronization using the `direction` option. Setting `direction: 'rtl'` means changes to the right ref (`b`) will update the left ref (`a`), but not vice-versa.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRef/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { syncRef } from '@vueuse/core'\n\nconst a = ref('a')\nconst b = ref('b')\n\nconst stop = syncRef(a, b, { direction: 'rtl' })\n```\n\n----------------------------------------\n\nTITLE: Using UsePreferredDark Component in Vue\nDESCRIPTION: Example demonstrating how to use the UsePreferredDark component with Vue's slot API. This provides the dark theme preference through the slot props.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredDark/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePreferredDark v-slot=\"{ prefersDark }\">\n    Prefers Dark: {{ prefersDark }}\n  </UsePreferredDark>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useSupported to Check Navigator API Availability in TypeScript\nDESCRIPTION: Demonstrates importing and using the `useSupported` function from `@vueuse/core`. It takes a callback function that performs the feature detection (checking if `getBattery` exists in `navigator`). The function returns a reactive boolean ref (`isSupported`) which is `true` if the feature is supported and `false` otherwise, allowing conditional logic based on feature availability while maintaining SSR compatibility.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSupported/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useSupported } from '@vueuse/core'\n\nconst isSupported = useSupported(() => navigator && 'getBattery' in navigator)\n\nif (isSupported.value) {\n  // do something\n  navigator.getBattery\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Fetch Error Event (VueUse TypeScript)\nDESCRIPTION: Registers a callback function using `onFetchError` that is triggered whenever a fetch request fails. Useful for logging errors or displaying user notifications without modifying the data or error state managed by `useFetch`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst { onFetchResponse, onFetchError } = useFetch(url)\n\nonFetchError((error) => {\n  console.error(error.message)\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring useColorMode with Custom Modes JavaScript\nDESCRIPTION: Illustrates how to initialize `useColorMode` with a configuration object. This example sets a custom `attribute` for the DOM manipulation and defines additional custom color `modes` like 'dim' and 'cafe', allowing the ref to accept these new values.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useColorMode/index.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { useColorMode } from '@vueuse/core'\n\nconst mode = useColorMode({\n  attribute: 'theme',\n  modes: {\n    // custom colors\n    dim: 'dim',\n    cafe: 'cafe',\n  },\n}) // Ref<'dark' | 'light' | 'dim' | 'cafe'>\n```\n\n----------------------------------------\n\nTITLE: Watching Extracted Observable in VueUse RxJS\nDESCRIPTION: Sets up a watcher on a derived observable, allowing Vue components to react to stream emissions in real-time.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_46\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Watches an extracted observable for new emissions, updating Vue component state reactively. */\n```\n\n----------------------------------------\n\nTITLE: Custom Keyboard Event Name with onKeyStroke\nDESCRIPTION: Shows how to specify a different keyboard event, like 'keyup', for the onKeyStroke handler. Also, demonstrates alternative shorthand functions for specific event types, such as onKeyUp. Facilitates handling of different keyboard event phases.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nonKeyStroke('Shift', (e) => {\n  console.log('Shift key up')\n}, { eventName: 'keyup' })\n\n// or using shorthand\nonKeyUp('Shift', () => console.log('Shift key up'))\n```\n\n----------------------------------------\n\nTITLE: Customizing Event Listeners for useKeyModifier in VueUse (TypeScript)\nDESCRIPTION: This snippet illustrates how to customize the events that trigger state updates in useKeyModifier by passing an 'events' array. It demonstrates setting specific events and observing the reactive state changes upon user interaction.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useKeyModifier/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useKeyModifier } from '@vueuse/core'\n\nconst capsLockState = useKeyModifier('CapsLock', { events: ['mouseup', 'mousedown'] })\n\nconsole.log(capsLockState) // null\n\n// Caps Lock turned on with key press\nconsole.log(capsLockState) // null\n\n// Mouse button clicked\nconsole.log(capsLockState) // true\n```\n\n----------------------------------------\n\nTITLE: Using useActiveElement in Vue Component\nDESCRIPTION: This Vue component example shows how to use the `useActiveElement` composable within a Vue template. It uses a `v-slot` to access the active element and displays the `dataset.id` of the active element. This provides a direct way to access the active element and use its properties within a Vue component's template.\n\nDependencies: Requires the '@vueuse/core' library.\n\nParameters: The `v-slot` provides access to the active element as a prop named `element`.\n\nOutput: Displays the `dataset.id` attribute of the active element in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useActiveElement/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseActiveElement v-slot=\"{ element }\">\n    Active element is {{ element.dataset.id }}\n  </UseActiveElement>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing refWithControl and Using Ref\nDESCRIPTION: This snippet demonstrates the basic usage of `refWithControl` to create a controlled ref and how it interacts with a computed property. It shows how the reactivity system behaves with normal assignments and with the `set` method when the reactivity trigger is disabled.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refWithControl/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { refWithControl } from '@vueuse/core'\n\nconst num = refWithControl(0)\nconst doubled = computed(() => num.value * 2)\n\n// just like normal ref\nnum.value = 42\nconsole.log(num.value) // 42\nconsole.log(doubled.value) // 84\n\n// set value without triggering the reactivity\nnum.set(30, false)\nconsole.log(num.value) // 30\nconsole.log(doubled.value) // 84 (doesn't update)\n\n// get value without tracking the reactivity\nwatchEffect(() => {\n  console.log(num.peek())\n}) // 30\n\nnum.value = 50 // watch effect wouldn't be triggered since it collected nothing.\nconsole.log(doubled.value) // 100 (updated again since it's a reactive set)\n```\n\n----------------------------------------\n\nTITLE: Using Cookies in VueUse\nDESCRIPTION: Provides reactive access to browser cookies, enabling reading and writing cookies within Vue components with reactivity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_36\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactive management of browser cookies in Vue, supporting read/write operations with automatic updates. */\n```\n\n----------------------------------------\n\nTITLE: Using Geolocation API with VueUse in a Vue Component (Vue Template Syntax)\nDESCRIPTION: Demonstrates the usage of the UseGeolocation component with scoped slots in a Vue template to access latitude and longitude values reactively. The snippet shows how to integrate geolocation data directly within a Vue template, allowing reactive updates of location information. It depends on the useGeolocation functionality and Vue's slot system.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGeolocation/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseGeolocation v-slot=\"{ coords: { latitude, longitude } }\">\n    Latitude: {{ latitude }}\n    Longitude: {{ longitude }}\n  </UseGeolocation>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Manually Creating a Reactive Subset in Vue/TypeScript (Before reactivePick)\nDESCRIPTION: Demonstrates the traditional approach to creating a reactive object containing a subset of properties ('height', 'width') derived from the `useElementBounding` composable. This involves destructuring the desired properties and wrapping them in `reactive`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactivePick/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useElementBounding } from '@vueuse/core'\nimport { reactive } from 'vue'\n\nconst { height, width } = useElementBounding() // object of refs\nconst size = reactive({ height, width })\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse with npm\nDESCRIPTION: Command to install the VueUse core package using npm. Note that from v12.0, VueUse no longer supports Vue 2.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: Using vElementHover Directive for Hover Detection\nDESCRIPTION: This example shows how to use the vElementHover directive from @vueuse/components to track hover state. It uses a callback function to update a reactive reference when the hover state changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementHover/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vElementHover } from '@vueuse/components'\nimport { shallowRef } from 'vue'\n\nconst isHovered = shallowRef(false)\nfunction onHover(state: boolean) {\n  isHovered.value = state\n}\n</script>\n\n<template>\n  <button v-element-hover=\"onHover\">\n    {{ isHovered ? 'Thank you!' : 'Hover me' }}\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store with Default Value\nDESCRIPTION: Shows how to configure createInjectionState with a default value (0) that will be used when a component consumes the store without it being explicitly provided by a parent component.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createInjectionState } from '@vueuse/core'\n// useCounterStore.ts\nimport { computed, shallowRef } from 'vue'\n\nconst [useProvideCounterStore, useCounterStore] = createInjectionState((initialValue: number) => {\n  // state\n  const count = shallowRef(initialValue)\n\n  // getters\n  const double = computed(() => count.value * 2)\n\n  // actions\n  function increment() {\n    count.value++\n  }\n\n  return { count, double, increment }\n}, { defaultValue: 0 })\n```\n\n----------------------------------------\n\nTITLE: Manually Aborting Fetch Request (VueUse TypeScript)\nDESCRIPTION: Shows how to manually cancel an ongoing fetch request using the `abort` function returned by `useFetch`. The `canAbort` ref indicates whether the request is currently in a state where it can be aborted.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst { abort, canAbort } = useFetch(url)\n\nsetTimeout(() => {\n  if (canAbort.value)\n    abort()\n}, 100)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Keyframes for useAnimate (TypeScript)\nDESCRIPTION: Illustrates the different valid formats for the `keyframes` argument when using the `useAnimate` function, as specified by the Web Animations API. It shows examples using a single keyframe object, an array of keyframe objects, and a Vue `ref` containing an array of keyframes, providing flexibility in defining complex animation sequences.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useAnimate/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst keyframes = { transform: 'rotate(360deg)' }\n// Or\nconst keyframes = [\n  { transform: 'rotate(0deg)' },\n  { transform: 'rotate(360deg)' },\n]\n// Or\nconst keyframes = ref([\n  { clipPath: 'circle(20% at 0% 30%)' },\n  { clipPath: 'circle(20% at 50% 80%)' },\n  { clipPath: 'circle(20% at 100% 30%)' },\n])\n\nuseAnimate(el, keyframes, 1000)\n```\n\n----------------------------------------\n\nTITLE: TypeScript example demonstrating useFuse integration with Vue.js\nDESCRIPTION: This snippet shows how to import the useFuse composable and Vue's shallowRef, prepare data and input references, and invoke useFuse to perform fuzzy searching. It illustrates configuring the search input and retrieving search results from an array of names.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFuse/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useFuse } from '@vueuse/integrations/useFuse'\nimport { shallowRef } from 'vue'\n\nconst data = [\n  'John Smith',\n  'John Doe',\n  'Jane Doe',\n  'Phillip Green',\n  'Peter Brown',\n]\n\nconst input = shallowRef('Jhon D')\n\nconst { results } = useFuse(input, data)\n\n/*\n * Results:\n *\n * { \"item\": \"John Doe\", \"index\": 1 }\n * { \"item\": \"John Smith\", \"index\": 0 }\n * { \"item\": \"Jane Doe\", \"index\": 2 }\n *\n */\n```\n\n----------------------------------------\n\nTITLE: Rendering Device Orientation State with VueUse in Vue SFC\nDESCRIPTION: This Vue Single File Component snippet demonstrates usage of a VueUse component wrapper named UseDeviceOrientation, which exposes device orientation state reactively to the template via scoped slots. The alpha, beta, and gamma angles are destructured from the slot props and rendered dynamically. This approach abstracts the JavaScript logic and provides a declarative method to bind device orientation data in a Vue template. It requires the UseDeviceOrientation component to be globally or locally registered and the environment to support DeviceOrientationEvent.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDeviceOrientation/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseDeviceOrientation v-slot=\"{ alpha, beta, gamma }\">\n    Alpha: {{ alpha }}\n    Beta: {{ beta }}\n    Gamma: {{ gamma }}\n  </UseDeviceOrientation>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Consuming Global State in Vue Component (JS)\nDESCRIPTION: Demonstrates how a Vue component can consume the global state hook created using `createGlobalState`. The component imports the hook and calls it within the `setup` function to access the shared state object.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createGlobalState/index.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// component.js\nimport { useGlobalState } from './store'\n\nexport default defineComponent({\n  setup() {\n    const state = useGlobalState()\n    return { state }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Event Hook in VueUse\nDESCRIPTION: Defines a function to create a custom event hook, enabling components to emit and listen for events systematically within Vue.js applications, depending on Vue's reactivity system.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Function to create an event hook for Vue components, facilitating event-based communication. Requires Vue's reactivity system and composition API. Inputs include event name and handler; outputs a reactive event emitter. Designed for Vue 3 with TypeScript. */\n```\n\n----------------------------------------\n\nTITLE: Basic usage of useArrayReduce with ref values\nDESCRIPTION: Demonstrates the basic usage of useArrayReduce with an array of ref values to compute their sum reactively.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayReduce/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayReduce } from '@vueuse/core'\n\nconst sum = useArrayReduce([ref(1), ref(2), ref(3)], (sum, val) => sum + val)\n// sum.value: 6\n```\n\n----------------------------------------\n\nTITLE: Displaying Preferred Languages Using usePreferredLanguages in Vue Component\nDESCRIPTION: This snippet illustrates how to integrate the usePreferredLanguages composable within a Vue component using the scoped slot syntax. The component exposes the current preferred languages as a reactive property, allowing the template to dynamically display the user's preferred language list. Dependencies include Vue (version supporting scoped slots) and the '@vueuse/core' library. The languages variable reacts to changes in the browser's navigator.languages array.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredLanguages/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>  \n  <UsePreferredLanguages v-slot=\"{ languages }\">  \n    Preferred Languages: {{ languages }}  \n  </UsePreferredLanguages>  \n</template>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useTextDirection in TypeScript\nDESCRIPTION: Demonstrates how to import and use the useTextDirection function to get a reactive reference to the text direction of the HTML document.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextDirection/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useTextDirection } from '@vueuse/core'\n\nconst dir = useTextDirection() // Ref<'ltr' | 'rtl' | 'auto'>\n```\n\n----------------------------------------\n\nTITLE: Import and Initialize useWindowFocus in JavaScript\nDESCRIPTION: This snippet shows how to import the useWindowFocus composable from VueUse and initialize it within a script. It provides a reactive 'focused' variable indicating whether the window is focused or not. Dependencies include VueUse and a Vue project setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWindowFocus/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useWindowFocus } from '@vueuse/core'\n\nconst focused = useWindowFocus()\n```\n\n----------------------------------------\n\nTITLE: Waiting for Async State Ready with until - JavaScript\nDESCRIPTION: Demonstrates using `until` with `useAsyncState` to pause execution until the `isReady` ref becomes true after data is fetched asynchronously. This pattern ensures that the state is available before attempting to use it.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/until/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { until, useAsyncState } from '@vueuse/core'\n\nconst { state, isReady } = useAsyncState(\n  fetch('https://jsonplaceholder.typicode.com/todos/1').then(t => t.json()),\n  {},\n)\n\n;(async () => {\n  await until(isReady).toBe(true)\n\n  console.log(state) // state is now ready!\n})()\n```\n\n----------------------------------------\n\nTITLE: Importing and Using usePermission Composable in VueUse (JavaScript)\nDESCRIPTION: This snippet shows how to import the usePermission composable from the @vueuse/core package and use it to query the user's microphone access permission reactively. The usePermission function takes a permission name (such as 'microphone', 'camera', or 'geolocation') and returns a reactive value reflecting the permission state. Dependencies: @vueuse/core must be installed; the Permissions API must be supported by the browser. Input: permission name as a string. Output: a reactive reference containing the permission state. Limited by browser support and user privacy constraints.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePermission/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { usePermission } from '@vueuse/core'\n\nconst microphoneAccess = usePermission('microphone')\n```\n\n----------------------------------------\n\nTITLE: Using useTitle with non-reactive argument in VueUse\nDESCRIPTION: Shows how to use useTitle with a plain string to set and reactively update the document title based on reactive data, such as isDark in Vue's Composition API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @lib: dom\nimport { useDark, useTitle } from '@vueuse/core'\nimport { watch } from 'vue'\n// ---cut---\nconst isDark = useDark()\nconst title = useTitle('Hello')\n\nconsole.log(document.title) // \"Hello\"\n\nwatch(isDark, () => {\n  title.value = isDark.value ? 'üåô Good evening!' : '‚òÄÔ∏è Good morning!'\n})\n```\n\n----------------------------------------\n\nTITLE: Using tryOnMounted for Conditional Mounting Logic in Vue\nDESCRIPTION: Imports the `tryOnMounted` function from '@vueuse/core' and demonstrates its basic usage. The callback function passed to `tryOnMounted` will be executed via Vue's `onMounted` hook if the call occurs within a component's setup lifecycle; otherwise, the callback is invoked immediately.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/tryOnMounted/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { tryOnMounted } from '@vueuse/core'\n\ntryOnMounted(() => {\n\n})\n```\n\n----------------------------------------\n\nTITLE: Using useVModels Hook for v-model binding in Vue.js\nDESCRIPTION: This code illustrates how to utilize the useVModels hook from '@vueuse/core' for managing multiple v-model props within a Vue component. It manages props 'foo' and 'bar', converts them into reactive references, and automatically emits update events when their values change. Dependencies include Vue.js and the @vueuse/core library, with key parameters being 'props' and 'emit'. Inputs are component props, and the output is reactive references with synchronized emit events. This pattern simplifies v-model management with reactive state and emit triggers.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVModels/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useVModels } from '@vueuse/core'\n\nexport default {\n  props: {\n    foo: String,\n    bar: Number,\n  },\n  setup(props, { emit }) {\n    const { foo, bar } = useVModels(props, emit)\n\n    console.log(foo.value) // props.foo\n    foo.value = 'foo' // emit('update:foo', 'foo')\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using useWebWorkerFn with Remote Dependencies - VueUse TypeScript\nDESCRIPTION: Illustrates how to configure useWebWorkerFn in TypeScript with an external dependency (date-fns) by providing a CDN URL in the dependencies array. The defined worker function sorts an array of dates using dateFns.compareAsc, and options include a timeout for worker termination. Key parameters are the function that operates on input dates and the options object that specifies the dependency source and worker timeout. Requires access to the date-fns library via CDN and relies on @vueuse/core in a Vue application.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebWorkerFn/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useWebWorkerFn } from '@vueuse/core'\n\nconst { workerFn, workerStatus, workerTerminate } = useWebWorkerFn(\n  dates => dates.sort(dateFns.compareAsc),\n  {\n    timeout: 50000,\n    dependencies: [\n      'https://cdnjs.cloudflare.com/ajax/libs/date-fns/1.30.1/date_fns.js', // dateFns\n    ],\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Resolving References in VueUse\nDESCRIPTION: Provides a function to resolve Vue refs or reactive objects to their current value, simplifying reactive data handling.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Resolves Vue refs or reactive objects to their current value for straightforward reactive data access. */\n```\n\n----------------------------------------\n\nTITLE: Initializing usePreferredLanguages Hook with JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use the usePreferredLanguages composable from the '@vueuse/core' library in a JavaScript environment. It reactively provides an array of user preferred languages as reported by the browser's Navigator Languages API, which can be used to adapt the application's language settings dynamically. This requires a modern JavaScript setup that supports ES module imports and the @vueuse/core package.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredLanguages/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { usePreferredLanguages } from '@vueuse/core'  \n\nconst languages = usePreferredLanguages()\n```\n\n----------------------------------------\n\nTITLE: Using useArrayMap with reactive array in VueUse\nDESCRIPTION: This snippet shows how useArrayMap operates on a reactive array defined by ref, transforming each element by doubling it. It also demonstrates how modifying the original array affects the mapped result, ensuring reactive updates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayMap/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayMap } from '@vueuse/core'\n\nconst list = ref([0, 1, 2, 3, 4])\nconst result = useArrayMap(list, i => i * 2)\n// result.value: [0, 2, 4, 6, 8]\nlist.value.pop()\n// result.value: [0, 2, 4, 6]\n```\n\n----------------------------------------\n\nTITLE: Hiding Textarea Scrollbars with CSS\nDESCRIPTION: Provides CSS rules to hide the default scrollbars on a textarea element across different browsers (IE/Edge, Firefox, WebKit). This styling is recommended when using `useTextareaAutosize` to avoid incorrect height calculations for large amounts of text.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextareaAutosize/index.md#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\ntextarea {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n\ntextarea::-webkit-scrollbar {\n  display: none;\n}\n```\n\n----------------------------------------\n\nTITLE: Using onClickOutside Composable with Template Ref in Vue (vue)\nDESCRIPTION: Demonstrates usage of the onClickOutside composable function from @vueuse/core by manually binding a template ref in a Vue component. The example defines a ref named 'el' with useTemplateRef, assigns a handler function 'close' to run when a click outside occurs, and binds the ref to a div element within the template. This shows the lower-level manual approach before using renderless components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/components.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { onClickOutside } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef('el')\n\nfunction close() {\n  /* ... */\n}\n\nonClickOutside(el, close)\n</script>\n\n<template>\n  <div ref=\"el\">\n    Click Outside of Me\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Decoding JWT with useJwt (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to use the `useJwt` composable within a Vue 3 setup function. It imports the necessary functions from `@vueuse/integrations/useJwt` and `vue`. A reactive reference `encodedJwt` holds the JWT string. The `useJwt` composable takes this reference (or a plain string) as input and returns reactive references for the decoded `header` and `payload` of the JWT.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useJwt/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useJwt } from '@vueuse/integrations/useJwt'\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  setup() {\n    const encodedJwt = ref('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyfQ.L8i6g3PfcHlioHCCPURC9pmXT7gdJpx3kOoyAfNUwCc')\n    const { header, payload } = useJwt(encodedJwt)\n\n    return { header, payload }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Waiting for Custom Condition with until - JavaScript\nDESCRIPTION: Shows how to use `until` with a custom predicate function provided to the `toMatch` method. This allows waiting for a ref (like a counter) to satisfy a specific, user-defined condition before proceeding.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/until/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { invoke, until, useCounter } from '@vueuse/core'\n\nconst { count } = useCounter()\n\ninvoke(async () => {\n  await until(count).toMatch(v => v > 7)\n\n  alert('Counter is now larger than 7!')\n})\n```\n\n----------------------------------------\n\nTITLE: Using useClipboard with v-slot in Vue template\nDESCRIPTION: This snippet shows how to utilize the useClipboard composable in a scoped slot, providing 'copy' and 'copied' functions as slot props. It enables encapsulated copy functionality with clear user feedback.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useClipboard/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseClipboard v-slot=\"{ copy, copied }\" source=\"copy me\">\n    <button @click=\"copy()\">\n      {{ copied ? 'Copied' : 'Copy' }}\n    </button>\n  </UseClipboard>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFindIndex with Array of Refs in JavaScript\nDESCRIPTION: Demonstrates how to use the useArrayFindIndex function from VueUse to reactively find an index within an array containing multiple ref objects. Requires Vue 3's ref functionality and the @vueuse/core package. The snippet initializes a list of refs with numeric values and applies a predicate that checks for even numbers. As underlying ref values update, the computed index (result.value) updates reactively, reflecting the new first matching element. Inputs are refs in an array; output is a reactive ref holding the index.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFindIndex/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayFindIndex } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(2)\nconst item3 = ref(4)\nconst item4 = ref(6)\nconst item5 = ref(8)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArrayFindIndex(list, i => i % 2 === 0)\n// result.value: 0\nitem1.value = 1\n// result.value: 1\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Math Extension with npm\nDESCRIPTION: Command to install both the @vueuse/math extension and its required dependency @vueuse/core using npm package manager.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/math @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: Using reactivePick to Selectively Pass Props in Vue\nDESCRIPTION: Shows a practical use case in a Vue 3 `<script setup>` component where `reactivePick` is used to select specific props ('color', 'font') from the component's `props` object. This `childProps` object is then bound to a child component, ensuring only the selected props are passed down.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactivePick/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { reactivePick } from '@vueuse/core'\n\nconst props = defineProps({\n  value: {\n    default: 'value',\n  },\n  color: {\n    type: String,\n  },\n  font: {\n    type: String,\n  }\n})\n\nconst childProps = reactivePick(props, 'color', 'font')\n</script>\n\n<template>\n  <div>\n    <!-- only passes \"color\" and \"font\" props to child -->\n    <ChildComp v-bind=\"childProps\" />\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Providing and Injecting Locally with VueUse\nDESCRIPTION: Demonstrates using `provideLocal` to set a value associated with a key ('MyInjectionKey') and then using `injectLocal` to retrieve that value within the same Vue component's `<script setup>` block. This pattern allows for component-scoped dependency provision and injection. Requires importing `injectLocal` and `provideLocal` from '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/injectLocal/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { injectLocal, provideLocal } from '@vueuse/core'\n\nprovideLocal('MyInjectionKey', 1)\nconst injectedValue = injectLocal('MyInjectionKey') // injectedValue === 1\n</script>\n```\n\n----------------------------------------\n\nTITLE: Initializing useMouseInElement Composable with TypeScript in Vue\nDESCRIPTION: This snippet shows how to import and use the useMouseInElement composable from @vueuse/core within a Vue 3 script setup using TypeScript. It creates a reactive reference to a target element and uses the composable to track the mouse X and Y coordinates relative to that element, as well as whether the mouse is outside the element boundary. The snippet demonstrates usage of useTemplateRef to bind the element reference, and outputs reactive properties for convenient use in templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouseInElement/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\\nimport { useMouseInElement } from '@vueuse/core'\\nimport { useTemplateRef } from 'vue'\\n\\nconst target = useTemplateRef<HTMLDivElement>('target')\\n\\nconst { x, y, isOutside } = useMouseInElement(target)\\n</script>\\n\\n<template>\\n  <div ref=\"target\">\\n    <h1>Hello world</h1>\\n  </div>\\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayUnique with array of multiple refs in JavaScript\nDESCRIPTION: Demonstrates how to use useArrayUnique with an array containing multiple ref objects to create a reactive array with unique values. When a ref's value changes, the unique array updates accordingly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayUnique/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayUnique } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(1)\nconst item3 = ref(1)\nconst item4 = ref(2)\nconst item5 = ref(3)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArrayUnique(list)\n// result.value: [0, 1, 2, 3]\nitem5.value = 1\n// result.value: [0, 1, 2]\n```\n\n----------------------------------------\n\nTITLE: Reactive Mode for useMagicKeys in Vue with Template Example\nDESCRIPTION: Shows how to enable reactive mode in useMagicKeys so that key states can be used directly in Vue templates via reactive bindings. When 'reactive: true' is set, the object becomes reactive and can be used inside templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst keys = useMagicKeys({ reactive: true })\n```\n\n----------------------------------------\n\nTITLE: Using useChangeCase with refs and options (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the usage of `useChangeCase` with a `ref` and an options object.  It imports `useChangeCase` and `shallowRef` from 'vue'.  It shows how the computed value updates reactively when the source ref's changes.  The options object allows for customization, in this case, setting a delimiter.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useChangeCase/index.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { useChangeCase } from '@vueuse/integrations/useChangeCase'\nimport { shallowRef } from 'vue'\n\nconst input = shallowRef('helloWorld')\nconst changeCase = useChangeCase(input, 'camelCase', {\n  delimiter: '-',\n})\nchangeCase.value // hello-World\ninput.value = 'vue use'\nchangeCase.value // vue-Use\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useScreenOrientation in TypeScript\nDESCRIPTION: Demonstrates how to import and use the useScreenOrientation hook to access screen orientation information. Returns isSupported flag, current orientation, angle, and methods to lock/unlock the orientation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenOrientation/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useScreenOrientation } from '@vueuse/core'\n\nconst {\n  isSupported,\n  orientation,\n  angle,\n  lockOrientation,\n  unlockOrientation,\n} = useScreenOrientation()\n```\n\n----------------------------------------\n\nTITLE: useFocusTrap with Multiple Refs (Vue/TypeScript)\nDESCRIPTION: Illustrates how to use `useFocusTrap` to trap focus within multiple target elements by passing an array of refs to the composable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { useTemplateRef } from 'vue'\n\nconst targetOne = useTemplateRef<HTMLDivElement>('targetOne')\nconst targetTwo = useTemplateRef<HTMLDivElement>('targetTwo')\nconst { hasFocus, activate, deactivate } = useFocusTrap([targetOne, targetTwo])\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div>\n    <button @click=\"activate()\">\n      Activate\n    </button>\n    <div ref=\"targetOne\">\n      <span>Has Focus: {{ hasFocus }}</span>\n      <input type=\"text\">\n    </div>\n    ...\n    <div ref=\"targetTow\">\n      <p>Another target here</p>\n      <input type=\"text\">\n      <button @click=\"deactivate()\">\n        Deactivate\n      </button>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayUnique with reactive array in JavaScript\nDESCRIPTION: Shows how to use useArrayUnique with a reactive array to maintain a derived array with only unique values. When the source array changes, the unique array updates automatically.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayUnique/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayUnique } from '@vueuse/core'\n\nconst list = reactive([1, 2, 2, 3])\nconst result = useArrayUnique(list)\n// result.value: [1, 2, 3]\n\nlist.push(1)\n// result.value: [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useMounted in Vue.js\nDESCRIPTION: Shows how to import and use the useMounted composable to get a reactive reference that indicates if a component is mounted.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMounted/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useMounted } from '@vueuse/core'\n\nconst isMounted = useMounted()\n```\n\n----------------------------------------\n\nTITLE: Configuring useSpeechSynthesis Options in TypeScript\nDESCRIPTION: Shows how to customize the speech synthesis behavior by passing configuration options to the useSpeechSynthesis function. These options are passed directly to the browser's SpeechSynthesis API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSpeechSynthesis/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nuseSpeechSynthesis({\n  lang: 'en-US',\n  pitch: 1,\n  rate: 1,\n  volume: 1,\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Composable Return Values via v-slot in Vue Components (vue)\nDESCRIPTION: Provides two examples using v-slot syntax to destructure reactive return values from renderless components UseMouse and UseDark. The UseMouse example exposes 'x' and 'y' coordinates of the mouse, and the UseDark example exposes 'isDark' boolean state along with 'toggleDark' function. This pattern facilitates reactive data sharing from composables to templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/components.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseMouse v-slot=\"{ x, y }\">\n    x: {{ x }}\n    y: {{ y }}\n  </UseMouse>\n</template>\n```\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseDark v-slot=\"{ isDark, toggleDark }\">\n    <button @click=\"toggleDark()\">\n      Is Dark: {{ isDark }}\n    </button>\n  </UseDark>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Server-Side Rendering Configuration with useBreakpoints\nDESCRIPTION: Demonstrates how to configure useBreakpoints for server-side rendering scenarios including Nuxt.js. Shows how to specify the screen width for the server-side render to avoid hydration mismatches.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBreakpoints/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { breakpointsTailwind, useBreakpoints } from '@vueuse/core'\n\nconst breakpoints = useBreakpoints(\n  breakpointsTailwind,\n  { ssrWidth: 768 } // Will enable SSR mode and render like if the screen was 768px wide\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing useFullscreen Hook (JavaScript)\nDESCRIPTION: Imports and initializes the `useFullscreen` hook from VueUse. It destructures `isFullscreen`, `enter`, `exit`, and `toggle` methods for controlling the fullscreen state. This basic usage typically applies to the document body if no target element is provided. Requires `@vueuse/core` and `vue` dependencies.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFullscreen/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useFullscreen } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst { isFullscreen, enter, exit, toggle } = useFullscreen()\n```\n\n----------------------------------------\n\nTITLE: Using UseNow component in Vue Template\nDESCRIPTION: Demonstrates how to use the `<UseNow>` component in a Vue template. It utilizes the default slot to expose the reactive `now` value and the `pause`/`resume` control functions for rendering and interaction.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNow/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseNow v-slot=\"{ now, pause, resume }\">\n    Now: {{ now }}\n    <button @click=\"pause()\">\n      Pause\n    </button>\n    <button @click=\"resume()\">\n      Resume\n    </button>\n  </UseNow>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayIncludes with a Reactive Array in JavaScript\nDESCRIPTION: Demonstrates importing `useArrayIncludes` from `@vueuse/core` and applying it to a reactive array (`ref`) and a search value. The returned `result` is a reactive computed ref that automatically updates its boolean value (true/false) based on whether the value exists in the array, reacting to changes like `push` and `pop` on the source array.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayIncludes/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayIncludes } from '@vueuse/core'\n\nconst list = ref([0, 2, 4, 6, 8])\nconst result = useArrayIncludes(list, 10)\n// result.value: false\nlist.value.push(10)\n// result.value: true\nlist.value.pop()\n// result.value: false\n```\n\n----------------------------------------\n\nTITLE: Creating and Displaying Web Notifications with VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `useWebNotification` composable in Vue.js to display a desktop notification. It initializes the notification with various options like title, direction, language, and more. Before showing the notification, it checks if the browser supports it and if the user has granted permission. This snippet uses the `isSupported` and `permissionGranted` reactive variables to control the notification's visibility.  The core functionality is provided by the `@vueuse/core` library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebNotification/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst {\n  isSupported,\n  notification,\n  permissionGranted,\n  show,\n  close,\n  onClick,\n  onShow,\n  onError,\n  onClose,\n} = useWebNotification({\n  title: 'Hello, VueUse world!',\n  dir: 'auto',\n  lang: 'en',\n  renotify: true,\n  tag: 'test',\n})\n\nif (isSupported.value && permissionGranted.value)\n  show()\n```\n\n----------------------------------------\n\nTITLE: vResizeObserver Directive Usage in Vue (TypeScript)\nDESCRIPTION: Shows how to use the `vResizeObserver` directive to observe changes in an element's dimensions. It imports the directive from `@vueuse/components` and defines a callback function to handle the resize events. Requires Vue 3 and TypeScript for type safety.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useResizeObserver/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vResizeObserver } from '@vueuse/components'\n\nconst text = ref('')\n\nfunction onResizeObserver(entries) {\n  const [entry] = entries\n  const { width, height } = entry.contentRect\n  text.value = `width: ${width}, height: ${height}`\n}\n</script>\n\n<template>\n  <div v-resize-observer=\"onResizeObserver\">\n    {{ text }}\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using UseColorMode Component Vue Template\nDESCRIPTION: Shows how to use the renderless `<UseColorMode>` component in a Vue template. It utilizes a v-slot to expose the reactive `mode` reference to the component's content, enabling easy binding and interaction within the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useColorMode/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseColorMode v-slot=\"{ mode }\">\n    <button @click=\"mode = mode === 'dark' ? 'light' : 'dark'\">\n      Mode {{ mode }}\n    </button>\n  </UseColorMode>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Debouncing with Max Wait Time\nDESCRIPTION: This snippet demonstrates `useDebounceFn` with a maximum wait time. It imports `useDebounceFn` and `useEventListener`. The `debouncedFn` function is created with a delay of 1000ms and a maxWait of 5000ms. If the function is invoked repeatedly, the function will be called after 5000ms even if the delay hasn't been reached due to repeated input. Then, it attaches the debounced function to the `resize` event of the window.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDebounceFn/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { useDebounceFn, useEventListener } from '@vueuse/core'\n\n// If no invokation after 5000ms due to repeated input,\n// the function will be called anyway.\nconst debouncedFn = useDebounceFn(() => {\n  // do something\n}, 1000, { maxWait: 5000 })\n\nuseEventListener(window, 'resize', debouncedFn)\n```\n\n----------------------------------------\n\nTITLE: Using useIdle in Vue component template\nDESCRIPTION: This snippet illustrates integration of useIdle within a Vue component's template via the v-slot syntax, displaying the current idle state. The component provides a timeout prop to customize the inactivity duration and reactive display of the user idle status.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useIdle/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseIdle v-slot=\"{ idle }\" :timeout=\"5 * 60 * 1000\">\n    Is Idle: {{ idle }}\n  </UseIdle>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useTextSelection in a Vue 3 Component with TypeScript\nDESCRIPTION: This code demonstrates how to import and utilize the useTextSelection composable within a Vue 3 component set up with the script setup syntax and TypeScript. It initializes reactive state that contains the user's current text selection, and displays the selected text in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextSelection/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useTextSelection } from '@vueuse/core'\nconst state = useTextSelection()\n</script>\n\n<template>\n  <p>{{ state.text }}</p>\n</template>\n```\n\n----------------------------------------\n\nTITLE: watchDebounced Equivalent Using debounceFilter and watchWithFilter (TypeScript)\nDESCRIPTION: This snippet shows how `watchDebounced` is internally implemented using `debounceFilter` and `watchWithFilter` from the `@vueuse/core` library. This code provides an alternative way to achieve the same result as the previous snippet, showing that `watchDebounced` is a shorthand for the more verbose implementation. It showcases the usage of `debounceFilter` which filters events based on the provided delay and `maxWait`. Dependencies include the `@vueuse/core` library. The expected output is the console logging of \"changed!\" after the debouncing period if the `source` value changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchDebounced/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { debounceFilter, watchWithFilter } from '@vueuse/core'\n\nwatchWithFilter(\n  source,\n  () => { console.log('changed!') },\n  {\n    eventFilter: debounceFilter(500, { maxWait: 1000 }),\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of extendRef with Static Data in TypeScript\nDESCRIPTION: Demonstrates how to add a static extra attribute to a Vue Ref. The example creates a shallow ref and extends it with a simple string property, showing how both the original value and the new property can be accessed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/extendRef/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { extendRef } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst myRef = shallowRef('content')\n\nconst extended = extendRef(myRef, { foo: 'extra data' })\n\nextended.value === 'content'\nextended.foo === 'extra data'\n```\n\n----------------------------------------\n\nTITLE: Accessing reactive ref value using VueUse 'get' function in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the 'get' function from '@vueuse/core' to simplify access to Vue's reactive ref values. It imports 'get', initializes a ref with a value, and logs the current value using 'get'. Dependencies include Vue's reactivity API and VueUse library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/get/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { get } from '@vueuse/core'\n\nconst a = ref(42)\n\nconsole.log(get(a)) // 42\n```\n\n----------------------------------------\n\nTITLE: Initializing Web Worker with VueUse Composable in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and use the useWebWorker composable from the '@vueuse/core' package in a Vue 3 application for registering and communicating with a Web Worker. Required dependency is @vueuse/core. The useWebWorker function is called with the path to a JavaScript worker file, returning reactive references to the worker instance and data, as well as 'post' and 'terminate' methods for managing worker communication and lifecycle. Inputs include the worker file path; outputs are an object containing { data, post, terminate, worker }. This approach is limited to browsers that support Web Workers and requires proper path setup for the worker script.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebWorker/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useWebWorker } from '@vueuse/core'\n\nconst { data, post, terminate, worker } = useWebWorker('/path/to/worker.js')\n```\n\n----------------------------------------\n\nTITLE: Using useImage Composable with VueUse in Vue\nDESCRIPTION: This snippet demonstrates how to use the useImage composable function from the @vueuse/core package to reactively load an image within a Vue component using the <script setup> syntax. It defines an image URL, initializes the useImage hook with the src option, and conditionally renders a loading indicator or the image based on the isLoading state. Dependencies include Vue 3 (with <script setup> support) and @vueuse/core. The src property expects a valid image URL, and the composable returns loading status for UI feedback.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useImage/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useImage } from '@vueuse/core'\n\nconst avatarUrl = 'https://place.dog/300/200'\nconst { isLoading } = useImage({ src: avatarUrl })\n</script>\n\n<template>\n  <span v-if=\"isLoading\">Loading</span>\n  <img v-else :src=\"avatarUrl\">\n</template>\n```\n\n----------------------------------------\n\nTITLE: Updating WebFrame Zoom Level with VueUse and a Ref (JavaScript)\nDESCRIPTION: This JavaScript snippet showcases how to use `useZoomLevel` with a Vue ref to automatically update the zoom level.  It imports `shallowRef` from 'vue' and uses it to create a reactive level ref. The `useZoomLevel` function is then called with this ref. When the ref's value changes, the web frame zoom level will automatically update. This enables binding of zoom to other data in the application.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomLevel/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { shallowRef } from 'vue'\nimport { useZoomLevel } from '@vueuse/electron'\n\nconst level = shallowRef(1)\n\nuseZoomLevel(level) // zoom level will match with the ref\n\nlevel.value = 2 // zoom level will change\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useMousePressed with VueUse in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of useMousePressed in a JavaScript environment. It imports the useMousePressed composable from @vueuse/core and retrieves the reactive pressed state. No special dependencies are needed beyond @vueuse/core. The returned pressed value dynamically reflects whether a mouse or touch is currently active anywhere on the window.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMousePressed/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useMousePressed } from '@vueuse/core'\n\nconst { pressed } = useMousePressed()\n```\n\n----------------------------------------\n\nTITLE: Observing computedWithControl Behavior in TypeScript\nDESCRIPTION: Illustrates the behavior of a computed ref created with `computedWithControl`. It shows that modifying the ref used only in the getter (`counter`) does not trigger a recomputation, while modifying the ref specified as the watch source (`source`) does trigger a recomputation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/computedWithControl/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.log(computedRef.value) // 0\n\ncounter.value += 1\n\nconsole.log(computedRef.value) // 0\n\nsource.value = 'bar'\n\nconsole.log(computedRef.value) // 1\n```\n\n----------------------------------------\n\nTITLE: Configuring Media Devices with useUserMedia - JavaScript\nDESCRIPTION: This snippet illustrates how to use `useDevicesList` to get available media devices (cameras and microphones) and pass device constraints to `useUserMedia`.  It retrieves available devices with their properties. It sets up reactive variables to select a camera and microphone. The `useUserMedia` then uses these values in constraints to capture the desired media stream.  Requires the VueUse library and assumes the devices are correctly connected.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUserMedia/index.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { useDevicesList, useUserMedia } from '@vueuse/core'\n\nconst {\n  videoInputs: cameras,\n  audioInputs: microphones,\n} = useDevicesList({\n  requestPermissions: true,\n})\nconst currentCamera = computed(() => cameras.value[0]?.deviceId)\nconst currentMicrophone = computed(() => microphones.value[0]?.deviceId)\n\nconst { stream } = useUserMedia({\n  constraints: reactive({\n    video: { deviceId: currentCamera },\n    audio: { deviceId: currentMicrophone, }\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using useArraySome with Reactive Array in JavaScript\nDESCRIPTION: This snippet illustrates the application of the useArraySome composable on a reactive array ref. The array is defined as a ref holding primitive values, and useArraySome tracks the array to determine if any element satisfies the predicate (i > 10). Upon adding a new element meeting the condition, the output reactive value updates accordingly. Required dependencies include Vue's ref and @vueuse/core's useArraySome. The inputs are the reactive array ref and the predicate function, and the output is a reactive boolean ref indicating predicate matches.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArraySome/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArraySome } from '@vueuse/core'\n\nconst list = ref([0, 2, 4, 6, 8])\nconst result = useArraySome(list, i => i > 10)\n// result.value: false\nlist.value.push(11)\n// result.value: true\n```\n\n----------------------------------------\n\nTITLE: Creating a Throttled Watcher with Manual Event Filter in VueUse (TypeScript)\nDESCRIPTION: Shows the explicit construction of a throttled watcher using watchWithFilter and throttleFilter from @vueuse/core. To use, import both dependencies, pass a reactive source, a callback, and set the eventFilter option to the result of throttleFilter(throttleMs). This enables fine-grained control over throttle mechanics; accepts the same parameters as watchThrottled, but event filtering allows further customization of watcher invocation rates. Inputs and outputs are consistent with Vue's standard watch API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchThrottled/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { throttleFilter, watchWithFilter } from '@vueuse/core'\n\nwatchWithFilter(\n  source,\n  () => { console.log('changed!') },\n  {\n    eventFilter: throttleFilter(500),\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using useSortable with CSS selector for root element\nDESCRIPTION: Example showing how to use useSortable with a CSS selector string instead of a template ref to target the sortable container element.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useSortable/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useSortable } from '@vueuse/integrations/useSortable'\nimport { shallowRef } from 'vue'\n\nconst list = shallowRef([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\n\nuseSortable('#dv', list)\n</script>\n\n<template>\n  <div id=\"dv\">\n    <div v-for=\"item in list\" :key=\"item.id\">\n      <span>{{ item.name }}</span>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useTransition with Numeric Source Value in JavaScript\nDESCRIPTION: Demonstrates the basic usage of useTransition by defining a numeric Vue ref as the source value. When the source changes, output smoothly transitions to the new value over the specified duration and easing preset. Requires Vue's shallowRef for reactive source state and '@vueuse/core' for useTransition and TransitionPresets. Parameters include the source ref and an options object specifying duration (milliseconds) and transition easing preset. Outputs a reactive value that follows the source with the defined transition.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { TransitionPresets, useTransition } from '@vueuse/core'\\nimport { shallowRef } from 'vue'\\n\\nconst source = shallowRef(0)\\n\\nconst output = useTransition(source, {\\n  duration: 1000,\\n  transition: TransitionPresets.easeInOutCubic,\\n})\n```\n\n----------------------------------------\n\nTITLE: Watching Arrays Using VueUse watchArray in TypeScript\nDESCRIPTION: This snippet shows how to use the watchArray function from '@vueuse/core' to monitor changes in a reactive array ref. It tracks the new and old values of the array and additionally identifies elements added or removed between updates. The snippet also includes an onMounted hook to demonstrate updating the array reactively by appending a new element. Dependencies include Vue's ref and onMounted hooks as well as watchArray from VueUse. Input is the reactive array 'list', and output occurs via console logs detailing the array changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchArray/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchArray } from '@vueuse/core'\n\nconst list = ref([1, 2, 3])\n\nwatchArray(list, (newList, oldList, added, removed) => {\n  console.log(newList) // [1, 2, 3, 4]\n  console.log(oldList) // [1, 2, 3]\n  console.log(added) // [4]\n  console.log(removed) // []\n})\n\nonMounted(() => {\n  list.value = [...list.value, 4]\n})\n```\n\n----------------------------------------\n\nTITLE: Using useArrayReduce with a reactive array\nDESCRIPTION: Shows how to use useArrayReduce with a reactive array, where changes to the array will automatically update the reduced value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayReduce/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayReduce } from '@vueuse/core'\n\nconst list = reactive([1, 2])\nconst sum = useArrayReduce(list, (sum, val) => sum + val)\n\nlist.push(3)\n// sum.value: 6\n```\n\n----------------------------------------\n\nTITLE: Monitoring Multi-Key Shortcut with Destructured Keys in TypeScript\nDESCRIPTION: Illustrates destructuring multiple key states such as Control+A+B and setting up watchers to respond to their activation. Useful for handling custom hotkeys fetchable via useMagicKeys. Dependencies involve '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys } from '@vueuse/core'\n\nconst { Ctrl_A_B, space, alt_s } = useMagicKeys()\n\nwatch(Ctrl_A_B, (v) => {\n  if (v)\n    console.log('Control+A+B have been pressed')\n})\n```\n\n----------------------------------------\n\nTITLE: Changing Favicon Using useFavicon in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `useFavicon` composable. It imports the composable from the `@vueuse/core` library. It then initializes `useFavicon` and directly assigns a new icon path to change the current favicon.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFavicon/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useFavicon } from '@vueuse/core'\n\nconst icon = useFavicon()\n\nicon.value = 'dark.png' // change current icon\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Data Fetching Pipeline with RxJS and Vue Refs (TypeScript)\nDESCRIPTION: This snippet demonstrates the integration of Vue's ref and @vueuse/rxjs's reactive wrappers with a chain of RxJS operators. It binds an HTMLButtonElement as a Vue ref, listens for click events, fetches posts data via ajax, and for each post, retrieves comment counts and user names through chained observables. Operators used include mergeMap, concatAll, forkJoin, scan, and pluck. Required dependencies: @vueuse/rxjs, rxjs, vue, and rxjs/ajax. Inputs include button element references and API endpoints; output is a reactive data array, automatically updated in the Vue component. Limitations: network connectivity required, basic error handling omitted for brevity.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { from, fromEvent, useObservable } from '@vueuse/rxjs'\nimport { forkJoin, of } from 'rxjs'\nimport { ajax } from 'rxjs/ajax'\nimport { concatAll, map, mergeMap, pluck, scan, take } from 'rxjs/operators'\nimport { ref } from 'vue'\n\nconst BASE_URL = 'https://jsonplaceholder.typicode.com'\nconst button = ref<HTMLButtonElement>(null)\n\nconst posts = useObservable(\n  fromEvent(button, 'click').pipe(\n    mergeMap(() => ajax.getJSON(`${BASE_URL}/posts`).pipe(\n      concatAll(),\n      take(4),\n      mergeMap(({ id, userId, title }) => forkJoin({\n        id: of(id),\n        comments: ajax.getJSON(`${BASE_URL}/posts/${id}/comments`).pipe(\n          map(comments => comments.length),\n        ),\n        username: ajax.getJSON(`${BASE_URL}/users/${userId}`).pipe(\n          pluck('username'),\n        ),\n      }), 2),\n      scan((acc, curr) => [...acc, curr], []),\n    )),\n  ),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Using useArrayEvery with Reactive Array in VueUse (JavaScript)\nDESCRIPTION: This snippet shows how to use useArrayEvery with a reactive array to check if all elements satisfy a predicate in real-time. It requires useArrayEvery and ref from VueUse and Vue, respectively. The array itself is made reactive with ref, and any mutations to the array or its contents trigger the reactive computation. The predicate checks for even values. The output is a computed ref that reflects the current state of the predicate check.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayEvery/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayEvery } from '@vueuse/core'\n\nconst list = ref([0, 2, 4, 6, 8])\nconst result = useArrayEvery(list, i => i % 2 === 0)\n// result.value: true\nlist.value.push(9)\n// result.value: false\n```\n\n----------------------------------------\n\nTITLE: Using watchAtMost Function from VueUse Library in TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of the `watchAtMost` function from the `@vueuse/core` library in a TypeScript environment.  The function watches a `source` (not defined in the provided snippet) and triggers a callback function, logging 'trigger!' to the console. It includes an option `count: 3`, specifying the maximum number of times the callback will be invoked before the watcher is automatically stopped. Prerequisites include installing and importing VueUse. The `source` parameter represents the data source being watched. The `count` parameter defines the maximum number of executions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchAtMost/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchAtMost } from '@vueuse/core'\n\nwatchAtMost(\n  source,\n  () => { console.log('trigger!') }, // triggered it at most 3 times\n  {\n    count: 3, // the number of times triggered\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Reactive Array Sorting with useSorted in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates the basic usage of useSorted for performing reactive sorting on a plain array. It includes examples of sorting numerical arrays and arrays of objects by a specified comparator. The snippet also showcases the 'dirty' mode, which sorts the source array in place. Key dependencies include '@vueuse/core' and Vue's ref for reactive state management.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSorted/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useSorted } from '@vueuse/core'\n\n// general sort\nconst source = [10, 3, 5, 7, 2, 1, 8, 6, 9, 4]\nconst sorted = useSorted(source)\nconsole.log(sorted.value) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconsole.log(source) // [10, 3, 5, 7, 2, 1, 8, 6, 9, 4]\n\n// object sort\nconst objArr = [{\n  name: 'John',\n  age: 40,\n}, {\n  name: 'Jane',\n  age: 20,\n}, {\n  name: 'Joe',\n  age: 30,\n}, {\n  name: 'Jenny',\n  age: 22,\n}]\nconst objSorted = useSorted(objArr, (a, b) => a.age - b.age)\n```\n\n----------------------------------------\n\nTITLE: Using VueUse useMath Reactive Math Functions in TypeScript\nDESCRIPTION: This snippet shows how to import and use the useMath function from @vueuse/math to perform reactive mathematical computations in a Vue application using TypeScript. The useMath hook takes a Math method name (e.g., 'pow', 'sqrt') and reactive inputs (refs) then returns a ref that automatically updates when inputs change. Dependencies include Vue's ref and @vueuse/math's useMath. The example demonstrates computing a power with base and exponent refs, and computing a reactive square root. Inputs are Vue refs holding numeric values; output is a ref holding the computed numeric result.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useMath/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMath } from '@vueuse/math'\n\nconst base = ref(2)\nconst exponent = ref(3)\nconst result = useMath('pow', base, exponent) // Ref<8>\n\nconst num = ref(2)\nconst root = useMath('sqrt', num) // Ref<1.4142135623730951>\n\nnum.value = 4\nconsole.log(root.value) // 2\n```\n\n----------------------------------------\n\nTITLE: Using Preferred Reduced Motion in a Vue Component\nDESCRIPTION: This Vue component demonstrates how to use the `UsePreferredReducedMotion` component to render the user's preferred reduced motion setting. The `v-slot` directive allows you to access the `motion` value, a boolean, indicating the reduced motion preference. This provides flexibility for conditional rendering or applying styles based on the user's choice.  No specific props are used.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredReducedMotion/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePreferredReducedMotion v-slot=\"{ motion }\">\n    Preferred Reduced Motion: {{ motion }}\n  </UsePreferredReducedMotion>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useOnline component in Vue Template\nDESCRIPTION: This snippet shows how to use the `UseOnline` component in a Vue template to display the online status.  The `v-slot` provides the `isOnline` variable, which can be used to conditionally render content or update the UI based on the online state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOnline/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseOnline v-slot=\"{ isOnline }\">\n    Is Online: {{ isOnline }}\n  </UseOnline>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Implementing provideLocal and injectLocal in VueUse\nDESCRIPTION: This snippet shows how to extend Vue's provide/inject system with provideLocal and injectLocal functions from VueUse. It demonstrates providing a local value with a key and then retrieving it within the same component, enabling scoped dependency injection for cleaner state management. Dependencies include '@vueuse/core' and Vue 3 composition API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/provideLocal/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { injectLocal, provideLocal } from '@vueuse/core'\n\nprovideLocal('MyInjectionKey', 1)\nconst injectedValue = injectLocal('MyInjectionKey') // injectedValue === 1\n```\n\n----------------------------------------\n\nTITLE: Using useArrayEvery with Array of Multiple Refs in VueUse (JavaScript)\nDESCRIPTION: This snippet demonstrates how to use the useArrayEvery function from @vueuse/core to reactively track whether all elements in an array of refs satisfy a given condition. It requires importing useArrayEvery and ref from the respective VueUse and Vue libraries. Each ref in the array represents a single reactive value, and the result updates automatically whenever any value in the array changes. The predicate function checks if each value is even. Returns a computed ref with a boolean indicating if all predicates are true.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayEvery/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayEvery } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(2)\nconst item3 = ref(4)\nconst item4 = ref(6)\nconst item5 = ref(8)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArrayEvery(list, i => i % 2 === 0)\n// result.value: true\nitem1.value = 1\n// result.value: false\n```\n\n----------------------------------------\n\nTITLE: Disabling Touch Input for useMouse in TypeScript\nDESCRIPTION: Shows how to configure the `useMouse` composable to ignore touch events and only track mouse movements by passing an options object with `touch` set to `false`. This allows focusing solely on mouse interactions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouse/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@vueuse/core'\n// ---cut---\nconst { x, y } = useMouse({ touch: false })\n```\n\n----------------------------------------\n\nTITLE: Handling custom onUpdate callback with useSortable\nDESCRIPTION: Example demonstrating how to use a custom onUpdate callback with useSortable to handle sorting events manually, using the moveArrayElement utility function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useSortable/index.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { moveArrayElement } from '@vueuse/integrations/useSortable'\n\nuseSortable(el, list, {\n  onUpdate: (e) => {\n    // do something\n    moveArrayElement(list.value, e.oldIndex, e.newIndex, e)\n    // nextTick required here as moveArrayElement is executed in a microtask\n    // so we need to wait until the next tick until that is finished.\n    nextTick(() => {\n      /* do something */\n    })\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Providing a Reactive Array with Vue Provide/Inject (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript injection key for a Ref containing an array of Item objects, then creates a reactive array and provides it using Vue's provide function. Required dependencies include 'vue' for type definitions and reactivity utilities. The array consists of objects with 'key' and 'value' properties, and is made available for injection in the component tree. No external parameters are required beyond a Vue setup context, and the output is reactive state for use by descendant components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedInject/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { InjectionKey, Ref } from 'vue'\nimport { provide } from 'vue'\n\ninterface Item {\n  key: number\n  value: string\n}\n\nexport const ArrayKey: InjectionKey<Ref<Item[]>> = Symbol('symbol-key')\n\nconst array = ref([{ key: 1, value: '1' }, { key: 2, value: '2' }, { key: 3, value: '3' }])\n\nprovide(ArrayKey, array)\n```\n\n----------------------------------------\n\nTITLE: Creating Global State with Getters/Actions (JS)\nDESCRIPTION: Shows a more complex example of creating global state using `createGlobalState`. The factory function includes not only reactive state (`shallowRef`) but also computed properties (getters) and functions (actions) that modify the state. The returned object exposes all these elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createGlobalState/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createGlobalState } from '@vueuse/core'\n// store.js\nimport { computed, shallowRef } from 'vue'\n\nexport const useGlobalState = createGlobalState(\n  () => {\n    // state\n    const count = shallowRef(0)\n\n    // getters\n    const doubleCount = computed(() => count.value * 2)\n\n    // actions\n    function increment() {\n      count.value++\n    }\n\n    return { count, doubleCount, increment }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Shorthand Functions for Keyboard Events in VueUse\nDESCRIPTION: Provides alternative function names for registering handlers for specific keyboard events: 'onKeyDown', 'onKeyPressed', and 'onKeyUp'. These shorthands simplify attaching handlers for different key event types without specifying the 'eventName' explicitly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// These are aliases for onKeyStroke with predefined eventName\n// onKeyDown\n// onKeyPressed\n// onKeyUp\n```\n\n----------------------------------------\n\nTITLE: NProgress Progress Bar in VueUse\nDESCRIPTION: Provides a progress bar component for indicating page or data loading states, enhancing UX.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Progress bar utility integrated with Vue for indicating loading states in UI. */\n```\n\n----------------------------------------\n\nTITLE: Defining and Reusing a Template in a Vue Component (Composition API, Vue)\nDESCRIPTION: Shows how to use 'createReusableTemplate' from '@vueuse/core' in a Vue SFC setup to define a reusable template section using <DefineTemplate> and render it in multiple locations with <ReuseTemplate>. The DefineTemplate registers the template content (which does not render by itself), while ReuseTemplate injects that content wherever it is needed. Prerequisites: Vue 3, @vueuse/core, script setup syntax. Inputs/Outputs: No direct input parameters; relies on Vue template context. Limitations: DefineTemplate must precede all ReuseTemplate usages in the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate()\n</script>\n\n<template>\n  <DefineTemplate>\n    <!-- something complex -->\n  </DefineTemplate>\n\n  <dialog v-if=\"showInDialog\">\n    <ReuseTemplate />\n  </dialog>\n  <div v-else>\n    <ReuseTemplate />\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Handling Timeout with until - TypeScript\nDESCRIPTION: Illustrates how to use the `timeout` option to limit the waiting time for the condition to be met. It also shows how to use `throwOnTimeout` within a `try...catch` block to handle cases where the condition is not satisfied within the specified duration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/until/index.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// will be resolve until ref.value === true or 1000ms passed\nawait until(ref).toBe(true, { timeout: 1000 })\n\n// will throw if timeout\ntry {\n  await until(ref).toBe(true, { timeout: 1000, throwOnTimeout: true })\n  // ref.value === true\n}\ncatch (e) {\n  // timeout\n}\n```\n\n----------------------------------------\n\nTITLE: Using useRound for Reactive Rounding in Vue\nDESCRIPTION: This code snippet demonstrates how to use the useRound composable from the @vueuse/math library to reactively round a number.  It imports useRound, creates a reactive value, and then uses useRound to create a reactive rounded value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useRound/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRound } from '@vueuse/math'\n\nconst value = ref(20.49)\nconst result = useRound(value) // 20\n```\n\n----------------------------------------\n\nTITLE: Using useEyeDropper API - TypeScript\nDESCRIPTION: This snippet demonstrates the direct usage of the `useEyeDropper` composable.  It imports `useEyeDropper` from the VueUse core library. The `useEyeDropper` composable provides reactive properties for `isSupported`, and a function `open`. The `sRGBHex` property provides the selected color in sRGB hex format.  Dependencies include VueUse and the EyeDropper API supported by the browser.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEyeDropper/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useEyeDropper } from '@vueuse/core'\n\nconst { isSupported, open, sRGBHex } = useEyeDropper()\n```\n\n----------------------------------------\n\nTITLE: Defining syncRefs Options Interface in TypeScript\nDESCRIPTION: This TypeScript interface definition outlines the available options for customizing the behavior of the `syncRefs` function. Options include `flush` for timing (similar to Vue's watch), `deep` for deep watching nested properties, and `immediate` for immediate synchronization upon creation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRefs/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface SyncRefOptions {\n  /**\n   * Timing for syncing, same as watch's flush option\n   *\n   * @default 'sync'\n   */\n  flush?: WatchOptions['flush']\n  /**\n   * Watch deeply\n   *\n   * @default false\n   */\n  deep?: boolean\n  /**\n   * Sync values immediately\n   *\n   * @default true\n   */\n  immediate?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Global State with createGlobalState (JS)\nDESCRIPTION: Demonstrates the basic usage of `createGlobalState` to create a simple global state hook. The factory function provided to `createGlobalState` defines the initial state using `shallowRef` and returns an object containing the state properties.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createGlobalState/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createGlobalState } from '@vueuse/core'\n// store.js\nimport { shallowRef } from 'vue'\n\nexport const useGlobalState = createGlobalState(\n  () => {\n    const count = shallowRef(0)\n    return { count }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Controlling a Reactive Interval with useInterval in TypeScript\nDESCRIPTION: Shows how to use the `useInterval` composable in TypeScript with the `controls: true` option. This returns an object containing the reactive `counter` along with control functions: `reset` (to set the counter back to its initial state and restart the interval), `pause` (to temporarily stop the interval), and `resume` (to continue a paused interval). The interval is set to 200ms.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useInterval/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst { counter, reset, pause, resume } = useInterval(200, { controls: true })\n```\n\n----------------------------------------\n\nTITLE: Importing useAsyncValidator Composable (TypeScript)\nDESCRIPTION: Demonstrates how to import the `useAsyncValidator` function from the `@vueuse/integrations` package for use within a Vue component or composable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAsyncValidator/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAsyncValidator } from '@vueuse/integrations/useAsyncValidator'\n```\n\n----------------------------------------\n\nTITLE: Implementing useConfirmDialog with Promises in Vue\nDESCRIPTION: This Vue.js snippet demonstrates the usage of the `useConfirmDialog` composable with promises for handling confirmation dialogs. It illustrates an `openDialog` function utilizing `await reveal()` to handle confirmation or cancellation. This version provides the ability to get the result of the confirmation and incorporates a `teleport` element to render the modal, along with buttons to confirm or cancel the action, passing the data accordingly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useConfirmDialog/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useConfirmDialog } from '@vueuse/core'\n\nconst {\n  isRevealed,\n  reveal,\n  confirm,\n  cancel,\n} = useConfirmDialog()\n\nasync function openDialog() {\n  const { data, isCanceled } = await reveal()\n  if (!isCanceled)\n    console.log(data)\n}\n</script>\n\n<template>\n  <button @click=\"openDialog\">\n    Show Modal\n  </button>\n\n  <teleport to=\"body\">\n    <div v-if=\"isRevealed\" class=\"modal-layout\">\n      <div class=\"modal\">\n        <h2>Confirm?</h2>\n        <button @click=\"confirm(true)\">\n          Yes\n        </button>\n        <button @click=\"confirm(false)\">\n          No\n        </button>\n      </div>\n    </div>\n  </teleport>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing computedWithControl in TypeScript\nDESCRIPTION: Imports `computedWithControl` from '@vueuse/core' and demonstrates its basic usage. It creates a computed ref (`computedRef`) where changes to `source` trigger updates, but the computed value is derived from `counter`. This separates the dependency tracking from the value computation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/computedWithControl/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { computedWithControl } from '@vueuse/core'\n\nconst source = ref('foo')\nconst counter = ref(0)\n\nconst computedRef = computedWithControl(\n  () => source.value, // watch source, same as `watch`\n  () => counter.value, // computed getter, same as `computed`\n)\n```\n\n----------------------------------------\n\nTITLE: Mapping Gamepad to Xbox360 Controller in Vue\nDESCRIPTION: This Vue snippet demonstrates how to use the `mapGamepadToXbox360Controller` function to map a gamepad to an Xbox 360 controller. It imports the `mapGamepadToXbox360Controller` function. It then accesses the pressed state of the A, B, X, and Y buttons.  Requires Vue, VueUse/core and a valid gamepad.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGamepad/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { mapGamepadToXbox360Controller } from '@vueuse/core'\n\nconst controller = mapGamepadToXbox360Controller(gamepad)\n</script>\n\n<template>\n  <span>{{ controller.buttons.a.pressed }}</span>\n  <span>{{ controller.buttons.b.pressed }}</span>\n  <span>{{ controller.buttons.x.pressed }}</span>\n  <span>{{ controller.buttons.y.pressed }}</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Composables\nDESCRIPTION: This snippet demonstrates how to implement asynchronous composables that return a PromiseLike object, useful for Vue's `<Suspense>` API. It uses refs to track the completion state (`isFinished`) and provides a `then` method to allow awaiting the composable. The return type includes both the state and a PromiseLike interface.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useFetch<T>(url: MaybeRefOrGetter<string>): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>> {\n  const data = shallowRef<T | undefined>()\n  const error = shallowRef<Error | undefined>()\n  const isFinished = ref(false)\n\n  fetch(toValue(url))\n    .then(r => r.json())\n    .then(r => data.value = r)\n    .catch(e => error.value = e)\n    .finally(() => isFinished.value = true)\n\n  // Store the return state in a variable\n  const state: UseFetchReturn<T> = {\n    data,\n    error,\n    isFinished,\n  }\n\n  return {\n    ...state,\n    // Adding `then` to an object allows it to be awaited.\n    then(onFulfilled, onRejected) {\n      return new Promise<UseFetchReturn<T>>((resolve, reject) => {\n        until(isFinished)\n          .toBeTruthy()\n          .then(() => resolve(state))\n          .then(() => reject(state))\n      }).then(onFulfilled, onRejected)\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using usePreferredColorScheme in Vue Component Template\nDESCRIPTION: This snippet shows how to use the UsePreferredColorScheme component within a Vue template employing a scoped slot to access the reactive colorScheme property. The template binds the preferred color scheme, provided reactively by the component, to the displayed output. This example requires Vue.js and the @vueuse/core package with the UsePreferredColorScheme component available globally or imported locally. It is intended to display the current preferred color scheme dynamically in the UI.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredColorScheme/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UsePreferredColorScheme v-slot=\"{ colorScheme }\">\n    Preferred Color Scheme: {{ colorScheme }}\n  </UsePreferredColorScheme>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic useCounter in VueUse (JavaScript)\nDESCRIPTION: Imports the `useCounter` function from '@vueuse/core' and destructures its returned reactive state (`count`) and utility functions (`inc`, `dec`, `set`, `reset`) for basic counter operations. This demonstrates the default usage without any initial value or constraints.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useCounter/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useCounter } from '@vueuse/core'\n\nconst { count, inc, dec, set, reset } = useCounter()\n```\n\n----------------------------------------\n\nTITLE: Initializing useKeyModifier with Explicit Initial State in VueUse (TypeScript)\nDESCRIPTION: This snippet shows how to specify an initial state for the useKeyModifier reactive ref by passing an 'initial' option. It provides two instances: one with the default null state and one with a defined boolean initial state, facilitating immediate state management.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useKeyModifier/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst capsLockState1 = useKeyModifier('CapsLock') // Ref<boolean | null>\nconst capsLockState2 = useKeyModifier('CapsLock', { initial: false }) // Ref<boolean>\n```\n\n----------------------------------------\n\nTITLE: useTimestamp Component Usage - Vue\nDESCRIPTION: Demonstrates using the UseTimestamp component in a Vue template. The component provides a slot scope with the timestamp, pause, and resume properties/methods. This allows for easy integration into Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimestamp/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseTimestamp v-slot=\"{ timestamp, pause, resume }\">\n    Current Time: {{ timestamp }}\n    <button @click=\"pause()\">\n      Pause\n    </button>\n    <button @click=\"resume()\">\n      Resume\n    </button>\n  </UseTimestamp>\n</template>\n```\n\n----------------------------------------\n\nTITLE: watchExtractedObservable with watch options in TypeScript\nDESCRIPTION: This snippet shows how to pass the `watch` options, like `immediate`, as the last argument to the `watchExtractedObservable` function. This enables to configure the watcher behaviour. It is similar to the previous example but includes `immediate: true`, so the watcher will be triggered immediately.  It requires the `@vueuse/rxjs` and Vue.js core libraries. The addition of the `immediate: true` option means that the callback function will be executed right away.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/watchExtractedObservable/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchExtractedObservable } from '@vueuse/rxjs'\nimport { computed, reactive, shallowRef } from 'vue'\nimport { AudioPlayer } from '../my/libs/AudioPlayer'\n\n// setup()\n\nconst audio = shallowRef<HTMLAudioElement>()\nconst player = computed(() => (audio.value ? new AudioPlayer(audio) : null))\nconst state = reactive({\n  progress: 0,\n})\n\nwatchExtractedObservable(player, p => p.progress$, (percentage) => {\n  state.progress = percentage * 100\n}, {\n  onError: (err: unknown) => {\n    console.error(err)\n  }\n}, {\n  immediate: true\n})\n```\n\n----------------------------------------\n\nTITLE: Using useParentElement with a ref in TypeScript\nDESCRIPTION: This example shows how to use useParentElement with a ref to a specific DOM element, enabling retrieval of its parent element. It highlights the need to bind the ref to an actual DOM node and logs the parent element during the mounted lifecycle phase.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useParentElement/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useParentElement } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\n// Don't forget to bind the ref to the element\nconst tooltip = shallowRef<HTMLElement | undefined>()\n\nconst tooltipWrapper = useParentElement(tooltip)\n\nonMounted(() => {\n  console.log(tooltipWrapper.value)\n})\n```\n\n----------------------------------------\n\nTITLE: Setting History Capacity and Clearing History in VueUse (TypeScript)\nDESCRIPTION: Demonstrates how to limit the number of saved state snapshots in manual ref history tracking using the capacity option and how to explicitly clear history records. Only requires a target ref and @vueuse/core. Setting capacity limits the maximum snapshots stored; clear() removes all history. Input: numeric capacity and actions; Output: constrained or reset history buffer.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst refHistory = useManualRefHistory(target, {\n  capacity: 15, // limit to 15 history records\n})\n\nrefHistory.clear() // explicitly clear all the history\n```\n\n----------------------------------------\n\nTITLE: Using Route Parameters in VueUse Router\nDESCRIPTION: Provides reactive access to route parameters within Vue Router, supporting dynamic route handling in Vue apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Accesses route parameters reactively in Vue Router, facilitating dynamic routing logic. */\n```\n\n----------------------------------------\n\nTITLE: Using UseElementVisibility as a Vue Component\nDESCRIPTION: Example showing how to use the UseElementVisibility component with slot props to access the visibility state directly in the template. This provides a declarative way to implement visibility tracking.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementVisibility/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseElementVisibility v-slot=\"{ isVisible }\">\n    Is Visible: {{ isVisible }}\n  </UseElementVisibility>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Joining Reactive Array with useArrayJoin in VueUse (JavaScript)\nDESCRIPTION: This snippet illustrates the use of useArrayJoin with a fully reactive array. By passing a single ref that holds an array (which may contain various value types), any push, replacement, or update to the array content will automatically update the joined result. This approach is flexible for dynamic lists, and accepts complex or nested array values; the resulting string reflects values in their stringified form. Dependencies include Vue's ref API and @vueuse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayJoin/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayJoin } from '@vueuse/core'\n\nconst list = ref(['string', 0, { prop: 'val' }, false, [1], [[2]], null, undefined, []])\nconst result = useArrayJoin(list)\n// result.value: string,0,[object Object],false,1,2,,,\nlist.value.push(true)\n// result.value: string,0,[object Object],false,1,2,,,,true\nlist.value = [null, 'string', undefined]\n// result.value: ,string,\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using useIDBKeyval Wrapper for IndexedDB in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import and use the useIDBKeyval wrapper from '@vueuse/integrations/useIDBKeyval' to bind reactive data to IndexedDB storage keys. It supports initializing data with different types such as objects, booleans, and numbers, returning reactive Ref objects. The snippet covers setting values, awaiting IndexedDB transactions, and deleting stored data by assigning null. Dependencies include the idb-keyval package and Vue's reactive system.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useIDBKeyval/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useIDBKeyval } from '@vueuse/integrations/useIDBKeyval'\n\n// bind object\nconst { data: storedObject, isFinished } = useIDBKeyval('my-idb-keyval-store', { hello: 'hi', greeting: 'Hello' })\n\n// update object\nstoredObject.value.hello = 'hola'\n\n// bind boolean\nconst flag = useIDBKeyval('my-flag', true) // returns Ref<boolean>\n\n// bind number\nconst count = useIDBKeyval('my-count', 0) // returns Ref<number>\n\n// awaiting IDB transaction\nawait count.set(10)\nconsole.log('IDB transaction finished!')\n\n// delete data from idb storage\nstoredObject.value = null\n```\n\n----------------------------------------\n\nTITLE: Getting SSR Handler in VueUse\nDESCRIPTION: Retrieves the currently set server-side rendering handler for use in SSR workflows within Vue applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Retrieves the current SSR handler for server-side rendering customization in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Using Template Promises with v-slot in Vue 3 Templates\nDESCRIPTION: Demonstrates how to access promise-related properties in the template using v-slot, allowing for custom UI rendering with promise resolution functionality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <TemplatePromise v-slot=\"{ promise, resolve, reject, args }\">\n    <!-- you can have anything -->\n    <button @click=\"resolve('ok')\">\n      OK\n    </button>\n  </TemplatePromise>\n  <MyPromise v-slot=\"{ promise, resolve, reject, args }\">\n    <!-- another one -->\n  </MyPromise>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Progress Percentage with useNProgress - JavaScript\nDESCRIPTION: Illustrates how to initialize the useNProgress composable with a starting progress value between 0 and 1, making the progress bar start from a specified percentage. It also shows updating the progress to complete the bar. Inputs include a number representing progress ratio; outputs reactively update NProgress.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useNProgress/index.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { useNProgress } from '@vueuse/integrations/useNProgress'\n\nconst { progress } = useNProgress(0.5)\n\nfunction done() {\n  progress.value = 1.0\n}\n```\n\n----------------------------------------\n\nTITLE: Using `watchIgnorable` and `ignorePrevAsyncUpdates` in VueUse (TypeScript)\nDESCRIPTION: Illustrates the use of `ignorePrevAsyncUpdates` returned by `watchIgnorable`. This function cancels pending watch callbacks triggered by previous source mutations when using async flush timings ('pre' or 'post'). It prevents the watcher from executing for changes made before `ignorePrevAsyncUpdates` was called but scheduled to run after the next tick. Requires `vue` for `shallowRef` and `nextTick`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchIgnorable/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchIgnorable } from '@vueuse/core'\nimport { nextTick, shallowRef } from 'vue'\n\nconst source = shallowRef('foo')\n\nconst { ignorePrevAsyncUpdates } = watchIgnorable(\n  source,\n  v => console.log(`Changed to ${v}!`),\n)\n\nsource.value = 'bar'\nawait nextTick() // logs: Changed to bar!\n\nsource.value = 'good'\nsource.value = 'by'\nignorePrevAsyncUpdates()\n\nawait nextTick() // (nothing happened)\n\nsource.value = 'prev'\nignorePrevAsyncUpdates()\nsource.value = 'after'\n\nawait nextTick() // logs: Changed to after!\n```\n\n----------------------------------------\n\nTITLE: Initializing usePointerLock - JavaScript\nDESCRIPTION: Initializes the `usePointerLock` composable from `@vueuse/core`. This composable provides reactive access to the pointer lock API. It returns properties such as `isSupported`, `lock`, `unlock`, `element`, and `triggerElement` for managing pointer lock state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointerLock/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { usePointerLock } from '@vueuse/core'\n\nconst { isSupported, lock, unlock, element, triggerElement } = usePointerLock()\n```\n\n----------------------------------------\n\nTITLE: Moving Array Elements in VueUse\nDESCRIPTION: Provides a small utility to move array elements from one index to another, supporting drag-and-drop reordering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_44\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility to reorder array elements by moving items between positions, supporting dynamic list management. */\n```\n\n----------------------------------------\n\nTITLE: Creating Renderless Components with Vue Composables\nDESCRIPTION: This code shows how to create a renderless component that uses a Vue composable and renders a slot with the composable's data. It wraps the composable's options as props and uses `reactive` to easily pass data to the slot. This provides a flexible way to expose composable functionality through a component without adding extra HTML elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { MouseOptions } from '@vueuse/core'\nimport { useMouse } from '@vueuse/core'\nimport { defineComponent, reactive } from 'vue'\n\nexport const UseMouse = defineComponent<MouseOptions>({\n  name: 'UseMouse',\n  props: ['touch', 'resetOnTouchEnds', 'initialValue'] as unknown as undefined,\n  setup(props, { slots }) {\n    const data = reactive(useMouse(props))\n\n    return () => {\n      if (slots.default)\n        return slots.default(data)\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using the UseMouse Component in Vue Templates\nDESCRIPTION: Demonstrates using the `<UseMouse>` renderless component within a Vue template. It exposes the reactive mouse coordinates `x` and `y` through its default scoped slot, allowing direct access within the template.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouse/index.md#_snippet_3\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseMouse v-slot=\"{ x, y }\">\n    x: {{ x }}\n    y: {{ y }}\n  </UseMouse>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using the vScroll Directive in Vue\nDESCRIPTION: Demonstrates how to use the vScroll directive from @vueuse/components to track scroll state with a callback function. Includes an example with additional throttle options.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScroll/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport type { UseScrollReturn } from '@vueuse/core'\nimport { vScroll } from '@vueuse/components'\n\nconst data = ref([1, 2, 3, 4, 5, 6])\n\nfunction onScroll(state: UseScrollReturn) {\n  console.log(state) // {x, y, isScrolling, arrivedState, directions}\n}\n</script>\n\n<template>\n  <div v-scroll=\"onScroll\">\n    <div v-for=\"item in data\" :key=\"item\">\n      {{ item }}\n    </div>\n  </div>\n\n  <!-- with options -->\n  <div v-scroll=\"[onScroll, { throttle: 10 }]\">\n    <div v-for=\"item in data\" :key=\"item\">\n      {{ item }}\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Computing symmetric difference with useArrayDifference and custom comparison\nDESCRIPTION: An advanced example demonstrating how to compute the symmetric difference between two arrays of objects. It returns elements that are in either array but not in both, using a custom comparison function and the symmetric option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayDifference/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayDifference } from '@vueuse/core'\n\nconst list1 = ref([{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }])\nconst list2 = ref([{ id: 4 }, { id: 5 }, { id: 6 }])\n\nconst result = useArrayDifference(\n  list1,\n  list2,\n  (value, othVal) => value.id === othVal.id,\n  { symmetric: true }\n)\n// result.value: [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 6 }]\n```\n\n----------------------------------------\n\nTITLE: Using useMax with Multiple Ref/Number Arguments in TypeScript\nDESCRIPTION: Illustrates using `useMax` with a mix of reactive refs (`ref(1)`, `ref(3)`) and a static number (2). It imports `useMax` and passes the individual refs and the number as separate arguments. The function reactively calculates the maximum among all provided values, resulting in a `ref` holding 3.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useMax/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useMax } from '@vueuse/math'\n\nconst a = ref(1)\nconst b = ref(3)\n\nconst max = useMax(a, b, 2) // Ref<3>\n```\n\n----------------------------------------\n\nTITLE: Typing Reusable Templates with TypeScript Generics (Vue + TypeScript)\nDESCRIPTION: Demonstrates advanced usage of 'createReusableTemplate' with a generic type argument to ensure type safety when passing data props via slots in TypeScript-enabled Vue SFCs. Multiple template pairs can be created with specific type signatures. Includes examples of both correct and intentional type error cases for TS. Prerequisites: Vue 3, @vueuse/core, TypeScript, appropriate SFC tooling. Inputs: Typed properties (e.g., 'msg' as string) passed to ReuseTemplate. Outputs: Strongly-typed templates; @ts-expect-error called out for type mismatch. Limitations: Type checking relies on correct generic annotations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { createReusableTemplate } from '@vueuse/core'\n\n// Comes with pair of `DefineFoo` and `ReuseFoo`\nconst [DefineFoo, ReuseFoo] = createReusableTemplate<{ msg: string }>()\n\n// You can create multiple reusable templates\nconst [DefineBar, ReuseBar] = createReusableTemplate<{ items: string[] }>()\n</script>\n\n<template>\n  <DefineFoo v-slot=\"{ msg }\">\n    <!-- `msg` is typed as `string` -->\n    <div>Hello {{ msg.toUpperCase() }}</div>\n  </DefineFoo>\n\n  <ReuseFoo msg=\"World\" />\n\n  <!-- @ts-expect-error Type Error! -->\n  <ReuseFoo :msg=\"1\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using logicAnd with whenever in VueUse - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `logicAnd` function from `@vueuse/math` in conjunction with the `whenever` function from `@vueuse/core` to execute a block of code only when both `a` and `b` refs are truthy. It initializes two refs, `a` and `b`, and then sets up a reactive effect that logs a message to the console when `logicAnd(a, b)` evaluates to true. The `whenever` function automatically watches the provided ref and triggers the callback when its value becomes truthy.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/logicAnd/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { whenever } from '@vueuse/core'\nimport { logicAnd } from '@vueuse/math'\n\nconst a = ref(true)\nconst b = ref(false)\n\nwhenever(logicAnd(a, b), () => {\n  console.log('both a and b are now truthy!')\n})\n```\n\n----------------------------------------\n\nTITLE: Using useIpcRenderer to Interact with ipcRenderer - TypeScript\nDESCRIPTION: This TypeScript code snippet demonstrates how to use the `useIpcRenderer` composable, part of the `@vueuse/electron` library, to access and use Electron's `ipcRenderer`. It initializes `ipcRenderer` using the composable and then utilizes it to invoke and listen for events from the main process. Dependencies include the `@vueuse/electron` library and the `vue` framework. The `invoke` function calls a method on the main process, and `on` sets up a listener for a custom event. The output is a ref containing the return value of the invoked function and console logging the arguments of a custom event.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useIpcRenderer/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { useIpcRenderer } from '@vueuse/electron'\nimport { computed } from 'vue'\n\n// enable nodeIntegration if you don't provide ipcRenderer explicitly\n// @see: https://www.electronjs.org/docs/api/webview-tag#nodeintegration\nconst ipcRenderer = useIpcRenderer()\n\n// Ref result will return\nconst result = ipcRenderer.invoke<string>('custom-channel', 'some data')\nconst msg = computed(() => result.value?.msg)\n\n// remove listener automatically on unmounted\nipcRenderer.on('custom-event', (event, ...args) => {\n  console.log(args)\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Getting Specific Component Element with VueUse useCurrentElement (Vue)\nDESCRIPTION: Shows how to use `useCurrentElement` with a ref to obtain the root DOM element of a specific child component instance. The hook takes a ref pointing to the component instance and returns a computed ref to its root element. This functionality is exclusive to Vue 3 and recommended for child components with a single root element.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCurrentElement/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useCurrentElement, VueInstance } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst componentRef = shallowRef<VueInstance>(null as unknown as VueInstance)\n\nconst el = useCurrentElement(componentRef) // ComputedRef<Element>\n</script>\n\n<template>\n  <div>\n    <OtherVueComponent ref=\"componentRef\" />\n    <p>Hello world</p>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using usePageLeave from VueUse in JavaScript\nDESCRIPTION: This snippet imports the usePageLeave reactive hook from the @vueuse/core library and assigns its reactive return value to a constant isLeft. This reactive state reflects whether the mouse has left the current page, enabling reactive logic based on this event. The snippet requires an environment with VueUse installed and Vue 3 with the Composition API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePageLeave/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { usePageLeave } from '@vueuse/core'\n\nconst isLeft = usePageLeave()\n```\n\n----------------------------------------\n\nTITLE: Project Monorepo Structure Example - Markdown\nDESCRIPTION: Illustrates the directory organization of the VueUse monorepo, utilizing Markdown code fences for tree structure formatting. Shows default locations for 'core', 'shared', add-ons, and special packages like 'firebase'. Intended as a documentation aid to help developers navigate and understand package placement within the codebase.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\npackages\n  shared/         - shared utils across packages\n  core/           - the core package\n  firebase/       - the Firebase add-on\n  [...addons]/    - add-ons named\n```\n\n----------------------------------------\n\nTITLE: Implementing v-intersection-observer directive in Vue 3 with TypeScript\nDESCRIPTION: Shows how to use the v-intersection-observer custom directive from '@vueuse/components' to observe element visibility declaratively in Vue templates. The code sets up a reactive state and an event handler, then applies the directive in the template, including options such as root. Dependencies include '@vueuse/components' and 'vue'. The example illustrates listening to intersection changes via a callback function within the directive.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useIntersectionObserver/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vIntersectionObserver } from '@vueuse/components'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst root = useTemplateRef<HTMLDivElement>('root')\n\nconst isVisible = shallowRef(false)\n\nfunction onIntersectionObserver([entry]: IntersectionObserverEntry[]) {\n  isVisible.value = entry?.isIntersecting || false\n}\n</script>\n\n<template>\n  <div>\n    <p>\n      Scroll me down!\n    </p>\n    <div v-intersection-observer=\"onIntersectionObserver\">\n      <p>Hello world!</p>\n    </div>\n  </div>\n\n  <!-- with options -->\n  <div ref=\"root\">\n    <p>\n      Scroll me down!\n    </p>\n    <div v-intersection-observer=\"[onIntersectionObserver, { root }]\">\n      <p>Hello world!</p>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Adding Completion Handling to Observables with useExtractedObservable in TypeScript\nDESCRIPTION: This snippet demonstrates the onComplete callback configuration for useExtractedObservable. An RxJS interval observable emits values until a takeWhile operator limits emissions below 10, after which the onComplete callback logs completion to the console. It uses shallowRef as an input, RxJS operators for transforming the stream, and provides reactive completion handling. Dependencies are Vue shallowRef, RxJS interval, and operator functions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useExtractedObservable/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useExtractedObservable } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { mapTo, scan, startWith, takeWhile } from 'rxjs/operators'\nimport { shallowRef } from 'vue'\n\n// setup()\nconst start = shallowRef(0)\n\nconst count = useExtractedObservable(\n  start,\n  (start) => {\n    return interval(1000).pipe(\n      mapTo(1),\n      startWith(start),\n      scan((total, next) => next + total),\n      takeWhile(num => num < 10)\n    )\n  },\n  {\n    onComplete: () => {\n      console.log('Done!')\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using Vue Native ref in <script setup> with TypeScript for Template Refs\nDESCRIPTION: This snippet explains that when using Vue's <script setup> syntax in TypeScript, the Vue native ref function suffices for reactive references to DOM elements, without needing VueUse's templateRef. It shows declaration of a ref variable initialized to null, which is exposed automatically to the template for binding to an element. This snippet depends on Vue 3 with TypeScript support and the <script setup> syntax feature.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/templateRef/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\nconst target = ref<HTMLElement | null>(null)\n</script>\n\n<template>\n  <div ref=\"target\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: useTimestamp with controls - JavaScript\nDESCRIPTION: Initializes the useTimestamp composable with controls enabled. This allows pausing and resuming the timestamp updates.  The returned object includes timestamp, pause, and resume functions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimestamp/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { timestamp, pause, resume } = useTimestamp({ controls: true })\n```\n\n----------------------------------------\n\nTITLE: Configuring Delay and Lifecycle Callbacks in useTransition (JavaScript)\nDESCRIPTION: Demonstrates setting a delay before the transition starts and providing two callbacks: onStarted and onFinished. These callbacks execute custom logic immediately after the transition begins and ends, respectively. The delay parameter specifies the time in milliseconds to wait before starting the transition. These options enhance control over transition timing and side effects. The source is reactive, and '@vueuse/core' provides useTransition.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nuseTransition(source, {\\n  delay: 1000,\\n  onStarted() {\\n    // called after the transition starts\\n  },\\n  onFinished() {\\n    // called after the transition ends\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useRefHistory in Vue\nDESCRIPTION: Demonstrates the basic usage of useRefHistory to track changes to a ref, showing how to initialize the history tracking and access the history value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRefHistory } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst counter = shallowRef(0)\nconst { history, undo, redo } = useRefHistory(counter)\n```\n\n----------------------------------------\n\nTITLE: Manually Executing and Awaiting Transitions with executeTransition in JavaScript\nDESCRIPTION: Illustrates manual control of transitions using the executeTransition function. This allows explicit transition handling from a defined 'from' value to a 'to' value with specified options like duration. The returned promise resolves upon transition completion, enabling asynchronous flow control. Optionally, an abort function can be defined to cancel an ongoing transition. This snippet depends on '@vueuse/core' and supports advanced scenarios beyond automatic reactive transitions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { executeTransition } from '@vueuse/core'\\n\\nawait executeTransition(source, from, to, {\\n  duration: 1000,\\n})\n```\n\n----------------------------------------\n\nTITLE: Adding and Managing Tracks (Captions/Subtitles) with useMediaControls in Vue\nDESCRIPTION: This example shows how to configure and manage media tracks (like subtitles or captions) using the `tracks` option within `useMediaControls`. It defines a subtitle track with its source, kind, label, and language. The composable returns a reactive `tracks` array and an `enableTrack` function, which are used in the template to create buttons for selecting different available tracks.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMediaControls/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useMediaControls } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst video = useTemplateRef('video')\nconst {\n  tracks,\n  enableTrack\n} = useMediaControls(video, {\n  src: 'video.mp4',\n  tracks: [\n    {\n      default: true,\n      src: './subtitles.vtt',\n      kind: 'subtitles',\n      label: 'English',\n      srcLang: 'en',\n    },\n  ]\n})\n</script>\n\n<template>\n  <video ref=\"video\" />\n  <button v-for=\"track in tracks\" :key=\"track.id\" @click=\"enableTrack(track)\">\n    {{ track.label }}\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Refs with Custom Transformations using VueUse syncRef (TypeScript)\nDESCRIPTION: Illustrates using the `transform` option with `syncRef` to apply custom functions during synchronization. Defines different transformations for left-to-right (`ltr`) and right-to-left (`rtl`) updates, allowing for value mapping.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRef/index.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { syncRef } from '@vueuse/core'\n\nconst a = ref(10)\nconst b = ref(2)\n\nconst stop = syncRef(a, b, {\n  transform: {\n    ltr: left => left * 2,\n    rtl: right => right / 2\n  }\n})\n\nconsole.log(b.value) // 20\n\nb.value = 30\n\nconsole.log(a.value) // 15\n```\n\n----------------------------------------\n\nTITLE: Throttling Ref Value without Trailing Updates - JavaScript\nDESCRIPTION: This snippet demonstrates how to disable trailing updates when throttling a ref value using `refThrottled`. The third parameter is set to `false` to prevent updates at the end of the throttle period. Requires `vue` and `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refThrottled/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { refThrottled } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst input = shallowRef('')\nconst throttled = refThrottled(input, 1000, false)\n```\n\n----------------------------------------\n\nTITLE: Initializing usePreferredColorScheme in JavaScript\nDESCRIPTION: This snippet demonstrates importing and calling the usePreferredColorScheme composable from the @vueuse/core library in a JavaScript context. The function returns a reactive value representing the user's preferred color scheme as dictated by the prefers-color-scheme media query. No parameters are required for the function. The output is a reactive string reflecting either \"light\" or \"dark\", updating automatically when the user's preference changes. This snippet assumes that the @vueuse/core package is installed and available in the project.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredColorScheme/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { usePreferredColorScheme } from '@vueuse/core'\n\nconst preferredColor = usePreferredColorScheme()\n```\n\n----------------------------------------\n\nTITLE: Tracking Deep Changes in Objects with useRefHistory\nDESCRIPTION: Shows how to track changes to object properties by using the deep option, which creates clones for each history record.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst state = ref({\n  foo: 1,\n  bar: 'bar',\n})\n\nconst { history, undo, redo } = useRefHistory(state, {\n  deep: true,\n})\n\nstate.value.foo = 2\n\nawait nextTick()\nconsole.log(history.value)\n/* [\n  { snapshot: { foo: 2, bar: 'bar' } },\n  { snapshot: { foo: 1, bar: 'bar' } }\n] */\n```\n\n----------------------------------------\n\nTITLE: Formatting non-reactive time ago string with formatTimeAgo in JavaScript\nDESCRIPTION: Illustrates using the `formatTimeAgo` function from `@vueuse/core` for obtaining a static, non-reactive time ago string. It takes a Date object and returns a simple string, which is suitable when automatic updates are not required. Requires `@vueuse/core` installation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimeAgo/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { formatTimeAgo } from '@vueuse/core'\n\nconst timeAgo = formatTimeAgo(new Date(2021, 0, 1)) // string\n```\n\n----------------------------------------\n\nTITLE: Reactive Pythagorean Theorem Implementation with Math Functions in TypeScript\nDESCRIPTION: Shows how to create a reactive implementation of the Pythagorean theorem by reactifying multiple Math functions. The example demonstrates composing multiple reactive functions together to build more complex reactive computations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactify/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactify } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst pow = reactify(Math.pow)\nconst sqrt = reactify(Math.sqrt)\nconst add = reactify((a: number, b: number) => a + b)\n\nconst a = shallowRef(3)\nconst b = shallowRef(4)\nconst c = sqrt(add(pow(a, 2), pow(b, 2)))\nconsole.log(c.value) // 5\n\n// 5:12:13\na.value = 5\nb.value = 12\nconsole.log(c.value) // 13\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Dependencies (Window) in VueUse (TypeScript)\nDESCRIPTION: Demonstrates specifying the `window` dependency for `useMouse`. This allows targeting a parent window (`window.parent`) or an iframe's content window (`iframe.contentWindow`), useful for cross-frame interactions or specific environments. Imports `useMouse` from `@vueuse/core` and requires DOM access (`document.querySelector`).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/config.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @lib: dom\n// @noErrors: 18047 2339\nimport { useMouse } from '@vueuse/core'\n\n// accessing parent context\nconst parentMousePos = useMouse({ window: window.parent })\n\nconst iframe = document.querySelector('#my-iframe')\n\n// accessing child context\nconst childMousePos = useMouse({ window: iframe.contentWindow })\n```\n\n----------------------------------------\n\nTITLE: Starting VitePress Dev Server - Bash\nDESCRIPTION: Runs the local VitePress documentation and development server using pnpm. This command starts a hot-reloading environment for live previewing changes to documentation or the site. Prerequisite: project dependencies must be installed. No additional input is necessary, and it serves content on a local HTTP port.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Basic usage of useStyleTag in VueUse to inject CSS into <head>\nDESCRIPTION: This snippet demonstrates how to import and utilize useStyleTag to inject a CSS style rule into the document's <head> section. It initializes reactive properties and shows how to modify styles dynamically. Dependencies include the VueUse core package and Vue.js reactivity system. Inputs are a CSS string, and outputs include the style's ID, reactive CSS content, and control functions load and unload.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStyleTag/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useStyleTag } from '@vueuse/core'\n\nconst {\n  id,\n  css,\n  load,\n  unload,\n  isLoaded,\n} = useStyleTag('.foo { margin-top: 32px; }')\n\n// Later you can modify styles\ncss.value = '.foo { margin-top: 64px; }'\n\n```\n\n----------------------------------------\n\nTITLE: Initializing User Media Stream - JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `useUserMedia` composable. It imports the function from the VueUse library and then calls it to obtain a stream. The `start()` method is invoked to initiate the media stream. The output is the `stream` object, which contains the user's media stream and other relevant information.  Requires VueUse library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUserMedia/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useUserMedia } from '@vueuse/core'\n\nconst { stream, start } = useUserMedia()\n\nstart()\n```\n\n----------------------------------------\n\nTITLE: Configuring useDark with Custom Selector and Attribute\nDESCRIPTION: Shows how to customize the useDark hook to work with different CSS frameworks or HTML attributes by setting options like selector, attribute, and values for dark/light states. This enables integration with non-Tailwind CSS styling approaches.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDark/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst isDark = useDark({\n  selector: 'body',\n  attribute: 'color-scheme',\n  valueDark: 'dark',\n  valueLight: 'light',\n})\n```\n\n----------------------------------------\n\nTITLE: Using usePreferredReducedTransparency in a Vue component with slot\nDESCRIPTION: This Vue component example demonstrates how to incorporate the usePreferredReducedTransparency within a template using a slot to access the reactive transparency value. It displays the current preference for reduced transparency to the user.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredReducedTransparency/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UsePreferredReducedTransparency v-slot=\"{ transparency }\">\n    Preferred Reduced transparency: {{ transparency }}\n  </UsePreferredReducedTransparency>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Easing Function for useTransition in JavaScript\nDESCRIPTION: Provides an example of passing a fully custom easing function to useTransition that implements an elastic easing curve using exponential decay and sine oscillations. The custom function accepts a normalized time input (0 to 1) and outputs the eased progress value. This allows for non-standard, animated easing behaviors beyond preset or cubic bezier curves. Dependencies include basic JavaScript math; requires useTransition from '@vueuse/core'. The function can be reused and passed via the transition option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction easeOutElastic(n) {\\n  return n === 0\\n    ? 0\\n    : n === 1\\n      ? 1\\n      : (2 ** (-10 * n)) * Math.sin((n * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1\\n}\\n\\nuseTransition(source, {\\n  transition: easeOutElastic,\\n})\n```\n\n----------------------------------------\n\nTITLE: Vue Component Template Using useDevicePixelRatio with Scoped Slot\nDESCRIPTION: This Vue template example shows how to incorporate the useDevicePixelRatio functionality into a component using a scoped slot, allowing reactive display of the current device pixel ratio within the component's markup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicePixelRatio/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseDevicePixelRatio v-slot=\"{ pixelRatio }\">\n    Pixel Ratio: {{ pixelRatio }}\n  </UseDevicePixelRatio>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Transitioning Array Source Values for Color Computation in JavaScript\nDESCRIPTION: Shows how to use useTransition with a reactive array source (e.g., representing RGB color components). The transition smoothly changes each numeric element of the array independently. The reactive computed property converts the transitioned array to a CSS rgb color string. Dependencies include Vue's shallowRef and computed, with useTransition from '@vueuse/core'. The source is an array of numbers; output maintains a corresponding transitioning array. Useful for animating colors or multi-dimensional numeric states.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTransition/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst source = shallowRef([0, 0, 0])\\n\\nconst output = useTransition(source)\\n\\nconst color = computed(() => {\\n  const [r, g, b] = output.value\\n  return `rgb(${r}, ${g}, ${b})`\\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving SSR Width in Subcomponents with Vue\nDESCRIPTION: Demonstrates how to access the globally provided SSR viewport width value in a child component. This allows components to utilize the consistent width value set at a higher level.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSSRWidth/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useSSRWidth } from '@vueuse/core'\n\nconst width = useSSRWidth()\n</script>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFilter with array of multiple refs\nDESCRIPTION: Example demonstrating how to use useArrayFilter with an array containing multiple refs. The filter predicate keeps only even numbers, and the result updates reactively when any ref value changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFilter/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayFilter } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(2)\nconst item3 = ref(4)\nconst item4 = ref(6)\nconst item5 = ref(8)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArrayFilter(list, i => i % 2 === 0)\n// result.value: [0, 2, 4, 6, 8]\nitem2.value = 1\n// result.value: [0, 4, 6, 8]\n```\n\n----------------------------------------\n\nTITLE: Integrating useMemoize with asyncComputed for Reactivity in TypeScript\nDESCRIPTION: Illustrates how to combine `useMemoize` with `asyncComputed` (another VueUse function) to create a reactive computed property that automatically updates when the underlying memoized asynchronous function's cache is updated or reloaded. Calling `load` on the memoized function will trigger reactivity for the `asyncComputed` ref. Requires `@vueuse/core` and potentially `vue` for `asyncComputed`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMemoize/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user1 = asyncComputed(() => getUser(1))\n// ...\nawait getUser.load(1) // Will also update user1\n```\n\n----------------------------------------\n\nTITLE: Converting ref, value, or getter to its underlying value in VueUse - TypeScript\nDESCRIPTION: This snippet demonstrates usage of the deprecated toValue utility function from '@vueuse/core', which obtains the raw value from a primitive value, a Vue ref, or a getter function. Dependencies include VueUse and Vue's ref reactive system. The function is useful to unwrap reactive references or evaluate getter functions to retrieve their current value. The input parameter is a generic value, reactive reference, or function, and output is the underlying primitive or computed value. The snippet shows that the function transparently handles refs, constants, and getters. Limitations include deprecation notice advising users to import toValue from 'vue' instead.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/toValue/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { toValue } from '@vueuse/core'\n\nconst foo = ref('hi')\n\nconst a = toValue(0) // 0\nconst b = toValue(foo) // 'hi'\nconst c = toValue(() => 'hi') // 'hi'\n```\n\n----------------------------------------\n\nTITLE: Using useLastChanged with default flush setting in Vue 3 with TypeScript\nDESCRIPTION: Demonstrates how to import and utilize the useLastChanged function to track the last change timestamp of a reactive reference in Vue 3, with default behavior recording on the next tick. It shows setting a reactive value and retrieving the timestamp after an update.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useLastChanged/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useLastChanged } from '@vueuse/core'\nimport { nextTick } from 'vue'\n\nconst a = ref(0)\nconst lastChanged = useLastChanged(a)\n\n a.value = 1\n\nawait nextTick()\n\nconsole.log(lastChanged.value) // 1704709379457\n```\n\n----------------------------------------\n\nTITLE: Controlling syncRefs Timing with flush:'pre' Option in TypeScript\nDESCRIPTION: This snippet demonstrates using the `flush: 'pre'` option with `syncRefs` to control synchronization timing. With `'pre'`, the target ref updates occur at the end of the current 'tick' before the DOM is updated, requiring `nextTick` to see the updated value outside the reactive system in synchronous checks.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRefs/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { syncRefs } from '@vueuse/core'\nimport { nextTick, shallowRef } from 'vue'\n\nconst source = shallowRef('hello')\nconst target = shallowRef('target')\n\nsyncRefs(source, target, { flush: 'pre' })\n\nconsole.log(target.value) // hello\n\nsource.value = 'foo'\n\nconsole.log(target.value) // hello <- still unchanged, because of flush 'pre'\n\nawait nextTick()\n\nconsole.log(target.value) // foo <- changed!\n```\n\n----------------------------------------\n\nTITLE: Using useFavicon with a source ref in JavaScript\nDESCRIPTION: This snippet shows how to use the `useFavicon` composable with a source ref.  It imports `useFavicon`, `usePreferredDark`, and `computed` from appropriate libraries.  It creates a computed ref that determines the favicon based on the user's dark mode preference and then passes that computed ref to `useFavicon`. The favicon will then automatically update based on the `isDark` value.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFavicon/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useFavicon, usePreferredDark } from '@vueuse/core'\nimport { computed } from 'vue'\n\nconst isDark = usePreferredDark()\nconst favicon = computed(() => isDark.value ? 'dark.png' : 'light.png')\n\nuseFavicon(favicon)\n```\n\n----------------------------------------\n\nTITLE: Using `watchIgnorable` and `ignoreUpdates` in VueUse (TypeScript)\nDESCRIPTION: Demonstrates the basic usage of `watchIgnorable` from `@vueuse/core` to watch a `shallowRef` source. It shows how to use the returned `ignoreUpdates` function to wrap changes to the source, preventing the watch callback from firing for those specific mutations. Requires `vue` for `shallowRef` and `nextTick`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchIgnorable/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchIgnorable } from '@vueuse/core'\nimport { nextTick, shallowRef } from 'vue'\n\nconst source = shallowRef('foo')\n\nconst { stop, ignoreUpdates } = watchIgnorable(\n  source,\n  v => console.log(`Changed to ${v}!`),\n)\n\nsource.value = 'bar'\nawait nextTick() // logs: Changed to bar!\n\nignoreUpdates(() => {\n  source.value = 'foobar'\n})\nawait nextTick() // (nothing happened)\n\nsource.value = 'hello'\nawait nextTick() // logs: Changed to hello!\n\nignoreUpdates(() => {\n  source.value = 'ignored'\n})\nsource.value = 'logged'\n\nawait nextTick() // logs: Changed to logged!\n```\n\n----------------------------------------\n\nTITLE: Chaining Method and Response Type (VueUse TypeScript)\nDESCRIPTION: Demonstrates using chainable methods like `.get()`, `.post()`, `.json()`, `.text()`, and `.blob()` after calling `useFetch(url)` to concisely specify the HTTP method and how the response body should be parsed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Request will be sent with GET method and data will be parsed as JSON\nconst { data } = useFetch(url).get().json()\n\n// Request will be sent with POST method and data will be parsed as text\nconst { data } = useFetch(url).post().text()\n```\n\n----------------------------------------\n\nTITLE: Using UseDevicesList Component - Vue\nDESCRIPTION: Demonstrates the usage of the renderless `<UseDevicesList>` component provided by VueUse. It uses a v-slot to access the reactive device lists (`videoInputs`, `audioInputs`, `audioOutputs`) exposed by the component, making them available directly within the template for rendering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicesList/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseDevicesList v-slot=\"{ videoInputs, audioInputs, audioOutputs }\">\n    Cameras: {{ videoInputs }}\n    Microphones: {{ audioInputs }}\n    Speakers: {{ audioOutputs }}\n  </UseDevicesList>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Custom Clone Function with Klona in VueUse (TypeScript)\nDESCRIPTION: Demonstrates integrating the lightweight klona library as a clone function for tracking deeply cloned ref history. Dependencies: @vueuse/core, klona, and a target ref. Passes klona as the clone option for efficient, fast cloning of most objects. Input: ref; Output: cloned history state with improved performance.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\nimport { klona } from 'klona'\n\nconst refHistory = useManualRefHistory(target, { clone: klona })\n```\n\n----------------------------------------\n\nTITLE: Basic usage of useParentElement to get parent of current component (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import and invoke useParentElement without arguments to retrieve the parent element of the current component. It uses Vue's onMounted lifecycle hook to log the parent element after component mount.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useParentElement/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useParentElement } from '@vueuse/core'\n\nconst parentEl = useParentElement()\n\nonMounted(() => {\n  console.log(parentEl.value)\n})\n```\n\n----------------------------------------\n\nTITLE: Using useDevicesList Hook - JavaScript\nDESCRIPTION: Imports the `useDevicesList` composable from VueUse and destructures the returned reactive properties `devices`, `videoInputs`, `audioInputs`, and `audioOutputs`. This provides access to lists of available media devices after the initial scan. Requires VueUse to be installed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDevicesList/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useDevicesList } from '@vueuse/core'\n\nconst {\n  devices,\n  videoInputs: cameras,\n  audioInputs: microphones,\n  audioOutputs: speakers,\n} = useDevicesList()\n```\n\n----------------------------------------\n\nTITLE: Initializing and Toggling NProgress with VueUse - JavaScript\nDESCRIPTION: Demonstrates importing and using the useNProgress composable from VueUse to manage a reactive loading progress bar. The snippet highlights toggling the isLoading reactive property to start or stop the progress bar. This requires Vue's reactive system and the NProgress library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useNProgress/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { useNProgress } from '@vueuse/integrations/useNProgress'\n\nconst { isLoading } = useNProgress()\n\nfunction toggle() {\n  isLoading.value = !isLoading.value\n}\n```\n\n----------------------------------------\n\nTITLE: Using VueUse useScriptTag Automatically (TypeScript)\nDESCRIPTION: This snippet demonstrates the default behavior of `useScriptTag`, which automatically creates and injects a script tag into the document's head when the component is mounted. It takes the script URL as the first argument and an optional callback function that is executed when the script finishes loading.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScriptTag/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useScriptTag } from '@vueuse/core'\n\nuseScriptTag(\n  'https://player.twitch.tv/js/embed/v1.js',\n  // on script tag loaded.\n  (el: HTMLScriptElement) => {\n    // do something\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using useUrlSearchParams in Hash-Params Mode (JavaScript)\nDESCRIPTION: This example showcases the usage of the `hash-params` mode with `useUrlSearchParams`. This mode enables the use of hash parameters even when the application is utilizing history mode.  Setting parameter values via the returned object updates the URL's hash fragment. Dependencies: VueUse library, and a Vue application using history mode routing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useUrlSearchParams/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useUrlSearchParams } from '@vueuse/core'\n\nconst params = useUrlSearchParams('hash-params')\n\nparams.foo = 'bar'\nparams.vueuse = 'awesome'\n// url updated to `/your/route#foo=bar&vueuse=awesome`\n```\n\n----------------------------------------\n\nTITLE: Adding Transitions to Template Promises in Vue 3\nDESCRIPTION: Shows how to configure and use Vue transitions with template promises, enabling smooth animations when showing and hiding the promise-based UI components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_5\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nconst TemplatePromise = createTemplatePromise<ReturnType>({\n  transition: {\n    name: 'fade',\n    appear: true,\n  },\n})\n</script>\n\n<template>\n  <TemplatePromise v-slot=\"{ resolve }\">\n    <!-- your UI -->\n    <button @click=\"resolve('ok')\">\n      OK\n    </button>\n  </TemplatePromise>\n</template>\n\n<style scoped>\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s;\n}\n.fade-enter,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n```\n\n----------------------------------------\n\nTITLE: Using VueUse useScriptTag Manually (TypeScript)\nDESCRIPTION: This snippet shows how to use the `useScriptTag` composable with manual control over loading and unloading. By setting the `manual: true` option, the script is not automatically loaded. Instead, the composable returns an object containing `scriptTag`, `load`, and `unload` functions, allowing you to explicitly manage the script's lifecycle.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScriptTag/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useScriptTag } from '@vueuse/core'\n\nconst { scriptTag, load, unload } = useScriptTag(\n  'https://player.twitch.tv/js/embed/v1.js',\n  () => {\n    // do something\n  },\n  { manual: true },\n)\n\n// manual controls\nawait load()\nawait unload()\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Template Promises in Vue 3\nDESCRIPTION: Shows how to define and pass arguments to template promises, enabling dynamic content in promise-based components with type safety.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTemplatePromise } from '@vueuse/core'\n\nconst TemplatePromise = createTemplatePromise<boolean, [string, number]>()\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await TemplatePromise.start('hello', 123) // Pr\n```\n\n----------------------------------------\n\nTITLE: Throttling Ref Value without Leading Updates - JavaScript\nDESCRIPTION: This snippet demonstrates how to disable leading updates when throttling a ref value using `refThrottled`. The fourth parameter is set to `false` to prevent immediate updates. Requires `vue` and `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refThrottled/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { refThrottled } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst input = shallowRef('')\nconst throttled = refThrottled(input, 1000, undefined, false)\n```\n\n----------------------------------------\n\nTITLE: Custom Clone Function with useCloned Using klona (TypeScript)\nDESCRIPTION: This code demonstrates integrating a custom clone function, such as klona, with useCloned. It allows deep cloning beyond the default JSON method, enabling more complex data structures and behaviors, and provides additional tools like isModified for change detection.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCloned/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCloned } from '@vueuse/core'\nimport { klona } from 'klona'\n\nconst original = ref({ key: 'value' })\n\nconst { cloned, isModified, sync } = useCloned(original, { clone: klona })\n```\n\n----------------------------------------\n\nTITLE: Initializing useStepper with an array of steps in JavaScript\nDESCRIPTION: This code snippet demonstrates how to initialize the `useStepper` composable from `@vueuse/core` with an array of step names.  It showcases accessing the current step using `current.value`. It requires `@vueuse/core` to be installed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStepper/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStepper } from '@vueuse/core'\n\nconst {\n  steps,\n  stepNames,\n  index,\n  current,\n  next,\n  previous,\n  isFirst,\n  isLast,\n  goTo,\n  goToNext,\n  goToPrevious,\n  goBackTo,\n  isNext,\n  isPrevious,\n  isCurrent,\n  isBefore,\n  isAfter,\n} = useStepper([\n  'billing-address',\n  'terms',\n  'payment',\n])\n\n// Access the step through `current`\nconsole.log(current.value) // 'billing-address'\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in RxJS Observables in Vue with Custom onError - TypeScript\nDESCRIPTION: Shows how to handle Observable errors within Vue components by providing a custom onError callback to useObservable. Requires @vueuse/rxjs and rxjs. The provided Observable throws an error when a condition is met, and the onError option captures and logs the error message. This pattern prevents unhandled Observable errors from propagating globally.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useObservable/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useObservable } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\n// setup()\nconst count = useObservable(\n  interval(1000).pipe(\n    map((n) => {\n      if (n === 10)\n        throw new Error('oops')\n\n      return n + n\n    }),\n  ),\n  {\n    onError: (err) => {\n      console.log(err.message) // \"oops\"\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Manually Triggering computedWithControl Update in TypeScript (Vue 3)\nDESCRIPTION: Demonstrates how to manually trigger an update for a computed ref created with `computedWithControl` using its `trigger()` method. This forces the computed getter to re-evaluate and update the value, regardless of dependency changes. Note that this feature is only available in Vue 3.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/computedWithControl/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst computedRef = computedWithControl(\n  () => source.value,\n  () => counter.value,\n)\n\ncomputedRef.trigger()\n```\n\n----------------------------------------\n\nTITLE: Omitting Props When Passing to Child Component using reactiveOmit (Vue SFC)\nDESCRIPTION: This Vue Single File Component example utilizes 'reactiveOmit' from @vueuse/core to filter props before passing them to a child component. It sets up component props via 'defineProps', then creates a subset excluding the 'value' prop. Dependencies include Vue 3, @vueuse/core, and the <script setup> syntax. The result is that only selected props (\"color\" and \"font\") are forwarded to the child, improving prop management and preventing unnecessary prop passing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactiveOmit/index.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup>\nimport { reactiveOmit } from '@vueuse/core'\n\nconst props = defineProps({\n  value: {\n    default: 'value',\n  },\n  color: {\n    type: String,\n  },\n  font: {\n    type: String,\n  }\n})\n\nconst childProps = reactiveOmit(props, 'value')\n</script>\n\n<template>\n  <div>\n    <!-- only passes \"color\" and \"font\" props to child -->\n    <ChildComp v-bind=\"childProps\" />\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Handling Observable Errors with useExtractedObservable in TypeScript\nDESCRIPTION: This example shows useExtractedObservable with an optional onError callback to handle errors emitted from an RxJS interval observable chain. It imports operators like mapTo, scan, and tap which may trigger an error after a condition is met. The reactive input is a shallow Vue ref 'start'. The onError function logs errors to the console, preventing unhandled observable errors from propagating globally. Dependencies include RXJS operators and Vue shallowRef.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useExtractedObservable/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useExtractedObservable } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { mapTo, scan, startWith, tap } from 'rxjs/operators'\nimport { shallowRef } from 'vue'\n\n// setup()\nconst start = shallowRef(0)\n\nconst count = useExtractedObservable(\n  start,\n  (start) => {\n    return interval(1000).pipe(\n      mapTo(1),\n      startWith(start),\n      scan((total, next) => next + total),\n      tap((n) => {\n        if (n === 10)\n          throw new Error('oops')\n      })\n    )\n  },\n  {\n    onError: (err) => {\n      console.log(err.message) // \"oops\"\n    },\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Importing and using useMemory from VueUse\nDESCRIPTION: This snippet demonstrates importing the useMemory function from '@vueuse/core' and destructuring its returned reactive properties isSupported and memory. It illustrates the initialization of reactive memory info within a Vue component or setup function, facilitating real-time memory status tracking.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMemory/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMemory } from '@vueuse/core'\n\nconst { isSupported, memory } = useMemory()\n```\n\n----------------------------------------\n\nTITLE: Using useNow with controls in JavaScript\nDESCRIPTION: Calls the `useNow` composable with the `{ controls: true }` option. This returns the reactive `now` date along with `pause` and `resume` functions to manually stop and restart the updates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNow/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { now, pause, resume } = useNow({ controls: true })\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Vue Chemistry Reactive Utilities in JavaScript\nDESCRIPTION: This code snippet demonstrates how to import reactive helper functions from the Vue Chemistry library, including console utilities, core reactive setters, and math operations like sum. It shows how to create reactive references a and b using ref, compute their reactive sum c, update reactive values using set, and log the reactive result to the console. The snippet requires Vue Chemistry modules and assumes an environment supporting reactive references (e.g., Vue 3) to enable reactive programming with primitive values.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/ecosystem.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport * as console from 'vue-chemistry/console'\\nimport { set } from 'vue-chemistry/core'\\nimport { sum } from 'vue-chemistry/math'\\n\\nconst a = ref(1)\\nconst b = ref(2)\\n\\nconst c = sum(a, b) // c = a + b = 3\\n\\nset(a, 2) // shorthand for a.value = 2\\n\\nconsole.log(c) // it's 4 (2 + 2)!\n```\n\n----------------------------------------\n\nTITLE: Using watchExtractedObservable for Basic Monitoring in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of `watchExtractedObservable` to monitor the `progress$` Observable extracted from a computed `player` object. The function automatically unsubscribes when the observable changes or the component is unmounted. It requires the `@vueuse/rxjs` library and the Vue.js core for reactivity and computed properties. The output updates the `state.progress` reactive property based on the percentage emitted by the Observable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/watchExtractedObservable/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { watchExtractedObservable } from '@vueuse/rxjs'\nimport { computed, reactive, shallowRef } from 'vue'\nimport { AudioPlayer } from '../my/libs/AudioPlayer'\n\n// setup()\n\nconst audio = shallowRef<HTMLAudioElement>()\nconst player = computed(() => (audio.value ? new AudioPlayer(audio) : null))\nconst state = reactive({\n  progress: 0,\n})\n\nwatchExtractedObservable(player, p => p.progress$, (percentage) => {\n  state.progress = percentage * 100\n})\n```\n\n----------------------------------------\n\nTITLE: Example Usage of useCeil with Vue Ref in TypeScript\nDESCRIPTION: Demonstrates how to import the `useCeil` function and apply it to a reactive Vue `ref`. The `useCeil` function takes a reactive value (like a `ref` or `computed`) as input and returns a new reactive value representing the ceiling of the input. Requires `@vueuse/math` and `vue` as dependencies.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useCeil/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCeil } from '@vueuse/math'\n\nconst value = ref(0.95)\nconst result = useCeil(value) // 1\n```\n\n----------------------------------------\n\nTITLE: Using UseOffsetPagination Component with Props Event Callbacks\nDESCRIPTION: Alternative approach to event handling in UseOffsetPagination component using props for event callbacks instead of event listeners. Demonstrates prop-based callbacks for pagination events.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useOffsetPagination/index.md#_snippet_3\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseOffsetPagination\n    v-slot=\"{\n      currentPage,\n      currentPageSize,\n      next,\n      prev,\n      pageCount,\n      isFirstPage,\n      isLastPage,\n    }\"\n    :total=\"database.length\"\n    :on-page-change=\"fetchData\"\n    :on-page-size-change=\"fetchData\"\n    :on-page-count-change=\"onPageCountChange\"\n  >\n    <!-- your code -->\n  </UseOffsetPagination>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization with useRefHistory\nDESCRIPTION: Shows how to use custom dump and parse functions for serialization and parsing, which can be useful for saving snapshots to local storage.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRefHistory } from '@vueuse/core'\n\nconst refHistory = useRefHistory(target, {\n  dump: JSON.stringify,\n  parse: JSON.parse,\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Fetch Response Event (VueUse TypeScript)\nDESCRIPTION: Registers a callback function using `onFetchResponse` that is triggered whenever a fetch request successfully completes and receives a response. Useful for logging responses or performing side effects.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst { onFetchResponse, onFetchError } = useFetch(url)\n\nonFetchResponse((response) => {\n  console.log(response.status)\n})\n```\n\n----------------------------------------\n\nTITLE: Using useTitle with reactive getter (reactivity transform) in VueUse\nDESCRIPTION: Shows passing a reactive getter function to useTitle, enabling dynamic updates based on reactive data without manual watchers.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useDark, useTitle } from '@vueuse/core'\n// ---cut---\nconst isDark = useDark()\n\nuseTitle(() => isDark.value ? 'üåô Good evening!' : '‚òÄÔ∏è Good morning!')\n```\n\n----------------------------------------\n\nTITLE: Using useScreenSafeArea composable in TypeScript\nDESCRIPTION: Example of importing and using the useScreenSafeArea composable to access reactive safe area inset values from all four edges of the screen.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenSafeArea/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useScreenSafeArea } from '@vueuse/core'\n\nconst {\n  top,\n  right,\n  bottom,\n  left,\n} = useScreenSafeArea()\n```\n\n----------------------------------------\n\nTITLE: OnLongPress Component Usage in Vue\nDESCRIPTION: This snippet demonstrates the usage of the `OnLongPress` component from `@vueuse/components`.  The component wraps a button, and the `trigger` event is emitted when a long press is detected.  A reactive variable is updated in the callback function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onLongPress/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { OnLongPress } from '@vueuse/components'\nimport { shallowRef } from 'vue'\n\nconst longPressedComponent = shallowRef(false)\n\nfunction onLongPressCallbackComponent(e: PointerEvent) {\n  longPressedComponent.value = true\n}\nfunction resetComponent() {\n  longPressedComponent.value = false\n}\n</script>\n\n<template>\n  <p>Long Pressed: {{ longPressedComponent }}</p>\n\n  <OnLongPress\n    as=\"button\"\n    class=\"ml-2 button small\"\n    @trigger=\"onLongPressCallbackComponent\"\n  >\n    Press long\n  </OnLongPress>\n\n  <button class=\"ml-2 button small\" @click=\"resetComponent\">\n    Reset\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating reactive time ago string with useTimeAgo in JavaScript\nDESCRIPTION: Demonstrates importing and using the `useTimeAgo` composable from `@vueuse/core` to create a reactive reference (`Ref`) that automatically updates with the time elapsed since the provided Date object. Requires `@vueuse/core` installation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimeAgo/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useTimeAgo } from '@vueuse/core'\n\nconst timeAgo = useTimeAgo(new Date(2021, 0, 1))\n```\n\n----------------------------------------\n\nTITLE: Defining Template Access via Property Instead of Destructuring (Vue + TypeScript)\nDESCRIPTION: Presents an alternative form for reusable templates where the return value of 'createReusableTemplate' is assigned to a variable and members are accessed via properties (e.g., TemplateFoo.define and TemplateFoo.reuse). Prerequisites: Vue 3, @vueuse/core, TypeScript. Inputs: Typed slot properties. Outputs: Usage is functionally equivalent to destructured forms, supporting personal preference or codebase style. Limitations: Must understand object property access in script setup context.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_5\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst TemplateFoo = createReusableTemplate<{ msg: string }>()\n</script>\n\n<template>\n  <TemplateFoo.define v-slot=\"{ msg }\">\n    <div>Hello {{ msg.toUpperCase() }}</div>\n  </TemplateFoo.define>\n\n  <TemplateFoo.reuse msg=\"World\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Destructuring a makeDestructurable Object by Properties or Indices in TypeScript\nDESCRIPTION: This snippet illustrates how to destructure an object created with makeDestructurable either by using property names (object destructuring) or indices (array destructuring) in TypeScript. The obj instance is assumed to be created with makeDestructurable and supports both destructuring syntaxes. There are no external dependencies for this usage beyond the TypeScript language, but obj must be created as shown in the previous example. The output will assign foo and bar respectively based on the destructuring method used. This approach is constrained to objects constructed using makeDestructurable.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/makeDestructurable/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet { foo, bar } = obj\nlet [foo, bar] = obj\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Refs Bidirectionally with VueUse syncRef (TypeScript)\nDESCRIPTION: Demonstrates the basic usage of `syncRef` to establish a default bidirectional synchronization between two Vue refs. Changes made to either ref are automatically reflected in the other.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRef/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { syncRef } from '@vueuse/core'\n\nconst a = ref('a')\nconst b = ref('b')\n\nconst stop = syncRef(a, b)\n\nconsole.log(a.value) // a\n\nb.value = 'foo'\n\nconsole.log(a.value) // foo\n\na.value = 'bar'\n\nconsole.log(b.value) // bar\n```\n\n----------------------------------------\n\nTITLE: Using UseScreenSafeArea component in Vue\nDESCRIPTION: Example of using the UseScreenSafeArea component wrapper in a Vue template. The component applies safe area insets to all four sides of its content.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenSafeArea/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseScreenSafeArea top right bottom left>\n    content\n  </UseScreenSafeArea>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Batching Operations with useRefHistory\nDESCRIPTION: Demonstrates how to use batch() to group multiple operations into a single history point when using sync flush timing.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst r = ref({ names: [], version: 1 })\nconst { history, batch } = useRefHistory(r, { flush: 'sync' })\n\nbatch(() => {\n  r.value.names.push('Lena')\n  r.value.version++\n})\n\nconsole.log(history.value)\n/* [\n  { snapshot: { names: [ 'Lena' ], version: 2 },\n  { snapshot: { names: [], version: 1 },\n] */\n```\n\n----------------------------------------\n\nTITLE: Using onElementRemoval in Vue 3 with Script Setup\nDESCRIPTION: This example demonstrates how to use the onElementRemoval function to track when an element is removed from the DOM. The code toggles between two button states and increments a counter whenever the target button is removed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onElementRemoval/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { onElementRemoval } from '@vueuse/core'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst btnRef = useTemplateRef<HTMLElement>('btn')\nconst btnState = shallowRef(true)\nconst removedCount = shallowRef(0)\n\nfunction btnOnClick() {\n  btnState.value = !btnState.value\n}\n\nonElementRemoval(btnRef, () => ++removedCount.value)\n</script>\n\n<template>\n  <button\n    v-if=\"btnState\"\n    @click=\"btnOnClick\"\n  >\n    recreate me\n  </button>\n  <button\n    v-else\n    ref=\"btnRef\"\n    @click=\"btnOnClick\"\n  >\n    remove me\n  </button>\n  <b>removed times: {{ removedCount }}</b>\n</template>\n```\n\n----------------------------------------\n\nTITLE: vOnLongPress Directive Usage in Vue\nDESCRIPTION: This snippet shows how to use the `vOnLongPress` directive from `@vueuse/components` to detect long press events on a button. It includes examples with and without modifiers.  The directive takes a callback function as its argument and optionally an object containing a delay and modifiers.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onLongPress/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vOnLongPress } from '@vueuse/components'\nimport { shallowRef } from 'vue'\n\nconst longPressedDirective = shallowRef(false)\n\nfunction onLongPressCallbackDirective(e: PointerEvent) {\n  longPressedDirective.value = true\n}\nfunction resetDirective() {\n  longPressedDirective.value = false\n}\n</script>\n\n<template>\n  <p>Long Pressed: {{ longPressedDirective }}</p>\n\n  <button\n    v-on-long-press.prevent=\"onLongPressCallbackDirective\"\n    class=\"ml-2 button small\"\n  >\n    Press long\n  </button>\n\n  <button\n    v-on-long-press=\"[onLongPressCallbackDirective, { delay: 1000, modifiers: { stop: true } }]\"\n    class=\"ml-2 button small\"\n  >\n    Press long (with options)\n  </button>\n\n  <button class=\"ml-2 button small\" @click=\"resetDirective\">\n    Reset\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Templates with Object Destructuring (Vue + TypeScript)\nDESCRIPTION: Shows using object destructuring instead of array destructuring when creating reusable templates via 'createReusableTemplate'. The 'define' and 'reuse' named properties provide alternative, possibly more readable, syntax. Prerequisites: Vue 3, @vueuse/core, TypeScript, script setup. Inputs: Typed slot props (e.g. 'msg'). Outputs: Rendered HTML with type-safe slot data. No major limitations beyond those of TS typing and prop shapes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst { define: DefineFoo, reuse: ReuseFoo } = createReusableTemplate<{\n  msg: string\n}>()\n</script>\n\n<template>\n  <DefineFoo v-slot=\"{ msg }\">\n    <div>Hello {{ msg.toUpperCase() }}</div>\n  </DefineFoo>\n\n  <ReuseFoo msg=\"World\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useWebWorkerFn for Asynchronous Heavy Work - VueUse JavaScript\nDESCRIPTION: Demonstrates the basic usage of useWebWorkerFn from @vueuse/core to offload a heavy, synchronous function to a Web Worker in a Vue project. This snippet imports the composable, defines a worker function containing the heavy computation, and extracts workerFn for later invocation. No external dependencies are required for this minimal example, and there are no input/output parameters to the worker function, serving as an entry point for further customization.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWebWorkerFn/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useWebWorkerFn } from '@vueuse/core'\n\nconst { workerFn } = useWebWorkerFn(() => {\n  // some heavy works to do in web worker\n})\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFindLast with a reactive array in Vue\nDESCRIPTION: This snippet demonstrates applying useArrayFindLast to a reactive array in Vue, showing how the result updates dynamically as the array changes, such as adding new elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFindLast/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayFindLast } from '@vueuse/core'\n\nconst list = reactive([-1, -2])\nconst positive = useArrayFindLast(list, val => val > 0)\n// positive.value: undefined\nlist.push(10)\n// positive.value: 10\nlist.push(5)\n// positive.value: 5\n```\n\n----------------------------------------\n\nTITLE: Using logicNot Function with VueUse in TypeScript\nDESCRIPTION: This snippet demonstrates importing the logicNot function from @vueuse/math and its usage with Vue's ref to watch for the negation condition. It sets up a reactive boolean and invokes a callback when the negation evaluates to true, aiding reactivity management in Vue.js.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/logicNot/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { whenever } from '@vueuse/core'\nimport { logicNot } from '@vueuse/math'\n\nconst a = ref(true)\n\nwhenever(logicNot(a), () => {\n  console.log('a is now falsy!')\n})\n```\n\n----------------------------------------\n\nTITLE: Binding Reactive Ref to Document Title with VueUse in JavaScript\nDESCRIPTION: This example illustrates how to bind a reactive computed ref as the document title source. It uses Vue's shallowRef and computed from 'vue' to create a reactive counter that dynamically updates the title to reflect message count. The document title updates automatically when the reactive ref changes. This requires Vue 3 reactive primitives and '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTitle/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { shallowRef } from 'vue'\nimport { useTitle } from '@vueuse/core'\n\nconst messages = shallowRef(0)\n\nconst title = computed(() => {\n  return !messages.value ? 'No message' : `${messages.value} new messages`\n})\n\nuseTitle(title) // document title will match with the ref \"title\"\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing useFps in VueUse (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to import the useFps composable from the @vueuse/core package and initialize it within a Vue.js project. The useFps function provides a reactive variable that tracks the current frames per second, enabling you to monitor rendering performance in real-time. To use this snippet, ensure that VueUse is installed as a dependency; no additional parameters are required as the function initializes with default behavior and returns a reactive value representing the FPS.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFps/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useFps } from '@vueuse/core'\n\nconst fps = useFps()\n```\n\n----------------------------------------\n\nTITLE: Converting String Ref to Number with useToNumber (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `useToNumber` composable from the `@vueuse/core` library to reactively convert a string ref to a number. It utilizes `shallowRef` from Vue to create a reactive string variable and then uses `useToNumber` to create a reactive number variable that automatically updates when the string ref changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useToNumber/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useToNumber } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst str = shallowRef('123')\nconst number = useToNumber(str)\n\nnumber.value // 123\n```\n\n----------------------------------------\n\nTITLE: Using useArrayReduce with an initial value\nDESCRIPTION: Demonstrates using useArrayReduce with an initial value parameter, allowing for accumulation starting from a specified value and working with object properties.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayReduce/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayReduce } from '@vueuse/core'\n\nconst list = reactive([{ num: 1 }, { num: 2 }])\nconst sum = useArrayReduce(list, (sum, val) => sum + val.num, 0)\n// sum.value: 3\n```\n\n----------------------------------------\n\nTITLE: Calculating Average of Refs using useAverage - TypeScript\nDESCRIPTION: This snippet shows how to compute the reactive average of two individual refs using the `useAverage` function from `@vueuse/math`.  Two refs, `a` and `b`, are initialized with numerical values. `useAverage` takes these refs as input and returns a ref (`averageValue`) containing their average. Any changes to `a` or `b` will automatically update `averageValue`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useAverage/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAverage } from '@vueuse/math'\n\nconst a = ref(1)\nconst b = ref(3)\n\nconst averageValue = useAverage(a, b) // Ref<2>\n```\n\n----------------------------------------\n\nTITLE: Using the UsePreferredContrast Component in Vue Templates\nDESCRIPTION: This snippet shows how to utilize the `UsePreferredContrast` renderless component provided by VueUse. It uses the `v-slot` directive to expose the current preferred contrast value (`contrast`) directly within the template for display or conditional rendering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredContrast/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePreferredContrast v-slot=\"{ contrast }\">\n    Preferred Contrast: {{ contrast }}\n  </UsePreferredContrast>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useFocusWithin to Detect Focus in Vue.js\nDESCRIPTION: This snippet demonstrates how to import and use the useFocusWithin function from '@vueuse/core' to monitor whether a form element or any of its input descendants currently has focus. It includes setting up a reactive reference, calling useFocusWithin, and reacting to focus changes with a watch statement. Dependencies include Vue's ref and watch functions, and the @vueuse/core library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFocusWithin/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n```vue\n<script>\nimport { useFocusWithin } from '@vueuse/core'\n\nconst target = ref()\nconst { focused } = useFocusWithin(target)\n\nwatch(focused, (focused) => {\n  if (focused)\n    console.log('Target contains the focused element')\n  else console.log('Target does NOT contain the focused element')\n})\n</script>\n\n<template>\n  <form ref=\"target\">\n    <input type=\"text\" placeholder=\"First Name\">\n    <input type=\"text\" placeholder=\"Last Name\">\n    <input type=\"text\" placeholder=\"Email\">\n    <input type=\"text\" placeholder=\"Password\">\n  </form>\n</template>```\n\n```\n\n----------------------------------------\n\nTITLE: Defining useArrayFindLast Function in VueUse\nDESCRIPTION: The snippet shows how to import and use the useArrayFindLast function from VueUse to find the last element satisfying a condition in an array of refs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFindLast/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayFindLast } from '@vueuse/core'\n\nconst list = [ref(1), ref(-1), ref(2)]\nconst positive = useArrayFindLast(list, val => val > 0)\n// positive.value: 2\n```\n\n----------------------------------------\n\nTITLE: Passing watch Options to useExtractedObservable in TypeScript\nDESCRIPTION: Shows how to pass additional watch options as the last argument in useExtractedObservable to customize its Vue watcher behavior. The reactive input is a shallowRef that could be undefined initially. The observable emits values with operators to sum values until takeWhile condition fails. The options object sets immediate to false, disabling immediate invocation. This snippet requires knowledge of Vue's watch configuration and RxJS integration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useExtractedObservable/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useExtractedObservable } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { mapTo, scan, startWith, takeWhile } from 'rxjs/operators'\nimport { shallowRef } from 'vue'\n\n// setup()\nconst start = shallowRef<number>()\n\nconst count = useExtractedObservable(\n  start,\n  (start) => {\n    return interval(1000).pipe(\n      mapTo(1),\n      startWith(start),\n      scan((total, next) => next + total),\n      takeWhile(num => num < 10)\n    )\n  },\n  {},\n  {\n    immediate: false\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: HTML Examples Showing LTR and RTL Configurations\nDESCRIPTION: Shows HTML examples of both left-to-right and right-to-left text direction configurations using the dir attribute on the html tag.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextDirection/index.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!--ltr-->\n<html>\n  ...\n</html>\n\n<!--rtl-->\n<html dir=\"rtl\">\n  ...\n</html>\n```\n\n----------------------------------------\n\nTITLE: Initializing reactive date with useNow in JavaScript\nDESCRIPTION: Imports the `useNow` composable from `@vueuse/core` and calls it to obtain a basic reactive `Date` instance that updates over time.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useNow/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useNow } from '@vueuse/core'\n\nconst now = useNow()\n```\n\n----------------------------------------\n\nTITLE: Configuring vElementHover Directive with Delay Options\nDESCRIPTION: This snippet demonstrates how to provide additional configuration options to the vElementHover directive. It shows how to set a delay before the hover state is triggered using the delayEnter option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementHover/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vElementHover } from '@vueuse/components'\nimport { shallowRef } from 'vue'\n\nconst isHovered = shallowRef(false)\nfunction onHover(hovered: boolean) {\n  isHovered.value = hovered\n}\n</script>\n\n<template>\n  <button v-element-hover=\"[onHover, { delayEnter: 1000 }]\">\n    <span>{{ isHovered ? 'Thank you!' : 'Hover me' }}</span>\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Initializing useStepper with an object of steps in JavaScript\nDESCRIPTION: This snippet shows how to initialize `useStepper` with an object where keys are step names and values are objects containing step data (e.g., title). It illustrates accessing properties of the current step object, like `current.value.title`. Requires `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStepper/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useStepper } from '@vueuse/core'\n\nconst {\n  steps,\n  stepNames,\n  index,\n  current,\n  next,\n  previous,\n  isFirst,\n  isLast,\n  goTo,\n  goToNext,\n  goToPrevious,\n  goBackTo,\n  isNext,\n  isPrevious,\n  isCurrent,\n  isBefore,\n  isAfter,\n} = useStepper({\n  'user-information': {\n    title: 'User information',\n  },\n  'billing-address': {\n    title: 'Billing address',\n  },\n  'terms': {\n    title: 'Terms',\n  },\n  'payment': {\n    title: 'Payment',\n  },\n})\n\n// Access the step object through `current`\nconsole.log(current.value.title) // 'User information'\n```\n\n----------------------------------------\n\nTITLE: Setting SSR Width in Root Component with Vue\nDESCRIPTION: Shows how to provide a global SSR viewport width from the root component using the composition API. This approach sets a width of 500 pixels without requiring the app instance.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSSRWidth/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { provideSSRWidth } from '@vueuse/core'\n\nprovideSSRWidth(500)\n</script>\n```\n\n----------------------------------------\n\nTITLE: Controlling Gamepad Updates with pause and resume\nDESCRIPTION: This TypeScript snippet illustrates controlling the polling of gamepad updates using the `pause` and `resume` functions provided by `useGamepad`.  It imports the `useGamepad` composable. It pauses the gamepad updates and resumes it later. Requires VueUse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGamepad/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useGamepad } from '@vueuse/core'\n\nconst { pause, resume, gamepads } = useGamepad()\n\npause()\n\n// gamepads object will not update\n\nresume()\n\n// gamepads object will update on user input\n```\n\n----------------------------------------\n\nTITLE: Displaying Mouse Leave State in a Vue Component Using usePageLeave\nDESCRIPTION: This Vue component snippet demonstrates how to consume the usePageLeave reactive state within a Vue Single File Component template. It uses a scoped slot named \"isLeft\" provided by a UsePageLeave component to reactively display whether the mouse has left the page. This requires that the UsePageLeave component internally uses the usePageLeave hook and emits the state via scoped slots.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePageLeave/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UsePageLeave v-slot=\"{ isLeft }\">\n    Has Left Page: {{ isLeft }}\n  </UsePageLeave>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using Klona Library with useRefHistory\nDESCRIPTION: Demonstrates using the lightweight klona library for object cloning when tracking history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useRefHistory/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRefHistory } from '@vueuse/core'\nimport { klona } from 'klona'\n\nconst refHistory = useRefHistory(target, { clone: klona })\n```\n\n----------------------------------------\n\nTITLE: Creating Unref Function - TypeScript\nDESCRIPTION: This snippet demonstrates the creation and usage of `createUnrefFn` from the `@vueuse/core` library in a TypeScript environment.  It imports `createUnrefFn` and `shallowRef` from the Vue library. It defines a function `post` that takes a URL and data, and then creates an \"unref\" version of it `unrefPost` using `createUnrefFn`.  The `unrefPost` function will automatically unref the arguments before passing them to the original function.  This helps to avoid errors associated with passing refs to functions that expect raw values.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createUnrefFn/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\nimport { createUnrefFn } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst url = shallowRef('https://httpbin.org/post')\nconst data = shallowRef({ foo: 'bar' })\n\nfunction post(url, data) {\n  return fetch(url, { data })\n}\nconst unrefPost = createUnrefFn(post)\n\npost(url, data) /* ‚ùå Will throw an error because the arguments are refs */\nunrefPost(url, data) /* ‚úîÔ∏è Will Work because the arguments will be auto unref */\n```\n```\n\n----------------------------------------\n\nTITLE: Using useArrayFindIndex with Reactive Array in JavaScript\nDESCRIPTION: Illustrates useArrayFindIndex applied to a reactive array wrapped in a ref, sourced from Vue 3's reactive system, along with the @vueuse/core package. The array contains numeric values with a predicate targeting even numbers. Upon mutations like unshifting a new element, the reactive index updates instantly to reflect the first element matching the condition. Inputs include a reactive array and a predicate function; output is a reactive index ref responsive to array changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayFindIndex/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArrayFindIndex } from '@vueuse/core'\n\nconst list = ref([0, 2, 4, 6, 8])\nconst result = useArrayFindIndex(list, i => i % 2 === 0)\n// result.value: 0\nlist.value.unshift(-1)\n// result.value: 1\n```\n\n----------------------------------------\n\nTITLE: Using v-element-bounding Directive - Vue and TypeScript\nDESCRIPTION: This snippet displays the usage of the `v-element-bounding` directive. The directive is applied to a `textarea` element and triggers the `onBounding` function whenever the bounding box of the textarea changes. Options for the directive are provided as well. The example also includes an interface `BoundingType` to describe the shape of the bounding box parameters passed to the callback.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useElementBounding/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { vElementBounding } from '@vueuse/components'\n\ninterface BoundingType {\n  height: number\n  bottom: number\n  left: number\n  right: number\n  top: number\n  width: number\n  x: number\n  y: number\n}\n\nfunction onBounding({ height, bottom, left, right, top, width, x, y }: BoundingType) {\n  console.log(height, bottom, left, right, top, width, x, y)\n}\n\nconst options = {\n  reset: true,\n  windowResize: true,\n  windowScroll: true,\n  immediate: true,\n  updateTiming: 'sync',\n}\n</script>\n\n<template>\n  <textarea v-element-bounding=\"onBounding\" />\n  <!-- with options -->\n  <textarea v-element-bounding=\"[onBounding, options]\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: useAxios with execute function and config\nDESCRIPTION: This example demonstrates the usage of `execute` function and config. The `execute` function can also accept only the config.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\n\nconst { execute } = useAxios(url1, { method: 'GET' }, { immediate: false })\nexecute({ params: { key: 1 } })\nexecute({ params: { key: 2 } })\n```\n\n----------------------------------------\n\nTITLE: Installing @vueuse/router package\nDESCRIPTION: This command installs the @vueuse/router package and vue-router version 4 using npm.  It is a prerequisite for using the functionalities provided by @vueuse/router.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/router vue-router@4\n```\n\n----------------------------------------\n\nTITLE: Customizing useTextDirection with Options\nDESCRIPTION: Shows how to customize the useTextDirection function by providing options, specifically changing the target element selector from the default html to body.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTextDirection/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useTextDirection } from '@vueuse/core'\n\nconst mode = useTextDirection({\n  selector: 'body'\n}) // Ref<'ltr' | 'rtl' | 'auto'>\n```\n\n----------------------------------------\n\nTITLE: Using useSortable with Vue template ref\nDESCRIPTION: Example demonstrating how to use useSortable with a Vue template ref to create a sortable list. Uses useTemplateRef and shallowRef to manage the sortable elements.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useSortable/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useSortable } from '@vueuse/integrations/useSortable'\nimport { shallowRef, useTemplateRef } from 'vue'\n\nconst el = useTemplateRef<HTMLElement>('el')\nconst list = shallowRef([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\n\nuseSortable(el, list)\n</script>\n\n<template>\n  <div ref=\"el\">\n    <div v-for=\"item in list\" :key=\"item.id\">\n      {{ item.name }}\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Complete VueUse usage example with multiple functions\nDESCRIPTION: Comprehensive example showing how to import and use multiple VueUse functions including useMouse, usePreferredDark, and useLocalStorage in a Vue component.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_7\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useLocalStorage, useMouse, usePreferredDark } from '@vueuse/core'\n\n// tracks mouse position\nconst { x, y } = useMouse()\n\n// is user prefers dark theme\nconst isDark = usePreferredDark()\n\n// persist state in localStorage\nconst store = useLocalStorage(\n  'my-storage',\n  {\n    name: 'Apple',\n    color: 'red',\n  },\n)\n</script>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of createTemplatePromise with Vue 3\nDESCRIPTION: Demonstrates the basic setup of createTemplatePromise in a Vue component, showing how to initialize the component and use it in a template with resolve functionality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { createTemplatePromise } from '@vueuse/core'\n\nconst TemplatePromise = createTemplatePromise<ReturnType>()\n\nasync function open() {\n  const result = await TemplatePromise.start()\n  // button is clicked, result is 'ok'\n}\n</script>\n\n<template>\n  <TemplatePromise v-slot=\"{ promise, resolve, reject, args }\">\n    <!-- your UI -->\n    <button @click=\"resolve('ok')\">\n      OK\n    </button>\n  </TemplatePromise>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Passing and Rendering Slots in Reusable Templates (Vue)\nDESCRIPTION: Explains how to pass named or default slots from ReuseTemplate to DefineTemplate and access them via $slots in the receiving template block for flexible slot composition. Prerequisites: Vue 3, @vueuse/core. Inputs: $slots object available in slot scope. Outputs: Arbitrary slot content rendered within the reusable template layout. Limitation: Slot resolution depends on correct slot naming and order.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_8\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate()\n</script>\n\n<template>\n  <DefineTemplate v-slot=\"{ $slots, otherProp }\">\n    <div some-layout>\n      <!-- To render the slot -->\n      <component :is=\"$slots.default\" />\n    </div>\n  </DefineTemplate>\n\n  <ReuseTemplate>\n    <div>Some content</div>\n  </ReuseTemplate>\n  <ReuseTemplate>\n    <div>Another content</div>\n  </ReuseTemplate>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Applying media query attribute with useStyleTag in VueUse\nDESCRIPTION: This snippet shows how to add a media attribute to the style element by passing an object with the 'media' property as the third argument. The injected style will include the media attribute in the <style> tag, enabling conditional application of styles based on media queries like 'print'. It depends on VueUse's reactive styling capabilities and supports media-specific styling.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useStyleTag/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nuseStyleTag('.foo { margin-top: 32px; }', { media: 'print' })\n\n// Injected into <head>\n// <style id=\"vueuse_styletag_1\" media=\"print\">\n//   .foo {\n//     margin-top: 32px;\n//   }\n// </style>\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Average of Array using useAverage - TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `useAverage` function from `@vueuse/math` to calculate the reactive average of a ref array. The `list` ref is initialized with an array of numbers. The `useAverage` function takes this `list` as input and returns a ref (`averageValue`) containing the average of the elements in the array.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useAverage/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAverage } from '@vueuse/math'\n\nconst list = ref([1, 2, 3])\nconst averageValue = useAverage(list) // Ref<2>\n```\n\n----------------------------------------\n\nTITLE: Using usePerformanceObserver VueUse Hook TypeScript\nDESCRIPTION: This snippet demonstrates how to use the `usePerformanceObserver` hook from `@vueuse/core` to observe specific performance entry types. It initializes a ref to store performance entries and updates it whenever 'paint' entries are observed. The hook takes configuration options (like `entryTypes`) and a callback function that receives a `PerformanceObserverEntryList`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePerformanceObserver/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { usePerformanceObserver } from '@vueuse/core'\n\nconst entrys = ref<PerformanceEntry[]>([])\nusePerformanceObserver({\n  entryTypes: ['paint'],\n}, (list) => {\n  entrys.value = list.getEntries()\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Drauu Library with Vue.js and VueUse\nDESCRIPTION: This Vue.js example demonstrates how to use the `useDrauu` composable.  It imports `useDrauu` and `toRefs` from `@vueuse/integrations/useDrauu` and `@vueuse/core` respectively.  It also uses the `useTemplateRef` hook from Vue for referencing an SVG element where the drawing will occur.  The `useDrauu` function is initialized with the `target` which is a reference to the SVG element, and provides access to undo/redo actions and brush settings.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useDrauu/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { toRefs } from '@vueuse/core'\nimport { useDrauu } from '@vueuse/integrations/useDrauu'\nimport { useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<SVGSVGElement>('target')\nconst { undo, redo, canUndo, canRedo, brush } = useDrauu(target)\nconst { color, size } = toRefs(brush)\n</script>\n\n<template>\n  <svg ref=\"target\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useQRCode with reactive ref\nDESCRIPTION: Example showing how to use useQRCode with a reactive ref as input. The QR code will automatically update when the source text changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useQRCode/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useQRCode } from '@vueuse/integrations/useQRCode'\nimport { shallowRef } from 'vue'\n\nconst text = shallowRef('text-to-encode')\nconst qrcode = useQRCode(text)\n```\n\n----------------------------------------\n\nTITLE: Using useArraySome with Array of Multiple Refs in JavaScript\nDESCRIPTION: This snippet demonstrates how to use the useArraySome composable from @vueuse/core on an array composed of multiple Vue refs. It shows creating individual refs as elements, applying useArraySome with a predicate (i > 10), and reactive tracking of changes to any ref in the array. Key dependencies include Vue's ref function and @vueuse/core's useArraySome composable. The input is an array of refs and a predicate function, and the output is a reactive ref containing a boolean reflecting whether any array element matches the predicate. Changes to element values dynamically update the result.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArraySome/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useArraySome } from '@vueuse/core'\n\nconst item1 = ref(0)\nconst item2 = ref(2)\nconst item3 = ref(4)\nconst item4 = ref(6)\nconst item5 = ref(8)\nconst list = [item1, item2, item3, item4, item5]\nconst result = useArraySome(list, i => i > 10)\n// result.value: false\nitem1.value = 11\n// result.value: true\n```\n\n----------------------------------------\n\nTITLE: Tracking Mutable Object Ref History with Cloning in VueUse (TypeScript)\nDESCRIPTION: Illustrates tracking the history of a mutable object using useManualRefHistory with the clone option enabled for safe deep copying. Requires @vueuse/core and vue. The clone: true parameter activates minimal deep clone via JSON parse/stringify for snapshots, essential when mutating object refs to avoid reference issues. Input: mutation of object ref properties; Output: properly cloned state snapshots in history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\nimport { ref } from 'vue'\n\nconst counter = ref({ foo: 1, bar: 2 })\nconst { history, commit, undo, redo } = useManualRefHistory(counter, { clone: true })\n\ncounter.value.foo += 1\ncommit()\n```\n\n----------------------------------------\n\nTITLE: Using VueUse via CDN\nDESCRIPTION: Example of including VueUse via CDN scripts. This exposes VueUse functionality to the global window object as window.VueUse.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script src=\"https://unpkg.com/@vueuse/shared\"></script>\n\n<script src=\"https://unpkg.com/@vueuse/core\"></script>\n```\n\n----------------------------------------\n\nTITLE: Using useArrayUnique with custom comparison function in JavaScript\nDESCRIPTION: Demonstrates how to use useArrayUnique with a custom comparison function to determine uniqueness based on specific object properties. This example filters objects based on their id property.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useArrayUnique/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useArrayUnique } from '@vueuse/core'\n\nconst list = reactive([\n  { id: 1, name: 'foo' },\n  { id: 2, name: 'bar' },\n  { id: 1, name: 'baz' },\n])\n\nconst result = useArrayUnique(list, (a, b) => a.id === b.id)\n// result.value: [{ id: 1, name: 'foo' }, { id: 2, name: 'bar' }]\n\nlist.push({ id: 1, name: 'qux' })\n// result.value: [{ id: 1, name: 'foo' }, { id: 2, name: 'bar' }]\n```\n\n----------------------------------------\n\nTITLE: useWindowSize Component Usage (Vue)\nDESCRIPTION: Demonstrates how to use the `useWindowSize` composable within a Vue component using the `<UseWindowSize>` component.  It utilizes a scoped slot to access the reactive `width` and `height` values and display them in the template.  The `UseWindowSize` component is not a standard Vue component and is likely a custom component provided by VueUse or a related library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWindowSize/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseWindowSize v-slot=\"{ width, height }\">\n    Width: {{ width }}\n    Height: {{ height }}\n  </UseWindowSize>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Configuring onBeforeChange Option\nDESCRIPTION: Demonstrates how to use the `onBeforeChange` option to control whether a new value should be accepted. It shows how to prevent changes that exceed a certain threshold by returning `false` from the callback function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refWithControl/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst num = refWithControl(0, {\n  onBeforeChange(value, oldValue) {\n    // disallow changes larger then ¬±5 in one operation\n    if (Math.abs(value - oldValue) > 5)\n      return false // returning `false` to dismiss the change\n  },\n})\n\nnum.value += 1\nconsole.log(num.value) // 1\n\nnum.value += 6\nconsole.log(num.value) // 1 (change been dismissed)\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Extractor with useMouse in TypeScript\nDESCRIPTION: Illustrates how to provide a custom extractor function (`UseMouseEventExtractor`) to `useMouse` for determining coordinates. This example extracts `offsetX` and `offsetY` relative to a target element (obtained via `useParentElement`), handling only `MouseEvent` instances.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMouse/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { UseMouseEventExtractor } from '@vueuse/core'\nimport { useMouse, useParentElement } from '@vueuse/core'\n\nconst parentEl = useParentElement()\n\nconst extractor: UseMouseEventExtractor = event => (\n  event instanceof MouseEvent\n    ? [event.offsetX, event.offsetY]\n    : null\n)\n\nconst { x, y, sourceType } = useMouse({ target: parentEl, type: extractor })\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with pnpm - Bash\nDESCRIPTION: Executes the unit tests for the project using the pre-configured test runner. This command helps verify code correctness and catch regressions. The testing environment relies on the project's previously installed dependencies. Outputs test results to the console.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm test:unit # to run unit tests\n```\n\n----------------------------------------\n\nTITLE: Key Aliasing with useMagicKeys in TypeScript\nDESCRIPTION: Shows how to define aliases for keys using the aliasMap option in useMagicKeys, allowing for custom key shortcut naming. Default alias mappings are available and can be customized as needed.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys, whenever } from '@vueuse/core'\n\nconst { shift_cool } = useMagicKeys({\n  aliasMap: {\n    cool: 'space',\n  },\n})\n\nwhenever(shift_cool, () => console.log('Shift + Space have been pressed'))\n```\n\n----------------------------------------\n\nTITLE: Custom Dump and Parse Functions in VueUse Ref History (TypeScript)\nDESCRIPTION: Shows how to use custom dump and parse serialization functions instead of cloning for flexible ref history tracking. Only requires @vueuse/core. Passes JSON.stringify as dump and JSON.parse as parse to store serialized state for efficient or persistent history (e.g., saving to local storage). Input: target ref; Output: serialized history snapshots.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\n\nconst refHistory = useManualRefHistory(target, {\n  dump: JSON.stringify,\n  parse: JSON.parse,\n})\n```\n\n----------------------------------------\n\nTITLE: Unlocking Screen Orientation with useScreenOrientation\nDESCRIPTION: Demonstrates how to unlock the screen orientation after it has been locked. The unlockOrientation function removes any previously applied orientation locks.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenOrientation/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nunlockOrientation()\n```\n\n----------------------------------------\n\nTITLE: Vue Template for Template Ref Example\nDESCRIPTION: Provides the Vue template associated with the TypeScript example using `useTemplateRef`. It demonstrates how a `ref` named 'element' can be conditionally assigned to different `div` elements using `v-if`/`v-else`, showcasing `useEventListener`'s ability to adapt to changing targets.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventListener/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <div v-if=\"cond\" ref=\"element\">\n    Div1\n  </div>\n  <div v-else ref=\"element\">\n    Div2\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useEyeDropper API - Vue Component\nDESCRIPTION: This Vue component example demonstrates how to integrate the `useEyeDropper` composable into a Vue template. It utilizes a `v-slot` directive with properties from the `useEyeDropper` composable: `isSupported`, `sRGBHex` and `open`. It disables the button if EyeDropper is not supported by the browser, updates the displayed color, and calls the `open` method on button click.  The primary dependency is Vue, with an import from `@vueuse/core`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEyeDropper/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseEyeDropper v-slot=\"{ isSupported, sRGBHex, open }\">\n    <button :disabled=\"!isSupported\" @click=\"open\">\n      sRGBHex: {{ sRGBHex }}\n    </button>\n  </UseEyeDropper>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using computedEager for Eager Reactivity in Vue.js\nDESCRIPTION: Demonstrates importing `computedEager` from `@vueuse/core` and using it to create an eagerly computed boolean ref (`hasOpenTodos`) based on the length of a reactive `todos` array. The computed value updates immediately when the `todos` array is modified, differing from the lazy evaluation of standard `computed`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/computedEager/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { computedEager } from '@vueuse/core'\nimport { ref } from 'vue' // Assuming ref is imported from Vue\n\nconst todos = ref([])\nconst hasOpenTodos = computedEager(() => !!todos.value.length)\n\nconsole.log(hasOpenTodos.value) // false\ntodos.value.push({ title: 'Learn Vue' })\nconsole.log(hasOpenTodos.value) // true\n```\n\n----------------------------------------\n\nTITLE: Using Custom Fetch Utility with Event Hooks in Vue 3 (TypeScript)\nDESCRIPTION: This Vue 3 `<script setup>` snippet imports and calls the `useMyFetch` function created in the previous example to initiate a data fetch. It then accesses the `onResult` and `onError` properties returned by `useMyFetch` and attaches callback functions using their `.on()` methods. These callbacks will execute when the fetch operation completes successfully or encounters an error, logging the outcome to the console.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createEventHook/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useMyFetch } from './my-fetch-function'\n\nconst { onResult, onError } = useMyFetch('my api url')\n\nonResult((result) => {\n  console.log(result)\n})\n\nonError((error) => {\n  console.error(error)\n})\n</script>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of tryOnBeforeMount in JavaScript\nDESCRIPTION: Demonstrates how to import `tryOnBeforeMount` from `@vueuse/core` and call it with an empty arrow function as the callback. This shows the fundamental way to use the function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/tryOnBeforeMount/index.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { tryOnBeforeMount } from '@vueuse/core'\n\ntryOnBeforeMount(() => {\n\n})\n```\n\n----------------------------------------\n\nTITLE: Using Key Combinations with useMagicKeys in TypeScript\nDESCRIPTION: Shows how to define and monitor complex key combinations such as 'Shift+Ctrl+A' using the keys object returned by useMagicKeys. Usage of watch to trigger actions when the shortcuts are activated. Dependencies include '@vueuse/core'.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMagicKeys } from '@vueuse/core'\n\nconst keys = useMagicKeys()\nconst shiftCtrlA = keys['Shift+Ctrl+A']\n\nwatch(shiftCtrlA, (v) => {\n  if (v)\n    console.log('Shift + Ctrl + A have been pressed')\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing useTimestamp with offset - JavaScript\nDESCRIPTION: Initializes the useTimestamp composable with an offset of 0. This will return a reactive timestamp that is offset by the specified amount. The timestamp will update automatically.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useTimestamp/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useTimestamp } from '@vueuse/core'\n\nconst timestamp = useTimestamp({ offset: 0 })\n```\n\n----------------------------------------\n\nTITLE: Using useMax with a Reactive Array in TypeScript\nDESCRIPTION: Demonstrates finding the maximum value within a reactive array using `useMax`. It imports `useMax` from `@vueuse/math` and applies it to a `ref` containing an array of numbers. The result is a reactive `ref` holding the maximum value (4 in this case).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useMax/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useMax } from '@vueuse/math'\n\nconst array = ref([1, 2, 3, 4])\nconst max = useMax(array) // Ref<4>\n```\n\n----------------------------------------\n\nTITLE: Binding Template Refs in Vue with JSX/TSX using VueUse and TypeScript\nDESCRIPTION: This snippet illustrates how to use the templateRef function from VueUse in a Vue component written in TypeScript with JSX/TSX syntax. It defines a type-safe reference for an HTMLElement or null with a string key, binds it using a string ref in JSX, and returns a render function invoking that binding. It requires '@vueuse/core' for templateRef and TypeScript for type annotations. The key parameter ('target') synchronizes the ref name between template and script.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/templateRef/index.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { templateRef } from '@vueuse/core'\n\nexport default {\n  setup() {\n    const target = templateRef<HTMLElement | null>('target', null)\n\n    // use string ref\n    return () => <div ref=\"target\"></div>\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Reactify Usage with Addition Function in TypeScript\nDESCRIPTION: Demonstrates how to convert a basic addition function into a reactive function using reactify. The function accepts refs as arguments and returns a computed ref that updates when input values change.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactify/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactify } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\n// a plain function\nfunction add(a: number, b: number): number {\n  return a + b\n}\n\n// now it accept refs and returns a computed ref\n// (a: number | Ref<number>, b: number | Ref<number>) => ComputedRef<number>\nconst reactiveAdd = reactify(add)\n\nconst a = shallowRef(1)\nconst b = shallowRef(2)\nconst sum = reactiveAdd(a, b)\n\nconsole.log(sum.value) // 3\n\na.value = 5\n\nconsole.log(sum.value) // 7\n```\n\n----------------------------------------\n\nTITLE: Watching with Filter in VueUse\nDESCRIPTION: Sets up a watcher that only triggers when a specific condition or filter on dependencies is met. Enhances Vue's reactive watch mechanism with conditional execution control.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Implements a watch function that invokes callback only when specified filter criteria are satisfied. Used in Vue 3 compositions to optimize reactions based on complex conditions. */\n```\n\n----------------------------------------\n\nTITLE: Using watchTriggerable with onCleanup (TypeScript)\nDESCRIPTION: This example demonstrates using `watchTriggerable` with the `onCleanup` parameter to handle asynchronous operations and prevent unintended side effects. It imports `watchTriggerable` from `@vueuse/core` and `shallowRef` from `vue`. The `onCleanup` function is used to cancel the asynchronous operation if the watcher is invalidated.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchTriggerable/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchTriggerable } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst source = shallowRef(0)\n\nconst { trigger } = watchTriggerable(\n  source,\n  async (v, _, onCleanup) => {\n    let canceled = false\n    onCleanup(() => canceled = true)\n\n    await new Promise(resolve => setTimeout(resolve, 500))\n    if (canceled)\n      return\n\n    console.log(`The value is \"${v}\"\n`)\n  },\n)\n\nsource.value = 1 // no log\nawait trigger() // logs (after 500 ms): The value is \"1\"\n```\n\n----------------------------------------\n\nTITLE: Importing and Using useAbs in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to import the `useAbs` function from `@vueuse/math` and use it to create a reactive absolute value. It initializes a Vue ref (`value`) with -23 and then uses `useAbs` to create a computed ref (`absValue`) that always holds the absolute value of `value` (which will be 23).\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useAbs/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAbs } from '@vueuse/math'\n\nconst value = ref(-23)\nconst absValue = useAbs(value) // Ref<23>\n```\n\n----------------------------------------\n\nTITLE: Using unrefElement with Vue refs and components\nDESCRIPTION: This example demonstrates how to use `unrefElement` to get the DOM element from a template ref bound to a div element and a component instance. It uses `useTemplateRef` to create the refs and `onMounted` to ensure the elements are available before accessing them with `unrefElement`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/unrefElement/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { unrefElement } from '@vueuse/core'\nimport { onMounted, useTemplateRef } from 'vue'\n\nconst div = useTemplateRef<HTMLElement>('div') // will be bound to the <div> element\nconst hello = useTemplateRef<Component>('hello') // will be bound to the HelloWorld Component\n\nonMounted(() => {\n  console.log(unrefElement(div)) // the <div> element\n  console.log(unrefElement(hello)) // the root element of the HelloWorld Component\n})\n</script>\n\n<template>\n  <div ref=\"div\" />\n  <HelloWorld ref=\"hello\" />\n</template>\n\n```\n\n----------------------------------------\n\nTITLE: Clamping Static Values Reactively with VueUse Math in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the useClamp function to clamp a static numeric value within reactive minimum and maximum boundaries using Vue's shallowRef and computed reactivity. Dependencies include Vue's shallowRef and the useClamp function from @vueuse/math. Inputs are the initial value (0) and reactive minimum (min) and maximum (max) bounds, with the output being a reactive clamped value that updates automatically if bounds change.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useClamp/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useClamp } from '@vueuse/math'\n\nconst min = shallowRef(0)\nconst max = shallowRef(10)\nconst value = useClamp(0, min, max)\n```\n\n----------------------------------------\n\nTITLE: Custom Clone Function with Lodash cloneDeep in VueUse (TypeScript)\nDESCRIPTION: Demonstrates using lodash-es cloneDeep function for custom deep cloning in ref history tracking. Dependencies: @vueuse/core, lodash-es, and the target ref. cloneDeep is passed as the clone option, enabling deep cloning for complex nested objects. Input: mutable ref; Output: deeply cloned snapshots in history.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\nimport { cloneDeep } from 'lodash-es'\n\nconst refHistory = useManualRefHistory(target, { clone: cloneDeep })\n```\n\n----------------------------------------\n\nTITLE: Automatic cleanup of event listeners with useEventListener in TypeScript\nDESCRIPTION: Illustrates the use of useEventListener to add a mousemove event listener that is automatically cleaned up upon component unmount, promoting efficient resource management.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useEventListener } from '@vueuse/core'\n// ---cut---\n// will cleanup automatically\nuseEventListener('mousemove', () => {})\n```\n\n----------------------------------------\n\nTITLE: Case Conversion in VueUse\nDESCRIPTION: Includes utilities for converting string case formats, such as snake_case to camelCase or hyphen-case, aiding in consistent formatting.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* String case conversion utilities for formatting consistency in Vue templates and code. */\n```\n\n----------------------------------------\n\nTITLE: Converting Vue Ref to Reactive Object using VueUse in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to use VueUse's toReactive function along with Vue's ref to convert a ref-wrapped object into a reactive object. Dependencies required are @vueuse/core and vue. The key parameter is refState, a ref holding the target object, which becomes fully reactive when passed to toReactive. Mutating refState.value swaps the referenced object, updating the reactivity accordingly. Inputs are ref objects, and the output is a reactive proxy object reflecting the latest reference; however, individual properties are not deep-proxied, and reactivity responds to the reference value itself.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/toReactive/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { toReactive } from '@vueuse/core'\nimport { ref } from 'vue'\n\nconst refState = ref({ foo: 'bar' })\n\nconsole.log(refState.value.foo) // => 'bar'\n\nconst state = toReactive(refState) // <--\n\nconsole.log(state.foo) // => 'bar'\n\nrefState.value = { bar: 'foo' }\n\nconsole.log(state.foo) // => undefined\nconsole.log(state.bar) // => 'foo'\n```\n\n----------------------------------------\n\nTITLE: Locking Screen Orientation with useScreenOrientation\nDESCRIPTION: Shows how to lock the screen orientation to a specific type. The lockOrientation function accepts an OrientationLockType parameter to specify the desired orientation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useScreenOrientation/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useScreenOrientation } from '@vueuse/core'\n\nconst {\n  isSupported,\n  orientation,\n  angle,\n  lockOrientation,\n  unlockOrientation,\n} = useScreenOrientation()\n\nlockOrientation('portrait-primary')\n```\n\n----------------------------------------\n\nTITLE: Restoring Ref Value with Undo in VueUse (TypeScript)\nDESCRIPTION: Shows how to use the undo function from useManualRefHistory to revert a ref's value to its previous state. Assumes an initialized useManualRefHistory instance containing undo. No external dependencies beyond VueUse and Vue. Input: current ref state; Output: reverted ref state after undo is called. Designed for simple rollback of stateful data.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconsole.log(counter.value) // 1\nundo()\nconsole.log(counter.value) // 0\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse in Nuxt using nuxi command\nDESCRIPTION: Demonstrates how to install the VueUse module in a Nuxt application using the nuxi command line tool. This is the recommended installation method.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/nuxt/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx nuxi@latest module add vueuse\n```\n\n----------------------------------------\n\nTITLE: Passing reactive options ref to useShare - TypeScript\nDESCRIPTION: Shows how to use a Vue `ref` to hold the share options dynamically. The `ref` is passed to `useShare`, allowing the options to be updated reactively. Calling `share()` without arguments subsequent to updating the ref will use the latest values from the ref, illustrating flexibility in setting share content.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useShare/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { ref } from 'vue'\n\nconst shareOptions = ref<ShareOptions>({ text: 'foo' })\nconst { share, isSupported } = useShare(shareOptions)\n\nshareOptions.value.text = 'bar'\n\nshare()\n```\n\n----------------------------------------\n\nTITLE: Registering Reusable Templates with the Options API (Vue)\nDESCRIPTION: Demonstrates how to setup DefineTemplate and ReuseTemplate components using the Options API by importing 'createReusableTemplate' ahead of the default export. Components are registered within the component's 'components' option, making them available for use in the SFC template. Prerequisites: Vue 3, @vueuse/core, Options API knowledge. Inputs/Outputs: Slots for passing data; ReuseTemplate can receive bound props. Limitations: Must manage prop passing explicitly and ensure correct component registration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script>\nimport { createReusableTemplate } from '@vueuse/core'\nimport { defineComponent } from 'vue'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate()\n\nexport default defineComponent({\n  components: {\n    DefineTemplate,\n    ReuseTemplate,\n  },\n  setup() {\n    // ...\n  },\n})\n</script>\n\n<template>\n  <DefineTemplate v-slot=\"{ data, msg, anything }\">\n    <div>{{ data }} passed from usage</div>\n  </DefineTemplate>\n\n  <ReuseTemplate :data=\"data\" msg=\"The first usage\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useSpeechRecognition in VueUse to implement speech recognition\nDESCRIPTION: This snippet demonstrates how to import and initialize the useSpeechRecognition composable from VueUse, extracting reactive properties and methods to control speech recognition functionality within a Vue component. Dependencies include '@vueuse/core' and the Web SpeechRecognition API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSpeechRecognition/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useSpeechRecognition } from '@vueuse/core'\n\nconst {\n  isSupported,\n  isListening,\n  isFinal,\n  result,\n  start,\n  stop\n} = useSpeechRecognition()\n```\n\n----------------------------------------\n\nTITLE: Using reactive() to unwrap useMouse object in Vue 3\nDESCRIPTION: Shows wrapping the object returned by useMouse with Vue's reactive() to auto-unwrap refs, simplifying access to temperature values without needing `.value`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@vueuse/core'\nimport { reactive } from 'vue'\n\nconst mouse = reactive(useMouse())\n\n// \"x\" and \"y\" will be auto unwrapped, no `.value` needed\nconsole.log(mouse.x)\n```\n\n----------------------------------------\n\nTITLE: Custom Clone Function with StructuredClone in VueUse (TypeScript)\nDESCRIPTION: Demonstrates the use of a custom clone function (structuredClone) for deep copying state when tracking ref history. Only requires @vueuse/core and a target ref. Passes structuredClone via the clone option to enhance compatibility with complex object structures. Input: any ref; Output: properly deep-cloned snapshots on commit.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useManualRefHistory/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useManualRefHistory } from '@vueuse/core'\n\nconst refHistory = useManualRefHistory(target, { clone: structuredClone })\n```\n\n----------------------------------------\n\nTITLE: Implementing a Single-Trigger Watcher with `watchOnce` in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the `watchOnce` function from `@vueuse/core`. It sets up a watcher on a specified `source` that executes its callback function only the first time the source changes, after which the watcher is automatically stopped.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/watchOnce/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { watchOnce } from '@vueuse/core'\n\nwatchOnce(source, () => {\n  // triggers only once\n  console.log('source changed!')\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies Using pnpm - Bash\nDESCRIPTION: Installs all required project dependencies using the pnpm package manager. This step must be performed after cloning the repository to ensure your development environment has all necessary packages defined in the project's configuration files. No additional parameters are required. The command installs dependencies as specified in package.json, and internet access is necessary.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Implementing onClickOutside with @vueuse/core\nDESCRIPTION: This snippet demonstrates how to use the `onClickOutside` composable function from the `@vueuse/core` library.  It listens for clicks outside of a target element. The `target` is a template ref, and a function handles the click event. Dependencies include `@vueuse/core` and `vue` for `useTemplateRef`.  The event object from outside the target is logged to the console.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onClickOutside/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { onClickOutside } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLElement>('target')\n\nonClickOutside(target, event => console.log(event))\n</script>\n\n<template>\n  <div ref=\"target\">\n    Hello world\n  </div>\n  <div>Outside element</div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Cache Mechanism Interface for useMemoize in TypeScript\nDESCRIPTION: Presents the TypeScript interface `MemoizeCache<Key, Value>` that must be implemented when providing a custom cache mechanism to `useMemoize` via the `cache` option. It defines the standard methods (`get`, `set`, `has`, `delete`, `clear`) required for a compliant cache store.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMemoize/index.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface MemoizeCache<Key, Value> {\n  /**\n   * Get value for key\n   */\n  get: (key: Key) => Value | undefined\n  /**\n   * Set value for key\n   */\n  set: (key: Key, value: Value) => void\n  /**\n   * Return flag if key exists\n   */\n  has: (key: Key) => boolean\n  /**\n   * Delete value for key\n   */\n  delete: (key: Key) => void\n  /**\n   * Clear cache\n   */\n  clear: () => void\n}\n```\n\n----------------------------------------\n\nTITLE: Function Folder Layout Example - Bash\nDESCRIPTION: Lists the standard file and directory layout for a new function in the VueUse core package. Uses bash-style code fence for visual clarity, although the list is documentation rather than an executable command. Serves as a template for contributors to ensure consistency in file naming and placement.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nindex.ts            # function source code itself\ndemo.vue            # documentation demo\nindex.test.ts       # vitest unit testing\nindex.md            # documentation\n```\n\n----------------------------------------\n\nTITLE: Initializing useExtractedObservable with RxJS ObservableSocket in TypeScript\nDESCRIPTION: This snippet demonstrates basic usage of useExtractedObservable to create a reactive reference that tracks messages from an ObservableSocket based on the current user. It imports Vue and RxJS dependencies and shows how to bind an observable to a composable reactive source. Dependencies include @vueuse/rxjs and observable-socket. The input is a reactive user object, and the output is a ref containing the last message. Automatic subscription management is handled internally.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useExtractedObservable/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useExtractedObservable } from '@vueuse/rxjs'\nimport ObservableSocket from 'observable-socket'\nimport { computed } from 'vue'\nimport { makeSocket, useUser } from '../some/lib/func'\n\n// setup()\nconst user = useUser()\nconst lastMessage = useExtractedObservable(user, u => ObservableSocket.create(makeSocket(u.id)).down)\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Reconnection with useEventSource in JavaScript\nDESCRIPTION: Illustrates enabling automatic reconnection by passing an options object with autoReconnect set to true. This configuration attempts to reconnect the EventSource instance automatically when an error occurs. It provides basic resilience to connection interruptions without additional configuration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventSource/index.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst { status, data, close } = useEventSource('https://event-source-url', [], {\n  autoReconnect: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation of useMounted in TypeScript\nDESCRIPTION: Demonstrates the underlying implementation of useMounted, showing how it creates a ref initialized to false and sets it to true when the component is mounted.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMounted/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst isMounted = ref(false)\n\nonMounted(() => {\n  isMounted.value = true\n})\n```\n\n----------------------------------------\n\nTITLE: Alternative Reactive Pythagorean Theorem Implementation in TypeScript\nDESCRIPTION: Demonstrates an alternative approach to implementing the reactive Pythagorean theorem by reactifying a single function that encapsulates the entire calculation, showing the flexibility of the reactify utility.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactify/index.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactify } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nfunction pythagorean(a: number, b: number) {\n  return Math.sqrt(a ** 2 + b ** 2)\n}\n\nconst a = shallowRef(3)\nconst b = shallowRef(4)\n\nconst c = reactify(pythagorean)(a, b)\nconsole.log(c.value) // 5\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Core via NPM in Bash\nDESCRIPTION: This command instructs developers on installing the '@vueuse/core' package using the npm package manager from the command line. The snippet is intended for initializing the VueUse utilities within a JavaScript or TypeScript Vue 3 project. Prerequisites: Node.js, npm, and a Vue 3 project setup. No input parameters; successful execution provides access to all VueUse core features in subsequent code.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpm i @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: IndexedDB Key-Value Storage in VueUse\nDESCRIPTION: Facilitates storing and retrieving data in IndexedDB, supporting persistent client-side data storage in Vue apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_37\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility for managing IndexedDB key-value pairs, enabling persistent storage with reactive access in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Using useEventListener with Template Refs (TypeScript)\nDESCRIPTION: Shows how to use `useEventListener` with a Vue `ref` targeting an HTML element, obtained via `useTemplateRef`. This allows the event listener to be attached to a specific element within the component's template and automatically handles updates if the referenced element changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventListener/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEventListener } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst element = useTemplateRef<HTMLDivElement>('element')\nuseEventListener(element, 'keydown', (e) => {\n  console.log(e.key)\n})\n```\n\n----------------------------------------\n\nTITLE: Using VueUse with CDN\nDESCRIPTION: This snippet demonstrates how to include VueUse using a CDN. It includes the `@vueuse/shared` and `@vueuse/core` scripts from unpkg.com. This method makes the library available globally as `window.VueUse`. The script tags need to be added to the HTML file.  After including these scripts, VueUse composables are directly accessible within the page's JavaScript.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/README.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n```vue\n<script src=\"https://unpkg.com/@vueuse/shared\"></script>\n\n<script src=\"https://unpkg.com/@vueuse/core\"></script>\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Touch Event Detection with useMousePressed in JavaScript\nDESCRIPTION: This snippet shows how to configure useMousePressed to only track mouse input by passing the option { touch: false }. This prevents touch events from affecting the pressed state, focusing solely on mouse activity. This is useful in scenarios where touch interactions are not required or may cause bugs in desktop-only contexts.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useMousePressed/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { pressed } = useMousePressed({ touch: false })\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime Props for Reusable Templates (TypeScript)\nDESCRIPTION: Demonstrates how to manually specify runtime props for a reusable template via the 'props' option of 'createReusableTemplate', providing fine-grained control over prop types and DOM inheritance. Prerequisites: TypeScript, @vueuse/core, understanding of Vue prop validation. Inputs: Prop definitions (e.g., msg: String, enable: Boolean). Outputs: Custom prop-handling reusable templates. Limitation: Only applies if customization of attribute inheritance or typing is required.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate({\n  props: {\n    msg: String,\n    enable: Boolean,\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Meridiem with useDateFormat\nDESCRIPTION: Demonstrates how to create a custom meridiem function for useDateFormat to support custom AM/PM formatting in different languages. The example shows Greek meridiem formatting with different cases and period options.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useDateFormat/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useDateFormat } from '@vueuse/core'\n\nfunction customMeridiem(hours: number, minutes: number, isLowercase?: boolean, hasPeriod?: boolean) {\n  const m = hours > 11 ? (isLowercase ? 'ŒºŒº' : 'ŒúŒú') : (isLowercase ? 'œÄŒº' : 'Œ†Œú')\n  return hasPeriod ? m.split('').reduce((acc, current) => acc += `${current}.`, '') : m\n}\n\nconst am = useDateFormat('2022-01-01 05:05:05', 'hh:mm:ss A', { customMeridiem })\n// am.value = '05:05:05 Œ†Œú'\nconst pm = useDateFormat('2022-01-01 17:05:05', 'hh:mm:ss AA', { customMeridiem })\n// pm.value = '05:05:05 Œú.Œú.'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Projecting Numeric Values with useProjection in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates the use of the useProjection composable from @vueuse/math in a Vue 3 (Composition API) setup using TypeScript. It projects a reactive input value from the domain [0, 10] to a new range [0, 100], updating the projected value whenever the input changes. Requires installation of @vueuse/core, @vueuse/math, and the use of ref from Vue for reactivity. Parameters:\n- input: a ref holding the numeric value to project\n- [0, 10]: source domain range\n- [0, 100]: target domain range. The output is a projected ref; ensure the ranges are valid, and the input remains within the domain for meaningful results.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useProjection/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useProjection } from '@vueuse/math'\n\nconst input = ref(0)\nconst projected = useProjection(input, [0, 10], [0, 100])\n\ninput.value = 5 // projected.value === 50\ninput.value = 10 // projected.value === 100\n```\n\n----------------------------------------\n\nTITLE: Reactive Minimum Calculation Using VueUse's useMin in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useMin function from '@vueuse/math' to compute a reactive minimum value from an array of refs. The useMin function takes reactive references and returns a ref containing the minimum value, suitable for reactive UI updates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useMin/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMin } from '@vueuse/math'\n\nconst array = ref([1, 2, 3, 4])\nconst min = useMin(array) // Ref<1>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useThrottleFn (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import and use the `useThrottleFn` composable from `@vueuse/core`. It creates a throttled version of a function that will execute at most once per 1000ms (1 second). The example shows attaching this throttled function as an event listener to the window's resize event using `useEventListener`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useThrottleFn/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { useThrottleFn } from '@vueuse/core'\n\nconst throttledFn = useThrottleFn(() => {\n  // do something, it will be called at most 1 time per second\n}, 1000)\n\nuseEventListener(window, 'resize', throttledFn)\n```\n\n----------------------------------------\n\nTITLE: Creating Deep and Shallow Refs with Vueuse and TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `createRef` function, which returns a deep or shallow ref depending on the 'deep' parameter. It imports `createRef` from '@vueuse/core' and `isShallow` and `ref` from 'vue'.  It initializes two refs, one shallow and one deep, and shows how to determine if a ref is shallow using `isShallow`.  The `initialData` variable is used as the initial value for the refs. The output of `isShallow` will be different for `shallowData` and `deepData`.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createRef/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\nimport { createRef } from '@vueuse/core'\nimport { isShallow, ref } from 'vue'\n\nconst initialData = 1\n\nconst shallowData = createRef(initialData)\nconst deepData = createRef(initialData, true)\n\nisShallow(shallowData) // true\nisShallow(deepData) // false\n```\n```\n\n----------------------------------------\n\nTITLE: Reusing Firestore DB References - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to reuse the Firestore database reference by passing `autoDispose: false` or `autoDispose` with a specific time frame to `useFirestore`. This helps in avoiding unnecessary Firestore reads when the reference is required again. It depends on the Firebase and Vue libraries and demonstrates how to manage the lifecycle of the Firestore DB connection.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useFirestore/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\nconst todos = useFirestore(collection(db, 'todos'), undefined, { autoDispose: false })\n```\n```\n\n----------------------------------------\n\nTITLE: Exploring Boolean Prop Handling in Reusable Templates (Vue + TypeScript)\nDESCRIPTION: Clarifies the caveat that boolean props provided to ReuseTemplate without v-bind (or when absent) are interpreted differently than native Vue: they become empty strings or undefined, not true/false. Demonstrates various cases of passing a boolean-type prop. Prerequisites: Vue 3, @vueuse/core, TypeScript. Inputs: Boolean-type prop 'value' passed in multiple formats (as true, false, present, or absent). Outputs: Rendered type and value info in template. Limitation: Does not mimic native Vue boolean prop behavior exactly.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createReusableTemplate/index.md#_snippet_9\n\nLANGUAGE: vue\nCODE:\n```\n<script setup lang=\"ts\">\nimport { createReusableTemplate } from '@vueuse/core'\n\nconst [DefineTemplate, ReuseTemplate] = createReusableTemplate<{\n  value?: boolean\n}>()\n</script>\n\n<template>\n  <DefineTemplate v-slot=\"{ value }\">\n    {{ typeof value }}: {{ value }}\n  </DefineTemplate>\n\n  <ReuseTemplate :value=\"true\" />\n  <!-- boolean: true -->\n\n  <ReuseTemplate :value=\"false\" />\n  <!-- boolean: false -->\n\n  <ReuseTemplate value />\n  <!-- string: -->\n\n  <ReuseTemplate />\n  <!-- undefined: -->\n</template>\n```\n\n----------------------------------------\n\nTITLE: Managing side-effects with effectScope in Vue 3\nDESCRIPTION: Demonstrates grouping composables within an effectScope for collective disposal, ensuring all side-effects are cleaned when scope.stop() is called.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/best-practice.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { effectScope } from 'vue'\n\nconst scope = effectScope()\n\nscope.run(() => {\n  // ...\n\n  useEventListener('mousemove', () => {})\n  onClickOutside(el, () => {})\n  watch(source, () => {})\n})\n\n// all composables called inside `scope.run` will be disposed\nscope.stop()\n```\n\n----------------------------------------\n\nTITLE: Accessing Template Promise Arguments in Vue Templates\nDESCRIPTION: Demonstrates how to access arguments that were passed to the template promise within the template slot, enabling dynamic content rendering.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_4\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <TemplatePromise v-slot=\"{ args, resolve }\">\n    <div>{{ args[0] }}</div>\n    <!-- hello -->\n    <div>{{ args[1] }}</div>\n    <!-- 123 -->\n    <button @click=\"resolve(true)\">\n      OK\n    </button>\n  </TemplatePromise>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useRTDB with autoDispose option in TypeScript\nDESCRIPTION: Example demonstrating how to use the useRTDB hook with the autoDispose option set to false, which prevents automatic cleanup of database listeners when the component is unmounted.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/firebase/useRTDB/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst todos = useRTDB(db.ref('todos'), { autoDispose: false })\n```\n\n----------------------------------------\n\nTITLE: Using useSubject with custom error handling\nDESCRIPTION: Shows how to use useSubject with custom error handling. The onError configuration allows capturing and handling errors from the Subject instead of letting them become unhandled exceptions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useSubject/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useSubject } from '@vueuse/rxjs'\nimport { Subject } from 'rxjs'\n\nconst subject = new Subject()\n\n// setup()\nconst subjectRef = useSubject(subject, {\n  onError: (err) => {\n    console.log(err.message) // \"oops\"\n  },\n},)\n```\n\n----------------------------------------\n\nTITLE: Importing and Using usePreferredContrast Composable in JavaScript\nDESCRIPTION: This snippet demonstrates how to import the `usePreferredContrast` function from `@vueuse/core` and call it to create a reactive variable (`preferredContrast`) that reflects the user's preferred contrast setting (e.g., 'no-preference', 'more', 'less'). This is typically used within a Vue component's setup function or script setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePreferredContrast/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { usePreferredContrast } from '@vueuse/core'\n\nconst preferredContrast = usePreferredContrast()\n```\n\n----------------------------------------\n\nTITLE: Initializing Web Animation with useAnimate (Vue 3 Script Setup)\nDESCRIPTION: Shows how to use the `useAnimate` composable within a Vue 3 `<script setup>` component to apply a Web Animation to a referenced DOM element. It demonstrates importing the function, creating a template reference, and calling `useAnimate` with the target element, keyframes, and duration. The destructured result provides properties for animation state and control methods.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useAnimate/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useAnimate } from '@vueuse/core'\nimport { useTemplateRef } from 'vue'\n\nconst el = useTemplateRef('el')\nconst {\n  isSupported,\n  animate,\n\n  // actions\n  play,\n  pause,\n  reverse,\n  finish,\n  cancel,\n\n  // states\n  pending,\n  playState,\n  replaceState,\n  startTime,\n  currentTime,\n  timeline,\n  playbackRate,\n} = useAnimate(el, { transform: 'rotate(360deg)' }, 1000)\n</script>\n\n<template>\n  <span ref=\"el\" style=\"display:inline-block\">useAnimate</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Importing useFileSystemAccess in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the `useFileSystemAccess` function from the `@vueuse/core` module. This function provides access to the File System Access API, allowing for operations like file creation, opening, and saving.  The imported object contains reactive properties and methods to interact with files.  It is crucial to have the VueUse library installed and configured for this to work.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFileSystemAccess/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useFileSystemAccess } from '@vueuse/core'\n\nconst { isSupported, data, file, fileName, fileMIME, fileSize, fileLastModified, create, open, save, saveAs, updateData } = useFileSystemAccess()\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum of a Reactive Array Using @vueuse/math in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useSum function to obtain the reactive sum of an array wrapped in a Vue ref. It requires the @vueuse/math package and Vue's ref API. The input is a reactive array of numbers, and the output is a reactive Ref containing the computed sum, which updates automatically as the array changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useSum/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useSum } from '@vueuse/math'\n\nconst array = ref([1, 2, 3, 4])\nconst sum = useSum(array) // Ref<10>\n```\n\n----------------------------------------\n\nTITLE: Using useDocumentVisibility in Vue Component Template\nDESCRIPTION: This Vue template snippet demonstrates how to utilize the <UseDocumentVisibility> component with a scoped slot to display the current document visibility status reactively. It enables component-based visibility tracking within Vue templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDocumentVisibility/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseDocumentVisibility v-slot=\"{ visibility }\">\n    Document Visibility: {{ visibility }}\n  </UseDocumentVisibility>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Generating QR Codes in VueUse\nDESCRIPTION: Provides functionality to generate QR codes from data, supporting visual encoding for sharing or scanning.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility to generate QR codes from data strings for display and sharing within Vue components. */\n```\n\n----------------------------------------\n\nTITLE: Using usePointer as a Vue Component with Window Targeting\nDESCRIPTION: This Vue component example showcases the use of `usePointer` within a Vue template via a slot. It accesses the reactive `x` and `y` properties provided by the `usePointer` composable. By default, the component tracks pointer events on the `window`. No specific props need to be passed to target the window.  The component's render function is expected to update whenever the pointer moves. It renders the x and y coordinates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointer/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePointer v-slot=\"{ x, y }\">\n    x: {{ x }}\n    y: {{ y }}\n  </UsePointer>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using useCloned with Default JSON Clone in VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to utilize the useCloned function from VueUse with its default JSON-based cloning method. It creates a reactive clone of an object and shows that modifications to the original do not affect the clone unless explicitly synchronized.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useCloned/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useCloned } from '@vueuse/core'\n\nconst original = ref({ key: 'value' })\n\nconst { cloned } = useCloned(original)\n\noriginal.value.key = 'some new value'\n\nconsole.log(cloned.value.key) // 'value'\n```\n\n----------------------------------------\n\nTITLE: Using useLastChanged with immediate recording (flush: 'sync') in Vue 3 with TypeScript\nDESCRIPTION: Shows how to configure useLastChanged to record the change timestamp immediately by passing the flush option with 'sync'. This enables capturing the timestamp at the exact moment of value change, instead of after the next tick.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useLastChanged/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useLastChanged } from '@vueuse/core'\n\nconst a = ref(0)\nconst lastChanged = useLastChanged(a, { flush: 'sync' })\n\na.value = 1\n\nconsole.log(lastChanged.value) // 1704709379457\n```\n\n----------------------------------------\n\nTITLE: Using onKeyStroke with Custom Event Target\nDESCRIPTION: Illustrates how to specify a custom event target, such as 'document', for listening to key events. This allows configuring the context from which keyboard events are captured. Implementation involves passing an options object with the 'target' property.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/onKeyStroke/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nonKeyStroke('A', (e) => {\n  console.log('Key A pressed on document')\n}, { target: document })\n```\n\n----------------------------------------\n\nTITLE: Configuring onChanged Option\nDESCRIPTION: This snippet illustrates the use of the `onChanged` option, which functions similarly to Vue's `watch` but provides lower overhead. The `onChanged` option allows performing side effects when the ref value changes in a synchronized manner.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refWithControl/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst num = refWithControl(0, {\n  onChanged(value, oldValue) {\n    console.log(value)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Single Refs with syncRefs in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of `syncRefs` to synchronize a single target ref with a single source ref. When the source ref's value changes, the target ref is automatically updated to match it.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/syncRefs/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { syncRefs } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst source = shallowRef('hello')\nconst target = shallowRef('target')\n\nconst stop = syncRefs(source, target)\n\nconsole.log(target.value) // hello\n\nsource.value = 'foo'\n\nconsole.log(target.value) // foo\n```\n\n----------------------------------------\n\nTITLE: Reading Battery Level from Bluetooth Device with VueUse in TypeScript\nDESCRIPTION: Provides an asynchronous function to access a device's battery service, read the battery level characteristic, and set up an event listener for characteristic value changes. It manages reactive state for battery percentage and uses pausableWatch to trigger data retrieval upon connection, ensuring updates are handled efficiently.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBluetooth/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { pausableWatch, useBluetooth, useEventListener } = '@vueuse/core'\n\nconst {\n  isSupported,\n  isConnected,\n  device,\n  requestDevice,\n  server,\n} = useBluetooth({\n  acceptAllDevices: true,\n  optionalServices: [\n    'battery_service',\n  ],\n})\n\nconst batteryPercent = ref<undefined | number>()\n\nconst isGettingBatteryLevels = ref(false)\n\nasync function getBatteryLevels() {\n  isGettingBatteryLevels.value = true\n\n  // Get the battery service:\n  const batteryService = await server.getPrimaryService('battery_service')\n\n  // Get the current battery level\n  const batteryLevelCharacteristic = await batteryService.getCharacteristic(\n    'battery_level',\n  )\n\n  // Listen to when characteristic value changes on `characteristicvaluechanged` event:\n  useEventListener(batteryLevelCharacteristic, 'characteristicvaluechanged', (event) => {\n    batteryPercent.value = event.target.value.getUint8(0)\n  }, { passive: true })\n\n  // Convert received buffer to number:\n  const batteryLevel = await batteryLevelCharacteristic.readValue()\n\n  batteryPercent.value = await batteryLevel.getUint8(0)\n}\n\nconst { stop } = pausableWatch(isConnected, (newIsConnected) => {\n  if (!newIsConnected || !server.value || isGettingBatteryLevels.value)\n    return\n  // Attempt to get the battery levels of the device:\n  getBatteryLevels()\n  // We only want to run this on the initial connection, as we will use an event listener to handle updates:\n  stop()\n})\n```\n\n----------------------------------------\n\nTITLE: useAxios replacing URL with execute\nDESCRIPTION: Illustrates that the `execute` function `url` is optional, and `url2` will replace the `url1` when calling execute.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAxios } from '@vueuse/integrations/useAxios'\n\nconst { execute } = useAxios(url1, {}, { immediate: false })\nexecute(url2)\n```\n\n----------------------------------------\n\nTITLE: Component Usage with UsePointerLock - Vue\nDESCRIPTION: Demonstrates the component usage of the `usePointerLock` composable within a Vue template. It utilizes the `UsePointerLock` component and its associated slot props to control the pointer lock state of a canvas element through a button click. The `lock` function provided by the slot is used to request pointer lock on the canvas.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/usePointerLock/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UsePointerLock v-slot=\"{ lock }\">\n    <canvas />\n    <button @click=\"lock\">\n      Lock Pointer on Canvas\n    </button>\n  </UsePointerLock>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Integrating useClipboardItems into a Vue Component\nDESCRIPTION: This Vue.js component integrates with the `useClipboardItems` composable to provide a user interface for copying text. It uses the `content`, `copy`, `copied`, and `isSupported` values returned by `useClipboardItems` to control the UI.  The template displays a button that triggers the `copy` function and indicates whether the content has been copied. It depends on the `useClipboardItems` function and the setup defined in the JavaScript snippet.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useClipboardItems/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <div v-if=\"isSupported\">\n    <button @click=\"copy(source)\">\n      <!-- by default, `copied` will be reset in 1.5s -->\n      <span v-if=\"!copied\">Copy</span>\n      <span v-else>Copied!</span>\n    </button>\n    <p>\n      Current copied: <code>{{ content || 'none' }}</code>\n    </p>\n  </div>\n  <p v-else>\n    Your browser does not support Clipboard API\n  </p>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Setting SSR Width with createApp in JavaScript\nDESCRIPTION: Demonstrates how to provide a global SSR viewport width at the application level using provideSSRWidth with the createApp instance. This setup configures a width of 500 pixels that will be used by SSR-dependent components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useSSRWidth/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { provideSSRWidth } from '@vueuse/core'\n\nconst app = createApp(App)\n\nprovideSSRWidth(500, app)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to an RxJS Interval Observable in Vue with useObservable - TypeScript\nDESCRIPTION: Demonstrates using useObservable from @vueuse/rxjs to subscribe to an RxJS interval Observable, which emits incremented values over time. Requires installing @vueuse/rxjs and rxjs. The Observable is piped through operators such as mapTo, startWith, and scan to accumulate values, and is safely unsubscribed upon component unmount. Returns a Vue ref with the current value stream.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/useObservable/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useObservable } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { mapTo, scan, startWith } from 'rxjs/operators'\n\n// setup()\nconst count = useObservable(\n  interval(1000).pipe(\n    mapTo(1),\n    startWith(0),\n    scan((total, next) => next + total),\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring VueUse in Nuxt 3\nDESCRIPTION: Configuration snippet for integrating VueUse with Nuxt 3 by adding it to the modules array in the Nuxt config file.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  modules: [\n    '@vueuse/nuxt',\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring VueUse in nuxt.config file\nDESCRIPTION: Demonstrates how to configure a Nuxt application to use the VueUse module by adding it to the modules array in the Nuxt configuration file.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/nuxt/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// nuxt.config\nexport default defineNuxtConfig({\n  modules: [\n    '@vueuse/nuxt',\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useEventBus in TypeScript\nDESCRIPTION: Demonstrates how to create an event bus, register a listener, emit an event, and handle cleanup. Listeners registered in component setup are automatically unregistered when the component unmounts.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useEventBus/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEventBus } from '@vueuse/core'\n\nconst bus = useEventBus<string>('news')\n\nfunction listener(event: string) {\n  console.log(`news: ${event}`)\n}\n\n// listen to an event\nconst unsubscribe = bus.on(listener)\n\n// fire an event\nbus.emit('The Tokyo Olympics has begun')\n\n// unregister the listener\nunsubscribe()\n// or\nbus.off(listener)\n\n// clearing all listeners\nbus.reset()\n```\n\n----------------------------------------\n\nTITLE: Installing Playwright Browser Dependencies - Bash\nDESCRIPTION: Installs the required browser binaries and dependencies for Playwright to enable browser-based testing. This setup is necessary before running browser tests. It requires the Playwright CLI to be available. The '--with-deps' flag ensures all necessary OS-level dependencies are installed alongside browser binaries.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnlx playwright install --with-deps\n```\n\n----------------------------------------\n\nTITLE: Configuring NProgress Options with useNProgress - JavaScript\nDESCRIPTION: Shows passing a configuration object as the second argument to useNProgress, allowing customization of NProgress settings such as minimum progress value. This snippet assumes familiarity with NProgress's configuration options and enables fine-tuning the progress bar behavior.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useNProgress/index.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { useNProgress } from '@vueuse/integrations/useNProgress'\n\nuseNProgress(null, {\n  minimum: 0.1,\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Using Math.floor reactively with useFloor in Vue applications\nDESCRIPTION: Demonstrates how to import and use the useFloor function from the VueUse math module to create a reactive floor value. The function takes a reactive value as input and returns a computed value that automatically updates when the source changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/useFloor/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useFloor } from '@vueuse/math'\n\nconst value = ref(45.95)\nconst result = useFloor(value) // 45\n```\n\n----------------------------------------\n\nTITLE: Using useDeviceMotion in Vue Component\nDESCRIPTION: This Vue component example demonstrates how to use the `useDeviceMotion` composable within a Vue template. It uses the `UseDeviceMotion` component (presumably custom) and displays the acceleration data. This component's purpose is to visualize or use the device motion data retrieved by `useDeviceMotion`. The output would be the acceleration object's string representation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useDeviceMotion/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<template>\n  <UseDeviceMotion v-slot=\"{ acceleration }\">\n    Acceleration: {{ acceleration }}\n  </UseDeviceMotion>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Basic useTimeout Usage - JavaScript\nDESCRIPTION: Initializes a reactive `ready` variable that becomes `true` after 1000ms. This snippet demonstrates the simplest way to use `useTimeout` to trigger a reactive update after a specified delay. It requires importing `useTimeout` from `@vueuse/core`. The `ready` variable is a `Ref<boolean>` that is initially `false` and becomes `true` after the timeout.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useTimeout/index.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useTimeout } from '@vueuse/core'\n\nconst ready = useTimeout(1000)\n```\n\n----------------------------------------\n\nTITLE: Using useChangeCase to transform strings (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the basic usage of `useChangeCase`. It imports the function, calls it with a string and the desired casing style ('camelCase'), and illustrates how the computed value updates reactively when the input string changes. It requires the `@vueuse/integrations/useChangeCase` import and `change-case` library.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useChangeCase/index.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { useChangeCase } from '@vueuse/integrations/useChangeCase'\n\n// `changeCase` will be a computed\nconst changeCase = useChangeCase('hello world', 'camelCase')\nchangeCase.value // helloWorld\nchangeCase.value = 'vue use'\nchangeCase.value // vueUse\n// Supported methods\n// export {\n//   camelCase,\n//   capitalCase,\n//   constantCase,\n//   dotCase,\n//   headerCase,\n//   noCase,\n//   paramCase,\n//   pascalCase,\n//   pathCase,\n//   sentenceCase,\n//   snakeCase,\n// } from 'change-case'\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Core and Components Packages using npm (bash)\nDESCRIPTION: This snippet demonstrates the installation command for both the @vueuse/core and @vueuse/components packages using npm. It is a prerequisite step before using composable functions and renderless components from the VueUse ecosystem.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/components.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/core @vueuse/components\n```\n\n----------------------------------------\n\nTITLE: Implementing Toggle State in VueUse\nDESCRIPTION: Offers a reactive boolean toggle that can be switched on and off, ideal for controlling visibility or modes in Vue components. Depends on Vue's reactivity system.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactive boolean toggle with functions to switch state on and off. Useful for toggling visibility or modes within Vue components. */\n```\n\n----------------------------------------\n\nTITLE: Binding Template Refs in Vue Options API using VueUse and TypeScript\nDESCRIPTION: This snippet demonstrates usage of the VueUse library's templateRef function within a Vue Options API component written in TypeScript. It shows how to create a reactive reference identified by a string key, which binds automatically to the template element with the corresponding ref attribute, eliminating the need to manually return the ref. The snippet requires Vue and @vueuse/core packages and expects the ref key ('target') to match both script and template refs.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/templateRef/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script lang=\"ts\">\nimport { templateRef } from '@vueuse/core'\n\nexport default {\n  setup() {\n    const target = templateRef('target')\n\n    // no need to return the `target`, it will bind to the ref magically\n  },\n}\n</script>\n\n<template>\n  <div ref=\"target\" />\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using shallowRef for Performance Optimization\nDESCRIPTION: This snippet demonstrates the use of `shallowRef` to prevent deep reactivity when dealing with large amounts of data, enhancing performance. The code shows how to use `shallowRef` in the context of a `useFetch` composable function to store fetched data and errors.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function useFetch<T>(url: MaybeRefOrGetter<string>) {\n  // use `shallowRef` to prevent deep reactivity\n  const data = shallowRef<T | undefined>()\n  const error = shallowRef<Error | undefined>()\n\n  fetch(toValue(url))\n    .then(r => r.json())\n    .then(r => data.value = r)\n    .catch(e => error.value = e)\n\n  /* ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Basic useFocusTrap Usage (Vue/TypeScript)\nDESCRIPTION: Demonstrates the basic usage of the `useFocusTrap` composable with a single target element. It shows how to activate and deactivate the trap and check its active state.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst { hasFocus, activate, deactivate } = useFocusTrap(target)\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div>\n    <button @click=\"activate()\">\n      Activate\n    </button>\n    <div ref=\"target\">\n      <span>Has Focus: {{ hasFocus }}</span>\n      <input type=\"text\">\n      <button @click=\"deactivate()\">\n        Deactivate\n      </button>\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Delaying Initial Fetch Request (VueUse TypeScript)\nDESCRIPTION: Prevents the fetch request from firing immediately when `useFetch` is called by setting the `immediate` option to `false`. The request must then be manually initiated by calling the returned `execute` function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFetch/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst { execute } = useFetch(url, { immediate: false })\n\nexecute()\n```\n\n----------------------------------------\n\nTITLE: Using useRouteHash for reactive hash in Vue.js (TypeScript)\nDESCRIPTION: The `useRouteHash` function provides a reactive reference to the current route's hash.  It requires the `@vueuse/router` package.  The code retrieves the current `route.hash` value and sets it to 'foobar', which updates the current route.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteHash/index.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { useRouteHash } from '@vueuse/router'\n\nconst search = useRouteHash()\n\nconsole.log(search.value) // route.hash\nsearch.value = 'foobar' // router.replace({ hash: 'foobar' })\n```\n\n----------------------------------------\n\nTITLE: Hyphenate Strings in VueUse\nDESCRIPTION: Converts camelCase strings to hyphen-separated case, useful for CSS class or HTML attribute formatting within Vue templates.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Transforms camelCase strings into hyphen-separated format for CSS and HTML consistency in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Using Unique Array in VueUse\nDESCRIPTION: Creates a reactive array that maintains a list of unique items, preventing duplicates. Useful for managing collections where uniqueness is required, such as tags or selected items.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactive array ensuring all elements are unique. Depends on Vue reactivity system. Useful for managing collections like tags or selected items in Vue applications. */\n```\n\n----------------------------------------\n\nTITLE: Converting Ref to Observer using toObserver - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `toObserver` function.  It takes an RxJS Observable and subscribes to it, using `toObserver` to update a `shallowRef` named `count`. Dependencies include `@vueuse/rxjs`, `rxjs`, and Vue's reactivity utilities. The `toObserver` function acts as a shortcut for directly assigning values from the Observable to the ref.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/toObserver/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { from, fromEvent, toObserver, useSubscription } from '@vueuse/rxjs'\nimport { interval } from 'rxjs'\nimport { map, mapTo, startWith, takeUntil, withLatestFrom } from 'rxjs/operators'\nimport { shallowRef } from 'vue'\n\nconst count = shallowRef(0)\nconst button = shallowRef<HTMLButtonElement | null>(null)\n\nuseSubscription(\n  interval(1000)\n    .pipe(\n      mapTo(1),\n      takeUntil(fromEvent(button, 'click')),\n      withLatestFrom(from(count).pipe(startWith(0))),\n      map(([curr, total]) => curr + total),\n    )\n    .subscribe(toObserver(count)), // same as ).subscribe(val => (count.value = val))\n)\n```\n\n----------------------------------------\n\nTITLE: Using useRouteQuery with default value for 'search' parameter\nDESCRIPTION: This snippet illustrates how to initialize the 'search' query parameter with a default value ('foo') if it is not present in the URL. It enables setting a fallback value for reactive binding.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/router/useRouteQuery/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst search = useRouteQuery('search', 'foo')\n```\n\n----------------------------------------\n\nTITLE: Installing Dependency with npm (Bash)\nDESCRIPTION: This command installs the `jwt-decode` library using npm, specifying version 4 or later. This dependency is required for the `useJwt` VueUse integration to function correctly by providing the underlying JWT decoding capabilities. It is executed in a terminal.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useJwt/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jwt-decode@^4\n```\n\n----------------------------------------\n\nTITLE: Installing NProgress via npm - Bash\nDESCRIPTION: This snippet shows the bash command to install NProgress, a lightweight progress bar library, using npm. It is a prerequisite to use the useNProgress wrapper in JavaScript projects.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useNProgress/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i nprogress@^0\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse in Nuxt using npm\nDESCRIPTION: Shows how to install the VueUse module in a Nuxt application using npm. This method requires installing both the Nuxt integration package and the core VueUse package.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/nuxt/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/nuxt @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: Converting Value to Number in VueUse\nDESCRIPTION: Provides a reactive or computed value that converts its input to a number, handling parsing and defaulting, useful for form inputs or numeric computations in Vue.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Converts reactive or static input to a number, providing reactive updates and default handling for form inputs or numeric data in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Reactive ipcRenderer.invoke usage in Vue with VueUse Electron\nDESCRIPTION: This snippet showcases how to import and use the useIpcRendererInvoke function to perform asynchronous IPC calls in a Vue component, making the results reactive using Vue's computed properties. It highlights dependencies on @vueuse/electron, Vue, and Electron's ipcRenderer, and demonstrates handling data with specified channel and arguments.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useIpcRendererInvoke/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useIpcRendererInvoke } from '@vueuse/electron'\nimport { computed } from 'vue'\n\n// enable nodeIntegration if you don't provide ipcRenderer explicitly\n// @see: https://www.electronjs.org/docs/api/webview-tag#nodeintegration\n// Ref result will return\nconst result = useIpcRendererInvoke<string>('custom-channel', 'some data')\nconst msg = computed(() => result.value?.msg)\n```\n\n----------------------------------------\n\nTITLE: Verifying useTimeout functionality - JavaScript\nDESCRIPTION: Illustrates the use of `promiseTimeout` to simulate waiting for the `useTimeout` to complete and verifying the `ready` variable's state before and after the timeout. This snippet tests the behavior of the basic `useTimeout`. It also requires importing `promiseTimeout` from `@vueuse/core`. The `promiseTimeout` function pauses execution for the specified time in milliseconds.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/useTimeout/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { promiseTimeout } from '@vueuse/core'\n\nconsole.log(ready.value) // false\n\nawait promiseTimeout(1200)\n\nconsole.log(ready.value) // true\n```\n\n----------------------------------------\n\nTITLE: Using Shorthands for Getting/Setting Values\nDESCRIPTION: This snippet shows the equivalent shorthands available for getting and setting ref values without triggering reactivity. It illustrates how `get`, `untrackedGet`, `peek`, `set`, `silentSet`, and `lay` can be used to achieve the same result.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/refWithControl/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst foo = refWithControl('foo')\n\n// getting\nfoo.get(false)\nfoo.untrackedGet()\nfoo.peek() // an alias for `untrackedGet`\n\n// setting\nfoo.set('bar', false)\nfoo.silentSet('bar')\nfoo.lay('bar') // an alias for `silentSet`\n```\n\n----------------------------------------\n\nTITLE: Providing Counter Store in Root Vue Component\nDESCRIPTION: Shows how to provide the counter store at the root component level using the useProvideCounterStore function with an initial value of 0.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<!-- RootComponent.vue -->\n<script setup lang=\"ts\">\nimport { useProvideCounterStore } from './useCounterStore'\n\nuseProvideCounterStore(0)\n</script>\n\n<template>\n  <div>\n    <slot />\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: JWT Handling in VueUse\nDESCRIPTION: Includes utilities for managing JSON Web Tokens (JWT), supporting authentication flows and token management in Vue apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_43\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utilities for encoding, decoding, and managing JWT tokens within Vue applications for auth flows. */\n```\n\n----------------------------------------\n\nTITLE: Installing Axios Dependency\nDESCRIPTION: This command installs Axios version 1 or higher as a dependency for the VueUse useAxios integration. Axios is a promise-based HTTP client for making requests from the browser or Node.js.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useAxios/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i axios@^1\n```\n\n----------------------------------------\n\nTITLE: Using Route Query in VueUse Router\nDESCRIPTION: Provides reactive access to query parameters from Vue Router, enabling dynamic component behavior based on URL queries.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Accesses query string parameters reactively within Vue Router for dynamic component adjustments. */\n```\n\n----------------------------------------\n\nTITLE: Setting SSR Handler in VueUse\nDESCRIPTION: Defines a handler for server-side rendering (SSR) scenarios, enabling custom SSR behavior or fallback mechanisms within Vue apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Registers a handler for server-side rendering processes, enabling custom SSR logic in Vue applications. */\n```\n\n----------------------------------------\n\nTITLE: Create Cookies Utility in VueUse\nDESCRIPTION: Allows creation and management of cookies within Vue apps, handling cookie setting, reading, and deletion with ease.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility for creating, reading, and deleting cookies in Vue applications for persistent client-side storage. */\n```\n\n----------------------------------------\n\nTITLE: Enabling Lazy Evaluation in computedAsync for Vue (JavaScript)\nDESCRIPTION: Explains how to configure computedAsync for lazy evaluation, making it defer execution until the first access rather than running immediately. Accepts an options object with lazy: true and a custom evaluating ref. Dependencies: @vueuse/core, vue. Parameters: lazy (boolean), evaluating (ref), async function, initial state. Input: accessing the computed value triggers evaluation. Output: async value after first retrieval attempt.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/computedAsync/index.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { computedAsync } from '@vueuse/core'\nimport { shallowRef } from 'vue'\n\nconst evaluating = shallowRef(false)\n\nconst userInfo = computedAsync(\n  async () => { /* your logic */ },\n  null,\n  { lazy: true, evaluating },\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Subject in VueUse RxJS\nDESCRIPTION: Provides a reactive subject that acts both as an observable and observer, enabling multicasting and event broadcasting in Vue.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_47\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Creates a subject for multicasting events or data streams within Vue components using RxJS. */\n```\n\n----------------------------------------\n\nTITLE: Reactify Functions in VueUse\nDESCRIPTION: Converts normal functions into reactive counterparts that respond to reactive data changes, enabling reactive computations within Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Transforms standard functions into reactive functions that respond to reactive data changes for dynamic updates in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Async Validator Utilities in VueUse\nDESCRIPTION: Supports asynchronous validation logic for forms or data pipelines, ensuring validation is performed asynchronously with reactive feedback.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Asynchronous validation utilities for form validation and data validation workflows in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Use Nuxt Default Module in VueUse\nDESCRIPTION: Includes the VueUse default module for Nuxt.js projects, providing integrated access to VueUse functionalities within Nuxt apps.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Integrates VueUse default features in Nuxt.js projects, enabling seamless composition API utilities. */\n```\n\n----------------------------------------\n\nTITLE: Extracted Observable in VueUse RxJS\nDESCRIPTION: Creates an extracted observable from a source observable, enabling reactive data streams in Vue components using RxJS.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_45\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Creates a derived or filtered observable from a source stream for reactive data handling in Vue with RxJS. */\n```\n\n----------------------------------------\n\nTITLE: Using reactifyObject with console in TypeScript\nDESCRIPTION: Example showing how to use reactifyObject to create a reactive version of the console object, allowing direct use of refs in console methods without accessing their .value property.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/reactifyObject/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { reactifyObject } from '@vueuse/core'\n\nconst reactifiedConsole = reactifyObject(console)\n\nconst a = ref('42')\n\nreactifiedConsole.log(a) // no longer need `.value`\n```\n\n----------------------------------------\n\nTITLE: Configuring VueUse in Nuxt 2\nDESCRIPTION: Configuration snippet for integrating VueUse with Nuxt 2 by adding it to the buildModules array in the Nuxt config file.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// nuxt.config.js\nexport default {\n  buildModules: [\n    '@vueuse/nuxt',\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Installing focus-trap Dependency (Bash)\nDESCRIPTION: Installs the required `focus-trap` library dependency using npm, specifying version 7 or higher.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i focus-trap@^7\n```\n\n----------------------------------------\n\nTITLE: Implementing useConfirmDialog with Hooks in Vue\nDESCRIPTION: This Vue.js snippet demonstrates the basic usage of the `useConfirmDialog` composable, utilizing hooks for managing modal interactions. It involves importing the composable, setting up the necessary data, and defining methods to reveal, confirm, and cancel the dialog. The template utilizes `v-if` and `@click` directives to render the modal and handle user interactions.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useConfirmDialog/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useConfirmDialog } from '@vueuse/core'\n\nconst { isRevealed, reveal, confirm, cancel, onReveal, onConfirm, onCancel }\n    = useConfirmDialog()\n</script>\n\n<template>\n  <button @click=\"reveal\">\n    Reveal Modal\n  </button>\n\n  <teleport to=\"body\">\n    <div v-if=\"isRevealed\" class=\"modal-bg\">\n      <div class=\"modal\">\n        <h2>Confirm?</h2>\n        <button @click=\"confirm\">\n          Yes\n        </button>\n        <button @click=\"cancel\">\n          Cancel\n        </button>\n      </div>\n    </div>\n  </teleport>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating TypeScript-typed Template Promises in Vue 3\nDESCRIPTION: Shows how to initialize createTemplatePromise with TypeScript typing to ensure type safety when using promises in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/createTemplatePromise/index.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTemplatePromise } from '@vueuse/core'\n\nconst TemplatePromise = createTemplatePromise()\nconst MyPromise = createTemplatePromise<boolean>() // with generic type\n```\n\n----------------------------------------\n\nTITLE: Automatically Activating useFocusTrap (Vue/TypeScript)\nDESCRIPTION: Shows how to configure the `useFocusTrap` composable to automatically activate the focus trap as soon as the component or composable is initialized using the `immediate: true` option.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useFocusTrap/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n<script setup lang=\"ts\">\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport { useTemplateRef } from 'vue'\n\nconst target = useTemplateRef<HTMLDivElement>('target')\nconst { hasFocus, activate, deactivate } = useFocusTrap(target, { immediate: true })\n</script>\n```\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <div>\n    <div ref=\"target\">\n      ...\n    </div>\n  </div>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Using Route Hash in VueUse Router\nDESCRIPTION: Provides reactive access to the URL hash fragment in Vue Router, supporting hash-based navigation or deep linking.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactively retrieves the URL hash fragment via Vue Router for hash-based navigation. */\n```\n\n----------------------------------------\n\nTITLE: Implementing Gamepad Vibration\nDESCRIPTION: This TypeScript snippet demonstrates how to implement gamepad vibration using the Gamepad Haptics API. It imports the `computed` function from 'vue'.  It checks for haptic actuator support and plays a dual-rumble effect if supported. Requires Vue and VueUse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGamepad/index.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { computed } from 'vue'\n\nconst supportsVibration = computed(() => gamepad.hapticActuators.length > 0)\nfunction vibrate() {\n  if (supportsVibration.value) {\n    const actuator = gamepad.hapticActuators[0]\n    actuator.playEffect('dual-rumble', {\n      startDelay: 0,\n      duration: 1000,\n      weakMagnitude: 1,\n      strongMagnitude: 1,\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding WebFrame Zoom Factor to a Vue Reactive Ref in JavaScript\nDESCRIPTION: This snippet illustrates passing a Vue shallowRef to useZoomFactor, enabling the zoom level to stay synchronized with the reactive ref. When the ref's value updates, the zoom factor in WebFrame updates correspondingly, facilitating reactive zoom control within Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomFactor/index.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { shallowRef } from 'vue'\\nimport { useZoomFactor } from '@vueuse/electron'\\n\\nconst factor = shallowRef(1)\\n\\nuseZoomFactor(factor) // zoom factor will match with the ref\\n\\nfactor.value = 2 // zoom factor will change\n```\n\n----------------------------------------\n\nTITLE: Defining Target Element for useFullscreen (HTML)\nDESCRIPTION: Declares an HTML `<video>` element within a Vue template. It uses the `ref=\"el\"` attribute to create a template reference, allowing the element to be accessed and manipulated by Vue composition functions like `useTemplateRef` and subsequently `useFullscreen`. This element serves as the target for fullscreen operations.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useFullscreen/index.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<video ref=\"el\"></video>\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Store with Custom Injection Key\nDESCRIPTION: Demonstrates how to use createInjectionState with a custom injection key ('counter-store') instead of the default Symbol-based key for more explicit control over the injection mechanism.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createInjectionState } from '@vueuse/core'\n// useCounterStore.ts\nimport { computed, shallowRef } from 'vue'\n\n// custom injectionKey\nconst CounterStoreKey = 'counter-store'\n\nconst [useProvideCounterStore, useCounterStore] = createInjectionState((initialValue: number) => {\n  // state\n  const count = shallowRef(initialValue)\n\n  // getters\n  const double = computed(() => count.value * 2)\n\n  // actions\n  function increment() {\n    count.value++\n  }\n\n  return { count, double, increment }\n}, { injectionKey: CounterStoreKey })\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse with npm\nDESCRIPTION: This snippet shows how to install the VueUse core package using npm. It specifies the command `npm i @vueuse/core`. This command installs the necessary core functionality of the VueUse library into the project.  After running this command, the VueUse core package can be imported and used in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nnpm i @vueuse/core\n```\n```\n\n----------------------------------------\n\nTITLE: Reducing Arrays in VueUse\nDESCRIPTION: Offers a reactive array reduction utility to compute a single value from an array, supporting accumulated computations like sum or product in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Performs reduction over reactive arrays, computing aggregate values such as sum or concatenation within Vue components. */\n```\n\n----------------------------------------\n\nTITLE: Displaying Battery Charging Status with UseBattery Component in Vue\nDESCRIPTION: Shows how to use the <UseBattery> component in a Vue template to access battery status and display whether the device is charging. Requires Vue and the UseBattery component provided by VueUse. The charging variable is exposed via scoped slot and rendered in the template. The component handles lifecycle and reactivity internally. Intended for single-file components in Vue 2 or Vue 3 applications using the setup script or options API.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBattery/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseBattery v-slot=\"{ charging }\">\n    Is Charging: {{ charging }}\n  </UseBattery>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Drauu Utility in VueUse for Drawing\nDESCRIPTION: Provides drawing and editing capabilities on a canvas or SVG, supporting collaborative drawing features in Vue applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Drawing and editing utility for graphical content in Vue, supporting interactive and collaborative features. */\n```\n\n----------------------------------------\n\nTITLE: Serialization Utilities for Storage in VueUse\nDESCRIPTION: Provides serialization methods for storing complex data structures in storage APIs, such as localStorage or sessionStorage, ensuring data integrity and type preservation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Collection of serializers for storing and retrieving complex objects in storage APIs, managing data format conversion and type safety. */\n```\n\n----------------------------------------\n\nTITLE: Defining Component Options Interface\nDESCRIPTION: Sometimes a function may have multiple parameters, in that case, you maybe need to create a new interface to merge all the interfaces into a single interface for the component props.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guidelines.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { TimeAgoOptions } from '@vueuse/core'\nimport { useTimeAgo } from '@vueuse/core'\n\ninterface UseTimeAgoComponentOptions extends Omit<TimeAgoOptions<true>, 'controls'> {\n  time: MaybeRef<Date | number | string>\n}\n\nexport const UseTimeAgo = defineComponent<UseTimeAgoComponentOptions>({ /* ... */ })\n```\n\n----------------------------------------\n\nTITLE: Initializing WebFrame Zoom Level with VueUse (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the `useZoomLevel` function from the `@vueuse/electron` library to get and set the current zoom level. It imports the `useZoomLevel` function and uses it to create a reactive ref that represents the zoom level. The example includes comments explaining the need to enable `nodeIntegration` if a webFrame is not explicitly provided. This ensures the Electron environment is correctly configured and the zoom level is initialized.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomLevel/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useZoomLevel } from '@vueuse/electron'\n\n// enable nodeIntegration if you don't provide webFrame explicitly\n// @see: https://www.electronjs.org/docs/api/webview-tag#nodeintegration\n// Ref result will return\nconst level = useZoomLevel()\nconsole.log(level.value) // print current zoom level\nlevel.value = 2 // change current zoom level\n```\n\n----------------------------------------\n\nTITLE: Initializing Web Bluetooth with VueUse in TypeScript\nDESCRIPTION: Demonstrates the import and initialization of the useBluetooth hook, acquiring reactive references for device management, including support status, connection state, device instance, request function, and server object. The configuration accepts all devices.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBluetooth/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst {\n  isSupported,\n  isConnected,\n  device,\n  requestDevice,\n  server,\n} = useBluetooth({\n  acceptAllDevices: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Using the Vibration API with a Pattern in Vue\nDESCRIPTION: This snippet demonstrates how to use the useVibrate composable to create a complex vibration pattern. It initializes the vibration with a pattern that alternates between vibration and pause, and shows how to start and stop the vibration programmatically.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useVibrate/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useVibrate } from '@vueuse/core'\n\n// This vibrates the device for 300 ms\n// then pauses for 100 ms before vibrating the device again for another 300 ms:\nconst { vibrate, stop, isSupported } = useVibrate({ pattern: [300, 100, 300] })\n\n// Start the vibration, it will automatically stop when the pattern is complete:\nvibrate()\n\n// But if you want to stop it, you can:\nstop()\n```\n\n----------------------------------------\n\nTITLE: Using useGamepad in Vue\nDESCRIPTION: This Vue snippet demonstrates how to use the `useGamepad` composable to access gamepad data. It imports `useGamepad` and the `computed` function from Vue.  It retrieves gamepad information and displays the ID of the first gamepad found with the 'standard' mapping in a template.  Requires Vue and VueUse/core.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useGamepad/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport { useGamepad } from '@vueuse/core'\nimport { computed } from 'vue'\n\nconst { isSupported, gamepads } = useGamepad()\nconst gamepad = computed(() => gamepads.value.find(g => g.mapping === 'standard'))\n</script>\n\n<template>\n  <span>\n    {{ gamepad.id }}\n  </span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Custom Storage Event Name in VueUse\nDESCRIPTION: Defines a custom event name for storage-related events, enabling applications to listen and respond to storage changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Sets a custom event name for storage events, facilitating cross-tab communication or storage change detection in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Reactive Numeric Projection with createProjection (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `createProjection` function from `@vueuse/math` to create a reactive numeric projection. It defines an input range and an output range, then projects a reactive input value from the input range to the output range. The projected value updates automatically when the input value changes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/math/createProjection/index.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createProjection } from '@vueuse/math'\n\nconst useProjector = createProjection([0, 10], [0, 100])\nconst input = ref(0)\nconst projected = useProjector(input) // projected.value === 0\n\ninput.value = 5 // projected.value === 50\ninput.value = 10 // projected.value === 100\n```\n\n----------------------------------------\n\nTITLE: Eager Computed Utility in VueUse\nDESCRIPTION: Provides an eager computed function similar to Vue's computed but with immediate evaluation, suitable for scenarios needing prompt data calculation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Utility for creating computed properties that evaluate eagerly upon creation for instant reactive data. */\n```\n\n----------------------------------------\n\nTITLE: Consuming Counter Store State in Vue Component\nDESCRIPTION: Demonstrates how to consume the counter store state (count and double) in a child component, with comments explaining different approaches for handling cases where the store might not be provided.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/shared/createInjectionState/index.md#_snippet_2\n\nLANGUAGE: vue\nCODE:\n```\n<!-- CountComponent.vue -->\n<script setup lang=\"ts\">\nimport { useCounterStore } from './useCounterStore'\n\n// use non-null assertion operator to ignore the case that store is not provided.\nconst { count, double } = useCounterStore()!\n// if you want to allow component to working without providing store, you can use follow code instead:\n// const { count, double } = useCounterStore() ?? { count: shallowRef(0), double: shallowRef(0) }\n// also, you can use another hook to provide default value\n// const { count, double } = useCounterStoreWithDefaultValue()\n// or throw error\n// const { count, double } = useCounterStoreOrThrow()\n</script>\n\n<template>\n  <ul>\n    <li>\n      count: {{ count }}\n    </li>\n    <li>\n      double: {{ double }}\n    </li>\n  </ul>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Component Usage of useWindowFocus with Slot in Vue\nDESCRIPTION: This Vue component demonstrates how to use the UseWindowFocus component to access reactive focus state via slot props. It provides a template that displays focus status, suitable for use within Vue SFCs. It depends on VueUse and Vue components setup.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useWindowFocus/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <UseWindowFocus v-slot=\"{ focused }\">\n    Document Focus: {{ focused }}\n  </UseWindowFocus>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Finding Last Element in Array Reactively in VueUse\nDESCRIPTION: Creates a reactive computed property to find the last matching element in an array based on a predicate, supporting array data management in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactive computed property to find the last element matching a condition in an array within Vue components. Supports dynamic data filtering. */\n```\n\n----------------------------------------\n\nTITLE: Extending Refs in VueUse\nDESCRIPTION: Provides function to extend Vue refs with additional properties or methods, enhancing reactivity and object manipulation capabilities within Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Extends Vue refs with extra properties or methods to enhance reactivity and functionality in Vue 3 components. */\n```\n\n----------------------------------------\n\nTITLE: Loading VueUse Modules via CDN in Vue (HTML Script Tag)\nDESCRIPTION: This snippet shows how to include the VueUse shared and core modules in a Vue application directly from public CDNs using script tags. This enables global access to VueUse utilities via 'window.VueUse', suitable for rapid prototyping or environments without module bundlers. Dependencies: a supported browser, a Vue 3 environment, and internet access to referenced CDN URLs. No input parameters are required; outputs are accessible global utilities for Vue composition.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/README.md#_snippet_2\n\nLANGUAGE: Vue\nCODE:\n```\n<script src=\"https://unpkg.com/@vueuse/shared\"></script>\n\n<script src=\"https://unpkg.com/@vueuse/core\"></script>\n```\n\n----------------------------------------\n\nTITLE: VueUse Bluetooth Device Request Button\nDESCRIPTION: Defines a Vue template with a button that, when clicked, invokes the requestDevice function to prompt the user to select a Bluetooth device. This facilitates user-initiated device connection within a Vue component.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/core/useBluetooth/index.md#_snippet_1\n\nLANGUAGE: Vue\nCODE:\n```\n<template>\n  <button @click=\"requestDevice()\">\n    Request Bluetooth Device\n  </button>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Functions in VueUse\nDESCRIPTION: Allows creation of reactive wrapper functions that track dependencies and trigger updates automatically, supporting advanced reactivity in Vue.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Constructs reactive functions that automatically track dependencies and trigger updates within Vue's reactivity system. */\n```\n\n----------------------------------------\n\nTITLE: Setting Initial WebFrame Zoom Level with VueUse (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to use the `useZoomLevel` function to set the initial zoom level. It takes an optional initial zoom level as an argument. This directly sets the zoom level when the component is mounted or the function is called, allowing you to quickly define the zoom.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/electron/useZoomLevel/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useZoomLevel } from '@vueuse/electron'\n\nconst level = useZoomLevel(2)\n```\n\n----------------------------------------\n\nTITLE: Making Objects Destructurable in VueUse\nDESCRIPTION: Enables decomposition of objects into reactive references, allowing granular reactivity on individual object properties for Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Converts objects into destructurable reactive references, enabling fine-grained reactivity at property level in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Exporting Named Functions in TypeScript - TypeScript\nDESCRIPTION: Demonstrates the preferred method for exporting functions from a TypeScript module in the VueUse codebase. Strongly advises using named exports rather than default exports to facilitate tree-shaking and code organization. Contributors should replace 'useMyFunction' with their actual function names and avoid default exports in package source files.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// DO\nexport { useMyFunction }\n\n// DON'T\nexport default useMyFunction\n```\n\n----------------------------------------\n\nTITLE: Detecting iOS Device in VueUse\nDESCRIPTION: Provides a reactive boolean indicating whether the current device is an iOS device, useful for platform-specific adjustments or styling within Vue applications. Depends on user-agent detection logic.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Reactive boolean indicating if the current device is running iOS. Utilizes user-agent detection logic for platform-specific feature toggling in Vue.js apps. */\n```\n\n----------------------------------------\n\nTITLE: Installing @vueuse/rxjs and rxjs packages (bash)\nDESCRIPTION: This snippet provides the npm install command required to use the @vueuse/rxjs package together with the core rxjs library. Both packages must be installed before using any of the observable utilities described in the documentation. It is intended to be run in a terminal within a Vue project directory.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/rxjs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/rxjs rxjs\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Components Package with npm\nDESCRIPTION: Command to install both the @vueuse/components package and its dependency @vueuse/core using npm. Both packages are required to use the renderless components functionality.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/components/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @vueuse/components @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: CamelCase to Hyphenated String Conversion in VueUse\nDESCRIPTION: Converts camelCase strings to hyphenated lowercase strings, aiding in CSS naming conventions and HTML attributes.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Converts camelCase string to hyphen-separated lowercase string for CSS classes or HTML attributes. */\n```\n\n----------------------------------------\n\nTITLE: Installing idb-keyval Dependency Using npm Bash CLI\nDESCRIPTION: This bash snippet shows the command to install the idb-keyval package as a peer dependency using npm. The version specified is compatible with version 6 and above. This prerequisite ensures the underlying IndexedDB key-val storage library is available for useIDBKeyval integration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useIDBKeyval/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install idb-keyval@^6\n```\n\n----------------------------------------\n\nTITLE: Installing VueUse Nuxt module with npm\nDESCRIPTION: Command to install VueUse Nuxt module and core packages using npm for integrating VueUse with Nuxt applications.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/guide/index.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -D @vueuse/nuxt @vueuse/core\n```\n\n----------------------------------------\n\nTITLE: Running Playwright Browser Tests with pnpm - Bash\nDESCRIPTION: Executes Playwright-powered browser tests using pnpm. Requires that Playwright and its dependencies have been installed beforehand. This command validates frontend functionality in real browsers, with results reported in the console.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm test:browser\n```\n\n----------------------------------------\n\nTITLE: Installing Drauu Library using npm\nDESCRIPTION: This bash command installs the Drauu library in a project using npm. The  `npm i drauu@^0` command installs the Drauu package with a version constraint that allows any version starting from 0.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useDrauu/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i drauu@^0\n```\n\n----------------------------------------\n\nTITLE: Function Documentation Markdown Template - Markdown\nDESCRIPTION: Provides a markdown template for documenting a new function. The first line with the function name acts as the section header, and the following sentence offers a short overview that is displayed in function lists. Contributors are encouraged to keep the introduction concise and clear. This serves as a reference for writing clear and effective documentation.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n# useMyFunction\n\nThis will be the intro. The detail descriptions...\n```\n\n----------------------------------------\n\nTITLE: Installing qrcode dependency\nDESCRIPTION: Command to install the qrcode library (version 1.x) which is required for the useQRCode integration to work.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useQRCode/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i qrcode@^1\n```\n\n----------------------------------------\n\nTITLE: Installing Sortable.js dependency for useSortable\nDESCRIPTION: Command to install the required Sortable.js dependency (version 1.x) for the useSortable integration.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useSortable/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i sortablejs@^1\n```\n\n----------------------------------------\n\nTITLE: Installing change-case with npm (Bash)\nDESCRIPTION: This snippet provides the command for installing the `change-case` library using npm.  It installs the package with a version constraint to ensure compatibility.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useChangeCase/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i change-case@^5\n```\n\n----------------------------------------\n\nTITLE: Installing universal-cookie Dependency\nDESCRIPTION: Installs the required `universal-cookie` library (version 7 or higher) using npm. This library is a necessary dependency for the `@vueuse/integrations/useCookies` function.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/integrations/useCookies/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i universal-cookie@^7\n```\n\n----------------------------------------\n\nTITLE: Fuse.js Search Integration in VueUse\nDESCRIPTION: Wraps Fuse.js search library for fuzzy searching within Vue, facilitating fast and flexible search capabilities.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_39\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Implements fuzzy search functionality in Vue using Fuse.js, supporting dynamic search operations. */\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Reactive References in VueUse\nDESCRIPTION: Syncs multiple reactive references so they stay consistent, supporting complex reactive data flows in Vue components.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Synchronizes multiple reactive references to maintain consistency across components in Vue. */\n```\n\n----------------------------------------\n\nTITLE: Providing Local Dependency in VueUse\nDESCRIPTION: Facilitates the provision of dependencies or services to child components in Vue by using Vue's provide API, supporting scoped dependency management.\nSOURCE: https://github.com/vueuse/vueuse/blob/main/packages/export-size.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Provides a dependency or service to descendant components via Vue's provide API, enabling scoped dependency sharing within Vue component trees. */\n```"
  }
]