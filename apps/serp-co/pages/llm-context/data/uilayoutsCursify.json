[
  {
    "owner": "ui-layouts",
    "repo": "cursify",
    "content": "TITLE: Initializing Fluid Cursor Effect\nDESCRIPTION: This code initializes the fluid cursor effect. It retrieves the canvas element, resizes it, defines configuration parameters for the simulation, initializes pointers for user interaction, and gets the WebGL context.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst useFluidCursor = () => {\n  const canvas = document.getElementById('fluid');\n  resizeCanvas();\n\n  //try to adjust settings\n\n  let config = {\n    SIM_RESOLUTION: 128,\n    DYE_RESOLUTION: 1440,\n    CAPTURE_RESOLUTION: 512,\n    DENSITY_DISSIPATION: 3.5,\n    VELOCITY_DISSIPATION: 2,\n    PRESSURE: 0.1,\n    PRESSURE_ITERATIONS: 20,\n    CURL: 3,\n    SPLAT_RADIUS: 0.2,\n    SPLAT_FORCE: 6000,\n    SHADING: true,\n    COLOR_UPDATE_SPEED: 10,\n    PAUSED: false,\n    BACK_COLOR: { r: 0.5, g: 0, b: 0 },\n    TRANSPARENT: true,\n  };\n\n  function pointerPrototype() {\n    this.id = -1;\n    this.texcoordX = 0;\n    this.texcoordY = 0;\n    this.prevTexcoordX = 0;\n    this.prevTexcoordY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.down = false;\n    this.moved = false;\n    this.color = [0, 0, 0];\n  }\n\n  const pointers = [];\n  pointers.push(new pointerPrototype());\n\n  const { gl, ext } = getWebGLContext(canvas);\n\n  if (!ext.supportLinearFiltering) {\n    config.DYE_RESOLUTION = 256;\n    config.SHADING = false;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Retrieving WebGL Context\nDESCRIPTION: This function retrieves the WebGL context from the canvas element. It attempts to get WebGL2 first, and falls back to WebGL or experimental-webgl if WebGL2 is not available. It also checks for necessary extensions and sets up texture formats.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function getWebGLContext(canvas) {\n    const params = {\n      alpha: true,\n      depth: false,\n      stencil: false,\n      antialias: false,\n      preserveDrawingBuffer: false,\n    };\n\n    let gl = canvas.getContext('webgl2', params);\n    const isWebGL2 = !!gl;\n    if (!isWebGL2)\n      gl =\n        canvas.getContext('webgl', params) ||\n        canvas.getContext('experimental-webgl', params);\n\n    let halfFloat;\n    let supportLinearFiltering;\n    if (isWebGL2) {\n      gl.getExtension('EXT_color_buffer_float');\n      supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n    } else {\n      halfFloat = gl.getExtension('OES_texture_half_float');\n      supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n    }\n\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n    const halfFloatTexType = isWebGL2\n      ? gl.HALF_FLOAT\n      : halfFloat.HALF_FLOAT_OES;\n    let formatRGBA;\n    let formatRG;\n    let formatR;\n\n    if (isWebGL2) {\n      formatRGBA = getSupportedFormat(\n        gl,\n        gl.RGBA16F,\n        gl.RGBA,\n        halfFloatTexType\n      );\n      formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n      formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n    } else {\n      formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    }\n\n    return {\n      gl,\n      ext: {\n        formatRGBA,\n        formatRG,\n        formatR,\n        halfFloatTexType,\n        supportLinearFiltering,\n      },\n    };\n  }\n\n```\n\n----------------------------------------\n\nTITLE: useCanvasCursor React Hook\nDESCRIPTION: This React hook, `useCanvasCursor`, initializes and manages a canvas element to create a dynamic neon cursor effect. It sets up event listeners for mouse movements, touch events, and window resizing. The hook uses requestAnimationFrame for rendering, and cleans up the event listeners when the component unmounts. The canvas is given the id 'canvas'.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/neon-cursor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// @ts-nocheck\n\nimport { useEffect } from 'react';\n\nconst useCanvasCursor = () => {\n  function n(e) {\n    this.init(e || {});\n  }\n  n.prototype = {\n    init: function (e) {\n      this.phase = e.phase || 0;\n      this.offset = e.offset || 0;\n      this.frequency = e.frequency || 0.001;\n      this.amplitude = e.amplitude || 1;\n    },\n    update: function () {\n      return (\n        (this.phase += this.frequency),\n        (e = this.offset + Math.sin(this.phase) * this.amplitude)\n      );\n    },\n    value: function () {\n      return e;\n    },\n  };\n\n  function Line(e) {\n    this.init(e || {});\n  }\n\n  Line.prototype = {\n    init: function (e) {\n      this.spring = e.spring + 0.1 * Math.random() - 0.02;\n      this.friction = E.friction + 0.01 * Math.random() - 0.002;\n      this.nodes = [];\n      for (var t, n = 0; n < E.size; n++) {\n        t = new Node();\n        t.x = pos.x;\n        t.y = pos.y;\n        this.nodes.push(t);\n      }\n    },\n    update: function () {\n      var e = this.spring,\n        t = this.nodes[0];\n      t.vx += (pos.x - t.x) * e;\n      t.vy += (pos.y - t.y) * e;\n      for (var n, i = 0, a = this.nodes.length; i < a; i++)\n        (t = this.nodes[i]),\n          0 < i &&\n            ((n = this.nodes[i - 1]),\n            (t.vx += (n.x - t.x) * e),\n            (t.vy += (n.y - t.y) * e),\n            (t.vx += n.vx * E.dampening),\n            (t.vy += n.vy * E.dampening)),\n          (t.vx *= this.friction),\n          (t.vy *= this.friction),\n          (t.x += t.vx),\n          (t.y += t.vy),\n          (e *= E.tension);\n    },\n    draw: function () {\n      var e,\n        t,\n        n = this.nodes[0].x,\n        i = this.nodes[0].y;\n      ctx.beginPath();\n      ctx.moveTo(n, i);\n      for (var a = 1, o = this.nodes.length - 2; a < o; a++) {\n        e = this.nodes[a];\n        t = this.nodes[a + 1];\n        n = 0.5 * (e.x + t.x);\n        i = 0.5 * (e.y + t.y);\n        ctx.quadraticCurveTo(e.x, e.y, n, i);\n      }\n      e = this.nodes[a];\n      t = this.nodes[a + 1];\n      ctx.quadraticCurveTo(e.x, e.y, t.x, t.y);\n      ctx.stroke();\n      ctx.closePath();\n    },\n  };\n\n  function onMousemove(e) {\n    function o() {\n      lines = [];\n      for (var e = 0; e < E.trails; e++)\n        lines.push(new Line({ spring: 0.4 + (e / E.trails) * 0.025 }));\n    }\n    function c(e) {\n      e.touches\n        ? ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY))\n        : ((pos.x = e.clientX), (pos.y = e.clientY)),\n        e.preventDefault();\n    }\n    function l(e) {\n      1 == e.touches.length &&\n        ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY));\n    }\n    document.removeEventListener('mousemove', onMousemove),\n      document.removeEventListener('touchstart', onMousemove),\n      document.addEventListener('mousemove', c),\n      document.addEventListener('touchmove', c),\n      document.addEventListener('touchstart', l),\n      c(e),\n      o(),\n      render();\n  }\n\n  function render() {\n    if (ctx.running) {\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.strokeStyle = 'hsla(' + Math.round(f.update()) + ',50%,50%,0.2)';\n      ctx.lineWidth = 1;\n      for (var e, t = 0; t < E.trails; t++) {\n        (e = lines[t]).update();\n        e.draw();\n      }\n      ctx.frame++;\n      window.requestAnimationFrame(render);\n    }\n  }\n\n  function resizeCanvas() {\n    ctx.canvas.width = window.innerWidth - 20;\n    ctx.canvas.height = window.innerHeight;\n  }\n\n  var ctx,\n    f,\n    e = 0,\n    pos = {},\n    lines = [],\n    E = {\n      debug: true,\n      friction: 0.5,\n      trails: 20,\n      size: 50,\n      dampening: 0.25,\n      tension: 0.98,\n    };\n  function Node() {\n    this.x = 0;\n    this.y = 0;\n    this.vy = 0;\n    this.vx = 0;\n  }\n\n  const renderCanvas = function () {\n    ctx = document.getElementById('canvas').getContext('2d');\n    ctx.running = true;\n    ctx.frame = 1;\n    f = new n({\n      phase: Math.random() * 2 * Math.PI,\n      amplitude: 85,\n      frequency: 0.0015,\n      offset: 285,\n    });\n    document.addEventListener('mousemove', onMousemove);\n    document.addEventListener('touchstart', onMousemove);\n    document.body.addEventListener('orientationchange', resizeCanvas);\n    window.addEventListener('resize', resizeCanvas);\n    window.addEventListener('focus', () => {\n      if (!ctx.running) {\n        ctx.running = true;\n        render();\n      }\n    });\n    window.addEventListener('blur', () => {\n      ctx.running = true;\n    });\n    resizeCanvas();\n  };\n\n  useEffect(() => {\n    renderCanvas();\n\n    return () => {\n      ctx.running = false;\n      document.removeEventListener('mousemove', onMousemove);\n      document.removeEventListener('touchstart', onMousemove);\n      document.body.removeEventListener('orientationchange', resizeCanvas);\n      window.removeEventListener('resize', resizeCanvas);\n      window.removeEventListener('focus', () => {\n        if (!ctx.running) {\n          ctx.running = true;\n          render();\n        }\n      });\n      window.removeEventListener('blur', () => {\n        ctx.running = true;\n      });\n    };\n  }, []);\n};\n\nexport default useCanvasCursor;\n```\n\n----------------------------------------\n\nTITLE: TextFlagCursor React Component\nDESCRIPTION: This React component, `TextFlagCursor`, creates a dynamic cursor effect where text characters follow the cursor's movement. It accepts options such as text, color, font, and size to customize the appearance. The component utilizes `useEffect` to initialize the effect and clean up event listeners when the component unmounts, and also handles the user's preference for reduced motion using `window.matchMedia`. The core functionality involves creating a canvas element, drawing text characters based on cursor position, and using requestAnimationFrame for smooth animation.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/textflag-cursor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// @ts-nocheck\n'use client';\n\nimport { useEffect, useRef } from 'react';\n\ninterface TextFlagOptions {\n  text?: string;\n  color?: string;\n  font?: string;\n  textSize?: number;\n  gap?: number;\n  element?: HTMLElement;\n  size?: number;\n}\n\nexport const TextFlagCursor: React.FC<TextFlagOptions> = (options) => {\n  const cursorRef = useRef<{ destroy: () => void } | null>(null);\n\n  useEffect(() => {\n    let cursorOptions = options || {};\n    let hasWrapperEl = options && options.element;\n    let element = hasWrapperEl || document.body;\n\n    let text = cursorOptions.text ? ' ' + options.text : ' Your Text Here';\n    let color = options?.color || '#000000';\n    let font = cursorOptions.font || 'monospace';\n    let textSize = cursorOptions.textSize || 12;\n    let fontFamily = textSize + 'px ' + font;\n    let gap = cursorOptions.gap || textSize + 2;\n    let angle = 0;\n    let radiusX = 2;\n    let radiusY = 5;\n    let charArray = [];\n\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n    let cursor = { x: width / 2, y: width / 2 };\n\n    for (let i = 0; i < text.length; i++) {\n      charArray[i] = { letter: text.charAt(i), x: width / 2, y: width / 2 };\n    }\n\n    let canvas: HTMLCanvasElement,\n      context: CanvasRenderingContext2D | null,\n      animationFrame: number;\n\n    // const size = options?.size || 3;\n    // let cursorsInitted = false;\n\n    const prefersReducedMotion = window.matchMedia(\n      '(prefers-reduced-motion: reduce)'\n    );\n\n    function init() {\n      if (prefersReducedMotion.matches) {\n        console.log(\n          'This browser has prefers reduced motion turned on, so the cursor did not init'\n        );\n        return false;\n      }\n\n      canvas = document.createElement('canvas');\n      context = canvas.getContext('2d');\n      canvas.style.top = '0px';\n      canvas.style.left = '0px';\n      canvas.style.pointerEvents = 'none';\n\n      if (hasWrapperEl) {\n        canvas.style.position = 'absolute';\n        element.appendChild(canvas);\n        canvas.width = element.clientWidth;\n        canvas.height = element.clientHeight;\n      } else {\n        canvas.style.position = 'fixed';\n        document.body.appendChild(canvas);\n        canvas.width = width;\n        canvas.height = height;\n      }\n\n      bindEvents();\n      loop();\n    }\n\n    function bindEvents() {\n      element.addEventListener('mousemove', onMouseMove);\n      window.addEventListener('resize', onWindowResize);\n    }\n\n    function onWindowResize() {\n      width = window.innerWidth;\n      height = window.innerHeight;\n\n      if (hasWrapperEl) {\n        canvas.width = element.clientWidth;\n        canvas.height = element.clientHeight;\n      } else {\n        canvas.width = width;\n        canvas.height = height;\n      }\n    }\n\n    function onMouseMove(e: MouseEvent) {\n      if (hasWrapperEl) {\n        const boundingRect = element.getBoundingClientRect();\n        cursor.x = e.clientX - boundingRect.left;\n        cursor.y = e.clientY - boundingRect.top;\n      } else {\n        cursor.x = e.clientX;\n        cursor.y = e.clientY;\n      }\n    }\n\n    function updateParticles() {\n      if (!context) return;\n      context.clearRect(0, 0, width, height);\n\n      angle += 0.15;\n      let locX = radiusX * Math.cos(angle);\n      let locY = radiusY * Math.sin(angle);\n\n      for (let i = charArray.length - 1; i > 0; i--) {\n        charArray[i].x = charArray[i - 1].x + gap;\n        charArray[i].y = charArray[i - 1].y;\n\n        context.fillStyle = color;\n        context.font = fontFamily;\n        context.fillText(charArray[i].letter, charArray[i].x, charArray[i].y);\n      }\n\n      let x1 = charArray[0].x;\n      let y1 = charArray[0].y;\n      x1 += (cursor.x - x1) / 5 + locX + 2;\n      y1 += (cursor.y - y1) / 5 + locY;\n      charArray[0].x = x1;\n      charArray[0].y = y1;\n    }\n\n    function loop() {\n      updateParticles();\n      animationFrame = requestAnimationFrame(loop);\n    }\n\n    function destroy() {\n      canvas.remove();\n      cancelAnimationFrame(animationFrame);\n      element.removeEventListener('mousemove', onMouseMove);\n      window.addEventListener('resize', onWindowResize);\n    }\n\n    const handleReducedMotionChange = () => {\n      if (prefersReducedMotion.matches) {\n        destroy();\n      } else {\n        init();\n      }\n    };\n\n    prefersReducedMotion.addEventListener('change', handleReducedMotionChange);\n    init();\n\n    cursorRef.current = { destroy };\n\n    return () => {\n      if (cursorRef.current) {\n        cursorRef.current.destroy();\n      }\n      prefersReducedMotion.removeEventListener(\n        'change',\n        handleReducedMotionChange\n      );\n    };\n  }, [options]);\n\n  return null;\n};\n\nexport default TextFlagCursor;\n\n```\n\n----------------------------------------\n\nTITLE: Resizing Canvas in JavaScript\nDESCRIPTION: This function resizes the canvas element based on the client width and height, scaled by the pixel ratio. It returns true if the canvas was resized, and false otherwise.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nfunction resizeCanvas() {\n  let width = scaleByPixelRatio(canvas.clientWidth);\n  let height = scaleByPixelRatio(canvas.clientHeight);\n  if (canvas.width != width || canvas.height != height) {\n    canvas.width = width;\n    canvas.height = height;\n    return true;\n  }\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom useMouse hook\nDESCRIPTION: A custom React hook that tracks the mouse position and its relation to a specific HTML element.  It returns the mouse coordinates (x, y), element-relative coordinates (elementX, elementY), the element's absolute position (elementPositionX, elementPositionY), and a ref to the target HTML element. The hook uses `useLayoutEffect` to ensure the calculations are performed after the layout is complete, preventing potential layout thrashing.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/app/(docs-page)/get-started/page.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Simulation Step in JavaScript\nDESCRIPTION: This function performs a single step of the fluid simulation. It calculates curl, applies vorticity confinement, computes divergence, performs pressure projection, subtracts the pressure gradient, and performs advection for both velocity and dye.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_36\n\nLANGUAGE: javascript\nCODE:\n```\nfunction step(dt) {\n  gl.disable(gl.BLEND);\n\n  curlProgram.bind();\n  gl.uniform2f(\n    curlProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n  blit(curl);\n\n  vorticityProgram.bind();\n  gl.uniform2f(\n    vorticityProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n  gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n  gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n  gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n  blit(velocity.write);\n  velocity.swap();\n\n  divergenceProgram.bind();\n  gl.uniform2f(\n    divergenceProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n  blit(divergence);\n\n  clearProgram.bind();\n  gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n  gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n  blit(pressure.write);\n  pressure.swap();\n\n  pressureProgram.bind();\n  gl.uniform2f(\n    pressureProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n  for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n    blit(pressure.write);\n    pressure.swap();\n  }\n\n  gradienSubtractProgram.bind();\n  gl.uniform2f(\n    gradienSubtractProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  gl.uniform1i(\n    gradienSubtractProgram.uniforms.uPressure,\n    pressure.read.attach(0)\n  );\n  gl.uniform1i(\n    gradienSubtractProgram.uniforms.uVelocity,\n    velocity.read.attach(1)\n  );\n  blit(velocity.write);\n  velocity.swap();\n\n  advectionProgram.bind();\n  gl.uniform2f(\n    advectionProgram.uniforms.texelSize,\n    velocity.texelSizeX,\n    velocity.texelSizeY\n  );\n  if (!ext.supportLinearFiltering)\n    gl.uniform2f(\n      advectionProgram.uniforms.dyeTexelSize,\n      velocity.texelSizeX,\n      velocity.texelSizeY\n    );\n  let velocityId = velocity.read.attach(0);\n  gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n  gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n  gl.uniform1f(advectionProgram.uniforms.dt, dt);\n  gl.uniform1f(\n    advectionProgram.uniforms.dissipation,\n    config.VELOCITY_DISSIPATION\n  );\n  blit(velocity.write);\n  velocity.swap();\n\n  if (!ext.supportLinearFiltering)\n    gl.uniform2f(\n      advectionProgram.uniforms.dyeTexelSize,\n      dye.texelSizeX,\n      dye.texelSizeY\n    );\n  gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n  gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n  gl.uniform1f(\n    advectionProgram.uniforms.dissipation,\n    config.DENSITY_DISSIPATION\n  );\n  blit(dye.write);\n  dye.swap();\n}\n```\n\n----------------------------------------\n\nTITLE: useMouse hook for cursor tracking\nDESCRIPTION: This React hook, `useMouse`, tracks the mouse's position and its position relative to a specific HTML element.  It uses `useLayoutEffect` to ensure that the measurements are taken after the layout is complete. It returns the current mouse state and a ref to the element.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/texticon-cursor.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Vorticity Confinement (GLSL)\nDESCRIPTION: This GLSL fragment shader applies vorticity confinement to the velocity field. It uses the curl texture to calculate a force that opposes the vorticity, thereby preventing excessive diffusion. The shader takes the curl and velocity as inputs, calculates the force direction, and adds it to the velocity.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_22\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision highp float;\nprecision highp sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n    float L = texture2D(uCurl, vL).x;\n    float R = texture2D(uCurl, vR).x;\n    float T = texture2D(uCurl, vT).x;\n    float B = texture2D(uCurl, vB).x;\n    float C = texture2D(uCurl, vUv).x;\n\n    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n    force /= length(force) + 0.0001;\n    force *= curl * C;\n    force.y *= -1.0;\n\n    vec2 velocity = texture2D(uVelocity, vUv).xy;\n    velocity += force * dt;\n    velocity = min(max(velocity, -1000.0), 1000.0);\ngl_FragColor = vec4(velocity, 0.0, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: useMouse Hook Implementation\nDESCRIPTION: This React hook tracks the mouse position and element coordinates relative to a specified DOM element. It returns the current mouse state and a ref to the target element, updating the state on every mouse movement within the document.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/gradient-cursor.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Pressure Calculation (GLSL)\nDESCRIPTION: This GLSL fragment shader calculates the pressure field based on the divergence of the velocity field using a Jacobi iteration. It samples the pressure texture at the current fragment and its neighboring fragments, as well as the divergence texture, to compute the pressure.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_23\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision mediump float;\nprecision mediump sampler2D;\n\nvarying highp vec2 vUv;\nvarying highp vec2 vL;\nvarying highp vec2 vR;\nvarying highp vec2 vT;\nvarying highp vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvoid main () {\n    float L = texture2D(uPressure, vL).x;\n    float R = texture2D(uPressure, vR).x;\n    float T = texture2D(uPressure, vT).x;\n    float B = texture2D(uPressure, vB).x;\n    float C = texture2D(uPressure, vUv).x;\n    float divergence = texture2D(uDivergence, vUv).x;\n    float pressure = (L + R + B + T - divergence) * 0.25;\ngl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initial Mousemove Event Listener\nDESCRIPTION: This snippet attaches a one-time event listener to the document body for the 'mousemove' event.  It's designed to capture the first mousemove event, retrieve and scale pointer coordinates, generate a color, update the pointer's movement data, and then remove itself as a listener. It initializes the interaction state on the first mouse movement.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_44\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.body.addEventListener('mousemove', function handleFirstMouseMove(e) {\n  let pointer = pointers[0];\n  let posX = scaleByPixelRatio(e.clientX);\n  let posY = scaleByPixelRatio(e.clientY);\n  let color = generateColor();\n\n  update();\n  updatePointerMoveData(pointer, posX, posY, color);\n\n  // Remove this event listener after the first mousemove event\n  document.body.removeEventListener('mousemove', handleFirstMouseMove);\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Splat to Fluid in JavaScript\nDESCRIPTION: This function applies a splat to the fluid simulation at the specified coordinates with the given velocity (dx, dy) and color. It binds the splat program, sets uniforms for target, aspect ratio, point, color, and radius, and then blits the result to the velocity and dye textures.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_40\n\nLANGUAGE: javascript\nCODE:\n```\nfunction splat(x, y, dx, dy, color) {\n  splatProgram.bind();\n  gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n  gl.uniform1f(\n    splatProgram.uniforms.aspectRatio,\n    canvas.width / canvas.height\n  );\n  gl.uniform2f(splatProgram.uniforms.point, x, y);\n  gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n  gl.uniform1f(\n    splatProgram.uniforms.radius,\n    correctRadius(config.SPLAT_RADIUS / 100.0)\n  );\n  blit(velocity.write);\n  velocity.swap();\n\n  gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n```\n\n----------------------------------------\n\nTITLE: WebGL Uniform Color Setting\nDESCRIPTION: This snippet sets the color uniform in a WebGL shader program using `gl.uniform3f`. It takes a `color` object with `r`, `g`, and `b` properties as input, and applies it to the `color` uniform of the `splatProgram`.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_41\n\nLANGUAGE: javascript\nCODE:\n```\ngl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Splatting (GLSL)\nDESCRIPTION: This GLSL fragment shader implements a splatting effect, adding a colored Gaussian blob to a base texture. It takes as input UV coordinates, a target texture, aspect ratio, color, splat point, and radius. It calculates the distance from the current fragment to the splat point, applies a Gaussian function, and adds the resulting color to the base texture.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_18\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision highp float;\nprecision highp sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n    vec2 p = vUv - point.xy;\np.x *= aspectRatio;\n    vec3 splat = exp(-dot(p, p) / radius) * color;\n    vec3 base = texture2D(uTarget, vUv).xyz;\n    gl_FragColor = vec4(base + splat, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Correct Radius Calculation based on Aspect Ratio\nDESCRIPTION: This function, `correctRadius`, adjusts a given radius based on the aspect ratio of the canvas. If the aspect ratio is greater than 1, the radius is multiplied by the aspect ratio. It ensures that visual elements maintain consistent proportions regardless of the canvas's shape.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_42\n\nLANGUAGE: javascript\nCODE:\n```\nfunction correctRadius(radius) {\n  let aspectRatio = canvas.width / canvas.height;\n  if (aspectRatio > 1) radius *= aspectRatio;\n  return radius;\n}\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Gradient Subtraction (GLSL)\nDESCRIPTION: This GLSL fragment shader subtracts the gradient of the pressure field from the velocity field, making the velocity field divergence-free. It samples the pressure texture at the current fragment and its neighboring fragments to compute the pressure gradient, which is then subtracted from the velocity.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_24\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision mediump float;\nprecision mediump sampler2D;\n\nvarying highp vec2 vUv;\nvarying highp vec2 vL;\nvarying highp vec2 vR;\nvarying highp vec2 vT;\nvarying highp vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvoid main () {\n    float L = texture2D(uPressure, vL).x;\n    float R = texture2D(uPressure, vR).x;\n    float T = texture2D(uPressure, vT).x;\n    float B = texture2D(uPressure, vB).x;\n    vec2 velocity = texture2D(uVelocity, vUv).xy;\n    velocity.xy -= vec2(R - L, T - B);\ngl_FragColor = vec4(velocity, 0.0, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Update Pointer Move Data\nDESCRIPTION: This function updates the pointer's data during a mouse or touch movement. It sets the previous texture coordinates, calculates new texture coordinates based on the current position, calculates the delta values, sets the moved flag, and assigns a color to the pointer.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_51\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updatePointerMoveData(pointer, posX, posY, color) {\n  // pointer.down = false;\n  pointer.prevTexcoordX = pointer.texcoordX;\n  pointer.prevTexcoordY = pointer.texcoordY;\n  pointer.texcoordX = posX / canvas.width;\n  pointer.texcoordY = 1.0 - posY / canvas.height;\n  pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n  pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n  pointer.moved =\n    Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n  pointer.color = color;\n}\n```\n\n----------------------------------------\n\nTITLE: Drawing Fluid Display in JavaScript\nDESCRIPTION: This function draws the fluid display to a specified target. It binds the display material, sets the texel size if shading is enabled, binds the dye texture, and then blits the result to the target.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_38\n\nLANGUAGE: javascript\nCODE:\n```\nfunction drawDisplay(target) {\n  let width = target == null ? gl.drawingBufferWidth : target.width;\n  let height = target == null ? gl.drawingBufferHeight : target.height;\n\n  displayMaterial.bind();\n  if (config.SHADING)\n    gl.uniform2f(\n      displayMaterial.uniforms.texelSize,\n      1.0 / width,\n      1.0 / height\n    );\n  gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n  blit(target);\n}\n```\n\n----------------------------------------\n\nTITLE: Splatting Pointer in JavaScript\nDESCRIPTION: This function applies a splat to the fluid simulation based on the pointer's movement. It calculates the delta X and delta Y based on pointer movement and then calls the `splat` function.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_39\n\nLANGUAGE: javascript\nCODE:\n```\nfunction splatPointer(pointer) {\n  let dx = pointer.deltaX * config.SPLAT_FORCE;\n  let dy = pointer.deltaY * config.SPLAT_FORCE;\n  splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n}\n```\n\n----------------------------------------\n\nTITLE: Blur Fragment Shader\nDESCRIPTION: This GLSL fragment shader implements a blur effect by sampling the texture at the current UV coordinate and its left and right neighbors, then averaging the results.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_12\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision mediump float;\n       precision mediump sampler2D;\n   \n       varying vec2 vUv;\n       varying vec2 vL;\n       varying vec2 vR;\n       uniform sampler2D uTexture;\n   \n       void main () {\n           vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\n           sum += texture2D(uTexture, vL) * 0.35294117;\n           sum += texture2D(uTexture, vR) * 0.35294117;\n           gl_FragColor = sum;\n       }\n   \n```\n\n----------------------------------------\n\nTITLE: Update Pointer Down Data\nDESCRIPTION: This function updates the pointer's data when a mouse or touch event starts. It sets the pointer's ID, down state, moved state, texture coordinates, previous texture coordinates, delta values to 0, and generates a new color for the pointer.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_50\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updatePointerDownData(pointer, id, posX, posY) {\n  pointer.id = id;\n  pointer.down = true;\n  pointer.moved = false;\n  pointer.texcoordX = posX / canvas.width;\n  pointer.texcoordY = 1.0 - posY / canvas.height;\n  pointer.prevTexcoordX = pointer.texcoordX;\n  pointer.prevTexcoordY = pointer.texcoordY;\n  pointer.deltaX = 0;\n  pointer.deltaY = 0;\n  pointer.color = generateColor();\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Shader Keywords in JavaScript\nDESCRIPTION: This function updates the keywords for the display material based on the `config.SHADING` value. It creates an array of keywords and sets them on the `displayMaterial` object.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_32\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updateKeywords() {\n  let displayKeywords = [];\n  if (config.SHADING) displayKeywords.push('SHADING');\n  displayMaterial.setKeywords(displayKeywords);\n}\n```\n\n----------------------------------------\n\nTITLE: Mousedown Event Listener\nDESCRIPTION: This snippet attaches an event listener to the window for the 'mousedown' event. When a mousedown event occurs, it retrieves pointer coordinates, scales them by the pixel ratio, updates pointer data, and simulates a click splat using the `clickSplat` function. It uses the first element in a `pointers` array.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_43\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener('mousedown', (e) => {\n  let pointer = pointers[0];\n  let posX = scaleByPixelRatio(e.clientX);\n  let posY = scaleByPixelRatio(e.clientY);\n  updatePointerDownData(pointer, -1, posX, posY);\n  clickSplat(pointer);\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Inputs to Fluid Simulation in JavaScript\nDESCRIPTION: This function iterates over an array of `pointers` and calls `splatPointer` for each pointer that has moved. This applies user input to the fluid simulation.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_35\n\nLANGUAGE: javascript\nCODE:\n```\nfunction applyInputs() {\n  pointers.forEach((p) => {\n    if (p.moved) {\n      p.moved = false;\n      splatPointer(p);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Touchstart Event Listener\nDESCRIPTION: This snippet attaches an event listener to the window for the 'touchstart' event. It iterates through all touches, scales their coordinates, and updates pointer down data.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_47\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener('touchstart', (e) => {\n  const touches = e.targetTouches;\n  let pointer = pointers[0];\n  for (let i = 0; i < touches.length; i++) {\n    let posX = scaleByPixelRatio(touches[i].clientX);\n    let posY = scaleByPixelRatio(touches[i].clientY);\n    updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Compiling GLSL Shader\nDESCRIPTION: This function compiles a GLSL shader of a given type (vertex or fragment). It adds keywords to the shader source, compiles the shader, and checks for compilation errors.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function compileShader(type, source, keywords) {\n    source = addKeywords(source, keywords);\n\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n      console.trace(gl.getShaderInfoLog(shader));\n\n    return shader;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Fluid Simulation in JavaScript\nDESCRIPTION: This function renders the fluid simulation to a specified target, enabling blending and calling the `drawDisplay` function to perform the actual rendering.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_37\n\nLANGUAGE: javascript\nCODE:\n```\nfunction render(target) {\n  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n  gl.enable(gl.BLEND);\n  drawDisplay(target);\n}\n```\n\n----------------------------------------\n\nTITLE: Blit Function (JavaScript/WebGL)\nDESCRIPTION: This JavaScript function performs a blit operation, copying the contents of one framebuffer to another. It can also clear the target framebuffer before copying. It sets up a simple vertex buffer and element array buffer to draw a quad that covers the entire target.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst blit = (() => {\n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),\n    gl.STATIC_DRAW\n  );\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array([0, 1, 2, 0, 2, 3]),\n    gl.STATIC_DRAW\n  );\n  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(0);\n\n  return (target, clear = false) => {\n    if (target == null) {\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    } else {\n      gl.viewport(0, 0, target.width, target.height);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n    }\n    if (clear) {\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n  };\n})();\n```\n\n----------------------------------------\n\nTITLE: Creating Frame Buffer Object (FBO) in WebGL\nDESCRIPTION: This function creates a Frame Buffer Object (FBO) with a specified width, height, internal format, format, type, and parameter. It binds a texture to the FBO and sets texture parameters such as min/mag filters and wrap modes. It returns an object containing the texture, FBO, dimensions, texel sizes, and a function to attach the texture to a specific texture unit.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createFBO(w, h, internalFormat, format, type, param) {\n  gl.activeTexture(gl.TEXTURE0);\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    internalFormat,\n    w,\n    h,\n    0,\n    format,\n    type,\n    null\n  );\n\n  let fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    texture,\n    0\n  );\n  gl.viewport(0, 0, w, h);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  let texelSizeX = 1.0 / w;\n  let texelSizeY = 1.0 / h;\n\n  return {\n    texture,\n    fbo,\n    width: w,\n    height: h,\n    texelSizeX,\n    texelSizeY,\n    attach(id) {\n      gl.activeTexture(gl.TEXTURE0 + id);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      return id;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: useMouse Hook Implementation\nDESCRIPTION: This custom React hook, `useMouse`, tracks the mouse position on the page and relative to a specified HTML element. It returns the current mouse state (x, y, elementX, elementY, elementPositionX, elementPositionY) and a ref to the HTML element that the mouse position is calculated relative to. The hook uses `useLayoutEffect` to ensure that the element's position is calculated correctly and `useState` to store the mouse position. The event listener for mousemove is added on mount and removed on unmount.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/3d-cursor.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Generate Random Color\nDESCRIPTION: This function generates a random color in RGB format by first generating a random color in HSV format and then converting it to RGB using the `HSVtoRGB` function. The RGB values are then scaled down to 0.15 to create a darker color.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_55\n\nLANGUAGE: javascript\nCODE:\n```\nfunction generateColor() {\n  let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n  c.r *= 0.15;\n  c.g *= 0.15;\n  c.b *= 0.15;\n  return c;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Double Frame Buffer Object (FBO) in WebGL\nDESCRIPTION: This function creates two Frame Buffer Objects (FBOs) using the `createFBO` function with the provided parameters. It returns an object with properties for width, height, texel sizes, read/write FBOs, and a swap function to alternate between the FBOs for double-buffering.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createDoubleFBO(w, h, internalFormat, format, type, param) {\n  let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n  let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n\n  return {\n    width: w,\n    height: h,\n    texelSizeX: fbo1.texelSizeX,\n    texelSizeY: fbo1.texelSizeY,\n    get read() {\n      return fbo1;\n    },\n    set read(value) {\n      fbo1 = value;\n    },\n    get write() {\n      return fbo2;\n    },\n    set write(value) {\n      fbo2 = value;\n    },\n    swap() {\n      let temp = fbo1;\n      fbo1 = fbo2;\n      fbo2 = temp;\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: useMouse Hook Implementation\nDESCRIPTION: This hook tracks the mouse position and its coordinates relative to a specified HTMLDivElement. It utilizes `useLayoutEffect` to add and remove a `mousemove` event listener on the document. The hook returns a state object containing the mouse coordinates and a ref object to the target HTMLDivElement.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/glitch-cursor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Resizing Frame Buffer Object (FBO) in WebGL\nDESCRIPTION: This function resizes an existing Frame Buffer Object (FBO) to a new width and height. It creates a new FBO with the specified dimensions and copies the contents of the old FBO to the new one using a copy program and blit function.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\nfunction resizeFBO(target, w, h, internalFormat, format, type, param) {\n  let newFBO = createFBO(w, h, internalFormat, format, type, param);\n  copyProgram.bind();\n  gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n  blit(newFBO);\n  return newFBO;\n}\n```\n\n----------------------------------------\n\nTITLE: useMouse Hook Implementation\nDESCRIPTION: This custom React hook, `useMouse`, tracks mouse movement and calculates its position relative to a specified HTML element. It uses `useState` to maintain the mouse state and `useLayoutEffect` to attach and detach the mousemove event listener. The hook returns the current mouse state and a ref to the target HTML element.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/multi-cursor.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n'use client';\nimport { type RefObject, useLayoutEffect, useRef, useState } from 'react';\n\ninterface MouseState {\n  x: number | null;\n  y: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  elementPositionX: number | null;\n  elementPositionY: number | null;\n}\n\nexport function useMouse(): [MouseState, RefObject<HTMLDivElement>] {\n  const [state, setState] = useState<MouseState>({\n    x: null,\n    y: null,\n    elementX: null,\n    elementY: null,\n    elementPositionX: null,\n    elementPositionY: null,\n  });\n\n  const ref = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      const newState: Partial<MouseState> = {\n        x: event.pageX,\n        y: event.pageY,\n      };\n\n      if (ref.current instanceof Element) {\n        const { left, top } = ref.current.getBoundingClientRect();\n        const elementPositionX = left + window.scrollX;\n        const elementPositionY = top + window.scrollY;\n        const elementX = event.pageX - elementPositionX;\n        const elementY = event.pageY - elementPositionY;\n\n        newState.elementX = elementX;\n        newState.elementY = elementY;\n        newState.elementPositionX = elementPositionX;\n        newState.elementPositionY = elementPositionY;\n      }\n\n      setState((s) => ({\n        ...s,\n        ...newState,\n      }));\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [state, ref];\n}\n```\n\n----------------------------------------\n\nTITLE: Program Class Definition\nDESCRIPTION: This class encapsulates a WebGL program, associating a vertex shader and fragment shader.  It compiles the shaders and retrieves the locations of all uniforms within the program.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n  class Program {\n    constructor(vertexShader, fragmentShader) {\n      this.uniforms = {};\n      this.program = createProgram(vertexShader, fragmentShader);\n      this.uniforms = getUniforms(this.program);\n    }\n\n    bind() {\n      gl.useProgram(this.program);\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: React Hook: Implementing Spotlight Cursor Effect in TypeScript\nDESCRIPTION: This hook, `useSpotlightEffect`, creates a dynamic spotlight effect that follows the user's cursor. It uses canvas manipulation to draw a spotlight and applies various configurations such as size, intensity, fade speed, and color. The hook returns a reference to the canvas element.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/spotlight-cursor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// @ts-nocheck\n'use client';\nimport { useEffect, useRef, useState } from 'react';\n\nconst useSpotlightEffect = (config = {}) => {\n  const {\n    spotlightSize = 200,\n    spotlightIntensity = 0.8,\n    fadeSpeed = 0.1,\n    glowColor = '255, 255, 255',\n    pulseSpeed = 2000,\n  } = config;\n\n  const canvasRef = useRef(null);\n  const ctxRef = useRef(null);\n  const spotlightPos = useRef({ x: 0, y: 0 });\n  const targetPos = useRef({ x: 0, y: 0 });\n  const animationFrame = useRef(null);\n  const [isHovered, setIsHovered] = useState(false);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    ctxRef.current = ctx;\n\n    const resizeCanvas = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n\n    const lerp = (start, end, factor) => {\n      return start + (end - start) * factor;\n    };\n\n    const handleMouseMove = (e) => {\n      targetPos.current = { x: e.clientX, y: e.clientY };\n      setIsHovered(true);\n    };\n\n    const handleMouseLeave = () => {\n      setIsHovered(false);\n    };\n\n    const render = () => {\n      if (!canvas || !ctx) return;\n\n      // Smooth position transition\n      spotlightPos.current.x = lerp(\n        spotlightPos.current.x,\n        targetPos.current.x,\n        fadeSpeed\n      );\n      spotlightPos.current.y = lerp(\n        spotlightPos.current.y,\n        targetPos.current.y,\n        fadeSpeed\n      );\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Create dark overlay\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Calculate pulse effect\n      const pulseScale =\n        1 + 0.1 * Math.sin((Date.now() / pulseSpeed) * Math.PI * 2);\n      const currentSpotlightSize = spotlightSize * pulseScale;\n\n      // Create spotlight gradient\n      const gradient = ctx.createRadialGradient(\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        0,\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        currentSpotlightSize\n      );\n\n      // Add multiple color stops for smoother transition\n      gradient.addColorStop(0, `rgba(${glowColor}, ${spotlightIntensity})`);\n      gradient.addColorStop(\n        0.5,\n        `rgba(${glowColor}, ${spotlightIntensity * 0.5})`\n      );\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n\n      // Apply spotlight effect\n      ctx.globalCompositeOperation = 'destination-out';\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        currentSpotlightSize,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n\n      // Add glow effect\n      ctx.globalCompositeOperation = 'source-over';\n      const glowGradient = ctx.createRadialGradient(\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        0,\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        currentSpotlightSize * 1.2\n      );\n      glowGradient.addColorStop(0, `rgba(${glowColor}, 0.2)`);\n      glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n      ctx.fillStyle = glowGradient;\n      ctx.beginPath();\n      ctx.arc(\n        spotlightPos.current.x,\n        spotlightPos.current.y,\n        currentSpotlightSize * 1.2,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n\n      animationFrame.current = requestAnimationFrame(render);\n    };\n\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseleave', handleMouseLeave);\n    render();\n\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n      document.addEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseleave', handleMouseLeave);\n      if (animationFrame.current) {\n        cancelAnimationFrame(animationFrame.current);\n      }\n    };\n  }, [spotlightSize, spotlightIntensity, fadeSpeed, glowColor, pulseSpeed]);\n\n  return canvasRef;\n};\n\nexport default useSpotlightEffect;\n\n```\n\n----------------------------------------\n\nTITLE: Material Class Definition\nDESCRIPTION: This class represents a material used in the WebGL rendering. It stores the vertex shader, fragment shader source, compiled shader programs, and uniform locations. It allows setting keywords to customize the shader program.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n  class Material {\n    constructor(vertexShader, fragmentShaderSource) {\n      this.vertexShader = vertexShader;\n      this.fragmentShaderSource = fragmentShaderSource;\n      this.programs = [];\n      this.activeProgram = null;\n      this.uniforms = [];\n    }\n\n    setKeywords(keywords) {\n      let hash = 0;\n      for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n\n      let program = this.programs[hash];\n      if (program == null) {\n        let fragmentShader = compileShader(\n          gl.FRAGMENT_SHADER,\n          this.fragmentShaderSource,\n          keywords\n        );\n        program = createProgram(this.vertexShader, fragmentShader);\n        this.programs[hash] = program;\n      }\n\n      if (program == this.activeProgram) return;\n\n      this.uniforms = getUniforms(program);\n      this.activeProgram = program;\n    }\n\n    bind() {\n      gl.useProgram(this.activeProgram);\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Canvas Cursor Effect Hook\nDESCRIPTION: This React hook, `useCanvasCursor`, implements a dynamic cursor effect using a canvas element. It defines functions for creating and updating lines and nodes, as well as handling mouse movements and window resizing. The hook uses `useEffect` to initialize the canvas and set up event listeners, and cleans up the listeners when the component unmounts.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/canvas-cursor.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @ts-nocheck\n\nimport { useEffect } from 'react';\n\nconst useCanvasCursor = () => {\n  function n(e) {\n    this.init(e || {});\n  }\n  n.prototype = {\n    init: function (e) {\n      this.phase = e.phase || 0;\n      this.offset = e.offset || 0;\n      this.frequency = e.frequency || 0.001;\n      this.amplitude = e.amplitude || 1;\n    },\n    update: function () {\n      return (\n        (this.phase += this.frequency),\n        (e = this.offset + Math.sin(this.phase) * this.amplitude)\n      );\n    },\n    value: function () {\n      return e;\n    },\n  };\n\n  function Line(e) {\n    this.init(e || {});\n  }\n\n  Line.prototype = {\n    init: function (e) {\n      this.spring = e.spring + 0.1 * Math.random() - 0.02;\n      this.friction = E.friction + 0.01 * Math.random() - 0.002;\n      this.nodes = [];\n      for (var t, n = 0; n < E.size; n++) {\n        t = new Node();\n        t.x = pos.x;\n        t.y = pos.y;\n        this.nodes.push(t);\n      }\n    },\n    update: function () {\n      var e = this.spring,\n        t = this.nodes[0];\n      t.vx += (pos.x - t.x) * e;\n      t.vy += (pos.y - t.y) * e;\n      for (var n, i = 0, a = this.nodes.length; i < a; i++)\n        (t = this.nodes[i]),\n          0 < i &&\n            ((n = this.nodes[i - 1]),\n            (t.vx += (n.x - t.x) * e),\n            (t.vy += (n.y - t.y) * e),\n            (t.vx += n.vx * E.dampening),\n            (t.vy += n.vy * E.dampening)),\n          (t.vx *= this.friction),\n          (t.vy *= this.friction),\n          (t.x += t.vx),\n          (t.y += t.vy),\n          (e *= E.tension);\n    },\n    draw: function () {\n      var e,\n        t,\n        n = this.nodes[0].x,\n        i = this.nodes[0].y;\n      ctx.beginPath();\n      ctx.moveTo(n, i);\n      for (var a = 1, o = this.nodes.length - 2; a < o; a++) {\n        e = this.nodes[a];\n        t = this.nodes[a + 1];\n        n = 0.5 * (e.x + t.x);\n        i = 0.5 * (e.y + t.y);\n        ctx.quadraticCurveTo(e.x, e.y, n, i);\n      }\n      e = this.nodes[a];\n      t = this.nodes[a + 1];\n      ctx.quadraticCurveTo(e.x, e.y, t.x, t.y);\n      ctx.stroke();\n      ctx.closePath();\n    },\n  };\n\n  function onMousemove(e) {\n    function o() {\n      lines = [];\n      for (var e = 0; e < E.trails; e++)\n        lines.push(new Line({ spring: 0.4 + (e / E.trails) * 0.025 }));\n    }\n    function c(e) {\n      e.touches\n        ? ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY))\n        : ((pos.x = e.clientX), (pos.y = e.clientY)),\n        e.preventDefault();\n    }\n    function l(e) {\n      1 == e.touches.length &&\n        ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY));\n    }\n    document.removeEventListener('mousemove', onMousemove),\n      document.removeEventListener('touchstart', onMousemove),\n      document.addEventListener('mousemove', c),\n      document.addEventListener('touchmove', c),\n      document.addEventListener('touchstart', l),\n      c(e),\n      o(),\n      render();\n  }\n\n  function render() {\n    if (ctx.running) {\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.strokeStyle = 'hsla(' + Math.round(f.update()) + ',50%,50%,0.2)';\n      ctx.lineWidth = 1;\n      for (var e, t = 0; t < E.trails; t++) {\n        (e = lines[t]).update();\n        e.draw();\n      }\n      ctx.frame++;\n      window.requestAnimationFrame(render);\n    }\n  }\n\n  function resizeCanvas() {\n    ctx.canvas.width = window.innerWidth - 20;\n    ctx.canvas.height = window.innerHeight;\n  }\n\n  var ctx,\n    f,\n    e = 0,\n    pos = {},\n    lines = [],\n    E = {\n      debug: true,\n      friction: 0.5,\n      trails: 20,\n      size: 50,\n      dampening: 0.25,\n      tension: 0.98,\n    };\n  function Node() {\n    this.x = 0;\n    this.y = 0;\n    this.vy = 0;\n    this.vx = 0;\n  }\n\n  const renderCanvas = function () {\n    ctx = document.getElementById('canvas').getContext('2d');\n    ctx.running = true;\n    ctx.frame = 1;\n    f = new n({\n      phase: Math.random() * 2 * Math.PI,\n      amplitude: 85,\n      frequency: 0.0015,\n      offset: 285,\n    });\n    document.addEventListener('mousemove', onMousemove);\n    document.addEventListener('touchstart', onMousemove);\n    document.body.addEventListener('orientationchange', resizeCanvas);\n    window.addEventListener('resize', resizeCanvas);\n    window.addEventListener('focus', () => {\n      if (!ctx.running) {\n        ctx.running = true;\n        render();\n      }\n    });\n    window.addEventListener('blur', () => {\n      ctx.running = true;\n    });\n    resizeCanvas();\n  };\n\n  useEffect(() => {\n    renderCanvas();\n\n    return () => {\n      ctx.running = false;\n      document.removeEventListener('mousemove', onMousemove);\n      document.removeEventListener('touchstart', onMousemove);\n      document.body.removeEventListener('orientationchange', resizeCanvas);\n      window.removeEventListener('resize', resizeCanvas);\n      window.removeEventListener('focus', () => {\n        if (!ctx.running) {\n          ctx.running = true;\n          render();\n        }\n      });\n      window.removeEventListener('blur', () => {\n        ctx.running = true;\n      });\n    };\n  }, []);\n};\n\nexport default useCanvasCursor;\n```\n\n----------------------------------------\n\nTITLE: Creating WebGL Program\nDESCRIPTION: This function creates a WebGL program by attaching the vertex and fragment shaders, linking the program, and checking for link errors.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function createProgram(vertexShader, fragmentShader) {\n    let program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n      console.trace(gl.getProgramInfoLog(program));\n\n    return program;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: FairyDustCursor Component Definition in React\nDESCRIPTION: Defines the `FairyDustCursor` React component, which renders a canvas and manages particle effects based on cursor movement. It utilizes `useEffect` to handle mouse and touch events, creating and updating particles on the canvas. The component accepts several props to customize the particle appearance and behavior, like colors, character set, size, count, gravity, and fade speed.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fairydust-cursor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\nimport React, { useEffect, useRef, useState } from 'react';\n\ninterface FairyDustCursorProps {\n  colors?: string[];\n  element?: HTMLElement;\n  characterSet?: string[];\n  particleSize?: number;\n  particleCount?: number;\n  gravity?: number;\n  fadeSpeed?: number;\n  initialVelocity?: {\n    min: number;\n    max: number;\n  };\n}\n\ninterface Particle {\n  x: number;\n  y: number;\n  character: string;\n  color: string;\n  velocity: {\n    x: number;\n    y: number;\n  };\n  lifeSpan: number;\n  initialLifeSpan: number;\n  scale: number;\n}\n\nexport const FairyDustCursor: React.FC<FairyDustCursorProps> = ({\n  colors = ['#D61C59', '#E7D84B', '#1B8798'],\n  element,\n  characterSet = ['✨', '⭐', '🌟', '★', '*'],\n  particleSize = 21,\n  particleCount = 1,\n  gravity = 0.02,\n  fadeSpeed = 0.98,\n  initialVelocity = { min: 0.5, max: 1.5 },\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const particlesRef = useRef<Particle[]>([]);\n  const cursorRef = useRef({ x: 0, y: 0 });\n  const lastPosRef = useRef({ x: 0, y: 0 });\n  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const targetElement = element || document.body;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n\n    const updateCanvasSize = () => {\n      const newWidth = element ? targetElement.clientWidth : window.innerWidth;\n      const newHeight = element\n        ? targetElement.clientHeight\n        : window.innerHeight;\n      setCanvasSize({ width: newWidth, height: newHeight });\n    };\n\n    updateCanvasSize();\n    window.addEventListener('resize', updateCanvasSize);\n\n    // Animation frame setup\n    let animationFrameId: number;\n\n    const createParticle = (x: number, y: number): Particle => {\n      const randomChar =\n        characterSet[Math.floor(Math.random() * characterSet.length)];\n      const randomColor = colors[Math.floor(Math.random() * colors.length)];\n      const velocityX =\n        (Math.random() < 0.5 ? -1 : 1) *\n        (Math.random() * (initialVelocity.max - initialVelocity.min) +\n          initialVelocity.min);\n      const velocityY = -(Math.random() * initialVelocity.max);\n\n      return {\n        x,\n        y,\n        character: randomChar,\n        color: randomColor,\n        velocity: { x: velocityX, y: velocityY },\n        lifeSpan: 100,\n        initialLifeSpan: 100,\n        scale: 1,\n      };\n    };\n\n    const updateParticles = () => {\n      if (!context) return;\n      context.clearRect(0, 0, canvasSize.width, canvasSize.height);\n\n      // Update and draw particles\n      particlesRef.current.forEach((particle, index) => {\n        // Update position\n        particle.x += particle.velocity.x;\n        particle.y += particle.velocity.y;\n\n        // Apply gravity\n        particle.velocity.y += gravity;\n\n        // Update lifespan and scale\n        particle.lifeSpan *= fadeSpeed;\n        particle.scale = Math.max(\n          particle.lifeSpan / particle.initialLifeSpan,\n          0\n        );\n\n        // Draw particle\n        context.save();\n        context.font = `${particleSize * particle.scale}px serif`;\n        context.fillStyle = particle.color;\n        context.globalAlpha = particle.scale;\n        context.fillText(particle.character, particle.x, particle.y);\n        context.restore();\n      });\n\n      // Remove dead particles\n      particlesRef.current = particlesRef.current.filter(\n        (particle) => particle.lifeSpan > 0.1\n      );\n    };\n\n    const animate = () => {\n      updateParticles();\n      animationFrameId = requestAnimationFrame(animate);\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = element ? targetElement.getBoundingClientRect() : undefined;\n      const x = element ? e.clientX - rect!.left : e.clientX;\n      const y = element ? e.clientY - rect!.top : e.clientY;\n\n      cursorRef.current = { x, y };\n\n      const distance = Math.hypot(\n        cursorRef.current.x - lastPosRef.current.x,\n        cursorRef.current.y - lastPosRef.current.y\n      );\n\n      if (distance > 2) {\n        for (let i = 0; i < particleCount; i++) {\n          particlesRef.current.push(\n            createParticle(cursorRef.current.x, cursorRef.current.y)\n          );\n        }\n        lastPosRef.current = { ...cursorRef.current };\n      }\n    };\n\n    const handleTouchMove = (e: TouchEvent) => {\n      e.preventDefault();\n      const touch = e.touches[0];\n      const rect = element ? targetElement.getBoundingClientRect() : undefined;\n      const x = element ? touch.clientX - rect!.left : touch.clientX;\n      const y = element ? touch.clientY - rect!.top : touch.clientY;\n\n      for (let i = 0; i < particleCount; i++) {\n        particlesRef.current.push(createParticle(x, y));\n      }\n    };\n\n    targetElement.addEventListener('mousemove', handleMouseMove);\n    targetElement.addEventListener('touchmove', handleTouchMove, {\n      passive: false,\n    });\n    animate();\n\n    return () => {\n      window.removeEventListener('resize', updateCanvasSize);\n      targetElement.removeEventListener('mousemove', handleMouseMove);\n      targetElement.removeEventListener('touchmove', handleTouchMove);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [\n    colors,\n    element,\n    characterSet,\n    particleSize,\n    particleCount,\n    gravity,\n    fadeSpeed,\n    initialVelocity,\n  ]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={canvasSize.width}\n      height={canvasSize.height}\n      style={{\n        position: element ? 'absolute' : 'fixed',\n        top: 0,\n        left: 0,\n        pointerEvents: 'none',\n        zIndex: 9999,\n      }}\n    />\n  );\n};\n\nexport default FairyDustCursor;\n\n```\n\n----------------------------------------\n\nTITLE: Getting Supported Texture Format\nDESCRIPTION: This function checks if a specific texture format is supported by the WebGL context. If the initial format is not supported, it attempts to find a suitable fallback format recursively.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function getSupportedFormat(gl, internalFormat, format, type) {\n    if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n      switch (internalFormat) {\n        case gl.R16F:\n          return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n        case gl.RG16F:\n          return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n        default:\n          return null;\n      }\n    }\n\n    return {\n      internalFormat,\n      format,\n    };\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Media Query Hook (use-media-query.tsx)\nDESCRIPTION: This custom hook, `useMediaQuery`, allows components to react to media query changes. It takes a media query string as input and returns a boolean value indicating whether the query matches. It uses `useEffect` to listen for changes and update the component's state.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/README.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect, useState } from 'react';\n\nexport function useMediaQuery(query: string) {\n  const [value, setValue] = useState(false);\n\n  useEffect(() => {\n    function onChange(event: MediaQueryListEvent) {\n      setValue(event.matches);\n    }\n\n    const result = matchMedia(query);\n    result.addEventListener('change', onChange);\n    setValue(result.matches);\n\n    return () => result.removeEventListener('change', onChange);\n  }, [query]);\n\n  return value;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Uniform Locations\nDESCRIPTION: This function retrieves the locations of all active uniforms in a WebGL program.  It iterates through the uniforms and stores their locations in a dictionary.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function getUniforms(program) {\n    let uniforms = [];\n    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; i++) {\n      let uniformName = gl.getActiveUniform(program, i).name;\n      uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n    }\n    return uniforms;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Generate Hash Code for String\nDESCRIPTION: This function, `hashCode`, generates a hash code for a given string. It iterates through the string, applying a bitwise operation to calculate the hash. It returns 0 if the string is empty. The bitwise operations and shifting are for performance and distribution of the hash value.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_60\n\nLANGUAGE: javascript\nCODE:\n```\nfunction hashCode(s) {\n  if (s.length == 0) return 0;\n  let hash = 0;\n  for (let i = 0; i < s.length; i++) {\n    hash = (hash << 5) - hash + s.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n```\n\n----------------------------------------\n\nTITLE: Get Resolution Based on Aspect Ratio\nDESCRIPTION: This function, `getResolution`, calculates a resolution based on a given resolution and the aspect ratio of the WebGL drawing buffer. It returns an object with `width` and `height` properties, ensuring that the resolution is scaled proportionally to the aspect ratio.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_58\n\nLANGUAGE: javascript\nCODE:\n```\nfunction getResolution(resolution) {\n  let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n  if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n\n  const min = Math.round(resolution);\n  const max = Math.round(resolution * aspectRatio);\n\n  if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n    return { width: max, height: min };\n  else return { width: min, height: max };\n}\n```\n\n----------------------------------------\n\nTITLE: Framebuffer Initialization (JavaScript/WebGL)\nDESCRIPTION: This JavaScript function initializes the framebuffers used in the fluid simulation. It creates or resizes double FBOs for dye and velocity, and single FBOs for divergence, curl, and pressure. It also retrieves necessary WebGL extensions for half-float textures and linear filtering, and disables blending.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA;\n    const rg = ext.formatRG;\n    const r = ext.formatR;\n    const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n\n    gl.disable(gl.BLEND);\n\n    if (dye == null)\n      dye = createDoubleFBO(\n        dyeRes.width,\n        dyeRes.height,\n        rgba.internalFormat,\n        rgba.format,\n        texType,\n        filtering\n      );\n    else\n      dye = resizeDoubleFBO(\n        dye,\n        dyeRes.width,\n        dyeRes.height,\n        rgba.internalFormat,\n        rgba.format,\n        texType,\n        filtering\n      );\n\n    if (velocity == null)\n      velocity = createDoubleFBO(\n        simRes.width,\n        simRes.height,\n        rg.internalFormat,\n        rg.format,\n        texType,\n        filtering\n      );\n    else\n      velocity = resizeDoubleFBO(\n        velocity,\n        simRes.width,\n        simRes.height,\n        rg.internalFormat,\n        rg.format,\n        texType,\n        filtering\n      );\n\n    divergence = createFBO(\n      simRes.width,\n      simRes.height,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST\n    );\n    curl = createFBO(\n      simRes.width,\n      simRes.height,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST\n    );\n    pressure = createDoubleFBO(\n      simRes.width,\n      simRes.height,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST\n    );\n  }\n```\n\n----------------------------------------\n\nTITLE: Resizing Double Frame Buffer Object (FBO) in WebGL\nDESCRIPTION: This function resizes a double FBO. If the dimensions haven't changed, it returns the target. It resizes the read FBO, creates a new FBO for the write buffer, and updates the target's width, height, and texel size properties.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\nfunction resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n  if (target.width == w && target.height == h) return target;\n  target.read = resizeFBO(\n    target.read,\n    w,\n    h,\n    internalFormat,\n    format,\n    type,\n    param\n  );\n  target.write = createFBO(w, h, internalFormat, format, type, param);\n  target.width = w;\n  target.height = h;\n  target.texelSizeX = 1.0 / w;\n  target.texelSizeY = 1.0 / h;\n  return target;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Texture Asynchronously in WebGL\nDESCRIPTION: This function creates a texture, loads an image from a URL asynchronously, and updates the texture with the image data once loaded.  It initializes the texture with a default white color, sets texture parameters (min/mag filters, wrap modes), and returns an object containing the texture, width, height, and an attach function.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createTextureAsync(url) {\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGB,\n    1,\n    1,\n    0,\n    gl.RGB,\n    gl.UNSIGNED_BYTE,\n    new Uint8Array([255, 255, 255])\n  );\n\n  let obj = {\n    texture,\n    width: 1,\n    height: 1,\n    attach(id) {\n      gl.activeTexture(gl.TEXTURE0 + id);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      return id;\n    },\n  };\n\n  let image = new Image();\n  image.onload = () => {\n    obj.width = image.width;\n    obj.height = image.height;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n  };\n  image.src = url;\n\n  return obj;\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Delta X based on Aspect Ratio\nDESCRIPTION: This function corrects the delta X value based on the aspect ratio of the canvas. If the aspect ratio is less than 1, the delta is multiplied by the aspect ratio. It helps maintain consistent movement speed regardless of the canvas's shape.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_53\n\nLANGUAGE: javascript\nCODE:\n```\nfunction correctDeltaX(delta) {\n  let aspectRatio = canvas.width / canvas.height;\n  if (aspectRatio < 1) delta *= aspectRatio;\n  return delta;\n}\n```\n\n----------------------------------------\n\nTITLE: Styling the Blob Cursor\nDESCRIPTION: This CSS defines the styling for the blob cursor effect, including the container, main element, and individual blobs. It uses absolute positioning, transforms, and box shadows to create the effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/blob-cursor.mdx#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\n.container {\n  width: 100%;\n  height: 100%;\n}\n\n.main > div {\n  position: absolute;\n  will-change: transform;\n  border-radius: 50%;\n  background: lightcoral;\n  box-shadow: 10px 10px 5px 0px rgba(0, 0, 0, 0.75);\n  opacity: 0.6;\n}\n\n.main > div:nth-child(1) {\n  width: 60px;\n  height: 60px;\n}\n\n.main > div:nth-child(2) {\n  width: 125px;\n  height: 125px;\n}\n\n.main > div:nth-child(3) {\n  width: 75px;\n  height: 75px;\n}\n\n.main > div::after {\n  content: '';\n  position: absolute;\n  top: 20px;\n  left: 20px;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background: rgba(255, 0, 0, 0.8);\n}\n\n.main > div:nth-child(2)::after {\n  top: 35px;\n  left: 35px;\n  width: 35px;\n  height: 35px;\n}\n\n.main > div:nth-child(3)::after {\n  top: 25px;\n  left: 25px;\n  width: 25px;\n  height: 25px;\n}\n\n.main {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  filter: url('#blob');\n  overflow: hidden;\n  background: transparent;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  cursor: default;\n}\n```\n\n----------------------------------------\n\nTITLE: Scale Input by Pixel Ratio\nDESCRIPTION: This function, `scaleByPixelRatio`, scales a given input value by the device pixel ratio. It retrieves the device pixel ratio from `window.devicePixelRatio` or defaults to 1. The input is multiplied by the pixel ratio, and the result is rounded down to the nearest integer.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_59\n\nLANGUAGE: javascript\nCODE:\n```\nfunction scaleByPixelRatio(input) {\n  const pixelRatio = window.devicePixelRatio || 1;\n  return Math.floor(input * pixelRatio);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Delta Time in JavaScript\nDESCRIPTION: This function calculates the delta time (dt) between the current frame and the last frame. It limits the maximum dt to 0.016666 seconds to prevent issues with large time steps.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nfunction calcDeltaTime() {\n  let now = Date.now();\n  let dt = (now - lastUpdateTime) / 1000;\n  dt = Math.min(dt, 0.016666);\n  lastUpdateTime = now;\n  return dt;\n}\n```\n\n----------------------------------------\n\nTITLE: Wrap Value within Range\nDESCRIPTION: This function, `wrap`, takes a value and a minimum and maximum range, and wraps the value within that range. If the range is zero, it returns the minimum value. It uses the modulo operator to wrap the value.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_57\n\nLANGUAGE: javascript\nCODE:\n```\nfunction wrap(value, min, max) {\n  const range = max - min;\n  if (range == 0) return min;\n  return ((value - min) % range) + min;\n}\n```\n\n----------------------------------------\n\nTITLE: Update Pointer Up Data\nDESCRIPTION: This function updates the pointer's data when a mouse or touch event ends. It sets the pointer's down state to false.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_52\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updatePointerUpData(pointer) {\n  pointer.down = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Convert HSV to RGB\nDESCRIPTION: This function converts a color from HSV (Hue, Saturation, Value) format to RGB (Red, Green, Blue) format.  It uses a standard algorithm for HSV to RGB conversion.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\nfunction HSVtoRGB(h, s, v) {\n  let r, g, b, i, f, p, q, t;\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n  }\n\n  return {\n    r,\n    g,\n    b,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Touchend Event Listener\nDESCRIPTION: This snippet adds a 'touchend' event listener to the window. It iterates through the changed touches and calls `updatePointerUpData` for each, indicating the end of the touch interaction.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_49\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener('touchend', (e) => {\n  const touches = e.changedTouches;\n  let pointer = pointers[0];\n\n  for (let i = 0; i < touches.length; i++) {\n    updatePointerUpData(pointer);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Checking Texture Format Support\nDESCRIPTION: This function checks if a specific render texture format is supported by the WebGL context. It creates a texture and framebuffer, attaches the texture to the framebuffer, and then checks the framebuffer status.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function supportRenderTextureFormat(gl, internalFormat, format, type) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      internalFormat,\n      4,\n      4,\n      0,\n      format,\n      type,\n      null\n    );\n\n    const fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    return status == gl.FRAMEBUFFER_COMPLETE;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Installing Framer Motion\nDESCRIPTION: This command installs the framer-motion library, which is a dependency for the React component providing animation capabilities for the cursor effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/arrow-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion\n```\n\n----------------------------------------\n\nTITLE: Mousemove Event Listener\nDESCRIPTION: This snippet adds a 'mousemove' event listener to the window.  It retrieves pointer coordinates, scales them, and updates the pointer's movement data using a previously assigned color, likely from the first mousemove event.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_45\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener('mousemove', (e) => {\n  let pointer = pointers[0];\n  let posX = scaleByPixelRatio(e.clientX);\n  let posY = scaleByPixelRatio(e.clientY);\n  let color = pointer.color;\n\n  updatePointerMoveData(pointer, posX, posY, color);\n});\n```\n\n----------------------------------------\n\nTITLE: Install framer-motion\nDESCRIPTION: This command installs the framer-motion library, which is required for animations and transitions in the gradient cursor effect. Framer-motion is used to create smooth visual effects based on mouse movements.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/gradient-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion\n```\n\n----------------------------------------\n\nTITLE: Touchmove Event Listener\nDESCRIPTION: This snippet attaches an event listener to the window for the 'touchmove' event. It iterates through all touches, scales their coordinates, and updates pointer move data using the pointer's current color.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_48\n\nLANGUAGE: javascript\nCODE:\n```\nwindow.addEventListener(\n  'touchmove',\n  (e) => {\n    const touches = e.targetTouches;\n    let pointer = pointers[0];\n    for (let i = 0; i < touches.length; i++) {\n      let posX = scaleByPixelRatio(touches[i].clientX);\n      let posY = scaleByPixelRatio(touches[i].clientY);\n      updatePointerMoveData(pointer, posX, posY, pointer.color);\n    }\n  },\n  false\n);\n```\n\n----------------------------------------\n\nTITLE: Install dependencies with npm\nDESCRIPTION: Installs framer-motion, clsx, and tailwind-merge using npm. These packages are required for Cursify components to function correctly. framer-motion is used for animations, clsx for conditional class names, and tailwind-merge to resolve Tailwind CSS class conflicts.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/app/(docs-page)/get-started/page.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion clsx tailwind-merge\n```\n\n----------------------------------------\n\nTITLE: Initial Touchstart Event Listener\nDESCRIPTION: This snippet handles the first 'touchstart' event on the document body. It iterates through all touches, scales their coordinates, updates pointer data, and then removes the event listener. It's designed to capture the initial touch interactions and set up the interaction.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_46\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.body.addEventListener(\n  'touchstart',\n  function handleFirstTouchStart(e) {\n    const touches = e.targetTouches;\n    let pointer = pointers[0];\n\n    for (let i = 0; i < touches.length; i++) {\n      let posX = scaleByPixelRatio(touches[i].clientX);\n      let posY = scaleByPixelRatio(touches[i].clientY);\n\n      update();\n      updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n    }\n\n    // Remove this event listener after the first touchstart event\n    document.body.removeEventListener('touchstart', handleFirstTouchStart);\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Utility function using clsx and tailwind-merge\nDESCRIPTION: Defines a utility function `cn` that combines `clsx` and `tailwind-merge` to handle conditional class names and resolve conflicts between Tailwind CSS classes. This function is commonly used in React components to dynamically apply styles.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/app/(docs-page)/get-started/page.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Delta Y based on Aspect Ratio\nDESCRIPTION: This function corrects the delta Y value based on the aspect ratio of the canvas. If the aspect ratio is greater than 1, the delta is divided by the aspect ratio. It helps maintain consistent movement speed regardless of the canvas's shape.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_54\n\nLANGUAGE: javascript\nCODE:\n```\nfunction correctDeltaY(delta) {\n  let aspectRatio = canvas.width / canvas.height;\n  if (aspectRatio > 1) delta /= aspectRatio;\n  return delta;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @react-spring/web\nDESCRIPTION: This command installs the @react-spring/web dependency, which is needed for the Blob Cursor Effect component. It uses npm, the Node Package Manager.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/blob-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @react-spring/web\n```\n\n----------------------------------------\n\nTITLE: Base Vertex Shader\nDESCRIPTION: This GLSL vertex shader calculates texture coordinates and varying variables for fragment shaders. It takes aPosition as input and outputs vUv, vL, vR, vT, and vB based on the texel size.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_10\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision highp float;\n   \n       attribute vec2 aPosition;\n       varying vec2 vUv;\n       varying vec2 vL;\n       varying vec2 vR;\n       varying vec2 vT;\n       varying vec2 vB;\n       uniform vec2 texelSize;\n   \n       void main () {\n           vUv = aPosition * 0.5 + 0.5;\n           vL = vUv - vec2(texelSize.x, 0.0);\n           vR = vUv + vec2(texelSize.x, 0.0);\n           vT = vUv + vec2(0.0, texelSize.y);\n           vB = vUv - vec2(0.0, texelSize.y);\n           gl_Position = vec4(aPosition, 0.0, 1.0);\n       }\n   \n```\n\n----------------------------------------\n\nTITLE: Component Metadata Definition (Next.js)\nDESCRIPTION: Defines the metadata for the page, including the title and description, which are used for SEO and display purposes in Next.js applications.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/scaling-cursor.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const metadata = {\n  title: '3d Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Diffuse Lighting Calculation (GLSL)\nDESCRIPTION: This GLSL fragment shader snippet calculates diffuse lighting based on surface normal and light direction, clamping the result to a specific range. It normalizes the normal vector, defines a light direction, calculates the dot product for diffuse lighting, and applies the diffuse lighting to the color.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_17\n\nLANGUAGE: GLSL\nCODE:\n```\nvec3 n = normalize(vec3(dx, dy, length(texelSize)));\nvec3 l = vec3(0.0, 0.0, 1.0);\n\nfloat diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\nc *= diffuse;\n#endif\n\nfloat a = max(c.r, max(c.g, c.b));\ngl_FragColor = vec4(c, a);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Metadata (Next.js)\nDESCRIPTION: This snippet defines the metadata for a Next.js page. It includes the title and description, which are used for SEO and page identification. The title is 'Character Cursor Effect', and the description explains the purpose of the component.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/character-cursor.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const metadata = {\n  title: 'Character Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Copy Fragment Shader\nDESCRIPTION: This GLSL fragment shader copies the color from the input texture to the output.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_13\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision mediump float;\n       precision mediump sampler2D;\n   \n       varying highp vec2 vUv;\n       uniform sampler2D uTexture;\n   \n       void main () {\n           gl_FragColor = texture2D(uTexture, vUv);\n       }\n   \n```\n\n----------------------------------------\n\nTITLE: Metadata Export (TypeScript)\nDESCRIPTION: Exports metadata for the Springy Cursor Effect component, including the title and description. This metadata is likely used for SEO or other documentation purposes. The title is 'Springy Cursor Effect' and the description provides a brief overview of the component's functionality.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/springy-cursor.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const metadata = {\n  title: 'Springy Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Utility function for Tailwind CSS class merging (utils.tsx)\nDESCRIPTION: This utility function, `cn`, uses `clsx` and `tailwind-merge` to conditionally apply and merge Tailwind CSS classes. It takes a variable number of `ClassValue` inputs and returns a merged class string, ensuring proper CSS class application and conflict resolution.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/README.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n----------------------------------------\n\nTITLE: Component Code Preview (Markdown/JSX)\nDESCRIPTION: Renders a code preview for the 'springy-cursor' component.  This indicates the existence of a reusable 'ComponentCodePreview' component that is being used to display the code for the 'springy-cursor' component. It implies the use of JSX or similar syntax.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/springy-cursor.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<ComponentCodePreview name='springy-cursor' />\n```\n\n----------------------------------------\n\nTITLE: Component Code Preview: Trail Cursor\nDESCRIPTION: Renders a code preview component named `trail-cursor`, presumably showcasing the usage or implementation of the trail cursor effect component. This assumes that `ComponentCodePreview` is a custom component.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/trail-cursor.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<ComponentCodePreview name='trail-cursor' />\n```\n\n----------------------------------------\n\nTITLE: React Component Preview: Snowflake Cursor\nDESCRIPTION: This JSX snippet includes a component called 'snowflake-cursor' using the ComponentCodePreview component. It is responsible for rendering and displaying the interactive Snowflake Cursor Effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/snowflake-cursor.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<ComponentCodePreview name='snowflake-cursor' />\n```\n\n----------------------------------------\n\nTITLE: Component Code Preview\nDESCRIPTION: Renders a preview of the 'scaling-cursor' component. This snippet indicates that a component named `ComponentCodePreview` is used to display the code and its output.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/scaling-cursor.mdx#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n<ComponentCodePreview name='scaling-cursor' />\n```\n\n----------------------------------------\n\nTITLE: Component Code Preview\nDESCRIPTION: Renders a live preview of the 'follow-cursor' React component. This component likely renders a functional example showcasing the described effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/follow-cursor.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<ComponentCodePreview name='follow-cursor' />\n```\n\n----------------------------------------\n\nTITLE: Metadata Export: Trail Cursor Effect\nDESCRIPTION: Exports metadata for the Trail Cursor Effect component, including title and description, which is commonly used for SEO and documentation purposes.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/trail-cursor.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const metadata = {\n  title: 'Trail Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Display Fragment Shader\nDESCRIPTION: This GLSL fragment shader displays the texture with optional shading and dithering. It calculates lighting based on neighboring pixels and applies dithering to reduce banding.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_16\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision highp float;\n       precision highp sampler2D;\n   \n       varying vec2 vUv;\n       varying vec2 vL;\n       varying vec2 vR;\n       varying vec2 vT;\n       varying vec2 vB;\n       uniform sampler2D uTexture;\n       uniform sampler2D uDithering;\n       uniform vec2 ditherScale;\n       uniform vec2 texelSize;\n   \n       vec3 linearToGamma (vec3 color) {\n           color = max(color, vec3(0));\n           return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n       }\n   \n       void main () {\n           vec3 c = texture2D(uTexture, vUv).rgb;\n   \n       #ifdef SHADING\n           vec3 lc = texture2D(uTexture, vL).rgb;\n           vec3 rc = texture2D(uTexture, vR).rgb;\n           vec3 tc = texture2D(uTexture, vT).rgb;\n           vec3 bc = texture2D(uTexture, vB).rgb;\n   \n           float dx = length(rc) - length(lc);\n           float dy = length(tc) - length(bc);\n   \n\n```\n\n----------------------------------------\n\nTITLE: Clear Fragment Shader\nDESCRIPTION: This GLSL fragment shader multiplies the color from the input texture by a specified value, effectively clearing or dimming the texture.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_14\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision mediump float;\n       precision mediump sampler2D;\n   \n       varying highp vec2 vUv;\n       uniform sampler2D uTexture;\n       uniform float value;\n   \n       void main () {\n           gl_FragColor = value * texture2D(uTexture, vUv);\n       }\n   \n```\n\n----------------------------------------\n\nTITLE: Blur Vertex Shader\nDESCRIPTION: This GLSL vertex shader calculates texture coordinates for a blur effect. It is similar to the base vertex shader but includes an offset for the blurred samples.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_11\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision highp float;\n   \n       attribute vec2 aPosition;\n       varying vec2 vUv;\n       varying vec2 vL;\n       varying vec2 vR;\n       uniform vec2 texelSize;\n   \n       void main () {\n           vUv = aPosition * 0.5 + 0.5;\n           float offset = 1.33333333;\n           vL = vUv - texelSize * offset;\n           vR = vUv + texelSize * offset;\n           gl_Position = vec4(aPosition, 0.0, 1.0);\n       }\n   \n```\n\n----------------------------------------\n\nTITLE: Adding Keywords to Shader Source\nDESCRIPTION: This function adds preprocessor directives (defines) to the shader source code based on the provided keywords. This allows for conditional compilation within the shader.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n  function addKeywords(source, keywords) {\n    if (keywords == null) return source;\n    let keywordsString = '';\n    keywords.forEach((keyword) => {\n      keywordsString += '#define ' + keyword + '\\n';\n    });\n\n    return keywordsString + source;\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Divergence Calculation (GLSL)\nDESCRIPTION: This GLSL fragment shader calculates the divergence of a velocity field. It samples the velocity texture at the current fragment and its neighboring fragments (left, right, top, bottom) to compute the divergence using a finite difference approximation.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_20\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision mediump float;\nprecision mediump sampler2D;\n\nvarying highp vec2 vUv;\nvarying highp vec2 vL;\nvarying highp vec2 vR;\nvarying highp vec2 vT;\nvarying highp vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n    float L = texture2D(uVelocity, vL).x;\n    float R = texture2D(uVelocity, vR).x;\n    float T = texture2D(uVelocity, vT).y;\n    float B = texture2D(uVelocity, vB).y;\n\n    vec2 C = texture2D(uVelocity, vUv).xy;\n    if (vL.x < 0.0) { L = -C.x; }\n    if (vR.x > 1.0) { R = -C.x; }\n    if (vT.y > 1.0) { T = -C.y; }\n    if (vB.y < 0.0) { B = -C.y; }\n\n    float div = 0.5 * (R - L + T - B);\ngl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Curl Calculation (GLSL)\nDESCRIPTION: This GLSL fragment shader calculates the curl (vorticity) of a velocity field. It samples the velocity texture at the current fragment and its neighboring fragments (left, right, top, bottom) to compute the curl using a finite difference approximation.  The result is then halved before being assigned to the output color's x component.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_21\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision mediump float;\nprecision mediump sampler2D;\n\nvarying highp vec2 vUv;\nvarying highp vec2 vL;\nvarying highp vec2 vR;\nvarying highp vec2 vT;\nvarying highp vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n    float L = texture2D(uVelocity, vL).y;\n    float R = texture2D(uVelocity, vR).y;\n    float T = texture2D(uVelocity, vT).x;\n    float B = texture2D(uVelocity, vB).x;\n    float vorticity = R - L - T + B;\ngl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fragment Shader: Advection (GLSL)\nDESCRIPTION: This GLSL fragment shader performs advection, moving texels based on a velocity field. It reads the velocity from a velocity texture and uses it to offset the UV coordinates when sampling the source texture. It supports optional manual filtering and also applies dissipation.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_19\n\nLANGUAGE: GLSL\nCODE:\n```\nprecision highp float;\nprecision highp sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform vec2 dyeTexelSize;\nuniform float dt;\nuniform float dissipation;\n\nvec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n    vec2 st = uv / tsize - 0.5;\n\n    vec2 iuv = floor(st);\n    vec2 fuv = fract(st);\n\n    vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n    vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n    vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n    vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n    return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n}\n\nvoid main () {\n#ifdef MANUAL_FILTERING\n    vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n    vec4 result = bilerp(uSource, coord, dyeTexelSize);\n#else\n    vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n    vec4 result = texture2D(uSource, coord);\n#endif\n    float decay = 1.0 + dissipation * dt;\ngl_FragColor = result / decay;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering the Character Cursor Component\nDESCRIPTION: This snippet shows how to render a `ComponentCodePreview` component with the name 'character-cursor'.  It likely imports and uses a custom component to display a preview of the character cursor effect component, as per the project's UI.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/character-cursor.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<ComponentCodePreview name='character-cursor' />\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies with npm\nDESCRIPTION: This command installs the necessary dependencies for the project, including framer-motion, clsx, and tailwind-merge. framer-motion is used for animations, clsx for conditional class names, and tailwind-merge for merging Tailwind CSS classes.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion clsx tailwind-merge\n```\n\n----------------------------------------\n\nTITLE: Installing framer-motion with npm\nDESCRIPTION: This command installs the framer-motion library using npm. framer-motion is a dependency required for the click cursor effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/clickeffect-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion\n```\n\n----------------------------------------\n\nTITLE: Install Framer Motion\nDESCRIPTION: This command installs the framer-motion library, which is a dependency for the magnetic cursor effect component. Framer Motion is used to handle the animations and transitions of the cursor effect.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/magnetic-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install framer-motion\n```\n\n----------------------------------------\n\nTITLE: Installing lucide-react dependency\nDESCRIPTION: This command installs the `lucide-react` package, which is likely used for icons or other UI elements within the React component.  This is a necessary dependency to use the component.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/texticon-cursor.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install lucide-react\n```\n\n----------------------------------------\n\nTITLE: Export useFluidCursor Function\nDESCRIPTION: This line exports the `useFluidCursor` function as the default export of the module.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_61\n\nLANGUAGE: javascript\nCODE:\n```\nexport default useFluidCursor;\n```\n\n----------------------------------------\n\nTITLE: Metadata for Follow Cursor Effect\nDESCRIPTION: Defines the metadata for the 'Follow Cursor Effect' component, including the title and a brief description. This metadata is commonly used for SEO and component documentation purposes.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/follow-cursor.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const metadata = {\n  title: 'Follow Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Metadata Export for Snowflake Cursor Effect\nDESCRIPTION: This JavaScript snippet exports metadata for a web page or component related to a Snowflake Cursor Effect. It includes the title and description, which are used for SEO and user understanding.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/snowflake-cursor.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const metadata = {\n  title: 'Snowflake Cursor Effect',\n  description:\n    'An interactive React component that adds a dynamic bubble effect, visually tracking cursor movement in real time.',\n};\n```\n\n----------------------------------------\n\nTITLE: Color Fragment Shader\nDESCRIPTION: This GLSL fragment shader sets the output color to a specified uniform color.\nSOURCE: https://github.com/ui-layouts/cursify/blob/main/content/components/fluid-cursor.mdx#_snippet_15\n\nLANGUAGE: GLSL\nCODE:\n```\n       precision mediump float;\n   \n       uniform vec4 color;\n   \n       void main () {\n           gl_FragColor = color;\n       }\n   \n```"
  }
]