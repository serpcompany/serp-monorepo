[
  {
    "owner": "ldqk",
    "repo": "masuit.tools",
    "content": "TITLE: Utilizing Collection Extension Methods in C#\nDESCRIPTION: Demonstrates a comprehensive set of collection extension methods provided by Masuit.Tools for `List<T>`, `Dictionary<TKey, TValue>`, `IEnumerable<T>`, and `IQueryable<T>`. Features include conditional adding (`AddRangeIf`, `AddRangeIfNotContains`), conditional removal (`RemoveWhere`), inserting elements (`InsertAfter`), safe dictionary conversions (`ToDictionarySafety`, `ToConcurrentDictionary`), conditional dictionary access/assignment, dictionary add/update/get-or-add operations (`AddOrUpdate`, `GetOrAdd`), DataTable conversions (`ToDataTable`, `AddIdentityColumn`, `HasRows`, `ToList`), async operations (`ForeachAsync`, `ForAsync`, `SelectAsync`), string joining (`Join`), safe aggregation (`MaxOrDefault`, `MinOrDefault`), standard deviation calculation (`StandardDeviation`), pagination (`ToPagedList`, `ToPagedListAsync`), set operations based on properties (`ExceptBy`, `IntersectBy`), sequence equality checks (`SequenceEqual`), random ordering (`OrderByRandom`), finding intersections across multiple collections (`IntersectAll`), changing element index (`ChangeIndex`), and finding percentile elements (`Percentile`).\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar list = new List<string>()\n{\n    \"1\", \"3\", \"3\", \"3\"\n};\nlist.AddRangeIf(s => s.Length > 1, \"1\", \"11\"); // 将被添加元素中的长度大于1的元素添加到list\nlist.AddRangeIfNotContains(\"1\", \"11\"); // 将被添加元素中不包含的元素添加到list\nlist.RemoveWhere(s => s.Length < 1); // 将集合中长度小于1的元素移除\nlist.InsertAfter(0, \"2\"); // 在第一个元素之后插入\nlist.InsertAfter(s => s == \"1\", \"2\"); // 在元素\"1\"后插入\n\nvar dic = list.ToDictionarySafety(s => s); // 安全的转换成字典类型，当键重复时只添加一个键\nvar dic = list.ToConcurrentDictionary(s => s); // 转换成并发字典类型，当键重复时只添加一个键\nvar dic = list.ToDictionarySafety(s => s, s => s.GetHashCode()); // 安全的转换成字典类型，当键重复时只添加一个键\nvar v = dic[x => x.Key.Contains(\"1\")]; // 字典根据条件取值\ndic[x => x.Key.Contains(\"1\")] = 2; // 字典根据条件赋值\nvar v = dic[(key, value) => key.Contains(\"1\")]; // 字典根据条件取值\ndic[(key, value) => key.Contains(\"1\")] = 2; // 字典根据条件赋值\nvar v = dic[key => key.Contains(\"1\")]; // 字典根据key条件取值\ndic[key => key.Contains(\"1\")] = 2; // 字典根据key条件赋值\nvar v = dic[value => value > 0]; // 字典根据value条件取值\ndic[value => value > 0] = 2; // 字典根据value条件赋值\ndic.AddOrUpdate(\"4\", 4); // 添加或更新键值对\ndic.AddOrUpdate(new Dictionary<string, int>()\n{\n    [\"5\"] = 5, [\"55\"] = 555\n}); // 批量添加或更新键值对\ndic.AddOrUpdate(\"5\", 6, (s, i) => 66); // 如果是添加，则值为6，若更新则值为66\ndic.AddOrUpdate(\"5\", 6, 666); // 如果是添加，则值为6，若更新则值为666\ndic.GetOrAdd(\"7\", 77); // 字典获取或添加元素\ndic.GetOrAdd(\"7\", () => 77); // 字典获取或添加元素\ndic.AsConcurrentDictionary(); // 普通字典转换成并发字典集合\n\nvar table = list.ToDataTable(); // 转换成DataTable类型\ntable.AddIdentityColumn(); //给DataTable增加一个自增列\ntable.HasRows(); // 检查DataTable 是否有数据行\ntable.ToList<T>(); // datatable转List\nvar set = list.ToHashSet(s => s.Name);// 转HashSet\nvar cts = new CancellationTokenSource(100); //取消口令\nawait list.ForeachAsync(async i =>\n{\n    await Task.Delay(100);\n    Console.WriteLine(i);\n}, cts.Token); // 异步foreach\n\nawait list.ForAsync(async (item, index) =>\n{\n    await Task.Delay(100);\n    Console.WriteLine(item + \"_\" + index);\n}, cts.Token); // 异步for，带索引编号\nawait list.SelectAsync(async i =>\n{\n    await Task.Delay(100);\n    return i * 10;\n}); // 异步Select\nawait list.SelectAsync(async (item, index) =>\n{\n    await Task.Delay(100);\n    return item * 10;\n}); // 异步Select，带索引编号\nstring s = list.Join(\",\");//将字符串集合连接成逗号分隔的单字符串\nvar max = list.MaxOrDefault(); // 取最大值，当集合为空的时候不会报错\nvar max = list.MaxOrDefault(selector); // 取最大值，当集合为空的时候不会报错\nvar max = list.MaxOrDefault(selector, default); // 取最大值，当集合为空的时候不会报错\nvar max = list.MinOrDefault(); // 取最小值，当集合为空的时候不会报错\nvar max = list.MinOrDefault(selector); // 取最小值，当集合为空的时候不会报错\nvar max = list.MinOrDefault(selector, default); // 取最小值，当集合为空的时候不会报错\nvar stdDev = list.Select(s => s.ConvertTo<int>()).StandardDeviation(); // 求标准差\n\nvar pages = queryable.ToPagedList(1, 10); // 分页查询\nvar pages = await queryable.ToPagedListAsync(1, 10); // 分页查询\n\nvar nums = Enumerable.Range(1, 10).ExceptBy(Enumerable.Range(5, 10), i => i); // 按字段取差集\nvar nums = Enumerable.Range(1, 10).IntersectBy(Enumerable.Range(5, 10), i => i); // 按字段取交集\nvar nums = Enumerable.Range(1, 10).SequenceEqual(Enumerable.Range(5, 10), i => i); // 判断序列相等\nvar nums = Enumerable.Range(1, 10).OrderByRandom(); // 随机排序\n\n// 多个集合取交集\nvar list = new List<List<MyClass>>(){\n    new List<MyClass>(){\n        new MyClass(){Name=\"aa\",Age=11},\n        new MyClass(){Name=\"bb\",Age=12},\n        new MyClass(){Name=\"cc\",Age=13},\n    },\n    new List<MyClass>(){\n        new MyClass(){Name=\"bb\",Age=12},\n        new MyClass(){Name=\"cc\",Age=13},\n        new MyClass(){Name=\"dd\",Age=14},\n    },\n    new List<MyClass>(){\n        new MyClass(){Name=\"cc\",Age=13},\n        new MyClass(){Name=\"dd\",Age=14},\n        new MyClass(){Name=\"ee\",Age=15},\n    },\n};\nvar sect = list.IntersectAll(m => m.Name); // new MyClass(){Name=\"cc\",Age=13}\n\nvar list = new List<List<int>>(){\n    new(){1,2,3},\n    new(){2,3,4},\n    new(){3,4,5}\n};\nvar sect = list.IntersectAll();// [3]\n\n// 集合元素改变其索引位置\nlist.ChangeIndex(item, 3); // 将元素item的索引位置变为第3个\nlist.ChangeIndex(t => t.Id == \"123\", 2); // 将id为123的元素的索引位置变为第2个\n\nvar item = list.Percentile(50); // 取第50%分位数的元素\n```\n\n----------------------------------------\n\nTITLE: Using Extension Methods for IDistributedCache in C#\nDESCRIPTION: Presents a set of generic extension methods for `IDistributedCache` instances. These methods simplify common caching operations such as `Get<T>`, `GetOrAdd<T>` (with value or factory), `Set<T>`, and `AddOrUpdate<T>`, providing a type-safe and more concise way to interact with the distributed cache.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\nvar item=cache.Get<T>(key); // 获取值\nvar item=cache.GetOrAdd<T>(key,value); // 获取或添加值\nvar item=cache.GetOrAdd<T>(key,valueFactory); // 获取或添加值\ncache.Set<T>(key,value); // 设置值\ncache.AddOrUpdate<T>(key,value,valueFactory); // 添加或更新值\n```\n\n----------------------------------------\n\nTITLE: Tracking Entity Changes and NoLock Queries in Entity Framework Core in C#\nDESCRIPTION: These snippets provide methods for tracking entity changes (add/update/remove) within a DBContext and demonstrate using NoLock-style reading in SQL Server and other supported databases via transaction control or interceptor. Includes both per-entity and global change-tracking, as well as async query variants optimized for dirty-read scenarios. Utilizes provider-specific dependency injection and custom extension methods.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvar changes=dbContext.GetChanges<TEntity>();//获取变更字段信息\nvar added=dbContext.GetAdded<TEntity>();//获取添加的实体字段信息\nvar removed=dbContext.GetRemoved<TEntity>();//获取被移除的实体字段信息  \nvar allchanges=dbContext.GetAllChanges<TEntity>();//获取增删改的实体字段信息  \n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar changes=dbContext.GetChanges();//获取变更字段信息\nvar added=dbContext.GetAdded();//获取添加的实体字段信息\nvar removed=dbContext.GetRemoved();//获取被移除的实体字段信息  \nvar allchanges=dbContext.GetAllChanges();//获取增删改的实体字段信息  \n```\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddDbContext<TContext>(opt => opt.UseSqlserver(\"ConnString\", builder => builder.AddInterceptors(new WithNoLockInterceptor(true))); // 启用全局nolock查询\nservices.AddDbContext<TContext>(opt => opt.UseSqlserver(\"ConnString\", builder => builder.AddInterceptors(new WithNoLockInterceptor())); // 按需启用全局nolock查询\n\n// 按需启用全局nolock查询，执行单个nolock查询\nawait dbContext.Users.Where(x=>x.Name==\"aaa\").WithNolock().ToListAsync();\n```\n\nLANGUAGE: csharp\nCODE:\n```\ndbcontext.NoLock(ctx=>ctx.Users...ToList()); // 开启一个nolock上下文，上下文范围内自动nolock\n\n// 执行单个nolock查询\nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").ToListWithNoLockAsync(); \nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").FirstOrDefaultWithNoLockAsync(); \nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").SingleOrDefaultWithNoLockAsync(); \nawait dbcontext.Users.AnyWithNoLockAsync(x=>x.Name==\"aaa\"); \nawait dbcontext.Users.AllWithNoLockAsync(x=>x.Name==\"aaa\"); \nawait dbcontext.Users.CountWithNoLockAsync(x=>x.Name==\"aaa\"); \n\n// 如果在上下文开启了重试机制,执行单个nolock查询需要开启策略查询\nservices.AddDbContext<TContext>(opt => opt.UseNpgsql(\"ConnString\", builder => builder.EnableRetryOnFailure(10));\n\n// 执行策略\ndbcontext.ExecutionStrategy(stg=>stg.NoLock(ctx=>ctx.Users...ToList()));\ndbcontext.ExecutionStrategy(ctx=>ctx.Users.Where(x=>x.Name==\"aaa\").ToListWithNoLockAsync());\n```\n\n----------------------------------------\n\nTITLE: Exporting Data to Excel using Masuit.Tools.Excel in C#\nDESCRIPTION: These examples demonstrate how to export lists or DataTable objects to Excel spreadsheets, including custom column definitions and support for image columns. Dependencies include the Masuit.Tools.Excel package. The inputs can be anonymous objects or DataTable, and options include sheet naming and password protection for output files. Outputs are Excel files or streams for further use.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nvar stream=list.Select(item=>new{\n    姓名=item.Name,\n    年龄=item.Age,\n    item.Gender,\n    Avatar=Image.FromStream(filestream) //图片列\n}).ToDataTable().ToExcel(\"Sheet1\"); //自定义列名导出\nvar stream=list.ToDataTable(\"Sheet1\").ToExcel(\"文件密码\");\n```\n\n----------------------------------------\n\nTITLE: Stream and MemoryStream Operations and Extensions in C#\nDESCRIPTION: This set of snippets provides stream utilities for saving/copying streams, stream conversion (to array or MemoryStream), memory pooling, large-memory stream handlers, and checksum calculations. Includes both synchronous and asynchronous usage, with helpful comments for recommended usage scenarios (e.g., very large memory streams). Requires appropriate using directives and classes such as MemoryStream, PooledMemoryStream, LargeMemoryStream, and extension methods for FileStreams.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nstream.SaveAsMemoryStream(); // 任意流转换成内存流\nstream.ToArray(); // 任意流转换成二进制数组\nstream.ToArrayAsync(); // 任意流转换成二进制数组\nstream.ShuffleCode(); // 流洗码，在流的末端随即增加几个空字节，重要数据请谨慎使用，可能造成流损坏\n\n// 池化内存流，用法与MemorySteam保持一致\nusing var ms=PooledMemoryStream();\n\n// 大型内存流,最大可支持1TB内存数据，推荐当数据流大于2GB时使用，用法与MemorySteam保持一致\nusing var ms=LargeMemoryStream();\n\n//文件流快速复制\nFileStream fs = new FileStream(@\"D:\\boot.vmdk\", FileMode.OpenOrCreate, FileAccess.ReadWrite);\n{\n        //fs.CopyToFile(@\"D:\\1.bak\");//同步复制大文件\n        fs.CopyToFileAsync(@\"D:\\1.bak\");//异步复制大文件\n        string md5 = fs.GetFileMD5Async().Result;//异步获取文件的MD5\n        string sha1 = fs.GetFileSha1();//异步获取文件的SHA1\n}\nmemoryStream.SaveFile(\"filename\"); // 将内存流转储成文件\n```\n\n----------------------------------------\n\nTITLE: Type Conversion, Primitive and String Utilities in C#\nDESCRIPTION: This group of snippets offers utilities for conversion between types, truncation, primitive and simple type checking, JSON serialization, null/empty checks, string manipulation, and encoding conversions. It supports fast and safe string containment checks, conversion between half/full width characters, emoji detection, measurement string rendering width, and more. Dependencies include core .NET types and possibly Newtonsoft.Json for JSON handling.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n1.2345678901.Digits8(); // 将小数截断为8位\n1.23.ConvertTo<int>(); // 小数转int\n1.23.ConvertTo<T>(); // 小数转T基本类型\nbool b=1.23.TryConvertTo<T>(out result); // 小数转T基本类型\nvar num=1.2345.ToDecimal(2); //转decimal并保留两位小数\n\n1.23.ChangeTypeTo<T>(); //小数转T基本类型,ConvertTo和ChangeTypeTo的区别在于：ConvertTo只适用于基元类型的互转，ChangeTypeTo不仅适用于基元类型的互转还支持数组、字符串的转换(Parse)，ConvertTo的性能更高\n\ntype.IsPrimitive(); // 判断类型是否是值类型\ntype.IsSimpleType(); // 判断类型是否是常见的简单类型，基元类型为 Boolean、 Byte、 SByte、 Int16、 UInt16、 Int32、 UInt32、 Int64、 UInt64、 IntPtr、 UIntPtr、 Char、 Double 、 Single、枚举、Nullable<T>。\ntype.IsSimpleArrayType(); // 判断类型是否是常见类型的 数组形式 类型\ntype.IsSimpleListType(); // 判断类型是否是常见类型的 泛型形式 类型\n\nmyClass.ToJsonString(); //序列化成json字符串\n\nstring s=null;\nbool b=s.IsNullOrEmpty();//判断字符串是否为空\nbool b=s.NotNullOrEmpty();//判断字符串不为空\nstring str=s.IfNullOrEmpty(\"aa\");//如果为空则返回aa\nstring str=s.IfNullOrEmpty(()=>\"aa\");//如果为空则返回aa,延迟执行\n\nbool contains=s.Contains(new[]{\"aa\",\"bb\"});// 检测字符串中是否包含列表中的关键词(快速匹配)\nbool contains=s.ContainsSafety(new[]{\"aa\",\"bb\"});// 检测字符串中是否包含列表中的关键词(安全匹配)，没有计时攻击风险\nbool contains=s.EndsWith(new[]{\"aa\",\"bb\"});// 检测字符串中是否以列表中的任意关键词结尾\nbool contains=s.StartsWith(new[]{\"aa\",\"bb\"});// 检测字符串中是否以列表中的任意关键词开头\n\nstring str=s.Take(10); // 取字符串前10个字符\n\nbool emoji=s.MatchEmoji(); // 匹配字符串是否包含emoji\n\nvar width=str.StringWidth(14); // 计算字符串以14号字体大小的渲染宽度像素\nvar width=str.StringWidth(\"微软雅黑\",14); // 计算字符串以14号字体大小的微软雅黑字体的渲染宽度像素\nvar width=str.CharacterCount(); // 获取字符串的字符数\nvar width=str.BytesCount(); // 获取字符串的字节数\n\n\nvar s = \"🤔1🥳a👨‍👩‍👧‍👦啊\";\nConsole.WriteLine(\"长度：\" + s.Length); // 18\nConsole.WriteLine(\"宽度：\" + s.StringWidth()); // 7\nConsole.WriteLine(\"字节数：\" + s.BytesCount()); // 38\nConsole.WriteLine(\"字符数：\" + s.CharacterCount()); // 6\n\nvar s=\"aa\".ToSBC(); // 转换为全角\nvar s=\"ａａ\".ToDBC(); // 转换为半角\n```\n\n----------------------------------------\n\nTITLE: Extending DateTime and Time Range Calculations in C#\nDESCRIPTION: This collection of code snippets provides extension methods for advanced DateTime calculations and time range operations in C#. The utilities include week/quarter/month/year recognition, high-precision time stamps (milliseconds to nanoseconds), in-range checks, parsing, and time range unions/intersections. They also include different calendar period retrievals (solar/lunar/custom). Dependencies may include custom extension classes like DateTimeRange, and key parameters often involve DateTime values, enums for range type, and custom class objects. Input is primarily DateTime or string as date, output varies from numbers to time range objects.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nvar weeks=DateTime.Now.GetWeekAmount(); // 获取当前所在年一共有多少周\nvar week = DateTime.Now.WeekOfYear(); // 获取当前所在年的第几周\nvar week = DateTime.Now.WeekOfYear(DayOfWeek.Monday); // 获取当前所在年的第几周,并指定星期几是每周第一天\n\ndouble milliseconds = DateTime.Now.GetTotalMilliseconds();// 获取毫秒级时间戳\ndouble microseconds = DateTime.Now.GetTotalMicroseconds();// 获取微秒级时间戳\ndouble nanoseconds = DateTime.Now.GetTotalNanoseconds();// 获取纳秒级时间戳\ndouble seconds = DateTime.Now.GetTotalSeconds();// 获取秒级时间戳\ndouble minutes = DateTime.Now.GetTotalMinutes();// 获取分钟级时间戳\n\nvar indate=DateTime.Parse(\"2020-8-3\").In(DateTime.Parse(\"2020-8-2\"),DateTime.Parse(\"2020-8-4\"));//true\nDateTime time=\"2021-1-1 8:00:00\".ToDateTime(); //字符串转DateTime\n\n//时间段计算工具\nvar range = new DateTimeRange(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-5\"));\nrange.Union(DateTime.Parse(\"2020-8-4\"), DateTime.Parse(\"2020-8-6\")); //连接两个时间段，结果：2020-8-3~2020-8-6\nrange.In(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-6\"));//判断是否在某个时间段内，true\nvar (intersected,range2) = range.Intersect(DateTime.Parse(\"2020-8-4\"), DateTime.Parse(\"2020-8-6\"));//两个时间段是否相交，(true,2020-8-3~2020-8-4)\nrange.Contains(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-4\"));//判断是否包含某个时间段，true\n\nrange.GetUnionSet(List<DateTimeRange>); // 根据某个时间段查找在某批时间段中的最大并集\nrange.GetMaxTimePeriod(List<DateTimeRange>); // 获取一批时间段内存在相互重叠的最大时间段\n\nvar range = DateTime.Now.GetCurrentWeek(); // 获取当前时间所在周的时间区间：2024-08-05 00:00:00~2024-08-11 23:59:59\nvar range = DateTime.Now.GetCurrentMonth(); // 获取当前时间所在月的时间区间：2024-08-01 00:00:00~2024-08-31 23:59:59\nvar range = DateTime.Now.GetCurrentYear(); // 获取当前时间所在年的时间区间：2024-01-01 00:00:00~2024-12-31 23:59:59\nvar range = DateTime.Now.GetCurrentQuarter(); // 获取当前时间所在季度的时间区间：2024-07-01 00:00:00~2024-09-30 23:59:59\nvar range = DateTime.Now.GetCurrentLunarMonth(); // 获取当前时间所在农历月的时间区间：2024-08-04 00:00:00~2024-09-02 23:59:59\nvar range = DateTime.Now.GetCurrentLunarQuarter(); // 获取当前时间所在农历季度的时间区间：2024-08-04 00:00:00~2024-10-31 23:59:59\nvar range = DateTime.Now.GetCurrentLunarYaer(); // 获取当前时间所在农历年的时间区间：2024-02-10 00:00:00~2025-01-28 23:59:59\nvar range = DateTime.Now.GetCurrentSolar(); // 获取当前时间所在季节的时间区间：2024-08-07 00:00:00~2024-11-06 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Week); // 获取当前时间所在周的时间区间：2024-08-05 00:00:00~2024-08-11 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Month); // 获取当前时间所在月的时间区间：2024-08-01 00:00:00~2024-08-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Quarter); // 获取当前时间所在季度的时间区间：2024-07-01 00:00:00~2024-09-30 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Year); // 获取当前时间所在年的时间区间：2024-01-01 00:00:00~2024-12-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarMonth); // 获取当前时间所在农历月的时间区间：2024-08-04 00:00:00~2024-09-02 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarQuarter); // 获取当前时间所在农历季度的时间区间：2024-08-04 00:00:00~2024-10-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarYear); // 获取当前时间所在农历年的时间区间：2024-02-10 00:00:00~2025-01-28 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Solar); // 获取当前时间所在季节的时间区间：2024-08-07 00:00:00~2024-11-06 23:59:59\n\n...\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Image Manipulations in C#\nDESCRIPTION: Illustrates various image processing capabilities using Masuit.Tools and likely SixLabors.ImageSharp (implied by `Image.Load`). Examples include saving a Base64 string as an image, creating thumbnails, converting to black and white, cropping, cropping and resizing, resizing, horizontal/vertical mirroring, adjusting brightness/darkness, color inversion, applying a relief effect, extracting frames from a GIF, and adding text or image watermarks.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\"base64\".SaveDataUriAsImageFile();// 将Base64编码转换成图片\n\nusing Image image = Image.Load(@\"D:\\1.jpg\");\nimage.MakeThumbnail(@\"D:\\2.jpg\", 120, 80,ResizeMode.BoxPad);//生成缩略图\n\nvar newBmp = image.BWPic(image.Width, image.Height);//转换成黑白\nvar newBmp = image.CutImage(new Rectangle(0, 0, 1600, 900));//裁剪\nvar newBmp = image.CutAndResize(new Rectangle(0, 0, 1600, 900), 160, 90);//裁剪并缩放\nvar newBmp = image.ResizeImage(160, 90);//改变大小\nvar newBmp = image.RevPicLR();//左右镜像\nvar newBmp = image.RevPicUD();//上下镜像\nvar newBmp =image.LDPic(10); //调整光暗\nvar newBmp =image.RePic(); //反色处理\nvar newBmp =image.Relief(); //浮雕处理\n\nvar gif = Image.Load(@\"D:\\1.gif\");\ngif.GetFrames(@\"D:\\frames\\\"); // 解压gif每帧图片\n\nvar marker=ImageWatermarker(stream);\nstream=maker.AddWatermark(\"水印文字\",\"字体文件\",字体大小,color,水印位置,边距); // 给图片添加水印\nstream=maker.AddWatermark(水印图片,水印位置,边距,字体大小,字体); // 给图片添加水印\n```\n\n----------------------------------------\n\nTITLE: Adding or Updating Entities with EF Core in C#\nDESCRIPTION: Demonstrates the `AddOrUpdate` extension method for `DbSet<T>` in Entity Framework Core, provided by Masuit.Tools. This method allows adding a new entity or updating an existing one based on a specified key selector (in this case, `t => t.Id`). It simplifies upsert operations.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// 按Id添加或更新文章实体\n/// </summary>\npublic override Post SavePost(Post t)\n{\n    DataContext.Set<Post>().AddOrUpdate(t => t.Id, t);\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Using [FromBodyOrDefault] for Flexible Model Binding in ASP.NET Core Actions (C#)\nDESCRIPTION: Provides examples of ASP.NET Core controller actions utilizing the `[FromBodyOrDefault]` attribute from `Masuit.Tools.AspNetCore`. This attribute allows action parameters (both complex models like `QueryModel` and simple types like `int` or `string`) to be bound from the query string, form data, or the request body (typically JSON), providing flexibility in how clients can send data to the endpoint. Both GET and POST methods are shown.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpGet(\"query\"),HttpPost(\"query\")]\npublic IActionResult Query([FromBodyOrDefault]QueryModel query)\n{\n    return Ok(...);\n}\n\n[HttpGet(\"query\"),HttpPost(\"query\")]\npublic IActionResult Query([FromBodyOrDefault]int id,[FromBodyOrDefault]string name)\n{\n    return Ok(...);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling BodyOrDefaultModelBinder in ASP.NET Core Startup (C#)\nDESCRIPTION: Shows the necessary configuration step to enable the `BodyOrDefaultModelBinder` in an ASP.NET Core application. Calling `app.UseBodyOrDefaultModelBinder()` within the `Configure` method of the `Startup` class (or the equivalent application configuration pipeline) registers the middleware required for the `[FromBodyOrDefault]` attribute to function correctly.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\napp.UseBodyOrDefaultModelBinder();\n```\n\n----------------------------------------\n\nTITLE: Installing Masuit.Tools.AspNetCore Package\nDESCRIPTION: Provides the command for installing the `Masuit.Tools.AspNetCore` NuGet package using the Package Manager Console in Visual Studio. This package is a prerequisite for using ASP.NET Core specific features from the Masuit.Tools library, such as the `BodyOrDefaultModelBinder`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\nPM> Install-Package Masuit.Tools.AspNetCore\n```\n\n----------------------------------------\n\nTITLE: Simplifying Recursive Include Calls in Entity Framework Core (C#)\nDESCRIPTION: Demonstrates using the `IncludeRecursive` extension method from Masuit.Tools as a concise alternative to manually chaining multiple `Include().ThenInclude()` calls for loading hierarchical data (like categories with nested children) in Entity Framework Core. Requires `Masuit.Tools` and Entity Framework Core. The first parameter specifies the recursion depth, and the second is a lambda expression selecting the navigation property.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n// 如果你现在正在写类似这样的代码：\ndbcontext.Category.Include(c=>c.Children).ThenInclude(c=>c.Children).ThenInclude(c=>c.Children).ThenInclude(c=>c.Children);\n\n// 那么可以改成这样：\ndbcontext.Category.IncludeRecursive(4, c => c.Children); // 自动Include 4次\n```\n\n----------------------------------------\n\nTITLE: Applying Custom JSON Serialization Resolvers (Newtonsoft & System.Text.Json) (C#)\nDESCRIPTION: Shows how to apply custom contract resolvers from Masuit.Tools for controlling JSON serialization/deserialization. It demonstrates configuring `JsonSerializerSettings` for Newtonsoft.Json with `DeserializeOnlyContractResolver` and `JsonSerializerOptions` for System.Text.Json with `SerializeIgnoreResolver`. This enables behavior defined by attributes like `[DeserializeOnlyJsonProperty]` or `[SerializeOnlyJsonProperty]` on DTOs.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n// Newtonsoft.Json\nJsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()\n{\n    ContractResolver = new DeserializeOnlyContractResolver() // 配置使用DeserializeOnlyContractResolver解释器\n});\n\n// System.Text.Json\nJsonSerializer.Serialize(object, new JsonSerializerOptions() { TypeInfoResolver = new SerializeIgnoreResolver() });\n```\n\n----------------------------------------\n\nTITLE: Configuring Global JSON Contract Resolver in ASP.NET Core (Newtonsoft.Json) (C#)\nDESCRIPTION: Illustrates how to configure the `DeserializeOnlyContractResolver` globally for an ASP.NET Core application using Newtonsoft.Json integration. By setting the `ContractResolver` in `AddNewtonsoftJson` options within `Startup.ConfigureServices`, the custom serialization/deserialization behavior (ignoring properties based on attributes) is applied consistently across all MVC actions. Optionally, a `NamingStrategy` like `CamelCaseNamingStrategy` can also be configured.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\n//在Startup.ConfigureServices中\nservices.AddMvc().AddNewtonsoftJson(options =>\n     {\n         var resolver = new DeserializeOnlyContractResolver();\n         resolver.NamingStrategy = new CamelCaseNamingStrategy();\n         options.SerializerSettings.ContractResolver = resolver;\n     });\n```\n\n----------------------------------------\n\nTITLE: Sending Email Asynchronously in C#\nDESCRIPTION: Demonstrates sending an email asynchronously using the `Email` class from Masuit.Tools. The example configures SMTP server details, credentials, SSL usage, recipients, subject, and body, then calls `SendAsync` with a callback function to execute upon successful sending.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew Email()\n{\n    SmtpServer = \"smtp.masuit.com\",// SMTP服务器\n    SmtpPort = 25, // SMTP服务器端口\n    EnableSsl = true,//使用SSL\n    Username = \"admin@masuit.com\",// 邮箱用户名\n    Password = \"123456\",// 邮箱密码\n    Tos = \"10000@qq.com,10001@qq.com\", //收件人\n    Subject = \"测试邮件\",//邮件标题\n    Body = \"你好啊\",//邮件内容\n}.SendAsync(s =>\n{\n    Console.WriteLine(s);// 发送成功后的回调\n});// 异步发送邮件\n```\n\n----------------------------------------\n\nTITLE: Mapping MIME Types and Extensions in C#\nDESCRIPTION: Demonstrates using the `MimeMapper` class from Masuit.Tools to map between MIME types and file extensions. `GetExtensionFromMime` converts a MIME type string (e.g., \"image/jpeg\") to its corresponding extension (e.g., \".jpg\"), and `GetMimeFromExtension` performs the reverse operation. Also shows accessing predefined MIME type constants via the `ContentType` static class or `DefaultMimeItems` collection.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar mimeMapper = new MimeMapper();\nvar ext = mimeMapper.GetExtensionFromMime(\"image/jpeg\"); // .jpg\nvar mime = mimeMapper.GetMimeFromExtension(\".jpg\"); // image/jpeg\n\nContentType常量库：\nvar type = ContentType.Exe; // application/octet-stream\nvar type = ContentType.Jpeg; // image/jpeg\nvar type = DefaultMimeItems.Items.FirstOrDefault(t => t.Extension == \"jpg\"); // image/jpeg\n```\n\n----------------------------------------\n\nTITLE: Storing and Retrieving Thread-Local Data in C#\nDESCRIPTION: Illustrates two approaches for managing thread-local temporary data. The first uses a generic `CurrentContext<T>` class with `SetData(value)` and `GetData()`. The second uses a non-generic `CurrentContext` class with `SetData(value)` and a generic `GetData<T>()` method. Both allow storing and retrieving values scoped to the current execution thread.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\nCurrentContext<T>.SetData(value);//设置值\nvar item=CurrentContext<T>.GetData();//获取值\n\nCurrentContext.SetData(value);//设置值\nvar item=CurrentContext.GetData<T>();//获取值\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Dynamic Objects in C#\nDESCRIPTION: Illustrates the creation of dynamic objects using `DynamicFactory.NewObject()` and initialization with `DynamicFactory.WithObject()`. Shows how to set and retrieve properties using both dot notation (`obj.Name`) and indexer access (`obj[\"Name\"]`), including handling nested dynamic objects and collections. Asserts demonstrate the equivalence of access methods.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\n        var obj = DynamicFactory.NewObject();\n        obj.Name = \"Masuit\";\n        obj.Age = 18;\n        obj[\"Gender\"]=\"男\"\n        obj.MyClass = DynamicFactory.WithObject(new\n        {\n            X = 10,\n            Y = 20,\n            Z = new List<int> { 1, 2, 3, 4, 5 }\n        });\n        Assert.Equal(obj.Name, obj[\"Name\"]);\n        Assert.Equal(obj[\"Gender\"], obj.Gender);\n        Assert.Equal(obj[\"MyClass\"][\"X\"], obj.MyClass.X);\n        Assert.Equal(obj.MyClass.Z[2], obj[\"MyClass\"][\"Z\"][2]);\n```\n\n----------------------------------------\n\nTITLE: Converting Objects to Dynamic Type and Modifying Properties in C#\nDESCRIPTION: Demonstrates converting an anonymous object to a dynamic type using the `.ToDynamic()` extension method. Shows how to add properties (`obj.Age = 18`), assign nested dynamic objects, and dynamically add (`+ \"Prop\"`) or remove (`- \"Prop\"`) properties using operator overloading. Asserts verify property access consistency.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\n        var obj = new\n        {\n            Name = \"Masuit\"\n        }.ToDynamic();\n        obj.Age = 18;\n        obj.MyClass = new\n        {\n            X = 10,\n            Y = 20,\n            Z = new List<int> { 1, 2, 3, 4, 5 }\n        }.ToDynamic();\n        obj.Prop = \"test\";\n        _ = obj - \"Prop\"; // 删除属性\n        _ = obj + \"Prop\"; // 增加属性\n\n        Assert.Equal(obj.Name, obj[\"Name\"]);\n        Assert.Equal(obj[\"MyClass\"][\"X\"], obj.MyClass.X);\n```\n\n----------------------------------------\n\nTITLE: Performing Reflection Operations in C#\nDESCRIPTION: Illustrates various reflection and object manipulation extension methods from Masuit.Tools. It shows getting properties (`GetProperties`), setting a property value (`SetProperty`), performing a deep clone (`DeepClone`), converting an object to a dictionary (`ToDictionary`), and converting an object to a dynamic expandable type (`ToDynamic`).\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMyClass myClass = new MyClass();\nPropertyInfo[] properties = myClass.GetProperties();// 获取属性列表\nmyClass.SetProperty(\"Email\",\"1@1.cn\");//给对象设置值\nmyClass.DeepClone(); // 对象深拷贝，带嵌套层级的\nmyClass.ToDictionary(); // 对象转字典\nmyClass.ToDynamic(); // 对象转换成动态可扩展类型\n```\n\n----------------------------------------\n\nTITLE: Enabling Chainable Method Calls on Any Type (C#)\nDESCRIPTION: Illustrates the `Next` extension method provided by Masuit.Tools, which allows applying a sequence of functions to any object in a fluent, chainable style. The first example shows chaining generic functions (`func1`, `func2`, `func3`), while the second demonstrates transforming a string through integer conversion, multiplication, and logarithm calculation using chained `Next` calls. This enhances code readability for sequential operations.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\na.Next(func1).Next(func2).Next(func3);\n\"123\".Next(s=>s.ToInt32()).Next(x=>x*2).Next(x=>Math.Log(x));\n```\n\n----------------------------------------\n\nTITLE: INI File Operations and Object Mapping in C#\nDESCRIPTION: These snippets show usage of an IniFile class for reading, writing, mapping to objects, and managing INI configuration files, including type-safe section extraction and bulk clearing/loading. Requires an absolute file path; usage involves key-value access, section querying, generic reading, and class attribute annotations for mapping. Inputs are typically strings for section/key, or generic parameters for strong typing; outputs are strings, objects, or enums.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nIniFile ini=new IniFile(\"X:\\\\filename.ini\"); // 需要绝对路径，否则会写到C:\\Windows目录下去\nini.SetValue(section,key,value); // 写值\nvar value=ini.GetValue(section,key); // 读值\nvar value=ini.GetValue<Enum>(section,key); // 读值并转换类型\nvar sections=ini.GetSections(); // 获取所有配置节\nvar section=ini.GetSection(section); // 获取配置节\nvar myclass=ini.GetSection<MyClass>(section); // 获取指定配置节并绑定到对象\nini.ClearAllSection(); // 清空所有配置节\nini.ClearSection(section); // 清空配置节\nini.Save(); // 保存ini文件\nini.Reload(); // 重新加载ini文件\n\n\nclass MyClass\n{\n    [IniProperty(\"str_value\")] // 设置别名\n    public string StringValue { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Masking Sensitive Data During JSON Serialization in C#\nDESCRIPTION: Shows how to apply automatic data masking during JSON serialization using custom `JsonConverter` attributes from Masuit.Tools. By decorating properties (`Email`, `PhoneNumber`) with `[JsonConverter(typeof(MaskEmailConverter))]` or `[JsonConverter(typeof(MaskConverter))]`, the sensitive data will be masked in the resulting JSON output. Note the requirement to use the correct namespace depending on whether Newtonsoft.Json or System.Text.Json is being used.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// Attribute的方式为json序列化时进行数据脱敏\npublic class MyClass\n{\n    [JsonConverter(typeof(MaskEmailConverter))] // 请注意命名空间，使用Newtonsoft.Json请导入Masuit.Tools.Systems命名空间，使用System.Text.Json请导入Masuit.Tools.Systems.Text.Json命名空间\n    public string Email { get; set; }\n\n    [JsonConverter(typeof(MaskConverter))] // 请注意命名空间，使用Newtonsoft.Json请导入Masuit.Tools.Systems命名空间，使用System.Text.Json请导入Masuit.Tools.Systems.Text.Json命名空间\n    public string PhoneNumber { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Masking Sensitive Information in Strings in C#\nDESCRIPTION: Illustrates using extension methods from Masuit.Tools to mask sensitive information within strings. `Mask()` provides general-purpose masking (e.g., for phone numbers), while `MaskEmail()` specifically masks email addresses, preserving the first and last characters of the username and the domain.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n\"13123456789\".Mask(); // 131****5678\n\"admin@masuit.com\".MaskEmail(); // a****n@masuit.com\n```\n\n----------------------------------------\n\nTITLE: Performing Anti-Virus Scans on Windows using C#\nDESCRIPTION: Provides examples of scanning files, directories, streams, and byte arrays for malware on Windows. Uses `WindowsDefenderScanService` (dependent on an active Windows Defender service) and `AmsiScanService` (dependent on `amsi.dll`, potentially functional even if Defender is stopped) for the scans. Comments indicate specific requirements for each service.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\n// 要求系统WindowsDefender没有被停掉\nvar result = WindowsDefenderScanService.ScanFile(@\"Y:\\1.exe\"); // 扫描文件\nvar result = WindowsDefenderScanService.ScanDirectory(@\"Y:\\\"); // 扫描文件夹\nvar result = WindowsDefenderScanService.ScanStream(stream); // 扫描文件流\n\n// 要求C:\\Windows\\System32\\amsi.dll文件存在，可在WindowsDefender停止时工作\nAmsiScanService.Scan(stream); // 扫描文件流\nAmsiScanService.Scan(@\"Y:\\1.exe\"); // 扫描文件\nAmsiScanService.Scan(bytes); // 扫描二进制数组\n```\n\n----------------------------------------\n\nTITLE: Automating Service Registration in ASP.NET Core using Attributes\nDESCRIPTION: Explains how to use the `AutoRegisterServices()` extension method (from `Masuit.Tools.AspNetCore`) on `IServiceCollection` to automatically scan assemblies and register services. Services intended for automatic registration should be decorated with the `[ServiceInject(ServiceLifetime)]` attribute, specifying their desired lifetime (e.g., `Scoped`, `Singleton`, `Transient`). This simplifies the dependency injection setup process.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\n// 自动扫描注册服务\nservices.AutoRegisterServices();\n\n// 需要自动注册的服务打上ServiceInject标记即可。\n[ServiceInject(ServiceLifetime.Scoped)]\npublic class MyClass:MyInterface{...}\n\n[ServiceInject(ServiceLifetime.Scoped)]\npublic class MyService{...}\n```\n\n----------------------------------------\n\nTITLE: Using Extension Methods for ViewDataDictionary in C#\nDESCRIPTION: Introduces generic extension methods for `ViewDataDictionary` (`ViewData`). These methods, `GetValue<T>`, `GetValueOrDefault<T>` (with default value or factory), facilitate retrieving strongly-typed values from `ViewData`, enhancing type safety and reducing boilerplate code in views or controllers.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\nvar item=ViewData.GetValue<T>(key);//获取对象\nvar item=ViewData.GetValueOrDefault<T>(key,defaultValue);//获取对象\nvar item=ViewData.GetValueOrDefault<T>(key,defaultValueFactory);//获取对象\n```\n\n----------------------------------------\n\nTITLE: Calculating String Similarity using SimHash Hamming Distance (C#)\nDESCRIPTION: Demonstrates calculating the Hamming distance between two strings using the SimHash algorithm provided by `Masuit.Tools`. The first example uses the `HammingDistance` extension method directly on strings, while the second creates `SimHash` objects first before calculating the distance. Lower Hamming distance indicates higher similarity between the input strings.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nvar dis=\"12345678\".HammingDistance(\"1234567\");\nvar dis=new SimHash(\"12345678\").HammingDistance(new SimHash(\"1234567\"));\n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 1) in C#\nDESCRIPTION: Demonstrates weighted random selection using extension methods on a list of `WeightedItem<T>` objects from Masuit.Tools. `WeightedItem()` selects a single element based on weights, and `WeightedItems(n)` selects multiple (n) elements based on their weights.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar data=new List<WeightedItem<string>>()\n{\n     new WeightedItem<string>(\"A\", 1),\n     new WeightedItem<string>(\"B\", 3),\n     new WeightedItem<string>(\"C\", 4),\n     new WeightedItem<string>(\"D\", 4),\n};\nvar item=data.WeightedItem();//按权重选出1个元素\nvar list=data.WeightedItems(2);//按权重选出2个元素\n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 2) in C#\nDESCRIPTION: Illustrates using the `WeightedSelector<T>` class from Masuit.Tools for weighted random selection. After initializing the selector with a list of `WeightedItem<T>`, `Select()` picks one item, and `SelectMultiple(n)` picks 'n' items according to their weights.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar selector = new WeightedSelector<string>(new List<WeightedItem<string>>()\n{\n    new WeightedItem<string>(\"A\", 1),\n    new WeightedItem<string>(\"B\", 3),\n    new WeightedItem<string>(\"C\", 4),\n    new WeightedItem<string>(\"D\", 4),\n});\nvar item = selector.Select();//按权重选出1个元素\nvar list = selector.SelectMultiple(3);//按权重选出3个元素\n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 3) in C#\nDESCRIPTION: Shows alternative extension methods for weighted random selection from Masuit.Tools, applied directly to a generic list. A lambda expression (`e => e.Price`) is used to specify the property representing the weight for selection. `WeightedItems(n, selector)` selects 'n' items, and `WeightedBy(selector)` selects one item.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nlist.WeightedItems(3,e=>e.Price); // 按价格权重选出3个元素\nlist.WeightedBy(e=>e.Price); // 按价格权重选出1个元素\n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers and Strings in C#\nDESCRIPTION: Shows how to use extension methods on the `Random` class provided by Masuit.Tools. `StrictNext()` generates a cryptographically strong random integer. `NextGauss()` generates a random double following a normal (Gaussian) distribution with a specified mean and standard deviation. Also demonstrates generating a random base-62 string using `NumberFormater`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nRandom rnd = new Random();\nint num = rnd.StrictNext();//产生真随机数\ndouble gauss = rnd.NextGauss(20,5);//产生正态高斯分布的随机数\nvar s = new NumberFormater(62).ToString(new Random().Next(100000, int.MaxValue));//生成随机字符串\n```\n\n----------------------------------------\n\nTITLE: Detecting File Encoding and True File Type (C#)\nDESCRIPTION: Showcases various methods from `Masuit.Tools` for detecting the text encoding and the actual file type (based on magic bytes/signature, not just the extension) of a file or stream. Examples include extension methods (`GetEncoding`, `DetectFiletype`) on `FileInfo` and `Stream`, as well as static methods (`TextEncodingDetector.GetEncoding`, `FileSignatureDetector.DetectFiletype`). The resulting `detector` object provides details like the true extension, MIME type, and format category.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nvar encoding=new FileInfo(filepath).GetEncoding(); // 获取文件编码(扩展调用)\nvar encoding=stream.GetEncoding(); // 获取流的编码(扩展调用)\nvar encoding=TextEncodingDetector.GetEncoding(filepath); // 获取文件编码(类调用)\n\n// 多种方式，任君调用\nvar detector=new FileInfo(filepath).DetectFiletype(); // 扩展调用\n//var detector=File.OpenRead(filepath).DetectFiletype(); // 流扩展调用\n//var detector=FileSignatureDetector.DetectFiletype(filepath); // 类调用\n\ndetector.Precondition;//基础文件类型\ndetector.Extension;//真实扩展名\ndetector.MimeType;//MimeType\ndetector.FormatCategories;//格式类别\n```\n\n----------------------------------------\n\nTITLE: Defining a DTO for Custom JSON Deserialization/Serialization Control (C#)\nDESCRIPTION: Defines a sample `ClassDto` demonstrating the use of attributes like `[DeserializeOnlyJsonProperty]` (or `[SerializeIgnore]`) and `[SerializeOnlyJsonProperty]` (or `[DeserializeIgnore]`). These attributes, when used in conjunction with specific Masuit.Tools contract resolvers (`DeserializeOnlyContractResolver`, `SerializeIgnoreResolver`), allow fine-grained control over whether properties are included during JSON serialization or deserialization processes.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClassDto\n    {\n        // 序列化时忽略这个属性/反序列化时加载这个属性\n        [DeserializeOnlyJsonProperty]\n        //[SerializeIgnore]\n        public string MyProperty { get; set; }\n\n        // 反序列化时忽略这个属性/序列化时加载这个属性\n        [SerializeOnlyJsonProperty]\n        //[DeserializeIgnore]\n        public int Num { get; set; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a DTO with Fallback JSON Property Names (C#)\nDESCRIPTION: Defines a `ClassDto` using the `[FallbackJsonProperty]` attribute from Masuit.Tools. This attribute allows specifying multiple alternative names (\"MyProperty\", \"a\", \"b\") for a single C# property (`MyProperty`). During JSON deserialization, if the `FallbackJsonPropertyResolver` is used, the property can be successfully populated from a JSON key matching any of these specified names.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClassDto\n{\n    [FallbackJsonProperty(\"MyProperty\",\"a\",\"b\")]\n    public string MyProperty { get; set; }\n\n    public int Num { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Image Similarity and Identifying Format in C#\nDESCRIPTION: Demonstrates using `ImageHasher` from Masuit.Tools to compute perceptual hashes of images using various algorithms (DifferenceHash256, AverageHash64, DctHash, MedianHash64) and comparing these hashes to determine image similarity (ranging from 0 to 1). It also shows how to get the actual image format from a stream using an extension method.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// 图像相似度对比\nvar hasher = new ImageHasher();\nvar hash1 = hasher.DifferenceHash256(\"图片1\"); // 使用差分哈希算法计算图像的256位哈希\nvar hash2 = hasher.DifferenceHash256(\"图片2\"); // 使用差分哈希算法计算图像的256位哈希\n//var hash1 = hasher.AverageHash64(\"图片1\"); // 使用平均值算法计算图像的64位哈希\n//var hash2 = hasher.AverageHash64(\"图片2\"); // 使用平均值算法计算图像的64位哈希\n//var hash1 = hasher.DctHash(\"图片1\"); // 使用DCT算法计算图像的64位哈希\n//var hash2 = hasher.DctHash(\"图片2\"); // 使用DCT算法计算图像的64位哈希\n//var hash1 = hasher.MedianHash64(\"图片1\"); // 使用中值算法计算给定图像的64位哈希\n//var hash2 = hasher.MedianHash64(\"图片2\"); // 使用中值算法计算给定图像的64位哈希\nvar sim=ImageHasher.Compare(hash1,hash2); // 图片的相似度，范围：[0,1]\n\nvar imageFormat=stream.GetImageType(); // 获取图片的真实格式\n```\n\n----------------------------------------\n\nTITLE: Tree Structure Filtering and Conversion Utilities in C#\nDESCRIPTION: This set of snippets shows functional and extension-style operations on tree structures implementing interfaces like ITree, ITreeParent, ITreeChildren, and ITreeEntity. Capabilities include tree flattening, child/parent retrieval, root/leaf detection, depth measurement, path extraction, and generic conversion from flat lists. Typically used for object collections that follow the specified interfaces; key outputs include filtered collections or new tree structures. Dependencies may include custom interface/contracts for tree representation.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\ntrees.Filter(func); // 从树形集合中过滤\ntrees.Flatten(); // 将数据平铺开\ntree.AllChildren(); // 获取所有的子级\ntree.AllParent(); // 获取所有的父级\ntree.IsRoot(); // 是否是根节点\ntree.IsLeaf(); // 是否是叶子节点\ntree.Level(); // 所处深度/层级\ntree.Path(); // 全路径\n\nvar tree=list.ToTree();//集合元素继承自ITreeEntity<T,TKey>或ITreeEntity<T>的集合转换成树形结构\nvar tree=list.ToTree(c => c.Id, c => c.Pid);//集合元素继承自ITreeParent<T>, ITreeChildren<T>的集合转换成树形结构\nvar tree=list.ToTreeGeneral(c => c.Id, c => c.Pid);//一般的集合转换成树形结构\n```\n\n----------------------------------------\n\nTITLE: Radar Chart Polygon Intersection and Area Calculation in C#\nDESCRIPTION: These snippets demonstrate calculating the intersection of radar chart polygons and computing area within a C# context, useful for multi-dimensional similarity or user profiling. The operations require a RadarChartEngine and support area calculation post-intersection. Expected inputs are polygon/chart objects; output is a list of intersection points and polygon area as a numeric value.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nvar points=RadarChartEngine.ComputeIntersection(chart1,chart2); //获取两个多边形的相交区域\npoints.ComputeArea(); //计算多边形面积\n```\n\n----------------------------------------\n\nTITLE: Initializing ConcurrentHashSet in C#\nDESCRIPTION: Shows how to instantiate a `ConcurrentHashSet<T>`, a thread-safe hash set implementation provided by Masuit.Tools. Its usage is consistent with the standard `HashSet<T>`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar set = new ConcurrentHashSet<string>(); // 用法和hashset保持一致\n```\n\n----------------------------------------\n\nTITLE: Initializing Fixed-Size Queues in C#\nDESCRIPTION: Demonstrates the creation of a standard fixed-size queue (`LimitedQueue<T>`) and a thread-safe fixed-size queue (`ConcurrentLimitedQueue<T>`) using the Masuit.Tools library. Both queues are initialized with a capacity of 32 elements. For .NET 5 and above, using the built-in `System.Threading.Channels.Channel` is recommended for similar functionality.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nLimitedQueue<string> queue = new LimitedQueue<string>(32);// 声明一个容量为32个元素的定长队列\nConcurrentLimitedQueue<string> queue = new ConcurrentLimitedQueue<string>(32);// 声明一个容量为32个元素的线程安全的定长队列\n```\n\n----------------------------------------\n\nTITLE: Generating CAPTCHA Codes and Images in C#\nDESCRIPTION: Shows how to generate a textual validation code (CAPTCHA) of a specified length using `ValidateCode.ValidateCode(length)`. Subsequently, it demonstrates creating a graphical representation (image stream) of the generated code using the `.CreateValidateGraphic()` method.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nvar code=ValidateCode.ValidateCode(6); // 生成6位长度的验证码\nvar stream=code.CreateValidateGraphic(); // 生成验证码图片流\n```\n\n----------------------------------------\n\nTITLE: Using FallbackJsonPropertyResolver for Multiple JSON Aliases (Newtonsoft.Json) (C#)\nDESCRIPTION: Demonstrates how to use the `FallbackJsonPropertyResolver` with Newtonsoft.Json. By configuring this resolver in `JsonSerializerSettings`, JSON deserialization will respect the multiple alias names defined using the `[FallbackJsonProperty]` attribute on the DTO, allowing for more flexible mapping from different JSON structures to the same C# model. Requires `Masuit.Tools` and `Newtonsoft.Json`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nJsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()\n{\n    ContractResolver = new FallbackJsonPropertyResolver() // 配置使用FallbackJsonPropertyResolver解释器\n});\n```"
  }
]