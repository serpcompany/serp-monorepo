[
  {
    "owner": "ldqk",
    "repo": "masuit.tools",
    "content": "TITLE: Utilizing Collection Extension Methods in C#\nDESCRIPTION: Demonstrates a comprehensive set of collection extension methods provided by Masuit.Tools for `List<T>`, `Dictionary<TKey, TValue>`, `IEnumerable<T>`, and `IQueryable<T>`. Features include conditional adding (`AddRangeIf`, `AddRangeIfNotContains`), conditional removal (`RemoveWhere`), inserting elements (`InsertAfter`), safe dictionary conversions (`ToDictionarySafety`, `ToConcurrentDictionary`), conditional dictionary access/assignment, dictionary add/update/get-or-add operations (`AddOrUpdate`, `GetOrAdd`), DataTable conversions (`ToDataTable`, `AddIdentityColumn`, `HasRows`, `ToList`), async operations (`ForeachAsync`, `ForAsync`, `SelectAsync`), string joining (`Join`), safe aggregation (`MaxOrDefault`, `MinOrDefault`), standard deviation calculation (`StandardDeviation`), pagination (`ToPagedList`, `ToPagedListAsync`), set operations based on properties (`ExceptBy`, `IntersectBy`), sequence equality checks (`SequenceEqual`), random ordering (`OrderByRandom`), finding intersections across multiple collections (`IntersectAll`), changing element index (`ChangeIndex`), and finding percentile elements (`Percentile`).\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar list = new List<string>()\n{\n    \"1\", \"3\", \"3\", \"3\"\n};\nlist.AddRangeIf(s => s.Length > 1, \"1\", \"11\"); // å°†è¢«æ·»åŠ å…ƒç´ ä¸­çš„é•¿åº¦å¤§äº1çš„å…ƒç´ æ·»åŠ åˆ°list\nlist.AddRangeIfNotContains(\"1\", \"11\"); // å°†è¢«æ·»åŠ å…ƒç´ ä¸­ä¸åŒ…å«çš„å…ƒç´ æ·»åŠ åˆ°list\nlist.RemoveWhere(s => s.Length < 1); // å°†é›†åˆä¸­é•¿åº¦å°äº1çš„å…ƒç´ ç§»é™¤\nlist.InsertAfter(0, \"2\"); // åœ¨ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹åæ’å…¥\nlist.InsertAfter(s => s == \"1\", \"2\"); // åœ¨å…ƒç´ \"1\"åæ’å…¥\n\nvar dic = list.ToDictionarySafety(s => s); // å®‰å…¨çš„è½¬æ¢æˆå­—å…¸ç±»å‹ï¼Œå½“é”®é‡å¤æ—¶åªæ·»åŠ ä¸€ä¸ªé”®\nvar dic = list.ToConcurrentDictionary(s => s); // è½¬æ¢æˆå¹¶å‘å­—å…¸ç±»å‹ï¼Œå½“é”®é‡å¤æ—¶åªæ·»åŠ ä¸€ä¸ªé”®\nvar dic = list.ToDictionarySafety(s => s, s => s.GetHashCode()); // å®‰å…¨çš„è½¬æ¢æˆå­—å…¸ç±»å‹ï¼Œå½“é”®é‡å¤æ—¶åªæ·»åŠ ä¸€ä¸ªé”®\nvar v = dic[x => x.Key.Contains(\"1\")]; // å­—å…¸æ ¹æ®æ¡ä»¶å–å€¼\ndic[x => x.Key.Contains(\"1\")] = 2; // å­—å…¸æ ¹æ®æ¡ä»¶èµ‹å€¼\nvar v = dic[(key, value) => key.Contains(\"1\")]; // å­—å…¸æ ¹æ®æ¡ä»¶å–å€¼\ndic[(key, value) => key.Contains(\"1\")] = 2; // å­—å…¸æ ¹æ®æ¡ä»¶èµ‹å€¼\nvar v = dic[key => key.Contains(\"1\")]; // å­—å…¸æ ¹æ®keyæ¡ä»¶å–å€¼\ndic[key => key.Contains(\"1\")] = 2; // å­—å…¸æ ¹æ®keyæ¡ä»¶èµ‹å€¼\nvar v = dic[value => value > 0]; // å­—å…¸æ ¹æ®valueæ¡ä»¶å–å€¼\ndic[value => value > 0] = 2; // å­—å…¸æ ¹æ®valueæ¡ä»¶èµ‹å€¼\ndic.AddOrUpdate(\"4\", 4); // æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹\ndic.AddOrUpdate(new Dictionary<string, int>()\n{\n    [\"5\"] = 5, [\"55\"] = 555\n}); // æ‰¹é‡æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹\ndic.AddOrUpdate(\"5\", 6, (s, i) => 66); // å¦‚æœæ˜¯æ·»åŠ ï¼Œåˆ™å€¼ä¸º6ï¼Œè‹¥æ›´æ–°åˆ™å€¼ä¸º66\ndic.AddOrUpdate(\"5\", 6, 666); // å¦‚æœæ˜¯æ·»åŠ ï¼Œåˆ™å€¼ä¸º6ï¼Œè‹¥æ›´æ–°åˆ™å€¼ä¸º666\ndic.GetOrAdd(\"7\", 77); // å­—å…¸è·å–æˆ–æ·»åŠ å…ƒç´ \ndic.GetOrAdd(\"7\", () => 77); // å­—å…¸è·å–æˆ–æ·»åŠ å…ƒç´ \ndic.AsConcurrentDictionary(); // æ™®é€šå­—å…¸è½¬æ¢æˆå¹¶å‘å­—å…¸é›†åˆ\n\nvar table = list.ToDataTable(); // è½¬æ¢æˆDataTableç±»å‹\ntable.AddIdentityColumn(); //ç»™DataTableå¢åŠ ä¸€ä¸ªè‡ªå¢åˆ—\ntable.HasRows(); // æ£€æŸ¥DataTable æ˜¯å¦æœ‰æ•°æ®è¡Œ\ntable.ToList<T>(); // datatableè½¬List\nvar set = list.ToHashSet(s => s.Name);// è½¬HashSet\nvar cts = new CancellationTokenSource(100); //å–æ¶ˆå£ä»¤\nawait list.ForeachAsync(async i =>\n{\n    await Task.Delay(100);\n    Console.WriteLine(i);\n}, cts.Token); // å¼‚æ­¥foreach\n\nawait list.ForAsync(async (item, index) =>\n{\n    await Task.Delay(100);\n    Console.WriteLine(item + \"_\" + index);\n}, cts.Token); // å¼‚æ­¥forï¼Œå¸¦ç´¢å¼•ç¼–å·\nawait list.SelectAsync(async i =>\n{\n    await Task.Delay(100);\n    return i * 10;\n}); // å¼‚æ­¥Select\nawait list.SelectAsync(async (item, index) =>\n{\n    await Task.Delay(100);\n    return item * 10;\n}); // å¼‚æ­¥Selectï¼Œå¸¦ç´¢å¼•ç¼–å·\nstring s = list.Join(\",\");//å°†å­—ç¬¦ä¸²é›†åˆè¿æ¥æˆé€—å·åˆ†éš”çš„å•å­—ç¬¦ä¸²\nvar max = list.MaxOrDefault(); // å–æœ€å¤§å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar max = list.MaxOrDefault(selector); // å–æœ€å¤§å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar max = list.MaxOrDefault(selector, default); // å–æœ€å¤§å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar max = list.MinOrDefault(); // å–æœ€å°å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar max = list.MinOrDefault(selector); // å–æœ€å°å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar max = list.MinOrDefault(selector, default); // å–æœ€å°å€¼ï¼Œå½“é›†åˆä¸ºç©ºçš„æ—¶å€™ä¸ä¼šæŠ¥é”™\nvar stdDev = list.Select(s => s.ConvertTo<int>()).StandardDeviation(); // æ±‚æ ‡å‡†å·®\n\nvar pages = queryable.ToPagedList(1, 10); // åˆ†é¡µæŸ¥è¯¢\nvar pages = await queryable.ToPagedListAsync(1, 10); // åˆ†é¡µæŸ¥è¯¢\n\nvar nums = Enumerable.Range(1, 10).ExceptBy(Enumerable.Range(5, 10), i => i); // æŒ‰å­—æ®µå–å·®é›†\nvar nums = Enumerable.Range(1, 10).IntersectBy(Enumerable.Range(5, 10), i => i); // æŒ‰å­—æ®µå–äº¤é›†\nvar nums = Enumerable.Range(1, 10).SequenceEqual(Enumerable.Range(5, 10), i => i); // åˆ¤æ–­åºåˆ—ç›¸ç­‰\nvar nums = Enumerable.Range(1, 10).OrderByRandom(); // éšæœºæ’åº\n\n// å¤šä¸ªé›†åˆå–äº¤é›†\nvar list = new List<List<MyClass>>(){\n    new List<MyClass>(){\n        new MyClass(){Name=\"aa\",Age=11},\n        new MyClass(){Name=\"bb\",Age=12},\n        new MyClass(){Name=\"cc\",Age=13},\n    },\n    new List<MyClass>(){\n        new MyClass(){Name=\"bb\",Age=12},\n        new MyClass(){Name=\"cc\",Age=13},\n        new MyClass(){Name=\"dd\",Age=14},\n    },\n    new List<MyClass>(){\n        new MyClass(){Name=\"cc\",Age=13},\n        new MyClass(){Name=\"dd\",Age=14},\n        new MyClass(){Name=\"ee\",Age=15},\n    },\n};\nvar sect = list.IntersectAll(m => m.Name); // new MyClass(){Name=\"cc\",Age=13}\n\nvar list = new List<List<int>>(){\n    new(){1,2,3},\n    new(){2,3,4},\n    new(){3,4,5}\n};\nvar sect = list.IntersectAll();// [3]\n\n// é›†åˆå…ƒç´ æ”¹å˜å…¶ç´¢å¼•ä½ç½®\nlist.ChangeIndex(item, 3); // å°†å…ƒç´ itemçš„ç´¢å¼•ä½ç½®å˜ä¸ºç¬¬3ä¸ª\nlist.ChangeIndex(t => t.Id == \"123\", 2); // å°†idä¸º123çš„å…ƒç´ çš„ç´¢å¼•ä½ç½®å˜ä¸ºç¬¬2ä¸ª\n\nvar item = list.Percentile(50); // å–ç¬¬50%åˆ†ä½æ•°çš„å…ƒç´ \n```\n\n----------------------------------------\n\nTITLE: Using Extension Methods for IDistributedCache in C#\nDESCRIPTION: Presents a set of generic extension methods for `IDistributedCache` instances. These methods simplify common caching operations such as `Get<T>`, `GetOrAdd<T>` (with value or factory), `Set<T>`, and `AddOrUpdate<T>`, providing a type-safe and more concise way to interact with the distributed cache.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\nvar item=cache.Get<T>(key); // è·å–å€¼\nvar item=cache.GetOrAdd<T>(key,value); // è·å–æˆ–æ·»åŠ å€¼\nvar item=cache.GetOrAdd<T>(key,valueFactory); // è·å–æˆ–æ·»åŠ å€¼\ncache.Set<T>(key,value); // è®¾ç½®å€¼\ncache.AddOrUpdate<T>(key,value,valueFactory); // æ·»åŠ æˆ–æ›´æ–°å€¼\n```\n\n----------------------------------------\n\nTITLE: Tracking Entity Changes and NoLock Queries in Entity Framework Core in C#\nDESCRIPTION: These snippets provide methods for tracking entity changes (add/update/remove) within a DBContext and demonstrate using NoLock-style reading in SQL Server and other supported databases via transaction control or interceptor. Includes both per-entity and global change-tracking, as well as async query variants optimized for dirty-read scenarios. Utilizes provider-specific dependency injection and custom extension methods.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvar changes=dbContext.GetChanges<TEntity>();//è·å–å˜æ›´å­—æ®µä¿¡æ¯\nvar added=dbContext.GetAdded<TEntity>();//è·å–æ·»åŠ çš„å®ä½“å­—æ®µä¿¡æ¯\nvar removed=dbContext.GetRemoved<TEntity>();//è·å–è¢«ç§»é™¤çš„å®ä½“å­—æ®µä¿¡æ¯  \nvar allchanges=dbContext.GetAllChanges<TEntity>();//è·å–å¢åˆ æ”¹çš„å®ä½“å­—æ®µä¿¡æ¯  \n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar changes=dbContext.GetChanges();//è·å–å˜æ›´å­—æ®µä¿¡æ¯\nvar added=dbContext.GetAdded();//è·å–æ·»åŠ çš„å®ä½“å­—æ®µä¿¡æ¯\nvar removed=dbContext.GetRemoved();//è·å–è¢«ç§»é™¤çš„å®ä½“å­—æ®µä¿¡æ¯  \nvar allchanges=dbContext.GetAllChanges();//è·å–å¢åˆ æ”¹çš„å®ä½“å­—æ®µä¿¡æ¯  \n```\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddDbContext<TContext>(opt => opt.UseSqlserver(\"ConnString\", builder => builder.AddInterceptors(new WithNoLockInterceptor(true))); // å¯ç”¨å…¨å±€nolockæŸ¥è¯¢\nservices.AddDbContext<TContext>(opt => opt.UseSqlserver(\"ConnString\", builder => builder.AddInterceptors(new WithNoLockInterceptor())); // æŒ‰éœ€å¯ç”¨å…¨å±€nolockæŸ¥è¯¢\n\n// æŒ‰éœ€å¯ç”¨å…¨å±€nolockæŸ¥è¯¢ï¼Œæ‰§è¡Œå•ä¸ªnolockæŸ¥è¯¢\nawait dbContext.Users.Where(x=>x.Name==\"aaa\").WithNolock().ToListAsync();\n```\n\nLANGUAGE: csharp\nCODE:\n```\ndbcontext.NoLock(ctx=>ctx.Users...ToList()); // å¼€å¯ä¸€ä¸ªnolockä¸Šä¸‹æ–‡ï¼Œä¸Šä¸‹æ–‡èŒƒå›´å†…è‡ªåŠ¨nolock\n\n// æ‰§è¡Œå•ä¸ªnolockæŸ¥è¯¢\nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").ToListWithNoLockAsync(); \nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").FirstOrDefaultWithNoLockAsync(); \nawait dbcontext.Users.Where(x=>x.Name==\"aaa\").SingleOrDefaultWithNoLockAsync(); \nawait dbcontext.Users.AnyWithNoLockAsync(x=>x.Name==\"aaa\"); \nawait dbcontext.Users.AllWithNoLockAsync(x=>x.Name==\"aaa\"); \nawait dbcontext.Users.CountWithNoLockAsync(x=>x.Name==\"aaa\"); \n\n// å¦‚æœåœ¨ä¸Šä¸‹æ–‡å¼€å¯äº†é‡è¯•æœºåˆ¶,æ‰§è¡Œå•ä¸ªnolockæŸ¥è¯¢éœ€è¦å¼€å¯ç­–ç•¥æŸ¥è¯¢\nservices.AddDbContext<TContext>(opt => opt.UseNpgsql(\"ConnString\", builder => builder.EnableRetryOnFailure(10));\n\n// æ‰§è¡Œç­–ç•¥\ndbcontext.ExecutionStrategy(stg=>stg.NoLock(ctx=>ctx.Users...ToList()));\ndbcontext.ExecutionStrategy(ctx=>ctx.Users.Where(x=>x.Name==\"aaa\").ToListWithNoLockAsync());\n```\n\n----------------------------------------\n\nTITLE: Exporting Data to Excel using Masuit.Tools.Excel in C#\nDESCRIPTION: These examples demonstrate how to export lists or DataTable objects to Excel spreadsheets, including custom column definitions and support for image columns. Dependencies include the Masuit.Tools.Excel package. The inputs can be anonymous objects or DataTable, and options include sheet naming and password protection for output files. Outputs are Excel files or streams for further use.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nvar stream=list.Select(item=>new{\n    å§“å=item.Name,\n    å¹´é¾„=item.Age,\n    item.Gender,\n    Avatar=Image.FromStream(filestream) //å›¾ç‰‡åˆ—\n}).ToDataTable().ToExcel(\"Sheet1\"); //è‡ªå®šä¹‰åˆ—åå¯¼å‡º\nvar stream=list.ToDataTable(\"Sheet1\").ToExcel(\"æ–‡ä»¶å¯†ç \");\n```\n\n----------------------------------------\n\nTITLE: Stream and MemoryStream Operations and Extensions in C#\nDESCRIPTION: This set of snippets provides stream utilities for saving/copying streams, stream conversion (to array or MemoryStream), memory pooling, large-memory stream handlers, and checksum calculations. Includes both synchronous and asynchronous usage, with helpful comments for recommended usage scenarios (e.g., very large memory streams). Requires appropriate using directives and classes such as MemoryStream, PooledMemoryStream, LargeMemoryStream, and extension methods for FileStreams.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nstream.SaveAsMemoryStream(); // ä»»æ„æµè½¬æ¢æˆå†…å­˜æµ\nstream.ToArray(); // ä»»æ„æµè½¬æ¢æˆäºŒè¿›åˆ¶æ•°ç»„\nstream.ToArrayAsync(); // ä»»æ„æµè½¬æ¢æˆäºŒè¿›åˆ¶æ•°ç»„\nstream.ShuffleCode(); // æµæ´—ç ï¼Œåœ¨æµçš„æœ«ç«¯éšå³å¢åŠ å‡ ä¸ªç©ºå­—èŠ‚ï¼Œé‡è¦æ•°æ®è¯·è°¨æ…ä½¿ç”¨ï¼Œå¯èƒ½é€ æˆæµæŸå\n\n// æ± åŒ–å†…å­˜æµï¼Œç”¨æ³•ä¸MemorySteamä¿æŒä¸€è‡´\nusing var ms=PooledMemoryStream();\n\n// å¤§å‹å†…å­˜æµ,æœ€å¤§å¯æ”¯æŒ1TBå†…å­˜æ•°æ®ï¼Œæ¨èå½“æ•°æ®æµå¤§äº2GBæ—¶ä½¿ç”¨ï¼Œç”¨æ³•ä¸MemorySteamä¿æŒä¸€è‡´\nusing var ms=LargeMemoryStream();\n\n//æ–‡ä»¶æµå¿«é€Ÿå¤åˆ¶\nFileStream fs = new FileStream(@\"D:\\boot.vmdk\", FileMode.OpenOrCreate, FileAccess.ReadWrite);\n{\n        //fs.CopyToFile(@\"D:\\1.bak\");//åŒæ­¥å¤åˆ¶å¤§æ–‡ä»¶\n        fs.CopyToFileAsync(@\"D:\\1.bak\");//å¼‚æ­¥å¤åˆ¶å¤§æ–‡ä»¶\n        string md5 = fs.GetFileMD5Async().Result;//å¼‚æ­¥è·å–æ–‡ä»¶çš„MD5\n        string sha1 = fs.GetFileSha1();//å¼‚æ­¥è·å–æ–‡ä»¶çš„SHA1\n}\nmemoryStream.SaveFile(\"filename\"); // å°†å†…å­˜æµè½¬å‚¨æˆæ–‡ä»¶\n```\n\n----------------------------------------\n\nTITLE: Type Conversion, Primitive and String Utilities in C#\nDESCRIPTION: This group of snippets offers utilities for conversion between types, truncation, primitive and simple type checking, JSON serialization, null/empty checks, string manipulation, and encoding conversions. It supports fast and safe string containment checks, conversion between half/full width characters, emoji detection, measurement string rendering width, and more. Dependencies include core .NET types and possibly Newtonsoft.Json for JSON handling.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n1.2345678901.Digits8(); // å°†å°æ•°æˆªæ–­ä¸º8ä½\n1.23.ConvertTo<int>(); // å°æ•°è½¬int\n1.23.ConvertTo<T>(); // å°æ•°è½¬TåŸºæœ¬ç±»å‹\nbool b=1.23.TryConvertTo<T>(out result); // å°æ•°è½¬TåŸºæœ¬ç±»å‹\nvar num=1.2345.ToDecimal(2); //è½¬decimalå¹¶ä¿ç•™ä¸¤ä½å°æ•°\n\n1.23.ChangeTypeTo<T>(); //å°æ•°è½¬TåŸºæœ¬ç±»å‹,ConvertToå’ŒChangeTypeToçš„åŒºåˆ«åœ¨äºï¼šConvertToåªé€‚ç”¨äºåŸºå…ƒç±»å‹çš„äº’è½¬ï¼ŒChangeTypeToä¸ä»…é€‚ç”¨äºåŸºå…ƒç±»å‹çš„äº’è½¬è¿˜æ”¯æŒæ•°ç»„ã€å­—ç¬¦ä¸²çš„è½¬æ¢(Parse)ï¼ŒConvertToçš„æ€§èƒ½æ›´é«˜\n\ntype.IsPrimitive(); // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯å€¼ç±»å‹\ntype.IsSimpleType(); // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯å¸¸è§çš„ç®€å•ç±»å‹ï¼ŒåŸºå…ƒç±»å‹ä¸º Booleanã€ Byteã€ SByteã€ Int16ã€ UInt16ã€ Int32ã€ UInt32ã€ Int64ã€ UInt64ã€ IntPtrã€ UIntPtrã€ Charã€ Double ã€ Singleã€æšä¸¾ã€Nullable<T>ã€‚\ntype.IsSimpleArrayType(); // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯å¸¸è§ç±»å‹çš„ æ•°ç»„å½¢å¼ ç±»å‹\ntype.IsSimpleListType(); // åˆ¤æ–­ç±»å‹æ˜¯å¦æ˜¯å¸¸è§ç±»å‹çš„ æ³›å‹å½¢å¼ ç±»å‹\n\nmyClass.ToJsonString(); //åºåˆ—åŒ–æˆjsonå­—ç¬¦ä¸²\n\nstring s=null;\nbool b=s.IsNullOrEmpty();//åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©º\nbool b=s.NotNullOrEmpty();//åˆ¤æ–­å­—ç¬¦ä¸²ä¸ä¸ºç©º\nstring str=s.IfNullOrEmpty(\"aa\");//å¦‚æœä¸ºç©ºåˆ™è¿”å›aa\nstring str=s.IfNullOrEmpty(()=>\"aa\");//å¦‚æœä¸ºç©ºåˆ™è¿”å›aa,å»¶è¿Ÿæ‰§è¡Œ\n\nbool contains=s.Contains(new[]{\"aa\",\"bb\"});// æ£€æµ‹å­—ç¬¦ä¸²ä¸­æ˜¯å¦åŒ…å«åˆ—è¡¨ä¸­çš„å…³é”®è¯(å¿«é€ŸåŒ¹é…)\nbool contains=s.ContainsSafety(new[]{\"aa\",\"bb\"});// æ£€æµ‹å­—ç¬¦ä¸²ä¸­æ˜¯å¦åŒ…å«åˆ—è¡¨ä¸­çš„å…³é”®è¯(å®‰å…¨åŒ¹é…)ï¼Œæ²¡æœ‰è®¡æ—¶æ”»å‡»é£é™©\nbool contains=s.EndsWith(new[]{\"aa\",\"bb\"});// æ£€æµ‹å­—ç¬¦ä¸²ä¸­æ˜¯å¦ä»¥åˆ—è¡¨ä¸­çš„ä»»æ„å…³é”®è¯ç»“å°¾\nbool contains=s.StartsWith(new[]{\"aa\",\"bb\"});// æ£€æµ‹å­—ç¬¦ä¸²ä¸­æ˜¯å¦ä»¥åˆ—è¡¨ä¸­çš„ä»»æ„å…³é”®è¯å¼€å¤´\n\nstring str=s.Take(10); // å–å­—ç¬¦ä¸²å‰10ä¸ªå­—ç¬¦\n\nbool emoji=s.MatchEmoji(); // åŒ¹é…å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«emoji\n\nvar width=str.StringWidth(14); // è®¡ç®—å­—ç¬¦ä¸²ä»¥14å·å­—ä½“å¤§å°çš„æ¸²æŸ“å®½åº¦åƒç´ \nvar width=str.StringWidth(\"å¾®è½¯é›…é»‘\",14); // è®¡ç®—å­—ç¬¦ä¸²ä»¥14å·å­—ä½“å¤§å°çš„å¾®è½¯é›…é»‘å­—ä½“çš„æ¸²æŸ“å®½åº¦åƒç´ \nvar width=str.CharacterCount(); // è·å–å­—ç¬¦ä¸²çš„å­—ç¬¦æ•°\nvar width=str.BytesCount(); // è·å–å­—ç¬¦ä¸²çš„å­—èŠ‚æ•°\n\n\nvar s = \"ğŸ¤”1ğŸ¥³ağŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦å•Š\";\nConsole.WriteLine(\"é•¿åº¦ï¼š\" + s.Length); // 18\nConsole.WriteLine(\"å®½åº¦ï¼š\" + s.StringWidth()); // 7\nConsole.WriteLine(\"å­—èŠ‚æ•°ï¼š\" + s.BytesCount()); // 38\nConsole.WriteLine(\"å­—ç¬¦æ•°ï¼š\" + s.CharacterCount()); // 6\n\nvar s=\"aa\".ToSBC(); // è½¬æ¢ä¸ºå…¨è§’\nvar s=\"ï½ï½\".ToDBC(); // è½¬æ¢ä¸ºåŠè§’\n```\n\n----------------------------------------\n\nTITLE: Extending DateTime and Time Range Calculations in C#\nDESCRIPTION: This collection of code snippets provides extension methods for advanced DateTime calculations and time range operations in C#. The utilities include week/quarter/month/year recognition, high-precision time stamps (milliseconds to nanoseconds), in-range checks, parsing, and time range unions/intersections. They also include different calendar period retrievals (solar/lunar/custom). Dependencies may include custom extension classes like DateTimeRange, and key parameters often involve DateTime values, enums for range type, and custom class objects. Input is primarily DateTime or string as date, output varies from numbers to time range objects.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nvar weeks=DateTime.Now.GetWeekAmount(); // è·å–å½“å‰æ‰€åœ¨å¹´ä¸€å…±æœ‰å¤šå°‘å‘¨\nvar week = DateTime.Now.WeekOfYear(); // è·å–å½“å‰æ‰€åœ¨å¹´çš„ç¬¬å‡ å‘¨\nvar week = DateTime.Now.WeekOfYear(DayOfWeek.Monday); // è·å–å½“å‰æ‰€åœ¨å¹´çš„ç¬¬å‡ å‘¨,å¹¶æŒ‡å®šæ˜ŸæœŸå‡ æ˜¯æ¯å‘¨ç¬¬ä¸€å¤©\n\ndouble milliseconds = DateTime.Now.GetTotalMilliseconds();// è·å–æ¯«ç§’çº§æ—¶é—´æˆ³\ndouble microseconds = DateTime.Now.GetTotalMicroseconds();// è·å–å¾®ç§’çº§æ—¶é—´æˆ³\ndouble nanoseconds = DateTime.Now.GetTotalNanoseconds();// è·å–çº³ç§’çº§æ—¶é—´æˆ³\ndouble seconds = DateTime.Now.GetTotalSeconds();// è·å–ç§’çº§æ—¶é—´æˆ³\ndouble minutes = DateTime.Now.GetTotalMinutes();// è·å–åˆ†é’Ÿçº§æ—¶é—´æˆ³\n\nvar indate=DateTime.Parse(\"2020-8-3\").In(DateTime.Parse(\"2020-8-2\"),DateTime.Parse(\"2020-8-4\"));//true\nDateTime time=\"2021-1-1 8:00:00\".ToDateTime(); //å­—ç¬¦ä¸²è½¬DateTime\n\n//æ—¶é—´æ®µè®¡ç®—å·¥å…·\nvar range = new DateTimeRange(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-5\"));\nrange.Union(DateTime.Parse(\"2020-8-4\"), DateTime.Parse(\"2020-8-6\")); //è¿æ¥ä¸¤ä¸ªæ—¶é—´æ®µï¼Œç»“æœï¼š2020-8-3~2020-8-6\nrange.In(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-6\"));//åˆ¤æ–­æ˜¯å¦åœ¨æŸä¸ªæ—¶é—´æ®µå†…ï¼Œtrue\nvar (intersected,range2) = range.Intersect(DateTime.Parse(\"2020-8-4\"), DateTime.Parse(\"2020-8-6\"));//ä¸¤ä¸ªæ—¶é—´æ®µæ˜¯å¦ç›¸äº¤ï¼Œ(true,2020-8-3~2020-8-4)\nrange.Contains(DateTime.Parse(\"2020-8-3\"), DateTime.Parse(\"2020-8-4\"));//åˆ¤æ–­æ˜¯å¦åŒ…å«æŸä¸ªæ—¶é—´æ®µï¼Œtrue\n\nrange.GetUnionSet(List<DateTimeRange>); // æ ¹æ®æŸä¸ªæ—¶é—´æ®µæŸ¥æ‰¾åœ¨æŸæ‰¹æ—¶é—´æ®µä¸­çš„æœ€å¤§å¹¶é›†\nrange.GetMaxTimePeriod(List<DateTimeRange>); // è·å–ä¸€æ‰¹æ—¶é—´æ®µå†…å­˜åœ¨ç›¸äº’é‡å çš„æœ€å¤§æ—¶é—´æ®µ\n\nvar range = DateTime.Now.GetCurrentWeek(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å‘¨çš„æ—¶é—´åŒºé—´ï¼š2024-08-05 00:00:00~2024-08-11 23:59:59\nvar range = DateTime.Now.GetCurrentMonth(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨æœˆçš„æ—¶é—´åŒºé—´ï¼š2024-08-01 00:00:00~2024-08-31 23:59:59\nvar range = DateTime.Now.GetCurrentYear(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å¹´çš„æ—¶é—´åŒºé—´ï¼š2024-01-01 00:00:00~2024-12-31 23:59:59\nvar range = DateTime.Now.GetCurrentQuarter(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å­£åº¦çš„æ—¶é—´åŒºé—´ï¼š2024-07-01 00:00:00~2024-09-30 23:59:59\nvar range = DateTime.Now.GetCurrentLunarMonth(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†æœˆçš„æ—¶é—´åŒºé—´ï¼š2024-08-04 00:00:00~2024-09-02 23:59:59\nvar range = DateTime.Now.GetCurrentLunarQuarter(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†å­£åº¦çš„æ—¶é—´åŒºé—´ï¼š2024-08-04 00:00:00~2024-10-31 23:59:59\nvar range = DateTime.Now.GetCurrentLunarYaer(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†å¹´çš„æ—¶é—´åŒºé—´ï¼š2024-02-10 00:00:00~2025-01-28 23:59:59\nvar range = DateTime.Now.GetCurrentSolar(); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å­£èŠ‚çš„æ—¶é—´åŒºé—´ï¼š2024-08-07 00:00:00~2024-11-06 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Week); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å‘¨çš„æ—¶é—´åŒºé—´ï¼š2024-08-05 00:00:00~2024-08-11 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Month); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨æœˆçš„æ—¶é—´åŒºé—´ï¼š2024-08-01 00:00:00~2024-08-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Quarter); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å­£åº¦çš„æ—¶é—´åŒºé—´ï¼š2024-07-01 00:00:00~2024-09-30 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Year); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å¹´çš„æ—¶é—´åŒºé—´ï¼š2024-01-01 00:00:00~2024-12-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarMonth); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†æœˆçš„æ—¶é—´åŒºé—´ï¼š2024-08-04 00:00:00~2024-09-02 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarQuarter); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†å­£åº¦çš„æ—¶é—´åŒºé—´ï¼š2024-08-04 00:00:00~2024-10-31 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.LunarYear); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å†œå†å¹´çš„æ—¶é—´åŒºé—´ï¼š2024-02-10 00:00:00~2025-01-28 23:59:59\nvar range = DateTime.Now.GetCurrentRange(DateRangeType.Solar); // è·å–å½“å‰æ—¶é—´æ‰€åœ¨å­£èŠ‚çš„æ—¶é—´åŒºé—´ï¼š2024-08-07 00:00:00~2024-11-06 23:59:59\n\n...\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Image Manipulations in C#\nDESCRIPTION: Illustrates various image processing capabilities using Masuit.Tools and likely SixLabors.ImageSharp (implied by `Image.Load`). Examples include saving a Base64 string as an image, creating thumbnails, converting to black and white, cropping, cropping and resizing, resizing, horizontal/vertical mirroring, adjusting brightness/darkness, color inversion, applying a relief effect, extracting frames from a GIF, and adding text or image watermarks.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\"base64\".SaveDataUriAsImageFile();// å°†Base64ç¼–ç è½¬æ¢æˆå›¾ç‰‡\n\nusing Image image = Image.Load(@\"D:\\1.jpg\");\nimage.MakeThumbnail(@\"D:\\2.jpg\", 120, 80,ResizeMode.BoxPad);//ç”Ÿæˆç¼©ç•¥å›¾\n\nvar newBmp = image.BWPic(image.Width, image.Height);//è½¬æ¢æˆé»‘ç™½\nvar newBmp = image.CutImage(new Rectangle(0, 0, 1600, 900));//è£å‰ª\nvar newBmp = image.CutAndResize(new Rectangle(0, 0, 1600, 900), 160, 90);//è£å‰ªå¹¶ç¼©æ”¾\nvar newBmp = image.ResizeImage(160, 90);//æ”¹å˜å¤§å°\nvar newBmp = image.RevPicLR();//å·¦å³é•œåƒ\nvar newBmp = image.RevPicUD();//ä¸Šä¸‹é•œåƒ\nvar newBmp =image.LDPic(10); //è°ƒæ•´å…‰æš—\nvar newBmp =image.RePic(); //åè‰²å¤„ç†\nvar newBmp =image.Relief(); //æµ®é›•å¤„ç†\n\nvar gif = Image.Load(@\"D:\\1.gif\");\ngif.GetFrames(@\"D:\\frames\\\"); // è§£å‹gifæ¯å¸§å›¾ç‰‡\n\nvar marker=ImageWatermarker(stream);\nstream=maker.AddWatermark(\"æ°´å°æ–‡å­—\",\"å­—ä½“æ–‡ä»¶\",å­—ä½“å¤§å°,color,æ°´å°ä½ç½®,è¾¹è·); // ç»™å›¾ç‰‡æ·»åŠ æ°´å°\nstream=maker.AddWatermark(æ°´å°å›¾ç‰‡,æ°´å°ä½ç½®,è¾¹è·,å­—ä½“å¤§å°,å­—ä½“); // ç»™å›¾ç‰‡æ·»åŠ æ°´å°\n```\n\n----------------------------------------\n\nTITLE: Adding or Updating Entities with EF Core in C#\nDESCRIPTION: Demonstrates the `AddOrUpdate` extension method for `DbSet<T>` in Entity Framework Core, provided by Masuit.Tools. This method allows adding a new entity or updating an existing one based on a specified key selector (in this case, `t => t.Id`). It simplifies upsert operations.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// æŒ‰Idæ·»åŠ æˆ–æ›´æ–°æ–‡ç« å®ä½“\n/// </summary>\npublic override Post SavePost(Post t)\n{\n    DataContext.Set<Post>().AddOrUpdate(t => t.Id, t);\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Using [FromBodyOrDefault] for Flexible Model Binding in ASP.NET Core Actions (C#)\nDESCRIPTION: Provides examples of ASP.NET Core controller actions utilizing the `[FromBodyOrDefault]` attribute from `Masuit.Tools.AspNetCore`. This attribute allows action parameters (both complex models like `QueryModel` and simple types like `int` or `string`) to be bound from the query string, form data, or the request body (typically JSON), providing flexibility in how clients can send data to the endpoint. Both GET and POST methods are shown.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpGet(\"query\"),HttpPost(\"query\")]\npublic IActionResult Query([FromBodyOrDefault]QueryModel query)\n{\n    return Ok(...);\n}\n\n[HttpGet(\"query\"),HttpPost(\"query\")]\npublic IActionResult Query([FromBodyOrDefault]int id,[FromBodyOrDefault]string name)\n{\n    return Ok(...);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling BodyOrDefaultModelBinder in ASP.NET Core Startup (C#)\nDESCRIPTION: Shows the necessary configuration step to enable the `BodyOrDefaultModelBinder` in an ASP.NET Core application. Calling `app.UseBodyOrDefaultModelBinder()` within the `Configure` method of the `Startup` class (or the equivalent application configuration pipeline) registers the middleware required for the `[FromBodyOrDefault]` attribute to function correctly.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\napp.UseBodyOrDefaultModelBinder();\n```\n\n----------------------------------------\n\nTITLE: Installing Masuit.Tools.AspNetCore Package\nDESCRIPTION: Provides the command for installing the `Masuit.Tools.AspNetCore` NuGet package using the Package Manager Console in Visual Studio. This package is a prerequisite for using ASP.NET Core specific features from the Masuit.Tools library, such as the `BodyOrDefaultModelBinder`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_30\n\nLANGUAGE: shell\nCODE:\n```\nPM> Install-Package Masuit.Tools.AspNetCore\n```\n\n----------------------------------------\n\nTITLE: Simplifying Recursive Include Calls in Entity Framework Core (C#)\nDESCRIPTION: Demonstrates using the `IncludeRecursive` extension method from Masuit.Tools as a concise alternative to manually chaining multiple `Include().ThenInclude()` calls for loading hierarchical data (like categories with nested children) in Entity Framework Core. Requires `Masuit.Tools` and Entity Framework Core. The first parameter specifies the recursion depth, and the second is a lambda expression selecting the navigation property.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\n// å¦‚æœä½ ç°åœ¨æ­£åœ¨å†™ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š\ndbcontext.Category.Include(c=>c.Children).ThenInclude(c=>c.Children).ThenInclude(c=>c.Children).ThenInclude(c=>c.Children);\n\n// é‚£ä¹ˆå¯ä»¥æ”¹æˆè¿™æ ·ï¼š\ndbcontext.Category.IncludeRecursive(4, c => c.Children); // è‡ªåŠ¨Include 4æ¬¡\n```\n\n----------------------------------------\n\nTITLE: Applying Custom JSON Serialization Resolvers (Newtonsoft & System.Text.Json) (C#)\nDESCRIPTION: Shows how to apply custom contract resolvers from Masuit.Tools for controlling JSON serialization/deserialization. It demonstrates configuring `JsonSerializerSettings` for Newtonsoft.Json with `DeserializeOnlyContractResolver` and `JsonSerializerOptions` for System.Text.Json with `SerializeIgnoreResolver`. This enables behavior defined by attributes like `[DeserializeOnlyJsonProperty]` or `[SerializeOnlyJsonProperty]` on DTOs.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n// Newtonsoft.Json\nJsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()\n{\n    ContractResolver = new DeserializeOnlyContractResolver() // é…ç½®ä½¿ç”¨DeserializeOnlyContractResolverè§£é‡Šå™¨\n});\n\n// System.Text.Json\nJsonSerializer.Serialize(object, new JsonSerializerOptions() { TypeInfoResolver = new SerializeIgnoreResolver() });\n```\n\n----------------------------------------\n\nTITLE: Configuring Global JSON Contract Resolver in ASP.NET Core (Newtonsoft.Json) (C#)\nDESCRIPTION: Illustrates how to configure the `DeserializeOnlyContractResolver` globally for an ASP.NET Core application using Newtonsoft.Json integration. By setting the `ContractResolver` in `AddNewtonsoftJson` options within `Startup.ConfigureServices`, the custom serialization/deserialization behavior (ignoring properties based on attributes) is applied consistently across all MVC actions. Optionally, a `NamingStrategy` like `CamelCaseNamingStrategy` can also be configured.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\n//åœ¨Startup.ConfigureServicesä¸­\nservices.AddMvc().AddNewtonsoftJson(options =>\n     {\n         var resolver = new DeserializeOnlyContractResolver();\n         resolver.NamingStrategy = new CamelCaseNamingStrategy();\n         options.SerializerSettings.ContractResolver = resolver;\n     });\n```\n\n----------------------------------------\n\nTITLE: Sending Email Asynchronously in C#\nDESCRIPTION: Demonstrates sending an email asynchronously using the `Email` class from Masuit.Tools. The example configures SMTP server details, credentials, SSL usage, recipients, subject, and body, then calls `SendAsync` with a callback function to execute upon successful sending.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew Email()\n{\n    SmtpServer = \"smtp.masuit.com\",// SMTPæœåŠ¡å™¨\n    SmtpPort = 25, // SMTPæœåŠ¡å™¨ç«¯å£\n    EnableSsl = true,//ä½¿ç”¨SSL\n    Username = \"admin@masuit.com\",// é‚®ç®±ç”¨æˆ·å\n    Password = \"123456\",// é‚®ç®±å¯†ç \n    Tos = \"10000@qq.com,10001@qq.com\", //æ”¶ä»¶äºº\n    Subject = \"æµ‹è¯•é‚®ä»¶\",//é‚®ä»¶æ ‡é¢˜\n    Body = \"ä½ å¥½å•Š\",//é‚®ä»¶å†…å®¹\n}.SendAsync(s =>\n{\n    Console.WriteLine(s);// å‘é€æˆåŠŸåçš„å›è°ƒ\n});// å¼‚æ­¥å‘é€é‚®ä»¶\n```\n\n----------------------------------------\n\nTITLE: Mapping MIME Types and Extensions in C#\nDESCRIPTION: Demonstrates using the `MimeMapper` class from Masuit.Tools to map between MIME types and file extensions. `GetExtensionFromMime` converts a MIME type string (e.g., \"image/jpeg\") to its corresponding extension (e.g., \".jpg\"), and `GetMimeFromExtension` performs the reverse operation. Also shows accessing predefined MIME type constants via the `ContentType` static class or `DefaultMimeItems` collection.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar mimeMapper = new MimeMapper();\nvar ext = mimeMapper.GetExtensionFromMime(\"image/jpeg\"); // .jpg\nvar mime = mimeMapper.GetMimeFromExtension(\".jpg\"); // image/jpeg\n\nContentTypeå¸¸é‡åº“ï¼š\nvar type = ContentType.Exe; // application/octet-stream\nvar type = ContentType.Jpeg; // image/jpeg\nvar type = DefaultMimeItems.Items.FirstOrDefault(t => t.Extension == \"jpg\"); // image/jpeg\n```\n\n----------------------------------------\n\nTITLE: Storing and Retrieving Thread-Local Data in C#\nDESCRIPTION: Illustrates two approaches for managing thread-local temporary data. The first uses a generic `CurrentContext<T>` class with `SetData(value)` and `GetData()`. The second uses a non-generic `CurrentContext` class with `SetData(value)` and a generic `GetData<T>()` method. Both allow storing and retrieving values scoped to the current execution thread.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\nCurrentContext<T>.SetData(value);//è®¾ç½®å€¼\nvar item=CurrentContext<T>.GetData();//è·å–å€¼\n\nCurrentContext.SetData(value);//è®¾ç½®å€¼\nvar item=CurrentContext.GetData<T>();//è·å–å€¼\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Dynamic Objects in C#\nDESCRIPTION: Illustrates the creation of dynamic objects using `DynamicFactory.NewObject()` and initialization with `DynamicFactory.WithObject()`. Shows how to set and retrieve properties using both dot notation (`obj.Name`) and indexer access (`obj[\"Name\"]`), including handling nested dynamic objects and collections. Asserts demonstrate the equivalence of access methods.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\n        var obj = DynamicFactory.NewObject();\n        obj.Name = \"Masuit\";\n        obj.Age = 18;\n        obj[\"Gender\"]=\"ç”·\"\n        obj.MyClass = DynamicFactory.WithObject(new\n        {\n            X = 10,\n            Y = 20,\n            Z = new List<int> { 1, 2, 3, 4, 5 }\n        });\n        Assert.Equal(obj.Name, obj[\"Name\"]);\n        Assert.Equal(obj[\"Gender\"], obj.Gender);\n        Assert.Equal(obj[\"MyClass\"][\"X\"], obj.MyClass.X);\n        Assert.Equal(obj.MyClass.Z[2], obj[\"MyClass\"][\"Z\"][2]);\n```\n\n----------------------------------------\n\nTITLE: Converting Objects to Dynamic Type and Modifying Properties in C#\nDESCRIPTION: Demonstrates converting an anonymous object to a dynamic type using the `.ToDynamic()` extension method. Shows how to add properties (`obj.Age = 18`), assign nested dynamic objects, and dynamically add (`+ \"Prop\"`) or remove (`- \"Prop\"`) properties using operator overloading. Asserts verify property access consistency.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\n        var obj = new\n        {\n            Name = \"Masuit\"\n        }.ToDynamic();\n        obj.Age = 18;\n        obj.MyClass = new\n        {\n            X = 10,\n            Y = 20,\n            Z = new List<int> { 1, 2, 3, 4, 5 }\n        }.ToDynamic();\n        obj.Prop = \"test\";\n        _ = obj - \"Prop\"; // åˆ é™¤å±æ€§\n        _ = obj + \"Prop\"; // å¢åŠ å±æ€§\n\n        Assert.Equal(obj.Name, obj[\"Name\"]);\n        Assert.Equal(obj[\"MyClass\"][\"X\"], obj.MyClass.X);\n```\n\n----------------------------------------\n\nTITLE: Performing Reflection Operations in C#\nDESCRIPTION: Illustrates various reflection and object manipulation extension methods from Masuit.Tools. It shows getting properties (`GetProperties`), setting a property value (`SetProperty`), performing a deep clone (`DeepClone`), converting an object to a dictionary (`ToDictionary`), and converting an object to a dynamic expandable type (`ToDynamic`).\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMyClass myClass = new MyClass();\nPropertyInfo[] properties = myClass.GetProperties();// è·å–å±æ€§åˆ—è¡¨\nmyClass.SetProperty(\"Email\",\"1@1.cn\");//ç»™å¯¹è±¡è®¾ç½®å€¼\nmyClass.DeepClone(); // å¯¹è±¡æ·±æ‹·è´ï¼Œå¸¦åµŒå¥—å±‚çº§çš„\nmyClass.ToDictionary(); // å¯¹è±¡è½¬å­—å…¸\nmyClass.ToDynamic(); // å¯¹è±¡è½¬æ¢æˆåŠ¨æ€å¯æ‰©å±•ç±»å‹\n```\n\n----------------------------------------\n\nTITLE: Enabling Chainable Method Calls on Any Type (C#)\nDESCRIPTION: Illustrates the `Next` extension method provided by Masuit.Tools, which allows applying a sequence of functions to any object in a fluent, chainable style. The first example shows chaining generic functions (`func1`, `func2`, `func3`), while the second demonstrates transforming a string through integer conversion, multiplication, and logarithm calculation using chained `Next` calls. This enhances code readability for sequential operations.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\na.Next(func1).Next(func2).Next(func3);\n\"123\".Next(s=>s.ToInt32()).Next(x=>x*2).Next(x=>Math.Log(x));\n```\n\n----------------------------------------\n\nTITLE: INI File Operations and Object Mapping in C#\nDESCRIPTION: These snippets show usage of an IniFile class for reading, writing, mapping to objects, and managing INI configuration files, including type-safe section extraction and bulk clearing/loading. Requires an absolute file path; usage involves key-value access, section querying, generic reading, and class attribute annotations for mapping. Inputs are typically strings for section/key, or generic parameters for strong typing; outputs are strings, objects, or enums.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nIniFile ini=new IniFile(\"X:\\\\filename.ini\"); // éœ€è¦ç»å¯¹è·¯å¾„ï¼Œå¦åˆ™ä¼šå†™åˆ°C:\\Windowsç›®å½•ä¸‹å»\nini.SetValue(section,key,value); // å†™å€¼\nvar value=ini.GetValue(section,key); // è¯»å€¼\nvar value=ini.GetValue<Enum>(section,key); // è¯»å€¼å¹¶è½¬æ¢ç±»å‹\nvar sections=ini.GetSections(); // è·å–æ‰€æœ‰é…ç½®èŠ‚\nvar section=ini.GetSection(section); // è·å–é…ç½®èŠ‚\nvar myclass=ini.GetSection<MyClass>(section); // è·å–æŒ‡å®šé…ç½®èŠ‚å¹¶ç»‘å®šåˆ°å¯¹è±¡\nini.ClearAllSection(); // æ¸…ç©ºæ‰€æœ‰é…ç½®èŠ‚\nini.ClearSection(section); // æ¸…ç©ºé…ç½®èŠ‚\nini.Save(); // ä¿å­˜iniæ–‡ä»¶\nini.Reload(); // é‡æ–°åŠ è½½iniæ–‡ä»¶\n\n\nclass MyClass\n{\n    [IniProperty(\"str_value\")] // è®¾ç½®åˆ«å\n    public string StringValue { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Masking Sensitive Data During JSON Serialization in C#\nDESCRIPTION: Shows how to apply automatic data masking during JSON serialization using custom `JsonConverter` attributes from Masuit.Tools. By decorating properties (`Email`, `PhoneNumber`) with `[JsonConverter(typeof(MaskEmailConverter))]` or `[JsonConverter(typeof(MaskConverter))]`, the sensitive data will be masked in the resulting JSON output. Note the requirement to use the correct namespace depending on whether Newtonsoft.Json or System.Text.Json is being used.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// Attributeçš„æ–¹å¼ä¸ºjsonåºåˆ—åŒ–æ—¶è¿›è¡Œæ•°æ®è„±æ•\npublic class MyClass\n{\n    [JsonConverter(typeof(MaskEmailConverter))] // è¯·æ³¨æ„å‘½åç©ºé—´ï¼Œä½¿ç”¨Newtonsoft.Jsonè¯·å¯¼å…¥Masuit.Tools.Systemså‘½åç©ºé—´ï¼Œä½¿ç”¨System.Text.Jsonè¯·å¯¼å…¥Masuit.Tools.Systems.Text.Jsonå‘½åç©ºé—´\n    public string Email { get; set; }\n\n    [JsonConverter(typeof(MaskConverter))] // è¯·æ³¨æ„å‘½åç©ºé—´ï¼Œä½¿ç”¨Newtonsoft.Jsonè¯·å¯¼å…¥Masuit.Tools.Systemså‘½åç©ºé—´ï¼Œä½¿ç”¨System.Text.Jsonè¯·å¯¼å…¥Masuit.Tools.Systems.Text.Jsonå‘½åç©ºé—´\n    public string PhoneNumber { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Masking Sensitive Information in Strings in C#\nDESCRIPTION: Illustrates using extension methods from Masuit.Tools to mask sensitive information within strings. `Mask()` provides general-purpose masking (e.g., for phone numbers), while `MaskEmail()` specifically masks email addresses, preserving the first and last characters of the username and the domain.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n\"13123456789\".Mask(); // 131****5678\n\"admin@masuit.com\".MaskEmail(); // a****n@masuit.com\n```\n\n----------------------------------------\n\nTITLE: Performing Anti-Virus Scans on Windows using C#\nDESCRIPTION: Provides examples of scanning files, directories, streams, and byte arrays for malware on Windows. Uses `WindowsDefenderScanService` (dependent on an active Windows Defender service) and `AmsiScanService` (dependent on `amsi.dll`, potentially functional even if Defender is stopped) for the scans. Comments indicate specific requirements for each service.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\n// è¦æ±‚ç³»ç»ŸWindowsDefenderæ²¡æœ‰è¢«åœæ‰\nvar result = WindowsDefenderScanService.ScanFile(@\"Y:\\1.exe\"); // æ‰«ææ–‡ä»¶\nvar result = WindowsDefenderScanService.ScanDirectory(@\"Y:\\\"); // æ‰«ææ–‡ä»¶å¤¹\nvar result = WindowsDefenderScanService.ScanStream(stream); // æ‰«ææ–‡ä»¶æµ\n\n// è¦æ±‚C:\\Windows\\System32\\amsi.dllæ–‡ä»¶å­˜åœ¨ï¼Œå¯åœ¨WindowsDefenderåœæ­¢æ—¶å·¥ä½œ\nAmsiScanService.Scan(stream); // æ‰«ææ–‡ä»¶æµ\nAmsiScanService.Scan(@\"Y:\\1.exe\"); // æ‰«ææ–‡ä»¶\nAmsiScanService.Scan(bytes); // æ‰«æäºŒè¿›åˆ¶æ•°ç»„\n```\n\n----------------------------------------\n\nTITLE: Automating Service Registration in ASP.NET Core using Attributes\nDESCRIPTION: Explains how to use the `AutoRegisterServices()` extension method (from `Masuit.Tools.AspNetCore`) on `IServiceCollection` to automatically scan assemblies and register services. Services intended for automatic registration should be decorated with the `[ServiceInject(ServiceLifetime)]` attribute, specifying their desired lifetime (e.g., `Scoped`, `Singleton`, `Transient`). This simplifies the dependency injection setup process.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\n// è‡ªåŠ¨æ‰«ææ³¨å†ŒæœåŠ¡\nservices.AutoRegisterServices();\n\n// éœ€è¦è‡ªåŠ¨æ³¨å†Œçš„æœåŠ¡æ‰“ä¸ŠServiceInjectæ ‡è®°å³å¯ã€‚\n[ServiceInject(ServiceLifetime.Scoped)]\npublic class MyClass:MyInterface{...}\n\n[ServiceInject(ServiceLifetime.Scoped)]\npublic class MyService{...}\n```\n\n----------------------------------------\n\nTITLE: Using Extension Methods for ViewDataDictionary in C#\nDESCRIPTION: Introduces generic extension methods for `ViewDataDictionary` (`ViewData`). These methods, `GetValue<T>`, `GetValueOrDefault<T>` (with default value or factory), facilitate retrieving strongly-typed values from `ViewData`, enhancing type safety and reducing boilerplate code in views or controllers.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\nvar item=ViewData.GetValue<T>(key);//è·å–å¯¹è±¡\nvar item=ViewData.GetValueOrDefault<T>(key,defaultValue);//è·å–å¯¹è±¡\nvar item=ViewData.GetValueOrDefault<T>(key,defaultValueFactory);//è·å–å¯¹è±¡\n```\n\n----------------------------------------\n\nTITLE: Calculating String Similarity using SimHash Hamming Distance (C#)\nDESCRIPTION: Demonstrates calculating the Hamming distance between two strings using the SimHash algorithm provided by `Masuit.Tools`. The first example uses the `HammingDistance` extension method directly on strings, while the second creates `SimHash` objects first before calculating the distance. Lower Hamming distance indicates higher similarity between the input strings.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nvar dis=\"12345678\".HammingDistance(\"1234567\");\nvar dis=new SimHash(\"12345678\").HammingDistance(new SimHash(\"1234567\"));\n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 1) in C#\nDESCRIPTION: Demonstrates weighted random selection using extension methods on a list of `WeightedItem<T>` objects from Masuit.Tools. `WeightedItem()` selects a single element based on weights, and `WeightedItems(n)` selects multiple (n) elements based on their weights.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar data=new List<WeightedItem<string>>()\n{\n     new WeightedItem<string>(\"A\", 1),\n     new WeightedItem<string>(\"B\", 3),\n     new WeightedItem<string>(\"C\", 4),\n     new WeightedItem<string>(\"D\", 4),\n};\nvar item=data.WeightedItem();//æŒ‰æƒé‡é€‰å‡º1ä¸ªå…ƒç´ \nvar list=data.WeightedItems(2);//æŒ‰æƒé‡é€‰å‡º2ä¸ªå…ƒç´ \n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 2) in C#\nDESCRIPTION: Illustrates using the `WeightedSelector<T>` class from Masuit.Tools for weighted random selection. After initializing the selector with a list of `WeightedItem<T>`, `Select()` picks one item, and `SelectMultiple(n)` picks 'n' items according to their weights.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar selector = new WeightedSelector<string>(new List<WeightedItem<string>>()\n{\n    new WeightedItem<string>(\"A\", 1),\n    new WeightedItem<string>(\"B\", 3),\n    new WeightedItem<string>(\"C\", 4),\n    new WeightedItem<string>(\"D\", 4),\n});\nvar item = selector.Select();//æŒ‰æƒé‡é€‰å‡º1ä¸ªå…ƒç´ \nvar list = selector.SelectMultiple(3);//æŒ‰æƒé‡é€‰å‡º3ä¸ªå…ƒç´ \n```\n\n----------------------------------------\n\nTITLE: Performing Weighted Random Selection (Method 3) in C#\nDESCRIPTION: Shows alternative extension methods for weighted random selection from Masuit.Tools, applied directly to a generic list. A lambda expression (`e => e.Price`) is used to specify the property representing the weight for selection. `WeightedItems(n, selector)` selects 'n' items, and `WeightedBy(selector)` selects one item.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nlist.WeightedItems(3,e=>e.Price); // æŒ‰ä»·æ ¼æƒé‡é€‰å‡º3ä¸ªå…ƒç´ \nlist.WeightedBy(e=>e.Price); // æŒ‰ä»·æ ¼æƒé‡é€‰å‡º1ä¸ªå…ƒç´ \n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers and Strings in C#\nDESCRIPTION: Shows how to use extension methods on the `Random` class provided by Masuit.Tools. `StrictNext()` generates a cryptographically strong random integer. `NextGauss()` generates a random double following a normal (Gaussian) distribution with a specified mean and standard deviation. Also demonstrates generating a random base-62 string using `NumberFormater`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nRandom rnd = new Random();\nint num = rnd.StrictNext();//äº§ç”ŸçœŸéšæœºæ•°\ndouble gauss = rnd.NextGauss(20,5);//äº§ç”Ÿæ­£æ€é«˜æ–¯åˆ†å¸ƒçš„éšæœºæ•°\nvar s = new NumberFormater(62).ToString(new Random().Next(100000, int.MaxValue));//ç”Ÿæˆéšæœºå­—ç¬¦ä¸²\n```\n\n----------------------------------------\n\nTITLE: Detecting File Encoding and True File Type (C#)\nDESCRIPTION: Showcases various methods from `Masuit.Tools` for detecting the text encoding and the actual file type (based on magic bytes/signature, not just the extension) of a file or stream. Examples include extension methods (`GetEncoding`, `DetectFiletype`) on `FileInfo` and `Stream`, as well as static methods (`TextEncodingDetector.GetEncoding`, `FileSignatureDetector.DetectFiletype`). The resulting `detector` object provides details like the true extension, MIME type, and format category.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nvar encoding=new FileInfo(filepath).GetEncoding(); // è·å–æ–‡ä»¶ç¼–ç (æ‰©å±•è°ƒç”¨)\nvar encoding=stream.GetEncoding(); // è·å–æµçš„ç¼–ç (æ‰©å±•è°ƒç”¨)\nvar encoding=TextEncodingDetector.GetEncoding(filepath); // è·å–æ–‡ä»¶ç¼–ç (ç±»è°ƒç”¨)\n\n// å¤šç§æ–¹å¼ï¼Œä»»å›è°ƒç”¨\nvar detector=new FileInfo(filepath).DetectFiletype(); // æ‰©å±•è°ƒç”¨\n//var detector=File.OpenRead(filepath).DetectFiletype(); // æµæ‰©å±•è°ƒç”¨\n//var detector=FileSignatureDetector.DetectFiletype(filepath); // ç±»è°ƒç”¨\n\ndetector.Precondition;//åŸºç¡€æ–‡ä»¶ç±»å‹\ndetector.Extension;//çœŸå®æ‰©å±•å\ndetector.MimeType;//MimeType\ndetector.FormatCategories;//æ ¼å¼ç±»åˆ«\n```\n\n----------------------------------------\n\nTITLE: Defining a DTO for Custom JSON Deserialization/Serialization Control (C#)\nDESCRIPTION: Defines a sample `ClassDto` demonstrating the use of attributes like `[DeserializeOnlyJsonProperty]` (or `[SerializeIgnore]`) and `[SerializeOnlyJsonProperty]` (or `[DeserializeIgnore]`). These attributes, when used in conjunction with specific Masuit.Tools contract resolvers (`DeserializeOnlyContractResolver`, `SerializeIgnoreResolver`), allow fine-grained control over whether properties are included during JSON serialization or deserialization processes.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClassDto\n    {\n        // åºåˆ—åŒ–æ—¶å¿½ç•¥è¿™ä¸ªå±æ€§/ååºåˆ—åŒ–æ—¶åŠ è½½è¿™ä¸ªå±æ€§\n        [DeserializeOnlyJsonProperty]\n        //[SerializeIgnore]\n        public string MyProperty { get; set; }\n\n        // ååºåˆ—åŒ–æ—¶å¿½ç•¥è¿™ä¸ªå±æ€§/åºåˆ—åŒ–æ—¶åŠ è½½è¿™ä¸ªå±æ€§\n        [SerializeOnlyJsonProperty]\n        //[DeserializeIgnore]\n        public int Num { get; set; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining a DTO with Fallback JSON Property Names (C#)\nDESCRIPTION: Defines a `ClassDto` using the `[FallbackJsonProperty]` attribute from Masuit.Tools. This attribute allows specifying multiple alternative names (\"MyProperty\", \"a\", \"b\") for a single C# property (`MyProperty`). During JSON deserialization, if the `FallbackJsonPropertyResolver` is used, the property can be successfully populated from a JSON key matching any of these specified names.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClassDto\n{\n    [FallbackJsonProperty(\"MyProperty\",\"a\",\"b\")]\n    public string MyProperty { get; set; }\n\n    public int Num { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Image Similarity and Identifying Format in C#\nDESCRIPTION: Demonstrates using `ImageHasher` from Masuit.Tools to compute perceptual hashes of images using various algorithms (DifferenceHash256, AverageHash64, DctHash, MedianHash64) and comparing these hashes to determine image similarity (ranging from 0 to 1). It also shows how to get the actual image format from a stream using an extension method.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// å›¾åƒç›¸ä¼¼åº¦å¯¹æ¯”\nvar hasher = new ImageHasher();\nvar hash1 = hasher.DifferenceHash256(\"å›¾ç‰‡1\"); // ä½¿ç”¨å·®åˆ†å“ˆå¸Œç®—æ³•è®¡ç®—å›¾åƒçš„256ä½å“ˆå¸Œ\nvar hash2 = hasher.DifferenceHash256(\"å›¾ç‰‡2\"); // ä½¿ç”¨å·®åˆ†å“ˆå¸Œç®—æ³•è®¡ç®—å›¾åƒçš„256ä½å“ˆå¸Œ\n//var hash1 = hasher.AverageHash64(\"å›¾ç‰‡1\"); // ä½¿ç”¨å¹³å‡å€¼ç®—æ³•è®¡ç®—å›¾åƒçš„64ä½å“ˆå¸Œ\n//var hash2 = hasher.AverageHash64(\"å›¾ç‰‡2\"); // ä½¿ç”¨å¹³å‡å€¼ç®—æ³•è®¡ç®—å›¾åƒçš„64ä½å“ˆå¸Œ\n//var hash1 = hasher.DctHash(\"å›¾ç‰‡1\"); // ä½¿ç”¨DCTç®—æ³•è®¡ç®—å›¾åƒçš„64ä½å“ˆå¸Œ\n//var hash2 = hasher.DctHash(\"å›¾ç‰‡2\"); // ä½¿ç”¨DCTç®—æ³•è®¡ç®—å›¾åƒçš„64ä½å“ˆå¸Œ\n//var hash1 = hasher.MedianHash64(\"å›¾ç‰‡1\"); // ä½¿ç”¨ä¸­å€¼ç®—æ³•è®¡ç®—ç»™å®šå›¾åƒçš„64ä½å“ˆå¸Œ\n//var hash2 = hasher.MedianHash64(\"å›¾ç‰‡2\"); // ä½¿ç”¨ä¸­å€¼ç®—æ³•è®¡ç®—ç»™å®šå›¾åƒçš„64ä½å“ˆå¸Œ\nvar sim=ImageHasher.Compare(hash1,hash2); // å›¾ç‰‡çš„ç›¸ä¼¼åº¦ï¼ŒèŒƒå›´ï¼š[0,1]\n\nvar imageFormat=stream.GetImageType(); // è·å–å›¾ç‰‡çš„çœŸå®æ ¼å¼\n```\n\n----------------------------------------\n\nTITLE: Tree Structure Filtering and Conversion Utilities in C#\nDESCRIPTION: This set of snippets shows functional and extension-style operations on tree structures implementing interfaces like ITree, ITreeParent, ITreeChildren, and ITreeEntity. Capabilities include tree flattening, child/parent retrieval, root/leaf detection, depth measurement, path extraction, and generic conversion from flat lists. Typically used for object collections that follow the specified interfaces; key outputs include filtered collections or new tree structures. Dependencies may include custom interface/contracts for tree representation.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\ntrees.Filter(func); // ä»æ ‘å½¢é›†åˆä¸­è¿‡æ»¤\ntrees.Flatten(); // å°†æ•°æ®å¹³é“ºå¼€\ntree.AllChildren(); // è·å–æ‰€æœ‰çš„å­çº§\ntree.AllParent(); // è·å–æ‰€æœ‰çš„çˆ¶çº§\ntree.IsRoot(); // æ˜¯å¦æ˜¯æ ¹èŠ‚ç‚¹\ntree.IsLeaf(); // æ˜¯å¦æ˜¯å¶å­èŠ‚ç‚¹\ntree.Level(); // æ‰€å¤„æ·±åº¦/å±‚çº§\ntree.Path(); // å…¨è·¯å¾„\n\nvar tree=list.ToTree();//é›†åˆå…ƒç´ ç»§æ‰¿è‡ªITreeEntity<T,TKey>æˆ–ITreeEntity<T>çš„é›†åˆè½¬æ¢æˆæ ‘å½¢ç»“æ„\nvar tree=list.ToTree(c => c.Id, c => c.Pid);//é›†åˆå…ƒç´ ç»§æ‰¿è‡ªITreeParent<T>, ITreeChildren<T>çš„é›†åˆè½¬æ¢æˆæ ‘å½¢ç»“æ„\nvar tree=list.ToTreeGeneral(c => c.Id, c => c.Pid);//ä¸€èˆ¬çš„é›†åˆè½¬æ¢æˆæ ‘å½¢ç»“æ„\n```\n\n----------------------------------------\n\nTITLE: Radar Chart Polygon Intersection and Area Calculation in C#\nDESCRIPTION: These snippets demonstrate calculating the intersection of radar chart polygons and computing area within a C# context, useful for multi-dimensional similarity or user profiling. The operations require a RadarChartEngine and support area calculation post-intersection. Expected inputs are polygon/chart objects; output is a list of intersection points and polygon area as a numeric value.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nvar points=RadarChartEngine.ComputeIntersection(chart1,chart2); //è·å–ä¸¤ä¸ªå¤šè¾¹å½¢çš„ç›¸äº¤åŒºåŸŸ\npoints.ComputeArea(); //è®¡ç®—å¤šè¾¹å½¢é¢ç§¯\n```\n\n----------------------------------------\n\nTITLE: Initializing ConcurrentHashSet in C#\nDESCRIPTION: Shows how to instantiate a `ConcurrentHashSet<T>`, a thread-safe hash set implementation provided by Masuit.Tools. Its usage is consistent with the standard `HashSet<T>`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar set = new ConcurrentHashSet<string>(); // ç”¨æ³•å’Œhashsetä¿æŒä¸€è‡´\n```\n\n----------------------------------------\n\nTITLE: Initializing Fixed-Size Queues in C#\nDESCRIPTION: Demonstrates the creation of a standard fixed-size queue (`LimitedQueue<T>`) and a thread-safe fixed-size queue (`ConcurrentLimitedQueue<T>`) using the Masuit.Tools library. Both queues are initialized with a capacity of 32 elements. For .NET 5 and above, using the built-in `System.Threading.Channels.Channel` is recommended for similar functionality.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nLimitedQueue<string> queue = new LimitedQueue<string>(32);// å£°æ˜ä¸€ä¸ªå®¹é‡ä¸º32ä¸ªå…ƒç´ çš„å®šé•¿é˜Ÿåˆ—\nConcurrentLimitedQueue<string> queue = new ConcurrentLimitedQueue<string>(32);// å£°æ˜ä¸€ä¸ªå®¹é‡ä¸º32ä¸ªå…ƒç´ çš„çº¿ç¨‹å®‰å…¨çš„å®šé•¿é˜Ÿåˆ—\n```\n\n----------------------------------------\n\nTITLE: Generating CAPTCHA Codes and Images in C#\nDESCRIPTION: Shows how to generate a textual validation code (CAPTCHA) of a specified length using `ValidateCode.ValidateCode(length)`. Subsequently, it demonstrates creating a graphical representation (image stream) of the generated code using the `.CreateValidateGraphic()` method.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nvar code=ValidateCode.ValidateCode(6); // ç”Ÿæˆ6ä½é•¿åº¦çš„éªŒè¯ç \nvar stream=code.CreateValidateGraphic(); // ç”ŸæˆéªŒè¯ç å›¾ç‰‡æµ\n```\n\n----------------------------------------\n\nTITLE: Using FallbackJsonPropertyResolver for Multiple JSON Aliases (Newtonsoft.Json) (C#)\nDESCRIPTION: Demonstrates how to use the `FallbackJsonPropertyResolver` with Newtonsoft.Json. By configuring this resolver in `JsonSerializerSettings`, JSON deserialization will respect the multiple alias names defined using the `[FallbackJsonProperty]` attribute on the DTO, allowing for more flexible mapping from different JSON structures to the same C# model. Requires `Masuit.Tools` and `Newtonsoft.Json`.\nSOURCE: https://github.com/ldqk/masuit.tools/blob/master/README.md#_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nJsonConvert.SerializeObject(new MyClass(),new JsonSerializerSettings()\n{\n    ContractResolver = new FallbackJsonPropertyResolver() // é…ç½®ä½¿ç”¨FallbackJsonPropertyResolverè§£é‡Šå™¨\n});\n```"
  }
]