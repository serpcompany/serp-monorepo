[
  {
    "owner": "networkx",
    "repo": "networkx",
    "content": "TITLE: Importing NetworkX Library in Python\nDESCRIPTION: Imports the NetworkX library using the conventional alias 'nx'. This is the standard first step for utilizing NetworkX functionalities in a Python script or session.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\n```\n\n----------------------------------------\n\nTITLE: Creating and Analyzing a MultiGraph with Weighted Edges in NetworkX (Python)\nDESCRIPTION: Shows how to create a MultiGraph, add multiple weighted edges (potentially between the same node pair), and compute the degree for each node using edge weights. Uses add_weighted_edges_from() to add edges with possible repeats. Produces a dictionary mapping nodes to their weighted degrees, highlighting support for repeated edges.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nMG = nx.MultiGraph()\\nMG.add_weighted_edges_from([(1, 2, 0.5), (1, 2, 0.75), (2, 3, 0.5)])\\ndict(MG.degree(weight='weight'))\n```\n\n----------------------------------------\n\nTITLE: Generating Stochastic Graphs with NetworkX Random Generators in Python\nDESCRIPTION: Demonstrates usage of random graph generators such as erdos_renyi_graph, watts_strogatz_graph, barabasi_albert_graph, and random_lobster. NetworkX must be imported. Inputs are node counts and model parameters, outputs are stochastically constructed network objects, useful for simulation, modeling, and structure analysis.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ner = nx.erdos_renyi_graph(100, 0.15)\\nws = nx.watts_strogatz_graph(30, 3, 0.1)\\nba = nx.barabasi_albert_graph(100, 5)\\nred = nx.random_lobster(100, 0.9, 0.9)\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX via pip - Bash/Shell\nDESCRIPTION: This snippet demonstrates how to install the released version of NetworkX and its default dependencies using pip from a terminal. It assumes pip is available for the current Python environment and that the user has the necessary permissions. The command installs the stable version of NetworkX plus recommended extras. No additional setup is required unless pip or Python is not installed.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install networkx[default]\n```\n\n----------------------------------------\n\nTITLE: Collapsing MultiGraph Edges Using Minimum Weights and Shortest Path in NetworkX (Python)\nDESCRIPTION: This snippet converts a MultiGraph MG into a standard Graph GG, collapsing parallel edges by taking their minimum weight, then computes the shortest path. Relies on prior existence of MG with 'weight' attributes. Inputs are adjacency data from MG, output is a shortest path in GG between nodes 1 and 3 considering minimal edge weights. Highlights a pattern for making measurement results well defined on multi-edge graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nGG = nx.Graph()\\nfor n, nbrs in MG.adjacency():\\n   for nbr, edict in nbrs.items():\\n       minvalue = min([d['weight'] for d in edict.values()])\\n       GG.add_edge(n, nbr, weight = minvalue)\\n\\nnx.shortest_path(GG, 1, 3)\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Path with NetworkX in Python\nDESCRIPTION: This Python snippet demonstrates a simple use case of the NetworkX library. It initializes an undirected graph (G), adds several edges with associated weights, and then uses the `nx.shortest_path` function to calculate and return the shortest path between nodes \"A\" and \"D\", taking the 'weight' attribute of the edges into account. The expected output is the list of nodes ['A', 'B', 'D'] representing the shortest path.\nSOURCE: https://github.com/networkx/networkx/blob/main/README.rst#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import networkx as nx\n>>> G = nx.Graph()\n>>> G.add_edge(\"A\", \"B\", weight=4)\n>>> G.add_edge(\"B\", \"D\", weight=2)\n>>> G.add_edge(\"A\", \"C\", weight=3)\n>>> G.add_edge(\"C\", \"D\", weight=4)\n>>> nx.shortest_path(G, \"A\", \"D\", weight=\"weight\")\n['A', 'B', 'D']\n```\n\n----------------------------------------\n\nTITLE: Saving a NetworkX Graph Visualization to a File using Matplotlib in Python\nDESCRIPTION: Demonstrates saving a NetworkX graph drawing to a file using Matplotlib. First, the graph `G` (assumed defined) is drawn using `nx.draw()`. Then, `plt.savefig(\"path.png\")` is called to save the current Matplotlib figure to a PNG file named 'path.png' in the current directory. Requires `matplotlib.pyplot` (as `plt`) and a NetworkX graph `G`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_28\n\nLANGUAGE: pycon\nCODE:\n```\n>>> nx.draw(G)\n>>> plt.savefig(\"path.png\")\n```\n\n----------------------------------------\n\nTITLE: Adding and Modifying Edge Attributes with NetworkX in Python\nDESCRIPTION: Demonstrates how to add or update edge attributes in a NetworkX graph using multiple methods: add_edge, add_edges_from, and subscript notation. Dependencies include NetworkX, and assumes an existing graph object G. Input consists of edges or edge attribute data, modifying the internal graph structure accordingly. Output is the updated graph with annotated edges, and 'weight' attributes should be numeric for compatibility with weighted algorithms.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nG.add_edge(1, 2, weight=4.7 )\\nG.add_edges_from([(3, 4), (4, 5)], color='red')\\nG.add_edges_from([(1, 2, {'color': 'blue'}), (2, 3, {'weight': 8})])\\nG[1][2]['weight'] = 4.7\\nG.edges[3, 4]['weight'] = 4.2\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Sparse Matrices in Matrix Market Coordinate Format with SciPy and NetworkX (Python)\nDESCRIPTION: This snippet shows working with sparse graph adjacency matrices using the Matrix Market coordinate format. It converts a NetworkX path graph to a SciPy sparse matrix in COO (coordinate) format, writes it to a Matrix Market file, reads it back, and reconstructs the graph. Dependencies include networkx, scipy, and io. The workflow illustrates efficient handling of sparse graphs, using BytesIO as a mock file and ensuring graph integrity through the serialization/deserialization process.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/matrix_market.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import scipy as sp\n>>> import io  # Use BytesIO as a stand-in for a Python file object\n>>> fh = io.BytesIO()\n\n>>> G = nx.path_graph(5)\n>>> m = nx.to_scipy_sparse_array(G)\n>>> print(m)\n  (0, 1)        1\n  (1, 0)        1\n  (1, 2)        1\n  (2, 1)        1\n  (2, 3)        1\n  (3, 2)        1\n  (3, 4)        1\n  (4, 3)        1\n\n>>> sp.io.mmwrite(fh, m)\n>>> print(fh.getvalue().decode('utf-8'))  # file contents\n%%MatrixMarket matrix coordinate integer symmetric\n%\n5 5 4\n2 1 1\n3 2 1\n4 3 1\n5 4 1\n\n>>> # Read from file\n>>> fh.seek(0)\n>>> H = nx.from_scipy_sparse_array(sp.io.mmread(fh))\n>>> H.edges() == G.edges()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Accessing JSON Graph Serialization/Deserialization Functions - NetworkX - Python\nDESCRIPTION: This snippet (in the form of directives) enumerates functions available in the networkx.readwrite.json_graph module, corresponding to various JSON formats for representing NetworkX graphs. The listed items (node_link_data, node_link_graph, adjacency_data, adjacency_graph, cytoscape_data, cytoscape_graph, tree_data, tree_graph) offer serialization (graph to dict) and deserialization (dict to graph) functionality using different schemas. Intended for developers using Sphinx autodoc/autosummary to build documentation, it requires NetworkX installed, and assumes familiarity with Python's documentation tools. Input parameters for these functions generally include NetworkX graph objects and optionally additional attribute mappings; outputs are dictionaries suitable for JSON encoding or reconstructed graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/json_graph.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: networkx.readwrite.json_graph\n.. autosummary::\n   :toctree: generated/\n\n   node_link_data\n   node_link_graph\n   adjacency_data\n   adjacency_graph\n   cytoscape_data\n   cytoscape_graph\n   tree_data\n   tree_graph\n\n```\n\n----------------------------------------\n\nTITLE: Generating and Drawing Complete Graph with Circular Layout (Python)\nDESCRIPTION: Python script example intended for the NetworkX gallery. It imports 'networkx' and 'matplotlib.pyplot', creates a complete graph with 10 nodes using 'nx.complete_graph(10)', and then draws it using 'nx.draw_networkx' with node positions determined by 'nx.circular_layout'. Dependencies include 'networkx' and 'matplotlib'.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/new_contributor_faq.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nG = nx.complete_graph(10)  # A complete graph with 10 nodes\nnx.draw_networkx(G, pos=nx.circular_layout(G))\n```\n\n----------------------------------------\n\nTITLE: Checking Eulerian Path Presence with Directed Graphs - NetworkX - Python\nDESCRIPTION: Demonstrates how to construct a directed graph using NetworkX, add an isolated node, and check for the presence of an Eulerian path. The code requires the NetworkX Python library. Key variables are the directed graph instance G and the isolated node added. Inputs are the edges and node, and the output is a boolean indicating whether an Eulerian path exists.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.8.1.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> G = nx.DiGraph([(0, 1), (1, 2), (2, 0)])\\n>>> G.add_node(3)\\n>>> nx.has_eulerian_path(G)\n```\n\n----------------------------------------\n\nTITLE: Converting and Reading Graph6 Files with NetworkX (Python)\nDESCRIPTION: This snippet lists primary functions for encoding and decoding graphs using the graph6 format via the networkx.readwrite.graph6 module. These functions handle conversion from and to bytes, and file I/O operations. Key dependencies are NetworkX and valid graph objects; the expected input is a NetworkX graph or graph6-format data, and output is either a graph or encoded bytes. Limitations include support only for undirected graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/sparsegraph6.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n   from_graph6_bytes\n   read_graph6\n   to_graph6_bytes\n   write_graph6\n```\n\n----------------------------------------\n\nTITLE: Setting Node and Edge Attributes with Explicit Keywords - NetworkX - Python\nDESCRIPTION: Compares legacy and updated approaches to assigning node and edge attributes using set_node_attributes and set_edge_attributes, emphasizing new argument order and use of keyword arguments for forward compatibility. Dependencies: networkx, graph G. Input: Attribute dicts. Output: Attribute assignment to graph.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph([(1, 2), (1, 3)])\n>>> nx.set_node_attributes(G, 'label', {1: 'one', 2: 'two', 3: 'three'})  # doctest: +SKIP\n>>> nx.set_edge_attributes(G, 'label', {(1, 2): 'path1', (2, 3): 'path2'})  # doctest: +SKIP\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph([(1, 2), (1, 3)])\n>>> nx.set_node_attributes(G, name='label', values={1: 'one', 2: 'two', 3: 'three'})\n>>> nx.set_edge_attributes(G, name='label', values={(1, 2): 'path1', (2, 3): 'path2'})\n```\n\n----------------------------------------\n\nTITLE: Constructing and Querying Directed Graphs with NetworkX in Python\nDESCRIPTION: Illustrates creation of a directed graph using DiGraph, adding weighted edges, and computing out-degree with weight consideration. Requires NetworkX and demonstrates edge addition with weights in the DG object. Outputs the weighted out-degree for a node, supporting analyses involving directionality and edge attributes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nDG = nx.DiGraph()\\nDG.add_weighted_edges_from([(1, 2, 0.5), (3, 1, 0.75)])\\nDG.out_degree(1, weight='weight')\n```\n\n----------------------------------------\n\nTITLE: Calculating Average In-Neighbor In-Degree using NetworkX in Python\nDESCRIPTION: This Python code snippet demonstrates the usage of the `networkx.average_neighbor_degree` function on a directed graph (`nx.DiGraph`). It calculates the average in-degree of the in-neighbors for each node in a path graph of length 3. This example illustrates the corrected behavior in NetworkX 2.8, where the calculation properly averages the specified neighbor degrees (`source=\\\"in\\\"`, `target=\\\"in\\\"`). The expected output is a dictionary mapping node IDs to their average neighbor degree values.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.8.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.path_graph(3, create_using=nx.DiGraph)\n>>> print(nx.average_neighbor_degree(G, source=\"in\", target=\"in\"))\n{0: 0.0, 1: 1.0, 2: 1.0}\n```\n\n----------------------------------------\n\nTITLE: Adding Edges with Custom Attributes and Using Hashable Objects as Nodes in Python\nDESCRIPTION: Demonstrates adding an edge with a non-numeric attribute (a function object `math.cos`) and adding a function object itself as a node to the graph. This highlights the flexibility of NetworkX in using any hashable Python object as a node and associating arbitrary data with edges. Requires the `math` module to be imported.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport math\nG.add_edge('y', 'x', function=math.cos)\nG.add_node(math.cos)  # any hashable can be a node\n```\n\n----------------------------------------\n\nTITLE: Querying Weighted Degree in Directed Graphs with NetworkX in Python\nDESCRIPTION: Shows how to compute the total (in + out) degree for a specific node in a directed graph, accounting for edge weights. Dependent on a pre-initialized DiGraph DG with edge weights set. Returns the sum of weighted in- and out-degrees, providing insight into node connectivity within directed graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDG.degree(1, weight='weight')\n```\n\n----------------------------------------\n\nTITLE: Calling NetworkX PageRank with Explicit Backend in Python\nDESCRIPTION: Shows how to explicitly specify a backend ('fast_backend') when calling a NetworkX function (`nx.pagerank`). This requires the backend to be installed and implement the function; NetworkX will not fall back to its default implementation if `backend=` is used. The result `pr` will contain the PageRank values computed by the specified backend.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\npr = nx.pagerank(G, backend=\"fast_backend\")\n```\n\n----------------------------------------\n\nTITLE: Enumerating Successors in Directed Graphs with NetworkX in Python\nDESCRIPTION: Demonstrates retrieval of all immediate successors (out-neighbors) for a node in a directed graph using the successors() method. Requires a directed graph DG. Input is a node identifier and outputs a list of successors, essential for traversal and reachability analyses.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlist(DG.successors(1))\n```\n\n----------------------------------------\n\nTITLE: Assigning and Accessing Graph Attributes in NetworkX Python\nDESCRIPTION: Demonstrates how to initialize a NetworkX Graph with attributes using keyword arguments (e.g., `region='Africa'`) and how to add or access graph-level attributes directly via the `G.graph` dictionary member (e.g., `G.graph['color']='green'`). Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph(region='Africa')\n>>> G.graph['color']='green'\n>>> G.graph\n{'region': 'Africa', 'color': 'green'}\n```\n\n----------------------------------------\n\nTITLE: Computing Node Clustering Coefficient with NetworkX in Python\nDESCRIPTION: Computes the clustering coefficient of all nodes in a graph, measuring the tendency to form triangles. Requires NetworkX and initialized graph G. Returns a dictionary mapping nodes to their clustering coefficient values.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nnx.clustering(G)\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX with Extra Packages via pip - Bash/Shell\nDESCRIPTION: This snippet shows how to install NetworkX along with its extra recommended packages in a single pip command. The [default,extra] syntax specifies multiple optional dependencies that extend functionality (such as graph drawing and XML support). Requires pip and a C/C++ compiler for some binaries.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install networkx[default,extra]\n```\n\n----------------------------------------\n\nTITLE: Accessing Edge Attributes in NetworkX Graphs (Python)\nDESCRIPTION: Demonstrates how to add and access attributes associated with edges in a NetworkX graph. An edge with 'color', 'weight', and 'size' attributes is added between nodes 1 and 2, and then these attributes are retrieved using both the adjacency dictionary (`G[1][2]['size']`) and the edges view (`G.edges[1, 2]['color']`). Requires the `networkx` library imported as `nx` (implicitly assumed from context).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\nG.add_edge(1, 2, color='red', weight=0.84, size=300)\nprint(G[1][2]['size'])\nprint(G.edges[1, 2]['color'])\n```\n\n----------------------------------------\n\nTITLE: Adding Single Edges with Attributes to a NetworkX Graph in Python\nDESCRIPTION: Illustrates how to add individual edges to an existing NetworkX `Graph` object using the `add_edge` method. It shows adding an edge with default attributes and adding another edge with a specific `weight` attribute.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\nG.add_edge(1, 2)  # default edge data=1\nG.add_edge(2, 3, weight=0.9)  # specify edge data\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Path with Dijkstra's Algorithm in NetworkX (Python)\nDESCRIPTION: Creates a simple weighted graph using `nx.Graph()` and `add_weighted_edges_from`. It then calculates and prints the shortest path between nodes 'a' and 'd' using `nx.dijkstra_path`. Requires the `networkx` library imported as `nx` (implicitly assumed from context).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\ne = [('a', 'b', 0.3), ('b', 'c', 0.9), ('a', 'c', 0.5), ('c', 'd', 1.2)]\nG.add_weighted_edges_from(e)\nprint(nx.dijkstra_path(G, 'a', 'd'))\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Dense Matrices in Matrix Market Array Format with SciPy and NetworkX (Python)\nDESCRIPTION: This snippet demonstrates saving and loading a dense graph adjacency matrix in Matrix Market array format using NumPy arrays and SciPy's mmwrite/mmread functions. It starts by converting a NetworkX complete graph to its adjacency matrix, writing it to a Matrix Market file, then reading it back and reconstructing a NetworkX graph. Dependencies: networkx, scipy, numpy, and io. The file-like object (BytesIO) is used in place of a real file. The graph structure is preserved through the round trip; expected inputs are a NetworkX graph object, and the output is a reconstructed graph equivalent to the original.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/matrix_market.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import scipy as sp\n>>> import io  # Use BytesIO as a stand-in for a Python file object\n>>> fh = io.BytesIO()\n\n>>> G = nx.complete_graph(5)\n>>> a = nx.to_numpy_array(G)\n>>> print(a)\n[[0. 1. 1. 1. 1.]\n [1. 0. 1. 1. 1.]\n [1. 1. 0. 1. 1.]\n [1. 1. 1. 0. 1.]\n [1. 1. 1. 1. 0.]]\n\n>>> # Write to file in Matrix Market array format\n>>> sp.io.mmwrite(fh, a)\n>>> print(fh.getvalue().decode('utf-8'))  # file contents\n%%MatrixMarket matrix array real symmetric\n%\n5 5\n0.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n0.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n0.0000000000000000e+00\n1.0000000000000000e+00\n1.0000000000000000e+00\n0.0000000000000000e+00\n1.0000000000000000e+00\n0.0000000000000000e+00\n\n>>> # Read from file\n>>> fh.seek(0)\n>>> H = nx.from_numpy_array(sp.io.mmread(fh))\n>>> H.edges() == G.edges()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Adding and Updating Edge Attributes in NetworkX Python\nDESCRIPTION: Demonstrates multiple methods for adding and updating edge attributes in NetworkX 1.0. It shows using `add_edge` with keyword arguments, `add_edges_from` applying a common attribute to multiple edges, `add_edges_from` using 3-tuples `(u, v, attr_dict)` for individual attributes, and updating attributes using subscript notation (`G[u][v]['attr']` or the equivalent `G.edge[u][v]['attr']`). Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_edge(1, 2, weight=4.7 )\n>>> G.add_edges_from([(3,4),(4,5)], color='red')\n>>> G.add_edges_from([(1,2,{'color':'blue'}), (2,3,{'weight':8})])\n>>> G[1][2]['weight'] = 4.7\n>>> G.edge[1][2]['weight'] = 4  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Drawing a NetworkX Graph with Basic and Shell Layouts using Matplotlib in Python\nDESCRIPTION: Creates a Petersen graph using `nx.petersen_graph()` and then draws it on two separate Matplotlib subplots. The first subplot uses `nx.draw` for a default layout, and the second uses `nx.draw_shell` to arrange nodes in specified shells (nodes 5-9 in the outer shell, 0-4 in the inner). Both include node labels with bold font weight. Requires `matplotlib.pyplot` (as `plt`) to be imported and a NetworkX graph `G`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nG = nx.petersen_graph()\nsubax1 = plt.subplot(121)\nnx.draw(G, with_labels=True, font_weight='bold')\nsubax2 = plt.subplot(122)\nnx.draw_shell(G, nlist=[range(5, 10), range(5)], with_labels=True, font_weight='bold')\n```\n\n----------------------------------------\n\nTITLE: Adding a Weighted Edge in NetworkX Python\nDESCRIPTION: Shows the basic syntax for adding a single edge between nodes 1 and 2 using `G.add_edge` and assigning it a 'weight' attribute with a floating-point value. This 'weight' key is commonly used by NetworkX algorithms. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_edge(1,2,weight=3.14159)\n```\n\n----------------------------------------\n\nTITLE: Generating Classic Graphs with NetworkX Constructors in Python\nDESCRIPTION: Illustrates generation of several standard graphs: complete, complete bipartite, barbell, and lollipop, using the relevant NetworkX generator functions. No special dependencies besides NetworkX. Inputs are graph size parameters, outputs are graph objects suitable for further operations or analysis.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nK_5 = nx.complete_graph(5)\\nK_3_5 = nx.complete_bipartite_graph(3, 5)\\nbarbell = nx.barbell_graph(10, 10)\\nlollipop = nx.lollipop_graph(10, 20)\n```\n\n----------------------------------------\n\nTITLE: Using NetworkX with Backend Prioritization in Python\nDESCRIPTION: Illustrates importing NetworkX, constructing a standard graph, and executing a supported algorithm (PageRank). Behavior changes depending on backend configuration: by default uses NetworkX, otherwise uses the backend if defined. Shows impact of backend for performance or feature improvement.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\\nG = nx.karate_club_graph()\\npr = nx.pagerank(G)  # runs using backend from NETWORKX_BACKEND_PRIORITY, if set\n```\n\n----------------------------------------\n\nTITLE: Adding Nodes with Attribute Dictionaries in NetworkX (Python)\nDESCRIPTION: Illustrates usage of the add_nodes_from method to add nodes along with their attribute dictionaries, as enabled in the NetworkX 1.1 release. This allows adding nodes with custom attributes in a single statement. Requires only base NetworkX installation. The method accepts tuples of (node, attrdict) and constructs nodes with the specified attributes for later use.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph()\n>>> G.add_nodes_from([(1, {'color': 'red'})])\n```\n\n----------------------------------------\n\nTITLE: Creating Empty NetworkX Graph Objects in Python\nDESCRIPTION: Demonstrates the instantiation of empty graph objects for each of the four basic NetworkX graph types: undirected simple graph (`Graph`), directed simple graph (`DiGraph`), undirected multigraph (`MultiGraph`), and directed multigraph (`MultiDiGraph`).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\nG = nx.DiGraph()\nG = nx.MultiGraph()\nG = nx.MultiDiGraph()\n```\n\n----------------------------------------\n\nTITLE: Computing All-Pairs Shortest Paths as a Dictionary with NetworkX in Python\nDESCRIPTION: Calculates shortest paths between all pairs of nodes and stores them in a dictionary. Input is a NetworkX graph G; output is a dict with node keys and path lists as values, providing easy access to shortest paths from each node. Post-processing example accesses paths from node 3.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsp = dict(nx.all_pairs_shortest_path(G))\\nsp[3]\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX with Optional Dependencies (Shell)\nDESCRIPTION: This shell command uses `pip` to install the NetworkX library along with its 'default' set of optional dependencies. Specifying `[default]` ensures that extra packages required for certain functionalities (like plotting or specific algorithms) are also installed.\nSOURCE: https://github.com/networkx/networkx/blob/main/README.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ pip install networkx[default]\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Edges and Weighted Edges to a NetworkX Graph in Python\nDESCRIPTION: Shows how to add multiple edges to a graph efficiently using lists. `add_edges_from` adds edges defined as tuples `(u, v)`, while `add_weighted_edges_from` adds edges from tuples `(u, v, weight)`, automatically assigning the third element as the 'weight' attribute.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nelist = [(1, 2), (2, 3), (1, 4), (4, 2)]\nG.add_edges_from(elist)\nelist = [('a', 'b', 5.0), ('b', 'c', 3.0), ('a', 'c', 1.0), ('c', 'd', 7.3)]\nG.add_weighted_edges_from(elist)\n```\n\n----------------------------------------\n\nTITLE: Directly Accessing Edge Weight Attribute in NetworkX Python\nDESCRIPTION: Demonstrates the direct method for accessing the value of a specific edge attribute (here, 'weight') in NetworkX 1.0. This is done using dictionary-style access `G[u][v]['attribute_key']`, assuming the edge (1, 2) and the 'weight' attribute exist. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> w = G[1][2]['weight']\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Nodes - NetworkX - Python\nDESCRIPTION: Shows how to iterate over nodes in a NetworkX graph using the NodeView interface. Dependencies: networkx, existing graph G. Prints each node integer as output. Useful for examining all nodes in a graph.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> for node in G.nodes:\n...     print(node)\n0\n1\n2\n3\n4\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Backends for NetworkX with Environment Variable in Bash\nDESCRIPTION: Demonstrates how to prioritize multiple backends by setting NETWORKX_BACKEND_PRIORITY to a comma-separated list, enabling fallback. Works on compatible Unix shells. NetworkX will try backends in order for each function call.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nbash$> NETWORKX_BACKEND_PRIORITY=\"fast_backend,other_backend\" python my_script.py\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging for NetworkX Modules in Python\nDESCRIPTION: Activates logging output specifically for NetworkX to help users debug backend dispatching or other internal details. Instantiates a logger for 'networkx', adds a stream handler, sets a formatter, and configures debug level. Expected input is none (for initialization). Outputs log messages at DEBUG level for NetworkX operations.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nimport logging\\n_l = logging.getLogger(\"networkx\")\\n_l.addHandler(_h:=logging.StreamHandler())\\n_h.setFormatter(logging.Formatter(\"%(levelname)s:NetworkX:%(message)s\"))\\n_l.setLevel(logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Drawing NetworkX Graphs with Various Layouts and Options using Matplotlib in Python\nDESCRIPTION: Defines a dictionary `options` for customizing node appearance (black color, size 100) and edge width (3). It then draws a graph `G` (assumed to be defined previously) on four separate subplots using different layout functions: `nx.draw_random`, `nx.draw_circular`, `nx.draw_spectral`, and `nx.draw_shell` (using specific shells). The defined `options` are applied to each drawing. Requires `matplotlib.pyplot` (as `plt`) and a NetworkX graph `G`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\noptions = {\n    'node_color': 'black',\n    'node_size': 100,\n    'width': 3,\n}\nsubax1 = plt.subplot(221)\nnx.draw_random(G, **options)\nsubax2 = plt.subplot(222)\nnx.draw_circular(G, **options)\nsubax3 = plt.subplot(223)\nnx.draw_spectral(G, **options)\nsubax4 = plt.subplot(224)\nnx.draw_shell(G, nlist=[range(5,10), range(5)], **options)\n```\n\n----------------------------------------\n\nTITLE: Creating a NumPy Generator Instance - Python\nDESCRIPTION: This snippet shows a proposed implementation updating the random state initialization to use np.random.default_rng and support both RandomState and Generator objects as valid returns. Input types handled include None, int, RandomState, and Generator. In cases of unsupported types, a ValueError is raised. Dependencies: NumPy 1.17 or newer, which includes the default_rng API.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef create_random_state(random_state=None):\n    if random_state is None or random_state is np.random:\n        return np.random.default_rng()\n    if isinstance(random_state, (np.random.RandomState, np.random.Generator)):\n        return random_state\n    if isinstance(random_state, int):\n        return np.random.default_rng(random_state)\n    msg = (\n        f\"{random_state} cannot be used to create a numpy.random.RandomState or\\n\"\n        \"numpy.random.Generator instance\"\n    )\n    raise ValueError(msg)\n```\n\n----------------------------------------\n\nTITLE: Drawing a Dodecahedral Graph with Multi-Shell Layout in NetworkX using Python\nDESCRIPTION: Creates a dodecahedral graph using `nx.dodecahedral_graph()`. It defines a list of lists (`shells`) specifying which nodes belong to each of the three concentric shells. The graph is then drawn using `nx.draw_shell`, passing the specific `shells` via the `nlist` argument and applying previously defined drawing `options`. Requires `matplotlib.pyplot` (as `plt`) and the `options` dictionary.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nG = nx.dodecahedral_graph()\nshells = [[2, 3, 4, 5, 6], [8, 1, 0, 19, 18, 17, 16, 15, 14, 7], [9, 10, 11, 12, 13]]\nnx.draw_shell(G, nlist=shells, **options)\n```\n\n----------------------------------------\n\nTITLE: Adding Edges using Unpacking - NetworkX - Python\nDESCRIPTION: Demonstrates the updated method for adding an edge in NetworkX 0.99 using the * operator to unpack node tuples rather than passing an edge tuple. Requires the networkx library and Python 2.4+. The input consists of node identifiers and an edge tuple; the output is a graph with the edge added. The snippet also shows adding edge data with the 'data' parameter. Prior versions accepted edge tuples directly, but now they must be unpacked. Specialized edge data can also be included.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> import networkx as nx\n>>> u='a'\n>>> v='b'\n>>> e=(u,v)\n>>> G=nx.Graph()\n\n# Old\n>>> # G.add_edge((u,v))  # or G.add_edge(e)\n\n# New\n>>> G.add_edge(*e) # or G.add_edge(*(u,v))\n\n# Adding edge with custom data\n>>> # G.add_edge('a','b','foo')  # add edge with string \"foo\" as data\n>>> # G.add_edge(1,2,5.0)  # add edge with float 5 as data\n```\n\n----------------------------------------\n\nTITLE: Basic Graph Construction and Component Analysis with NetworkX in Python\nDESCRIPTION: Demonstrates constructing a simple undirected graph, adding nodes and edges, and enumerating connected components. NetworkX is required. Inputs include edge tuples and explicit node additions, outputs the list of sets representing the graph's connected components, useful for validating connectivity.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\\nG.add_edges_from([(1, 2), (1, 3)])\\nG.add_node(\"spam\")       # adds node \"spam\"\\nlist(nx.connected_components(G))\n```\n\n----------------------------------------\n\nTITLE: Retrieving Neighbors of a Node - NetworkX - Python\nDESCRIPTION: Demonstrates how to get an iterator of a node's neighbors and convert it into a list. Dependencies: networkx, graph G, node n. Input: Node identifier. Output: Iterator and list of adjacent nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> n = 1\n>>> G.neighbors(n)\n<dict_keyiterator object at ...>\n>>> list(G.neighbors(n))\n[0, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Setting Node Attributes with Keywords in NetworkX (Python)\nDESCRIPTION: Demonstrates setting node attributes using explicit keyword arguments 'values' and 'name' in NetworkX graphs to ensure compatibility across v1.x and v2.x. Requires NetworkX installed and a pre-existing graph object G. The snippet sets the 'weight' attribute for all nodes to 1.0.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> nx.set_node_attributes(G, values=1.0, name='weight')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Node View in NetworkX 2.0 (Python)\nDESCRIPTION: This snippet shows the new behavior of `G.nodes()` in NetworkX 2.0. It now returns a `NodeView` object, which is a dynamic view of the graph's nodes. To get a list, explicit conversion using `list()` is required. This replaces the separate list-returning and iterator-returning methods of previous versions.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.complete_graph(5)\n>>> G.nodes()\nNodeView((0, 1, 2, 3, 4))\n>>> list(G.nodes())\n[0, 1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Configuring NETWORKX_BACKEND_PRIORITY Environment Variable in Bash\nDESCRIPTION: Shows how to run a Python script with a specific backend for NetworkX by setting the NETWORKX_BACKEND_PRIORITY environment variable. Executed in the shell before or while running a script. Enables backend-based acceleration or feature enhancements for supported functions.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nbash$> NETWORKX_BACKEND_PRIORITY=fast_backend python my_script.py\n```\n\n----------------------------------------\n\nTITLE: Importing SciPy Subpackages Convention\nDESCRIPTION: This Python code snippet demonstrates the preferred way to access SciPy subpackages within NetworkX code. It shows importing SciPy as `sp` and then accessing subpackages like `sparse.linalg` via the top-level `sp` namespace, rather than importing subpackages directly.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport scipy as sp\n```\n\nLANGUAGE: python\nCODE:\n```\nsp.sparse.linalg\n```\n\n----------------------------------------\n\nTITLE: Drawing Graphs with Graphviz Interface in NetworkX (Python)\nDESCRIPTION: Demonstrates calling the optional pygraphviz/pydot interface via `draw_graphviz(G)` to visualize NetworkX graphs using Graphviz. The interface prefers pygraphviz if available. This capability was introduced in NetworkX version 0.26.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndraw_graphviz(G)\n```\n\n----------------------------------------\n\nTITLE: Copying Node Attribute Dictionaries Safely in NetworkX (Python)\nDESCRIPTION: Illustrates safe and unsafe methods for copying node attribute dictionaries between graphs in NetworkX. It shows that direct assignment (G.node[n] = H.node[n]) was dangerous in v1.x and is disallowed in v2.x, while updating the attribute dictionary (G.nodes[n].update(H.nodes[n])) is safe in v2.x. Requires NetworkX, graphs G and H, and node n present in both graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> # dangerous in v1.x, not allowed in v2.x\n>>> G.node[n] = H.node[n]  # doctest: +SKIP\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> G.nodes[n].update(H.nodes[n])  # works in v2.x\n```\n\n----------------------------------------\n\nTITLE: Defining a Backend Graph Class in Python\nDESCRIPTION: Defines the basic structure for a custom backend graph class in NetworkX. It must include the '__networkx_backend__' attribute set to the backend's entry point name. It may optionally include '__networkx_cache__' for caching.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass BackendGraph:\n    __networkx_backend__ = \"backend_name\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Converting NetworkX Component Generator to List (Python)\nDESCRIPTION: Demonstrates how to convert the generator returned by functions like `connected_components` in the `networkx.algorithms.components` package back into a list. This is necessary to replicate the behavior of older versions where these functions returned lists directly. `G` represents a NetworkX graph object.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.9.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlist(connected_components(G))\n```\n\n----------------------------------------\n\nTITLE: Drawing NetworkX Graphs with Matplotlib (Python)\nDESCRIPTION: Demonstrates basic graph drawing using NetworkX and Matplotlib. It creates a cubical graph and draws it in two different subplots: one with the default spring layout and another with a circular layout, specifying node and edge colors. Requires `networkx` (as `nx`) and `matplotlib.pyplot` (as `plt`).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nG = nx.cubical_graph()\nsubax1 = plt.subplot(121)\nnx.draw(G)   # default spring_layout\nsubax2 = plt.subplot(122)\nnx.draw(G, pos=nx.circular_layout(G), node_color='r', edge_color='b')\n```\n\n----------------------------------------\n\nTITLE: Explicitly Using a Specified Backend in NetworkX Algorithm - Python\nDESCRIPTION: Illustrates explicit dispatch to the 'parallel' backend when calling NetworkX's 'betweenness_centrality' algorithm. The 'backend' keyword argument chooses the backend at call time, converting the input graph as needed and caching the result by default. Dependencies include NetworkX with a compatible 'parallel' backend installed. Inputs are the graph G, the sample size k, and optionally the backend name. The output is the betweenness centrality calculated by the selected backend.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnx.betweenness_centrality(G, k=10, backend=\"parallel\")\n```\n\n----------------------------------------\n\nTITLE: Sorting Node Degrees in NetworkX Graphs in Python\nDESCRIPTION: Shows how to retrieve the degree (number of incident edges) for each node and sort the results. Assumes G is a graph, and outputs a sorted list of degrees. Handy for basic degree distribution analysis.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsorted(d for n, d in G.degree())\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Spanning Tree in NetworkX 2.0 (Python)\nDESCRIPTION: This snippet demonstrates how to use the new `maximum_spanning_tree` function introduced in NetworkX 2.0. It shows specifying the algorithm ('kruskal') using the required `algorithm` parameter.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> nx.maximum_spanning_tree(G, algorithm='kruskal')\n```\n\n----------------------------------------\n\nTITLE: Seeding Global RNGs in Python with random and NumPy\nDESCRIPTION: Demonstrates how to set the seed for the global random number generators in both Python's built-in `random` module and the `numpy.random` package using integer values. This ensures reproducible sequences of pseudo-random numbers for debugging or scientific publication. Requires `random` and `numpy` to be imported.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/randomness.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import random\n>>> random.seed(246)        # or any integer\n>>> import numpy as np\n>>> np.random.seed(4812)\n```\n\n----------------------------------------\n\nTITLE: Performing Shallow and Deep Copies of NetworkX Graphs in Python\nDESCRIPTION: Shows the difference between creating a shallow copy and a deep copy of a NetworkX graph `G`. A shallow copy (`nx.Graph(G)`) shares data structures with the original, while a deep copy (`G.copy()`) creates fully independent copies of the graph structure and all associated node/edge attributes. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph()\n>>> G_shallow=nx.Graph(G) # shallow copy\n>>> G_deep=G.copy() # deep copy\n```\n\n----------------------------------------\n\nTITLE: Embedding Sphinx Parameter Declarations in MyST Markdown - Markdown\nDESCRIPTION: This code snippet demonstrates how to declare the current Python module within Sphinx-compatible MyST Markdown files using the \\\"{currentmodule} networkx\\\" directive. No dependencies are required apart from Sphinx and MyST parser support. The directive helps link documented content to relevant Python modules for improved reference resolution and is a common pattern in Sphinx-based documentation. No runtime inputs or outputs are involved; this is purely contextual metadata.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/backends.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{currentmodule} networkx\n\n```\n```\n\n----------------------------------------\n\nTITLE: Working with Degree Views - NetworkX - Python\nDESCRIPTION: Demonstrates various ways to inspect node degrees using DegreeView, including lookup, iteration, and dict conversion. Works with NetworkX undirected graphs G. Inputs: Optional subset of nodes. Outputs: DegreeView, list of tuples, or dict mapping nodes to degrees.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> G.degree  # for backward compatibility G.degree() works as well\nDegreeView({0: 4, 1: 4, 2: 4, 3: 4, 4: 4})\n>>> G.degree([1, 2, 3])\nDegreeView({1: 4, 2: 4, 3: 4})\n>>> list(G.degree([1, 2, 3]))\n[(1, 4), (2, 4), (3, 4)]\n>>> dict(G.degree([1, 2, 3]))\n{1: 4, 2: 4, 3: 4}\n>>> G.degree\nDegreeView({0: 4, 1: 4, 2: 4, 3: 4, 4: 4})\n>>> list(G.degree)\n[(0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]\n>>> dict(G.degree)\n{0: 4, 1: 4, 2: 4, 3: 4, 4: 4}\n```\n\n----------------------------------------\n\nTITLE: Querying Edges for an Existing Node using NetworkX in Python\nDESCRIPTION: This Python snippet demonstrates creating a directed graph (DiGraph) using NetworkX, adding edges using `add_edges_from`, and then querying the outgoing edges for a specific node ('ab') using the `G.edges()` method. Since 'ab' exists as a node in the graph, the method returns edges originating from it.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/glossary.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx as nx\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(\"b\", \"c\"), (\"a\", \"ab\"), (\"ab\", \"c\")])\n>>> G.edges(\"ab\")\nOutEdgeDataView([('ab', 'c')])\n```\n\n----------------------------------------\n\nTITLE: Adding and Updating Edge Weight Attribute in NetworkX Python\nDESCRIPTION: Illustrates how to add an edge with a specific 'weight' attribute using `add_edge` in NetworkX 1.0. It also shows how to subsequently update that 'weight' attribute value using dictionary-style access `G[u][v]['weight']`. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph()\n>>> G.add_edge(1,2,weight=3.1415) # add the edge 1-2 with a weight\n>>> G[1][2]['weight']=2.3 # set the weight to 2.3\n```\n\n----------------------------------------\n\nTITLE: Initializing and Inspecting Graph Node Views - NetworkX - Python\nDESCRIPTION: Demonstrates creation of a complete graph and retrieval of its nodes using the NetworkX NodeView interface. The code highlights how G.nodes and iteration over G.nodes provides dict-like access, backward-compatible with G.nodes(). Dependencies: networkx. Input: None. Output: NodeView of integer nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx as nx\n>>> G = nx.complete_graph(5)\n>>> G.nodes  # for backward compatibility G.nodes() works as well\nNodeView((0, 1, 2, 3, 4))\n```\n\n----------------------------------------\n\nTITLE: Creating an Undirected Graph from a Directed Graph in NetworkX (Python)\nDESCRIPTION: Demonstrates the transformation of a directed graph into an undirected graph by constructing a new Graph object from an existing DiGraph. Given a directed graph G, this creates an undirected version H, suitable for algorithms that require undirected graphs. Maintains original nodes and edges, but ignores edge directionality.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nH = nx.Graph(G)  # create an undirected graph H from a directed graph G\n```\n\n----------------------------------------\n\nTITLE: Listing Nodes with Python list() - NetworkX - Python\nDESCRIPTION: Utilizes the Python built-in list() to convert a NodeView to a standard list, yielding all node identifiers. Dependencies: networkx, graph G. Input: None. Output: List of node integers.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> list(G.nodes)\n[0, 1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Tests via SetupTools (Shell)\nDESCRIPTION: Explains how to execute the NetworkX test suite using the setuptools command `python setup.py test`. This improved testing infrastructure was introduced in version 0.25, leveraging setuptools.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\npython setup.py test\n```\n\n----------------------------------------\n\nTITLE: Adding a Single Node with Attributes in NetworkX Python\nDESCRIPTION: Demonstrates using the `add_node` method to add a single node (node 1) to the graph `G` along with a specific attribute ('room') using keyword arguments. The attributes are stored in the node's attribute dictionary, accessible via `G.node[1]`. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_node(1,room=714)\n```\n\n----------------------------------------\n\nTITLE: Controlling RNG Behavior in NetworkX Functions via seed Parameter (Python)\nDESCRIPTION: Illustrates various ways to use the `seed` parameter within NetworkX functions, exemplified by `random_layout`. It shows how to use the global default RNG (`seed=None`), create a function-specific local RNG with an integer seed (`seed=42`), force the use of the global NumPy RNG (`seed=numpy.random`), or supply a pre-configured NumPy RandomState instance (`seed=random_state`). Depends on `networkx` and `numpy`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/randomness.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from networkx import path_graph, random_layout\n>>> G = path_graph(9)\n>>> pos = random_layout(G, seed=None)  # use (either) global default RNG\n>>> pos = random_layout(G, seed=42)  # local RNG just for this call\n>>> pos = random_layout(G, seed=numpy.random)  # use numpy global RNG\n>>> random_state = numpy.random.RandomState(42)\n>>> pos = random_layout(G, seed=random_state)  # use/reuse your own RNG\n```\n\n----------------------------------------\n\nTITLE: Retrieving Node Neighbors and the Underlying Data Structure - NetworkX - Python\nDESCRIPTION: Shows two approaches for accessing the neighbors of a node in the new NetworkX API: using G[v] to get the neighbor dict which maps to edge data, or using G.neighbors(v) for a list. Requires networkx. Inputs: Graph G, node identifier. Outputs: Neighbor dictionary or neighbor list. Warning: Directly modifying the returned dictionary can corrupt graph data; copy it for safe modification.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> G=nx.path_graph(5)\n>>> # G[0]\n#  {1: 1}\n\n>>> G.neighbors(0)  # doctest: +SKIP\n[1]\n```\n\n----------------------------------------\n\nTITLE: Writing and Reading Graphs in GML Format with NetworkX in Python\nDESCRIPTION: Shows exporting a NetworkX graph to a GML file using write_gml and importing it with read_gml. Requires NetworkX and a graph object (red). File paths are specified as strings. Outputs are persistent graph structure in file and a reloaded graph object, respectively. Useful for interoperability and persistence.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnx.write_gml(red, \"path.to.file\")\\nmygraph = nx.read_gml(\"path.to.file\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Wheel Graph using NetworkX in Python\nDESCRIPTION: Shows the standard syntax for creating a NetworkX wheel graph with 9 spokes (resulting in 10 nodes) using the `nx.wheel_graph` function. This demonstrates the existing API which the NXEP 3 proposal aims to preserve for backward compatibility.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.wheel_graph(9)  # same as current code\n```\n\n----------------------------------------\n\nTITLE: Building and Converting Multi-Attribute Adjacency Matrices - Python\nDESCRIPTION: Creates a NetworkX graph with multi-attribute edges, defines a structured NumPy dtype, generates an adjacency array with both 'weight' and 'cost', and shows access patterns for attributes. Showcases use of to_numpy_array for structured dtypes and view transformation to recarray for field access. Requires NetworkX and NumPy. Inputs are edges with dict attributes; outputs are ndarray/recarray with fields accessible as attributes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> edges = [\n...     (0, 1, {\"weight\": 10, \"cost\": 2}),\n...     (1, 2, {\"weight\": 5, \"cost\": 100})\n... ]\n>>> G = nx.Graph(edges)\n>>> # Create an adjacency matrix with \"weight\" and \"cost\" attributes\n>>> dtype = np.dtype([(\"weight\", float), (\"cost\", int)])\n>>> A = nx.to_numpy_array(G, dtype=dtype, weight=None)\n>>> A\narray([[( 0.,   0), (10.,   2), ( 0.,   0)],\n       [(10.,   2), ( 0.,   0), ( 5., 100)],\n       [( 0.,   0), ( 5., 100), ( 0.,   0)]],\n      dtype=[('weight', '<f8'), ('cost', '<i8')])\n>>> A[\"cost\"]\narray([[  0,   2,   0],\n       [  2,   0, 100],\n       [  0, 100,   0]])\n>>> # The recarray interface can be recovered with ``view``\n>>> A = nx.to_numpy_array(G, dtype=dtype, weight=None).view(np.recarray)\n>>> A\nrec.array([[( 0.,   0), (10.,   2), ( 0.,   0)],\n           [(10.,   2), ( 0.,   0), ( 5., 100)],\n           [( 0.,   0), ( 5., 100), ( 0.,   0)]],\n          dtype=[('weight', '<f8'), ('cost', '<i8')])\n>>> A.weight\narray([[ 0., 10.,  0.],\n       [10.,  0.,  5.],\n       [ 0.,  5.,  0.]])\n```\n\n----------------------------------------\n\nTITLE: Using not_implemented_for Decorator in NetworkX (Python)\nDESCRIPTION: Demonstrates the use of the @nx.not_implemented_for decorator from networkx.utils.decorators to specify unsupported graph types for functions. The decorator restricts the function based on graph properties ('directed', 'multigraph'), ensuring the function is called only with appropriate graphs. The first parameter is expected to be the graph object. No external dependencies besides NetworkX are required. The snippet serves as a template for conditional function support in NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n@nx.not_implemented_for(\"directed\", \"multigraph\")\ndef function_not_for_MultiDiGraph(G, others):\n    # function not for graphs that are directed *and* multigraph\n    pass\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@nx.not_implemented_for(\"directed\")\n@nx.not_implemented_for(\"multigraph\")\ndef function_only_for_Graph(G, others):\n    # function not for directed graphs *or* for multigraphs\n    pass\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Max Flow and Min Cut in NetworkX 1.9 (Python)\nDESCRIPTION: Illustrates the new API introduced in NetworkX 1.9 for flow and cut calculations. It shows how to import the necessary flow algorithms explicitly. It demonstrates calculating the maximum flow value using `nx.maximum_flow_value()` and minimum cut value using `nx.minimum_cut_value()`. It also shows how to compute the maximum flow and obtain the flow dictionary using `nx.maximum_flow()`, specifying different underlying algorithms (`ford_fulkerson`, `preflow_push`, `shortest_augmenting_path`, `edmonds_karp`) via the `flow_func` parameter. Using `nx.maximum_flow()` without `flow_func` defaults to `preflow_push`. This code is marked for skipping in doctests.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.9.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from networkx.algorithms.flow import (ford_fulkerson, preflow_push,\n...        edmonds_karp, shortest_augmenting_path)  # doctest: +SKIP\n>>> flow_value = nx.maximum_flow_value(G, 0, 6)  # doctest: +SKIP\n>>> cut_value = nx.minimum_cut_value(G, 0, 6)  # doctest: +SKIP\n>>> flow_value == cut_value  # doctest: +SKIP\nTrue\n>>> # Legacy: this returns the exact same output than ford_fulkerson in 1.8.1\n>>> flow_value, flow_dict = nx.maximum_flow(G, 0, 6, flow_func=ford_fulkerson)  # doctest: +SKIP\n>>> # We strongly recommend to use the new algorithms:\n>>> flow_value, flow_dict = nx.maximum_flow(G, 0, 6)  # doctest: +SKIP\n>>> # If no flow_func is passed as argument, the default flow_func\n>>> # (preflow-push) is used. Therefore this is the same than:\n>>> flow_value, flow_dict = nx.maximum_flow(G, 0, 6, flow_func=preflow_push)  # doctest: +SKIP\n>>> # You can also use alternative maximum flow algorithms:\n>>> flow_value, flow_dict = nx.maximum_flow(G, 0, 6, flow_func=shortest_augmenting_path)  # doctest: +SKIP\n>>> flow_value, flow_dict = nx.maximum_flow(G, 0, 6, flow_func=edmonds_karp)  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Using add_edge with Attributes in NetworkX Python\nDESCRIPTION: Example showing how the `add_edge` method in NetworkX 1.0 accepts optional keyword arguments (like 'weight') to assign attributes to the edge being added between nodes 1 and 2. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_edge(1, 2, weight=4.7 )\n```\n\n----------------------------------------\n\nTITLE: Slicing EdgeView Produces Informative Error in NetworkX Python\nDESCRIPTION: Illustrates the error message provided when a user attempts to slice a NetworkX EdgeView object directly. The error message suggests converting the view to a list before slicing, guiding users to the correct approach. This snippet clarifies the effect of the implementation discussed in the document, requiring only NetworkX and relying on standard Python exception handling.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0002.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> G.edges()[0:10]\nTraceback (most recent call last)\n   ...\nNetworkXError: EdgeView does not support slicing, try list(G.edges)[0:10:None]\n```\n\n----------------------------------------\n\nTITLE: Registering NetworkX Backend Info Entry Point - TOML\nDESCRIPTION: Demonstrates how to provide additional backend metadata for NetworkX by defining an entry-point for 'networkx.backend_info' in the package's 'pyproject.toml'. Here, 'backend_name' is mapped to the 'get_info' function, which must return a dictionary of backend information. This is intended for use in package publishing and documentation enhancement, with no runtime dependencies except the corresponding Python module and function.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_10\n\nLANGUAGE: toml\nCODE:\n```\n[project.entry-points.\"networkx.backend_info\"]\\nbackend_name = \"your_get_info_function\"\n```\n\n----------------------------------------\n\nTITLE: Importing NetworkX with Alias 'NX' (Python)\nDESCRIPTION: Illustrates importing the NetworkX library and aliasing it as 'NX' for potentially more concise code or maintaining compatibility with older examples. This convention was suggested alongside the package rename in version 0.23.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as NX\n```\n\n----------------------------------------\n\nTITLE: Passing numpy.random.Generator Instance to Decorated Function (Python)\nDESCRIPTION: This snippet shows that even with the current decorator implementation, users can utilize the newer `numpy.random.Generator` API by explicitly creating a `Generator` instance (using `np.random.default_rng()`) and passing it directly as the `seed` argument.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> rng = np.random.default_rng()\n>>> type(foo(rng))\nnumpy.random._generator.Generator\n```\n\n----------------------------------------\n\nTITLE: Documenting NodeNotFound Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NodeNotFound` exception class, raised when an operation references a node that does not exist in the graph. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NodeNotFound\n```\n\n----------------------------------------\n\nTITLE: Recommended Usage of Spanning Tree Functions in NetworkX 2.0 (Python)\nDESCRIPTION: This snippet shows the recommended way to import and use the spanning tree functions in NetworkX 2.0. It involves importing the specific `tree` submodule from `networkx.algorithms` and then calling the functions (e.g., `tree.minimum_spanning_tree`) with explicit keyword arguments for `algorithm` and `weight`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from networkx.algorithms import tree\n# recommended\n>>> tree.minimum_spanning_tree(G, algorithm='kruskal', weight='mass')\n>>> tree.minimum_spanning_edges(G, algorithm='prim', weight='mass')\n```\n\n----------------------------------------\n\nTITLE: Managing Node Attributes in NetworkX Python\nDESCRIPTION: Illustrates adding nodes with attributes using `add_node` (with keyword args) and `add_nodes_from` (with keyword args applying to all listed nodes). Shows accessing a specific node's attribute dictionary via `G.node[node_id]`, adding new attributes directly to this dictionary (e.g., `G.node[1]['room'] = 714`), and viewing all nodes along with their attribute dictionaries using `G.nodes(data=True)`. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_node(1, time='5pm')\n>>> G.add_nodes_from([3], time='2pm')\n>>> G.node[1]  # doctest: +SKIP\n{'time': '5pm'}\n>>> G.node[1]['room'] = 714  # doctest: +SKIP\n>>> G.nodes(data=True)  # doctest: +SKIP\n[(1, {'room': 714, 'time': '5pm'}), (3, {'time': '2pm'})]\n```\n\n----------------------------------------\n\nTITLE: Setting Backend Priority with Environment Variable in Bash - Bash Script\nDESCRIPTION: Demonstrates how to direct NetworkX to use the 'cugraph' backend for all supported algorithm functions by setting the NETWORKX_BACKEND_PRIORITY environment variable. This setup enables seamless fallback to standard NetworkX implementations for functions not implemented by the backend, while continuing to use NetworkX graphs for graph generators. To use, set the variable before running your Python script (e.g., my_networkx_script.py). The primary input is the environment variable, and the output is determined by your script's execution using the desired backend.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash> NETWORKX_BACKEND_PRIORITY=cugraph python my_networkx_script.py\n```\n\n----------------------------------------\n\nTITLE: Safely Accessing Edge Weight with Default in NetworkX Python\nDESCRIPTION: Illustrates a safe method for retrieving an edge attribute ('weight') using the dictionary `.get()` method on the edge's attribute dictionary (`G[u][v]`). This approach provides a default value (1 in this case) if the edge exists but the 'weight' attribute key is not present, thus preventing potential `KeyError` exceptions. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> w= G[1][2].get('weight',1)  # set w to 1 if there is no 'weight' key\n```\n\n----------------------------------------\n\nTITLE: Viewing Backend Information in Function Docstrings - Python Console\nDESCRIPTION: Illustrates the use of the built-in 'help' function to display backend support and notes in the docstring of a NetworkX function. The snippet indicates the presence of backend information, especially for parallel implementations. No further dependencies aside from having NetworkX and the desired backend installed. Output is a detailed help text including backend details. The docstring may include code explanations and summaries for each backend.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> help(nx.betweenness_centrality)  # doctest: +SKIP\\n...\\nBackends\\n--------\\nparallel : Parallel backend for NetworkX algorithms\\n  The parallel computation is implemented by dividing the nodes into chunks\\n  and computing betweenness centrality for each chunk concurrently.\\n...\n```\n\n----------------------------------------\n\nTITLE: Topological Sorting Without nbunch or Reverse Parameter - NetworkX - Python\nDESCRIPTION: Shows updated use of nx.topological_sort, replacing the deprecated nbunch and reverse arguments. Utilizes subgraph construction or Python reversed() to achieve the desired behavior. Dependencies: networkx, graph G, node input nbunch. Inputs: Graph, node. Outputs: topological sort iterator and reversed list.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnx.topological_sort(G.subgraph(nx.descendants(G, nbunch)))\n```\n\nLANGUAGE: python\nCODE:\n```\nreversed(list(nx.topological_sort(G)))\n```\n\n----------------------------------------\n\nTITLE: Updating Minimum Spanning Tree Calls in NetworkX 2.0 (Python)\nDESCRIPTION: These snippets contrast the old and new ways of specifying the weight attribute for spanning tree functions like `minimum_spanning_tree`. Due to the introduction of the `algorithm` parameter, the optional `weight` parameter must now be specified explicitly by name (e.g., `weight='mass'`) instead of positionally.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> nx.minimum_spanning_tree(G, 'mass')  # old\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> nx.minimum_spanning_tree(G, weight='mass') # new\n```\n\n----------------------------------------\n\nTITLE: Generating a Function Summary Table with Sphinx using reStructuredText\nDESCRIPTION: This reStructuredText directive (`autosummary`) tells Sphinx to create a summary table for the subsequently listed items (typically functions or classes). The `:toctree: generated/` option instructs Sphinx to generate individual documentation pages for each item listed below this directive and place them in the 'generated/' subdirectory relative to the current file.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/dominance.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n```\n\n----------------------------------------\n\nTITLE: Generating Summary Table for NetworkX Clustering Functions via Sphinx Autosummary\nDESCRIPTION: This reStructuredText directive (`autosummary`) instructs Sphinx to generate a concise summary table for the listed Python functions within the `networkx.algorithms.cluster` module. The `:toctree: generated/` option tells Sphinx to create individual stub pages for each function's detailed documentation within the 'generated/' subdirectory. Functions listed include `triangles`, `transitivity`, `clustering`, `average_clustering`, `square_clustering`, and `generalized_degree`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/clustering.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   triangles\n   transitivity\n   clustering\n   average_clustering\n   square_clustering\n   generalized_degree\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Backend Toggling for Random State - Python\nDESCRIPTION: This snippet, using Python's interactive mode, shows example usages of creating random state instances via the NetworkX utility, illustrating the effect of toggling between the legacy RandomState backend and the newer Generator backend via a package-level attribute. It highlights how setting nx._random_backend affects the type of random object returned by create_random_state. Requirements: NetworkX, NumPy.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx as nx\n>>> from networkx.utils.misc import create_random_state\n\n# NetworkX 2.X behavior: RandomState by default\n\n>>> type(create_random_state(12345))\nnumpy.random.mtrand.RandomState\n\n# Change random backend by setting pkg attr\n\n>>> nx._random_backend = \"Generator\"\n\n>>> type(create_random_state(12345))\nnumpy.random._generator.Generator\n```\n\n----------------------------------------\n\nTITLE: Generating Gomory-Hu Tree Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Gomory-Hu tree function (`gomory_hu_tree`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   gomory_hu_tree\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX in User Directory via pip - Bash/Shell\nDESCRIPTION: This command installs NetworkX for the current user only using the --user flag with pip, which is useful when system-wide installation is not possible due to permissions. It installs the package with its default dependencies to the user Python environment.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install --user networkx[default]\n```\n\n----------------------------------------\n\nTITLE: Inspecting and Listing Edge Views - NetworkX - Python\nDESCRIPTION: Demonstrates retrieval and listing of graph edges using EdgeView in NetworkX 2.0. Supports set-like operations. Dependencies: networkx, graph G. Outputs EdgeView and a list of edge tuples.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> G.edges  # for backward compatibility G.nodes() works as well\nEdgeView([(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)])\n>>> list(G.edges)\n[(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Nodes with Attributes using nodes(data=True) in NetworkX Python\nDESCRIPTION: Illustrates initializing a graph and then using the `nodes` method with the `data=True` argument. This returns a list of (node, attribute_dict) tuples, showing each node along with its associated attribute dictionary. Even if no attributes were explicitly added, an empty dictionary `{}` is associated with each node. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph([(1,2),(3,4)])\n>>> G.nodes(data=True)  # doctest: +SKIP\n[(1, {}), (2, {}), (3, {}), (4, {})]\n```\n\n----------------------------------------\n\nTITLE: Function for Reverse Graph View in NetworkX (Python)\nDESCRIPTION: The `reverse_view()` function in NetworkX 2.3 provides a read-only reverse view of a directed graph, where edges are reversed compared to the original graph. This function replaces the removed `ReverseView` class.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.3.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nreverse_view()\n```\n\n----------------------------------------\n\nTITLE: Recommended Graph Copy Method in NetworkX (Python)\nDESCRIPTION: The `G.__class__()` syntax is the recommended method in NetworkX 2.3 and later to create a new, empty graph instance of the same type as an existing graph `G`. This replaces the deprecated `G.fresh_copy()` method.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.3.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nG.__class__()\n```\n\n----------------------------------------\n\nTITLE: Importing Module Documentation with automodule (rst)\nDESCRIPTION: Instructs the Sphinx documentation generator to automatically pull documentation from the specified Python module, `networkx.algorithms.flow`. This serves as the entry point for documenting the entire flow algorithms module.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.flow\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodocumentation for NetworkX D-Separation\nDESCRIPTION: This snippet uses Sphinx reStructuredText directives to automatically generate documentation. The `automodule` directive targets the `networkx.algorithms.d_separation` Python module, instructing Sphinx to pull documentation from it. The `autosummary` directive, with the `toctree` option, creates a table of contents linking to generated pages for the listed functions: `is_d_separator`, `is_minimal_d_separator`, and `find_minimal_d_separator`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/d_separation.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.d_separation\n.. autosummary::\n   :toctree: generated/\n\n   is_d_separator\n   is_minimal_d_separator\n   find_minimal_d_separator\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation for NetworkX Graph Product Operators (reStructuredText)\nDESCRIPTION: Uses Sphinx `automodule` and `autosummary` directives to generate documentation for various graph product operations (`cartesian_product`, `lexicographic_product`, `rooted_product`, `strong_product`, `tensor_product`, `power`, `corona_product`, `modular_product`) available in the `networkx.algorithms.operators.product` Python module. The `:toctree: generated/` option directs Sphinx to create individual documentation pages for these functions within the 'generated' subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/operators.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.operators.product\n.. autosummary::\n   :toctree: generated/\n\n   cartesian_product\n   lexicographic_product\n   rooted_product\n   strong_product\n   tensor_product\n   power\n   corona_product\n   modular_product\n```\n\n----------------------------------------\n\nTITLE: Generating Component Subgraphs using List Comprehension in Python\nDESCRIPTION: Demonstrates the recommended method in NetworkX 2.1+ for generating subgraphs corresponding to various graph components (e.g., connected, biconnected, strongly/weakly connected). This approach uses a list comprehension iterating over the node sets yielded by component functions (like `connected_components`, `biconnected_components`, etc., represented by `*_components` placeholder) and calling `G.subgraph(c)` for each component `c`. This replaces deprecated functions like `connected_component_subgraphs`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.1.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n[G.subgraph(c) for c in *_components]\n```\n\n----------------------------------------\n\nTITLE: Automatic Dispatch to Backend for Algorithms and Generators Using Shell Environment - Bash Script\nDESCRIPTION: Shows how to simultaneously configure automatic use of a backend (here 'cugraph') for all algorithms and generators in NetworkX with environment variables, and to enable fallback to NetworkX for any missing implementations. The configuration variables NETWORKX_BACKEND_PRIORITY_ALGOS and NETWORKX_BACKEND_PRIORITY_GENERATORS select the backend for each function group, while NETWORKX_FALLBACK_TO_NX allows the system to revert to NetworkX if the function is unavailable in the backend. This should be set before running the target script.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbash> NETWORKX_BACKEND_PRIORITY_ALGOS=cugraph \\\n      NETWORKX_BACKEND_PRIORITY_GENERATORS=cugraph \\\n      NETWORKX_FALLBACK_TO_NX=True \\\n      python my_networkx_script.py\n```\n\n----------------------------------------\n\nTITLE: Directed Graph View Operations - NetworkX - Python\nDESCRIPTION: Illustrates retrieval and manipulation of various views in a directed graph, including nodes, edges, in-edges, out-edges, and traversal of successors and predecessors. Dependencies: networkx. Input: DiGraph D. Output: Various view types, lists, and degree lookups.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> D = nx.DiGraph()\n>>> D.add_edges_from([(1, 2), (2, 3), (1, 3), (2, 4)])\n>>> D.nodes\nNodeView((1, 2, 3, 4))\n>>> list(D.nodes)\n[1, 2, 3, 4]\n>>> D.edges\nOutEdgeView([(1, 2), (1, 3), (2, 3), (2, 4)])\n>>> list(D.edges)\n[(1, 2), (1, 3), (2, 3), (2, 4)]\n>>> D.in_degree[2]\n1\n>>> D.out_degree[2]\n2\n>>> D.in_edges\nInEdgeView([(1, 2), (2, 3), (1, 3), (2, 4)])\n>>> list(D.in_edges())\n[(1, 2), (2, 3), (1, 3), (2, 4)]\n>>> D.out_edges(2)\nOutEdgeDataView([(2, 3), (2, 4)])\n>>> list(D.out_edges(2))\n[(2, 3), (2, 4)]\n>>> D.in_degree\nInDegreeView({1: 0, 2: 1, 3: 2, 4: 1})\n>>> list(D.in_degree)\n[(1, 0), (2, 1), (3, 2), (4, 1)]\n>>> D.successors(2)\n<dict_keyiterator object at ...>\n>>> list(D.successors(2))\n[3, 4]\n>>> D.predecessors(2)\n<dict_keyiterator object at ...>\n>>> list(D.predecessors(2))\n[1]\n```\n\n----------------------------------------\n\nTITLE: Using np_random_state Decorator in NetworkX (Python)\nDESCRIPTION: This snippet demonstrates the basic usage of the `@np_random_state` decorator in NetworkX. The decorator is applied to a function `foo` and configured to manage the `seed` argument, automatically converting various inputs (like integers or `None`) into a NumPy random number generator instance within the function.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom networkx.utils import np_random_state\n\n@np_random_state(\"seed\")  # Or could be the arg position, i.e. 0\ndef foo(seed=None):\n    return seed\n```\n\n----------------------------------------\n\nTITLE: Checking Eulerian Path Presence with Undirected Graphs - NetworkX - Python\nDESCRIPTION: Shows how to create an undirected graph in NetworkX, add an isolated node, and determine if an Eulerian path exists. The code depends on having the NetworkX package installed and uses a Graph object with a set of edges and an additional node. It returns a boolean result for the existence of an Eulerian path, highlighting consistent handling of isolated nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.8.1.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> G = nx.Graph([(0, 1), (1, 2), (2, 0)])\\n>>> G.add_node(3)\\n>>> nx.has_eulerian_path(G)\n```\n\n----------------------------------------\n\nTITLE: Documenting Maximal Independent Set Algorithm with Sphinx (reStructuredText)\nDESCRIPTION: This snippet employs Sphinx's automodule and autosummary directives in reStructuredText to auto-generate documentation for the maximal independent set algorithm from the networkx.algorithms.mis Python module. It references the module and the \"maximal_independent_set\" public API for inclusion in the generated documentation. No programming code is present; instead, it acts as the scaffolding for docs generation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/mis.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n***********************\\nMaximal independent set\\n***********************\\n\\n.. automodule:: networkx.algorithms.mis\\n.. autosummary::\\n   :toctree: generated/\\n\\n   maximal_independent_set\\n\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkX Hierarchy Module with Sphinx (reStructuredText)\nDESCRIPTION: This snippet uses Sphinx's automodule and autosummary directives in reStructuredText to generate API documentation for the networkx.algorithms.hierarchy module and its flow_hierarchy function. Dependencies include having Sphinx set up in the documentation build system, and the NetworkX package available for introspection. The :toctree: option controls where summaries are placed; the snippet is intended to be included in a larger Sphinx docs tree, and does not directly take inputs or produce outputs except for generated HTML/API docs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/hierarchy.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n*********\nHierarchy\n*********\n\n.. automodule:: networkx.algorithms.hierarchy\n.. autosummary::\n   :toctree: generated/\n\n   flow_hierarchy\n```\n\n----------------------------------------\n\nTITLE: Building HTML Documentation with Sphinx Makefile (Makefile)\nDESCRIPTION: Generates the HTML version of the NetworkX documentation by invoking 'make html' from within the 'doc/' directory. This command uses the Sphinx Makefile alongside all required dependencies, producing the built website within the 'build/html' subdirectory as output. No parameters are necessary if setup is correct; any failures typically relate to missing dependencies or misconfiguration in Sphinx or the Makefile itself.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/README.rst#_snippet_2\n\nLANGUAGE: makefile\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Set Operations on NodeView Objects - NetworkX - Python\nDESCRIPTION: Illustrates set intersection and union of nodes between two NetworkX graphs using NodeView objects. Dependencies: networkx, graphs G and H. Input: Existing graphs. Output: Set of common or combined nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> H = nx.Graph()\n>>> H.add_nodes_from([1, 'networkx', '2.0'])\n>>> G.nodes & H.nodes  # finding common nodes in 2 graphs\n{1}\n>>> # union of nodes in 2 graphs\n>>> G.nodes | H.nodes  # doctest: +SKIP\n{0, 1, 2, 3, 4, 'networkx', '2.0'}\n```\n\n----------------------------------------\n\nTITLE: Creating Deep Copy Subgraphs (Deprecated Method) in NetworkX Python\nDESCRIPTION: Shows the syntax (commented out) for creating a deep copy subgraph using `G.subgraph(nodes, copy=True)`. The comment highlights that the `copy=True` keyword argument, which ensured a deep copy including attributes, is deprecated in NetworkX versions greater than 1.0. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph()\n>>> # note: copy keyword deprecated in networkx>1.0\n>>> # H = G.subgraph([],copy=True)  # deep copy of all data\n```\n\n----------------------------------------\n\nTITLE: Converting to Directed Graph (Shallow/Deep Copy) in NetworkX Python\nDESCRIPTION: Illustrates converting an undirected graph `G` to a directed graph `D`. Using the class initializer `nx.DiGraph(G)` creates a new directed graph sharing data (a shallow copy). Using the `G.to_directed()` method creates a new directed graph with independent copies of all data and attributes (a deep copy). Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph()\n>>> D_shallow = nx.DiGraph(G) # shallow copy\n>>> D_deep = G.to_directed() # deep copy\n```\n\n----------------------------------------\n\nTITLE: In-degree Operations on Directed Graphs - NetworkX - Python\nDESCRIPTION: Shows methods for examining in-degree statistics in a DiGraph, with different ways to collect degree values, including view lookup, iteration, and adjacency lookups. Dependencies: networkx. Inputs: Directed graph DG with weighted edges. Outputs: Degree values by node.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> DG = nx.DiGraph()\n>>> DG.add_weighted_edges_from([(1, 2, 0.5), (3, 1, 0.75)])\n>>> deg = DG.in_degree   # sets up the view\n>>> [d for n, d in deg]   # gets all nodes' degree values\n[1, 1, 0]\n>>> (d for n, d in deg)    # iterator over degree values\n<generator object <genexpr> ...>\n>>> [deg[n] for n in [1, 3]]   # using lookup for only some nodes\n[1, 0]\n\n>>> for node, in_deg in dict(DG.in_degree).items():  # works for nx1 and nx2\n...     print(node, in_deg)\n1 1\n2 1\n3 0\n>>> dict(DG.in_degree([1, 3])).values()    # works for nx1 and nx2\ndict_values([1, 0])\n>>> # DG.in_degree(nlist) creates a restricted view for only nodes in nlist.\n>>> # but see the fourth option above for using lookup instead.\n>>> list(d for n, d in DG.in_degree([1, 3]))\n[1, 0]\n\n>>> [len(nbrs) for n, nbrs in DG.pred.items()]  # probably slightly fastest for all nodes\n[1, 1, 0]\n>>> [len(DG.pred[n]) for n in [1, 3]]           # probably slightly faster for only some nodes\n[1, 0]\n```\n\n----------------------------------------\n\nTITLE: Upgrading NetworkX via pip - Bash/Shell\nDESCRIPTION: This snippet upgrades an existing NetworkX installation to the latest release using pip. The --upgrade flag ensures the most recent compatible version is installed. The command requires pip and suitable system permissions, and works in any environment where pip is available.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install --upgrade networkx[default]\n```\n\n----------------------------------------\n\nTITLE: Accessing nx_agraph Functions via Namespace in NetworkX 1.11 (Python)\nDESCRIPTION: Demonstrates the updated method in NetworkX 1.11 for accessing functions within the `nx_agraph` module, such as `write_dot`. Instead of being available at the top-level `nx` namespace, functions must now be accessed via the nested module path `nx.nx_agraph`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.11.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnx.nx_agraph.write_dot\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Requirements in requirements.txt Format\nDESCRIPTION: Specifies the required third-party Python packages and their minimum versions for the NetworkX project. This file is auto-generated and intended to be used by tools such as pip to install necessary dependencies. It includes metadata comments warning not to edit this file directly, as changes should be made in 'pyproject.toml' and propagated from there. The expected input is a series of package specifications in the format 'package>=version', with no support for complex expressions or extras. Limitations: manual modifications may be overwritten by the generation process.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/extra.txt#_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\n# Do not edit this file; modify pyproject.toml instead.\nlxml>=4.6\npygraphviz>=1.14\npydot>=3.0.1\nsympy>=1.10\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Requirements using Requirements Format\nDESCRIPTION: Specifies the minimum required versions of major scientific Python libraries (numpy, scipy, matplotlib, pandas) for the project. This ensures compatibility with code throughout the project and facilitates installation via pip or other tools. The file is generated automatically and should not be edited directly; instead, dependencies are managed via pyproject.toml and generation scripts.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/default.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\\n# Do not edit this file; modify pyproject.toml instead.\\nnumpy>=1.25\\nscipy>=1.11.2\\nmatplotlib>=3.8\\npandas>=2.0\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Distance Function for geographical_threshold_graph in Python\nDESCRIPTION: Illustrates how to define a custom distance function for the `geographical_threshold_graph` in NetworkX 2.1. The `alpha` parameter was deprecated and replaced by `p_dist`. This custom function `custom_dist` replicates the behavior of `alpha=2` from previous versions by calculating `r**-2`. It should be passed to the `geographical_threshold_graph` function via the `p_dist` parameter (e.g., `p_dist=custom_dist`).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.1.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef custom_dist(r): r**-2\n```\n\n----------------------------------------\n\nTITLE: Illustrating Old Node Access Methods in NetworkX 1.x (Python)\nDESCRIPTION: This snippet demonstrates the behavior of `G.nodes()` and `G.nodes_iter()` in NetworkX versions prior to 2.0. `G.nodes()` returned a list of nodes, while `G.nodes_iter()` returned an iterator. This is contrasted with the new view-based approach in NetworkX 2.0.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.complete_graph(5)\n>>> G.nodes()  # doctest: +SKIP\n[0, 1, 2, 3, 4]\n>>> G.nodes_iter()  # doctest: +SKIP\n<dictionary-keyiterator at ...>\n```\n\n----------------------------------------\n\nTITLE: Using an Instance of Backend Graph in NetworkX Algorithm - Python\nDESCRIPTION: Shows how to create a graph instance using a backend graph class (here, ParallelGraph from nx_parallel) and pass it directly to a NetworkX function. If the input graph's backend matches, no conversion occurs, and the backend's implementation is invoked. Dependencies are NetworkX and the 'nx_parallel' package. Input is a NetworkX or existing compatible graph G; output is the result of the backend's betweenness centrality computation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nH = nx_parallel.ParallelGraph(G)\nnx.betweenness_centrality(H, k=10)\n```\n\n----------------------------------------\n\nTITLE: Querying Available Backends for a Function - Python Console\nDESCRIPTION: Shows how to introspect which backends are currently installed and implement a specific NetworkX function by accessing the '.backends' attribute. Assumes 'nx' namespace and relevant functions are already imported and available. No dependencies except for NetworkX installed. Output is a set of backend names. The 'doctest: +SKIP' comment is included to prevent execution during doctests.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> nx.betweenness_centrality.backends  # doctest: +SKIP\\n{'parallel'}\n```\n\n----------------------------------------\n\nTITLE: Changing Edge Attribute Assignment in NetworkX 2.0 (Python)\nDESCRIPTION: These snippets illustrate the API change for adding edges with attributes in NetworkX 2.0. The old method using an `attr_dict` parameter (`G.add_edge(1, 2, {'color': 'red'})`) is deprecated. The new method uses keyword arguments (`G.add_edge(1, 2, color='red')`) for string attributes. For non-string attributes, manual update via `G.edges[u, v].update()` is required.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nG.add_edge(1, 2, {'color': 'red'})\n```\n\nLANGUAGE: python\nCODE:\n```\nG.add_edge(1, 2, color='red')\n```\n\nLANGUAGE: python\nCODE:\n```\nG.edges[1, 2].update({0: \"zero\"})\n```\n\n----------------------------------------\n\nTITLE: Implementing the Proposed `@node_and_edge_builder` Decorator in Python\nDESCRIPTION: Provides the Python implementation for the proposed `@node_and_edge_builder` decorator. It takes a function `f` (which yields graph sequence elements) and returns a new function `graph`. This `graph` function accepts `*args`, `**kwargs`, and an optional `create_using` parameter. It initializes an empty graph `G` (using `create_using` or the default `nx.Graph`), populates it by calling `G.update()` with the elements yielded by `f(*args, **kwargs)`, and returns `G`. It also attaches the original generator `f` as attributes `.edges` and `.edges_plus` to the returned `graph` function. Requires `functools.wraps` and NetworkX (`nx`).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef node_and_edge_builder(f):\n    @wraps(f)\n    def graph(*args, create_using=None, **kwargs):\n        G = nx.empty_graph(0, create_using=create_using)\n        G.update(f(*args, **kwargs))\n        return G\n\n    graph.edges = f\n    graph.edges_plus = f\n    return graph\n```\n\n----------------------------------------\n\nTITLE: Importing Matplotlib Pyplot for NetworkX Drawing in Python\nDESCRIPTION: Imports the `matplotlib.pyplot` module, commonly aliased as `plt`. This is a prerequisite for using NetworkX's drawing functions that rely on Matplotlib for creating visualizations.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Using NumPy Random Generator in NetworkX Layouts - Python\nDESCRIPTION: Demonstrates passing a numpy.random.Generator instance as the seed parameter to NetworkX's spring_layout function to control randomization reproducibly in graph layouts. Requires NetworkX and NumPy 1.17 or newer. Inputs include a generated graph and a specific RNG; output is a layout (positions) dictionary. This approach leverages improvements in the new Generator API, but does not guarantee reproducibility across all numpy versions.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.barbell_graph(6, 2)\n>>> pos = nx.spring_layout(G, seed=np.random.default_rng(123456789))\n```\n\n----------------------------------------\n\nTITLE: Committing Version Bump Post Release - Git\nDESCRIPTION: This command sequence stages, commits, and pushes the updated project version after documentation deployment and other post-release steps. Run these after editing networkx/__init__.py to ensure the new version is reflected in the codebase.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_7\n\nLANGUAGE: git\nCODE:\n```\ngit add networkx/__init__.py\\ngit commit -m \\\"Bump release version\\\"\\ngit push origin main\n```\n\n----------------------------------------\n\nTITLE: Modern NumPy Generator for Non-Exact Layout Reproducibility - Python\nDESCRIPTION: Illustrates usage of numpy.random.default_rng to generate a modern Generator for graph layout randomization when exact reproducibility is less critical. Updated use of Generator improves performance and statistical properties. Inputs: graph G and Generator; output: node-coordinate mapping. Requires NumPy 1.17+, NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>>> rng = np.random.default_rng(12345)\n>>> pos = nx.spring_layout(G, seed=rng)\n```\n\n----------------------------------------\n\nTITLE: Pushing Tags and Commits to GitHub - Git\nDESCRIPTION: This command pushes commits and tags to the remote repository named 'origin' on the 'main' branch. This step ensures that all changes and version tags are available on GitHub for collaborative access and further deployment.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_5\n\nLANGUAGE: git\nCODE:\n```\ngit push --tags origin main\n```\n\n----------------------------------------\n\nTITLE: Initializing a NetworkX Graph with Attributes in Python\nDESCRIPTION: Example of creating a NetworkX Graph instance (`nx.Graph`) and simultaneously assigning graph-level attributes ('year', 'city') using keyword arguments during initialization. These attributes are stored in the `G.graph` dictionary. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph(year='2009',city='New York')\n```\n\n----------------------------------------\n\nTITLE: Formatting NXEP Author Header with Email\nDESCRIPTION: Provides an example of the required format for the Author header in an NXEP when including the author's email address. The format is 'Real Name <email@address>'. Multiple authors should each be on a separate line.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0000.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nRandom J. User <address@dom.ain>\n```\n\n----------------------------------------\n\nTITLE: Using Graphviz for Layout and Exporting to DOT Format in NetworkX using Python\nDESCRIPTION: Illustrates integration with Graphviz for advanced layout and export. It imports `write_dot` from `networkx.drawing.nx_pydot`. Node positions (`pos`) are calculated using Graphviz via `nx.nx_agraph.graphviz_layout(G)`. The graph `G` is then drawn using Matplotlib with these calculated positions (`nx.draw(G, pos=pos)`). Finally, the graph structure is exported to a file named 'file.dot' in the DOT language using `write_dot(G, 'file.dot')`. Requires NetworkX, Matplotlib, Graphviz, and either PyGraphviz (`nx_agraph`) or pydot (`nx_pydot`) to be installed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_29\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from networkx.drawing.nx_pydot import write_dot\n>>> pos = nx.nx_agraph.graphviz_layout(G)\n>>> nx.draw(G, pos=pos)\n>>> write_dot(G, 'file.dot')\n```\n\n----------------------------------------\n\nTITLE: Testing the Installed NetworkX Package with pytest --pyargs - Bash/Shell\nDESCRIPTION: This snippet tests the currently installed version of NetworkX using pytest's --pyargs argument to locate the package regardless of Python path. Useful for verifying successful installations and identifying integration issues. Requires the pytest package and a properly installed NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\npytest --pyargs networkx\n```\n\n----------------------------------------\n\nTITLE: Using add_edges_from with Attributes in NetworkX Python\nDESCRIPTION: Demonstrates two ways `add_edges_from` handles attributes in NetworkX 1.0: applying a common attribute ('color') to multiple edges listed in the iterable `[(3,4),(4,5)]` via keyword arguments, and adding edges specified as 3-tuples `(u, v, attribute_dict)` allowing each edge to have unique attributes (e.g., `(1,2,{'color':'blue'})`). Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_edges_from([(3,4),(4,5)], color='red')\n>>> G.add_edges_from([(1,2,{'color':'blue'}), (2,3,{'weight':8})])\n```\n\n----------------------------------------\n\nTITLE: Iterating over Edges of a Binomial Graph using Proposed NetworkX Generator in Python\nDESCRIPTION: Demonstrates the proposed syntax for iterating directly over the edges generated by a binomial graph builder without constructing the full graph object first. It accesses the edge generator via `.edges` (as proposed later for `@node_and_edge_builder`) on the builder function `nx.binomial_graph`. Assumes a `process` function exists to handle the edge tuples `(u, v)`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> for u, v in nx.binomial_graph.edges(9):\n>>>     process(u, v)\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX almost_equal Utility\nDESCRIPTION: The NetworkX utility function 'almost_equal', used for comparing floating-point numbers for approximate equality (common in testing), is deprecated. Users should use 'math.isclose' or NumPy's testing utilities instead.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nalmost_equal\n```\n\n----------------------------------------\n\nTITLE: Enumerating Neighbors in Directed Graphs with NetworkX in Python\nDESCRIPTION: Shows how retrieving neighbors for a node in a DiGraph returns its successors, supporting consistency across directed and undirected graph APIs. Input is the node id, returns a list of adjacent nodes. Useful for generic algorithms that operate on either graph type without special handling.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlist(DG.neighbors(1))\n```\n\n----------------------------------------\n\nTITLE: Processing Graph Sequences to Build NetworkX Graphs in Python\nDESCRIPTION: This Python code snippet demonstrates how to process a 'Graph Sequence', a proposed list-of-tuples format for representing graph components. It iterates through the sequence, determines the type of element (graph attribute, node with/without attribute, edge with/without attribute, multiedge) based on tuple length and the hashability of the last element, and adds it to an existing NetworkX graph `G`. It requires a `hashable` function (likely checking `isinstance(x, collections.abc.Hashable)`) and may raise `NetworkXInvalidEdgelist` for malformed sequence elements.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfor S in graphsequence:\n    N = len(S)\n    last_entry = S[-1]\n    attrs = not hashable(last_entry)\n    if N == 1:\n        if attrs:\n            G.graph.update(last_entry)  # graph attributes\n        else:\n            G.add_node(last_entry)  # node without attributes\n    elif N == 2:\n        if attrs:\n            G.add_node(S[0], **last_entry)  # (node, attrdict)\n        else:\n            G.add_edge(*S)  # (u, v)\n    elif N == 3:\n        if attrs:\n            G.add_edge(*S[:2], **last_entry)  # (u, v, attrdict)\n        else:\n            G.add_edge(*S)  # (u, v, edge_key)\n    elif N == 4:\n        if attrs:\n            G.add_edge(*S)  # (u, v, edge_key, attrdict)\n        else:\n            raise NetworkXInvalidEdgelist(\n                \"Sequence element has 4 items and last is not hashable: {S}\"\n            )\n    else:\n        raise NetworkXInvalidEdgelist(\n            \"Graph Sequence element has more than 4 items: {S}\"\n        )\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Iterable Utility\nDESCRIPTION: The NetworkX utility function 'iterable' is deprecated. This function was likely used to check if an object supports iteration, a check often better performed with 'isinstance' and 'collections.abc.Iterable'.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\niterable\n```\n\n----------------------------------------\n\nTITLE: Testing the NetworkX Source Package with pytest - Bash/Shell\nDESCRIPTION: This command runs all tests in the unpacked NetworkX source directory using pytest, validating correctness before or after installation. Requires pytest to be installed. The test suite should be run in the source directory for full coverage.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npytest networkx\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Run Function\nDESCRIPTION: The NetworkX function named 'run' is deprecated. Its specific purpose is unclear from the context but might have related to executing algorithms, tests, or other processes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nrun\n```\n\n----------------------------------------\n\nTITLE: Using NumPy RandomState for Exact Layout Reproducibility - Python\nDESCRIPTION: Shows initializing a numpy.random.RandomState and using it as the seed with NetworkX's spring_layout for exactly reproducible layouts. Requires NetworkX and NumPy. Inputs are graph G and RNG; output is a coordinate mapping. Ensures identical output across versions, though RandomState is considered legacy compared to Generator.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> rng = np.random.RandomState(12345)\n>>> pos = nx.spring_layout(G, seed=rng)\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX simrank_similarity_numpy Function\nDESCRIPTION: The NetworkX function 'simrank_similarity_numpy', a specific NumPy-based implementation for calculating SimRank node similarity, is deprecated. Users should use the main 'networkx.simrank_similarity' function.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nsimrank_similarity_numpy\n```\n\n----------------------------------------\n\nTITLE: Checking for an Edge using Unpacking - NetworkX - Python\nDESCRIPTION: Shows the updated pattern for checking the existence of an edge by unpacking node pairs instead of passing edge tuples, using the * operator. Requires networkx and a created graph. Input is an edge tuple or node names; output is a boolean indicating edge existence. This replaces the deprecated behavior where edge tuples were accepted directly.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> # G.has_edge((u,v))  # or has_edge(e)\n\n>>> G.has_edge(*e) # or has_edge(*(u,v))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Nodes with Common Attributes in NetworkX Python\nDESCRIPTION: Illustrates adding multiple nodes (1 and 2) simultaneously using `add_nodes_from`. A common attribute ('time') is applied to all nodes added in this call via keyword arguments. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_nodes_from([1,2],time='2pm')  # all nodes have same attribute\n```\n\n----------------------------------------\n\nTITLE: Exporting NetworkX Graph to GraphML - Python\nDESCRIPTION: Demonstrates how to export a NetworkX graph object to a GraphML file using the write_graphml function. This allows interoperability with external visualization tools (such as Cytoscape) that support the GraphML format. Requires NetworkX installed; expects G as a graph object and path as the output file path. The resulting file can be imported into compatible visualization software.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/drawing.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nnetworkx.write_graphml(G, path)\n```\n\n----------------------------------------\n\nTITLE: Adding a Path with Edge Attributes in NetworkX Python\nDESCRIPTION: Demonstrates using the `add_path` helper function to add a sequence of nodes `[0, 1, 2, 3]` as a path to the graph `G`. It also shows how to apply a common attribute ('width') to all the newly created edges along this path using keyword arguments. Requires the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.0.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.Graph()\n>>> G.add_path([0, 1, 2, 3], width=3.2)  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Checking Proposed RNG Type with None Seed (Python)\nDESCRIPTION: This example illustrates the proposed change described in NXEP 4. When `None` is passed as the seed to a function decorated with `@np_random_state`, the decorator would return an instance of the newer `numpy.random.Generator` instead of `RandomState`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> type(foo(None))\nnumpy.random._generator.Generator\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Backend Priorities in NetworkX Programmatically in Python\nDESCRIPTION: Sets the backend priority for NetworkX as a Python list of backend names, controlling which backends are tried for accelerated operations. Skips execution in documentation build as indicated. Enables flexible, programmatic runtime dispatch.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nnx.config.backend_priority = [\"fast_backend\", \"other_backend\"]\n```\n\n----------------------------------------\n\nTITLE: Setting Backend Priority Programmatically in NetworkX (Python)\nDESCRIPTION: Configures backend priority within code by setting nx.config.backend_priority to a list of backend names. Tag skip-execution suggests the code is not run during documentation build. This method is less portable as changes require code edits but allows for programmatic backend selection. Follows with a PageRank call leveraging the chosen backend.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nnx.config.backend_priority = [\"fast_backend\"]\\npr = nx.pagerank(G)\n```\n\n----------------------------------------\n\nTITLE: Checking Current RNG Type with None Seed (Python)\nDESCRIPTION: This example shows the current behavior (NetworkX <= 2.X) when calling a function decorated with `@np_random_state` and passing `None` as the seed. The decorator currently returns an instance of `numpy.random.RandomState`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> type(foo(None))\nnumpy.random.mtrand.RandomState\n```\n\n----------------------------------------\n\nTITLE: Removing NetworkX nx_yaml Function and PyYAML Dependency\nDESCRIPTION: The 'nx_yaml' function for YAML I/O has been completely removed from NetworkX, along with the 'pyyaml' dependency. The removal was implemented using 'module.__getattr__' to intercept calls and provide informative errors, particularly addressing security concerns related to older PyYAML versions.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nnx_yaml\n```\n\nLANGUAGE: python\nCODE:\n```\npyyaml\n```\n\nLANGUAGE: python\nCODE:\n```\nmodule.__getattr__\n```\n\n----------------------------------------\n\nTITLE: Updating Local NetworkX Git Clone - Bash/Shell\nDESCRIPTION: This command fetches the latest changes from the upstream NetworkX repository into the local git clone. It keeps the local copy synchronized with the development branch, useful when tracking active development.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ git pull\n```\n\n----------------------------------------\n\nTITLE: Using New View Features in NetworkX 2.0 (Python)\nDESCRIPTION: This snippet illustrates new capabilities of the view objects introduced in NetworkX 2.0. It shows how to access node data directly from the `NodeView` (e.g., `G.nodes[3]`) and how to perform set operations (like intersection `&`) with the view.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.0.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> G.add_node(3, color='blue')\n>>> G.nodes[3]\n{'color': 'blue'}\n>>> G.nodes & {3, 4, 5}\n{3, 4}\n```\n\n----------------------------------------\n\nTITLE: Creating a NumPy Random State Instance - Python\nDESCRIPTION: This snippet demonstrates the legacy approach to initializing a random state object for use in NetworkX, returning either the global RandomState, a provided RandomState, or creating one from an integer seed. Supported input types include None, integer, RandomState, and Generator, though only Generator and RandomState are returned directly. A ValueError is raised for unsupported types. Dependencies: NumPy.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nif random_state is None or random_state is np.random:\n    return np.random.mtrand._rand\nif isinstance(random_state, np.random.RandomState):\n    return random_state\nif isinstance(random_state, int):\n    return np.random.RandomState(random_state)\nif isinstance(random_state, np.random.Generator):\n    return random_state\nmsg = (\n    f\"{random_state} cannot be used to create a numpy.random.RandomState or\\n\"\n    \"numpy.random.Generator instance\"\n)\nraise ValueError(msg)\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX YAML I/O Functions\nDESCRIPTION: These NetworkX functions, 'read_yaml' and 'write_yaml', used for reading and writing graph data in YAML format, are deprecated. Users should migrate to other serialization formats or handle YAML serialization manually if needed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nread_yaml\n```\n\nLANGUAGE: python\nCODE:\n```\nwrite_yaml\n```\n\n----------------------------------------\n\nTITLE: Running a Single Benchmark Test (Pagerank) Between Commits (Shell)\nDESCRIPTION: Uses `asv continuous` with the `--bench` flag to run only a specific benchmark test (`AlgorithmBenchmarks.time_pagerank`) when comparing the performance of two commits (`<sha1>` and `<sha2>`). Replace placeholders with actual commit SHAs.\nSOURCE: https://github.com/networkx/networkx/blob/main/benchmarks/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nasv continuous --bench AlgorithmBenchmarks.time_pagerank <sha1> <sha2>\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX preserve_random_state Utility\nDESCRIPTION: The NetworkX utility 'preserve_random_state', likely a context manager or decorator for managing the state of random number generators, is deprecated. Users should manage RNG state explicitly if needed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\npreserve_random_state\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX empty_generator Function\nDESCRIPTION: The NetworkX utility function 'empty_generator' is deprecated. This function likely returned a generator that immediately stops iteration (yields no values).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nempty_generator\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX adj_matrix Function\nDESCRIPTION: The NetworkX function 'adj_matrix' is deprecated. This function was used to obtain the adjacency matrix representation of a graph. Users should now use functions like 'networkx.to_scipy_sparse_array' or 'networkx.to_numpy_array' for creating matrix representations.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nadj_matrix\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing NetworkX Graphs in YAML Format - Python\nDESCRIPTION: Shows how to read and write NetworkX graphs as YAML files using the pyyaml package instead of the deprecated read_yaml/write_yaml. Requires NetworkX and pyyaml. Uses file context managers and demonstrates both dumping and loading graphs in YAML format. The yaml.Loader is specified to avoid security issues. Inputs: NetworkX graph, YAML file path; outputs: serialized and deserialized graph objects.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import yaml\n>>> G = nx.path_graph(4)\n>>> with open('test.yaml', 'w') as f:\n...     yaml.dump(G, f)\n...\n>>> with open('test.yaml', 'r') as f:\n...     G = yaml.load(f, Loader=yaml.Loader)\n...\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing NetworkX Graphs with Pickle - Python\nDESCRIPTION: Presents code for serializing and deserializing NetworkX graphs using the pickle module due to removal of the read_gpickle/write_gpickle functions. Requires NetworkX and Python's built-in pickle module. Handles file I/O with context managers. Inputs: graph object and file paths; outputs: pickled and unpickled graphs. Pickle protocol version can be specified.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_2.x_to_3.0.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import pickle\n>>> G = nx.path_graph(4)\n>>> with open('test.gpickle', 'wb') as f:\n...     pickle.dump(G, f, pickle.HIGHEST_PROTOCOL)\n...\n>>> with open('test.gpickle', 'rb') as f:\n...     G = pickle.load(f)\n...\n```\n\n----------------------------------------\n\nTITLE: Using `average_neighbor_degree` in NetworkX 1.6 (Python)\nDESCRIPTION: Illustrates the usage of the consolidated `average_neighbor_degree` function introduced in NetworkX 1.6, which replaces the older `average_neighbor_in_degree` and `average_neighbor_out_degree` functions. It computes the average neighbor degree for nodes in graph `G`, using the `source` and `target` parameters ('in' or 'out') to specify the desired directionality.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\naverage_neighbor_degree(G, source='in', target='in')\n```\n\nLANGUAGE: python\nCODE:\n```\naverage_neighbor_degree(G, source='out', target='out')\n```\n\n----------------------------------------\n\nTITLE: Induced Subgraph Creation and Type Conversion - NetworkX - Python\nDESCRIPTION: Illustrates how to generate an induced subgraph and convert it to a different graph type (e.g., to a directed graph) using the latest parameters (copy=True|False) and class constructors. The snippet uses path_graph to create an example graph and the DiGraph class to convert a subgraph copy. Requires networkx. Inputs: Existing graph and node subset. Outputs: Subgraph of the desired type. The create_using argument is removed in this version.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> G=nx.path_graph(5)\n>>> H=nx.DiGraph(G.subgraph([0,1])) # digraph of copy of induced subgraph\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging for NetworkX Backend Dispatch - Python\nDESCRIPTION: Demonstrates configuring the logging module to enable NetworkX's backend logger to print debug output to sys.stderr. Requires the standard 'logging' module. \"nxl\" is set as the logger for 'networkx', and the StreamHandler is added before changing the log level to DEBUG for maximum verbosity. No explicit inputs or outputs except for debug messages printed to standard error. No significant constraints.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport logging\\nnxl = logging.getLogger(\"networkx\")\\nnxl.addHandler(logging.StreamHandler())\\nnxl.setLevel(logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: List of Shortest Path Functions with Updated Behavior\nDESCRIPTION: Lists NetworkX functions related to shortest path calculations (A*, Dijkstra, Bellman-Ford variants) that were modified in version 1.4 to raise a NetworkXNoPath exception if no path exists between the specified source and target nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.4.rst#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nastar_path(), astar_path_length(), shortest_path(), shortest_path_length(),\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nbidirectional_shortest_path(), dijkstra_path(), dijkstra_path_length(),\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nbidirectional_dijkstra()\n^^^^^^^^^^^^^^^^^^^^^^^^\n   These algorithms now raise an exception when a source and a target are\n   specified and no path exist between these two nodes. The exception is\n   a NetworkXNoPath exception.\n```\n\n----------------------------------------\n\nTITLE: Querying Edges for Non-Existent Nodes using NetworkX in Python\nDESCRIPTION: This Python snippet demonstrates calling `G.edges()` with an iterable ('de') where neither the iterable itself nor its individual elements ('d', 'e') exist as nodes in the graph. Since 'de' is not a node, it's treated as an iterable ['d', 'e']. As neither 'd' nor 'e' are nodes, an empty edge view is returned.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/glossary.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> G.edges(\"de\")\nOutEdgeDataView([])\n```\n\n----------------------------------------\n\nTITLE: Image Comparison Testing with pytest-mpl in NetworkX (Python)\nDESCRIPTION: Illustrates the creation of an image comparison test for a Matplotlib figure using the pytest-mpl plugin and NetworkX's drawing utilities. The test function generates a barbell graph, computes a deterministic layout, and draws it, returning the figure for comparison with baseline images. Requires pytest, pytest-mpl, matplotlib, and networkx as dependencies. Always fix random seeds to provide reproducible results. Intended for use within NetworkX's test suite for graphical regression testing.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.mpl_image_compare\ndef test_barbell():\n    fig = plt.figure()\n    barbell = nx.barbell_graph(4, 6)\n    # make sure to fix any randomness\n    pos = nx.spring_layout(barbell, seed=42)\n    nx.draw(barbell, pos=pos)\n    return fig\n\n```\n\n----------------------------------------\n\nTITLE: Converting and Reading Sparse6 Files with NetworkX (Python)\nDESCRIPTION: This snippet lists functions for converting and reading sparse6-format graphs using the networkx.readwrite.sparse6 module. It provides entry points for serializing graphs to sparse6 bytes, deserializing, and file operations. Dependencies include the NetworkX library; the expected input is a graph object or sparse6-format data, and the expected output is a converted graph or sparse6-encoded bytes. Suitable for storing large, sparse undirected graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/sparsegraph6.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n   from_sparse6_bytes\n   read_sparse6\n   to_sparse6_bytes\n   write_sparse6\n```\n\n----------------------------------------\n\nTITLE: Importing nx_agraph Functions Directly in NetworkX 1.11 (Python)\nDESCRIPTION: Illustrates the alternative way to use functions from the `nx_agraph` module in NetworkX 1.11. Users can directly import specific functions like `write_dot` from their submodule path `networkx.drawing.nx_agraph`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.11.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom networkx.drawing.nx_agraph import write_dot\n```\n\n----------------------------------------\n\nTITLE: Querying Edges with List Containing Non-Node using NetworkX in Python\nDESCRIPTION: This Python snippet illustrates the behavior of `G.edges()` when passed a list containing an item ('bc') that is not a node in the graph. NetworkX treats the list as an iterable, and its element 'bc' is considered as a potential single node. Since 'bc' is not found as a node in the graph, an empty edge view is returned.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/glossary.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> G.edges([\"bc\"])\nOutEdgeDataView([])\n```\n\n----------------------------------------\n\nTITLE: Getting Graph Information with G.info() in NetworkX (Python)\nDESCRIPTION: Shows how to use the `G.info(node=None)` function in NetworkX to retrieve concise information about the entire graph or a specific node. This function was introduced in NetworkX version 0.26.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nG.info(node=None)\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX using pip (Shell)\nDESCRIPTION: This shell command uses the Python package installer `pip` to install the latest stable release of the NetworkX library from the Python Package Index (PyPI). This is the standard command for installing the base NetworkX package without optional dependencies.\nSOURCE: https://github.com/networkx/networkx/blob/main/README.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ pip install networkx\n```\n\n----------------------------------------\n\nTITLE: Cloning NetworkX Source from GitHub - Bash/Shell\nDESCRIPTION: This snippet utilizes git to clone the entire NetworkX source repository from GitHub. After execution, it creates a local networkx directory containing the latest development code. Requires Git to be installed and network access.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/networkx/networkx.git\n```\n\n----------------------------------------\n\nTITLE: Importing NetworkX Flow Algorithms (Python)\nDESCRIPTION: Demonstrates how to explicitly import specific flow algorithms (`ford_fulkerson`, `preflow_push`, `edmonds_karp`, `shortest_augmenting_path`) from the `networkx.algorithms.flow` package in NetworkX 1.9. These functions are no longer available directly under the base `networkx` namespace.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.9.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from networkx.algorithms.flow import (ford_fulkerson, preflow_push,\n...        edmonds_karp, shortest_augmenting_path)  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Setting up NetworkX Development Environment using Conda\nDESCRIPTION: These shell commands show how to set up a Conda environment named 'networkx-dev', activate it, install required development, testing, and runtime dependencies from conda-forge using requirements files, optionally install extra dependencies, install NetworkX in editable mode using pip (`-e .`), and run tests using pytest.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Create a conda environment named ``networkx-dev``\nconda create --name networkx-dev\n# Activate it\nconda activate networkx-dev\n# Install main development and runtime dependencies of networkx\nconda install -c conda-forge --file requirements/default.txt --file requirements/test.txt --file requirements/developer.txt\n#\n# (Optional) Install pygraphviz and pydot packages\n# These packages require that you have your system properly configured\n# and what that involves differs on various systems.\n# conda install -c conda-forge --file requirements/extra.txt\n#\n# Install networkx from source\npip install -e .\n# Test your installation\npytest --pyargs networkx\n```\n\n----------------------------------------\n\nTITLE: Passing Backend-specific Arguments in NetworkX Function - Python\nDESCRIPTION: Demonstrates passing a backend-specific argument ('get_chunks') in addition to standard parameters when invoking a NetworkX algorithm using the 'parallel' backend. Such arguments are passed through only to the relevant backend implementation; for this to work, the backend must support the extra argument. Dependencies are NetworkX, an installed 'parallel' backend, and a definition for 'get_chunks'. Inputs include the graph, sample size, backend name, and backend-specific keyword arguments. Output is backend-calculated betweenness centrality.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnx.betweenness_centrality(G, k=10, backend=\"parallel\", get_chunks=get_chunks)\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Doc Build Dependencies - Requirements File - plaintext\nDESCRIPTION: This snippet provides a list of required Python packages and version constraints for documentation generation using Sphinx and its associated plugins. It relies on standard requirements.txt format and should not be manually edited, as it is autogenerated via tools/generate_requirements.py and a pre-commit hook. Dependencies listed include sphinx, pydata-sphinx-theme, sphinx-gallery, numpydoc, pillow, texext, myst-nb, and intersphinx-registry, which are necessary for rich documentation features; inputs are package names and version specs, and outputs are used by package managers like pip to install prerequisites.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/doc.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\\n# Do not edit this file; modify pyproject.toml instead.\\nsphinx>=8.0\\npydata-sphinx-theme>=0.16\\nsphinx-gallery>=0.18\\nnumpydoc>=1.8.0\\npillow>=10\\ntexext>=0.6.7\\nmyst-nb>=1.1\\nintersphinx-registry\n```\n\n----------------------------------------\n\nTITLE: Declaring Pytest Requirements - Text Configuration\nDESCRIPTION: This snippet lists the minimum required versions of testing dependencies for the project, such as pytest, pytest-cov for coverage, and pytest-xdist for distributed testing. The file is generated automatically and should not be edited manually; instead, updates should be applied to 'pyproject.toml'. This ensures that all contributors use consistent test environments and the dependencies meet the specified minimum version requirements.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/test.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\\n# Do not edit this file; modify pyproject.toml instead.\\npytest>=7.2\\npytest-cov>=4.0\\npytest-xdist>=3.0\n```\n\n----------------------------------------\n\nTITLE: Specifying Minimum Versions for Optional Python Dependencies\nDESCRIPTION: This configuration snippet lists optional Python packages and their minimum required versions needed for extra functionalities in the NetworkX library. It includes geospatial (osmnx, momepy, contextily), plotting (seaborn, cairocffi), graph analysis (igraph), and machine learning (scikit-learn) dependencies. This format is typically used by package managers like pip. The comments indicate the file is auto-generated from pyproject.toml and shouldn't be modified manually.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/example.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\\n# Do not edit this file; modify pyproject.toml instead.\\nosmnx>=2.0.0\\nmomepy>=0.7.2\\ncontextily>=1.6\\nseaborn>=0.13\\ncairocffi>=1.7\\nigraph>=0.11\\nscikit-learn>=1.5\n```\n\n----------------------------------------\n\nTITLE: Adding Path Method for v1.x Compatibility in NetworkX (Python)\nDESCRIPTION: Provides an ad hoc method to add the 'add_path' function to the NetworkX v1.x namespace, enabling code compatible with v2.x to run in v1.x. Checks the major version and conditionally defines 'nx.add_path' for v1.x installations. Depends on NetworkX, and assumes typical import as 'import networkx as nx'.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> if nx.__version__[0] == '1':\n...     nx.add_path = lambda G, nodes: G.add_path(nodes)\n```\n\n----------------------------------------\n\nTITLE: Importing the NetworkX Isomorphism Module in Python\nDESCRIPTION: Demonstrates the recommended way to import the `networkx.algorithms.isomorphism` module in Python, using the alias `iso`. This alias provides convenient access to isomorphism-related functions like `is_isomorphic` and the various helper functions (e.g., `categorical_node_match`, `numerical_edge_match`) used for creating custom matchers.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport networkx.algorithms.isomorphism as iso\n```\n\n----------------------------------------\n\nTITLE: Converting Numpy Scalars to Native Python Types (Python)\nDESCRIPTION: Shows how to safely return a native Python scalar instead of a numpy scalar from a function to improve compatibility in the NetworkX codebase. After performing computations yielding a numpy type (e.g., np.int64), the item() method converts it to a native Python type before returning. Requires numpy as a dependency. Ensures functions avoid returning numpy-specific types.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef convert_to_python_type():\n    # Perform some computation resulting in a numpy scalar\n    a = np.int64(42)\n    # Convert to a Python scalar before returning\n    return a.item()\n\n```\n\n----------------------------------------\n\nTITLE: Defining Function for Reproducibility Demonstration (Python)\nDESCRIPTION: This defines a sample function `bar` decorated with `np_random_state`. The function takes a number `num` and a `seed`, uses the generated random state object (`seed`) to produce `num` uniform random numbers, and returns them. This function is used to demonstrate reproducibility differences between `RandomState` and `Generator`.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@np_random_state(\"seed\")\ndef bar(num, seed=None):\n    \"\"\"Return an array of `num` uniform random numbers.\"\"\"\n    return seed.random(num)\n```\n\n----------------------------------------\n\nTITLE: Updating Local Main Branch from Upstream using Git\nDESCRIPTION: These Git commands first switch to the local 'main' branch and then pull the latest changes from the 'upstream' (original NetworkX) repository's 'main' branch. This ensures the local main branch is synchronized before creating a new feature branch.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\ngit pull upstream main\n```\n\n----------------------------------------\n\nTITLE: Illustrating NetworkX Undirected Graph Data Structure (Python)\nDESCRIPTION: Shows the underlying dictionary-based data structure of a NetworkX undirected graph. It creates a `nx.Graph`, adds edges between nodes 'A', 'B', and 'C', and prints the adjacency view (`G.adj`) to reveal the nested dictionary representation. Requires the `networkx` library imported as `nx` (implicitly assumed from context).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/introduction.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nG = nx.Graph()\nG.add_edge('A', 'B')\nG.add_edge('B', 'C')\nprint(G.adj)\n```\n\n----------------------------------------\n\nTITLE: Importing the NetworkX Library (Python)\nDESCRIPTION: Shows the standard, recommended way to import the entire NetworkX library. This convention was established in version 0.23, replacing the older 'NX' package name.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport networkx\n```\n\n----------------------------------------\n\nTITLE: Defining Build and Distribution Dependencies in requirements Format\nDESCRIPTION: This snippet lists Python package dependencies required for building (`build`, `wheel`), releasing (`twine`), and potentially managing changes (`changelist`) for a Python project. It specifies minimum versions using `>=` for most packages, but an exact version (`==`) for `changelist`. These dependencies are typically installed using tools like `pip`.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/release.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\nbuild>=0.10\\ntwine>=4.0\\nwheel>=0.40\\nchangelist==0.5\n```\n\n----------------------------------------\n\nTITLE: Building NetworkX Egg Distribution (Bash)\nDESCRIPTION: Command-line instruction provided in the NetworkX 0.32 release notes to build a Python Egg distribution package for NetworkX using `setup_egg.py`. This command leverages `setuptools` and makes egg usage optional.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython setup_egg.py bdist_egg\n```\n\n----------------------------------------\n\nTITLE: Explicitly Passing numpy.random.RandomState Instance (Python)\nDESCRIPTION: This example clarifies that even after the proposed default change to `Generator`, users can still achieve the previous behavior by explicitly creating a `numpy.random.RandomState` instance and passing it as the `seed` argument.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> rs = np.random.RandomState(12345)\n>>> type(foo(rs))\nnumpy.random.mtrand.RandomState\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Changed Output with Proposed Generator (Python)\nDESCRIPTION: This example illustrates the impact of the proposed change on reproducibility. If the default RNG is changed to `numpy.random.Generator`, calling the `bar` function with the same integer seed (12345) will produce a *different* sequence of random numbers compared to the output generated by `RandomState` shown previously.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> bar(10, seed=12345)\narray([0.22733602, 0.31675834, 0.79736546, 0.67625467, 0.39110955,\n       0.33281393, 0.59830875, 0.18673419, 0.67275604, 0.94180287])\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks for NetworkX Development\nDESCRIPTION: This command installs pre-commit hooks into the local Git repository. These hooks automatically run linters and formatters (as configured in `.pre-commit-config.yaml`) on staged files before each commit, helping to maintain consistent code style and quality.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Using `average_degree_connectivity` in NetworkX 1.6 (Python)\nDESCRIPTION: Shows the updated usage of `average_degree_connectivity` in NetworkX 1.6. This function replaces the deprecated `average_in_degree_connectivity` and `average_out_degree_connectivity`. It calculates the average degree connectivity of a graph `G`, allowing specification of the source and target node degree types ('in' or 'out') via the `source` and `target` parameters.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\naverage_degree_connectivity(G, source='in', target='in')\n```\n\nLANGUAGE: python\nCODE:\n```\naverage_degree_connectivity(G, source='out', target='out')\n```\n\n----------------------------------------\n\nTITLE: Setting up an Icosahedral Graph with Capacities (Python)\nDESCRIPTION: Illustrates creating an icosahedral graph using `networkx.icosahedral_graph()` and setting a 'capacity' attribute with a value of 1 for all edges using `networkx.set_edge_attributes()`. This setup prepares the graph for subsequent maximum flow and minimum cut examples.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.9.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx as nx\n>>> G = nx.icosahedral_graph()\n>>> nx.set_edge_attributes(G, 'capacity', 1)\n```\n\n----------------------------------------\n\nTITLE: Checking Current RNG Type with Integer Seed (Python)\nDESCRIPTION: This example demonstrates that, under the current implementation, providing an integer value for the `seed` parameter to a function decorated with `@np_random_state` also results in the creation and use of a `numpy.random.RandomState` instance.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> type(foo(12345))\nnumpy.random.mtrand.RandomState\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current Reproducibility with RandomState (Python)\nDESCRIPTION: This snippet shows the current behavior regarding reproducibility. When using the same integer seed (12345) in multiple calls to the decorated function `bar`, the `np_random_state` decorator (using `RandomState` by default) produces the exact same sequence of random numbers, ensuring reproducibility.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> bar(10, seed=12345)\narray([0.92961609, 0.31637555, 0.18391881, 0.20456028, 0.56772503,\n       0.5955447 , 0.96451452, 0.6531771 , 0.74890664, 0.65356987])\n>>> bar(10, seed=12345)\narray([0.92961609, 0.31637555, 0.18391881, 0.20456028, 0.56772503,\n       0.5955447 , 0.96451452, 0.6531771 , 0.74890664, 0.65356987])\n```\n\n----------------------------------------\n\nTITLE: Installing Default Requirements using Pip in Bash\nDESCRIPTION: This command demonstrates how to install the default Python package dependencies for the NetworkX project using pip. It utilizes the '-U' flag to upgrade packages to the newest available version and the '-r' flag to specify the requirements file (`requirements/default.txt`).\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install -U -r requirements/default.txt\n```\n\n----------------------------------------\n\nTITLE: Installing Test Requirements using Pip in Bash\nDESCRIPTION: These commands show the process for setting up the environment to run the NetworkX test suite. First, the default requirements are installed/upgraded using `pip install -U -r requirements/default.txt`. Then, the specific testing requirements are installed/upgraded using `pip install -U -r requirements/test.txt`.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install -U -r requirements/default.txt\n$ pip install -U -r requirements/test.txt\n```\n\n----------------------------------------\n\nTITLE: Using Info Function for Graphs - NetworkX - Python\nDESCRIPTION: Demonstrates the switch of info from being a method to a standalone function in networkx. When called, it displays summary statistics for the provided graph. Inputs: Graph with custom name. Output: Formatted information about the graph. Requires networkx.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n>>> G=nx.Graph(name='test me')\n>>> nx.info(G)  # doctest: +SKIP\nName:                  test me\nType:                  Graph\nNumber of nodes:       0\nNumber of edges:       0\n```\n\n----------------------------------------\n\nTITLE: Finding Function Definition using Grep (Bash)\nDESCRIPTION: Demonstrates using the 'grep -r' command-line utility to recursively search ('-r') for the definition string ('def kamada_kawai_layout') within the current directory ('.') and its subdirectories. The output shows the file path and the line containing the matching function definition.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/new_contributor_faq.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ grep -r \"def kamada_kawai_layout\" .\n./networkx/drawing/layout.py:def kamada_kawai_layout(\n```\n\n----------------------------------------\n\nTITLE: Recovering Original Reproducibility by Passing RandomState (Python)\nDESCRIPTION: This snippet demonstrates how users can maintain the exact reproducibility of older code after the proposed change. By explicitly creating a `numpy.random.RandomState` instance with the desired seed and passing this instance to the decorated function, the original sequence of random numbers can be recovered.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> rng = np.random.RandomState(12345)\n>>> bar(10, seed=rng)\narray([0.92961609, 0.31637555, 0.18391881, 0.20456028, 0.56772503,\n       0.5955447 , 0.96451452, 0.6531771 , 0.74890664, 0.65356987])\n```\n\n----------------------------------------\n\nTITLE: Defining the `is_isomorphic` Function Signature in NetworkX 1.6 (Python)\nDESCRIPTION: Presents the updated Python function signature for `is_isomorphic` in NetworkX 1.6. It now accepts two graph objects (`g1`, `g2`) and optional `node_match` and `edge_match` functions. These functions allow for customized comparison of node and edge attributes during the isomorphism check, replacing the need for separate weighted matcher classes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nis_isomorphic(g1, g2, node_match=None, edge_match=None)\n```\n\n----------------------------------------\n\nTITLE: Referencing the Kevin Bacon Example Script (Python)\nDESCRIPTION: Mentions the example script `Examples/kevin_bacon.py`, introduced around version 0.22, which demonstrates NetworkX usage, likely involving graph creation and pathfinding related to the 'Six Degrees of Kevin Bacon' concept.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nExamples/kevin_bacon.py\n```\n\n----------------------------------------\n\nTITLE: Accessing Directed Attribute - NetworkX - Python\nDESCRIPTION: Illustrates accessing the directed attribute of a DiGraph object to check orientation, rather than calling is_directed(). Requires networkx and a DiGraph object. Inputs: DiGraph instance. Output: Boolean indicating directionality. This reflects the move from method to attribute.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n>>> G=nx.DiGraph()\n>>> # G.directed\n#  True\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Tests for a Custom Backend using Shell\nDESCRIPTION: Shell commands demonstrating how to run the NetworkX test suite against a custom backend. It involves setting the 'NETWORKX_TEST_BACKEND' environment variable to the backend's name and optionally 'NETWORKX_FALLBACK_TO_NX' to control behavior for unimplemented algorithms, then executing pytest.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nNETWORKX_TEST_BACKEND=<backend_name>\nNETWORKX_FALLBACK_TO_NX=True # or False\npytest --pyargs networkx\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote Repository using Git\nDESCRIPTION: This command adds the original NetworkX repository as a remote named 'upstream'. This allows contributors to fetch changes from the main project repository to keep their local repository and fork up-to-date.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream git@github.com:networkx/networkx.git\n```\n\n----------------------------------------\n\nTITLE: Applying the Proposed `@graph_builder` Decorator in NetworkX Python\nDESCRIPTION: Example of applying the proposed `@graph_builder` decorator to a function (`extended_barabasi_albert_graph`) that internally constructs and returns a complete NetworkX graph object `G`. This decorator is intended to automatically provide the corresponding generator functionality (e.g., `nx.extended_barabasi_albert_graph_generator`) which would yield the graph sequence. It also shows the co-use of `@py_random_state` for random seed management.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@graph_builder\n@py_random_state(4)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    # some fancy code that requires we construct G to use graph properties\n    # while we decide what edges to add next.\n    return G\n```\n\n----------------------------------------\n\nTITLE: Defining a node and edge graph builder decorator in Python\nDESCRIPTION: This snippet defines the 'node_and_edge_builder' decorator, designed to wrap functions yielding node and edge data for flexible NetworkX graph creation. It attaches methods for generating Graph, DiGraph, MultiGraph, and MultiDiGraph objects, as well as custom graph types using a 'create_using' parameter. The wrapped function exposes alternative constructors as attributes, plus a direct edgelist generator. Dependencies include Python's functools, and NetworkX for graph classes, and it expects the decorated function to yield edge or node data in a compatible format as input. Output is a function with attribute-methods for creating various kinds of NetworkX graphs or returning edge lists. Limitations are that the decorator expects the underlying function to produce data suitable for NetworkX construction.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef node_and_edge_builder(f):\n    @wraps(f)\n    def graph(*args, **kwargs):\n        return nx.Graph(f(*args, **kwargs))\n\n    def digraph(*args, **kwargs):\n        return nx.DiGraph(f(*args, **kwargs))\n\n    def multigraph(*args, **kwargs):\n        return nx.MultiGraph(f(*args, **kwargs))\n\n    def multidigraph(*args, **kwargs):\n        return nx.MultiDiGraph(f(*args, **kwargs))\n\n    def custom_graph(*args, create_using=None, **kwargs):\n        g = create_using()\n        g.update(f(*args, **kwargs))\n        return g\n\n    graph.Graph = graph\n    graph.DiGraph = digraph\n    graph.MultiGraph = multigraph\n    graph.MultiDiGraph = multidigraph\n    graph.CustomGraph = custom_graph\n    graph.edgelist = f\n    return graph\n```\n\n----------------------------------------\n\nTITLE: Disabling NetworkX Backend Debug Logging - Python\nDESCRIPTION: Demonstrates how to set the NetworkX backend logger's level to CRITICAL, effectively suppressing debug and informational messages. Uses the 'nxl' logger previously configured. No dependencies beyond the Python 'logging' module. No parameters; sets the log level directly with no outputs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnxl.setLevel(logging.CRITICAL)\n```\n\n----------------------------------------\n\nTITLE: Applying the Proposed `@node_and_edge_builder` Decorator in NetworkX Python\nDESCRIPTION: Example of applying the proposed `@node_and_edge_builder` decorator to a function (`ladder_graph_generator`) that yields graph sequence elements (in this case, edges represented as node pairs). This decorator is designed to automatically create the corresponding graph-building function (e.g., `nx.ladder_graph`) that accepts `create_using` and constructs the graph from the yielded sequence.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@node_and_edge_builder\ndef ladder_graph_generator(n):\n    yield from pairwise(range(n))\n    yield from pairwise(range(n, 2 * n))\n    yield from ((v, v + n) for v in range(n))\n```\n\n----------------------------------------\n\nTITLE: Updating an Existing NetworkX Graph with a Proposed Binomial Graph Generator in Python\nDESCRIPTION: Illustrates how to add nodes and edges from a generated graph sequence to an existing graph `G` using the `G.update()` method. It calls the proposed `nx.binomial_graph_generator` function with a range of nodes (9 to 18) to generate the sequence.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> G.update(nx.binomial_graph_generator(range(9, 19))\n```\n\n----------------------------------------\n\nTITLE: Displaying Matplotlib Plots in Python\nDESCRIPTION: Calls `plt.show()` from Matplotlib to render and display any figures that have been created, such as those generated by NetworkX drawing functions. This command is often necessary to make the plot window appear, especially when running Python scripts outside of an interactive environment.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Querying Edges for Non-Node Iterable using NetworkX in Python\nDESCRIPTION: This Python snippet shows how NetworkX's `G.edges()` method handles an iterable (the string 'bc') that is not itself a node in the graph. Because 'bc' is not a node, NetworkX treats the string as an iterable of individual potential nodes ('b', 'c') and returns edges associated with those nodes if they exist in the graph.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/glossary.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G.edges(\"bc\")\nOutEdgeDataView([('b', 'c')])\n```\n\n----------------------------------------\n\nTITLE: Listing Isomorphism Helper Functions in NetworkX 1.6\nDESCRIPTION: Lists the helper functions available in the `networkx.algorithms.isomorphism` module as of NetworkX 1.6. These functions (`categorical_*`, `numerical_*`, `generic_*`) are designed to simplify the creation of custom `node_match` and `edge_match` functions, which can then be supplied to the `is_isomorphic` function for attribute-aware graph isomorphism testing.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\ncategorical_node_match\ncategorical_edge_match\ncategorical_multiedge_match\nnumerical_node_match\nnumerical_edge_match\nnumerical_multiedge_match\ngeneric_node_match\ngeneric_edge_match\ngeneric_multiedge_match\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Gpickle I/O Functions\nDESCRIPTION: These NetworkX functions, 'read_gpickle' and 'write_gpickle', used for serializing and deserializing NetworkX graphs using Python's pickle format, are deprecated. Users should consider alternative serialization methods like standard pickle or other graph formats.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nread_gpickle\n```\n\nLANGUAGE: python\nCODE:\n```\nwrite_gpickle\n```\n\n----------------------------------------\n\nTITLE: Constructing a Path Graph as a MultiDiGraph using NetworkX in Python\nDESCRIPTION: Shows two methods for creating a directed multigraph (`MultiDiGraph`) representing a specific path (`[3, 4, 2, 5, 7, 6]`). The first uses the existing `create_using` parameter with `nx.path_graph`. The second uses the proposed `nx.path_graph_generator` to generate the graph sequence and passes it to the `nx.MultiDiGraph` constructor, demonstrating the flexibility of the proposed generator approach.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> MDG = nx.path_graph([3, 4, 2, 5, 7, 6], create_using=MultiDiGraph)\n>>> MDG = nx.MultiDiGraph(nx.path_graph_generator([3, 4, 2, 5, 7, 6])\n```\n\n----------------------------------------\n\nTITLE: Enabling Global Debug Logging in Python\nDESCRIPTION: Sets the Python root logger's level globally to DEBUG, activating detailed log output for all modules, including NetworkX. Simple and effective for development or troubleshooting. Requires import of logging module.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/tutorial.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nlogging.basicConfig(level=logging.DEBUG)\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX HITS Matrix Functions\nDESCRIPTION: The NetworkX functions 'hub_matrix' and 'authority_matrix', related to the HITS algorithm for link analysis, are deprecated. Users should refer to the main HITS implementation or alternative methods for these calculations.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nhub_matrix\n```\n\nLANGUAGE: python\nCODE:\n```\nauthority_matrix\n```\n\n----------------------------------------\n\nTITLE: Defining a general graph builder decorator in Python\nDESCRIPTION: This snippet shows the 'graph_builder' decorator that modifies a graph-constructing function to support easy extraction of edgelists and the construction of different NetworkX graph types as attribute methods. It provides alternatives for creating Graph, DiGraph, MultiGraph, MultiDiGraph, or a custom graph using a 'create_using' argument. The 'edgelist' attribute-method yields a combined sequence of nodes (with data) and edges (with data) using itertools. Dependencies include functools (for wraps), itertools, and NetworkX. Expected inputs are parameters for the underlying graph factory, and outputs are either graph objects or generator objects for edge lists. The decorator expects a function returning a NetworkX-compatible graph when called.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef graph_builder(f):\n    @wraps(f)\n    def edgelist(*args, **kwargs):\n        g = f(*args, **kwargs)\n        return itertools.ichain(map(tuple, G.nodes.data()), map(tuple, G.edges.data()))\n\n    f.edgelist = edgelist\n    f.CustomGraph = f\n\n    def graph(*args, **kwargs):\n        return f(*args, create_using=nx.Graph, **kwargs)\n\n    def digraph(*args, **kwargs):\n        return f(*args, create_using=nx.DiGraph, **kwargs)\n\n    def multigraph(*args, **kwargs):\n        return f(*args, create_using=nx.MultiGraph, **kwargs)\n\n    def multidigraph(*args, **kwargs):\n        return f(*args, create_using=nx.MultiDiGraph, **kwargs)\n\n    f.Graph = graph\n    f.DiGraph = digraph\n    f.MultiGraph = multigraph\n    f.MultiDiGraph = multidigraph\n    return f\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX JIT Functions\nDESCRIPTION: The NetworkX functions or variables 'jit_data' and 'jit_graph' are deprecated. These were likely related to experimental Just-In-Time compilation features, possibly using Numba, for graph data or operations.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\njit_data\n```\n\nLANGUAGE: python\nCODE:\n```\njit_graph\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX k_nearest_neighbors Function\nDESCRIPTION: The NetworkX function 'k_nearest_neighbors' is deprecated. This function likely computed the k-nearest neighbors for nodes based on some implicit or explicit distance/similarity metric, possibly requiring node attributes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nk_nearest_neighbors\n```\n\n----------------------------------------\n\nTITLE: Migrating Graph Data with Pickle Between NetworkX Versions (Python)\nDESCRIPTION: Shows a migration workflow for transferring graph data between NetworkX v1.x and v2.x using Pickle. Since pickled v1.x graphs may not unpickle in v2.x, the snippet first dumps node and edge data in v1.x and later reconstructs the graph from this data in v2.x. Requires Python's 'pickle' module and NetworkX. Inputs are a file handle and the required graphs.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/migration_guide_from_1.x_to_2.0.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> # in v1.x\n>>> pickle.dump([G.nodes(data=True), G.edges(data=True)], file)  # doctest: +SKIP\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> # then in v2.x\n>>> nodes, edges = pickle.load(file)  # doctest: +SKIP\n>>> G = nx.Graph()  # doctest: +SKIP\n>>> G.add_nodes_from(nodes)  # doctest: +SKIP\n>>> G.add_edges_from(edges)  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Standard Python Import Conventions for NetworkX Development\nDESCRIPTION: This Python code snippet illustrates the standard import conventions recommended for NetworkX development. It shows the preferred aliases for commonly used libraries like NumPy, SciPy, Matplotlib, Pandas, and NetworkX itself.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport scipy as sp\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport networkx as nx\n```\n\n----------------------------------------\n\nTITLE: Implementing __getitem__ Slicing in NetworkX View Classes - Python\nDESCRIPTION: Demonstrates a potential implementation of slicing in NodeView's __getitem__ method, allowing both direct index access and retrieval of slices as lists. The method checks if the input n is a slice, in which case it converts the internal _nodes to a list and returns the requested slice segment; otherwise, it retrieves a single node entry. This pattern relies on _nodes being a dict-like object and assumes Python 3.6+ where dicts maintain insertion order.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0002.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef __getitem__(self, n):\n    if isinstance(n, slice):\n        return list(self._nodes).__getitem__(n)\n    return self._nodes[n]\n\n```\n\n----------------------------------------\n\nTITLE: Working with In-Edges in Directed Graphs - NetworkX - Python\nDESCRIPTION: Demonstrates updated idioms for obtaining in-edges of a directed graph by reversing the graph and calling edges(), or by list comprehensions swapping node order. Requires networkx and a DiGraph. Input: DiGraph G. Output: Edge list in the in-edges format. Adopts these patterns instead of deprecated G.in_edges().\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_0.99.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n>>> G = nx.DiGraph()\n>>> R = G.reverse()\n>>> R.edges()  # doctest: +SKIP\n[]\n\n>>> [(v,u) for (u,v) in G.edges()]\n[]\n```\n\n----------------------------------------\n\nTITLE: Querying Degree after API Change in NetworkX (Python)\nDESCRIPTION: Demonstrates how the degree() method returns a dictionary keyed by node, reflecting a change from earlier versions where a list was returned and the 'with_labels' keyword was required. This change affects all primary graph classes and some algorithms. No external dependencies are needed except for importing NetworkX. The snippet shows how to inspect degrees in both batch and single-node queries. Returns a dictionary for all nodes, or an integer for a single node.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> G=nx.Graph()\n>>> G.add_edge('a','b')\n>>> G.degree()  # doctest: +SKIP\n{'a': 1, 'b': 1}\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> G.degree('a')\n1\n```\n\n----------------------------------------\n\nTITLE: Starting Definition of create_random_state Function (Python)\nDESCRIPTION: This snippet shows the beginning definition of the `create_random_state` utility function within NetworkX. This function is central to the proposed change, as its internal logic determines which type of random number generator (`RandomState` or `Generator`) is created based on the input `random_state` argument (e.g., None, integer, existing RNG instance).\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef create_random_state(random_state=None):\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Dependencies with pip (Python, Shell)\nDESCRIPTION: Installs the necessary Python packages for building NetworkX documentation by reading the requirements from 'requirements/doc.txt'. This command should be run from the root directory of the project after installing NetworkX and its core dependencies. The input to the command is the text file specifying dependency requirements, and the expected output is the installed packages ready for building documentation. No special output is produced, but errors will occur if dependencies are missing or the requirements file is not found.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/README.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements/doc.txt\n```\n\n----------------------------------------\n\nTITLE: Using the Deprecated 'import NX' Statement (Python)\nDESCRIPTION: Shows the older, now deprecated, import statement `import NX` used prior to NetworkX version 0.23. Code cleanup mentioned in the version 0.22 notes involved changing these imports to protect namespaces, preceding the official package rename.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport NX\n```\n\n----------------------------------------\n\nTITLE: Pushing Local Branch to Forked Repository using Git\nDESCRIPTION: This Git command pushes the changes from the local feature branch ('bugfix-for-issue-1480') to the corresponding branch on the 'origin' remote, which is the contributor's personal fork on GitHub. This makes the changes available online for creating a pull request.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin bugfix-for-issue-1480\n```\n\n----------------------------------------\n\nTITLE: Setting up NetworkX Development Environment using venv/pip\nDESCRIPTION: These shell commands demonstrate how to set up a Python virtual environment using `venv`, activate it, install required development, testing, and runtime dependencies using pip from requirements files, optionally install extra dependencies like pygraphviz/pydot, install NetworkX in editable mode (`-e .`), and run tests using pytest.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Create a virtualenv named ``networkx-dev`` that lives in the directory of\n# the same name\npython -m venv networkx-dev\n# Activate it\nsource networkx-dev/bin/activate\n# Install main development and runtime dependencies of networkx\npip install -r requirements/default.txt -r requirements/test.txt -r requirements/developer.txt\n#\n# (Optional) Install pygraphviz and pydot packages\n# These packages require that you have your system properly configured\n# and what that involves differs on various systems.\n# pip install -r requirements/extra.txt\n#\n# Build and install networkx from source\npip install -e .\n# Test your installation\npytest --pyargs networkx\n```\n\n----------------------------------------\n\nTITLE: Comparing NetworkX Benchmark Performance Between Two Commits (Shell)\nDESCRIPTION: Uses the `asv continuous` command to run benchmarks on two specified Git commits (`base_commit_hash` and `test_commit_hash`) and compare their performance results. Replace the placeholders with actual commit SHAs.\nSOURCE: https://github.com/networkx/networkx/blob/main/benchmarks/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nasv continuous base_commit_hash test_commit_hash\n```\n\n----------------------------------------\n\nTITLE: Checking for Iterator Type in Python\nDESCRIPTION: This snippet demonstrates the recommended way to check if an object 'obj' is an iterator using Python's built-in 'isinstance' function and the 'collections.abc.Iterator' abstract base class. This replaces the deprecated 'networkx.utils.misc.is_iterator' function.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nisinstance(obj, collections.abc.Iterator)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Feature Branch using Git\nDESCRIPTION: This Git command creates a new branch named 'bugfix-for-issue-1480' based off the 'main' branch and switches to it. It is recommended to use descriptive branch names that indicate the purpose of the branch, often referencing a specific issue number.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b bugfix-for-issue-1480 main\n```\n\n----------------------------------------\n\nTITLE: Installing an Individual Optional Package via pip - Bash/Shell\nDESCRIPTION: This snippet demonstrates installing a single optional dependency, pygraphviz, with pip. It is suitable when only one additional feature (e.g., advanced graph layout) is required without installing all extras.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install pygraphviz\n```\n\n----------------------------------------\n\nTITLE: Importing Module Documentation with Sphinx automodule (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `automodule` feature to automatically include documentation generated from the docstrings of the `networkx.algorithms.tournament` Python module. It's a key part of generating API documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/tournament.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.tournament\n```\n\n----------------------------------------\n\nTITLE: Creating Git Branch for Example Contribution (Bash)\nDESCRIPTION: Demonstrates creating a new Git feature branch named 'complete-graph-circular-layout-example' using the 'git checkout -b' command. This is a recommended first step when starting work on a new contribution, such as a gallery example, to isolate changes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/new_contributor_faq.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b complete-graph-circular-layout-example\n```\n\n----------------------------------------\n\nTITLE: Generating Maximum Flow Function Summaries (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for maximum flow related functions (`maximum_flow`, `maximum_flow_value`, `minimum_cut`, `minimum_cut_value`) from the NetworkX library. The `:toctree:` option links to detailed documentation pages.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   maximum_flow\n   maximum_flow_value\n   minimum_cut\n   minimum_cut_value\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for A* Algorithm Functions (reStructuredText)\nDESCRIPTION: This reStructuredText snippet uses Sphinx directives to automatically generate documentation for the A* search algorithm functions (`astar_path`, `astar_path_length`) defined in the `networkx.algorithms.shortest_paths.astar` module. The generated documentation files are placed within the 'generated/' directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/shortest_paths.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.shortest_paths.astar\n.. autosummary::\n   :toctree: generated/\n\n   astar_path\n   astar_path_length\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX Without Required Dependencies via pip - Bash/Shell\nDESCRIPTION: This snippet installs only the NetworkX core package without pulling in optional dependencies like numpy or scipy. This option is beneficial for minimal installations, or when the user does not require third-party extensions and wishes to avoid unnecessary dependencies. Requires pip, Python, and may have limited functionality compared to the full installation.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install networkx\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXError Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXError` class, a specific exception type within the NetworkX library. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXError\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Dense Graph Shortest Path Functions (reStructuredText)\nDESCRIPTION: This reStructuredText snippet utilizes Sphinx directives to generate documentation for shortest path algorithms optimized for dense graphs, specifically the Floyd-Warshall algorithm, found in `networkx.algorithms.shortest_paths.dense`. It includes functions for the core algorithm, predecessor/distance calculation, a NumPy-based version, and path reconstruction, placing results in 'generated/'.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/shortest_paths.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.shortest_paths.dense\n.. autosummary::\n   :toctree: generated/\n\n   floyd_warshall\n   floyd_warshall_predecessor_and_distance\n   floyd_warshall_numpy\n   reconstruct_path\n```\n\n----------------------------------------\n\nTITLE: Attempting Slice Notation on Python dict_values Object\nDESCRIPTION: Shows the standard Python behavior when attempting to slice the dict_values view from a dictionary, resulting in a TypeError. Also demonstrates proper slicing by first converting the dict_values view to a list. This is used as a precedent for the decision not to add slicing directly to NetworkX view objects. There are no external dependencies except Python 3.6+ with standard dict behavior.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0002.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> d = {k:v for k, v in zip(range(10), range(10))}\n>>> d.values()[3:6]\nTraceback (most recent call last)\n   ...\nTypeError: 'dict_values' object is not subscriptable\n>>> list(d.values())[3:6]\n[3, 4, 5]\n```\n\n----------------------------------------\n\nTITLE: Adding Resolved Files after Merge Conflict using Git\nDESCRIPTION: This Git command stages a file ('file_with_conflict.txt') after its merge conflicts have been manually resolved. Staging the file marks it as ready for the next commit, which will finalize the merge.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ngit add file_with_conflict.txt\n```\n\n----------------------------------------\n\nTITLE: Generating a Deprecation Warning in Python\nDESCRIPTION: This Python code snippet demonstrates how to issue a `DeprecationWarning` using the `warnings` module. It defines a message informing the user about the deprecated function, its replacement, and the version when it will be removed.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmsg = \"curly_hair is deprecated and will be removed in v3.0. Use sum() instead.\"\nwarnings.warn(msg, DeprecationWarning)\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXNoCycle Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXNoCycle` exception class, raised when cycle-finding algorithms do not detect any cycles. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXNoCycle\n```\n\n----------------------------------------\n\nTITLE: Importing and Summarizing the Planar Drawing Module (Sphinx/rst)\nDESCRIPTION: This snippet uses Sphinx's reStructuredText directives to automatically document the `networkx.algorithms.planar_drawing` Python module. The `automodule` directive imports the module for documentation generation, and `autosummary` creates a summary table linking to the documentation of specified functions, in this case, `combinatorial_embedding_to_pos`. The `:toctree: generated/` option directs Sphinx to place the generated function documentation files within the `generated/` subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/planar_drawing.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.planar_drawing\n.. autosummary::\n   :toctree: generated/\n\n   combinatorial_embedding_to_pos\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXUnfeasible Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXUnfeasible` exception class, likely raised when an algorithm determines a solution is not possible. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXUnfeasible\n```\n\n----------------------------------------\n\nTITLE: Generating Shortest Augmenting Path Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Shortest Augmenting Path algorithm function (`shortest_augmenting_path`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   shortest_augmenting_path\n```\n\n----------------------------------------\n\nTITLE: Generating Dinitz Algorithm Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Dinitz algorithm function (`dinitz`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   dinitz\n```\n\n----------------------------------------\n\nTITLE: Using head() on NodeView in NetworkX Python\nDESCRIPTION: Demonstrates the invocation of the proposed head() method on a NetworkX NodeView to retrieve the first n nodes from a graph. No external dependencies are shown besides standard NetworkX usage. The head method is hypothetical in this context and is intended to provide a convenient shorthand for viewing a subset of nodes without converting the NodeView to a list. Input is the number of nodes desired, and output is a NodeView containing the sliced nodes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0002.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> G = nx.path_graph(10)\n>>> G.nodes()\nNodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))\n>>> G.nodes().head(3)   # Display the first three nodes\nNodeView((0, 1, 2))\n```\n\n----------------------------------------\n\nTITLE: Checking Git Status for Merge Conflicts\nDESCRIPTION: This Git command displays the current status of the working directory and staging area. It is particularly useful after a merge attempt to identify files that have merge conflicts and need manual resolution.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n```\n\n----------------------------------------\n\nTITLE: Finding Function Source File using IPython Help (IPython)\nDESCRIPTION: Shows how to use the IPython interactive shell's help feature ('?') to locate the source file definition of a NetworkX function ('nx.kamada_kawai_layout'). The command sequence first imports the networkx library and then appends '?' to the function name to display its documentation and location.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/new_contributor_faq.rst#_snippet_2\n\nLANGUAGE: ipython3\nCODE:\n```\nIn [1]: import networkx as nx\nIn [2]: nx.kamada_kawai_layout?\n```\n\n----------------------------------------\n\nTITLE: Documenting Chains Module Using Sphinx Directives - reStructuredText\nDESCRIPTION: This snippet uses Sphinx reStructuredText directives (:automodule: and :autosummary:) to document the networkx.algorithms.chains module and summarize its available functions. The :toctree: option organizes the generated documentation, while 'chain_decomposition' is listed for summary generation. Prerequisite: Sphinx must be set up in the documentation build environment, and networkx.algorithms.chains must be importable. Inputs are reStructuredText directives; the output is generated HTML documentation for project use.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/chains.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\nChains\n======\n\n.. automodule:: networkx.algorithms.chains\n.. autosummary::\n   :toctree: generated/\n\n   chain_decomposition\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Test Suite using Pytest\nDESCRIPTION: This command runs the NetworkX test suite using pytest. The `PYTHONPATH=.` part ensures that the local, editable version of NetworkX is imported during the tests. Running tests locally helps catch issues before submitting a pull request.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nPYTHONPATH=. pytest networkx\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation for NetworkX Multi-Graph Operators (reStructuredText)\nDESCRIPTION: Uses Sphinx `automodule` and `autosummary` directives to generate documentation for operators designed to work with multiple graphs simultaneously (`compose_all`, `union_all`, `disjoint_union_all`, `intersection_all`) located in the `networkx.algorithms.operators.all` Python module. The `:toctree: generated/` option ensures separate documentation pages are created for each function within the 'generated' subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/operators.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.operators.all\n.. autosummary::\n   :toctree: generated/\n\n   compose_all\n   union_all\n   disjoint_union_all\n   intersection_all\n```\n\n----------------------------------------\n\nTITLE: Generating a Summary Table for distance_regular Functions in Sphinx\nDESCRIPTION: This Sphinx `autosummary` directive, combined with the `:toctree:` option, creates a summary table listing the specified functions (`is_distance_regular`, `is_strongly_regular`, `intersection_array`, `global_parameters`) from the `networkx.algorithms.distance_regular` module. It generates individual pages for each function's documentation within the `generated/` directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/distance_regular.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   is_distance_regular\n   is_strongly_regular\n   intersection_array\n   global_parameters\n```\n\n----------------------------------------\n\nTITLE: Running Pre-commit Linters on All Files\nDESCRIPTION: This command manually triggers the pre-commit hooks to run on all files in the repository. This can be useful if the automatic hooks failed or if you want to ensure the entire codebase adheres to the configured linting standards.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Including immediate_dominators in Sphinx Autosummary using reStructuredText\nDESCRIPTION: This line, indented under an `autosummary` directive in reStructuredText, specifies that the `immediate_dominators` function (part of the `networkx.algorithms.dominance` module targeted by `automodule`) should be included in the generated summary table and have its own documentation page created.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/dominance.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n   immediate_dominators\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for NetworkX Graphical Module (reStructuredText)\nDESCRIPTION: This snippet uses Sphinx reStructuredText directives to automatically generate documentation for the `networkx.algorithms.graphical` Python module. `automodule` imports the module documentation, and `autosummary` creates a table linking to the documentation of specific functions within that module, intended for checking graphical degree sequences.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/graphical.rst#_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. automodule:: networkx.algorithms.graphical\n.. autosummary::\n   :toctree: generated/\n\n   is_graphical\n   is_digraphical\n   is_multigraphical\n   is_pseudographical\n   is_valid_degree_sequence_havel_hakimi\n   is_valid_degree_sequence_erdos_gallai\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Deprecation Warnings in Pytest Configuration\nDESCRIPTION: This Python code snippet, intended for `networkx/conftest.py`, shows how to use `warnings.filterwarnings` to ignore specific `DeprecationWarning` messages during tests. This prevents tests from failing due to expected deprecation warnings.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nwarnings.filterwarnings(\n    \"ignore\", category=DeprecationWarning, message=<start of message>\n)\n```\n\n----------------------------------------\n\nTITLE: Generating a Function Summary Table using Sphinx Autosummary (reStructuredText)\nDESCRIPTION: This reStructuredText directive, along with its options (`:toctree: generated/`) and content (list of function names), instructs Sphinx to create a summary table linking to the documentation of the listed Python functions (`read_adjlist`, `write_adjlist`, `parse_adjlist`, `generate_adjlist`) within the `networkx.readwrite.adjlist` module. The `:toctree:` option generates individual stub files for each function's documentation in the specified directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/adjlist.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   read_adjlist\n   write_adjlist\n   parse_adjlist\n   generate_adjlist\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodocumentation for NetworkX Moral Module (reStructuredText)\nDESCRIPTION: This snippet uses Sphinx reStructuredText directives to automatically generate documentation. `automodule` imports documentation from the specified Python module (`networkx.algorithms.moral`), and `autosummary` creates a summary table linking to the documentation of listed items (here, `moral_graph`), placing generated files in the `generated/` subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/moral.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n*****\nMoral\n*****\n\n.. automodule:: networkx.algorithms.moral\n.. autosummary::\n   :toctree: generated/\n\n   moral_graph\n```\n\n----------------------------------------\n\nTITLE: Installing Development Version of NetworkX Editable - Bash/Shell\nDESCRIPTION: After cloning the repository, this snippet installs NetworkX in 'editable' mode using pip, enabling link-based development. The -e flag allows immediate propagation of source code changes to the installed package. Requires pip, Python, and developer permissions.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install -e .[default]\n```\n\n----------------------------------------\n\nTITLE: Automodule and Autosummary Usage for Python Reference Documentation - reStructuredText\nDESCRIPTION: This snippet utilizes Sphinx directives to automatically document all public classes and functions from the networkx.algorithms.boundary submodule. The .. automodule:: directive imports docstrings and signatures from boundary.py, while the .. autosummary:: block with the :toctree: directive configures autogeneration of individual pages for the edge_boundary and node_boundary functions. There are no code dependencies, but Sphinx with autodoc and autosummary extensions are required. The output populates HTML (or other formats) reference documentation with auto-generated API details for users.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/boundary.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: networkx.algorithms.boundary\n.. autosummary::\n   :toctree: generated/\n\n   edge_boundary\n   node_boundary\n```\n\n----------------------------------------\n\nTITLE: Importing a Python Module for Sphinx Autodoc using reStructuredText\nDESCRIPTION: This reStructuredText directive (`automodule`) instructs Sphinx, a documentation generator, to automatically document the Python module located at `networkx.algorithms.dominance`. Sphinx will pull documentation primarily from the module's docstrings.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/dominance.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.dominance\n```\n\n----------------------------------------\n\nTITLE: Installing Extra and Example Gallery Dependencies with pip (Python, Shell)\nDESCRIPTION: Installs additional dependencies required for building the example gallery in the NetworkX documentation using two separate requirements files: 'requirements/extra.txt' and 'requirements/example.txt'. These commands should be executed from the project root directory before generating documentation that includes figures or example galleries. They take the respective requirements files as input, ensuring that all necessary optional packages are available. Failure to install these dependencies may prevent gallery examples or plots from being generated in the documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/README.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements/extra.txt\n```\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements/example.txt\n```\n\n----------------------------------------\n\nTITLE: Documenting Greedy and Equitable Coloring Algorithms (reStructuredText)\nDESCRIPTION: This snippet sets up Sphinx-generated documentation for the NetworkX coloring algorithms, using directives like '.. automodule::' to import docstrings, and '.. autosummary::' to auto-generate summary tables and links for functions like greedy_color and equitable_color. It introduces anchor references and lists node ordering strategies for greedy coloring. No direct code execution occurs; instead, the focus is on organizing API-level documentation for use in building HTML or other doc outputs. Primary dependencies: Sphinx, NetworkX documentation standards. Inputs are function and strategy names; outputs are the generated navigation and summaries in the built documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/coloring.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _networkx.algorithms.coloring.greedy_coloring:\n.. _networkx.algorithms.coloring.equitable_coloring:\n\n********\nColoring\n********\n\n.. automodule:: networkx.algorithms.coloring\n.. autosummary::\n   :toctree: generated/\n\n   greedy_color\n   equitable_color\n\nSome node ordering strategies are provided for use with :func:`greedy_color`.\n\n.. autosummary::\n   :toctree: generated/\n\n    strategy_connected_sequential\n    strategy_connected_sequential_dfs\n    strategy_connected_sequential_bfs\n    strategy_independent_set\n    strategy_largest_first\n    strategy_random_sequential\n    strategy_saturation_largest_first\n    strategy_smallest_last\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodocumentation for NetworkX Rich Club Module\nDESCRIPTION: This snippet uses reStructuredText directives for Sphinx. `automodule` imports documentation from the specified Python module (`networkx.algorithms.richclub`). `autosummary` creates a summary table linking to the documentation of the listed function (`rich_club_coefficient`), placing generated files in the `generated/` directory relative to the documentation root.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/rich_club.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.richclub\n.. autosummary::\n   :toctree: generated/\n\n   rich_club_coefficient\n```\n\n----------------------------------------\n\nTITLE: Defining Backend Function Metadata in Python\nDESCRIPTION: Example structure of the 'additional_parameters' dictionary within the 'functions' mapping for a NetworkX backend interface. This dictionary provides metadata about extra parameters accepted by the backend implementation of a function, used for generating documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n\"additional_parameters\": {\n    'param1 : str, function (default = \\\"chunks\\\")' : \"...\",\n    'param2 : int' : \"...\",\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NetworkX from Source Directory via pip - Bash/Shell\nDESCRIPTION: This snippet shows how to install NetworkX from a manually downloaded and unpacked source archive by running pip from its top-level directory. The .[default] notation installs required extras, and this command allows for custom or offline installations.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install .[default]\n```\n\n----------------------------------------\n\nTITLE: Documenting Traversal Algorithms - reStructuredText\nDESCRIPTION: This snippet structures the main traversal documentation for NetworkX, using Sphinx reStructuredText directives to organize references for depth-first, breadth-first, and beam search algorithms, as well as edge-based traversals. Dependencies include Sphinx and NetworkX documentation generation tools. The file contains module listings and function summary tables that do not take direct inputs but guide the documentation build process, outputting a navigable set of reference pages for end users.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/traversal.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _traversal:\n\nTraversal\n=========\n\n.. toctree::\n   :maxdepth: 2\n\n\n\nDepth First Search\n------------------\n.. automodule:: networkx.algorithms.traversal.depth_first_search\n.. autosummary::\n   :toctree: generated/\n\n   dfs_edges\n   dfs_tree\n   dfs_predecessors\n   dfs_successors\n   dfs_preorder_nodes\n   dfs_postorder_nodes\n   dfs_labeled_edges\n\nBreadth First Search\n--------------------\n.. automodule:: networkx.algorithms.traversal.breadth_first_search\n.. autosummary::\n   :toctree: generated/\n\n   bfs_edges\n   bfs_layers\n   bfs_tree\n   bfs_predecessors\n   bfs_successors\n   descendants_at_distance\n   generic_bfs_edges\n\nBeam search\n-----------\n.. automodule:: networkx.algorithms.traversal.beamsearch\n.. autosummary::\n   :toctree: generated/\n\n   bfs_beam_edges\n\n\nDepth First Search on Edges\n---------------------------\n.. automodule:: networkx.algorithms.traversal.edgedfs\n.. autosummary::\n   :toctree: generated/\n\n   edge_dfs\n\nBreadth First Search on Edges\n-----------------------------\n.. automodule:: networkx.algorithms.traversal.edgebfs\n.. autosummary::\n   :toctree: generated/\n\n   edge_bfs\n```\n\n----------------------------------------\n\nTITLE: Explicitly Installing All Optional Packages via pip - Bash/Shell\nDESCRIPTION: This command installs the extra optional dependencies individually, useful if selective installation or troubleshooting is required. It installs pygraphviz, pydot, and lxml, which add graph drawing and XML parsing features to NetworkX. Some packages may require compilation tools.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install pygraphviz pydot lxml\n```\n\n----------------------------------------\n\nTITLE: Documenting ExceededMaxIterations Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.ExceededMaxIterations` exception class, raised by iterative algorithms that fail to converge within a specified number of iterations. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_14\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.ExceededMaxIterations\n```\n\n----------------------------------------\n\nTITLE: Uninstalling NetworkX via pip - Bash/Shell\nDESCRIPTION: Before installing the development version, this command removes the existing stable installation of NetworkX. It uses pip's uninstall operation, which interactsively confirms the removal before deleting binaries and Python files.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ pip uninstall networkx\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodocumentation for networkx.readwrite.gexf\nDESCRIPTION: This snippet uses Sphinx reStructuredText directives to set up automatic documentation generation. `.. automodule::` targets the specified Python module (`networkx.readwrite.gexf`), instructing Sphinx to pull documentation from its docstrings. `.. autosummary::` creates a summary table for the listed functions, and `:toctree: generated/` ensures that pages generated for each function are linked in the table of contents located in the 'generated/' subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/gexf.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.readwrite.gexf\n.. autosummary::\n   :toctree: generated/\n\n   read_gexf\n   write_gexf\n   generate_gexf\n   relabel_gexf_graph\n```\n\n----------------------------------------\n\nTITLE: Reference to NetworkX make_list_of_ints Function\nDESCRIPTION: This mentions 'networkx.utils.misc.make_list_of_ints' as functionality related to the deprecated 'networkx.utils.misc.is_list_of_ints'. The 'make_list_of_ints' function likely takes an input and attempts to convert it into a list of integers.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnetworkx.utils.misc.make_list_of_ints\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Generic Shortest Path Functions (reStructuredText)\nDESCRIPTION: This reStructuredText snippet uses Sphinx directives to automatically generate documentation for generic shortest path functions found in the `networkx.algorithms.shortest_paths.generic` module. It includes functions like `shortest_path`, `all_shortest_paths`, `shortest_path_length`, etc., and organizes the generated documentation under the 'generated/' directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/shortest_paths.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.shortest_paths.generic\n.. autosummary::\n   :toctree: generated/\n\n   shortest_path\n   all_shortest_paths\n   all_pairs_all_shortest_paths\n   single_source_all_shortest_paths\n   shortest_path_length\n   average_shortest_path_length\n   has_path\n```\n\n----------------------------------------\n\nTITLE: Implementing the Proposed `@graph_builder` Decorator (Partial) in Python\nDESCRIPTION: Shows the initial definition of the proposed `@graph_builder` decorator implementation in Python. It takes a function `f` (expected to return a fully constructed NetworkX graph object) and uses `@wraps(f)` to preserve metadata. It defines an inner function `edgelist` which is intended to eventually yield the graph sequence derived from the graph returned by `f`. The provided snippet is incomplete. Requires `functools.wraps` and likely NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0003.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef graph_builder(f):\n    @wraps(f)\n    def edgelist(*args, **kwargs):\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Unweighted Shortest Path Functions (reStructuredText)\nDESCRIPTION: This reStructuredText snippet uses Sphinx directives to automatically generate documentation for unweighted shortest path algorithms (like BFS) from the `networkx.algorithms.shortest_paths.unweighted` module. It lists functions for single-source, single-target, bidirectional, and all-pairs paths, placing the generated documentation in the 'generated/' directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/shortest_paths.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.shortest_paths.unweighted\n.. autosummary::\n   :toctree: generated/\n\n   single_source_shortest_path\n   single_source_shortest_path_length\n   single_target_shortest_path\n   single_target_shortest_path_length\n   bidirectional_shortest_path\n   all_pairs_shortest_path\n   all_pairs_shortest_path_length\n   predecessor\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Weighted Shortest Path Functions (reStructuredText)\nDESCRIPTION: This reStructuredText snippet employs Sphinx directives to create documentation for weighted shortest path algorithms (Dijkstra, Bellman-Ford, Johnson, etc.) located in `networkx.algorithms.shortest_paths.weighted`. It covers various algorithm variations (single-source, multi-source, all-pairs) and negative cycle detection, storing the output in the 'generated/' directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/shortest_paths.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.shortest_paths.weighted\n.. autosummary::\n   :toctree: generated/\n\n   dijkstra_predecessor_and_distance\n   dijkstra_path\n   dijkstra_path_length\n   single_source_dijkstra\n   single_source_dijkstra_path\n   single_source_dijkstra_path_length\n   multi_source_dijkstra\n   multi_source_dijkstra_path\n   multi_source_dijkstra_path_length\n   all_pairs_dijkstra\n   all_pairs_dijkstra_path\n   all_pairs_dijkstra_path_length\n   bidirectional_dijkstra\n\n   bellman_ford_path\n   bellman_ford_path_length\n   single_source_bellman_ford\n   single_source_bellman_ford_path\n   single_source_bellman_ford_path_length\n   all_pairs_bellman_ford_path\n   all_pairs_bellman_ford_path_length\n   bellman_ford_predecessor_and_distance\n\n   negative_edge_cycle\n   find_negative_cycle\n   goldberg_radzik\n   johnson\n```\n\n----------------------------------------\n\nTITLE: Including External File Content in reStructuredText\nDESCRIPTION: This reStructuredText directive `.. include::` is used to insert the content of an external file (`../INSTALL.rst`) into the current document during processing. It references a file relative to the current document's location. This specific usage likely pulls in standard installation instructions for the NetworkX library.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/install.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../INSTALL.rst\n```\n\n----------------------------------------\n\nTITLE: Checking Proposed RNG Type with Integer Seed (Python)\nDESCRIPTION: Following the proposed change in NXEP 4, this snippet shows that passing an integer seed to a function decorated with `@np_random_state` would also result in the creation and use of a `numpy.random.Generator` instance.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0004.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> type(foo(12345))\nnumpy.random._generator.Generator\n```\n\n----------------------------------------\n\nTITLE: Including External File Content using reStructuredText Include Directive\nDESCRIPTION: This reStructuredText directive includes the content of the file specified by the relative path '../../CONTRIBUTING.rst'. It's used in Sphinx (a common documentation generator for Python projects) to incorporate content from other files directly into the current document during the build process. This ensures consistency for frequently used content like contribution guidelines.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/contribute.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../../CONTRIBUTING.rst\n```\n\n----------------------------------------\n\nTITLE: Referencing the Eigenvalues Example Script (Python)\nDESCRIPTION: Points to the example script `Examples/eigenvalues.py`, added around version 0.22, that shows how to compute eigenvalues of a graph's Laplacian matrix using NetworkX and potentially other libraries like NumPy/SciPy.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nExamples/eigenvalues.py\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Tests via setup_egg.py (Bash)\nDESCRIPTION: Command-line instruction to execute the NetworkX test suite using `setup_egg.py`. This method requires the `setuptools` package to be installed. It is mentioned as an alternative way to run tests in the NetworkX 0.34 release notes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython setup_egg.py test\n```\n\n----------------------------------------\n\nTITLE: Registering a NetworkX Backend Entry Point - TOML\nDESCRIPTION: Provides a TOML-formatted example for registering a backend with NetworkX by adding an entry-point in a Python package's 'pyproject.toml' metadata. The '[project.entry-points.\"networkx.backends\"]' section defines a backend name mapped to the import path for the backend interface object. No actual executable code; instead, this is metadata for the Python packaging system. Only useful when constructing or distributing a custom backend package.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/backends.rst#_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[project.entry-points.\"networkx.backends\"]\\nbackend_name = \"your_backend_interface_object\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Deprecations in RST for Removal\nDESCRIPTION: This reStructuredText (RST) code block shows an example entry for `doc/developer/deprecations.rst`. It serves as a reminder for developers to remove the specified deprecated function (`generate_unique_node`) and its related tests in a future release.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_12\n\nLANGUAGE: rst\nCODE:\n```\n* In ``utils/misc.py`` remove ``generate_unique_node`` and related tests.\n```\n\n----------------------------------------\n\nTITLE: Deprecating Specific NetworkX PageRank Implementations\nDESCRIPTION: The separate NumPy ('pagerank_numpy') and SciPy ('pagerank_scipy') implementations of the PageRank algorithm in NetworkX are deprecated. Users should now use the unified 'networkx.pagerank' function, which likely selects the appropriate backend automatically or via parameters.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npagerank_numpy\n```\n\nLANGUAGE: python\nCODE:\n```\npagerank_scipy\n```\n\n----------------------------------------\n\nTITLE: Generating Function Summary Table with Sphinx autosummary (reStructuredText)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autosummary` feature to create a table listing specific functions from the current module (`networkx.algorithms.tournament`). The `:toctree: generated/` option ensures that separate documentation pages are generated for each listed item within the 'generated' subdirectory and linked from the summary table. This provides a quick overview and navigation for the module's API.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/tournament.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   hamiltonian_path\n   is_reachable\n   is_strongly_connected\n   is_tournament\n   random_tournament\n   score_sequence\n   tournament_matrix\n```\n\n----------------------------------------\n\nTITLE: Importing All NetworkX Contents into Namespace (Python)\nDESCRIPTION: Demonstrates importing all functions and classes from the NetworkX library directly into the current namespace using `from networkx import *`. While mentioned as an option in version 0.23, this approach is generally discouraged due to potential namespace pollution.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom networkx import *\n```\n\n----------------------------------------\n\nTITLE: Building HTML Documentation Without Plots with Sphinx Makefile (Makefile)\nDESCRIPTION: Builds the HTML documentation for NetworkX without generating figures or plots by running 'make html-noplot' from the 'doc/' directory. This is useful if the optional dependencies for plotting and examples are not installed. The command outputs the documentation (minus generated figures) to the appropriate build directory. Absence of extra dependencies is tolerated for this operation; produced documentation will not include gallery figures.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/README.rst#_snippet_3\n\nLANGUAGE: makefile\nCODE:\n```\nmake html-noplot\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting the distance_regular Module in Sphinx\nDESCRIPTION: This Sphinx directive instructs the documentation generator to automatically pull documentation from the specified Python module `networkx.algorithms.distance_regular`. It includes docstrings and signatures from the module.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/distance_regular.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.distance_regular\n```\n\n----------------------------------------\n\nTITLE: Generating Preflow-Push Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Preflow-Push algorithm function (`preflow_push`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   preflow_push\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXException Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXException` class. It pulls the class's docstring, signature, and potentially documentation for its methods and attributes, formatting them into the output documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXException\n```\n\n----------------------------------------\n\nTITLE: Auto-Documenting a Python Module using Sphinx Automodule (reStructuredText)\nDESCRIPTION: This reStructuredText directive instructs the Sphinx documentation generator to automatically pull documentation from the specified Python module (`networkx.readwrite.adjlist`). It's used within Sphinx configuration files or reStructuredText documents to incorporate docstrings and signatures from the module.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/readwrite/adjlist.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.readwrite.adjlist\n```\n\n----------------------------------------\n\nTITLE: Documenting Threshold Graph Algorithms in reStructuredText\nDESCRIPTION: This snippet utilizes reStructuredText directives to build documentation for threshold graph methods in the NetworkX Python library. Key directives include automodule (documenting the threshold module) and autosummary (listing and generating summaries for documented functions). The snippet assumes Sphinx or a similar documentation generator is being used to interpret these directives, and the referenced Python functions (find_threshold_graph, is_threshold_graph) are public and documented in the threshold module. The expected output is rendered HTML or other readable documentation, with no code execution.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/threshold.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n****************\nThreshold Graphs\n****************\n\n.. automodule:: networkx.algorithms.threshold\n.. autosummary::\n   :toctree: generated/\n\n   find_threshold_graph\n   is_threshold_graph\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation for NetworkX Unary Operators (reStructuredText)\nDESCRIPTION: Uses Sphinx `automodule` and `autosummary` directives to generate documentation for unary graph operators (`complement`, `reverse`) found in the `networkx.algorithms.operators.unary` Python module. The `:toctree: generated/` option within `autosummary` instructs Sphinx to create individual pages for each listed function within a 'generated' subdirectory relative to the current file.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/operators.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.operators.unary\n.. autosummary::\n   :toctree: generated/\n\n   complement\n   reverse\n```\n\n----------------------------------------\n\nTITLE: Deprecated Graph Copy Method in NetworkX (Python)\nDESCRIPTION: The `G.fresh_copy()` method, previously used in NetworkX to create an empty graph of the same type as graph `G`, has been deprecated in version 2.3 due to compatibility issues (e.g., with pickling). It is recommended to use `G.__class__()` instead.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.3.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nG.fresh_copy()\n```\n\n----------------------------------------\n\nTITLE: Generating a Summary Table with Links for Specific NetworkX Functions using Sphinx\nDESCRIPTION: This Sphinx `autosummary` directive generates a summary table for the listed items (`tutte_polynomial`, `chromatic_polynomial`). The `:toctree: generated/` option instructs Sphinx to create separate documentation pages (stubs) for each item within the `generated/` subdirectory and link to them from the table. This requires Sphinx and relies on the listed functions being properly documented elsewhere in the project.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/polynomials.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   tutte_polynomial\n   chromatic_polynomial\n```\n\n----------------------------------------\n\nTITLE: Deprecating Order Parameter in NetworkX to_pandas_edgelist\nDESCRIPTION: The 'order' parameter within the NetworkX function 'to_pandas_edgelist' is deprecated as it was unused. This function converts graph edges into a Pandas DataFrame.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\norder\n```\n\n----------------------------------------\n\nTITLE: Building PDF Documentation with LaTeX via Sphinx (Makefile)\nDESCRIPTION: Generates a PDF version of the NetworkX documentation by running 'make latexpdf' (typically from within the 'doc/' directory). Requires LaTeX to be pre-installed on the system. The command compiles the documentation source to LaTeX and then to PDF, producing a complete, printable manual. Missing LaTeX installation will cause build failures; all Sphinx and documentation dependencies must be satisfied for successful output.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/README.rst#_snippet_4\n\nLANGUAGE: makefile\nCODE:\n```\nmake latexpdf\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Shapefile I/O Functions\nDESCRIPTION: The NetworkX functions 'read_shp' (for reading graph data from ESRI Shapefiles), 'edges_from_line' (likely for converting line geometries to edges), and 'write_shp' (for writing graph data to Shapefiles) are deprecated. Users needing Shapefile support should look for alternative geospatial libraries or methods.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nread_shp\n```\n\nLANGUAGE: python\nCODE:\n```\nedges_from_line\n```\n\nLANGUAGE: python\nCODE:\n```\nwrite_shp\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Graph Assertion Utilities\nDESCRIPTION: The NetworkX testing utility functions 'assert_nodes_equal', 'assert_edges_equal', and 'assert_graphs_equal' are deprecated. Users writing tests involving NetworkX graphs should use alternative assertion methods or libraries.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nassert_nodes_equal\n```\n\nLANGUAGE: python\nCODE:\n```\nassert_edges_equal\n```\n\nLANGUAGE: python\nCODE:\n```\nassert_graphs_equal\n```\n\n----------------------------------------\n\nTITLE: Deprecating Copy Method in NetworkX Filtered Views\nDESCRIPTION: The 'copy' method available on NetworkX's coreview Filtered-related classes (e.g., FilteredGraph, FilteredNodes) is deprecated. Users should use alternative methods to create copies of filtered graph views if needed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncopy\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX numeric_mixing_matrix Function\nDESCRIPTION: The NetworkX function 'numeric_mixing_matrix', used for calculating the mixing matrix for nodes with numeric attributes (often used in assortativity calculations), is deprecated. Users should refer to updated assortativity functions or calculate mixing matrices manually if needed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nnumeric_mixing_matrix\n```\n\n----------------------------------------\n\nTITLE: Running All NetworkX Benchmarks on Current HEAD (Shell)\nDESCRIPTION: Executes the entire NetworkX benchmark suite using the `asv run` command. This command benchmarks the code at the current HEAD commit.\nSOURCE: https://github.com/networkx/networkx/blob/main/benchmarks/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nasv run\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Ordered Graph Classes\nDESCRIPTION: The 'Ordered' graph classes in NetworkX (like OrderedGraph, OrderedDiGraph) are deprecated. Since standard Python dictionaries maintain insertion order (Python 3.7+), these specialized classes are no longer necessary. Users should use the standard Graph, DiGraph, etc., classes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nOrdered\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for Structural Holes Algorithms - Sphinx/reStructuredText\nDESCRIPTION: This snippet uses Sphinx automodule and autosummary directives in reStructuredText to document specific functions from networkx.algorithms.structuralholes. It lists and links to the constraint, effective_size, and local_constraint functions, enabling automated API documentation generation. Requires Sphinx and assumes a Python environment where NetworkX is installed; input is used within Sphinx documentation workflows and outputs HTML or other documentation formats. Note that this does not execute code but serves as a documentation template.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/structuralholes.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n****************\nStructural holes\n****************\n\n.. automodule:: networkx.algorithms.structuralholes\n.. autosummary::\n   :toctree: generated/\n\n   constraint\n   effective_size\n   local_constraint\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX generate_unique_node Function\nDESCRIPTION: The NetworkX utility function 'generate_unique_node' is deprecated. This function was used to create node labels guaranteed to be unique within the context of a graph.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ngenerate_unique_node\n```\n\n----------------------------------------\n\nTITLE: Running Specific Benchmark Class (Algorithms) Between Commits (Shell)\nDESCRIPTION: Executes the `asv continuous` command, but limits the run to only the benchmarks defined in the `AlgorithmBenchmarks` class using the `--bench` flag. Compares performance between the specified commits (`<sha1>` and `<sha2>`). Replace placeholders with actual commit SHAs.\nSOURCE: https://github.com/networkx/networkx/blob/main/benchmarks/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nasv continuous --bench AlgorithmBenchmarks <sha1> <sha2>\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Consume Utility\nDESCRIPTION: The NetworkX utility function 'consume' is deprecated. This function was typically used to fully exhaust an iterator without storing its yielded values, often for side effects.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nconsume\n```\n\n----------------------------------------\n\nTITLE: Automating Module Documentation for networkx.algorithms.polynomials using Sphinx\nDESCRIPTION: This Sphinx directive `automodule` automatically imports the specified Python module (`networkx.algorithms.polynomials`) and extracts its documentation (usually from the module's docstring and potentially members' docstrings, depending on options) to include in the generated output. It requires Sphinx and the target module to be available in the environment.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/polynomials.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.polynomials\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX Partition Quality Metrics\nDESCRIPTION: The NetworkX functions or parameters named 'performance' and 'coverage', likely used for evaluating the quality of graph partitions (e.g., in community detection), are deprecated. Users should use the 'partition_quality' function or metric instead.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nperformance\n```\n\nLANGUAGE: python\nCODE:\n```\ncoverage\n```\n\n----------------------------------------\n\nTITLE: Rendering Object Name Title with Underline in Jinja2\nDESCRIPTION: This Jinja2 template snippet renders the `objname` variable, escapes it for safe output, and applies an `underline` filter (likely for reStructuredText formatting) to create a heading. It depends on the `objname` variable being present in the template context and the availability of the `escape` and `underline` filters.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/_templates/autosummary/base.rst#_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{{ objname | escape | underline }}\n```\n\n----------------------------------------\n\nTITLE: Cloning Forked NetworkX Repository using Git\nDESCRIPTION: This command clones a personal fork of the NetworkX repository from GitHub to the local machine. Replace 'your-username' with the actual GitHub username. This is a standard step in the GitHub fork-and-clone workflow for contributing.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:your-username/networkx.git\n```\n\n----------------------------------------\n\nTITLE: Deprecating NetworkX default_opener Function\nDESCRIPTION: The NetworkX utility function 'default_opener', likely used as a helper for opening files (potentially handling compressed formats automatically), is deprecated. Users should handle file opening using standard Python I/O practices.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.6.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndefault_opener\n```\n\n----------------------------------------\n\nTITLE: Creating a List-Table of NetworkX Backends in MyST Markdown - Markdown\nDESCRIPTION: This snippet illustrates the use of the \\\"list-table\\\" directive in MyST Markdown for formatting a tabular list of NetworkX-compatible backends. The table includes headers and several rows, each linking to third-party backend repositories and giving succinct descriptions. Requires MyST Markdown and Sphinx for proper rendering; no runtime values, only static descriptive data about alternate backend libraries such as nx-parallel, nx-cugraph, and nx-arangodb. Outputs a structured table in documentation builds.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/backends.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```{list-table}\n:header-rows: 1\n*  - Name\n   - Description\n*  - [nx-parallel](https://github.com/networkx/nx-parallel)\n   - Parallelized implementations of various NetworkX functions using joblib\n*  - [nx-cugraph](https://rapids.ai/nx-cugraph)\n   - GPU acceleration using RAPIDS cuGraph and NVIDIA GPUs\n*  - [nx-arangodb](https://github.com/arangodb/nx-arangodb)\n   - Seamlessly adds ArangoDB as a persistence layer to NetworkX graphs\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting Hybrid Algorithms API with Sphinx reStructuredText\nDESCRIPTION: This code snippet uses Sphinx's automodule and autosummary directives to generate structured documentation for the networkx.algorithms.hybrid Python module. It lists the kl_connected_subgraph and is_kl_connected functions for targeted documentation, enabling automatic inclusion of function signatures and docstrings in the generated docs. Requires Sphinx with autodoc and autosummary extensions enabled.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/hybrid.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n******\nHybrid\n******\n\n.. automodule:: networkx.algorithms.hybrid\n.. autosummary::\n   :toctree: generated/\n\n   kl_connected_subgraph\n   is_kl_connected\n\n```\n\n----------------------------------------\n\nTITLE: Removed ReverseView Class in NetworkX (Python)\nDESCRIPTION: The `ReverseView` class, previously used for obtaining a reverse view of a graph in NetworkX, was removed in version 2.3. The `reverse_view()` function should be used as its replacement.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/release_2.3.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nReverseView\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkX Exception Module using Sphinx\nDESCRIPTION: This Sphinx directive instructs the documentation generator to automatically pull documentation from the specified Python module (`networkx.exception`). It will typically include the module's docstring and potentially documentation for its members.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.exception\n```\n\n----------------------------------------\n\nTITLE: Sphinx Directives for Asteroidal Module Documentation\nDESCRIPTION: These reStructuredText lines use Sphinx directives. `.. automodule::` imports documentation from the specified Python module (`networkx.algorithms.asteroidal`). `.. autosummary::` creates a summary table listing the specified functions (`is_at_free`, `find_asteroidal_triple`), with links to their detailed documentation generated in the `generated/` directory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/asteroidal.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n**********\nAsteroidal\n**********\n\n.. automodule:: networkx.algorithms.asteroidal\n.. autosummary::\n   :toctree: generated/\n\n   is_at_free\n   find_asteroidal_triple\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Autodocumentation Dynamically (reST/Jinja2)\nDESCRIPTION: This reStructuredText block uses Jinja2 variables to configure Sphinx dynamically. The `.. currentmodule::` directive sets the context using the `module` variable. Subsequently, `.. auto{{ objtype }}::` invokes the appropriate autodoc command (determined by `objtype`) for the specified `objname`, automating documentation generation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/_templates/autosummary/base.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: {{ module }}\\n\\n.. auto{{ objtype }}:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Including dominance_frontiers in Sphinx Autosummary using reStructuredText\nDESCRIPTION: Indented under a Sphinx `autosummary` directive, this reStructuredText line lists the `dominance_frontiers` function (from the `networkx.algorithms.dominance` module) for inclusion in the automatically generated summary table and directs Sphinx to create a separate documentation page for it.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/dominance.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n   dominance_frontiers\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation for NetworkX Binary Operators (reStructuredText)\nDESCRIPTION: Uses Sphinx `automodule` and `autosummary` directives to generate documentation for binary graph operators (like `compose`, `union`, `intersection`, `difference`, `symmetric_difference`, `full_join`) found in the `networkx.algorithms.operators.binary` Python module. The `:toctree: generated/` option directs Sphinx to create individual pages for each function in the 'generated' subdirectory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/operators.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.operators.binary\n.. autosummary::\n   :toctree: generated/\n\n   compose\n   union\n   disjoint_union\n   intersection\n   difference\n   symmetric_difference\n   full_join\n```\n\n----------------------------------------\n\nTITLE: Calculating Max Flow and Min Cut in NetworkX 1.8 (Python)\nDESCRIPTION: Shows the deprecated method for calculating maximum flow value using `nx.max_flow()` and minimum cut value using `nx.min_cut()` between nodes 0 and 6 on graph G, as done in NetworkX version 1.8. It also shows obtaining the flow dictionary using the legacy `nx.ford_fulkerson()` function. This code is marked for skipping in doctests as it represents the older API.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.9.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> flow_value = nx.max_flow(G, 0, 6)  # doctest: +SKIP\n>>> cut_value = nx.min_cut(G, 0, 6)  # doctest: +SKIP\n>>> flow_value == cut_value  # doctest: +SKIP\nTrue\n>>> flow_value, flow_dict = nx.ford_fulkerson(G, 0, 6)  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Importing NetworkX Clustering Module via Sphinx Automodule\nDESCRIPTION: This reStructuredText directive (`automodule`) instructs Sphinx to automatically import the specified Python module (`networkx.algorithms.cluster`) and extract documentation from its docstrings. It's used to generate API documentation for the entire clustering module within NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/clustering.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. automodule:: networkx.algorithms.cluster\n```\n\n----------------------------------------\n\nTITLE: Generating reStructuredText Class Documentation with Jinja2 - Jinja2\nDESCRIPTION: This snippet is a Jinja2 template for creating reStructuredText documentation for Python classes, to be processed by Sphinx. It makes use of context variables for class names and members, rendering separate method and attribute sections only if items exist. Dependencies include Sphinx configured for Python autodoc and autosummary, as well as the Jinja2 templating engine. Input context must provide class names, methods, attributes, and optional internationalization via the _() function. The output is designed to be included in Sphinx documentation builds.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/_templates/autosummary/class.rst#_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{{ fullname | escape | underline}}\n\n.. currentmodule:: {{ module }}\n\n.. autoclass:: {{ objname }}\n\n   {% block methods %}\n   .. automethod:: __init__\n\n   {% if methods %}\n   .. rubric:: {{ _('Methods') }}\n\n   .. autosummary::\n      :toctree: generated/\n\n   {% for item in methods %}\n       {% if item != \"__init__\" %}\n          ~{{ name }}.{{ item }}\n       {% endif %}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n   {% block attributes %}\n   {% if attributes %}\n   .. rubric:: {{ _('Attributes') }}\n\n   .. autosummary::\n      :toctree: generated/\n\n   {% for item in attributes %}\n      ~{{ name }}.{{ item }}\n   {%- endfor %}\n   {% endif %}\n   {% endblock %}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Capacity Scaling Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Capacity Scaling minimum cost flow algorithm function (`capacity_scaling`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_10\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n    capacity_scaling\n```\n\n----------------------------------------\n\nTITLE: Listing Removed Weighted Graph Matcher Classes in NetworkX 1.6\nDESCRIPTION: Lists the specific matcher classes for weighted graphs (Graph, DiGraph, MultiGraph, MultiDiGraph) that were removed in NetworkX 1.6. This change was part of the update to streamline isomorphism checks, replacing these classes with more flexible `node_match` and `edge_match` parameters in the `is_isomorphic` function.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/api_1.6.rst#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nWeightedGraphMatcher\nWeightedDiGraphMatcher\nWeightedMultiGraphMatcher\nWeightedMultiDiGraphMatcher\n```\n\n----------------------------------------\n\nTITLE: Generating Edmonds-Karp Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Edmonds-Karp algorithm function (`edmonds_karp`) from the NetworkX library. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   edmonds_karp\n```\n\n----------------------------------------\n\nTITLE: Generating Boykov-Kolmogorov Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for the Boykov-Kolmogorov algorithm function (`boykov_kolmogorov`) from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   boykov_kolmogorov\n```\n\n----------------------------------------\n\nTITLE: Generating Network Simplex Function Summaries (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for Network Simplex and minimum cost flow related functions (`network_simplex`, `min_cost_flow_cost`, `min_cost_flow`, `cost_of_flow`, `max_flow_min_cost`) from NetworkX. The `:toctree:` option links to detailed documentation pages.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n    network_simplex\n    min_cost_flow_cost\n    min_cost_flow\n    cost_of_flow\n    max_flow_min_cost\n```\n\n----------------------------------------\n\nTITLE: Listing Development Dependencies in Requirements Format\nDESCRIPTION: Specifies Python development dependencies (`pre-commit>=4.1`, `mypy>=1.15`) for the NetworkX project. This file is intended to be used with package managers like pip for setting up a development environment. Note the comment indicating it's auto-generated and should not be edited directly.\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/developer.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Generated via tools/generate_requirements.py and pre-commit hook.\n# Do not edit this file; modify pyproject.toml instead.\npre-commit>=4.1\nmypy>=1.15\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXAlgorithmError Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXAlgorithmError` exception class, typically raised for errors specific to algorithm execution. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXAlgorithmError\n```\n\n----------------------------------------\n\nTITLE: Generating Flow Utilities Function Summary (rst)\nDESCRIPTION: Uses the `autosummary` directive in reStructuredText to create a summary table for flow utility functions, specifically `build_residual_network`, from NetworkX. The `:toctree:` option links to its detailed documentation page.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/algorithms/flow.rst#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n.. autosummary::\n   :toctree: generated/\n\n   build_residual_network\n```\n\n----------------------------------------\n\nTITLE: Tagging the Release in Git - Git\nDESCRIPTION: This command signs and tags the current commit with the new version number, helping to demarcate official releases in the git history. GPG signing is applied for authenticity. Replace ${VERSION} with the actual release version before running.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_4\n\nLANGUAGE: git\nCODE:\n```\ngit tag -s networkx-${VERSION} -m \\\"signed ${VERSION} tag\\\"\n```\n\n----------------------------------------\n\nTITLE: Example Output of IPython Help Command (Text)\nDESCRIPTION: Illustrates the typical output format when using the IPython help command ('?') on a function. It shows the function signature (clipped), docstring (clipped), the relative or absolute path to the source file containing the definition ('File:'), and the object type ('Type:').\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/new_contributor_faq.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nSignature: <clipped for brevity>\nDocstring: <clipped for brevity>\nFile: ~/networkx/networkx/drawing/layout.py\nType: function\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXNoPath Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXNoPath` exception class, raised when algorithms searching for paths fail to find one. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXNoPath\n```\n\n----------------------------------------\n\nTITLE: Documenting HasACycle Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.HasACycle` exception class, potentially raised by algorithms that require an acyclic graph when a cycle is detected. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_10\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.HasACycle\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXUnbounded Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXUnbounded` exception class, likely related to algorithms where the solution can be infinitely large or small (e.g., shortest paths with negative cycles). It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_11\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXUnbounded\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXNotImplemented Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXNotImplemented` exception class, raised when a requested feature or algorithm combination is not available. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_12\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXNotImplemented\n```\n\n----------------------------------------\n\nTITLE: Documenting AmbiguousSolution Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.AmbiguousSolution` exception class, potentially raised when an algorithm finds multiple equally valid solutions where a single one is expected. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_13\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.AmbiguousSolution\n```\n\n----------------------------------------\n\nTITLE: Documenting PowerIterationFailedConvergence Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.PowerIterationFailedConvergence` exception class, a specific convergence error related to power iteration methods (e.g., PageRank). It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_15\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.PowerIterationFailedConvergence\n```\n\n----------------------------------------\n\nTITLE: Documenting NetworkXPointlessConcept Class using Sphinx\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `networkx.NetworkXPointlessConcept` exception class. It fetches and formats the class documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: networkx.NetworkXPointlessConcept\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Tests via Python Interpreter (Bash)\nDESCRIPTION: Command-line instruction to run the NetworkX test suite directly from the Python interpreter using the `-c` flag. This involves importing the library and calling its `test()` method. Listed as an alternative testing method in NetworkX 0.34 release notes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython -c \"import networkx; networkx.test()\"\n```\n\n----------------------------------------\n\nTITLE: Setting Release Variables - Bash\nDESCRIPTION: This Bash snippet initializes key environment variables such as VERSION, PREVIOUS, ORG, and REPO to define the scope and versioning of the release process. These variables are subsequently used in automated commands for changelog generation and documentation updates. Replace <version number> and <previous version number> with the appropriate release identifiers before running.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport VERSION=<version number>\\nexport PREVIOUS=<previous version number>\\nexport ORG=\\\"networkx\\\"\\nexport REPO=\\\"networkx\\\"\n```\n\n----------------------------------------\n\nTITLE: Running NetworkX Tests Interactively (Python)\nDESCRIPTION: Python code demonstrating how to run the NetworkX test suite from within an interactive Python session by importing the library and calling its `test()` method. The `doctest: +SKIP` comment suggests this example might be skipped during automated documentation testing. Introduced in NetworkX 0.33 release notes.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import networkx\n>>> networkx.test()  # doctest: +SKIP\n```\n\n----------------------------------------\n\nTITLE: Merging Upstream Main into Local Branch using Git\nDESCRIPTION: These Git commands first fetch the latest changes from the 'upstream' remote's 'main' branch and then merge them into the current local branch. This is done to resolve situations where a pull request branch has diverged from the target branch and cannot be merged automatically.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch upstream main\ngit merge upstream/main\n```\n\n----------------------------------------\n\nTITLE: Committing Changes after Resolving Merge Conflicts using Git\nDESCRIPTION: This Git command creates a new commit containing the changes staged after resolving merge conflicts. This typically completes the merge process initiated earlier.\nSOURCE: https://github.com/networkx/networkx/blob/main/CONTRIBUTING.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngit commit\n```\n\n----------------------------------------\n\nTITLE: Setting Notes Path for Prerelease or Release - Bash\nDESCRIPTION: These Bash commands set the NOTES environment variable to select the correct release notes file, depending on whether the new release is a prerelease or a finalized release. For finalized releases, the associated dev release notes file is also removed using git rm. Run these commands as appropriate for the release type before proceeding with subsequent steps.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport NOTES=\\\"doc/release/release_dev.rst\\\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport NOTES=\\\"doc/release/release_${VERSION}.rst\\\"\\ngit rm doc/release/release_dev.rst\n```\n\n----------------------------------------\n\nTITLE: Setting Current Module Context in Sphinx\nDESCRIPTION: This Sphinx directive sets the default module name (`networkx`) for subsequent directives like `autoclass`. This avoids having to repeatedly specify the full path for classes within this module.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/reference/exceptions.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. currentmodule:: networkx\n```\n\n----------------------------------------\n\nTITLE: Committing Version and Documentation Updates - Git\nDESCRIPTION: This Git snippet stages relevant files, including the project version, release notes, and documentation navigation data, for commit. It then commits the changes with a message indicating the release version. Run these after making all manual edits to ensure that versioning details and documentation are updated together.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_3\n\nLANGUAGE: git\nCODE:\n```\ngit add networkx/__init__.py ${NOTES} doc/_static/version_switcher.json doc/release/index.rst\\ngit commit -m \\\"Designate ${VERSION} release\\\"\n```\n\n----------------------------------------\n\nTITLE: Autogenerating Release Notes - CLI (changelist)\nDESCRIPTION: This command utilizes the changelist CLI tool to generate release notes in both reStructuredText and Markdown formats. It consumes various environment variables (ORG, REPO, PREVIOUS, VERSION, NOTES) to contextualize the release content. Ensure 'changelist' is installed and the variables are set properly; outputs are directed to specified files.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nchangelist ${ORG}/${REPO} networkx-${PREVIOUS} main --version ${VERSION} --out ${NOTES} --format rst\n```\n\nLANGUAGE: bash\nCODE:\n```\nchangelist ${ORG}/${REPO} networkx-${PREVIOUS} main --version ${VERSION} --out ${VERSION}.md\n```\n\n----------------------------------------\n\nTITLE: Defining NXEP Header Structure using reStructuredText\nDESCRIPTION: Specifies the required and optional headers for a NetworkX Enhancement Proposal (NXEP) using a reStructuredText definition list format. It includes fields like Author, Status, Type, Created, Requires, NetworkX-Version, Replaces, Replaced-By, and Resolution. Note that 'optional' applies specifically to the email addresses within the Author header; all other listed headers are mandatory.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0000.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n:Author: <list of authors' real names and optionally, email addresses>\n:Status: <Draft | Active | Accepted | Deferred | Rejected |\n         Withdrawn | Final | Superseded>\n:Type: <Standards Track | Process>\n:Created: <date created on, in dd-mmm-yyyy format>\n* :Requires: <nxep numbers>\n* :NetworkX-Version: <version number>\n* :Replaces: <nxep number>\n* :Replaced-By: <nxep number>\n* :Resolution: <url>\n```\n\n----------------------------------------\n\nTITLE: Synchronizing and Deploying Documentation - Bash and Git\nDESCRIPTION: This sequence of Bash and Git commands copies new documentation to a versioned directory, resets to the previous release, moves the new docs to the correct location, updates the 'stable' pointer, and stages and commits these changes. Caution is advised, especially around force-pushes. Replace <commit from last release> and ${VERSION} as needed.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/release.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncp -a latest ../networkx-${VERSION}\\ngit reset --hard <commit from last release>\\nmv ../networkx-${VERSION} .\\nrm -rf stable\\ncp -rf networkx-${VERSION} stable\\ngit add networkx-${VERSION} stable\\ngit commit -m \\\"Add ${VERSION} docs\\\"\\ngit push  # force push---be careful!\n```\n\n----------------------------------------\n\nTITLE: Listing Python Development/Benchmarking Dependencies (plaintext)\nDESCRIPTION: This configuration lists 'asv' (airspeed velocity) for benchmarking and 'virtualenv' for creating isolated Python environments. These are likely dependencies for the development, testing, or performance tracking setup of the associated Python project (NetworkX).\nSOURCE: https://github.com/networkx/networkx/blob/main/requirements/benchmarking.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nasv\nvirtualenv\n```\n\n----------------------------------------\n\nTITLE: Formatting NXEP Author Header without Email\nDESCRIPTION: Shows the correct format for the Author header in an NXEP when the author's email address is omitted. The format is simply 'Real Name'. Multiple authors should each be on a separate line.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0000.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nRandom J. User\n```\n\n----------------------------------------\n\nTITLE: Defining References and Links in reStructuredText for NetworkX\nDESCRIPTION: This snippet contains multiple reStructuredText directives defining footnotes and external links relevant to NetworkX development. It includes links to historical records on GitHub, NXEP documentation, the main repository, mailing list, issue tracker, pull requests, and reStructuredText/Sphinx documentation.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/developer/nxeps/nxep-0000.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. [1] This historical record is available by the normal git commands\n   for retrieving older revisions, and can also be browsed on\n   `GitHub <https://github.com/networkx/networkx/tree/main/doc/developer/nxeps>`_.\n\n.. [2] The URL for viewing NXEPs on the web is\n   https://networkx.org/documentation/latest/developer/nxeps/index.html\n\n.. _repo: https://github.com/networkx/networkx\n\n.. _mailing list: https://groups.google.com/group/networkx-discuss/\n\n.. _issue tracker: https://github.com/networkx/networkx/issues\n\n.. _`GitHub pull request`: https://github.com/networkx/networkx/pulls\n\n.. _reStructuredText: http://docutils.sourceforge.net/rst.html\n\n.. _reStructuredTextPrimer: http://www.sphinx-doc.org/en/stable/rest.html\n\n.. _Sphinx: http://www.sphinx-doc.org/en/stable/\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to networkx - Bash/Shell\nDESCRIPTION: This command switches the current shell directory to the cloned networkx repository, a prerequisite for pip install operations performed on the source directory. Ensures further commands affect the correct path.\nSOURCE: https://github.com/networkx/networkx/blob/main/INSTALL.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ cd networkx\n```\n\n----------------------------------------\n\nTITLE: Referencing the Graph Atlas Example Script (Python)\nDESCRIPTION: Mentions the example script `Examples/atlas.py`, added around version 0.22, which likely demonstrates how to generate or work with graphs from the included Atlas of Small Graphs using NetworkX.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/release/old_release_log.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nExamples/atlas.py\n```\n\n----------------------------------------\n\nTITLE: Automating Favicon Creation with Inkscape and ImageMagick - Shell Script\nDESCRIPTION: This shell script automates the process of creating a Windows-compatible favicon.ico from a source SVG image. It first downloads the SVG using wget, batch-converts it into 16x16, 32x32, and 48x48 PNG images with the inkscape CLI, and finally combines these into a multi-resolution .ico file using the convert command from ImageMagick. Dependencies required are wget (for downloading), inkscape (for SVG to PNG conversion), and ImageMagicks convert utility. Inputs are the SVG URL and output PNG/ICO file names, and output is a favicon.ico suitable for web usage. Outputs will overwrite existing files with the same name, and the script assumes all tools are available in PATH.\nSOURCE: https://github.com/networkx/networkx/blob/main/doc/_static/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwget https://raw.githubusercontent.com/networkx/branding/main/logo/networkx_favicon.svg\ninkscape -w 16 -h 16 -o 16.png networkx_favicon.svg\ninkscape -w 32 -h 32 -o 32.png networkx_favicon.svg\ninkscape -w 48 -h 48 -o 48.png networkx_favicon.svg\nconvert 16.png 32.png 48.png favicon.ico\n```"
  }
]