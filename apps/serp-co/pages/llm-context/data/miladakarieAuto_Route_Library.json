[
  {
    "owner": "milad-akarie",
    "repo": "auto_route_library",
    "content": "TITLE: Annotating a Widget with RoutePage - Dart\nDESCRIPTION: This snippet demonstrates how to annotate a widget with `@RoutePage()` to make it a routable page. This allows the router to construct the widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass HomeScreen extends StatefulWidget {}\n```\n\n----------------------------------------\n\nTITLE: Basic Route Navigation with AutoRouter in Flutter\nDESCRIPTION: This code snippet demonstrates how to use `AutoRouter` to navigate between screens in a Flutter application. It covers pushing, replacing, navigating, and popping routes using both generated `PageRouteInfo` objects and paths, including methods to manipulate the pages stack and navigate back.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\n// get the scoped router by calling\nAutoRouter.of(context);\n// or using the extension\ncontext.router;\n// adds a new entry to the pages stack\nrouter.push(const BooksListRoute());\n// or by using paths\nrouter.pushPath('/books');\n// removes last entry in stack and pushes provided route\n// if last entry == provided route page will just be updated\nrouter.replace(const BooksListRoute());\n// or by using paths\nrouter.replacePath('/books');\n// pops until provided route, if it already exists in stack\n// else adds it to the stack (good for web Apps).\nrouter.navigate(const BooksListRoute());\n// or by using paths\nrouter.navigatePath('/books');\n// on Web it calls window.history.back();\n// on Native it navigates you back\n// to the previous location\nrouter.back();\n// adds a list of routes to the pages stack at once\nrouter.pushAll([\n  BooksListRoute(),\n  BookDetailsRoute(id: 1),\n]);\n// This is like providing a completely new stack as it rebuilds the stack\n// with the list of passed routes\n// entries might just update if already exist\nrouter.replaceAll([\n  LoginRoute(),\n]);\n\n// pops the top page even if it's the last entry in stack\ncontext.router.pop()\n// pops the most top page of the most top router even if it's the last entry in stack\ncontext.router.popTop();\n\n// pops the last page unless blocked or stack has only 1 entry\ncontext.router.maybePop();\n// pops the most top page of the most top router unless blocked\n// or stack has only 1 entry\ncontext.router.maybePopTop();\n// keeps popping routes until predicate is satisfied\ncontext.router.popUntil((route) => route.settings.name == 'HomeRoute');\n// a simplified version of the above line\ncontext.router.popUntilRouteWithName('HomeRoute');\n// keeps popping routes until route with provided path is found\ncontext.router.popUntilRouteWithPath('/some-path');\n// pops all routes down to the root\ncontext.router.popUntilRoot();\n// removes the top most page in stack even if it's the last\n// remove != pop, it doesn't respect WillPopScopes it just\n// removes the entry.\ncontext.router.removeLast();\n// removes any route in stack that satisfies the predicate\n// this works exactly like removing items from a regular List\n// <PageRouteInfo>[...].removeWhere((r)=>)\ncontext.router.removeWhere((route) => );\n// you can also use the common helper methods from context extension to navigate\ncontext.pushRoute(const BooksListRoute());\ncontext.replaceRoute(const BooksListRoute());\ncontext.navigateTo(const BooksListRoute());\ncontext.navigateToPath('/books');\ncontext.back();\ncontext.maybePop();\ncontext.pop();\n```\n\n----------------------------------------\n\nTITLE: Implementing AuthGuard with AutoRouteGuard in Dart\nDESCRIPTION: This Dart code snippet demonstrates how to create a route guard by extending the `AutoRouteGuard` class from the AutoRoute package. It implements the `onNavigation` method to control route access based on authentication status. If the user is authenticated, navigation continues; otherwise, the user is redirected to the login page.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_36\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthGuard extends AutoRouteGuard {\n\n  @override\n  void onNavigation(NavigationResolver resolver, StackRouter router) {\n    // the navigation is paused until resolver.next() is called with either\n    // true to resume/continue navigation or false to abort navigation\n    if(authenticated) {\n      // if user is authenticated we continue\n      resolver.next(true);\n    } else {\n        // we redirect the user to our login page\n        // tip: use resolver.redirectUntil to have the redirected route\n        // automatically removed from the stack when the resolver is completed\n        resolver.redirectUntil(\n          LoginRoute(onResult: (success) {\n            // if success == true the navigation will be resumed\n            // else it will be aborted\n            resolver.next(success);\n          },\n        );\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning AuthGuard to a Route in Dart\nDESCRIPTION: This snippet shows how to assign a custom AuthGuard to a specific route using the AutoRoute configuration.  The guards parameter takes a list of AutoRouteGuard instances that will be executed before the route is navigated to.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_50\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  page: ProfileRoute.page,\n  guards: [AuthGuard()],\n);\n```\n\n----------------------------------------\n\nTITLE: Nested Navigation with AutoRoute in Dart\nDESCRIPTION: Demonstrates how to implement nested navigation using AutoRoute. This involves defining child routes within a parent route and using the `AutoRouter` widget as an outlet to render the nested routes.  Also shows how to define an empty shell route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(replaceInRouteName: 'Page,Route')\nclass AppRouter extends RootStackRouter {\n\n@override\nList<AutoRoute> get routes => [\n    AutoRoute(\n      path: '/dashboard',\n      page: DashboardRoute.page,\n      children: [\n        AutoRoute(path: 'users', page: UsersRoute.page),\n        AutoRoute(path: 'posts', page: PostsRoute.page),\n        AutoRoute(path: 'settings', page: SettingsRoute.page),\n      ],\n    ),\n    AutoRoute(path: '/login', page: LoginRoute.page),\n  ];\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(label: 'Users', destination: const UsersRoute()),\n            NavLink(label: 'Posts', destination: const PostsRoute()),\n            NavLink(label: 'Settings', destination: const SettingsRoute()),\n          ],\n        ),\n        Expanded(\n          // nested routes will be rendered here\n          child: AutoRouter(), // this is important\n        ),\n      ],\n    );\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    AutoRoute(path: '', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    RedirectRoute(path: '', redirectTo: 'users'),\n    AutoRoute(path: 'users', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass MyShellPage extends StatelessWidget {\n  const MyShellPage({Key? key}) : super(key: key);\n  @override\n  Widget build(BuildContext context) {\n     /// you can wrap the AutoRouter with any widget you want\n    return  AutoRouter();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass MyShellPage extends AutoRouter {\n   const MyShellPage({Key? key}) : super(key: key);  \n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nconst BooksTab = EmptyShellRoute('BooksTab');\ncontext.push(BooksTab());\n```\n\n----------------------------------------\n\nTITLE: Creating a Router Class with AutoRouterConfig - Dart\nDESCRIPTION: This snippet shows how to create a router class that extends `RootStackRouter` and is annotated with `@AutoRouterConfig`.  The `routes` getter is overridden to define the app's routes. Replace `/// routes go here` with your actual routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter {\n\n  @override\n  List<AutoRoute> get routes => [\n    /// routes go here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Path Parameters Dart\nDESCRIPTION: This snippet demonstrates how to extract path parameters by annotating constructor parameters with `@PathParam('optional-alias')`. The `bookId` parameter is annotated with `@PathParam('id')`, allowing AutoRoute to automatically inject the value from the `/books/1` URL.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_41\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@PathParam('id') this.bookId});\n\n  final int bookId;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Finalizing Setup with MaterialApp.router - Dart\nDESCRIPTION: This snippet shows how to integrate the generated router with your `MaterialApp` or `CupertinoApp` using `MaterialApp.router`.  It's crucial to avoid initializing the router inside the `build` function to prevent unnecessary rebuilds. The `routerConfig` parameter takes the generated router configuration.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n// assuming this is the root widget of your App\nclass App extends StatelessWidget {\n  // make sure you don't initiate your router\n  // inside of the build function.\n  final _appRouter = AppRouter();\n\n  @override\n  Widget build(BuildContext context){\n    return MaterialApp.router(\n      routerConfig: _appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Route Guards in Dart\nDESCRIPTION: This code snippet demonstrates how to implement global route guards by overriding the guards property inside the router class. It provides a simple guard that checks if the user is authenticated or navigating to the LoginRoute before allowing navigation.  This snippet showcases the use of AutoRouteGuard.simple for a more concise guard implementation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_51\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter{\n\n  @override\n  late final List<AutoRouteGuard> guards = [\n    AutoRouteGuard.simple((resolver, router) {\n        if(isAuthenticated || resolver.routeName == LoginRoute.name) {\n          // we continue navigation\n          resolver.next();\n        } else {\n          // else we navigate to the Login page so we get authenticated\n\n          // tip: use resolver.redirectUntil to have the redirected route\n          // automatically removed from the stack when the resolver is completed\n          resolver.redirectUntil(LoginRoute(onResult: (didLogin) => resolver.next(didLogin)));\n        }\n      },\n    ),\n    // add more guards here\n  ];\n\n// ..routes[]\n}\n```\n\n----------------------------------------\n\nTITLE: Generated PageRouteInfo - Dart\nDESCRIPTION: This snippet demonstrates the generated `PageRouteInfo` object for each `AutoRoute`. These objects encapsulate strongly-typed page arguments extracted from the page's constructor, functioning as type-safe path segments.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nclass BookListRoute extends PageRouteInfo {\n  const BookListRoute({\n    List<PagerouteInfo>? children,\n  }) : super(name, initialChildren: children);\n\n  static const String name = 'BookListRoute';\n  static const PageInfo page = PageInfo(name,builder: (...));\n}\n```\n\n----------------------------------------\n\nTITLE: Finalizing AutoRoute setup in Dart\nDESCRIPTION: Finalizes the AutoRoute setup by hooking the generated router class up with MaterialApp.router. The _appRouter should not be initiated inside the build function to avoid unnecessary re-creation of the router instance.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_8\n\nLANGUAGE: Dart\nCODE:\n```\n// assuming this is the root widget of your App\nclass App extends StatelessWidget {\n  // make sure you don't initiate your router\n  // inside of the build function.\n  final _appRouter = AppRouter();\n\n  @override\n  Widget build(BuildContext context){\n    return MaterialApp.router(\n      routerConfig: _appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Guards in Dart\nDESCRIPTION: This Dart code snippet demonstrates how to implement global route guards by overriding the `guards` property in the router class, which extends `RootStackRouter`. This ensures that all stack routes (non-tab routes) go through a list of global guards, restricting navigation based on conditions like user authentication status.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_38\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter{\n\n  @override\n  late final List<AutoRouteGuard> guards = [\n    AutoRouteGuard.simple((resolver, router) {\n        if(isAuthenticated || resolver.routeName == LoginRoute.name) {\n          // we continue navigation\n          resolver.next();\n        } else {\n          // else we navigate to the Login page so we get authenticated\n\n          // tip: use resolver.redirectUntil to have the redirected route\n          // automatically removed from the stack when the resolver is completed\n          resolver.redirectUntil(LoginRoute(onResult: (didLogin) => resolver.next(didLogin)));\n        }\n      },\n    ),\n    // add more guards here\n  ];\n\n// ..routes[]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with AutoTabsScaffold (Dart)\nDESCRIPTION: This snippet demonstrates a cleaner way to implement tab navigation using the `AutoTabsScaffold` widget in Flutter. It simplifies the setup by providing a dedicated builder for the bottom navigation bar.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsScaffold(\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      bottomNavigationBuilder: (_, tabsRouter) {\n        return BottomNavigationBar(\n          currentIndex: tabsRouter.activeIndex,\n          onTap: tabsRouter.setActiveIndex,\n          items: const [\n            BottomNavigationBarItem(label: 'Users', ...),\n            BottomNavigationBarItem(label: 'Posts', ...),\n            BottomNavigationBarItem(label: 'Settings', ...),\n          ],\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an AppRouter class in Dart\nDESCRIPTION: Creates a router class that extends RootStackRouter. This class is annotated with @AutoRouterConfig, indicating that it's the main router configuration class.  The routes getter is overridden to define the application's routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_2\n\nLANGUAGE: Dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter {\n\n  @override\n  List<AutoRoute> get routes => [\n    /// routes go here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Routes with AutoRouteWrapper in Dart\nDESCRIPTION: This Dart code snippet demonstrates how to wrap a screen with a parent widget using the `AutoRouteWrapper` interface. The `wrappedRoute` method returns the current widget as the child of the wrapper widget, allowing you to provide context values (e.g., Theme or Provider) to the route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_42\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass ProductsScreen extends StatelessWidget implements AutoRouteWrapper {\n  \n  @override\n  Widget wrappedRoute(BuildContext context) {\n    return Provider(create: (ctx) => ProductsBloc(), child: this);\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding AutoRoute dependencies via terminal\nDESCRIPTION: This command adds the necessary dependencies using flutter pub add. It includes `auto_route` as a regular dependency and `auto_route_generator` and `build_runner` as dev dependencies.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_1\n\nLANGUAGE: terminal\nCODE:\n```\nflutter pub add auto_route dev:auto_route_generator dev:build_runner\n```\n\n----------------------------------------\n\nTITLE: Running the Build Runner in Watch Mode - Terminal\nDESCRIPTION: This command runs the `build_runner` in watch mode, which automatically rebuilds the generated code whenever changes are detected in the source files. It's essential for automatically generating routes based on your AutoRoute configuration.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_4\n\nLANGUAGE: terminal\nCODE:\n```\ndart run build_runner watch\n```\n\n----------------------------------------\n\nTITLE: Implementing Tabs with AutoTabsRouter in Dart\nDESCRIPTION: This snippet shows how to use AutoTabsRouter to implement tab navigation in Flutter. It defines a DashboardPage widget that uses AutoTabsRouter to manage three child routes: UsersRoute, PostsRoute, and SettingsRoute. The transitionBuilder is used for animation between tabs, and a BottomNavigationBar is used to switch between tabs using tabsRouter.setActiveIndex.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsRouter(\n      // list of your tab routes\n      // routes used here must be declared as children\n      // routes of /dashboard\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      transitionBuilder: (context,child,animation) => FadeTransition(\n            opacity: animation,\n            // the passed child is technically our animated selected-tab page\n            child: child,\n          ),\n      builder: (context, child) {\n        // obtain the scoped TabsRouter controller using context\n        final tabsRouter = AutoTabsRouter.of(context);\n        // Here we're building our Scaffold inside of AutoTabsRouter\n        // to access the tabsRouter controller provided in this context\n        //\n        // alternatively, you could use a global key\n        return Scaffold(\n          body: child,\n          bottomNavigationBar: BottomNavigationBar(\n            currentIndex: tabsRouter.activeIndex,\n            onTap: (index) {\n              // here we switch between tabs\n              tabsRouter.setActiveIndex(index);\n            },\n            items: [\n              BottomNavigationBarItem(label: 'Users', ...),\n              BottomNavigationBarItem(label: 'Posts', ...),\n              BottomNavigationBarItem(label: 'Settings', ...),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending RootStackRouter in AutoRoute (After v9)\nDESCRIPTION: This snippet illustrates the correct way to define an `AppRouter` in v9 by extending `RootStackRouter` from the `auto_route` package directly. This is a crucial change for v9 compatibility.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter {\n\n  @override\n  List<AutoRoute> get routes => [\n    /// routes go here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Routers with a GlobalKey (Dart)\nDESCRIPTION: This snippet shows how to access an inner router from outside its scope using a `GlobalKey<AutoRouterState>`. This allows navigation within the inner router from a parent widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_29\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatefulWidget {\n  @override\n  _DashboardPageState createState() => _DashboardPageState();\n}\n\nclass _DashboardPageState extends State<DashboardPage> {\n  final _innerRouterKey = GlobalKey<AutoRouterState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(\n              label: 'Users',\n              onTap: () {\n                final router = _innerRouterKey.currentState?.controller;\n                router?.push(const UsersRoute());\n              },\n            ),\n            ...\n          ],\n        ),\n        Expanded(\n          child: AutoRouter(key: _innerRouterKey),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Results from Routes using Callback Functions in Flutter AutoRoute\nDESCRIPTION: This code snippet shows how to return results from a route using a callback function passed as an argument.  The page constructor includes a callback function which is called when popping the page. It also shows how to call this callback function before popping the page.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsRoute({this.book, required this.onRateBook});\n\n  final Book book;\n  final void Function(int) onRateBook;\n  ...\n\n```\n\nLANGUAGE: dart\nCODE:\n```\ncontext.pushRoute(\n  BookDetailsRoute(\n    book: book,\n    onRateBook: (rating) {\n      // handle result\n    },\n  ),\n);\n```\n\nLANGUAGE: dart\nCODE:\n```\nonRateBook(RESULT);\ncontext.maybePop();\n```\n\n----------------------------------------\n\nTITLE: Context-Free Router Access\nDESCRIPTION: This demonstrates how to access the registered AppRouter instance through the dependency injection container, allowing navigation without requiring a context object.  It assumes `AppRouter` has been registered using a dependency injection framework.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\ngetIt<AppRouter>().push(...);\n```\n\n----------------------------------------\n\nTITLE: Configuring Router with Navigation Observers in Dart\nDESCRIPTION: This Dart code snippet configures the router with navigation observers using the `navigatorObservers` property of `_appRouter.config`. It emphasizes that this property is a builder function, which should return new instances of observers to avoid issues with nested routers.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_44\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(\n  routerConfig: _appRouter.config(\n    navigatorObservers: () => [MyObserver()],\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Route Navigation with AutoRouter in Dart\nDESCRIPTION: Demonstrates various navigation methods using `AutoRouter` in Flutter, including pushing routes, replacing routes, navigating to routes, going back, pushing multiple routes, replacing all routes, and popping routes. These methods are used to manipulate the navigation stack and transition between different screens in the application.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n// get the scoped router by calling\nAutoRouter.of(context);\n// or using the extension\ncontext.router;\n// adds a new entry to the pages stack\nrouter.push(const BooksListRoute());\n// or by using paths\nrouter.pushPath('/books');\n// removes last entry in stack and pushes provided route\n// if last entry == provided route page will just be updated\nrouter.replace(const BooksListRoute());\n// or by using paths\nrouter.replacePath('/books');\n// pops until provided route, if it already exists in stack\n// else adds it to the stack (good for web Apps).\nrouter.navigate(const BooksListRoute());\n// or by using paths\nrouter.navigatePath('/books');\n// on Web it calls window.history.back();\n// on Native it navigates you back\n// to the previous location\nrouter.back();\n// adds a list of routes to the pages stack at once\nrouter.pushAll([\n  BooksListRoute(),\n  BookDetailsRoute(id: 1),\n]);\n// This is like providing a completely new stack as it rebuilds the stack\n// with the list of passed routes\n// entries might just update if already exist\nrouter.replaceAll([\n  LoginRoute(),\n]);\n\n// pops the top page even if it's the last entry in stack\ncontext.router.pop()\n// pops the most top page of the most top router even if it's the last entry in stack\ncontext.router.popTop();\n\n// pops the last page unless blocked or stack has only 1 entry\ncontext.router.maybePop();\n// pops the most top page of the most top router unless blocked\n// or stack has only 1 entry\ncontext.router.maybePopTop();\n// keeps popping routes until predicate is satisfied\ncontext.router.popUntil((route) => route.settings.name == 'HomeRoute');\n// a simplified version of the above line\ncontext.router.popUntilRouteWithName('HomeRoute');\n// keeps popping routes until route with provided path is found\ncontext.router.popUntilRouteWithPath('/some-path');\n// pops all routes down to the root\ncontext.router.popUntilRoot();\n// removes the top most page in stack even if it's the last\n// remove != pop, it doesn't respect WillPopScopes it just\n// removes the entry.\ncontext.router.removeLast();\n// removes any route in stack that satisfies the predicate\n// this works exactly like removing items from a regular List\n// <PageRouteInfo>[...].removeWhere((r)=>)\ncontext.router.removeWhere((route) => );\n// you can also use the common helper methods from context extension to navigate\ncontext.pushRoute(const BooksListRoute());\ncontext.replaceRoute(const BooksListRoute());\ncontext.navigateTo(const BooksListRoute());\ncontext.navigateToPath('/books');\ncontext.back();\ncontext.maybePop();\ncontext.pop();\n```\n\n----------------------------------------\n\nTITLE: Adding Generated Route to Routes List - Dart\nDESCRIPTION: This snippet demonstrates how to add a generated route (e.g., `HomeRoute`) to the `routes` list in the router class. The `replaceInRouteName` property allows you to customize the generated route name.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(replaceInRouteName: 'Screen|Page,Route')\nclass AppRouter extends RootStackRouter {\n\n  @override\n  RouteType get defaultRouteType => RouteType.material(); //.cupertino, .adaptive ..etc\n  \n  @override\n  List<AutoRoute> get routes => [\n    // HomeScreen is generated as HomeRoute because\n    // of the replaceInRouteName property\n    AutoRoute(page: HomeRoute.page),\n  ];\n\n  @override\n  List<AutoRouteGuard> get guards => [\n    // optionally add root guards here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Navigation Observer to Router Configuration in Dart\nDESCRIPTION: This code snippet shows how to pass a custom navigation observer to the router configuration using the navigatorObservers property.  The navigatorObservers property takes a builder function that returns a list of observers, ensuring that each router gets a fresh instance of the observer.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_56\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(\n  routerConfig: _appRouter.config(\n    navigatorObservers: () => [MyObserver()],\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Router with GetIt (Dependency Injection) Dart\nDESCRIPTION: This snippet shows how to initialize and register an `AppRouter` as a Singleton using the `get_it` package for dependency injection.  It provides a better alternative to global variables for accessing the router throughout the application. The `AppRouter` instance is retrieved using `getIt<AppRouter>()` within the `build` method.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_33\n\nLANGUAGE: dart\nCODE:\n```\nvoid main(){\n  // make sure you register it as a Singleton or a lazySingleton\n  getIt.registerSingleton<AppRouter>(AppRouter());\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appRouter = getIt<AppRouter>();\n\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TabBar Implementation with AutoTabsRouter in Dart\nDESCRIPTION: This snippet demonstrates how to create tabs using a TabBar with AutoTabsRouter.tabBar. It defines the tab routes and uses a builder function to create the Scaffold, AppBar containing a TabBar, the tab content (child), and a BottomNavigationBar. The TabBar uses a controller provided by AutoTabsRouter, and the BottomNavigationBar manages the active tab index.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.tabBar(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, controller) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n        bottom: TabBar(\n          controller: controller,\n          tabs: const [\n            Tab(text: '1', icon: Icon(Icons.abc)),\n            Tab(text: '2', icon: Icon(Icons.abc)),\n            Tab(text: '3', icon: Icon(Icons.abc)),\n          ],\n        ),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books',...),\n          BottomNavigationBarItem(label: 'Profile',...),\n          BottomNavigationBarItem(label: 'Settings',...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using AutoTabsScaffold for Tab Navigation in Dart\nDESCRIPTION: This code demonstrates using AutoTabsScaffold to simplify the tab navigation setup. It defines a DashboardPage widget that uses AutoTabsScaffold, which handles the creation of the Scaffold and BottomNavigationBar. The routes parameter specifies the child routes, and the bottomNavigationBuilder builds the BottomNavigationBar using the provided tabsRouter.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsScaffold(\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      bottomNavigationBuilder: (_, tabsRouter) {\n        return BottomNavigationBar(\n          currentIndex: tabsRouter.activeIndex,\n          onTap: tabsRouter.setActiveIndex,\n          items: const [\n            BottomNavigationBarItem(label: 'Users', ...),\n            BottomNavigationBarItem(label: 'Posts', ...),\n            BottomNavigationBarItem(label: 'Settings', ...),\n          ],\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transition Example (Custom TransitionsBuilder)\nDESCRIPTION: Illustrates how to implement a custom route transition using a custom transitions builder function.  The example uses ScaleTransition to create a zoom-in effect. It requires the `ZoomInScreen` page to be defined.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_60\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: ZoomInScreen,\n  transitionsBuilder:\n    (BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child) {\n      // you get an animation object and a widget\n      // make your own transition\n      return ScaleTransition(scale: animation, child: child);\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with AutoTabsRouter (Dart)\nDESCRIPTION: This snippet demonstrates how to implement tab navigation using the `AutoTabsRouter` widget in Flutter. It takes a list of routes as input and uses a `BottomNavigationBar` to switch between them, preserving the state of offstage routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsRouter(\n      // list of your tab routes\n      // routes used here must be declared as children\n      // routes of /dashboard\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      transitionBuilder: (context,child,animation) => FadeTransition(\n            opacity: animation,\n            // the passed child is technically our animated selected-tab page\n            child: child,\n          ),\n      builder: (context, child) {\n        // obtain the scoped TabsRouter controller using context\n        final tabsRouter = AutoTabsRouter.of(context);\n        // Here we're building our Scaffold inside of AutoTabsRouter\n        // to access the tabsRouter controller provided in this context\n        //\n        // alternatively, you could use a global key\n        return Scaffold(\n          body: child,\n          bottomNavigationBar: BottomNavigationBar(\n            currentIndex: tabsRouter.activeIndex,\n            onTap: (index) {\n              // here we switch between tabs\n              tabsRouter.setActiveIndex(index);\n            },\n            items: [\n              BottomNavigationBarItem(label: 'Users', ...),\n              BottomNavigationBarItem(label: 'Posts', ...),\n              BottomNavigationBarItem(label: 'Settings', ...),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: AutoRoute Path Definition\nDESCRIPTION: This shows how to explicitly define a path for an AutoRoute, useful for web applications and deep linking. It maps the `/books` path to the `BookListPage` widget, allowing users to navigate directly to that page via the URL.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_31\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books', page: BookListPage),\n```\n\n----------------------------------------\n\nTITLE: Using ActiveGuardObserver for Loading Indicator - Dart\nDESCRIPTION: This code demonstrates how to use `ActiveGuardObserver` to monitor guard checks and display a loading indicator while a guard is in progress. It listens for changes in the `guardInProgress` property to update the UI.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_60\n\nLANGUAGE: dart\nCODE:\n```\nvar isLoading = false;\nvoid initState(){\n  final guardObserver = context.router.activeGuardObserver;\n\n  guardObserver.addListener(() {\n    setState((){\n      isLoading = guardObserver.guardInProgress;\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Adding AutoRoute dependencies in pubspec.yaml\nDESCRIPTION: This snippet demonstrates how to add the necessary dependencies for AutoRoute to your project's `pubspec.yaml` file. It includes `auto_route` as a regular dependency and `auto_route_generator` and `build_runner` as dev dependencies. Required for generating routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ndependencies:\n  auto_route: [latest-version]\n\ndev_dependencies:\n  auto_route_generator: [latest-version]\n  build_runner:\n```\n\n----------------------------------------\n\nTITLE: Accessing the Root Routing Controller (Dart)\nDESCRIPTION: This code snippet shows how to access the root routing controller using `AutoRouter.of(context)`. This provides access to the top-level router in the application.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    // this will get us the root routing controller\n    AutoRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(title: Text('Dashboard page')),\n      // this inserts a new router scope into the widgets tree\n      body: AutoRouter()\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Path Parameters Dart\nDESCRIPTION: This snippet defines a route with a dynamic segment (path parameter) using a colon in the path.  It specifies that the `/books/:id` path maps to `BookDetailsPage` and the `:id` segment is a path parameter.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_40\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books/:id', page: BookDetailsPage),\n```\n\n----------------------------------------\n\nTITLE: Custom Route Builder Example\nDESCRIPTION: Shows how to use a custom route builder function with `CustomRoute`. It creates a `PageRouteBuilder` and passes the page settings.  Requires that `CustomPage` is already defined.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_61\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: CustomPage,\n  customRouteBuilder: <T>(BuildContext context, Widget child, AutoRoutePage<T> page) {\n    return PageRouteBuilder<T>(\n      fullscreenDialog: page.fullscreenDialog,\n      // this is important\n      settings: page,\n      pageBuilder: (_,__,___) => child,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Routes in Dart\nDESCRIPTION: Demonstrates how to pass arguments to a page using AutoRoute. The `BookDetailsPage` widget takes a `Book` object as an argument, and the generated `BookDetailsRoute` delivers the same argument to the page. This showcases how AutoRoute automatically detects and handles page arguments.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({required this.book});\n\n  final Book book;\n  ...\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.push(BookDetailsRoute(book: book));\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Routes in Flutter AutoRoute\nDESCRIPTION: This code snippet demonstrates how to pass arguments to a route using AutoRoute. It shows a `BookDetailsPage` widget that takes a `Book` object as an argument, and how the generated `BookDetailsRoute` delivers the argument to the page.  All arguments are generated as named parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({required this.book});\n\n  final Book book;\n  ...\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.push(BookDetailsRoute(book: book));\n```\n\n----------------------------------------\n\nTITLE: Creating a Re-evaluate Listenable with ChangeNotifier in Dart\nDESCRIPTION: This Dart code snippet creates an `AuthProvider` class extending `ChangeNotifier`. This class is a re-evaluate listenable used to indicate that the authentication state has changed, causing the router to re-evaluate the stack. The `login` and `logout` methods update the authentication status and notify listeners.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_39\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthProvider extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Route with GetIt Dart\nDESCRIPTION: This snippet shows how to push a new route using the globally accessible `AppRouter` instance registered with `get_it`. It is used to navigate without explicit context passing.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_34\n\nLANGUAGE: dart\nCODE:\n```\ngetIt<AppRouter>().push(...);\n```\n\n----------------------------------------\n\nTITLE: Adding generated route to routes list in Dart\nDESCRIPTION: Adds a generated route to the routes list in the AppRouter class.  The replaceInRouteName property is used to customize the generated route name (e.g., replacing 'Screen' or 'Page' with 'Route'). RouteType.material() sets the default route transition. AutoRouteGuard can be added to routes\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_7\n\nLANGUAGE: Dart\nCODE:\n```\n@AutoRouterConfig(replaceInRouteName: 'Screen|Page,Route')\nclass AppRouter extends RootStackRouter {\n\n  @override\n  RouteType get defaultRouteType => RouteType.material(); //.cupertino, .adaptive ..etc\n  \n  @override\n  List<AutoRoute> get routes => [\n    // HomeScreen is generated as HomeRoute because\n    // of the replaceInRouteName property\n    AutoRoute(page: HomeRoute.page),\n  ];\n\n  @override\n  List<AutoRouteGuard> get guards => [\n    // optionally add root guards here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Results from Routes using Completer in Flutter AutoRoute\nDESCRIPTION: This code snippet demonstrates how to return results from a route using the `pop` completer in AutoRoute. It shows how to await a route push and then pop the route with a result. Type specification for the result is recommended for type safety.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop(true);\n```\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push<bool>(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop<bool>(true);\n```\n\n----------------------------------------\n\nTITLE: Enabling Android Predictive Back\nDESCRIPTION: Shows how to enable Android predictive back for a route by setting `enablePredictiveBackGesture` to true.  It also includes the optional `predictiveBackPageTransitionsBuilder` for customizing the transitions.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_72\n\nLANGUAGE: dart\nCODE:\n```\nRouteType.material(\n      enablePredictiveBackGesture: true,\n       // optionally provide a custom transitions builder\n      predictiveBackPageTransitionsBuilder: (context,animation,secondaryAnimation,child) {\n       // return preferred transitions\n      },\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing an AutoRouteGuard (Dart)\nDESCRIPTION: This snippet demonstrates how to create a route guard by extending `AutoRouteGuard`. The `onNavigation` method is overridden to implement the guard's logic, which controls whether navigation to a route is allowed or redirected based on some condition (e.g., authentication).\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_32\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthGuard extends AutoRouteGuard {\n\n  @override\n  void onNavigation(NavigationResolver resolver, StackRouter router) {\n    // the navigation is paused until resolver.next() is called with either\n    // true to resume/continue navigation or false to abort navigation\n    if(authenticated) {\n      // if user is authenticated we continue\n      resolver.next(true);\n    } else {\n        // we redirect the user to our login page\n        // tip: use resolver.redirect to have the redirected route\n        // automatically removed from the stack when the resolver is completed\n        resolver.redirect(\n          LoginRoute(onResult: (success) {\n            // if success == true the navigation will be resumed\n            // else it will be aborted\n            resolver.next(success);\n          },\n        );\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Nested Routes with AutoRouter Widget in Flutter\nDESCRIPTION: This code snippet shows how to render nested routes using the `AutoRouter` widget.  The `AutoRouter` widget acts as an outlet or a nested router-view inside a page. It is placed in the widget tree where nested routes should be rendered.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(label: 'Users', destination: const UsersRoute()),\n            NavLink(label: 'Posts', destination: const PostsRoute()),\n            NavLink(label: 'Settings', destination: const SettingsRoute()),\n          ],\n        ),\n        Expanded(\n          // nested routes will be rendered here\n          child: AutoRouter(), // this is important\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoBackButton.builder\nDESCRIPTION: Demonstrates how to use `AutoBackButton.builder` to provide a nullable leading widget in the `AppBar`, preventing `AppBar.leadingWidth` issues when there's no leading to show.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_70\n\nLANGUAGE: dart\nCODE:\n```\nAutoBackButton.builder(\n  builder: (BuildContext context, Widget? leading) {\n    return  Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: leading,\n      ),\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Including Micro/External Packages\nDESCRIPTION: Demonstrates how to include routes from a micro package in the main router. This can be done by either using the generated routes individually or merging all routes from the micro router.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_62\n\nLANGUAGE: dart\nCODE:\n```\nfinal myMicroRouter = MyMicroRouter();\n\n  @override\n  List<AutoRoute> get routes => [\n        AutoRoute(page: HomeRoute.page, initial: true),\n        /// use micro routes individually\n        AutoRoute(page: RouteFromMicroPackage.page),\n        /// or merge all routes from micro router\n        ...myMicroRouter.routes,\n      ];\n```\n\n----------------------------------------\n\nTITLE: Implementing an AuthGuard with AutoRouteGuard in Dart\nDESCRIPTION: This code snippet demonstrates how to create a custom route guard by extending the AutoRouteGuard class. It overrides the onNavigation method to implement authentication logic, redirecting users to the login page if they are not authenticated.  The NavigationResolver is used to control the flow of navigation by calling resolver.next() or resolver.redirectUntil().\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_49\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthGuard extends AutoRouteGuard {\n\n  @override\n  void onNavigation(NavigationResolver resolver, StackRouter router) {\n    // the navigation is paused until resolver.next() is called with either\n    // true to resume/continue navigation or false to abort navigation\n    if(authenticated) {\n      // if user is authenticated we continue\n      resolver.next(true);\n    } else {\n        // we redirect the user to our login page\n        // tip: use resolver.redirectUntil to have the redirected route\n        // automatically removed from the stack when the resolver is completed\n        resolver.redirectUntil(\n          LoginRoute(onResult: (success) {\n            // if success == true the navigation will be resumed\n            // else it will be aborted\n            resolver.next(success);\n          },\n        );\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Router Initialization with GetIt\nDESCRIPTION: This code snippet illustrates the usage of `get_it` for dependency injection, registering `AppRouter` as a singleton.  It then accesses the router instance within the `MyApp` widget using `getIt<AppRouter>()`, enabling context-free navigation.  Requires the `get_it` package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\nvoid main(){\n  // make sure you register it as a Singleton or a lazySingleton\n  getIt.registerSingleton<AppRouter>(AppRouter());\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appRouter = getIt<AppRouter>();\n\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Router in Dart\nDESCRIPTION: This snippet shows how to access the root router using AutoRouter.of(context) within a nested widget. It emphasizes that calling AutoRouter.of(context) inside Dashboard will return the root routing controller, as Dashboard is a root-level stack entry.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    // this will get us the root routing controller\n    AutoRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(title: Text('Dashboard page')),\n      // this inserts a new router scope into the widgets tree\n      body: AutoRouter()\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Navigation Observers with AutoRouterObserver in Dart\nDESCRIPTION: This Dart code snippet shows how to implement a navigation observer by extending `AutoRouterObserver`. It overrides methods like `didPush`, `didInitTabRoute` and `didChangeTabRoute` to observe route changes and print related logs. `AutoRouterObserver` is essentially a `NavigatorObserver` with tab route support.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_43\n\nLANGUAGE: dart\nCODE:\n```\nclass MyObserver extends AutoRouterObserver {\n\n  @override\n  void didPush(Route route, Route? previousRoute) {\n    print('New route pushed: ${route.settings.name}');\n  }\n\n // only override to observer tab routes\n  @override\n  void didInitTabRoute(TabPageRoute route, TabPageRoute? previousRoute) {\n    print('Tab route visited: ${route.name}');\n  }\n\n  @override\n  void didChangeTabRoute(TabPageRoute route, TabPageRoute previousRoute) {\n    print('Tab route re-visited: ${route.name}');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating to Named Routes in Dart\nDESCRIPTION: Navigates to a named route either by name using NamedRoute or by path using pushPath, replacePath, or navigatePath. The NamedRoute constructor takes the route name and parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_10\n\nLANGUAGE: Dart\nCODE:\n```\n /// match by name\n    router.push(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n    router.replace(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n    router.navigate(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n/// match by path\n     router.pushPath('/books/1');\n     router.replacePath('/books/1');\n     router.navigatePath('/books/1');\n```\n\n----------------------------------------\n\nTITLE: Re-evaluating Routes with reevaluateListenable (Dart)\nDESCRIPTION: This shows how to use the `reevaluateListenable` parameter in `router.config` to trigger route re-evaluation whenever a `Listenable` (e.g., a `ChangeNotifier`) notifies its listeners. This is useful for updating routes based on changes in application state, such as authentication status. requires Flutter's MaterialApp.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_36\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    reevaluateListenable: authProvider,\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with Params\nDESCRIPTION: This shows how to redirect paths including parameters.  The snippet redirects from `books/:id` to `books/:id/details`, allowing a change of path structure without breaking existing links.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_34\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  RedirectRoute(path: 'books/:id', redirectTo: '/books/:id/details'),\n  AutoRoute(path: '/books/:id/details', page: BookDetailsRoute.page),\n]\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Routers from Outside the Scope (Dart)\nDESCRIPTION: This snippet provides an example of accessing the inner router from outside its scope using `context.innerRouterOf<StackRouter>(DashboardRoute.name)`. The example demonstrates pushing a route onto the inner router's stack.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_31\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Dashboard'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.person),\n            onPressed: () {\n              // accessing the inner router from\n              // outside the scope\n              final router = context.innerRouterOf<StackRouter>(DashboardRoute.name)\n              router?.push(const UsersRoute());\n            },\n          ),\n        ],\n      ),\n      body: AutoRouter(), // we're trying to get access to this\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Generators for Pages and Router\nDESCRIPTION: Example configuration for the `build.yaml` which sets up different generate_for rules for @RoutePage and @AutoRouterConfig.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_67\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Declarative Navigation Example (Dart)\nDESCRIPTION: This snippet shows how to use the `AutoRouter.declarative` constructor for declarative navigation, defining routes based on application state. The `routes` parameter takes a function that returns a list of `PageRouteInfo` objects based on current state.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter.declarative(\n  routes: (handler) => [\n    BookListRoute(),\n    if(_selectedBook != null) {\n      BookDetailsRoute(id: _selectedBook.id),\n    }\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Using AutoLeadingButton\nDESCRIPTION: Demonstrates how to use `AutoLeadingButton` as a replacement for the default `BackButton` in the `AppBar`. It simplifies handling nested or parent stack popping.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_69\n\nLANGUAGE: dart\nCODE:\n```\nAppBar(\n  title: Text(context.topRoute.name),\n  leading: AutoLeadingButton(),\n)\n```\n\n----------------------------------------\n\nTITLE: Empty Shell Route Example Dart\nDESCRIPTION: This code snippet demonstrates how to create empty shell routes using the auto_route library. Empty shell routes can be used as placeholders in the navigation structure. The code shows the declaration of a constant named `BooksTab` as an `EmptyShellRoute` and using it with `context.push`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/CHANGELOG.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nconst BooksTab = EmptyShellRoute('BooksTab');\ncontext.push(BooksTab());\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Routers with GlobalKey in Dart\nDESCRIPTION: This example shows how to access an inner router from outside its scope using a GlobalKey. The _innerRouterKey is associated with the AutoRouter widget, and its currentState.controller is used to push new routes onto the inner router's stack when a NavLink is tapped.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatefulWidget {\n  @override\n  _DashboardPageState createState() => _DashboardPageState();\n}\n\nclass _DashboardPageState extends State<DashboardPage> {\n  final _innerRouterKey = GlobalKey<AutoRouterState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(\n              label: 'Users',\n              onTap: () {\n                final router = _innerRouterKey.currentState?.controller;\n                router?.push(const UsersRoute());\n              },\n            ),\n            ...\n          ],\n        ),\n        Expanded(\n          child: AutoRouter(key: _innerRouterKey),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoLeadingButton in AppBar - Dart\nDESCRIPTION: This code demonstrates how to use `AutoLeadingButton` as a replacement for the default `BackButton` in an `AppBar`. `AutoLeadingButton` handles nested or parent stack popping automatically.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_58\n\nLANGUAGE: dart\nCODE:\n```\nAppBar(\n  title: Text(context.topRoute.name),\n  leading: AutoLeadingButton(),\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Routers with context.innerRouterOf in Dart\nDESCRIPTION: This snippet illustrates accessing an inner router from outside its scope using context.innerRouterOf. It assumes the code is in a widget outside the DashboardPage and retrieves the inner StackRouter associated with the DashboardRoute's name. This allows pushing new routes onto the inner router's stack.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Dashboard'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.person),\n            onPressed: () {\n              // accessing the inner router from\n              // outside the scope\n              final router = context.innerRouterOf<StackRouter>(DashboardRoute.name);\n              router?.push(const UsersRoute());\n            },\n          ),\n        ],\n      ),\n      body: AutoRouter(), // we're trying to get access to this\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Redirect with Initial Route Dart\nDESCRIPTION: This snippet simplifies redirecting by setting the target path as the initial route. AutoRoute automatically generates the redirect code.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_46\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  AutoRoute(path: '/books', page: BookListRoute.page, initial: true),\n]\n```\n\n----------------------------------------\n\nTITLE: Path Parameter Extraction\nDESCRIPTION: This example demonstrates how to extract path parameters from a route's path using the `@PathParam` annotation.  The `bookId` parameter is automatically extracted from the `/books/:id` path and injected into the `BookDetailsPage` widget. Requires the `auto_route` annotations package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_32\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books/:id', page: BookDetailsPage),\n\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@PathParam('id') this.bookId});\n\n  final int bookId;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transitions with CustomRoute in Dart\nDESCRIPTION: This snippet demonstrates how to use CustomRoute to define custom route transitions. It passes a TransitionsBuilder function (TransitionsBuilders.slideBottom) and a duration to customize the animation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_46\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: LoginRoute.page,\n  // TransitionsBuilders class contains a preset of common transitions builders.\n  transitionsBuilder: TransitionsBuilders.slideBottom,\n  durationInMilliseconds: 400,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Route Paths (Dart)\nDESCRIPTION: This code shows how to define a specific path for an `AutoRoute` using the `path` argument. This is useful for web applications and native apps that require deep linking.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books', page: BookListPage),\n```\n\n----------------------------------------\n\nTITLE: Using AutoTabsScaffold for Tab Navigation in Dart\nDESCRIPTION: This snippet showcases the use of `AutoTabsScaffold` widget, which simplifies the setup for tab navigation, creating a cleaner implementation. It allows specifying routes and customizing the bottom navigation bar.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsScaffold(\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      bottomNavigationBuilder: (_, tabsRouter) {\n        return BottomNavigationBar(\n          currentIndex: tabsRouter.activeIndex,\n          onTap: tabsRouter.setActiveIndex,\n          items: const [\n            BottomNavigationBarItem(label: 'Users', ...),\n            BottomNavigationBarItem(label: 'Posts', ...),\n            BottomNavigationBarItem(label: 'Settings', ...),\n          ],\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Navigation Observer with AutoRouterObserver in Dart\nDESCRIPTION: This code snippet demonstrates how to implement a custom navigation observer by extending the AutoRouterObserver class. It overrides the didPush, didInitTabRoute, and didChangeTabRoute methods to observe and log route changes. This is useful for tracking navigation events in the application.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_55\n\nLANGUAGE: dart\nCODE:\n```\nclass MyObserver extends AutoRouterObserver {\n\n  @override\n  void didPush(Route route, Route? previousRoute) {\n    print('New route pushed: ${route.settings.name}');\n  }\n\n // only override to observer tab routes\n  @override\n  void didInitTabRoute(TabPageRoute route, TabPageRoute? previousRoute) {\n    print('Tab route visited: ${route.name}');\n  }\n\n  @override\n  void didChangeTabRoute(TabPageRoute route, TabPageRoute previousRoute) {\n    print('Tab route re-visited: ${route.name}');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning AuthGuard to a Route in Dart\nDESCRIPTION: This Dart code snippet shows how to assign the `AuthGuard` to a specific route using the `AutoRoute` constructor. This ensures that the route can only be accessed if the user passes the authentication check implemented in the `AuthGuard`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_37\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  page: ProfileRoute.page,\n  guards: [AuthGuard()],\n);\n```\n\n----------------------------------------\n\nTITLE: Wildcard Route Dart\nDESCRIPTION: This snippet demonstrates using a wildcard route to handle undefined paths.  The `*` path matches any path not explicitly defined and navigates to `UnknownRoute.page`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_48\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '*',\n  page: UnknownRoute.page,\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/profile/*',\n  page: ProfileRoute.page,\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nRedirectRoute(\n  path: '*',\n  redirectTo: '/',\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Routes with AutoRoute in Dart\nDESCRIPTION: This snippet demonstrates how to define nested routes using the `AutoRouterConfig` and `AutoRoute` widgets in the auto_route library. This configures nested navigation structure, with children routes for a parent route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(replaceInRouteName: 'Page,Route')\nclass AppRouter extends $AppRouter {\n\n@override\nList<AutoRoute> get routes => [\n    AutoRoute(\n      path: '/dashboard',\n      page: DashboardRoute.page,\n      children: [\n        AutoRoute(path: 'users', page: UsersRoute.page),\n        AutoRoute(path: 'posts', page: PostsRoute.page),\n        AutoRoute(path: 'settings', page: SettingsRoute.page),\n      ],\n    ),\n    AutoRoute(path: '/login', page: LoginRoute.page),\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global AutoRouteGuard in Router (Dart)\nDESCRIPTION: This example demonstrates implementing a global `AutoRouteGuard` within the router configuration. This guard applies to all stack-routes, controlling navigation based on conditions like user authentication. The `onNavigation` method in the router is overridden to implement the global guard logic.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_34\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends $AppRouter implements AutoRouteGuard {\n\n  @override\n  void onNavigation(NavigationResolver resolver, StackRouter router) {\n    if(isAuthenticated || resolver.route.name == LoginRoute.name) {\n      // we continue navigation\n      resolver.next();\n    } else {\n        // else we navigate to the Login page so we get authenticated\n\n        // tip: use resolver.redirect to have the redirected route\n        // automatically removed from the stack when the resolver is completed\n      resolver.redirect(LoginRoute(onResult: (didLogin) => resolver.next(didLogin)));\n    }\n  }\n  // ..routes[]\n}\n```\n\n----------------------------------------\n\nTITLE: Deep Link Transformer Example\nDESCRIPTION: This snippet shows how to use a deep link transformer to modify incoming deep links before they're processed. In this example, it removes a specified prefix from the beginning of the path, requiring `SynchronousFuture` from flutter foundation package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_27\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: (uri) {\n      if (uri.path.startsWith('/prefix')) {\n        return SynchronousFuture(\n        uri.replace(path: uri.path.replaceFirst('/prefix', '')),\n          );\n      }  \n      return SynchronousFuture(uri);\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Pushing a Route and Popping with Result in AutoRoute Dart\nDESCRIPTION: This snippet demonstrates how to push a new route onto the navigation stack using `router.push` and then pop the current route, passing a result back to the previous route using `router.maybePop`. It highlights the use of dynamic types and type safety.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop(true);\n```\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage<bool>()\nclass LoginPage extends StatelessWidget {}\n```\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push<bool>(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop<bool>(true);\n```\n\n----------------------------------------\n\nTITLE: Defining Route Path Dart\nDESCRIPTION: This snippet defines a route with a specific path using the `path` argument in `AutoRoute`. It maps the `/books` path to the `BookListPage`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_39\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books', page: BookListPage),\n```\n\n----------------------------------------\n\nTITLE: Building Router without Code Generation - Dart\nDESCRIPTION: This snippet shows how to build a router directly using `RootStackRouter.build` without relying on code generation. The routes are declared inline using `NamedRouteDef`.  This is useful when you don't want to use code generation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nfinal router = RootStackRouter.build(\n      defaultRouteType: ...,\n      guards: [global guards],\n      routes: [\n        NamedRouteDef(\n          name: 'BookDetailsRoute',\n          path: '/books/:id', // optional\n          builder: (context, data) {\n            return BookDetailsPage(id: data.params.getInt('id'));\n          },\n        ),\n         // ... other routes\n      ],\n    );\n```\n\n----------------------------------------\n\nTITLE: Wildcard Route Handling\nDESCRIPTION: This demonstrates how to use wildcard routes to handle undefined or invalid paths. Any route that doesn't match a defined path will be directed to the `UnknownRoute` page. Wildcard routes should be placed at the end of the route list.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_35\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '*',\n  page: UnknownRoute.page,\n)\n// it could be used with defined prefixes\nAutoRoute(\n  path: '/profile/*',\n  page: ProfileRoute.page,\n)\n// or it could be used with RedirectRoute\nRedirectRoute(\n  path: '*',\n  redirectTo: '/',\n)\n```\n\n----------------------------------------\n\nTITLE: Extracting Path Parameters with @PathParam (Dart)\nDESCRIPTION: This snippet illustrates how to extract path parameters by annotating constructor parameters with `@PathParam('alias')`. The alias should match the dynamic segment name in the route's path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@PathParam('id') this.bookId});\n\n  final int bookId;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Results from Routes in Dart\nDESCRIPTION: Illustrates two methods for returning results from a page using AutoRoute: using the `pop` completer and passing a callback function as an argument. Both methods allow data to be passed back from a navigated page to the page that initiated the navigation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop(true);\n```\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push<bool>(LoginRoute());\n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.maybePop<bool>(true);\n```\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsRoute({this.book, required this.onRateBook});\n\n  final Book book;\n  final void Function(int) onRateBook;\n  ...\n\n```\n\nLANGUAGE: dart\nCODE:\n```\ncontext.pushRoute(\n  BookDetailsRoute(\n    book: book,\n    onRateBook: (rating) {\n      // handle result\n    },\n  ),\n);\n```\n\nLANGUAGE: dart\nCODE:\n```\nonRateBook(RESULT);\ncontext.maybePop();\n```\n\n----------------------------------------\n\nTITLE: Deep Link Prefix Stripper\nDESCRIPTION: This code uses the built-in `DeepLink.prefixStripper` to remove a prefix from incoming deep links, providing a more concise way to achieve the same result as the previous example. It simplifies the deep link transformation process.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_28\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: DeepLink.prefixStripper('prefix'),\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Route Guards with AutoRouteGuard in Dart\nDESCRIPTION: This snippet demonstrates creating a route guard by extending `AutoRouteGuard`. The `onNavigation` method is overridden to implement custom logic for controlling route access, such as authentication checks.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthGuard extends AutoRouteGuard {\n @override\n void onNavigation(NavigationResolver resolver, StackRouter router) {\n // the navigation is paused until resolver.next() is called with either \n // true to resume/continue navigation or false to abort navigation\n     if(authenitcated){\n       // if user is authenticated we continue\n        resolver.next(true);\n      }else{\n         // we redirect the user to our login page\n         router.push(LoginRoute(onResult: (success){\n                // if success == true the navigation will be resumed\n                // else it will be aborted\n               resolver.next(success);\n          }));\n         }\n     }\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths Dart\nDESCRIPTION: This snippet shows how to redirect a path using `RedirectRoute`. The `/` path is redirected to `/books`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_45\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  RedirectRoute(path: '/', redirectTo: '/books'),\n  AutoRoute(path: '/books', page: BookListRoute.page),\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Named Route - Dart\nDESCRIPTION: This snippet showcases how to declare a named route using `NamedRouteDef`. This allows using auto_route without code generation. It accepts a name, optional path, and a builder function that returns the Widget associated to the route. The builder gets the context and data parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nNamedRouteDef(\n    name: 'BookDetailsRoute',\n    path: '/books/:id', // optional\n    builder: (context, data) {\n      return BookDetailsPage(id: data.params.getInt('id'));\n    },\n  ),\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Nested Route with Empty Path in Flutter AutoRoute\nDESCRIPTION: This snippet demonstrates how to make a child route the initial route when navigating to the parent route by giving the child route an empty path (`''`). When the parent route `/dashboard` is navigated to, the `UsersRoute` will be displayed initially.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    AutoRoute(path: '', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAware Mixin in Dart\nDESCRIPTION: This code shows how to use the AutoRouteAware mixin to make a screen route aware.  It overrides the didChangeDependencies method to subscribe to the AutoRouteObserver and the dispose method to unsubscribe from the observer. This allows the widget to receive notifications about route changes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_32\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAware {          \n   AutoRouteObserver? _observer;          \n             \n  @override          \n  void didChangeDependencies() {          \n    super.didChangeDependencies();          \n    // RouterScope exposes the list of provided observers          \n    // including inherited observers          \n   _observer = RouterScope.of(context).firstObserverOfType<AutoRouteObserver>();          \n    if (_observer != null) {          \n      // we subscribe to the observer by passing our          \n      // AutoRouteAware state and the scoped routeData          \n      _observer.subscribe(this, context.routeData);          \n    }          \n  }          \n            \n @override          \n  void dispose() {          \n    super.dispose();          \n    // don't forget to unsubscribe from the          \n    // observer on dispose          \n    _observer.unsubscribe(this);          \n  }          \n          \n // only override if this is a tab page          \n   @override          \n   void didInitTabRoute(TabPageRoute? previousRoute) {}          \n          \n // only override if this is a tab page          \n   @override          \n   void didChangeTabRoute(TabPageRoute previousRoute) {}          \n          \n   @override          \n   void didPopNext() {}          \n          \n   @override          \n   void didPushNext() {}          \n          \n   @override          \n   void didPush() {}          \n          \n   @override          \n   void didPop() {}          \n}          \n```\n\n----------------------------------------\n\nTITLE: Accessing Path/Query Parameters Dart\nDESCRIPTION: This snippet shows how to access query parameters by annotating constructor parameters with `@QueryParam('optional-alias')`. The document mentions how to use `RouteData` to access path and query parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_43\n\nLANGUAGE: dart\nCODE:\n```\nRouteData.of(context).pathParams;\n// or using the extension\ncontext.routeData.queryParams;\n```\n\n----------------------------------------\n\nTITLE: Removing Shadow from Nested Routers Dart\nDESCRIPTION: Shows how to remove shadows from nested routers by overriding the default CupertinoPageTransitionsBuilder with NoShadowCupertinoPageTransitionsBuilder in the PageTransitionsTheme.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_42\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  theme: ThemeData.dark().copyWith(\n  pageTransitionsTheme: PageTransitionsTheme(\n     builders: {\n         // replace default CupertinoPageTransitionsBuilder with this\n        TargetPlatform.iOS: NoShadowCupertinoPageTransitionsBuilder(),\n        TargetPlatform.android: FadeUpwardsPageTransitionsBuilder(),\n    } )\n  ),\n \n```\n\n----------------------------------------\n\nTITLE: Simplified Parameter Annotation Dart\nDESCRIPTION: Demonstrates how to simplify path parameter annotation using the `@pathParam` constant when the parameter name is the same as the path segment.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_44\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@pathParam this.id});\n\n  final int id;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using resolver.resolveNext to control Re-evaluation in Dart\nDESCRIPTION: This Dart code snippet shows how to use `resolver.resolveNext` inside of `AutoRouteGuard.onNavigation` method for more control over route re-evaluation. You can choose to stop re-pushing any pending routes after the current route by setting `reevaluateNext` to `false`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_41\n\nLANGUAGE: dart\nCODE:\n```\n@override\nvoid onNavigation(NavigationResolver resolver, StackRouter router) async {\n  if (authProvider.isAuthenticated) {\n    resolver.next();\n  } else {\n    resolver.redirectUntil(\n      WebLoginRoute(\n        /// this part is optional if you're not using reevaluateListenable as this method will \n        /// be called again and if the condition is satisfied the resolver will be completed\n        onResult: (didLogin) {\n          /// stop re-pushing any pending routes after current\n          resolver.resolveNext(didLogin, reevaluateNext: false);\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with Parameters Dart\nDESCRIPTION: This snippet demonstrates redirecting paths with parameters using `RedirectRoute`. It redirects `books/:id` to `/books/:id/details`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_47\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  RedirectRoute(path: 'books/:id', redirectTo: '/books/:id/details'),\n  AutoRoute(path: '/books/:id/details', page: BookDetailsRoute.page),\n]\n```\n\n----------------------------------------\n\nTITLE: Setting Observers for Nested Routers in Dart\nDESCRIPTION: This snippet shows how to configure observers for nested routers using AutoRouter and AutoTabsRouter.  The inheritNavigatorObservers property controls whether the nested router inherits observers from its parent. The navgiatorObservers property accepts a function that returns a list of observers.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_30\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter(          \n    inheritNavigatorObservers: true, // true by default          \n    navgiatorObservers:()=> [list of observers]);          \n              \n AutoTabsRouter(          \n    inheritNavigatorObservers: true, // true by default          \n    navgiatorObservers:()=> [list of observers]);          \n```\n\n----------------------------------------\n\nTITLE: Defining Path Parameters (Dart)\nDESCRIPTION: This code demonstrates how to define a dynamic segment (path parameter) in a route path and extract it using the `@PathParam` annotation. This enables passing data via the URL path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books/:id', page: BookDetailsPage),\n```\n\n----------------------------------------\n\nTITLE: Deep-link Transformer with Prefix Stripper (Dart)\nDESCRIPTION: This code shows how to use the built-in `DeepLink.prefixStripper` for stripping prefixes from deep links.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: DeepLink.prefixStripper('prefix'),\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAwareStateMixin in Dart\nDESCRIPTION: This code simplifies the previous example by using the AutoRouteAwareStateMixin.  This mixin handles the subscription and unsubscription to the AutoRouteObserver automatically, reducing boilerplate code.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_33\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAwareStateMixin<BookListPage> {          \n // only override if this is a tab page          \n   @override          \n   void didInitTabRoute(TabPageRoute? previousRoute) {}          \n // only override if this is a tab page          \n   @override          \n   void didChangeTabRoute(TabPageRoute previousRoute) {}          \n       \n // only override if this is a stack page         \n   @override          \n   void didPopNext() {}          \n // only override if this is a stack page         \n   @override          \n   void didPushNext() {}          \n}          \n```\n\n----------------------------------------\n\nTITLE: Inheriting Path Parameters Dart\nDESCRIPTION: This example shows how to inherit a path parameter from a parent route using `@PathParam.inherit`. The `ProductReviewScreen` inherits the `id` parameter from its parent route `/product/:id`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_42\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass ProductReviewScreen extends StatelessWidget {\n  // the path-param 'id' will be inherited and it can not be passed\n  // as a route arg by user\n  const ProductReviewScreen({super.key, @PathParam.inherit('id') required String id});\n}\n```\n\n----------------------------------------\n\nTITLE: Generated BookListRoute class in Dart\nDESCRIPTION: Shows the structure of a generated PageRouteInfo class for a BookListRoute. This class holds strongly-typed page arguments. A `PageRouteInfo` object will be generated for every declared **AutoRoute**.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_12\n\nLANGUAGE: Dart\nCODE:\n```\nclass BookListRoute extends PageRouteInfo {\n  const BookListRoute({\n    List<PagerouteInfo>? children,\n  }) : super(name, initialChildren: children);\n\n  static const String name = 'BookListRoute';\n  static const PageInfo page = PageInfo(name,builder: (...));\n}\n```\n\n----------------------------------------\n\nTITLE: Building a router without code generation in Dart\nDESCRIPTION: Demonstrates how to build a router without code generation using RootStackRouter.build.  It allows specifying defaultRouteType, global guards, and a list of NamedRouteDef objects.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_11\n\nLANGUAGE: Dart\nCODE:\n```\n    final router = RootStackRouter.build(\n      defaultRouteType: ...,\n      guards: [global guards],\n      routes: [\n        NamedRouteDef(\n          name: 'BookDetailsRoute',\n          path: '/books/:id', // optional\n          builder: (context, data) {\n            return BookDetailsPage(id: data.params.getInt('id'));\n          },\n        ),\n         // ... other routes\n      ],\n    );\n```\n\n----------------------------------------\n\nTITLE: Handling Wildcard Routes in AutoRoute in Dart\nDESCRIPTION: This snippet demonstrates how to use wildcard routes ('*') to handle undefined paths. This allows you to navigate to a default page or redirect the user when no other route matches.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_23\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '*', page: UnknownRoutePage)\n// it could be used with defined prefixes\nAutoRoute(path: '/profile/*', page: ProfilePage)\n// or it could be used with RedirectRoute\nRedirectRoute(path: '*', redirectTo: '/')\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transitions with TransitionsBuilder - Dart\nDESCRIPTION: This code demonstrates how to define a custom route transition using `CustomRoute` and a `TransitionsBuilder`. It uses a pre-defined transition (`TransitionsBuilders.slideBottom`) with a specified duration. The `TransitionsBuilder` function needs to be passed as a static/const reference that has the same signature as the `TransitionsBuilder` function of the `PageRouteBuilder` class.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_47\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: LoginRoute.page,\n  // TransitionsBuilders class contains a preset of common transitions builders.\n  transitionsBuilder: TransitionsBuilders.slideBottom,\n  duration: Duration(milliseconds: 400),\n)\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Routes in Dart\nDESCRIPTION: This snippet illustrates how to pass arguments to routes using AutoRoute. It shows how AutoRoute automatically detects and handles page arguments, delivering them to the page widget via the generated route object. It emphasizes that all arguments are generated as named parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget {              \n const BookDetailsPage({required this.book});              \n              \n  final Book book;           \n  ...              \n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.push(BookDetailsRoute(book: book));              \n```\n\n----------------------------------------\n\nTITLE: Accessing Root Router (Dart)\nDESCRIPTION: This code demonstrates how to access the root routing controller using `router.root`. The root router is always a StackRouter, so no type casting is required.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\nrouter.root // this returns the root router as a Stack Routing controller\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Shell Routes with AutoRouter in Flutter\nDESCRIPTION: This code snippet demonstrates how to create an empty shell route, which builds a screen containing the `AutoRouter` widget to render nested routes. Two approaches are shown: building the widget directly and extending the `AutoRouter` widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass MyShellPage extends StatelessWidget {\n  const MyShellPage({Key? key}) : super(key: key);\n  @override\n  Widget build(BuildContext context) {\n     /// you can wrap the AutoRouter with any widget you want\n    return  AutoRouter();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass MyShellPage extends AutoRouter {\n   const MyShellPage({Key? key}) : super(key: key);  \n}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Route-Aware Screens with AutoRouteAwareStateMixin in Dart\nDESCRIPTION: This Dart code snippet simplifies the implementation of route-aware screens by using the `AutoRouteAwareStateMixin`. This mixin automatically handles subscribing and unsubscribing from the `AutoRouteObserver`, reducing boilerplate code. Methods such as `didPopNext` and `didPushNext` should be overridden for stack pages and `didInitTabRoute` and `didChangeTabRoute` for tab pages.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_46\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAwareStateMixin<BookListPage> {\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  // only override if this is a stack page\n  @override\n  void didPopNext() {}\n  \n  // only override if this is a stack page\n  @override\n  void didPushNext() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Generation Time with Globs\nDESCRIPTION: Demonstrates how to optimize generation time by specifying the files that build_runner should process using globs.  Examples show filtering files based on directory and filename patterns.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_66\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**.dart\n```\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**_screen.dart\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Parameters using RouteData in Dart\nDESCRIPTION: This snippet demonstrates how to access query parameters using the `RouteData` object. You can retrieve query parameters either directly from `RouteData.of(context).pathParams` or through the extension `context.routeData.queryParams`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_18\n\nLANGUAGE: dart\nCODE:\n```\nRouteData.of(context).pathParams;\n// or using the extension\ncontext.routeData.queryParams\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with PageView in Dart\nDESCRIPTION: This code demonstrates how to implement tab navigation using `AutoTabsRouter.pageView`, which integrates tabs with a PageView for swiping between tabs. The snippet also displays how to access the current route name using `context.topRoute.name`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.pageView(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, _) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books', ...),\n          BottomNavigationBarItem(label: 'Profile', ...),\n          BottomNavigationBarItem(label: 'Settings', ...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Exporting Micro Router\nDESCRIPTION: Shows how to export a micro router to simplify imports in the main application. Exporting allows importing only `app_router.dart` instead of the micro router directly.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_63\n\nLANGUAGE: dart\nCODE:\n```\n// ...imports\nexport 'package:my_package/my_micro_router.dart'\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter {}\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router with GlobalKey (Dart)\nDESCRIPTION: This snippet illustrates how to access an inner router from outside its scope using a GlobalKey. It shows how to obtain the router's state and controller to push new routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatefulWidget {          \n  @override          \n  _DashboardPageState createState() => _DashboardPageState();          \n}          \n          \nclass _DashboardPageState extends State<DashboardPage> {          \n  final _innerRouterKey = GlobalKey<AutoRouterState>();          \n  @override          \n  Widget build(BuildContext context) {          \n    return Row(          \n      children: [          \n        Column(          \n          children: [          \n            NavLink(label: 'Users',          \n            onTap:(){          \n               final router = _innerRouterKey.currentState?.controller;          \n               router?.push(const UsersRoute());          \n             }          \n            ),          \n            ...          \n          ],          \n        ),          \n        Expanded(          \n          child: AutoRouter(key: _innerRouterKey),          \n        )          \n      ],          \n    );          \n  }          \n}\n```\n\n----------------------------------------\n\nTITLE: Micro Router Configuration (After v9)\nDESCRIPTION: This snippet shows how to configure micro routers and merge their routes in v9.  The generated `PageRouteInfos` are now self-sufficient.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_7\n\nLANGUAGE: dart\nCODE:\n```\n/// normal auto router config\n@AutoRouterConfig()\nclass MyMicroRouter extends RootStackRouter{}\n```\n\nLANGUAGE: dart\nCODE:\n```\n  final myMicroRouter = MyMicroRouter();\n\n  @override\n  List<AutoRoute> get routes => [\n        AutoRoute(page: HomeRoute.page, initial: true),\n        /// use micro routes individually\n        AutoRoute(page: RouteFromMicroPackage.page),\n        /// or merge all routes from micro router\n        ...myMicroRouter.routes,\n      ];\n```\n\n----------------------------------------\n\nTITLE: Using AutoBackButton.builder in Scaffold - Dart\nDESCRIPTION: This code demonstrates how to use `AutoBackButton.builder` to provide a nullable leading widget to the AppBar, preventing AppBar.leadingWidth issues when there's no leading to show.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_59\n\nLANGUAGE: dart\nCODE:\n```\nAutoBackButton.builder(\n  builder: (BuildContext context, Widget? leading) {\n    return  Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: leading,\n      ),\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Enabling Predictive Back Gesture - Dart\nDESCRIPTION: This code demonstrates how to enable the predictive back gesture for a specific route by setting `enablePredictiveBackGesture` to `true` in the route type. It also shows how to provide a custom `predictiveBackPageTransitionsBuilder` to customize the transitions.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_61\n\nLANGUAGE: dart\nCODE:\n```\nRouteType.material(\n      enablePredictiveBackGesture: true,\n       // optionally provide a custom transitions builder\n      predictiveBackPageTransitionsBuilder: (context,animation,secondaryAnimation,child) {\n       // return preferred transitions\n      },\n    )\n```\n\n----------------------------------------\n\nTITLE: Wrapping Routes with AutoRouteWrapper in Dart\nDESCRIPTION: This snippet demonstrates implementing the `AutoRouteWrapper` interface to wrap a route with a parent widget. The `wrappedRoute` method returns the widget to wrap the route with, typically used for providing contextual values or dependencies.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\nclass ProductsScreen extends StatelessWidget implements AutoRouteWrapper {\n  @override\n  Widget wrappedRoute(BuildContext context) {\n  return Provider(create: (ctx) => ProductsBloc(), child: this);\n  }\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Returning Results from Routes in Dart\nDESCRIPTION: This snippet demonstrates two methods for returning results from routes using AutoRoute: using the pop completer and passing a callback function as an argument. It covers specifying the result type and handling the returned value, emphasizing the importance of type safety.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push(LoginRoute());              \n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.pop(true);             \n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute<bool>(page: LoginPage),           \n```\n\nLANGUAGE: dart\nCODE:\n```\nvar result = await router.push<bool>(LoginRoute());              \n```\n\nLANGUAGE: dart\nCODE:\n```\nrouter.pop<bool>(true);             \n```\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget {              \n const BookDetailsRoute({this.book, required this.onRateBook});              \n              \n  final Book book;              \n  final void Function(int) onRateBook;              \n  ...              \n```\n\nLANGUAGE: dart\nCODE:\n```\ncontext.router.push(              \n      BookDetailsRoute(              \n          book: book,              \n          onRateBook: (rating) {              \n           // handle result              \n          }),              \n    );              \n```\n\nLANGUAGE: dart\nCODE:\n```\nonRateBook(RESULT);              \ncontext.router.pop();              \n```\n\n----------------------------------------\n\nTITLE: Declarative Navigation Dart\nDESCRIPTION: This snippet demonstrates declarative navigation using `AutoRouter.declarative`. It returns a list of routes based on application state. The `routes` parameter receives a `handler` but its usage is unclear based on the given example.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_38\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter.declarative(\n  routes: (handler) => [\n    BookListRoute(),\n    if(_selectedBook != null) {\n      BookDetailsRoute(id: _selectedBook.id),\n    }\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Route Paths with AutoRoute (Dart)\nDESCRIPTION: This example demonstrates how to define custom paths for routes using the `path` argument in `AutoRoute`. This allows for clear and memorable names, especially important for web applications and deep-linking scenarios.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books', page: BookListPage),\n```\n\n----------------------------------------\n\nTITLE: Assigning Route Guards to Routes in Dart\nDESCRIPTION: This snippet demonstrates how to assign a route guard (e.g., `AuthGuard`) to a specific route using the `guards` property. The route will only be accessible if the guard allows it.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(page: ProfileScreen, guards: [AuthGuard]);\n```\n\n----------------------------------------\n\nTITLE: Accessing the Root Router (Dart)\nDESCRIPTION: This snippet shows how to access the root router without type casting using the `router.root` property.  The root router is always a `StackRouter`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_28\n\nLANGUAGE: dart\nCODE:\n```\nrouter.root // this returns the root router as a Stack Routing controller\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with TabBar in Dart\nDESCRIPTION: This code snippet provides an example of implementing tab navigation with `AutoTabsRouter.tabBar` and `TabBar`. This allows using a TabBar widget for tab selection, enabling a more traditional tabbed interface within a Flutter app.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.tabBar(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, controller) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n        bottom: TabBar(\n          controller: controller,\n          tabs: const [\n            Tab(text: '1', icon: Icon(Icons.abc)),\n            Tab(text: '2', icon: Icon(Icons.abc)),\n            Tab(text: '3', icon: Icon(Icons.abc)),\n          ],\n        ),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books',...),\n          BottomNavigationBarItem(label: 'Profile',...),\n          BottomNavigationBarItem(label: 'Settings',...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: RoutePage Return Type Definition (Before v9)\nDESCRIPTION: This snippet demonstrates how return types were previously defined directly inside `@RoutePage<RETURN_TYPE>()`. This approach has been deprecated.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage<bool>()\nclass LoginPage extends StatelessWidget {}\n```\n\nLANGUAGE: dart\nCODE:\n```\n /// pushing the route\nbool didLogin = await context.pushRoute<bool>();\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transitions with Custom Builder - Dart\nDESCRIPTION: This code demonstrates how to implement custom route transitions by defining a custom `transitionsBuilder` function within a `CustomRoute`.  It showcases the use of `ScaleTransition` to achieve a zoom-in effect. The function has to take in exactly one `BuildContext`, `Animation<Double>`, `Animation<Double>` and a child `Widget` and it needs to return a `Widget`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_48\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: ZoomInScreen,\n  transitionsBuilder:\n    (BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child) {\n      // you get an animation object and a widget\n      // make your own transition\n      return ScaleTransition(scale: animation, child: child);\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using ActiveGuardObserver for Loading Indicator (Dart)\nDESCRIPTION: This snippet demonstrates how to use `ActiveGuardObserver` to get notified when a guard is being checked, enabling implementation of a loading indicator.  It adds a listener to `guardObserver` and updates the state based on `guardObserver.guardInProgress`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_59\n\nLANGUAGE: dart\nCODE:\n```\nvar isLoading = false;\nvoid initState(){\n  final guardObserver = context.router.activeGuardObserver;\n\n  guardObserver.addListener(() {\n    setState((){\n      isLoading = guardObserver.guardInProgress;\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Global Guards Implementation (Before v9)\nDESCRIPTION: This snippet shows the previous implementation of global guards using `implements AutoRouteGuard`. This method is no longer supported in v9.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends $AppRouter implements AutoRouteGuard {\n\n  @override\n  void onNavigation(NavigationResolver resolver, StackRouter router) {\n     /// guard logic\n  }\n \n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAwareStateMixin in Dart\nDESCRIPTION: This code snippet demonstrates the usage of `AutoRouteAwareStateMixin` to simplify the process of making a screen route-aware. This mixin handles the subscription and unsubscription to the `AutoRouteObserver`, reducing boilerplate code in the widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_58\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAwareStateMixin<BookListPage> {\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  // only override if this is a stack page\n  @override\n  void didPopNext() {}\n  \n  // only override if this is a stack page\n  @override\n  void didPushNext() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with TabBar (Dart)\nDESCRIPTION: This snippet demonstrates the use of `AutoTabsRouter.tabBar` to implement tab navigation with a `TabBar` in the AppBar.  The `TabBar` provides a visual representation of the active tab at the top of the screen.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.tabBar(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, controller) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n        bottom: TabBar(\n          controller: controller,\n          tabs: const [\n            Tab(text: '1', icon: Icon(Icons.abc)),\n            Tab(text: '2', icon: Icon(Icons.abc)),\n            Tab(text: '3', icon: Icon(Icons.abc)),\n          ],\n        ),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books',...),\n          BottomNavigationBarItem(label: 'Profile',...),\n          BottomNavigationBarItem(label: 'Settings',...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing AutoRouterObserver in Dart\nDESCRIPTION: This snippet demonstrates how to implement an AutoRouterObserver to observe route changes (push, replace, pop) and tab route events. It overrides the didPush, didInitTabRoute, and didChangeTabRoute methods to print route names to the console.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_39\n\nLANGUAGE: dart\nCODE:\n```\nclass MyObserver extends AutoRouterObserver {\n\n  @override\n  void didPush(Route route, Route? previousRoute) {\n    print('New route pushed: ${route.settings.name}');\n  }\n\n // only override to observer tab routes\n  @override\n  void didInitTabRoute(TabPageRoute route, TabPageRoute? previousRoute) {\n    print('Tab route visited: ${route.name}');\n  }\n\n  @override\n  void didChangeTabRoute(TabPageRoute route, TabPageRoute previousRoute) {\n    print('Tab route re-visited: ${route.name}');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Custom Ignore Rules\nDESCRIPTION: Shows how to pass custom ignore_for_file rules to the generated router using the `build.yaml` file.  This example configures the generator to ignore `custom_rule_1` and `custom_rule_2`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_65\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_router_generator:\n       options:\n         ignore_fore_file:\n           - custom_rule_1\n           - custom_rule_2\n```\n\n----------------------------------------\n\nTITLE: Navigating to Named Routes - Dart\nDESCRIPTION: This snippet illustrates how to navigate to a named route using either the `NamedRoute` class or `pushPath`, `replacePath`, and `navigatePath` methods. The `NamedRoute` class matches routes by name, while the `pushPath` method matches routes by path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\n/// match by name\n    router.push(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n    router.replace(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n    router.navigate(NamedRoute('BookDetailsRoute', params: {'id': 1}));\n/// match by path\n     router.pushPath('/books/1');\n     router.replacePath('/books/1');\n     router.navigatePath('/books/1');\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Router (Dart)\nDESCRIPTION: This snippet shows how to access parent routing controllers using `router.parent<T>()`, specifying the router type (StackRouter or TabsRouter). This is used when the parent router type is known, allowing access to specific parent router functionalities.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nrouter.parent<StackRouter>() // this returns  the parent router as a Stack Routing controller              \nrouter.parent<TabsRouter>() // this returns athe parent router as a Tabs Routing controller\n```\n\n----------------------------------------\n\nTITLE: Exporting MyPackageModule in Dart\nDESCRIPTION: Shows how to export `MyPackageModule` to `app_router.dart`, simplifying imports.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_51\n\nLANGUAGE: dart\nCODE:\n```\n// ...imports\nexport 'package:my_package/my_package_module.dart'\n@AutoRouterConfig(modules: [MyPackageModule])\nclass AppRouter extends $AppRouter {}\n```\n\n----------------------------------------\n\nTITLE: Annotating Pages with @RoutePage (Dart)\nDESCRIPTION: This snippet explains how to annotate pages with `@RoutePage` instead of passing the page component as a type directly to `AutoRoute`.  It shows that the page is annotated, and the `result.page` is used when defining the `AutoRoute`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_61\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage() // Add this annotation to your routable pages\nclass ProductDetailsPage extends StatelessWidget {}\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(page: ProductDetailsRoute.page) // ProductDetailsRoute is generated\n```\n\n----------------------------------------\n\nTITLE: Configuring Router with Re-evaluate Listenable in Dart\nDESCRIPTION: This Dart code snippet configures the router with a re-evaluate listenable using the `routerConfig` property of `MaterialApp.router`. It passes an instance of `AuthProvider` as the `reevaluateListenable`. This triggers the router to re-evaluate the stack whenever `AuthProvider` notifies its listeners.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_40\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    reevaluateListenable: authProvider,\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: TabBar Implementation with AutoTabsRouter (Dart)\nDESCRIPTION: This snippet demonstrates how to implement a TabBar using the AutoTabsRouter.tabBar constructor. It configures the routes for each tab and defines the UI using a builder function, including the AppBar, TabBar, body, and BottomNavigationBar.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.tabBar(      \n     routes: [      \n        BooksTab(),      \n        ProfileTab(),      \n        SettingsTab(),      \n        ],     \n     builder: (context, child, controller) {      \n        return Scaffold(      \n              appBar: AppBar(      \n                 title: Text(context.topRoute.name),      \n                 leading: AutoLeadingButton(),    \n                 bottom: TabBar(      \n                    controller: controller,      \n                    tabs: const [      \n                    Tab(text: '1', icon: Icon(Icons.abc)),      \n                    Tab(text: '2', icon: Icon(Icons.abc)),      \n                    Tab(text: '3', icon: Icon(Icons.abc)),      \n                   ],),    \n               ),      \n              body: child,      \n              bottomNavigationBar: BottomNavigationBar(          \n                    currentIndex: tabsRouter.activeIndex,          \n                    onTap: tabsRouter.setActiveIndex          \n                    items: [          \n                      BottomNavigationBarItem(label: 'Books',...),          \n                      BottomNavigationBarItem(label: 'Profile',...),          \n                      BottomNavigationBarItem(label: 'Settings',...),          \n                    ],          \n                  ),    \n            ),      \n      ); },    \n  );\n```\n\n----------------------------------------\n\nTITLE: Initializing Router as Global Variable Dart\nDESCRIPTION: This snippet demonstrates how to initialize an `AppRouter` as a global variable for navigation without context. It is generally not recommended due to best practices favoring dependency injection.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_32\n\nLANGUAGE: dart\nCODE:\n```\n// declare your route as a global variable\nfinal appRouter = AppRouter();\n\nclass MyApp extends StatefulWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating with AutoRouter in Dart\nDESCRIPTION: This snippet demonstrates various navigation methods using the `AutoRouter` in Flutter. It covers pushing, replacing, navigating, and popping routes using both `PageRouteInfo` objects and paths. It also includes examples of pushing multiple routes and manipulating the route stack.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n// get the scoped router by calling              \nAutoRouter.of(context)              \n// or using the extension              \ncontext.router              \n              \n// adds a new entry to the pages stack              \nrouter.push(const BooksListRoute())            \n// or by using using paths            \nrouter.pushNamed('/books')             \n          \n// removes last entry in stack and pushs provided route           \n// if last entry == provided route page will just be updated          \nrouter.replace(const BooksListRoute())              \n// or by using using paths            \nrouter.replaceNamed('/books')            \n          \n// pops until provided route, if it already exists in stack              \n// else adds it to the stack (good for web Apps).              \nrouter.navigate(const BooksListRoute())            \n// or by using using paths            \nrouter.navigateNamed('/books')          \n        \n// on Web it calls window.history.back();      \n// on Native it navigates you back       \n// to the previous location      \nrouter.navigateBack();      \n      \n// adds a list of routes to the pages stack at once          \nrouter.pushAll([          \n   BooksListRoute(),          \n   BookDetailsRoute(id:1),          \n]);          \n          \n// This's like providing a completely new stack as it rebuilds the stack          \n// with the list of passed routes          \n// entires might just update if already exist          \nrouter.replaceAll([          \n   LoginRoute()          \n]);          \n// pops the last page unless stack has 1 entry              \ncontext.router.pop();             \n// keeps poping routes until predicate is satisfied          \ncontext.router.popUntil((route) => route.name == 'HomeRoute');          \n// a simplifed version of the above line          \ncontext.router.popUntilRouteWithName('HomeRoute');          \n// pops all routes down to the root          \ncontext.router.popUntilRoot();          \n               \n// removes the top most page in stack even if it's the last          \n// remove != pop, it doesn't respect WillPopScopes it just           \n// removes the entry.          \ncontext.router.removeLast();           \n          \n// removes any route in stack that satisfis the predicate          \n// this works exactly like removing items from a regualar List          \n// <PageRouteInfo>[...].removeWhere((r)=>)          \ncontext.router.removeWhere((route) => );          \n              \n// you can also use the common helper methods from context extension to navigate          \ncontext.pushRoute(const BooksListRoute());          \ncontext.replaceRoute(const BooksListRoute());          \ncontext.navigateTo(const BooksListRoute());          \ncontext.navigateNamedTo('/books');          \ncontext.navigateBack();         \ncontext.popRoute();          \n```\n\n----------------------------------------\n\nTITLE: Using resolver.resolveNext with Reevaluate Listenable in Dart\nDESCRIPTION: This code snippet demonstrates the use of resolver.resolveNext() to stop re-evaluating routes after a certain point when using a Reevaluate Listenable. It showcases how to conditionally stop the re-pushing of pending routes after the current one by setting reevaluateNext: false.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_53\n\nLANGUAGE: dart\nCODE:\n```\n@override\nvoid onNavigation(NavigationResolver resolver, StackRouter router) async {\n  if (authProvider.isAuthenticated) {\n    resolver.next();\n  } else {\n    resolver.redirectUntil(\n      WebLoginRoute(\n        /// this part is optional if you're not using reevaluateListenable as this method will \n        /// be called again and if the condition is satisfied the resolver will be completed\n        onResult: (didLogin) {\n          /// stop re-pushing any pending routes after current\n          resolver.resolveNext(didLogin, reevaluateNext: false);\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Nested Routes using AutoRouter in Dart\nDESCRIPTION: This snippet shows how to render nested routes using the `AutoRouter` widget as an outlet within a parent page. The `AutoRouter` widget displays the currently active child route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(label: 'Users', destination: const UsersRoute()),\n            NavLink(label: 'Posts', destination: const PostsRoute()),\n            NavLink(label: 'Settings', destination: const SettingsRoute()),\n          ],\n        ),\n        Expanded(\n          // nested routes will be rendered here\n          child: AutoRouter(),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declarative Route Definition\nDESCRIPTION: This snippet illustrates how to define routes declaratively based on application state.  It creates a list of routes, including `BookDetailsRoute` only when `_selectedBook` is not null.  Requires an `AutoRouter` instance and route classes to be defined elsewhere.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_30\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter.declarative(\n  routes: (handler) => [\n    BookListRoute(),\n    if(_selectedBook != null) {\n      BookDetailsRoute(id: _selectedBook.id),\n    }\n  ],\n);\n```\n\n----------------------------------------\n\nTITLE: Running the code generator in build mode\nDESCRIPTION: Runs the AutoRoute code generator once using the build_runner. This command generates the necessary route code and then exits.  It's suitable for scenarios where continuous monitoring is not required.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_6\n\nLANGUAGE: Terminal\nCODE:\n```\ndart run build_runner build\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Routers without a GlobalKey (Dart)\nDESCRIPTION: This snippet demonstrates how to access an inner router without using a global key by using the `context.innerRouterOf<T>(routeName)` extension method.  This is possible as long as the inner router has been initialized.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_30\n\nLANGUAGE: dart\nCODE:\n```\n// assuming this is the root router\ncontext.innerRouterOf<StackRouter>(UserRoute.name);\n// or if we're using an AutoTabsRouter inside of DashboardPage\ncontext.innerRouterOf<TabsRouter>(UserRoute.name);\n```\n\n----------------------------------------\n\nTITLE: AuthProvider ChangeNotifier (Dart)\nDESCRIPTION: This is a mock `AuthProvider` class extending `ChangeNotifier`. It provides a simple login/logout mechanism and notifies listeners when the authentication state changes. This can be used as a `reevaluateListenable` to trigger route re-evaluation. Dependencies: flutter foundation package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_35\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthProvider extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Callback Function as Argument in AutoRoute Dart\nDESCRIPTION: This snippet shows how to pass a callback function as an argument to a route in the auto_route library. The generated `BookDetailsRoute` will deliver the same arguments to its corresponding page. It is used for delivering data back to the originating page.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsRoute({this.book, required this.onRateBook});\n\n  final Book book;\n  final void Function(int) onRateBook;\n  ...\n\n```\n\nLANGUAGE: dart\nCODE:\n```\ncontext.pushRoute(\n  BookDetailsRoute(\n    book: book,\n    onRateBook: (rating) {\n      // handle result\n    },\n  ),\n);\n```\n\nLANGUAGE: dart\nCODE:\n```\nonRateBook(RESULT);\ncontext.maybePop();\n```\n\n----------------------------------------\n\nTITLE: Micro Packages Route Inclusion - Dart\nDESCRIPTION: This code illustrates how to include routes from a micro-package into the main router. It demonstrates two approaches: using micro-routes individually or merging all routes from the micro-router. It assumes that `MyMicroRouter` is already generated in the micro-package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_50\n\nLANGUAGE: dart\nCODE:\n```\nfinal myMicroRouter = MyMicroRouter();\n\n  @override\n  List<AutoRoute> get routes => [\n        AutoRoute(page: HomeRoute.page, initial: true),\n        /// use micro routes individually\n        AutoRoute(page: RouteFromMicroPackage.page),\n        /// or merge all routes from micro router\n        ...myMicroRouter.routes,\n      ];\n```\n\n----------------------------------------\n\nTITLE: Configuring MaterialApp.router with navigatorObservers in Dart\nDESCRIPTION: This code shows how to configure MaterialApp.router with a list of navigator observers. The navigatorObservers property is a builder function that returns a list of observers. This ensures that each router instance has its own observer instance.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_40\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(\n  routerConfig: _appRouter.config(\n    navigatorObservers: () => [MyObserver()],\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Passing custom ignore_for_file rules in build.yaml\nDESCRIPTION: This YAML snippet shows how to pass custom ignore_for_file rules to the generated router via the build.yaml file.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_53\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_router_generator:\n       options:\n         ignore_fore_file:\n           - custom_rule_1\n           - custom_rule_2\n```\n\n----------------------------------------\n\nTITLE: Accessing Inherited Path Parameters in Dart\nDESCRIPTION: This snippet shows how to define a widget that uses an inherited path parameter. The `@pathParam` annotation signals that the parameter is inherited from a parent route, so it should not be passed as a route argument by user.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nclass ProductReviewScreen extends StatelessWidget {\n   // the path-param 'id' will be inherited and it can not be passed\n   // as a route arg by user\n  const ProductReviewScreen({super.key, @pathParam required String id}); \n}\n```\n\n----------------------------------------\n\nTITLE: Using Deep-link Builder (Dart)\nDESCRIPTION: This example demonstrates how to use a deep link builder to validate or override deep links. It only allows deep links starting with `/products`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkBuilder: (deepLink) {\n      if (deepLink.path.startsWith('/products')) {\n        // continue with the platform link\n        return deepLink;\n      } else {\n        return DeepLink.defaultPath;\n        // or DeepLink.path('/')\n        // or DeepLink([HomeRoute()])\n      }\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Path Parameters with AutoRoute in Dart\nDESCRIPTION: This snippet demonstrates how to define a dynamic path segment in an AutoRoute using a colon prefix. The path parameter 'id' can then be extracted and used to navigate to the BookDetailsPage.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(path: '/books/:id', page: BookDetailsPage),\n```\n\n----------------------------------------\n\nTITLE: Annotating a Widget with @RoutePage in Dart\nDESCRIPTION: Annotates a StatefulWidget with @RoutePage(). This annotation allows the router to automatically construct the widget. It indicates that this widget is a routable page and can be used with AutoRoute.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_4\n\nLANGUAGE: Dart\nCODE:\n```\n@RoutePage()\nclass HomeScreen extends StatefulWidget {}\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with RedirectRoute in Dart\nDESCRIPTION: This snippet demonstrates how to redirect from one path to another using `RedirectRoute`. When the path '/' is matched, the user will be automatically redirected to '/books'.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_20\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n     RedirectRoute(path: '/', redirectTo: '/books'),\n     AutoRoute(path: '/books', page: BookListPage),\n ]\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router Using Global Key (Dart)\nDESCRIPTION: This snippet demonstrates how to access an inner router from outside its scope using a `GlobalKey<AutoRouterState>`. The key is associated with an `AutoRouter` widget, and the router is accessed through the key's current state's controller.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatefulWidget {\n  @override\n  _DashboardPageState createState() => _DashboardPageState();\n}\n\nclass _DashboardPageState extends State<DashboardPage> {\n  final _innerRouterKey = GlobalKey<AutoRouterState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: [\n        Column(\n          children: [\n            NavLink(\n              label: 'Users',\n              onTap: () {\n                final router = _innerRouterKey.currentState?.controller;\n                router?.push(const UsersRoute());\n              },\n            ),\n            ...\n          ],\n        ),\n        Expanded(\n          child: AutoRouter(key: _innerRouterKey),\n        ),\n      ],\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ActiveGuardObserver\nDESCRIPTION: Illustrates how to use `ActiveGuardObserver` to monitor guard checks and update the UI accordingly. This example uses it to implement a loading indicator.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_71\n\nLANGUAGE: dart\nCODE:\n```\nvar isLoading = false;\nvoid initState(){\n  final guardObserver = context.router.activeGuardObserver;\n\n  guardObserver.addListener(() {\n    setState((){\n      isLoading = guardObserver.guardInProgress;\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Build Configuration with build.yaml - YAML\nDESCRIPTION: This YAML configuration shows how to configure the `auto_route_generator` in the `build.yaml` file.  This file is required to pass builder configurations to the code generation process.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_52\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n      # configs for @RoutePage() generator ...\n      auto_route_generator:auto_router_generator:\n      # configs for @AutoRouterConfig() generator ...\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with RedirectRoute (Dart)\nDESCRIPTION: This code demonstrates how to redirect paths using `RedirectRoute`. The example shows redirecting from '/' to '/books'.  It requires the AutoRoute package. RedirectRoutes are fully matched.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_28\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  RedirectRoute(path: '/', redirectTo: '/books'),\n  AutoRoute(path: '/books', page: BookListRoute.page),\n]\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Routers (Dart)\nDESCRIPTION: This snippet shows how to access parent routing controllers using `router.parent<T>()`. The generic type `T` specifies the type of the parent router, allowing access to either a `StackRouter` or a `TabsRouter`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_27\n\nLANGUAGE: dart\nCODE:\n```\nrouter.parent<StackRouter>() // this returns  the parent router as a Stack Routing controller\nrouter.parent<TabsRouter>() // this returns the parent router as a Tabs Routing controller\n```\n\n----------------------------------------\n\nTITLE: Global Guards Implementation (After v9)\nDESCRIPTION: This snippet demonstrates the new way to implement global guards in v9 using a `List<AutoRouteGuard>`. This provides a more flexible and manageable approach to route protection.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter{\n  \n  final authGuard = AuthGuard();\n  \n  @override\n  late final List<AutoRouteGuard> guards = [\n    authGuard, ///add  guard instance\n  ///\n   /// or use a simple guard wrapper\n    AutoRouteGuard.simple((resolver, router) {\n        /// guard logic\n    }),\n        \n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Builders in build.yaml\nDESCRIPTION: Illustrates how to configure builders for `auto_route_generator` in the `build.yaml` file. This involves defining targets and specifying which builders should be used for route page and router configuration generation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_64\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n      # configs for @RoutePage() generator ...\n      auto_route_generator:auto_router_generator:\n      # configs for @AutoRouterConfig() generator ...\n```\n\n----------------------------------------\n\nTITLE: Limiting Files for Code Generation - YAML\nDESCRIPTION: This YAML code demonstrates how to specify the files with `_screen.dart` suffix for which the code generator should run, to optimize the generation time. It uses globs to match file names based on patterns.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_55\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**_screen.dart\n```\n\n----------------------------------------\n\nTITLE: Wrapping Routes with AutoRouteWrapper (Dart)\nDESCRIPTION: This demonstrates how to wrap a route with a parent widget by implementing the `AutoRouteWrapper` interface. The `wrappedRoute` method should return the current widget (`this`) as a child of the wrapper widget, allowing you to inject providers or themes. Dependencies: AutoRoute package, flutter widgets.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_38\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass ProductsScreen extends StatelessWidget implements AutoRouteWrapper {\n  \n  @override\n  Widget wrappedRoute(BuildContext context) {\n    return Provider(create: (ctx) => ProductsBloc(), child: this);\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Deep-link Transformer (Dart)\nDESCRIPTION: This code shows how to use a deep link transformer to modify deep links before they are matched. In this example, it strips a prefix from the deep link's path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_17\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: (uri) {\n      if (uri.path.startsWith('/prefix')) {\n        return SynchronousFuture(\n        uri.replace(path: uri.path.replaceFirst('/prefix', '')),\n          );\n      }  \n      return SynchronousFuture(uri);\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Deep Link Builder Example\nDESCRIPTION: This snippet showcases the use of a deep link builder to validate or override incoming deep links. Here, it only allows deep links that start with `/products`, redirecting others to the default path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_29\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkBuilder: (deepLink) {\n      if (deepLink.path.startsWith('/products')) {\n        // continue with the platform link\n        return deepLink;\n      } else {\n        return DeepLink.defaultPath;\n        // or DeepLink.path('/')\n        // or DeepLink([HomeRoute()])\n      }\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: AutoRouterConfig.module() for External Packages in Dart\nDESCRIPTION: This code demonstrates how to use the AutoRouterConfig.module() annotation to generate an AutoRouterModule in an external package. This allows the root router to include routes from that package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_49\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig.module()\nclass MyPackageModule extends $MyPackageModule {}\n```\n\n----------------------------------------\n\nTITLE: Simplified Route Redirection Using Initial Route in Dart\nDESCRIPTION: This snippet shows a simplified way to handle redirection of initial routes by setting the `initial` property to `true`. This generates the necessary redirect code automatically.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n     AutoRoute(path: '/books', page: BookListPage, initial: true),\n ]\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with AutoTabsRouter in Dart\nDESCRIPTION: This example illustrates how to implement tab navigation using the `AutoTabsRouter` widget. It preserves the state of offstage routes and allows for custom transition animations between tabs, with an example of `FadeTransition`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_5\n\nLANGUAGE: dart\nCODE:\n```\nclass DashboardPage extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return AutoTabsRouter(\n      // list of your tab routes\n      // routes used here must be declared as children\n      // routes of /dashboard\n      routes: const [\n        UsersRoute(),\n        PostsRoute(),\n        SettingsRoute(),\n      ],\n      transitionBuilder: (context,child,animation) => FadeTransition(\n            opacity: animation,\n            // the passed child is technically our animated selected-tab page\n            child: child,\n          ),\n      builder: (context, child) {\n        // obtain the scoped TabsRouter controller using context\n        final tabsRouter = AutoTabsRouter.of(context);\n        // Here we're building our Scaffold inside of AutoTabsRouter\n        // to access the tabsRouter controller provided in this context\n        //\n        // alternatively, you could use a global key\n        return Scaffold(\n          body: child,\n          bottomNavigationBar: BottomNavigationBar(\n            currentIndex: tabsRouter.activeIndex,\n            onTap: (index) {\n              // here we switch between tabs\n              tabsRouter.setActiveIndex(index);\n            },\n            items: [\n              BottomNavigationBarItem(label: 'Users', ...),\n              BottomNavigationBarItem(label: 'Posts', ...),\n              BottomNavigationBarItem(label: 'Settings', ...),\n            ],\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: PageView Implementation with AutoTabsRouter in Dart\nDESCRIPTION: This snippet illustrates how to implement tab navigation using a PageView with AutoTabsRouter.pageView. It defines the routes for each tab and uses a builder function to create the Scaffold, AppBar, PageView (represented by the 'child' parameter), and BottomNavigationBar. The BottomNavigationBar controls the PageView's current index using tabsRouter.setActiveIndex.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.pageView(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, _) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books', ...),\n          BottomNavigationBarItem(label: 'Profile', ...),\n          BottomNavigationBarItem(label: 'Settings', ...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using Deep-link Builder Dart\nDESCRIPTION: This snippet shows how to use a deep-link builder to validate or override deep-links.  It checks if the deep-link starts with `/products` and returns the original deep-link if it does, otherwise, it returns a default path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_37\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkBuilder: (deepLink) {\n      if (deepLink.path.startsWith('/products')) {\n        // continue with the platform link\n        return deepLink;\n      } else {\n        return DeepLink.defaultPath;\n        // or DeepLink.path('/')\n        // or DeepLink([HomeRoute()])\n      }\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing AutoRouterObserver in Dart\nDESCRIPTION: This code snippet demonstrates how to extend AutoRouterObserver to create a custom observer that prints route push and tab route events to the console.  It overrides the didPush, didInitTabRoute, and didChangeTabRoute methods to log route information.  This observer is then passed to AutoRouterDelegate.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_27\n\nLANGUAGE: dart\nCODE:\n```\nclass MyObserver extends AutoRouterObserver {          \n  @override          \n  void didPush(Route route, Route? previousRoute) {          \n    print('New route pushed: ${route.settings.name}');          \n  }          \n ...          \n // only override to observer tab routes          \n @override          \n  void didInitTabRoute(TabPageRoute route, TabPageRoute? previousRoute) {          \n    print('Tab route visited: ${route.name}');          \n  }          \n  @override          \n  void didChangeTabRoute(TabPageRoute route, TabPageRoute previousRoute) {          \n    print('Tab route re-visited: ${route.name}');          \n  }          \n  ...          \n}          \n```\n\n----------------------------------------\n\nTITLE: Custom Route Transition Example (TransitionsBuilder)\nDESCRIPTION: Demonstrates how to use a custom route with a predefined transition builder (slideBottom) from the TransitionsBuilders class. It sets the page to LoginRoute and specifies a duration of 400 milliseconds.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_59\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: LoginRoute.page,\n  // TransitionsBuilders class contains a preset of common transitions builders.\n  transitionsBuilder: TransitionsBuilders.slideBottom,\n  duration: Duration(milliseconds: 400),\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Path and Query Parameters in AutoRoute (Dart)\nDESCRIPTION: This snippet shows how to access path and query parameters using the `RouteData` object. It demonstrates accessing parameters through both `RouteData.of(context).pathParams` and the `context.routeData.queryParams` extension. This approach allows accessing route parameters at runtime. Dependencies: AutoRoute package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_26\n\nLANGUAGE: dart\nCODE:\n```\nRouteData.of(context).pathParams;\n// or using the extension\ncontext.routeData.queryParams;\n```\n\n----------------------------------------\n\nTITLE: Custom Route Builder with CustomRoute in Dart\nDESCRIPTION: This snippet demonstrates how to use a custom route builder function with CustomRoute.  The function takes the context, child and CustomPage<T> and returns a PageRouteBuilder.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_48\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: CustomPage,\n  customRouteBuilder: (BuildContext context, Widget child, CustomPage<T> page) {\n    return PageRouteBuilder(\n      fullscreenDialog: page.fullscreenDialog,\n      // this is important\n      settings: page,\n      pageBuilder: (_,__,___) => child,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Using Wildcards in AutoRoute (Dart)\nDESCRIPTION: This code shows how to use wildcards ('*') in AutoRoute to handle undefined paths. It demonstrates using a wildcard to navigate to an `UnknownRoute`, a route with a prefix, and redirecting with a wildcard. Wildcards should be placed at the end of the route list.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_31\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '*',\n  page: UnknownRoute.page,\n)\n// it could be used with defined prefixes\nAutoRoute(\n  path: '/profile/*',\n  page: ProfileRoute.page,\n)\n// or it could be used with RedirectRoute\nRedirectRoute(\n  path: '*',\n  redirectTo: '/',\n)\n```\n\n----------------------------------------\n\nTITLE: Passing Observer to AutoRouterDelegate in Dart\nDESCRIPTION: This code snippet shows how to pass a custom AutoRouterObserver to the AutoRouterDelegate using the navigatorObservers property. The navigatorObservers property is a builder function that returns a list of observers. It's important to always return fresh observer instances unless you are using a single router or don't want nested routers to inherit observers.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_28\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(          \n      routerDelegate: AutoRouterDelegate(          \n        _appRouter,          \n        navigatorObservers: () => [MyObserver()],          \n      ),          \n      routeInformationParser: _appRouter.defaultRouteParser(),          \n    );          \n```\n\n----------------------------------------\n\nTITLE: Configuring Builders in build.yaml\nDESCRIPTION: This YAML snippet shows the basic structure for configuring builders in a build.yaml file. It defines the targets and builders for auto_route_generator.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_52\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n      # configs for @RoutePage() generator ...\n      auto_route_generator:auto_router_generator:\n      # configs for @AutoRouterConfig() generator ...\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with Parameters (Dart)\nDESCRIPTION: This snippet illustrates how to redirect paths that contain parameters. The example shows redirecting from 'books/:id' to '/books/:id/details', preserving the 'id' parameter. Requires the AutoRoute package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_30\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  RedirectRoute(path: 'books/:id', redirectTo: '/books/:id/details'),\n  AutoRoute(path: '/books/:id/details', page: BookDetailsRoute.page),\n]\n```\n\n----------------------------------------\n\nTITLE: Inherited Path Parameter\nDESCRIPTION: Demonstrates how to inherit a path parameter from a parent route using `@PathParam.inherit`. In this example, ProductReviewScreen inherits the 'id' parameter from the parent route `/product/:id`, which means this param cant be passed as a route arg.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_33\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/product/:id',\n  page: ProductRoute.page,\n  children: [\n    AutoRoute(path: 'review',page: ProductReviewRoute.page),\n  ],\n)\n\n@RoutePage()\nclass ProductReviewScreen extends StatelessWidget {\n  // the path-param 'id' will be inherited and it can not be passed\n  // as a route arg by user\n  const ProductReviewScreen({super.key, @PathParam.inherit('id') required String id});\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping a Route with AutoRouteWrapper in Dart\nDESCRIPTION: This code snippet shows how to wrap a screen with a parent widget using the AutoRouteWrapper interface. It implements the wrappedRoute method to return the screen as the child of a Provider widget, allowing the screen to access values provided by the Provider.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_54\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass ProductsScreen extends StatelessWidget implements AutoRouteWrapper {\n  \n  @override\n  Widget wrappedRoute(BuildContext context) {\n    return Provider(create: (ctx) => ProductsBloc(), child: this);\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Router with AutoRouter.of (Dart)\nDESCRIPTION: This code snippet illustrates how to obtain a scoped routing controller using `AutoRouter.of(context)` within a StatelessWidget.  It demonstrates accessing the root routing controller and how `AutoRouter` inserts a new router scope into the widgets tree for nested routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {              \n             \n  @override              \n  Widget build(BuildContext context) {              \n  // this will get us the root routing controller              \n    AutoRouter.of(context);              \n    return Scaffold(              \n      appBar: AppBar(title: Text('Dashboard page')),               \n      // this inserts a new router scope into the widgets tree              \n      body: AutoRouter()               \n    );              \n  }              \n}\n```\n\n----------------------------------------\n\nTITLE: Providing AutoRouteObserver in Dart\nDESCRIPTION: This snippet shows how to provide an AutoRouteObserver to MaterialApp.router. This observer is then used by AutoRouteAware widgets to listen to route events.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_43\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(\n  routerConfig: _appRouter.config(\n    navigatorObservers: () => [AutoRouteObserver()],\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Assigning a Guard to a Route (Dart)\nDESCRIPTION: This shows how to assign a route guard to a specific route using the `guards` parameter in `AutoRoute`. This ensures that the specified guard will be executed before the route can be accessed.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_33\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  page: ProfileRoute.page,\n  guards: [AuthGuard()],\n);\n```\n\n----------------------------------------\n\nTITLE: Using a Reevaluate Listenable with AuthProvider in Dart\nDESCRIPTION: This snippet demonstrates how to use a Reevaluate Listenable to re-evaluate the stack when the authentication state changes. It shows how to pass an instance of AuthProvider (which extends ChangeNotifier) to the reevaluateListenable property in the router configuration. The AuthProvider is a mock implementation demonstrating the use of notifyListeners() to trigger the re-evaluation of route guards.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_52\n\nLANGUAGE: dart\nCODE:\n```\nclass AuthProvider extends ChangeNotifier {\n  bool _isLoggedIn = false;\n\n  bool get isLoggedIn => _isLoggedIn;\n\n  void login() {\n    _isLoggedIn = true;\n    notifyListeners();\n  }\n\n  void logout() {\n    _isLoggedIn = false;\n    notifyListeners();\n  }\n}\n```\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    reevaluateListenable: authProvider,\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Redirecting Paths with Parameters using RedirectRoute in Dart\nDESCRIPTION: This snippet demonstrates how to redirect paths while preserving parameters. When a path like 'books/:id' is matched, the user is redirected to '/books/:id/details', maintaining the value of 'id'.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_22\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n     RedirectRoute(path: 'books/:id', redirectTo: '/books/:id/details'),\n     AutoRoute(path: '/books/:id/details', page: BookDetailsPage),\n ]\n```\n\n----------------------------------------\n\nTITLE: Custom Route Builder Implementation Dart\nDESCRIPTION: Provides an implementation for a custom route builder function.  This function creates a PageRouteBuilder, setting its fullscreenDialog and settings properties using the CustomPage, and its pageBuilder property returns the child widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_38\n\nLANGUAGE: dart\nCODE:\n```\nRoute<T> myCustomRouteBuilder<T>(BuildContext context, Widget child, CustomPage<T> page){\n  return PageRouteBuilder(\n  fullscreenDialog: page.fullscreenDialog,\n  // this is important\n  settings: page,\n  pageBuilder: (,__,___) => child);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Route-Aware Screens with AutoRouteAware in Dart\nDESCRIPTION: This Dart code snippet shows how to make a screen route-aware by using the `AutoRouteAware` mixin and subscribing to an `AutoRouteObserver`. The `didChangeDependencies` method subscribes to the observer, while the `dispose` method unsubscribes. It also overrides several methods like `didPush`, `didPop` etc., to listen to navigation events.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_45\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAware {\n  AutoRouteObserver? _observer;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // RouterScope exposes the list of provided observers\n    // including inherited observers\n    _observer = RouterScope.of(context).firstObserverOfType<AutoRouteObserver>();\n    if (_observer != null) {\n      // we subscribe to the observer by passing our\n      // AutoRouteAware state and the scoped routeData\n      _observer.subscribe(this, context.routeData);\n    }\n  }\n\n @override\n  void dispose() {\n    super.dispose();\n    // don't forget to unsubscribe from the\n    // observer on dispose\n    _observer.unsubscribe(this);\n  }\n\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  @override\n  void didPopNext() {}\n\n  @override\n  void didPushNext() {}\n\n  @override\n  void didPush() {}\n\n  @override\n  void didPop() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Routes with AutoRoute in Flutter\nDESCRIPTION: This code snippet demonstrates how to define nested routes using AutoRoute.  The `children` property of a route is used to define nested routes. This example creates a dashboard route with users, posts, and settings as nested children routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(replaceInRouteName: 'Page,Route')\nclass AppRouter extends RootStackRouter {\n\n@override\nList<AutoRoute> get routes => [\n    AutoRoute(\n      path: '/dashboard',\n      page: DashboardRoute.page,\n      children: [\n        AutoRoute(path: 'users', page: UsersRoute.page),\n        AutoRoute(path: 'posts', page: PostsRoute.page),\n        AutoRoute(path: 'settings', page: SettingsRoute.page),\n      ],\n    ),\n    AutoRoute(path: '/login', page: LoginRoute.page),\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tab Navigation with PageView (Dart)\nDESCRIPTION: This snippet shows how to use `AutoTabsRouter.pageView` to create tab navigation using a `PageView`. This approach provides a different user experience where tabs can be swiped.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\nAutoTabsRouter.pageView(\n  routes: [\n    BooksTab(),\n    ProfileTab(),\n    SettingsTab(),\n  ],\n  builder: (context, child, _) {\n    final tabsRouter = AutoTabsRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(context.topRoute.name),\n        leading: AutoLeadingButton(),\n      ),\n      body: child,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: tabsRouter.activeIndex,\n        onTap: tabsRouter.setActiveIndex,\n        items: [\n          BottomNavigationBarItem(label: 'Books', ...),\n          BottomNavigationBarItem(label: 'Profile', ...),\n          BottomNavigationBarItem(label: 'Settings', ...),\n        ],\n      ),\n    );\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Limiting Files for @RoutePage and @AutoRouterConfig- YAML\nDESCRIPTION: This YAML configuration demonstrates how to specify different file sets for `@RoutePage` and `@AutoRouterConfig` annotations during code generation, using the `generate_for` option. This allows for finer control over which files are processed by each generator.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_56\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router from Outside Scope (Dart)\nDESCRIPTION: This snippet shows how to access the inner router of the `DashboardPage` from the `Dashboard` widget using `context.innerRouterOf<StackRouter>(DashboardRoute.name)`. This allows pushing a new route into the inner router's stack.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_14\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Dashboard'),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.person),\n            onPressed: () {\n              // accessing the inner router from\n              // outside the scope\n              final router = context.innerRouterOf<StackRouter>(DashboardRoute.name)\n              router?.push(const UsersRoute());\n            },\n          ),\n        ],\n      ),\n      body: AutoRouter(), // we're trying to get access to this\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating Without Context using get_it (Dart)\nDESCRIPTION: This code demonstrates navigating without context using the `get_it` dependency injection package. The `AppRouter` is registered as a singleton, allowing it to be accessed from anywhere in the app without using context. This approach improves testability and reduces coupling.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nvoid main(){          \n// make sure you register it as a Singleton or a lazySingleton          \n  getIt.registerSingleton<AppRouter>(AppRouter());          \n  runApp(MyApp());          \n }          \n          \nclass MyApp extends StatefulWidget {          \n  @override          \n  Widget build(BuildContext context) {          \n    final router = getIt<AppRouter>();          \n    return MaterialApp.router(          \n      routerDelegate: AutoRouterDelegate(router),          \n      routeInformationParser: router.defaultRouteParser(),          \n      );          \n    }\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAwareStateMixin in Dart\nDESCRIPTION: This shows a simplified version of AutoRouteAware usage using `AutoRouteAwareStateMixin`. It handles subscription and unsubscription automatically, requiring fewer overrides.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_45\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAwareStateMixin<BookListPage> {\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  // only override if this is a stack page\n  @override\n  void didPopNext() {}\n  \n  // only override if this is a stack page\n  @override\n  void didPushNext() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nested Routers with inheritNavigatorObservers in Dart\nDESCRIPTION: This demonstrates setting up AutoRouter and AutoTabsRouter with inheritNavigatorObservers set to true (default), allowing them to inherit observers from their parent. The navigatorObservers property can provide additional observers for each router.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_42\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter(\n  inheritNavigatorObservers: true, // true by default\n  navigatorObservers:() => [list of observers],\n);\n\nAutoTabsRouter(\n  inheritNavigatorObservers: true, // true by default\n  navigatorObservers:() => [list of observers],\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router with context.innerRouterOf (Dart)\nDESCRIPTION: This code shows how to access an inner router from outside its scope using the `context.innerRouterOf<T>(routeName)` method, as long as it has been initiated.  The router type, `StackRouter` or `TabsRouter`, needs to be specified.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_8\n\nLANGUAGE: dart\nCODE:\n```\n// assuming this's the root router              \ncontext.innerRouterOf<StackRouter>(UserRoute.name)               \n// or if we're usign an AutoTabsRouter inside of DashboardPage          \ncontext.innerRouterOf<TabsRouter>(UserRoute.name)\n```\n\n----------------------------------------\n\nTITLE: Enabling Cached Builds in auto_route_generator\nDESCRIPTION: This snippet demonstrates how to enable cached builds for both auto_route_generator and auto_router_generator within the `build.yaml` file.  Enabling cached builds attempts to prevent redundant re-builds by analyzing changes for their impact on route information.  The `enable_cached_builds` option is set to `true` for each builder.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_57\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Routers with Type Casting (Dart)\nDESCRIPTION: This code snippet illustrates how to access parent routing controllers using the `router.parent<T>()` method. It shows examples of casting the parent router to `StackRouter` and `TabsRouter`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\nrouter.parent<StackRouter>() // this returns  the parent router as a Stack Routing controller\nrouter.parent<TabsRouter>() // this returns the parent router as a Tabs Routing controller\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router in Dashboard (Dart)\nDESCRIPTION: This example demonstrates accessing the inner router of the `DashboardPage` using `context.innerRouterOf<StackRouter>(DashboardRoute.name)` from a widget within the `DashboardPage`'s scope.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {              \n            \n  @override              \n  Widget build(BuildContext context) {              \n    return Scaffold(              \n      appBar: AppBar(              \n        title: Text('Dashboard'),              \n        actions: [              \n          IconButton(              \n            icon: Icon(Icons.person),              \n            onPressed: () {              \n              // accessing the inner router from              \n              // outside the scope              \n              final router = context.innerRouterOf<StackRouter>(DashboardRoute.name)          \n              router?.push(const UsersRoute());              \n            },              \n          ),              \n        ],              \n      ),              \n      body: AutoRouter(), // we're trying to get access to this              \n    );              \n  }              \n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAware Mixin in Dart\nDESCRIPTION: This code snippet demonstrates how to use the AutoRouteAware mixin to make a screen route-aware and subscribe to an AutoRouteObserver.  It overrides the didChangeDependencies and dispose methods to subscribe to and unsubscribe from the observer, allowing the screen to receive notifications about route changes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_57\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAware {\n  AutoRouteObserver? _observer;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // RouterScope exposes the list of provided observers\n    // including inherited observers\n    _observer = RouterScope.of(context).firstObserverOfType<AutoRouteObserver>();\n    if (_observer != null) {\n      // we subscribe to the observer by passing our\n      // AutoRouteAware state and the scoped routeData\n      _observer.subscribe(this, context.routeData);\n    }\n  }\n\n @override\n  void dispose() {\n    super.dispose();\n    // don't forget to unsubscribe from the\n    // observer on dispose\n    _observer.unsubscribe(this);\n  }\n\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  @override\n  void didPopNext() {}\n\n  @override\n  void didPushNext() {}\n\n  @override\n  void didPush() {}\n\n  @override\n  void didPop() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Declarative Navigation with AutoRouter.declarative (Dart)\nDESCRIPTION: This snippet showcases declarative navigation using the `AutoRouter.declarative` constructor. The routes are dynamically generated based on the application's state, providing a reactive and state-driven navigation system.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_12\n\nLANGUAGE: dart\nCODE:\n```\nAutoRouter.declarative(      \n  routes: (handler) => [      \n     BookListRoute(),      \n     if(_selectedBook != null)      \n     BookDetailsRoute(id: _selectedBook.id),      \n ],);\n```\n\n----------------------------------------\n\nTITLE: Deep Link Transformer Example Dart\nDESCRIPTION: This code snippet showcases how to use the `deepLinkTransformer` to parse URIs for deep links before route matching. It's particularly useful for handling intent-filter prefixes on Android. The example demonstrates stripping a 'FILTER' prefix from the URI.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/CHANGELOG.md#_snippet_1\n\nLANGUAGE: dart\nCODE:\n```\nRouterConfig `<UrlState>` config({\ndeepLinkTransformer : Deelkink.prefixStripper('FILTER'),\n})\n\n```\n\n----------------------------------------\n\nTITLE: Using @pathParam Const Annotation in Dart\nDESCRIPTION: This snippet demonstrates using the `@pathParam` constant annotation when the parameter name matches the path parameter name, simplifying the code and avoiding the need to pass an alias.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@pathParam this.id});\n\n  final int id;\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Passing Route Guards as Instances (Dart)\nDESCRIPTION: This snippet illustrates the change in how route guards are passed. Instead of passing guards as types, you now pass instances of the guard classes, allowing parameters to be passed to the guard.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_63\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(page: ProfilePage, guards:[AuthGuard(<params>)]) // as Instance\n```\n\n----------------------------------------\n\nTITLE: Using Deep-link Transformer Dart\nDESCRIPTION: This snippet demonstrates how to use a deep-link transformer to modify deep-links before they are processed.  In this example, it removes a specified prefix from the deep-link's path.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_35\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: (uri) {\n      if (uri.path.startsWith('/prefix')) {\n        return SynchronousFuture(\n        uri.replace(path: uri.path.replaceFirst('/prefix', '')),\n          );\n      }  \n      return SynchronousFuture(uri);\n    }\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Redirecting to Nested Route using RedirectRoute in Flutter AutoRoute\nDESCRIPTION: This snippet demonstrates how to redirect from the parent route to a specific child route, using a `RedirectRoute` with an empty path. Navigating to `/dashboard` will redirect to the `/dashboard/users` route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_19\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    RedirectRoute(path: '', redirectTo: 'users'),\n    AutoRoute(path: 'users', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Adding AutoRoute dependencies using flutter pub add\nDESCRIPTION: Adds the necessary dependencies for AutoRoute and its code generator using the flutter pub add command. This includes auto_route for the core routing functionality, auto_route_generator for generating route code, and build_runner to execute the code generation process. The `dev:` prefix indicates that these dependencies are only required during development.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_1\n\nLANGUAGE: Terminal\nCODE:\n```\nflutter pub add auto_route dev:auto_route_generator dev:build_runner\n```\n\n----------------------------------------\n\nTITLE: Custom Route Builder Implementation - Dart\nDESCRIPTION: This snippet shows how to use a custom route builder function with `CustomRoute`. It demonstrates the implementation of the builder function, ensuring the page argument is passed to the custom route. It's important to specify the return type `<T>` for the custom route builder function.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_49\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: CustomPage,\n  customRouteBuilder: <T>(BuildContext context, Widget child, AutoRoutePage<T> page) {\n    return PageRouteBuilder<T>(\n      fullscreenDialog: page.fullscreenDialog,\n      // this is important\n      settings: page,\n      pageBuilder: (_,__,___) => child,\n    );\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Route Return Type When Pushing Route (After v9)\nDESCRIPTION: This snippet shows how to specify the return type when pushing a route in v9. The return type should now be provided directly when calling `context.pushRoute<ReturnType>()`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_3\n\nLANGUAGE: dart\nCODE:\n```\n/// provide the return type as you push your page\nbool didLogin = await context.pushRoute<bool>();\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Shell Routes with EmptyShellRoute Helper in Flutter\nDESCRIPTION: This code snippet demonstrates how to create a shell route without code generation using the `EmptyShellRoute` helper.  This provides a simplified way to create empty shell routes for tab-based navigation or similar scenarios.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_21\n\nLANGUAGE: dart\nCODE:\n```\nconst BooksTab = EmptyShellRoute('BooksTab');\ncontext.push(BooksTab());\n```\n\n----------------------------------------\n\nTITLE: Enabling Cached Builds\nDESCRIPTION: Illustrates how to enable cached builds to prevent redundant rebuilds by analyzing file changes. This feature is experimental and needs to be enabled on both generators.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_68\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Accessing Inner Router Without Global Key (Dart)\nDESCRIPTION: This snippet shows how to access an inner router without a global key using the `context.innerRouterOf<T>(routeName)` extension method, as long as the router has already been initiated.  It supports both `StackRouter` and `TabsRouter`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_13\n\nLANGUAGE: dart\nCODE:\n```\n// assuming this is the root router\ncontext.innerRouterOf<StackRouter>(UserRoute.name);\n// or if we're using an AutoTabsRouter inside of DashboardPage\ncontext.innerRouterOf<TabsRouter>(UserRoute.name);\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Routing Controller in Dashboard Widget (Dart)\nDESCRIPTION: This code demonstrates how to obtain the root routing controller within a `Dashboard` widget using `AutoRouter.of(context)`. It also shows how `AutoRouter` inserts a new router scope into the widget tree for nested routes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_9\n\nLANGUAGE: dart\nCODE:\n```\nclass Dashboard extends StatelessWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    // this will get us the root routing controller\n    AutoRouter.of(context);\n    return Scaffold(\n      appBar: AppBar(title: Text('Dashboard page')),\n      // this inserts a new router scope into the widgets tree\n      body: AutoRouter()\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoLeadingButton in AppBar Dart\nDESCRIPTION: Shows how to use AutoLeadingButton as a replacement for the default BackButton within an AppBar. It assigns an instance of AutoLeadingButton to the leading property of the AppBar.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_40\n\nLANGUAGE: dart\nCODE:\n```\nappBar: AppBar(\n  title: Text(context.topRoute.name),\n  leading: AutoLeadingButton(),\n)\n```\n\n----------------------------------------\n\nTITLE: Using @pathParam Annotation in StatelessWidget (Dart)\nDESCRIPTION: This snippet shows the usage of `@pathParam` const to access the same path/query parameter. Use `@pathParam` when parameter name and path/query parameter are same.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_27\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass BookDetailsPage extends StatelessWidget {\n  const BookDetailsPage({@pathParam this.id});\n\n  final int id;\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Files for Code Generation - YAML\nDESCRIPTION: This YAML code demonstrates how to specify the files for which the code generator should run, to optimize the generation time. It uses globs to match file names based on patterns.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_54\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**.dart\n```\n\n----------------------------------------\n\nTITLE: Providing AutoRouteObserver Instance in Dart\nDESCRIPTION: This code demonstrates how to provide an AutoRouteObserver instance to the AutoRouterDelegate. This observer is used to make screens route aware.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_31\n\nLANGUAGE: dart\nCODE:\n```\nreturn MaterialApp.router(          \n      routerDelegate: AutoRouterDelegate(          \n        _appRouter,          \n       // Provide an AutoRouteObserver instance          \n        navigatorObservers: () => [AutoRouteObserver()],          \n      ),          \n      routeInformationParser: _appRouter.defaultRouteParser(),          \n    );          \n```\n\n----------------------------------------\n\nTITLE: Adding AutoRoute dependencies in pubspec.yaml\nDESCRIPTION: Adds the necessary dependencies for AutoRoute and its code generator to the pubspec.yaml file. This includes auto_route for the core routing functionality, auto_route_generator for generating route code, and build_runner to execute the code generation process.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\ndependencies:\n  auto_route: [latest-version]\n\ndev_dependencies:\n  auto_route_generator: [latest-version]\n  build_runner:\n```\n\n----------------------------------------\n\nTITLE: Inheriting Path Parameters in AutoRoute (Dart)\nDESCRIPTION: This code snippet demonstrates how to inherit a path parameter from a parent route's path using the `@PathParam.inherit` annotation in the child route's constructor. It shows a parent route with a path parameter ':id' and a child route inheriting that parameter. Dependencies: AutoRoute package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/product/:id',\n  page: ProductRoute.page,\n  children: [\n    AutoRoute(path: 'review',page: ProductReviewRoute.page),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Using DeepLink.prefixStripper Dart\nDESCRIPTION: This snippet uses the built-in `DeepLink.prefixStripper` to remove a prefix from deep links. It simplifies the process compared to a custom transformer.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_36\n\nLANGUAGE: dart\nCODE:\n```\nMaterialApp.router(\n  routerConfig: _appRouter.config(\n    deepLinkTransformer: DeepLink.prefixStripper('prefix'),\n  ),\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Root Router Without Type Casting (Dart)\nDESCRIPTION: This code shows how to access the root router using the `router.root` property, which always returns a `StackRouter` without requiring type casting.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_11\n\nLANGUAGE: dart\nCODE:\n```\nrouter.root // this returns the root router as a Stack Routing controller\n```\n\n----------------------------------------\n\nTITLE: Navigating Without Context with GetIt (Dart)\nDESCRIPTION: This example showcases how to use the `get_it` dependency injection package to access the router without context. The `AppRouter` is registered as a singleton, and then retrieved in the `MyApp` widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\nvoid main(){\n  // make sure you register it as a Singleton or a lazySingleton\n  getIt.registerSingleton<AppRouter>(AppRouter());\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appRouter = getIt<AppRouter>();\n\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Routes with Inherited Path Parameters in Dart\nDESCRIPTION: This snippet demonstrates how nested routes can inherit path parameters from parent routes. The `ProductReviewScreen` inherits the 'id' parameter from the `/product/:id` route, avoiding the need to redefine it.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_16\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n\t  path: '/product/:id',\n\t  page: ProductScreen,\n\t  children: [\n\t\t  AutoRoute(path: 'review',page: ProductReviewScreen),\n\t ],\n ),\n```\n\n----------------------------------------\n\nTITLE: Extracting Path Parameters using @PathParam Annotation in Dart\nDESCRIPTION: This snippet shows how to extract a path parameter (e.g., 'id') by annotating a constructor parameter with `@PathParam('id')`. The AutoRoute library automatically injects the parameter value into the widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\nclass BookDetailsPage extends StatelessWidget { \n  const BookDetailsPage({@PathParam('id') this.bookId});\n\n  final int bookId;\n  ...\n\n```\n\n----------------------------------------\n\nTITLE: Micro Router Export - Dart\nDESCRIPTION: This code demonstrates how to export a micro-router in `app_router.dart`, so you only need to import `app_router.dart` in your code, simplifying imports.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_51\n\nLANGUAGE: dart\nCODE:\n```\n// ...imports\nexport 'package:my_package/my_micro_router.dart'\n@AutoRouterConfig()\nclass AppRouter extends RootStackRouter {}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transition with Preset Builder Dart\nDESCRIPTION: Demonstrates using a preset transition builder from TransitionsBuilders for a custom route in auto_route. It specifies the LoginScreen as the page and slideBottom as the transition, with a 400ms duration.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_34\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\npage: LoginScreen,\n//TransitionsBuilders class contains a preset of common transitions builders. \ntransitionsBuilder: TransitionsBuilders.slideBottom,\ndurationInMilliseconds: 400)\n```\n\n----------------------------------------\n\nTITLE: Simplified Redirect with Initial Route (Dart)\nDESCRIPTION: This example shows how to simplify redirecting to an initial route. Setting `initial: true` on the desired route eliminates the need for a separate `RedirectRoute`. This simplifies the route configuration.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_29\n\nLANGUAGE: dart\nCODE:\n```\n<AutoRoute> [\n  AutoRoute(path: '/books', page: BookListRoute.page, initial: true),\n]\n```\n\n----------------------------------------\n\nTITLE: Custom Route Builder Type Definition Dart\nDESCRIPTION: Defines the type alias for a custom route builder function.  This function must accept a BuildContext, a Widget, and a CustomPage, and it must return a Route.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_37\n\nLANGUAGE: dart\nCODE:\n```\ntypedef CustomRouteBuilder = Route<T> Function<T>(\n  BuildContext context, Widget child, CustomPage page);\n```\n\n----------------------------------------\n\nTITLE: Stopping Route Re-evaluation (Dart)\nDESCRIPTION: This demonstrates how to stop the re-evaluation of pending routes using `resolver.resolveNext(didLogin, reevaluateNext: false)`.  This allows fine-grained control over which routes are re-evaluated after a state change.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_37\n\nLANGUAGE: dart\nCODE:\n```\n@override\nvoid onNavigation(NavigationResolver resolver, StackRouter router) async {\n  if (authProvider.isAuthenticated) {\n    resolver.next();\n  } else {\n    resolver.redirect(\n      WebLoginRoute(\n        onResult: (didLogin) {\n          // stop re-pushing any pending routes after current\n          resolver.resolveNext(didLogin, reevaluateNext: false);\n        },\n      ),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AutoRouteAware mixin in Dart\nDESCRIPTION: This code demonstrates how to use the AutoRouteAware mixin in a StatefulWidget to subscribe to an AutoRouteObserver. It overrides didChangeDependencies to subscribe and dispose to unsubscribe.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_44\n\nLANGUAGE: dart\nCODE:\n```\nclass BooksListPage extends State<BookListPage> with AutoRouteAware {\n  AutoRouteObserver? _observer;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // RouterScope exposes the list of provided observers\n    // including inherited observers\n    _observer = RouterScope.of(context).firstObserverOfType<AutoRouteObserver>();\n    if (_observer != null) {\n      // we subscribe to the observer by passing our\n      // AutoRouteAware state and the scoped routeData\n      _observer.subscribe(this, context.routeData);\n    }\n  }\n\n @override\n  void dispose() {\n    super.dispose();\n    // don't forget to unsubscribe from the\n    // observer on dispose\n    _observer.unsubscribe(this);\n  }\n\n  // only override if this is a tab page\n  @override\n  void didInitTabRoute(TabPageRoute? previousRoute) {}\n\n  // only override if this is a tab page\n  @override\n  void didChangeTabRoute(TabPageRoute previousRoute) {}\n\n  @override\n  void didPopNext() {}\n\n  @override\n  void didPushNext() {}\n\n  @override\n  void didPush() {}\n\n  @override\n  void didPop() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transition with Custom Builder Usage Dart\nDESCRIPTION: Illustrates how to use a custom transition builder function with a custom route.  It passes a reference to the `zoomInTransition` function to the `transitionsBuilder` property of the `CustomRoute` widget.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_36\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(page: ZoomInScreen, transitionsBuilder: zoomInTransition)\n```\n\n----------------------------------------\n\nTITLE: Migrating to AutoRouterConfig (Dart)\nDESCRIPTION: This code snippet illustrates the changes required to migrate from `MaterialAutoRouter`, `CupertinoAutoRouter`, etc. to the new `@AutoRouterConfig` annotation.  It shows how to override the `routes` getter and `defaultRouteType` to define routes and their types within the generated router class.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_60\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends $AppRouter {\n\n  @override\n  RouteType get defaultRouteType => RouteType.material(); //.cupertino, .adaptive ..etc\n\n  @override\n  List<AutoRoute> get routes => [\n    // routes go here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transitions with custom transitionsBuilder in Dart\nDESCRIPTION: This code shows how to use a custom transitionsBuilder function with CustomRoute. The function takes the context, animation objects, and child widget to create a custom transition (ScaleTransition).\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_47\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(\n  page: ZoomInScreen,\n  transitionsBuilder:\n    (BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child) {\n      // you get an animation object and a widget\n      // make your own transition\n      return ScaleTransition(scale: animation, child: child);\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: ActiveGuardObserver Usage Dart\nDESCRIPTION: Demonstrates how to use ActiveGuardObserver to monitor guard status changes. An isLoading variable is updated when the guardInProgress state changes.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_41\n\nLANGUAGE: dart\nCODE:\n```\nvar isLoading = false;\n void initState(){\n    final guardObserver = context.router.activeGuardObserver;\n\n    guardObserver.addListener(() { \n      setState((){\n        isLoading = guardObserver.guardInProgress;\n       });\n    });\n  }\n```\n\n----------------------------------------\n\nTITLE: Enabling Cached Builds in build.yaml - YAML\nDESCRIPTION: This YAML configuration shows how to enable cached builds for both the `auto_route_generator` and `auto_router_generator`. Cached builds prevent redundant rebuilds by analyzing changes in files and skipping code generation if the route information hasn't changed.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_57\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        options:\n          enable_cached_builds: true\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Generating a part-of file in Dart\nDESCRIPTION: Demonstrates how to generate a part-of file by adding a `part` directive to the `AppRouter` class. Note that the `deferredLoading` functionality is not supported with this setup.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_3\n\nLANGUAGE: Dart\nCODE:\n```\n// part 'app_router.g.dart'; // Example of how to include the generated part file\n```\n\n----------------------------------------\n\nTITLE: Including an AutoRouterModule in the Root Router in Dart\nDESCRIPTION: This snippet shows how to include a generated AutoRouterModule from an external package in the root router using the modules property of the AutoRouterConfig annotation.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_50\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(modules: [MyPackageModule])\nclass AppRouter extends $AppRouter {}\n```\n\n----------------------------------------\n\nTITLE: Running the Build Runner One Time - Terminal\nDESCRIPTION: This command runs the `build_runner` once, generating the code and then exiting. It's useful for CI/CD pipelines or when you only need to generate the code once.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/README.md#_snippet_5\n\nLANGUAGE: terminal\nCODE:\n```\ndart run build_runner build\n```\n\n----------------------------------------\n\nTITLE: Limiting processed files with a naming convention in build.yaml\nDESCRIPTION: Shows how to use a naming convention to only process files ending in `_screen.dart`\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_55\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**_screen.dart\n```\n\n----------------------------------------\n\nTITLE: Using AutoLeadingButton in AppBar (Dart)\nDESCRIPTION: This snippet shows how to use `AutoLeadingButton` as a replacement for the default `BackButton` in an `AppBar`. It handles nested or parent stack popping. It's assigned to the `leading` property of the `AppBar`.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_58\n\nLANGUAGE: dart\nCODE:\n```\nAppBar(\n  title: Text(context.topRoute.name),\n  leading: AutoLeadingButton(),\n)\n```\n\n----------------------------------------\n\nTITLE: Replacing EmptyRoutePage with AutoRouter (Dart)\nDESCRIPTION: This snippet demonstrates how to replace `EmptyRoutePage` by extending the `AutoRouter` widget and annotating it with `@RoutePage`. The `name` parameter is passed to `@RoutePage`. Then, the generated `.page` getter is used.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_62\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage(name: 'ProductsRouter')\nclass ProductsRouterPage extends AutoRouter {}\n\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(page: ProductsRouter.page)\n```\n\n----------------------------------------\n\nTITLE: Global Router Initialization\nDESCRIPTION: This code snippet demonstrates how to declare and initialize the AppRouter as a global variable, allowing access to the router without requiring a build context. It is generally discouraged due to potential maintainability issues, favoring dependency injection instead.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_24\n\nLANGUAGE: dart\nCODE:\n```\n// declare your route as a global variable\nfinal appRouter = AppRouter();\n\nclass MyApp extends StatefulWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom ignore_for_file rules in build.yaml - YAML\nDESCRIPTION: This YAML configuration demonstrates how to add custom `ignore_for_file` rules to the generated router using the `build.yaml` file. This can be used to suppress linter warnings in the generated code.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_53\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_router_generator:\n       options:\n         ignore_fore_file:\n           - custom_rule_1\n           - custom_rule_2\n```\n\n----------------------------------------\n\nTITLE: Inheriting Path Parameter in StatelessWidget (Dart)\nDESCRIPTION: This snippet illustrates how to use the inherited path parameter in a StatelessWidget. The `@PathParam.inherit('id')` annotation is used to specify that the 'id' parameter is inherited from the parent route. The 'id' parameter is required and cannot be passed as a route argument. Dependencies: AutoRoute package.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_25\n\nLANGUAGE: dart\nCODE:\n```\n@RoutePage()\nclass ProductReviewScreen extends StatelessWidget {\n  // the path-param 'id' will be inherited and it can not be passed\n  // as a route arg by user\n  const ProductReviewScreen({super.key, @PathParam.inherit('id') required String id});\n}\n```\n\n----------------------------------------\n\nTITLE: Navigating Without Context using Global Variable (Dart)\nDESCRIPTION: This snippet illustrates navigating without context by assigning the generated router to a global variable. While functional, it's noted that using global variables is generally not recommended.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_10\n\nLANGUAGE: dart\nCODE:\n```\n// declarate your route as a global vairable          \nfinal appRouter = AppRouter();            \n          \nclass MyApp extends StatefulWidget {          \n          \n  @override          \n  Widget build(BuildContext context) {          \n    return MaterialApp.router(          \n      routerDelegate: AutoRouterDelegate(appRouter),          \n      routeInformationParser: appRouter.defaultRouteParser(),          \n      );          \n    }\n```\n\n----------------------------------------\n\nTITLE: Specifying different generate_for rules for RoutePage and AutoRouterConfig in build.yaml\nDESCRIPTION: This YAML snippet shows how to specify different `generate_for` rules for @RoutePage and @AutoRouterConfig builders in the build.yaml file.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_56\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator: # this for @RoutePage\n        generate_for:\n          - lib/ui/**_screen.dart\n      auto_route_generator:auto_router_generator: # this for @AutoRouterConfig\n        generate_for:\n          - lib/ui/router.dart\n```\n\n----------------------------------------\n\nTITLE: Declaring Named Routes in Dart\nDESCRIPTION: Declares a named route using NamedRouteDef without code generation.  It requires a name and an optional path.  The builder function constructs the page with the route's parameters.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_9\n\nLANGUAGE: Dart\nCODE:\n```\n  NamedRouteDef(\n    name: 'BookDetailsRoute',\n    path: '/books/:id', // optional\n    builder: (context, data) {\n      return BookDetailsPage(id: data.params.getInt('id'));\n    },\n  ),\n```\n\n----------------------------------------\n\nTITLE: Navigating Without Context with Global Variable (Dart)\nDESCRIPTION: This code snippet demonstrates how to navigate without context by assigning the generated router to a global variable. While functional, the documentation advises against this approach in favor of dependency injection.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_15\n\nLANGUAGE: dart\nCODE:\n```\n// declare your route as a global variable\nfinal appRouter = AppRouter();\n\nclass MyApp extends StatefulWidget {\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: appRouter.config(),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Route for Nested Navigation in Dart\nDESCRIPTION: This code demonstrates two ways to define an initial route for nested navigation: by setting an empty path `''` for a child route or by using a `RedirectRoute`. This sets the default route when the parent route is navigated to.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_4\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    AutoRoute(path: '', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\nLANGUAGE: dart\nCODE:\n```\nAutoRoute(\n  path: '/dashboard',\n  page: DashboardRoute.page,\n  children: [\n    RedirectRoute(path: '', redirectTo: 'users'),\n    AutoRoute(path: 'users', page: UsersRoute.page),\n    AutoRoute(path: 'posts', page: PostsRoute.page),\n  ],\n)\n```\n\n----------------------------------------\n\nTITLE: Running the code generator in watch mode\nDESCRIPTION: Runs the AutoRoute code generator in watch mode using the build_runner. The watch flag ensures that the generator monitors the file system for changes and rebuilds the generated code automatically whenever a relevant file is modified.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route/README.md#_snippet_5\n\nLANGUAGE: Terminal\nCODE:\n```\ndart run build_runner watch\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Shell Routes in Dart\nDESCRIPTION: This snippet demonstrates how to create empty shell routes using the `EmptyShellRoute` class in the auto_route library. It allows defining routes without an associated widget, useful for creating nested navigation structures.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/auto_route_generator/CHANGELOG.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\nfinal BooksTab = EmptyShellRoute('BooksTab');\ncontext.push(BooksTab());\n```\n\n----------------------------------------\n\nTITLE: Custom Route with Custom Route Builder Dart\nDESCRIPTION: Demonstrates how to use the custom route builder.  It passes a reference of our custom function to our CustomRoute.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_39\n\nLANGUAGE: dart\nCODE:\n```\nCustomRoute(page: CustomPage, customRouteBuilder: myCustomRouteBuilder)\n```\n\n----------------------------------------\n\nTITLE: Extending RootStackRouter in AutoRoute (Before v9)\nDESCRIPTION: This snippet shows how to define an AppRouter by extending the generated class `$AppRouter` before v9 of the AutoRoute library. This approach is deprecated in v9.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_0\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig()\nclass AppRouter extends $AppRouter {\n\n  @override\n  List<AutoRoute> get routes => [\n    /// routes go here\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Observer Usage with Nested Routers in Dart\nDESCRIPTION: This code snippet demonstrates an incorrect approach for using an observer with nested routers.  It uses a single observer instance, which will not work correctly if nested routers inherit observers. The navigatorObservers builder should return new instances of the observer.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_29\n\nLANGUAGE: dart\nCODE:\n```\nfinal _observer = MyObserver();          \n   return MaterialApp.router(          \n      routerDelegate: AutoRouterDelegate(          \n        _appRouter,          \n        // this should always return new instances          \n        navigatorObservers: () => [_observer],          \n      ),          \n      routeInformationParser: _appRouter.defaultRouteParser(),          \n    );          \n```\n\n----------------------------------------\n\nTITLE: AutoRouterConfig Module Usage (Before v9)\nDESCRIPTION: This snippet demonstrates the old approach to module configuration. This is deprecated in v9.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/migrations/migrating_to_v9.md#_snippet_6\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig.module()\nclass MyPackageModule extends $MyPackageModule {}\n```\n\nLANGUAGE: dart\nCODE:\n```\n@AutoRouterConfig(modules: [MyPackageModule])\nclass AppRouter extends $AppRouter {}\n```\n\n----------------------------------------\n\nTITLE: Custom Route Transition with Custom Builder Dart\nDESCRIPTION: Shows how to define a custom transition builder function for a custom route.  The function takes a BuildContext, two Animation objects, and a child Widget. It then returns a transition widget, in this case a ScaleTransition.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v6_README.md#_snippet_35\n\nLANGUAGE: dart\nCODE:\n```\nWidget zoomInTransition(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child) {\n // you get an animation object and a widget\n // make your own transition\n    return ScaleTransition(scale: animation, child: child);\n  }\n```\n\n----------------------------------------\n\nTITLE: Optimizing Generation Time with Globs in build.yaml\nDESCRIPTION: This YAML snippet shows how to optimize generation time by specifying files to process using globs in the build.yaml file.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_54\n\nLANGUAGE: yaml\nCODE:\n```\ntargets:\n  $default:\n    builders:\n      auto_route_generator:auto_route_generator:\n        generate_for:\n          - lib/ui/**.dart\n```\n\n----------------------------------------\n\nTITLE: Incorrect navigatorObservers configuration in Dart\nDESCRIPTION: This snippet demonstrates an incorrect way to configure navigatorObservers when nested routers are involved. Using a single observer instance for multiple routers can lead to unexpected behavior. This should be avoided.\nSOURCE: https://github.com/milad-akarie/auto_route_library/blob/master/old/pre_v9_README.md#_snippet_41\n\nLANGUAGE: dart\nCODE:\n```\nfinal _observer = MyObserver();\nreturn MaterialApp.router(\n  routerConfig: _appRouter.config(\n    // this should always return new instances\n    navigatorObservers: () => [_observer],\n  ),\n);\n```"
  }
]