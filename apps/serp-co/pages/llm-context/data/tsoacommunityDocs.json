[
  {
    "owner": "tsoa-community",
    "repo": "docs",
    "content": "TITLE: Configuring tsoa with tsoa.json\nDESCRIPTION: This snippet shows a sample configuration for tsoa, which defines the project's entry point, excess property handling, controller paths, and specification generation settings. The `entryFile` specifies the main application file, `controllerPathGlobs` tells tsoa where to find the controllers, and `spec` defines the output directory and OpenAPI version. The `routes` section specifies the directory for generated routes.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// tsoa.json\n{\n  \"entryFile\": \"src/app.ts\",\n  \"noImplicitAdditionalProperties\": \"throw-on-extras\",\n  \"controllerPathGlobs\": [\"src/**/*Controller.ts\"],\n  \"spec\": {\n    \"outputDirectory\": \"build\",\n    \"specVersion\": 3\n  },\n  \"routes\": {\n    \"routesDir\": \"build\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Users Controller with tsoa\nDESCRIPTION: This snippet defines a `UsersController` class, which uses tsoa decorators to define API endpoints.  It includes `@Get` and `@Post` endpoints for retrieving and creating users. The `@Path`, `@Query`, `@Body`, and `@SuccessResponse` decorators are used to handle parameters, query parameters, and custom response messages. This controller uses the `UsersService` to interact with the user data.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// src/users/usersController.ts\nimport {\n  Body,\n  Controller,\n  Get,\n  Path,\n  Post,\n  Query,\n  Route,\n  SuccessResponse,\n} from \"tsoa\";\nimport { User } from \"./user\";\nimport { UsersService, UserCreationParams } from \"./usersService\";\n\n@Route(\"users\")\nexport class UsersController extends Controller {\n  @Get(\"{userId}\")\n  public async getUser(\n    @Path() userId: number,\n    @Query() name?: string\n  ): Promise<User> {\n    return new UsersService().get(userId, name);\n  }\n\n  @SuccessResponse(\"201\", \"Created\") // Custom success response\n  @Post()\n  public async createUser(\n    @Body() requestBody: UserCreationParams\n  ): Promise<void> {\n    this.setStatus(201); // set return status 201\n    new UsersService().create(requestBody);\n    return;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tsoa Project with npm\nDESCRIPTION: This snippet demonstrates the basic commands for initializing a new tsoa project using npm. It involves creating a project directory, initializing git and a package.json file using Yarn, adding dependencies for tsoa, express, and TypeScript, and initializing the tsconfig.json file for TypeScript compilation. pnpm specific handling for runtime is included.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Create a new folder for our project\nmkdir tsoa-project\ncd tsoa-project\n\n# Create a package.json and initialize git\ngit init\nyarn init -y\n\n# Add our dependencies\nyarn add tsoa express\nyarn add -D typescript @types/node @types/express\n\n# Initialize tsconfig.json\nyarn run tsc --init\n```\n\n----------------------------------------\n\nTITLE: Implementing Express Authentication Middleware for TSOA - TypeScript\nDESCRIPTION: This function, 'expressAuthentication', validates incoming requests using either 'api_key' passed in the query string or JWT tokens in body, query, or headers. It uses the 'jsonwebtoken' and 'express' packages, resolves with user information upon success, and rejects otherwise. The scopes are checked on JWT tokens to ensure proper authorization, and the function returns a Promise as required by TSOA middleware standards.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/authentication.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as express from \"express\";\nimport * as jwt from \"jsonwebtoken\";\n\nexport function expressAuthentication(\n  request: express.Request,\n  securityName: string,\n  scopes?: string[]\n): Promise<any> {\n  if (securityName === \"api_key\") {\n    let token;\n    if (request.query && request.query.access_token) {\n      token = request.query.access_token;\n    }\n\n    if (token === \"abc123456\") {\n      return Promise.resolve({\n        id: 1,\n        name: \"Ironman\",\n      });\n    } else {\n      return Promise.reject({});\n    }\n  }\n\n  if (securityName === \"jwt\") {\n    const token =\n      request.body.token ||\n      request.query.token ||\n      request.headers[\"x-access-token\"];\n\n    return new Promise((resolve, reject) => {\n      if (!token) {\n        reject(new Error(\"No token provided\"));\n      }\n      jwt.verify(token, \"[secret]\", function (err: any, decoded: any) {\n        if (err) {\n          reject(err);\n        } else {\n          // Check if JWT contains all required scopes\n          for (let scope of scopes) {\n            if (!decoded.scopes.includes(scope)) {\n              reject(new Error(\"JWT does not contain required scope.\"));\n            }\n          }\n          resolve(decoded);\n        }\n      });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a User Service Class\nDESCRIPTION: This snippet defines a `UsersService` class, which encapsulates the business logic related to user operations. It includes methods for retrieving a user (`get`) and creating a user (`create`). The `get` method returns a sample user object. The `create` method generates a random ID and creates a user.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { User } from \"./user\";\n\n// A post request should not contain an id.\nexport type UserCreationParams = Pick<User, \"email\" | \"name\" | \"phoneNumbers\">;\n\nexport class UsersService {\n  public get(id: number, name?: string): User {\n    return {\n      id,\n      email: \"jane@doe.com\",\n      name: name ?? \"Jane Doe\",\n      status: \"Happy\",\n      phoneNumbers: [],\n    };\n  }\n\n  public create(userCreationParams: UserCreationParams): User {\n    return {\n      id: Math.floor(Math.random() * 10000), // Random\n      status: \"Happy\",\n      ...userCreationParams,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenAPI Security Definitions and Middleware Path - JavaScript\nDESCRIPTION: This JSON snippet establishes the OpenAPI security definitions used for authentication in a TSOA project. It supports both API key and OAuth2 mechanisms, specifying their parameters, flows, and scopes. The 'routes' key configures the location of the authentication middleware module ('./authentication.ts'). Dependencies are OpenAPI-compatible tooling, and this should be added to your TSOA or Swagger configuration.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/authentication.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  \"spec\": {\n    \"securityDefinitions\": {\n        \"api_key\": {\n            \"type\": \"apiKey\",\n            \"name\": \"access_token\",\n            \"in\": \"query\"\n        },\n        \"tsoa_auth\": {\n            \"type\": \"oauth2\",\n            \"authorizationUrl\": \"http://swagger.io/api/oauth/dialog\",\n            \"flow\": \"implicit\",\n            \"scopes\": {\n                \"write:pets\": \"modify things\",\n                \"read:pets\": \"read things\"\n            }\n        }\n    },\n    ...\n  },\n  \"routes\": {\n    \"authenticationModule\": \"./authentication.ts\",\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Middleware Function in TypeScript\nDESCRIPTION: Defines an asynchronous custom middleware function that intercepts HTTP requests, performs operations, and calls next() to pass control, typically used with Express, Koa, or Hapi frameworks.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-middlewares.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync function customMiddleware(req: Req, res: ExpRes, next: NextFunction) {\n    // Perform any necessary operations or modifications\n    next();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Class-Validator Middleware (TypeScript)\nDESCRIPTION: Provides the source code for a reusable Express middleware function (`validateBody`) that performs request body validation using `class-transformer` and `class-validator`. It transforms the request body into an instance of the target class, validates it synchronously, formats validation errors into the TSOA `ValidateError` structure, and passes the error to the next middleware or continues the request chain on success.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-validation.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { ClassConstructor, plainToInstance } from 'class-transformer';\nimport { validateSync } from 'class-validator';\nimport { NextFunction, Request, Response } from 'express';\nimport { ValidateError } from 'tsoa';\n\nexport function validateBody<T extends object>(targetClass: ClassConstructor<T>) {\n   return async (req: Request, _res: Response, next: NextFunction) => {\n      const instance = plainToInstance(targetClass, req.body);\n      const errors = validateSync(instance, {\n         forbidUnknownValues: true,\n         validationError: {\n            target: false\n         }\n      });\n      const fieldsErrors: { [name: string]: { message: string; value: string } } = {};\n\n      if (errors.length > 0) {\n         errors.forEach(error => {\n            if (error.constraints) {\n               fieldsErrors[error.property] = {\n                  message: Object.values(error.constraints).join(', '),\n                  value: error.value\n               };\n            }\n            if (error.children) {\n               error.children.forEach(errorNested => {\n                  if (errorNested.constraints) {\n                     fieldsErrors[errorNested.property] = {\n                        message: Object.values(errorNested.constraints!).join(', '),\n                        value: errorNested.value\n                     };\n                  }\n               })\n            }\n         });\n         next(new ValidateError(fieldsErrors, 'Validation failed'));\n         return;\n      }\n      next();\n   };\n}\n```\n\n----------------------------------------\n\nTITLE: Securing Controller Endpoints with TSOA Security Decorators - TypeScript\nDESCRIPTION: This controller class demonstrates how to secure API endpoints using TSOA decorators such as '@Security' and '@Response'. The 'userInfo' endpoints require authentication via either 'api_key' or JWT with 'admin' scope and utilize request injection for user data. Dependencies include TSOA and its decorators, and the expected input is an authenticated request; outputs are user data or strings as specified.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/authentication.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Get, Route, Security, Response } from \"tsoa\";\n\n@Route(\"secure\")\nexport class SecureController {\n  @Response<ErrorResponseModel>(\"Unexpected error\")\n  @Security(\"api_key\")\n  @Get(\"UserInfo\")\n  public async userInfo(@Request() request: any): Promise<UserResponseModel> {\n    return Promise.resolve(request.user);\n  }\n\n  @Security(\"jwt\", [\"admin\"])\n  @Get(\"EditUser\")\n  public async userInfo(@Request() request: any): Promise<string> {\n    // Do something here\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an IoC Container Module Using a DI Container or Factory Function (TypeScript)\nDESCRIPTION: This example demonstrates how to create and export an IoC container module compatible with tsoa by either directly exporting an instantiated container or exporting a factory function that creates and configures a new container per request. The code imports container types and a DI package, either assigns a container instance to 'iocContainer' or assigns a function that binds the current request to a new container, and exports 'iocContainer' according to tsoa conventions. This pattern enables flexible integration with any DI framework while conforming to tsoa's expectations.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// src/ioc.ts\nimport { IocContainer, IocContainerFactory } from \"@tsoa/runtime\";\nimport { Container } from \"di-package\";\n\n// Assign a container to `iocContainer`.\nconst iocContainer = new Container();\n\n// Or assign a function with to `iocContainer`.\nconst iocContainer: IocContainerFactory = function (\n  request: Request\n): IocContainer {\n  const container = new Container();\n  container.bind(request);\n  return container;\n};\n\n// export according to convention\nexport { iocContainer };\n```\n\n----------------------------------------\n\nTITLE: Using Custom Validation in TSOA Controller (TypeScript)\nDESCRIPTION: Illustrates how to integrate the custom `validateBody` middleware and the validation class (`RequestClass`) into a TSOA controller method. It shows the necessary imports, controller/route/method decorators, and the application of the validation middleware using the `@Middlewares` decorator.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-validation.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n    Controller,\n    Middlewares,\n    Post,\n    Route,\n    SuccessResponse,\n    Body\n} from 'tsoa';\nimport { provide } from 'inversify-binding-decorators';\nimport {validateBody} from \"../middleware/ValidationMiddleware\";\n\n@provide(PostController)\n@Route('/post')\nexport class PostController extends Controller {\n\n    @SuccessResponse(200, 'Post created')\n    @Post()\n    @Middlewares([jwt, validateBody(RequestClass)])\n    public async create(\n        @Body() request: RequestClass\n    ): Promise<void> {\n        console.log(`validated request: ${request}`);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying OR Security Requirements in tsoa\nDESCRIPTION: Demonstrates how to use the `@Security` decorator multiple times on a method to specify that only *one* of the listed security schemes is required for access (logical OR). The decorator accepts the scheme name and an optional array of scopes.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@Security('tsoa_auth', ['write:pets', 'read:pets'])\n@Security('api_key')\n@Get('OauthOrAPIkey')\npublic async GetWithOrSecurity(@Request() request: express.Request): Promise<any> {\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IoC Container Interface and Factory Signature in TypeScript\nDESCRIPTION: This snippet defines the IoC container interface and factory function type required by tsoa. The 'IocContainer' interface specifies a generic 'get' method for retrieving controller instances identified by their prototype. The 'IocContainerFactory' type defines a function that accepts a framework-specific request object and returns an 'IocContainer'. Implementing these contracts enables tsoa to interact with IoC containers regardless of the underlying DI framework or request context.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface IocContainer {\n  get<T>(controller: { prototype: T }): T;\n}\n\ntype IocContainerFactory = (request: unknown) => IocContainer;\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads via Decorators (TSOA, Express)\nDESCRIPTION: Shows how to use tsoa's `@UploadedFiles` and `@UploadedFile` decorators within an Express controller method to automatically parse multipart form data and access uploaded files. It also demonstrates using `@FormField` for other form fields. This method uses multer's default disk storage.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Post, Route, FormField, UploadedFiles, UploadedFile } from \"tsoa\";\n\n@Route(\"files\")\nexport class FilesController {\n  @Post(\"uploadFile\")\n  public async uploadFile(\n      @FormField() title: string,\n      @FormField() description: string,\n      @UploadedFiles() files: Express.Multer.File[],\n      @UploadedFile() file: Express.Multer.File,\n  ): Promise<void> {\n    console.log(files);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating OAS and Routes via tsoa CLI - Bash\nDESCRIPTION: This snippet demonstrates usage of the tsoa CLI commands to generate OpenAPI Specification (OAS) files and API routes. It requires the tsoa CLI to be installed (typically via npm install -g tsoa or in project devDependencies). The tsoa spec command generates the OAS file, while tsoa routes generates TypeScript Express-compatible routes based on your controllers and configuration. Expected input is a configured tsoa.json file in the working directory. The output is the generated specification or route code in your project directories. No code changes are made outside of generation; these commands are intended for scripts or manual runs.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/generating.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# generate OAS\ntsoa spec\n\n# generate routes\ntsoa routes\n```\n\n----------------------------------------\n\nTITLE: Injecting Services into Controllers Using TSyringe with tsoa (TypeScript)\nDESCRIPTION: This snippet shows how to define a tsoa controller that uses TSyringe for dependency injection. The controller class is annotated with '@injectable()' and '@Route' decorators. The injected service (FooService) is received via constructor injection and passed to the base Controller with 'super()' called. This pattern enables seamless integration of TSyringe DI within tsoa controllers.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// src/controllers/FooController.ts\n\nimport { Controller, Route } from 'tsoa';\nimport { injectable } from 'tsyringe';\nimport { FooService } from '../services/FooService';\n// ...\n\n@injectable()\n@Route('foo')\nexport class FooController extends Controller {\n  constructor(private fooService: FooService) {\n    super();\n  }\n  \n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up InversifyJS IoC Container for tsoa Controllers (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure an InversifyJS container to work with tsoa controllers. It creates a new Inversify container, decorates the tsoa Controller base class with @injectable to allow injection, and loads provider modules from inversify-binding-decorators. This setup allows controllers decorated with @provideSingleton or similar decorators to be resolved by the container. The container is exported as 'iocContainer' for use by tsoa via the 'iocModule' setting.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// src/ioc.ts\nimport { Container, decorate, injectable } from \"inversify\";\nimport { buildProviderModule } from \"inversify-binding-decorators\";\nimport { Controller } from \"tsoa\";\n\n// Create a new container tsoa can use\nconst iocContainer = new Container();\n\ndecorate(injectable(), Controller); // Makes tsoa's Controller injectable\n\n// make inversify aware of inversify-binding-decorators\niocContainer.load(buildProviderModule());\n\n// export according to convention\nexport { iocContainer };\n```\n\n----------------------------------------\n\nTITLE: Generating Routes File with tsoa\nDESCRIPTION: This snippet describes the command to generate the `routes.ts` file using the tsoa command-line tool. This command processes the controller definitions and configuration to generate the necessary routing code which is then used to initialize the Express server.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nmkdir -p build # Create the build directory if it doesn't exist\nyarn run tsoa routes\n```\n\n----------------------------------------\n\nTITLE: Creating the Express Server\nDESCRIPTION: This snippet creates the `server.ts` file that starts the Express server. It imports the express app from `app.ts`, gets the port number from an environment variable (or defaults to 3000), and listens for incoming requests. It logs a message to the console when the server is running.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// src/server.ts\nimport { app } from \"./app\";\n\nconst port = process.env.PORT || 3000;\n\napp.listen(port, () =>\n  console.log(`Example app listening at http://localhost:${port}`)\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring controllerPathGlobs in tsoa.json (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to configure the `controllerPathGlobs` option in the `tsoa.json` file.  This allows tsoa to automatically discover controllers based on glob patterns.  Multiple glob patterns can be provided to cover different directories and naming conventions.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/routes.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"entryFile\": \"...\",\n  \"routes\": {\n    \"routesDir\": \"...\",\n    \"middleware\": \"...\",\n    \"controllerPathGlobs\": [\n      \"./dir-with-controllers/*\",\n      \"./recursive-dir/**/*\",\n      \"./custom-filerecursive-dir/**/*.controller.ts\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Validation Class (class-validator)\nDESCRIPTION: Defines a simple TypeScript class (`RequestClass`) annotated with `class-validator` decorators to specify the structure and validation rules for a request body. This class serves as the schema that the custom validation middleware validates the incoming request body against.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-validation.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nclass RequestClass {\n   @Length(1, 2000)\n   text: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Express 404 Not Found Handler (TypeScript)\nDESCRIPTION: Shows how to include a simple Express middleware after the tsoa `RegisterRoutes` call to handle requests that don't match any defined routes. This middleware sends a 404 status code with a basic JSON message (`{ message: \"Not Found\" }`), providing a user-friendly response for missing endpoints.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/error-handling.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// app.ts\nimport express, {\n  Response as ExResponse,\n  Request as ExRequest,\n  NextFunction,\n} from \"express\";\n\n// ...\n\nRegisterRoutes(app)\n\napp.use(function notFoundHandler(_req, res: ExResponse) {\n  res.status(404).send({\n    message: \"Not Found\",\n  });\n});\n\n\napp.use(function errorHandler(\n// ...\n```\n\n----------------------------------------\n\nTITLE: Manually registering routes and controllers (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to manually register routes and controllers by importing them into the app entry file.  The `RegisterRoutes` function (auto-generated by tsoa) is called to connect the controllers to the express app, and the controllers need to be imported so that tsoa can \"crawl\" the file and discover them.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/routes.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as methodOverride from \"method-override\";\nimport * as express from \"express\";\nimport * as bodyParser from \"body-parser\";\nimport { RegisterRoutes } from \"./routes\";\n\n// ########################################################################\n// controllers need to be referenced in order to get crawled by the generator\nimport \"./users/usersController\";\n// ########################################################################\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(methodOverride());\n\nRegisterRoutes(app);\n\napp.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Applying AND Security Requirements in tsoa\nDESCRIPTION: Shows how to use the `@Security` decorator with an object configuration to specify that *all* listed security schemes are required for access (logical AND). The object keys are the security scheme names, and values are arrays of required scopes.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@Security({\n  tsoa_auth: ['write:pets', 'read:pets'],\n  api_key: [],\n})\n@Get('OauthAndAPIkey')\npublic async GetWithAndSecurity(@Request() request: express.Request): Promise<any> {\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Services into Controllers Using InversifyJS and provideSingleton (TypeScript)\nDESCRIPTION: This example demonstrates applying the custom 'provideSingleton' decorator in a tsoa controller and service to enable DI through InversifyJS. The 'UsersController' is decorated with '@provideSingleton' and includes a constructor-injected 'FooService' identified via '@inject'. The 'FooService' class is similarly decorated to register it as a singleton. This pattern ensures controller instances are resolved through the Inversify container with dependencies automatically injected.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// src/users/usersController.ts\nimport { Route } from 'tsoa';\nimport { provideSingleton, inject } from '../inversify/ioc';\n\n@Route('foo')\n@provideSingleton(FooController)\nexport class UsersController {\n  constructor(\n    @inject(FooService) private fooService: FooService\n  ) { }\n  ...\n}\n\n@provideSingleton(FooService) // or @provide(FooService)\nexport class FooService {\n  constructor(\n    // maybe even more dependencies to be injected...\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a TSyringe IoC Container Module for tsoa (TypeScript)\nDESCRIPTION: This snippet illustrates how to create an IoC container module using TSyringe compatible with tsoa. It imports the tsoa 'IocContainer' interface and TSyringe's 'container', then exports an object with a 'get' method that resolves requested controllers using TSyringe's container. This module is targeted in the 'iocModule' config of tsoa to enable controller resolution with TSyringe's DI features.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// src/lib/tsyringeTsoaIocContainer.ts\n// Target this file in your tsoa.json's \"iocModule\" property\n\nimport { IocContainer } from '@tsoa/runtime';\nimport { container } from 'tsyringe';\n\nexport const iocContainer: IocContainer = {\n  get: <T>(controller: { prototype: T }): T => {\n    return container.resolve<T>(controller as never);\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Koa Request Object in tsoa\nDESCRIPTION: Demonstrates using the `@Request` decorator on a method parameter to inject the underlying Koa request object (which contains the context `ctx`). This allows direct access to request/context details. Note that this parameter is omitted in the generated OpenAPI spec.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// src/users/usersController.ts\n\nimport * as koa from \"koa\";\nimport { Get, Route, Request } from \"tsoa\";\nimport { User, UserCreationRequest } from \"../models/user\";\n\n@Route(\"users\")\nexport class UsersController {\n  @Get(\"{userId}\")\n  public async getUser(\n    userrId: number,\n    @Request() request: koa.Request\n  ): Promise<User> {\n    const ctx = request.ctx;\n    // TODO: implement some code that uses the request as well\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating the Express App\nDESCRIPTION: This snippet creates the `app.ts` file to set up the Express application. It imports the necessary modules (express, body-parser), and then defines the express app. The code also uses the `urlencoded` and `json` middleware to parse JSON and URL-encoded request bodies and includes a call to `RegisterRoutes` from the build directory to register the routes generated by tsoa.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// src/app.ts\nimport express, {json, urlencoded} from \"express\";\nimport { RegisterRoutes } from \"../build/routes\";\n\nexport const app = express();\n\n// Use body parser to read sent json payloads\napp.use(\n  urlencoded({\n    extended: true,\n  })\n);\napp.use(json());\n\nRegisterRoutes(app);\n```\n\n----------------------------------------\n\nTITLE: Defining Data Model Constraints with tsoa JSDoc Annotations in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the use of JSDoc annotations for applying JSON Schema keyword-based validation constraints to a data transfer object (DTO) named CustomerDto. Dependencies include tsoa and TypeScript, with reliance on tsoa's integration for OpenAPI and validation handling. Key parameters annotated here include\\nage (must be integer, minimum value of 18),\\ntags (array requiring at least 1 item),\\nand email (string matching an email regex); these constraints will be enforced in generated OpenAPI specs and runtime validation. Expected input is an object matching CustomerDto; outputs may include validation failures if requirements are not met. To use, add similar annotations to DTOs in tsoa-enabled TypeScript projects. Limitations: The actual error handling and validation occur at runtime via tsoa, and not all JSON Schema features are directly translatable in TypeScript.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/annotations.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface CustomerDto {\n    /**\n     * @isInt we would kindly ask you to provide a number here\n     * @minimum 18 minimum age is 18\n     */\n    age: number;\n    /**\n     * @minItems 1 at least 1 category is required\n     */\n    tags: string[];\n    /**\n     * @pattern ^(.+)@(.+)$ please provide correct email\n     */\n    email: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Singleton Service Using TSyringe Decorators (TypeScript)\nDESCRIPTION: This snippet demonstrates how to declare a singleton service using the '@singleton()' decorator from TSyringe. Marking a service class with '@singleton' ensures the TSyringe container will create a single instance that is reused when injected elsewhere. This service can then be injected into controllers or other components requiring it.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// src/services/FooService.ts\n\nimport { singleton } from 'tsyringe';\n// ...\n\n@singleton()\nexport class FooService {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using typescript-ioc to Inject Dependencies in tsoa Controllers (TypeScript)\nDESCRIPTION: This snippet provides example controller and service classes using the typescript-ioc framework. The 'FooController' class is annotated with '@Route' and has an injected 'FooService' marked with '@Inject'. The service itself is decorated with '@Singleton' to ensure a single shared instance. This pattern allows controllers to receive dependencies defined with typescript-ioc annotations, enabling DI container integration within tsoa projects.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Route } from 'tsoa';\nimport { Inject, Singleton } from \"typescript-ioc\";\n\n@Route('foo')\nexport class FooController {\n\n  @Inject\n  private fooService: FooService\n  ...\n}\n\n@Singleton\nexport class FooService {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Global Express Error Handler for tsoa Validation Errors (TypeScript)\nDESCRIPTION: Demonstrates adding an Express middleware after `RegisterRoutes` to catch `tsoa.ValidateError` instances, logging the error fields and returning a structured 422 JSON response. It also provides a generic 500 response for other standard `Error` types, preventing stack traces from being sent to the client. This handler should be placed after the `RegisterRoutes(app)` call in your main application file (`app.ts`).\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/error-handling.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport express, {\n  Response as ExResponse,\n  Request as ExRequest,\n  NextFunction,\n} from \"express\";\nimport { ValidateError } from \"tsoa\";\n// ...\n\napp.use(function errorHandler(\n  err: unknown,\n  req: ExRequest,\n  res: ExResponse,\n  next: NextFunction\n): ExResponse | void {\n  if (err instanceof ValidateError) {\n    console.warn(`Caught Validation Error for ${req.path}:`, err.fields);\n    return res.status(422).json({\n      message: \"Validation Failed\",\n      details: err?.fields,\n    });\n  }\n  if (err instanceof Error) {\n    return res.status(500).json({\n      message: \"Internal Server Error\",\n    });\n  }\n\n  next();\n});\n```\n\n----------------------------------------\n\nTITLE: Hiding Parameters from OpenAPI Spec in tsoa\nDESCRIPTION: Illustrates using the `@Hidden` decorator on method parameters decorated with `@Query`. This excludes the parameter from the generated OpenAPI Specification. The parameter must either be optional (`?`) or have a default value.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n  @Get()\n  public async find(\n    @Query() normalParam: string,\n    @Query() @Hidden() defaultSecret = true,\n    @Query() @Hidden() optionalSecret?: string\n  ): Promise<any> {\n\n  }\n```\n\n----------------------------------------\n\nTITLE: Improved TypeScript Configuration\nDESCRIPTION: This snippet presents an example of a more complete `tsconfig.json` file for a tsoa project. It includes several advanced options to enforce strict type-checking, module resolution settings, and experimental features for decorators. The configuration enhances code quality, provides better error detection, and improves maintainability.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_3\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n  \"compilerOptions\": {\n    /* Basic Options */\n    \"incremental\": true,\n    \"target\": \"es6\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"build\",\n\n    /* Strict Type-Checking Options */\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"strictPropertyInitialization\": true,\n    \"noImplicitThis\": true,\n    \"alwaysStrict\": true,\n\n    /* Additional Checks */\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n\n    /* Module Resolution Options */\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \".\",\n    \"esModuleInterop\": true,\n\n    /* Experimental Options */\n    \"experimentalDecorators\": true,\n    // emitDecoratorMetadata is not needed by tsoa (unless you are using Custom Middlewares)\n\n    /* Advanced Options */\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Model Descriptions in tsoa TypeScript\nDESCRIPTION: This snippet shows how to provide a description for a model (interface) in TypeScript using JSDoc. The description gives context about the model and is used to generate documentation.  The structure allows easy understanding of what the model represents within the API.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * User objects allow you to associate actions performed\n * in the system with the user that performed them.\n * The User object contains common information across\n * every user in the system regardless of status and role.\n */\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  status?: \"Happy\" | \"Sad\";\n  phoneNumbers: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Build Scripts\nDESCRIPTION: This snippet suggests adding scripts to the `package.json` to simplify build and start processes. The `build` script combines `tsoa spec-and-routes` and `tsc` to generate specifications, routes, and TypeScript code. The `start` script uses node to run the server.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\n\"main\": \"build/src/server.js\",\n\"scripts\": {\n  \"build\": \"tsoa spec-and-routes && tsc\",\n  \"start\": \"node build/src/server.js\"\n},\n```\n\n----------------------------------------\n\nTITLE: Generating OAS and Routes Programmatically Using tsoa - TypeScript\nDESCRIPTION: This snippet illustrates how to generate OpenAPI Specification files and API routes using tsoa programmatically within a TypeScript script. It requires installation of the tsoa library as a dependency. The script imports generateRoutes and generateSpec, configures options such as basePath, entryFile, output paths, and controller glob patterns, and invokes generation asynchronously. The input consists of configuration objects for specOptions and routeOptions. Output is written to the specified directories. Note that internal tsoa methods could change in minor/patch releases; TypeScript support helps with API updates.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/generating.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  generateRoutes,\n  generateSpec,\n  ExtendedRoutesConfig,\n  ExtendedSpecConfig,\n} from \"tsoa\";\n\n(async () => {\n  const specOptions: ExtendedSpecConfig = {\n    basePath: \"/api\",\n    entryFile: \"./api/server.ts\",\n    specVersion: 3,\n    outputDirectory: \"./api/dist\",\n    controllerPathGlobs: [\"./routeControllers/**/*Controller.ts\"],\n  };\n\n  const routeOptions: ExtendedRoutesConfig = {\n    basePath: \"/api\",\n    entryFile: \"./api/server.ts\",\n    routesDir: \"./api\",\n  };\n\n  await generateSpec(specOptions);\n\n  await generateRoutes(routeOptions);\n})();\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Type Alias with Description in tsoa\nDESCRIPTION: This snippet demonstrates the creation of a reusable type alias with a description, utilizing JSDoc annotations,  This allows for standardization of types and reusability across the API, enhancing documentation quality by providing comprehensive information.  The `@pattern` and `@format` JSDoc tags help with the specification of the type.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Stringified UUIDv4.\n * See [RFC 4112](https://tools.ietf.org/html/rfc4122)\n * @pattern [0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}\n * @format uuid\n */\nexport type UUID = string;\n```\n\n----------------------------------------\n\nTITLE: Adding Property Descriptions in tsoa TypeScript\nDESCRIPTION: This snippet illustrates adding descriptions to individual properties within a model using JSDoc comments. It focuses on documenting the `email` property of the `User` interface. This practice improves documentation.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * User objects allow you to associate actions performed in the system with the user that performed them.\n * The User object contains common information across every user in the system regardless of status and role.\n */\nexport interface User {\n  id: UUID;\n\n  /**\n   * The email the user used to register his account\n   */\n  email: string;\n\n  name: string;\n  status?: \"Happy\" | \"Sad\";\n  phoneNumbers: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running the Server\nDESCRIPTION: This snippet presents the commands to compile the TypeScript code and start the Express server. First, it runs `tsc` with the  `--outDir build` option to transpile the code to the build directory. Then, it executes the compiled `server.js` file with Node.js.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nyarn run tsc --outDir build --experimentalDecorators\nnode build/src/server.js\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Path Mapping (tsconfig.json)\nDESCRIPTION: This code snippet demonstrates a common configuration for TypeScript path mapping using the `tsconfig.json` file.  It defines a `baseUrl` and a `paths` property. The `baseUrl` specifies the base directory from which module resolution begins, and `paths` maps module names (like \"jquery\") to specific file locations. Dependencies include a TypeScript project using module resolution. The output allows TypeScript compiler to find modules such as jquery.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/path-mapping.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // This must be specified if \"paths\" is.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // This mapping is relative to \"baseUrl\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenAPI Spec for File Upload (tsoa.json)\nDESCRIPTION: Provides a sample `tsoa.json` configuration snippet showing how to use `specMerging` to add `multipart/form-data` content type and define file parameters (`type: \"file\"`, `in: \"formData\"`) for a specific endpoint in the generated OpenAPI specification. This ensures API documentation accurately reflects the file upload capability.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"spec\": {\n    ...\n    \"specMerging\": \"recursive\",\n    \"spec\": {\n      \"paths\": {\n        \"/files/uploadFile\": {\n          \"post\": {\n            \"consumes\": [\n              \"multipart/form-data\"\n            ],\n            \"parameters\": [\n              {\n                \"in\": \"formData\",\n                \"name\": \"randomFileIsHere\",\n                \"required\": true,\n                \"type\": \"file\"\n              }\n            ]\n          }\n        }\n      }\n    }\n  },\n  \"routes\": {\n     ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting tsoa Error Responses with @Response Decorator (TypeScript)\nDESCRIPTION: Illustrates how to use the `@Response` decorator in a tsoa controller method to explicitly document potential error responses in the generated OpenAPI specification. This example documents a 422 \"Validation Failed\" response with a specific JSON structure (`ValidateErrorJSON`), improving the clarity of the API documentation for clients.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/error-handling.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Body, Controller, Post, Route, Response, SuccessResponse } from \"tsoa\";\nimport { User } from \"./user\";\nimport { UsersService, UserCreationParams } from \"./usersService\";\n\ninterface ValidateErrorJSON {\n  message: \"Validation failed\";\n  details: { [name: string]: unknown };\n}\n\n@Route(\"users\")\nexport class UsersController extends Controller {\n  // more code here\n\n  @Response<ValidateErrorJSON>(422, \"Validation Failed\")\n  @SuccessResponse(\"201\", \"Created\") // Custom success response\n  @Post()\n  public async createUser(\n    @Body() requestBody: UserCreationParams\n  ): Promise<void> {\n    this.setStatus(201); // set return status 201\n    new UsersService().create(requestBody);\n    return;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring tsoa IoC Module in JSON Configuration (JavaScript)\nDESCRIPTION: This snippet shows how to configure the 'iocModule' property in the tsoa JSON configuration file (e.g., tsoa.json) to point to a module exporting an IoC container. The 'iocModule' tells tsoa where to find and call the IoC container for controller creation. This is a necessary setup step for enabling custom dependency injection when generating routes. The snippet assumes standard JSON syntax and usage within tsoa project configuration.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"entryFile\": \"...\",\n  \"spec\": {\n    ...\n  },\n  \"routes\": {\n    \"routesDir\": \"...\",\n    \"middleware\": \"...\",\n    \"iocModule\": \"src/ioc\",\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @Res Decorator for Type-Checked Alternate Responses (TypeScript)\nDESCRIPTION: Explains how to inject a `TsoaResponse` function into a controller method using the `@Res` decorator (available in tsoa >= 3.1). This function allows the method to return alternative responses (like a 404) programmatically and type-safely without throwing errors, providing more control over response generation and documentation.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/error-handling.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Route, Controller, Get, Query, Res, TsoaResponse } from 'tsoa'\n\n@Route('/greeting')\nexport class GreetingsController extends Controller {\n  /**\n   * @param notFoundResponse The responder function for a not found response\n   */\n  @Get('/')\n  public async greet(@Query() name?: string, @Res() notFoundResponse: TsoaResponse<404, { reason: string }>): Promise<string> {\n    if (!name) {\n      return notFoundResponse(404, { reason: \"We don't know you yet. Please provide a name\" });\n    }\n\n    return `Hello, ${name}`;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating Parameters using @Deprecated in tsoa\nDESCRIPTION: Illustrates how to mark individual method parameters as deprecated using the `@Deprecated` decorator, applicable with `@Query` and `@Queries` decorators. This adds the `deprecated: true` field to the parameter object in the generated OpenAPI specification (OpenAPI 3+ only).\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@Get(\"v2\")\npublic async findV2(\n  @Query() text: string,\n  @Deprecated() @Query() dontUse?: string\n): Promise<any> {\n\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface QueryParams {\n  text: string;\n  sort?: string;\n  page?: number;\n}\n\n@Get(\"v2\")\npublic async findV2(\n  @Queries() queryParams: QueryParams\n): Promise<any> {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating an Operation in tsoa\nDESCRIPTION: Shows how to mark an entire operation (method) as deprecated using the `@Deprecated` decorator. This adds the `deprecated: true` field to the operation object in the generated OpenAPI specification.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@Get()\n@Deprecated()\npublic async find(): Promise<any> {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing Swagger UI Endpoint (TypeScript Express)\nDESCRIPTION: Adds an Express middleware handler for the `/docs` route. It uses `swaggerUi.serve` to handle static assets and `swaggerUi.generateHTML` to render the Swagger UI page, dynamically importing the `swagger.json` file on each request during development. This provides a live view of the API documentation.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\napp.use(\"/docs\", swaggerUi.serve, async (_req: ExRequest, res: ExResponse) => {\n  return res.send(\n    swaggerUi.generateHTML(await import(\"../build/swagger.json\"))\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Multer Integration (TSOA, Express)\nDESCRIPTION: Demonstrates manual integration of multer within an Express tsoa controller using the `@Request` decorator to access the raw request object. It shows how to configure multer (e.g., `single(\"file\")`) and process the upload within a controller method for custom handling like storage location or file filtering.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Post, Request, Route } from \"tsoa\";\nimport express from \"express\";\nimport multer from \"multer\";\n\n@Route(\"files\")\nexport class FilesController {\n  @Post(\"uploadFile\")\n  public async uploadFile(@Request() request: express.Request): Promise<any> {\n    await this.handleFile(request);\n    // file will be in request.randomFileIsHere, it is a buffer\n    return {};\n  }\n\n  private handleFile(request: express.Request): Promise<any> {\n    const multerSingle = multer().single(\"file\");\n    return new Promise((resolve, reject) => {\n      multerSingle(request, undefined, async (error) => {\n        if (error) {\n          reject(error);\n        }\n        resolve();\n      });\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deprecating Schemas using @Deprecated and JSDoc in tsoa\nDESCRIPTION: Shows how to mark properties within classes, interfaces, and type aliases as deprecated. Use the `@Deprecated` decorator for class properties and constructor parameters, and the `@deprecated` JSDoc annotation for interface and type alias properties (OpenAPI 3+ only).\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nclass CreateUserRequest {\n  name: string;\n  @Deprecated() firstName?: string;\n\n  constructor(\n    public emailAddress: string,\n    @Deprecated() public icqHandle?: string\n  ) {}\n}\n\ninterface CreateUserResponse {\n  /** @deprecated */ durationMs?: number;\n  details: UserDetails;\n}\n\ntype UserDetails = {\n  name: string;\n  /** @deprecated */ firstName?: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Resolving Duplicate Model Names in tsoa with @tsoaModel (TypeScript)\nDESCRIPTION: Demonstrates how to designate a specific interface as the canonical version for tsoa when dealing with duplicate model names across different files or modules. This is achieved by adding the `@tsoaModel` JSDoc tag to the desired interface definition, resolving potential conflicts during specification generation and ensuring the correct model is referenced.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/faq.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @tsoaModel\n */\nexport interface MyModel {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Multer Integration (TSOA, Koa)\nDESCRIPTION: Illustrates accessing the Koa request context using the `@Request` decorator to manually process file uploads with multer within a tsoa controller. It demonstrates defining multer middleware and applying it to the request context (`request.ctx`) for custom file handling.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Post, Request, Route } from \"tsoa\";\nimport { Request as KoaRequest } from \"koa\";\nimport multer from \"multer\";\n\n@Route(\"files\")\nexport class FilesController {\n  @Post(\"uploadFile\")\n  public async uploadFile(@Request() request: KoaRequest): Promise<any> {\n    const multer = multer().single(\"file\");\n    await multer(request.ctx, async () => null);\n    const multerSingle = multer().single(\"randomFileIsHere\");\n    // file will be in request.randomFileIsHere, it is a buffer\n    return {};\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tag Descriptions in tsoa.json\nDESCRIPTION: Shows how to define detailed tag information, including descriptions and external documentation URLs, within the `tsoa.json` configuration file under the `spec.tags` property. This information is included in the generated OpenAPI specification.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"spec\": {\n    \"tags\":  [\n      {\n        \"name\": \"User\",\n        \"description\": \"Operations about users\",\n        \"externalDocs\": {\n          \"description\": \"Find out more about users\",\n          \"url\": \"http://swagger.io\"\n        }\n      }\n    ],\n    ...\n  },\n  \"routes\": {\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling File Uploads via Decorators (TSOA, Koa)\nDESCRIPTION: Illustrates using tsoa's `@UploadedFiles` and `@UploadedFile` decorators in a Koa controller method. It parses multipart form data, providing access to uploaded files using Koa's `File` type and other form fields via `@FormField`. This method uses multer's default disk storage.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Post, Route, FormField, UploadedFiles, UploadedFile } from \"tsoa\";\nimport { Request as KoaRequest } from \"koa\";\n\n@Route(\"files\")\nexport class FilesController {\n  @Post(\"uploadFile\")\n  public async uploadFile(\n      @FormField() title: string,\n      @FormField() description: string,\n      @UploadedFiles() files: File[],\n      @UploadedFile() file: File,\n  ): Promise<void> {\n    console.log(files);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Creation Parameter Type\nDESCRIPTION: This snippet defines a type `UserCreationParams` which is a subset of the `User` interface.  It uses the `Pick` utility type to select only the `email`, `name`, and `phoneNumbers` properties. This is often used for POST requests, ensuring that the client does not set the ID when creating a user.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type UserCreationParams = Pick<User, \"email\" | \"name\" | \"phoneNumbers\">;\n```\n\n----------------------------------------\n\nTITLE: Defining Development and Build Scripts (package.json JSON)\nDESCRIPTION: Adds `scripts` to the `package.json` file to automate development and build tasks. The `dev` script uses `concurrently` to run `nodemon` and `tsoa spec-and-routes` in parallel. The `build` script runs `tsoa` and then `tsc`, and the `start` script executes the compiled server.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"scripts\": {\n  \"dev\": \"concurrently \\\"nodemon\\\" \\\"nodemon -x tsoa spec-and-routes\\\"\",\n  \"build\": \"tsoa spec-and-routes && tsc\",\n  \"start\": \"node build/src/server.js\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger UI Express Types (Bash)\nDESCRIPTION: Installs the `@types/swagger-ui-express` package as a development dependency. This package provides TypeScript definitions for the `swagger-ui-express` library, enabling type checking and improved developer experience when using TypeScript.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D @types/swagger-ui-express\n```\n\n----------------------------------------\n\nTITLE: Installing Live Reloading Dependencies (Bash)\nDESCRIPTION: Installs `nodemon` for monitoring file changes and restarting the application, `ts-node` for executing TypeScript files directly, and `concurrently` for running multiple commands simultaneously. These packages are required for setting up an efficient development workflow with live reloading.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -D nodemon ts-node concurrently\n```\n\n----------------------------------------\n\nTITLE: Overriding Express Array Parsing Limit for Large Arrays (JavaScript)\nDESCRIPTION: Shows how to configure an Express application to handle arrays with more than 20 elements in query parameters, which is the default limit of the 'qs' parser used internally by Express. This involves setting a custom query parser function using `app.set('query parser', ...)` that utilizes the `qs` library with an increased `arrayLimit` (set to `Infinity` in this example). This setup is crucial when validating large arrays with tsoa and requires the 'qs', 'express', and potentially 'body-parser' packages. It must be placed before other middleware like `bodyParser` and the tsoa `Router`.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/faq.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst app = express();\n\napp.set('query parser', function(str) {\n  return qs.parse(str, { arrayLimit: Infinity });\n});\n\napp.use(bodyParser.json())\napp.use(Router())\n```\n\n----------------------------------------\n\nTITLE: Configuring Nodemon for Live Reloading (JSON)\nDESCRIPTION: Defines a `nodemon.json` configuration file. The `exec` field specifies the command to run the server using `ts-node`, `watch` lists directories to monitor for changes, and `ext` specifies file extensions that trigger a restart. This setup ensures the server restarts automatically when source files are modified.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"exec\": \"ts-node src/server.ts\",\n  \"watch\": [\"src\"],\n  \"ext\": \"ts\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Multer Dependencies (Bash)\nDESCRIPTION: Installs the `multer` package for handling `multipart/form-data` and its TypeScript type definitions (`@types/multer`) as a development dependency. These packages are required for implementing file upload functionality with tsoa.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/file-upload.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add multer\nyarn add -D @types/multer\n```\n\n----------------------------------------\n\nTITLE: Enabling JSON Module Imports (tsconfig.json JSON)\nDESCRIPTION: Modifies the `tsconfig.json` file to enable `resolveJsonModule` under `compilerOptions`. This allows TypeScript to import `.json` files directly as modules, which is necessary for the dynamic import of the `swagger.json` file in the Express route handler.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"resolveJsonModule\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Parameter Descriptions in tsoa TypeScript\nDESCRIPTION: This snippet illustrates how to add descriptions to parameters of an API endpoint using JSDoc's `@param` tag. The comments clarify the purpose of each parameter, improving the understanding of the API.  This improves the documentation of the API.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Retrieves the details of an existing user.\n * Supply the unique user ID from either and receive corresponding user details.\n * @param userId The user's identifier\n * @param name Provide a username to display\n */\n@Get(\"{userId}\")\npublic async getUser(\n  @Path() userId: number,\n  @Query() name?: string\n): Promise<User> {\n  return new UsersService().get(userId, name);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TSOA Path Mapping (tsoa.json)\nDESCRIPTION: This snippet shows how to configure tsoa generators to use the path mappings defined in `compilerOptions` within the `tsoa.json` file. The `compilerOptions` property, including `baseUrl` and `paths`, is provided within the `routes` configuration. This ensures that tsoa's internal generators can correctly resolve module paths when generating routes and documentation.  Dependencies: a tsoa project and a correctly configured TypeScript project with path mappings defined (like the previous example).\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/path-mapping.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  \"spec\": {\n    ...\n  },\n  \"routes\": {\n    ...\n  },\n   \"compilerOptions\": {\n        \"baseUrl\": \"./path/to/base/url\",\n        \"paths\": {\n            \"exampleLib\": \"./path/to/example/lib\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Endpoint Descriptions in tsoa TypeScript\nDESCRIPTION: This snippet demonstrates adding a description to an API endpoint using JSDoc comments.  The JSDoc comments are placed above the method definition and will be used to generate documentation for the endpoint.  This annotation is part of enhancing the API documentation and developer experience when using tsoa.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Retrieves the details of an existing user.\n * Supply the unique user ID from either and receive corresponding user details.\n */\n@Get(\"{userId}\")\npublic async getUser(\n  @Path() userId: number,\n  @Query() name?: string\n): Promise<User> {\n  return new UsersService().get(userId, name);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Express Request Object in tsoa\nDESCRIPTION: Demonstrates using the `@Request` decorator on a method parameter to inject the underlying Express request object. This allows direct access to request details not otherwise exposed by tsoa's parameter decorators. Note that this parameter is omitted in the generated OpenAPI spec.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// src/users/usersController.ts\n\nimport * as express from \"express\";\nimport { Get, Route, Request } from \"tsoa\";\nimport { User, UserCreationRequest } from \"../models/user\";\n\n@Route(\"users\")\nexport class UsersController {\n  @Get(\"{userId}\")\n  public async getUser(\n    userId: number,\n    @Request() request: express.Request\n  ): Promise<User> {\n    // TODO: implement some code that uses the request as well\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Validation Middleware (TSOA)\nDESCRIPTION: Demonstrates how to apply multiple middlewares, including a custom `validateBody` middleware, to a TSOA endpoint using the `@Middlewares` decorator. It shows how to pass an array of middleware functions to the decorator.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-validation.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n@Middlewares([jwt, validateBody(RequestClass)])\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Middleware with @Middlewares Decorator in a Controller Endpoint\nDESCRIPTION: Shows how to decorate a GET endpoint with @Middlewares and a custom middleware function, demonstrating middleware execution before the endpoint handler in a TypeScript web framework context.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/custom-middlewares.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Get(\"/custom-middleware\")\n@Middlewares(customMiddleware)\nasync exampleGetEndpoint(@Request() req: Req): Promise<void> {\n    console.log(`Custom middleware`);\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Default/Catch-all Responses with @Response Decorator (TypeScript)\nDESCRIPTION: Shows how to use the `@Response` decorator with the 'default' status code alias in tsoa. This is used to document responses for any status code not explicitly listed, typically used for unexpected or generic error types in the OpenAPI specification, ensuring the documentation covers all potential outcomes.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/error-handling.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n@Response<ErrorResponse>('default', 'Unexpected error')\n@Get('Response')\npublic async getResponse(): Promise<TestModel> {\n  return new ModelService().getModel();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tags for Controllers and Methods in tsoa\nDESCRIPTION: Illustrates using the `@Tags` decorator on both a controller class and individual methods. This decorator adds tags to the corresponding entries in the generated OpenAPI specification, helping categorize and group related endpoints.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Get, Route, Response, Tags } from \"tsoa\";\n\n@Route(\"users\")\n@Tags(\"User\")\nexport class UsersController {\n  @Response<ErrorResponseModel>(\"Unexpected error\")\n  @Get(\"UserInfo\")\n  @Tags(\"Info\", \"Get\")\n  public async userInfo(@Request() request: any): Promise<UserResponseModel> {\n    return Promise.resolve(request.user);\n  }\n\n  @Get(\"EditUser\")\n  @Tags(\"Edit\")\n  public async userInfo(@Request() request: any): Promise<string> {\n    // Do something here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Media Types with @Produces in tsoa\nDESCRIPTION: Shows how to use the `@Produces` decorator on a method to define a specific media type for its response in the generated OpenAPI specification. It is crucial to also manually set the `Content-Type` header in the method implementation using `this.setHeader` to match the specified type.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@Route('MediaTypeTest')\n@Produces('application/vnd.mycompany.myapp+json')\nexport class MediaTypeTestController extends Controller {\n  @Get('users/{userId}')\n  public async getDefaultProduces(@Path() userId: number): Promise<UserResponseModel> {\n    this.setHeader('Content-Type', 'application/vnd.mycompany.myapp+json');\n    return Promise.resolve({\n      id: userId,\n      name: 'foo',\n    });\n  }\n  @Get('custom/security.txt')\n  @Produces('text/plain')\n  public async getCustomProduces(): Promise<string> {\n    const securityTxt = 'Contact: mailto: security@example.com\\nExpires: 2012-12-12T12:37:00.000Z';\n    this.setHeader('Content-Type', 'text/plain');\n    return securityTxt;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Interface\nDESCRIPTION: This snippet defines a simple `User` interface using TypeScript. The interface specifies the structure for user objects, including properties like `id`, `email`, `name`, `status`, and `phoneNumbers`. This interface serves as a data model for the application and is used in the controller and service.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  status?: \"Happy\" | \"Sad\";\n  phoneNumbers: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Setting OperationId for Endpoint in tsoa\nDESCRIPTION: Demonstrates using the `@OperationId` decorator on a controller method. This sets the unique `operationId` parameter in the OpenAPI specification for the corresponding path operation, which is useful for generating client SDKs.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@Get()\n@OperationId('findDomain')\npublic async find(): Promise<any> {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Using Summary Annotation in tsoa TypeScript\nDESCRIPTION: This demonstrates how to use the `@summary` JSDoc annotation to provide a short summary for an API method. This summary is then used as the summary in the generated OpenAPI documentation, helping to create a concise documentation entry. It improves the readability and user-friendliness of the documentation.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological,\n * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate,\n * loquacious, garrulous, chatty, extended, babbling description.\n * @summary A concise summary.\n */\n@Get('SummaryMethod')\npublic async summaryMethod(): Promise<TestModel> {\n  return new ModelService().getModel();\n}\n```\n\n----------------------------------------\n\nTITLE: Hiding a Method from OpenAPI Spec in tsoa\nDESCRIPTION: Demonstrates using the `@Hidden` decorator on a controller method to exclude that specific operation from being included in the generated OpenAPI Specification document.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n  @Get()\n  @Hidden()\n  public async find(): Promise<any> {\n\n  }\n```\n\n----------------------------------------\n\nTITLE: Hiding a Controller from OpenAPI Spec in tsoa\nDESCRIPTION: Shows how to apply the `@Hidden` decorator to an entire controller class. This excludes all methods (operations) within that controller from appearing in the generated OpenAPI Specification document.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/decorators.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@Hidden()\nexport class HiddenController {\n  @Get()\n  public async find(): Promise<any> {}\n\n  @Post()\n  public async create(): Promise<any> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Usage and Option Reference for tsoa Commands - Bash\nDESCRIPTION: This snippet provides detailed usage help for the tsoa CLI commands spec and routes, including optional parameters such as configuration file path, API host, and base paths. It is useful when customizing where configuration or output should reside or targeting multiple deployments. Parameters such as --configuration (or -c), --host, and --basePath should be specified as strings. No dependencies beyond the tsoa CLI are required, and these commands must be run from the shell or as npm/yarn scripts. Outputs are generated API route files or OAS according to the given configuration.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/generating.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nUsage: tsoa spec [options]\n\nOptions:\n   --configuration, -c  tsoa configuration file; default is tsoa.json in the working directory  [string]\n   --host  API host                                                                             [string]\n   --basePath  Base API path                                                                    [string]\n```\n\nLANGUAGE: bash\nCODE:\n```\nUsage: tsoa routes [options]\n\nOptions:\n  --configuration, -c  tsoa configuration file; default is tsoa.json in the working directory   [string]\n  --basePath  Base API path                                                                     [string]\n```\n\n----------------------------------------\n\nTITLE: Scaffold Hapi and Koa Authentication Middleware for TSOA - TypeScript\nDESCRIPTION: These function stubs, 'hapiAuthentication' and 'koaAuthentication', are placeholders for implementing authentication logic similar to the Express middleware, but adapted to Hapi and Koa server frameworks. Both return a Promise and are typed for their respective libraries ('@hapi/hapi' and 'koa'). Implementations should follow the Express example, with dependencies on the appropriate HTTP framework.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/authentication.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport * as hapi from \"@hapi/hapi\";\nexport function hapiAuthentication(\n  request: hapi.Request,\n  securityName: string,\n  scopes?: string[]\n): Promise<any> {\n  // See above\n}\n\nimport { Request } from \"koa\";\nexport function koaAuthentication(\n  request: Request,\n  securityName: string,\n  scopes?: string[]\n): Promise<any> {\n  // See above\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Type Alias in tsoa TypeScript\nDESCRIPTION: This code shows how to reuse the `UUID` type alias defined previously within a `User` interface. It uses a reference to the `UUID` type to define the `id` property, making the code more readable and maintainable. This illustrates the benefit of defining descriptions on reusable types.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/descriptions.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * User objects allow you to associate actions performed in the system with the user that performed them.\n * The User object contains common information across every user in the system regardless of status and role.\n */\nexport interface User {\n  id: UUID;\n  email: string;\n  name: string;\n  status?: \"Happy\" | \"Sad\";\n  phoneNumbers: string[];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Singleton Provider Wrapper with inversify-binding-decorators (TypeScript)\nDESCRIPTION: This snippet defines a utility function 'provideSingleton' that wraps the 'fluentProvide' API from 'inversify-binding-decorators' to create singleton-scoped bindings easily. It takes a service identifier and returns a decorator configured for singleton scope. This convenience helps manage the lifecycle of DI bindings and is especially useful when injecting services into controllers. The function uses generics to preserve type safety.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// src/util/provideSingleton.ts\nimport { fluentProvide } from \"inversify-binding-decorators\";\nimport { interfaces } from \"inversify\";\n\nexport const provideSingleton = function <T>(\n  identifier: interfaces.ServiceIdentifier<T>\n) {\n  return fluentProvide(identifier).inSingletonScope().done();\n};\n```\n\n----------------------------------------\n\nTITLE: Linking tsoa Controllers by Importing Them for DI Container Setup (TypeScript)\nDESCRIPTION: This snippet shows the pattern of importing controller modules directly to ensure they are included in the application build and linked by the DI container. This is necessary in frameworks like typescript-ioc that rely on runtime metadata and decorators to register classes. Importing the controller files (e.g., './controllers/fooController.ts') ensures proper initialization.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/di.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport \"./controllers/fooController.ts\"\n...\n```\n\n----------------------------------------\n\nTITLE: Installing Swagger UI Express (Bash)\nDESCRIPTION: Installs the `swagger-ui-express` package, which provides middleware to serve Swagger UI from an Express application. This package is essential for displaying the generated API documentation via a web route.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/live-reloading.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add swagger-ui-express\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Route Template in tsoa.json (JSON)\nDESCRIPTION: This configuration snippet from `tsoa.json` shows how to specify a custom Handlebars template file for generating routes. Located within the `routes` configuration object, the `middlewareTemplate` property takes the path to your custom template file, overriding the default template for the specified `middleware` type. Prerequisites include a `tsoa.json` file and the existence of the specified custom template file.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/templates.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"entryFile\": \"...\",\n  \"spec\": {\n    ...\n  },\n  \"routes\": {\n    \"routesDir\": \"...\",\n    \"middleware\": \"express\",\n    \"middlewareTemplate\": \"custom-template.ts\"\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding @tsoa/runtime Dependency with pnpm\nDESCRIPTION: This snippet addresses a specific requirement for projects using pnpm. Due to the way pnpm manages node_modules, it's necessary to explicitly add the @tsoa/runtime dependency for generated routes to function correctly. This is not usually needed for npm or yarn projects.\nSOURCE: https://github.com/tsoa-community/docs/blob/main/docs/getting-started.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Explicitely add @tsoa/runtime with pnpm as it will be needed by generated routes\npnpm add @tsoa/runtime\n```"
  }
]